{"sha": "704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwNGFmMmQ3ZTE0NzRiYTYwYTBiNzBhNWFhNzhlMjk5MDVhYmI0ZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-11T19:50:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-11T19:50:14Z"}, "message": "Auto merge of #52268 - Mark-Simulacrum:rollup, r=Mark-Simulacrum\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #51614 (Correct suggestion for println)\n - #51952 ( hygiene: Decouple transparencies from expansion IDs)\n - #52193 (step_by: leave time of item skip unspecified)\n - #52207 (improve error message shown for unsafe operations)\n - #52223 (Deny bare trait objects in in src/liballoc)\n - #52224 (Deny bare trait objects in in src/libsyntax)\n - #52239 (Remove sync::Once::call_once 'static bound)\n - #52247 (Deny bare trait objects in in src/librustc)\n - #52248 (Deny bare trait objects in in src/librustc_allocator)\n - #52252 (Deny bare trait objects in in src/librustc_codegen_llvm)\n - #52253 (Deny bare trait objects in in src/librustc_data_structures)\n - #52254 (Deny bare trait objects in in src/librustc_metadata)\n - #52261 (Deny bare trait objects in in src/libpanic_unwind)\n - #52265 (Deny bare trait objects in in src/librustc_codegen_utils)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "ecccdd7baa7a2aea62eb9fc8f40ffb877ce71903", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecccdd7baa7a2aea62eb9fc8f40ffb877ce71903"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "html_url": "https://github.com/rust-lang/rust/commit/704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d573fe17786b9c2f5a766498d411d54eee5fa19f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d573fe17786b9c2f5a766498d411d54eee5fa19f", "html_url": "https://github.com/rust-lang/rust/commit/d573fe17786b9c2f5a766498d411d54eee5fa19f"}, {"sha": "a0b288e1b85424bb3a5b1f89fc904d431d904a1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0b288e1b85424bb3a5b1f89fc904d431d904a1c", "html_url": "https://github.com/rust-lang/rust/commit/a0b288e1b85424bb3a5b1f89fc904d431d904a1c"}], "stats": {"total": 1345, "additions": 865, "deletions": 480}, "files": [{"sha": "44f15981137ba2ac5a1ed3f61be13f6ea1d41fd1", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -446,7 +446,7 @@ impl From<Box<str>> for Box<[u8]> {\n     }\n }\n \n-impl Box<Any> {\n+impl Box<dyn Any> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Attempt to downcast the box to a concrete type.\n@@ -468,10 +468,10 @@ impl Box<Any> {\n     ///     print_if_string(Box::new(0i8));\n     /// }\n     /// ```\n-    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any>> {\n+    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<dyn Any>> {\n         if self.is::<T>() {\n             unsafe {\n-                let raw: *mut Any = Box::into_raw(self);\n+                let raw: *mut dyn Any = Box::into_raw(self);\n                 Ok(Box::from_raw(raw as *mut T))\n             }\n         } else {\n@@ -480,7 +480,7 @@ impl Box<Any> {\n     }\n }\n \n-impl Box<Any + Send> {\n+impl Box<dyn Any + Send> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Attempt to downcast the box to a concrete type.\n@@ -502,10 +502,10 @@ impl Box<Any + Send> {\n     ///     print_if_string(Box::new(0i8));\n     /// }\n     /// ```\n-    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<Any + Send>> {\n-        <Box<Any>>::downcast(self).map_err(|s| unsafe {\n+    pub fn downcast<T: Any>(self) -> Result<Box<T>, Box<dyn Any + Send>> {\n+        <Box<dyn Any>>::downcast(self).map_err(|s| unsafe {\n             // reapply the Send marker\n-            Box::from_raw(Box::into_raw(s) as *mut (Any + Send))\n+            Box::from_raw(Box::into_raw(s) as *mut (dyn Any + Send))\n         })\n     }\n }\n@@ -643,7 +643,7 @@ impl<A, F> FnBox<A> for F\n \n #[unstable(feature = \"fnbox\",\n            reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n-impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + 'a> {\n+impl<'a, A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + 'a> {\n     type Output = R;\n \n     extern \"rust-call\" fn call_once(self, args: A) -> R {\n@@ -653,7 +653,7 @@ impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + 'a> {\n \n #[unstable(feature = \"fnbox\",\n            reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n-impl<'a, A, R> FnOnce<A> for Box<FnBox<A, Output = R> + Send + 'a> {\n+impl<'a, A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + Send + 'a> {\n     type Output = R;\n \n     extern \"rust-call\" fn call_once(self, args: A) -> R {"}, {"sha": "55995742a4a7da7bfa1ce5ec4008145190da7842", "filename": "src/liballoc/boxed_test.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -31,8 +31,8 @@ struct Test;\n \n #[test]\n fn any_move() {\n-    let a = Box::new(8) as Box<Any>;\n-    let b = Box::new(Test) as Box<Any>;\n+    let a = Box::new(8) as Box<dyn Any>;\n+    let b = Box::new(Test) as Box<dyn Any>;\n \n     match a.downcast::<i32>() {\n         Ok(a) => {\n@@ -47,26 +47,26 @@ fn any_move() {\n         Err(..) => panic!(),\n     }\n \n-    let a = Box::new(8) as Box<Any>;\n-    let b = Box::new(Test) as Box<Any>;\n+    let a = Box::new(8) as Box<dyn Any>;\n+    let b = Box::new(Test) as Box<dyn Any>;\n \n     assert!(a.downcast::<Box<Test>>().is_err());\n     assert!(b.downcast::<Box<i32>>().is_err());\n }\n \n #[test]\n fn test_show() {\n-    let a = Box::new(8) as Box<Any>;\n-    let b = Box::new(Test) as Box<Any>;\n+    let a = Box::new(8) as Box<dyn Any>;\n+    let b = Box::new(Test) as Box<dyn Any>;\n     let a_str = format!(\"{:?}\", a);\n     let b_str = format!(\"{:?}\", b);\n     assert_eq!(a_str, \"Any\");\n     assert_eq!(b_str, \"Any\");\n \n     static EIGHT: usize = 8;\n     static TEST: Test = Test;\n-    let a = &EIGHT as &Any;\n-    let b = &TEST as &Any;\n+    let a = &EIGHT as &dyn Any;\n+    let b = &TEST as &dyn Any;\n     let s = format!(\"{:?}\", a);\n     assert_eq!(s, \"Any\");\n     let s = format!(\"{:?}\", b);\n@@ -110,12 +110,12 @@ fn raw_trait() {\n         }\n     }\n \n-    let x: Box<Foo> = Box::new(Bar(17));\n+    let x: Box<dyn Foo> = Box::new(Bar(17));\n     let p = Box::into_raw(x);\n     unsafe {\n         assert_eq!(17, (*p).get());\n         (*p).set(19);\n-        let y: Box<Foo> = Box::from_raw(p);\n+        let y: Box<dyn Foo> = Box::from_raw(p);\n         assert_eq!(19, y.get());\n     }\n }"}, {"sha": "63cf01a0facbca245ebc2b393464df9fdf85898b", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -72,6 +72,7 @@\n        test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n #![no_std]\n #![needs_allocator]\n+#![deny(bare_trait_objects)]\n #![deny(missing_debug_implementations)]\n \n #![cfg_attr(test, allow(deprecated))] // rand"}, {"sha": "d76acb28df92b2ae6b43bf7c091f500a0b9154aa", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -618,7 +618,7 @@ impl<T: Clone> Rc<T> {\n     }\n }\n \n-impl Rc<Any> {\n+impl Rc<dyn Any> {\n     #[inline]\n     #[stable(feature = \"rc_downcast\", since = \"1.29.0\")]\n     /// Attempt to downcast the `Rc<Any>` to a concrete type.\n@@ -641,7 +641,7 @@ impl Rc<Any> {\n     ///     print_if_string(Rc::new(0i8));\n     /// }\n     /// ```\n-    pub fn downcast<T: Any>(self) -> Result<Rc<T>, Rc<Any>> {\n+    pub fn downcast<T: Any>(self) -> Result<Rc<T>, Rc<dyn Any>> {\n         if (*self).is::<T>() {\n             let ptr = self.ptr.cast::<RcBox<T>>();\n             forget(self);\n@@ -1554,7 +1554,7 @@ mod tests {\n         assert_eq!(unsafe { &*ptr }, \"foo\");\n         assert_eq!(rc, rc2);\n \n-        let rc: Rc<Display> = Rc::new(123);\n+        let rc: Rc<dyn Display> = Rc::new(123);\n \n         let ptr = Rc::into_raw(rc.clone());\n         let rc2 = unsafe { Rc::from_raw(ptr) };\n@@ -1755,8 +1755,8 @@ mod tests {\n         use std::fmt::Display;\n         use std::string::ToString;\n \n-        let b: Box<Display> = box 123;\n-        let r: Rc<Display> = Rc::from(b);\n+        let b: Box<dyn Display> = box 123;\n+        let r: Rc<dyn Display> = Rc::from(b);\n \n         assert_eq!(r.to_string(), \"123\");\n     }\n@@ -1765,8 +1765,8 @@ mod tests {\n     fn test_from_box_trait_zero_sized() {\n         use std::fmt::Debug;\n \n-        let b: Box<Debug> = box ();\n-        let r: Rc<Debug> = Rc::from(b);\n+        let b: Box<dyn Debug> = box ();\n+        let r: Rc<dyn Debug> = Rc::from(b);\n \n         assert_eq!(format!(\"{:?}\", r), \"()\");\n     }\n@@ -1783,8 +1783,8 @@ mod tests {\n     fn test_downcast() {\n         use std::any::Any;\n \n-        let r1: Rc<Any> = Rc::new(i32::max_value());\n-        let r2: Rc<Any> = Rc::new(\"abc\");\n+        let r1: Rc<dyn Any> = Rc::new(i32::max_value());\n+        let r2: Rc<dyn Any> = Rc::new(\"abc\");\n \n         assert!(r1.clone().downcast::<u32>().is_err());\n "}, {"sha": "5def0237e7e71761c1ceb8752fa2118fb2258452", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -978,18 +978,18 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Arc<T> {\n     }\n }\n \n-impl Arc<Any + Send + Sync> {\n+impl Arc<dyn Any + Send + Sync> {\n     #[inline]\n     #[stable(feature = \"rc_downcast\", since = \"1.29.0\")]\n-    /// Attempt to downcast the `Arc<Any + Send + Sync>` to a concrete type.\n+    /// Attempt to downcast the `Arc<dyn Any + Send + Sync>` to a concrete type.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::any::Any;\n     /// use std::sync::Arc;\n     ///\n-    /// fn print_if_string(value: Arc<Any + Send + Sync>) {\n+    /// fn print_if_string(value: Arc<dyn Any + Send + Sync>) {\n     ///     if let Ok(string) = value.downcast::<String>() {\n     ///         println!(\"String ({}): {}\", string.len(), string);\n     ///     }\n@@ -1574,7 +1574,7 @@ mod tests {\n         assert_eq!(unsafe { &*ptr }, \"foo\");\n         assert_eq!(arc, arc2);\n \n-        let arc: Arc<Display> = Arc::new(123);\n+        let arc: Arc<dyn Display> = Arc::new(123);\n \n         let ptr = Arc::into_raw(arc.clone());\n         let arc2 = unsafe { Arc::from_raw(ptr) };\n@@ -1879,8 +1879,8 @@ mod tests {\n         use std::fmt::Display;\n         use std::string::ToString;\n \n-        let b: Box<Display> = box 123;\n-        let r: Arc<Display> = Arc::from(b);\n+        let b: Box<dyn Display> = box 123;\n+        let r: Arc<dyn Display> = Arc::from(b);\n \n         assert_eq!(r.to_string(), \"123\");\n     }\n@@ -1889,8 +1889,8 @@ mod tests {\n     fn test_from_box_trait_zero_sized() {\n         use std::fmt::Debug;\n \n-        let b: Box<Debug> = box ();\n-        let r: Arc<Debug> = Arc::from(b);\n+        let b: Box<dyn Debug> = box ();\n+        let r: Arc<dyn Debug> = Arc::from(b);\n \n         assert_eq!(format!(\"{:?}\", r), \"()\");\n     }\n@@ -1907,8 +1907,8 @@ mod tests {\n     fn test_downcast() {\n         use std::any::Any;\n \n-        let r1: Arc<Any + Send + Sync> = Arc::new(i32::max_value());\n-        let r2: Arc<Any + Send + Sync> = Arc::new(\"abc\");\n+        let r1: Arc<dyn Any + Send + Sync> = Arc::new(i32::max_value());\n+        let r2: Arc<dyn Any + Send + Sync> = Arc::new(\"abc\");\n \n         assert!(r1.clone().downcast::<u32>().is_err());\n "}, {"sha": "c0681619bf8b584ce9f71997a9e8b3e103a48221", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -271,9 +271,30 @@ pub trait Iterator {\n     /// Creates an iterator starting at the same point, but stepping by\n     /// the given amount at each iteration.\n     ///\n-    /// Note that it will always return the first element of the iterator,\n+    /// Note 1: The first element of the iterator will always be returned,\n     /// regardless of the step given.\n     ///\n+    /// Note 2: The time at which ignored elements are pulled is not fixed.\n+    /// `StepBy` behaves like the sequence `next(), nth(step-1), nth(step-1), \u2026`,\n+    /// but is also free to behave like the sequence\n+    /// `advance_n_and_return_first(step), advance_n_and_return_first(step), \u2026`\n+    /// Which way is used may change for some iterators for performance reasons.\n+    /// The second way will advance the iterator earlier and may consume more items.\n+    ///\n+    /// `advance_n_and_return_first` is the equivalent of:\n+    /// ```\n+    /// fn advance_n_and_return_first<I>(iter: &mut I, total_step: usize) -> Option<I::Item>\n+    /// where\n+    ///     I: Iterator,\n+    /// {\n+    ///     let next = iter.next();\n+    ///     if total_step > 1 {\n+    ///         iter.nth(total_step-2);\n+    ///     }\n+    ///     next\n+    /// }\n+    /// ```\n+    ///\n     /// # Panics\n     ///\n     /// The method will panic if the given step is `0`."}, {"sha": "a24c659689139d6f7b6f3760f109ad0b1b56b647", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -48,8 +48,8 @@ pub const DW_EH_PE_indirect: u8 = 0x80;\n pub struct EHContext<'a> {\n     pub ip: usize, // Current instruction pointer\n     pub func_start: usize, // Address of the current function\n-    pub get_text_start: &'a Fn() -> usize, // Get address of the code section\n-    pub get_data_start: &'a Fn() -> usize, // Get address of the data section\n+    pub get_text_start: &'a dyn Fn() -> usize, // Get address of the code section\n+    pub get_data_start: &'a dyn Fn() -> usize, // Get address of the data section\n }\n \n pub enum EHAction {"}, {"sha": "87efc23abc81d7bec015bfff038a1e2fa2c3f9ed", "filename": "src/libpanic_unwind/emcc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibpanic_unwind%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibpanic_unwind%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Femcc.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -29,20 +29,20 @@ pub fn payload() -> *mut u8 {\n     ptr::null_mut()\n }\n \n-pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {\n+pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     assert!(!ptr.is_null());\n     let ex = ptr::read(ptr as *mut _);\n     __cxa_free_exception(ptr as *mut _);\n     ex\n }\n \n-pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n+pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     let sz = mem::size_of_val(&data);\n     let exception = __cxa_allocate_exception(sz);\n     if exception == ptr::null_mut() {\n         return uw::_URC_FATAL_PHASE1_ERROR as u32;\n     }\n-    let exception = exception as *mut Box<Any + Send>;\n+    let exception = exception as *mut Box<dyn Any + Send>;\n     ptr::write(exception, data);\n     __cxa_throw(exception as *mut _, ptr::null_mut(), ptr::null_mut());\n "}, {"sha": "11ebcf5c01ea79e3ca62052577c394afd3c951c8", "filename": "src/libpanic_unwind/gcc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibpanic_unwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibpanic_unwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fgcc.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -67,10 +67,10 @@ use dwarf::eh::{self, EHContext, EHAction};\n #[repr(C)]\n struct Exception {\n     _uwe: uw::_Unwind_Exception,\n-    cause: Option<Box<Any + Send>>,\n+    cause: Option<Box<dyn Any + Send>>,\n }\n \n-pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n+pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     let exception = Box::new(Exception {\n         _uwe: uw::_Unwind_Exception {\n             exception_class: rust_exception_class(),\n@@ -94,7 +94,7 @@ pub fn payload() -> *mut u8 {\n     ptr::null_mut()\n }\n \n-pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {\n+pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     let my_ep = ptr as *mut Exception;\n     let cause = (*my_ep).cause.take();\n     uw::_Unwind_DeleteException(ptr as *mut _);"}, {"sha": "f8cd29fc0861fe4d7a43b8fe646a6bb2d5322166", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -22,6 +22,7 @@\n //! More documentation about each implementation can be found in the respective\n //! module.\n \n+#![deny(bare_trait_objects)]\n #![no_std]\n #![unstable(feature = \"panic_unwind\", issue = \"32837\")]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -117,6 +118,6 @@ pub unsafe extern \"C\" fn __rust_maybe_catch_panic(f: fn(*mut u8),\n #[no_mangle]\n #[unwind(allowed)]\n pub unsafe extern \"C\" fn __rust_start_panic(payload: usize) -> u32 {\n-    let payload = payload as *mut &mut BoxMeUp;\n+    let payload = payload as *mut &mut dyn BoxMeUp;\n     imp::panic(Box::from_raw((*payload).box_me_up()))\n }"}, {"sha": "8cbc4a623fa052ebf44664614dfeac7f1e036cfd", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -43,7 +43,7 @@\n //!   throwing. Note that throwing an exception into Rust is undefined behavior\n //!   anyway, so this should be fine.\n //! * We've got some data to transmit across the unwinding boundary,\n-//!   specifically a `Box<Any + Send>`. Like with Dwarf exceptions\n+//!   specifically a `Box<dyn Any + Send>`. Like with Dwarf exceptions\n //!   these two pointers are stored as a payload in the exception itself. On\n //!   MSVC, however, there's no need for an extra heap allocation because the\n //!   call stack is preserved while filter functions are being executed. This\n@@ -243,7 +243,7 @@ static mut TYPE_DESCRIPTOR2: _TypeDescriptor = _TypeDescriptor {\n     name: imp::NAME2,\n };\n \n-pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n+pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     use core::intrinsics::atomic_store;\n \n     // _CxxThrowException executes entirely on this stack frame, so there's no\n@@ -297,7 +297,7 @@ pub fn payload() -> [u64; 2] {\n     [0; 2]\n }\n \n-pub unsafe fn cleanup(payload: [u64; 2]) -> Box<Any + Send> {\n+pub unsafe fn cleanup(payload: [u64; 2]) -> Box<dyn Any + Send> {\n     mem::transmute(raw::TraitObject {\n         data: payload[0] as *mut _,\n         vtable: payload[1] as *mut _,"}, {"sha": "0b08e54c6739a0684c41cf9478e87b35027f8e82", "filename": "src/libpanic_unwind/seh64_gnu.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibpanic_unwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh64_gnu.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -37,10 +37,10 @@ const RUST_PANIC: c::DWORD = ETYPE | (1 << 24) | MAGIC;\n \n #[repr(C)]\n struct PanicData {\n-    data: Box<Any + Send>,\n+    data: Box<dyn Any + Send>,\n }\n \n-pub unsafe fn panic(data: Box<Any + Send>) -> u32 {\n+pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     let panic_ctx = Box::new(PanicData { data: data });\n     let params = [Box::into_raw(panic_ctx) as c::ULONG_PTR];\n     c::RaiseException(RUST_PANIC,\n@@ -54,7 +54,7 @@ pub fn payload() -> *mut u8 {\n     ptr::null_mut()\n }\n \n-pub unsafe fn cleanup(ptr: *mut u8) -> Box<Any + Send> {\n+pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     let panic_ctx = Box::from_raw(ptr as *mut PanicData);\n     return panic_ctx.data;\n }"}, {"sha": "7150560b4a13d809d29a0e4d0ab3cc2d3e9ad640", "filename": "src/libpanic_unwind/wasm32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibpanic_unwind%2Fwasm32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibpanic_unwind%2Fwasm32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fwasm32.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -20,10 +20,10 @@ pub fn payload() -> *mut u8 {\n     0 as *mut u8\n }\n \n-pub unsafe fn cleanup(_ptr: *mut u8) -> Box<Any + Send> {\n+pub unsafe fn cleanup(_ptr: *mut u8) -> Box<dyn Any + Send> {\n     intrinsics::abort()\n }\n \n-pub unsafe fn panic(_data: Box<Any + Send>) -> u32 {\n+pub unsafe fn panic(_data: Box<dyn Any + Send>) -> u32 {\n     intrinsics::abort()\n }"}, {"sha": "876cf295acc1ba984c3037f2b630191a097dc3e6", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -1351,7 +1351,7 @@ pub mod __internal {\n     use syntax::parse::token::{self, Token};\n     use syntax::tokenstream;\n     use syntax_pos::{BytePos, Loc, DUMMY_SP};\n-    use syntax_pos::hygiene::{Mark, SyntaxContext, Transparency};\n+    use syntax_pos::hygiene::{SyntaxContext, Transparency};\n \n     use super::{TokenStream, LexError, Span};\n \n@@ -1436,20 +1436,15 @@ pub mod __internal {\n \n             // No way to determine def location for a proc macro right now, so use call location.\n             let location = cx.current_expansion.mark.expn_info().unwrap().call_site;\n-            // Opaque mark was already created by expansion, now create its transparent twin.\n-            // We can't use the call-site span literally here, even if it appears to provide\n-            // correct name resolution, because it has all the `ExpnInfo` wrong, so the edition\n-            // checks, lint macro checks, macro backtraces will all break.\n-            let opaque_mark = cx.current_expansion.mark;\n-            let transparent_mark = Mark::fresh_cloned(opaque_mark);\n-            transparent_mark.set_transparency(Transparency::Transparent);\n-\n-            let to_span = |mark| Span(location.with_ctxt(SyntaxContext::empty().apply_mark(mark)));\n+            let to_span = |transparency| Span(location.with_ctxt(\n+                SyntaxContext::empty().apply_mark_with_transparency(cx.current_expansion.mark,\n+                                                                    transparency))\n+            );\n             p.set(ProcMacroSess {\n                 parse_sess: cx.parse_sess,\n                 data: ProcMacroData {\n-                    def_site: to_span(opaque_mark),\n-                    call_site: to_span(transparent_mark),\n+                    def_site: to_span(Transparency::Opaque),\n+                    call_site: to_span(Transparency::Transparent),\n                 },\n             });\n             f()"}, {"sha": "7a26a239aeffadb777733841e1411434752f789a", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -129,6 +129,16 @@ pub enum Namespace {\n     MacroNS,\n }\n \n+impl Namespace {\n+    pub fn descr(self) -> &'static str {\n+        match self {\n+            TypeNS => \"type\",\n+            ValueNS => \"value\",\n+            MacroNS => \"macro\",\n+        }\n+    }\n+}\n+\n /// Just a helper \u2012 separate structure for each namespace.\n #[derive(Copy, Clone, Default, Debug)]\n pub struct PerNS<T> {"}, {"sha": "7dd7954c8f439f0fea9e6c4349bff201f26aa411", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -82,9 +82,9 @@ pub struct LoweringContext<'a> {\n     // Use to assign ids to hir nodes that do not directly correspond to an ast node\n     sess: &'a Session,\n \n-    cstore: &'a CrateStore,\n+    cstore: &'a dyn CrateStore,\n \n-    resolver: &'a mut Resolver,\n+    resolver: &'a mut dyn Resolver,\n \n     /// The items being lowered are collected here.\n     items: BTreeMap<NodeId, hir::Item>,\n@@ -199,10 +199,10 @@ impl<'a> ImplTraitContext<'a> {\n \n pub fn lower_crate(\n     sess: &Session,\n-    cstore: &CrateStore,\n+    cstore: &dyn CrateStore,\n     dep_graph: &DepGraph,\n     krate: &Crate,\n-    resolver: &mut Resolver,\n+    resolver: &mut dyn Resolver,\n ) -> hir::Crate {\n     // We're constructing the HIR here; we don't care what we will\n     // read, since we haven't even constructed the *input* to"}, {"sha": "49a4a1b78a1a8714edf8d7808b6870e2fe04f19b", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 7, "deletions": 29, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -153,6 +153,7 @@ impl Decodable for DefPathTable {\n /// The definition table containing node definitions.\n /// It holds the DefPathTable for local DefIds/DefPaths and it also stores a\n /// mapping from NodeIds to local DefIds.\n+#[derive(Clone)]\n pub struct Definitions {\n     table: DefPathTable,\n     node_to_def_index: NodeMap<DefIndex>,\n@@ -161,34 +162,12 @@ pub struct Definitions {\n     /// If `Mark` is an ID of some macro expansion,\n     /// then `DefId` is the normal module (`mod`) in which the expanded macro was defined.\n     parent_modules_of_macro_defs: FxHashMap<Mark, DefId>,\n-    /// Item with a given `DefIndex` was defined during opaque macro expansion with ID `Mark`.\n-    /// It can actually be defined during transparent macro expansions inside that opaque expansion,\n-    /// but transparent expansions are ignored here.\n-    opaque_expansions_that_defined: FxHashMap<DefIndex, Mark>,\n+    /// Item with a given `DefIndex` was defined during macro expansion with ID `Mark`.\n+    expansions_that_defined: FxHashMap<DefIndex, Mark>,\n     next_disambiguator: FxHashMap<(DefIndex, DefPathData), u32>,\n     def_index_to_span: FxHashMap<DefIndex, Span>,\n }\n \n-// Unfortunately we have to provide a manual impl of Clone because of the\n-// fixed-sized array field.\n-impl Clone for Definitions {\n-    fn clone(&self) -> Self {\n-        Definitions {\n-            table: self.table.clone(),\n-            node_to_def_index: self.node_to_def_index.clone(),\n-            def_index_to_node: [\n-                self.def_index_to_node[0].clone(),\n-                self.def_index_to_node[1].clone(),\n-            ],\n-            node_to_hir_id: self.node_to_hir_id.clone(),\n-            parent_modules_of_macro_defs: self.parent_modules_of_macro_defs.clone(),\n-            opaque_expansions_that_defined: self.opaque_expansions_that_defined.clone(),\n-            next_disambiguator: self.next_disambiguator.clone(),\n-            def_index_to_span: self.def_index_to_span.clone(),\n-        }\n-    }\n-}\n-\n /// A unique identifier that we can use to lookup a definition\n /// precisely. It combines the index of the definition's parent (if\n /// any) with a `DisambiguatedDefPathData`.\n@@ -409,7 +388,7 @@ impl Definitions {\n             def_index_to_node: [vec![], vec![]],\n             node_to_hir_id: IndexVec::new(),\n             parent_modules_of_macro_defs: FxHashMap(),\n-            opaque_expansions_that_defined: FxHashMap(),\n+            expansions_that_defined: FxHashMap(),\n             next_disambiguator: FxHashMap(),\n             def_index_to_span: FxHashMap(),\n         }\n@@ -584,9 +563,8 @@ impl Definitions {\n             self.node_to_def_index.insert(node_id, index);\n         }\n \n-        let expansion = expansion.modern();\n         if expansion != Mark::root() {\n-            self.opaque_expansions_that_defined.insert(index, expansion);\n+            self.expansions_that_defined.insert(index, expansion);\n         }\n \n         // The span is added if it isn't dummy\n@@ -606,8 +584,8 @@ impl Definitions {\n         self.node_to_hir_id = mapping;\n     }\n \n-    pub fn opaque_expansion_that_defined(&self, index: DefIndex) -> Mark {\n-        self.opaque_expansions_that_defined.get(&index).cloned().unwrap_or(Mark::root())\n+    pub fn expansion_that_defined(&self, index: DefIndex) -> Mark {\n+        self.expansions_that_defined.get(&index).cloned().unwrap_or(Mark::root())\n     }\n \n     pub fn parent_module_of_macro_def(&self, mark: Mark) -> DefId {"}, {"sha": "ed2127cc755fc5f47dbddac5184357e97feda701", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -32,7 +32,7 @@ impl_stable_hash_for!(struct mir::LocalDecl<'tcx> {\n });\n impl_stable_hash_for!(struct mir::UpvarDecl { debug_name, var_hir_id, by_ref, mutability });\n impl_stable_hash_for!(struct mir::BasicBlockData<'tcx> { statements, terminator, is_cleanup });\n-impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, kind });\n+impl_stable_hash_for!(struct mir::UnsafetyViolation { source_info, description, details, kind });\n impl_stable_hash_for!(struct mir::UnsafetyCheckResult { violations, unsafe_blocks });\n \n impl<'a> HashStable<StableHashingContext<'a>>"}, {"sha": "c72952efc61447ef5f5b988bebffc9371f01057b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -36,6 +36,8 @@\n //!\n //! This API is completely unstable and subject to change.\n \n+#![deny(bare_trait_objects)]\n+\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]"}, {"sha": "efc2d9311c1dcbe67ee58d39cc4d14e7e2da43a7", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -316,6 +316,12 @@ declare_lint! {\n     \"checks the object safety of where clauses\"\n }\n \n+declare_lint! {\n+    pub PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n+    Warn,\n+    \"detects proc macro derives using inaccessible names from parent modules\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -372,6 +378,7 @@ impl LintPass for HardwiredLints {\n             DUPLICATE_MACRO_EXPORTS,\n             INTRA_DOC_LINK_RESOLUTION_FAILURE,\n             WHERE_CLAUSES_OBJECT_SAFETY,\n+            PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n         )\n     }\n }\n@@ -384,6 +391,7 @@ pub enum BuiltinLintDiagnostics {\n     BareTraitObject(Span, /* is_global */ bool),\n     AbsPathWithModule(Span),\n     DuplicatedMacroExports(ast::Ident, Span, Span),\n+    ProcMacroDeriveResolutionFallback(Span),\n }\n \n impl BuiltinLintDiagnostics {\n@@ -420,6 +428,10 @@ impl BuiltinLintDiagnostics {\n                 db.span_label(later_span, format!(\"`{}` already exported\", ident));\n                 db.span_note(earlier_span, \"previous macro export is now shadowed\");\n             }\n+            BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(span) => {\n+                db.span_label(span, \"names from parent modules are not \\\n+                                     accessible without an explicit import\");\n+            }\n         }\n     }\n }"}, {"sha": "ed8e1654d5a7d6fb3441d69cb38c33db469a8f2a", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -257,7 +257,7 @@ pub trait CrateStore {\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n-pub type CrateStoreDyn = CrateStore + sync::Sync;\n+pub type CrateStoreDyn = dyn CrateStore + sync::Sync;\n \n // FIXME: find a better place for this?\n pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {"}, {"sha": "f8f8753e214e85af15f9218388712ee4af5a05c9", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -2377,6 +2377,7 @@ pub enum UnsafetyViolationKind {\n pub struct UnsafetyViolation {\n     pub source_info: SourceInfo,\n     pub description: InternedString,\n+    pub details: InternedString,\n     pub kind: UnsafetyViolationKind,\n }\n "}, {"sha": "4a76cc683f6800ecf8715ee725d12006bae4ddbf", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -2724,7 +2724,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: NodeId) -> (Ident, DefId) {\n         ident = ident.modern();\n         let target_expansion = match scope.krate {\n-            LOCAL_CRATE => self.hir.definitions().opaque_expansion_that_defined(scope.index),\n+            LOCAL_CRATE => self.hir.definitions().expansion_that_defined(scope.index),\n             _ => Mark::root(),\n         };\n         let scope = match ident.span.adjust(target_expansion) {"}, {"sha": "ffbbd8a33a1d04fdc748fe13475a0902c5f42a50", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -37,7 +37,7 @@ use {AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n \n pub fn modify(\n     sess: &ParseSess,\n-    resolver: &mut Resolver,\n+    resolver: &mut dyn Resolver,\n     krate: Crate,\n     crate_name: String,\n     handler: &rustc_errors::Handler,\n@@ -56,7 +56,7 @@ struct ExpandAllocatorDirectives<'a> {\n     found: bool,\n     handler: &'a rustc_errors::Handler,\n     sess: &'a ParseSess,\n-    resolver: &'a mut Resolver,\n+    resolver: &'a mut dyn Resolver,\n     crate_name: Option<String>,\n \n     // For now, we disallow `global_allocator` in submodules because hygiene is hard. Keep track of\n@@ -256,7 +256,7 @@ impl<'a> AllocFnFactory<'a> {\n         &self,\n         ty: &AllocatorTy,\n         args: &mut Vec<Arg>,\n-        ident: &mut FnMut() -> Ident,\n+        ident: &mut dyn FnMut() -> Ident,\n     ) -> P<Expr> {\n         match *ty {\n             AllocatorTy::Layout => {"}, {"sha": "1227936ce96fc89a3cdc5352918e8d253b59cb2c", "filename": "src/librustc_allocator/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_allocator%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_allocator%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Flib.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deny(bare_trait_objects)]\n #![feature(rustc_private)]\n \n #[macro_use] extern crate log;"}, {"sha": "9ea6c44502a4b2bd6b4fa4aa110e0d6643595f11", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -48,7 +48,7 @@ enum Addition {\n     },\n     Archive {\n         archive: ArchiveRO,\n-        skip: Box<FnMut(&str) -> bool>,\n+        skip: Box<dyn FnMut(&str) -> bool>,\n     },\n }\n "}, {"sha": "a7f0910a6fcccff6e1fe9eb48b1ea26d213499b9", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -251,7 +251,7 @@ fn filename_for_metadata(sess: &Session, crate_name: &str, outputs: &OutputFilen\n \n pub(crate) fn each_linked_rlib(sess: &Session,\n                                info: &CrateInfo,\n-                               f: &mut FnMut(CrateNum, &Path)) -> Result<(), String> {\n+                               f: &mut dyn FnMut(CrateNum, &Path)) -> Result<(), String> {\n     let crates = info.used_crates_static.iter();\n     let fmts = sess.dependency_formats.borrow();\n     let fmts = fmts.get(&config::CrateTypeExecutable)\n@@ -984,7 +984,7 @@ fn exec_linker(sess: &Session, cmd: &mut Command, out_filename: &Path, tmpdir: &\n     }\n }\n \n-fn link_args(cmd: &mut Linker,\n+fn link_args(cmd: &mut dyn Linker,\n              sess: &Session,\n              crate_type: config::CrateType,\n              tmpdir: &Path,\n@@ -1195,7 +1195,7 @@ fn link_args(cmd: &mut Linker,\n // Also note that the native libraries linked here are only the ones located\n // in the current crate. Upstream crates with native library dependencies\n // may have their native library pulled in above.\n-fn add_local_native_libraries(cmd: &mut Linker,\n+fn add_local_native_libraries(cmd: &mut dyn Linker,\n                               sess: &Session,\n                               codegen_results: &CodegenResults) {\n     sess.target_filesearch(PathKind::All).for_each_lib_search_path(|path, k| {\n@@ -1226,7 +1226,7 @@ fn add_local_native_libraries(cmd: &mut Linker,\n // Rust crates are not considered at all when creating an rlib output. All\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n-fn add_upstream_rust_crates(cmd: &mut Linker,\n+fn add_upstream_rust_crates(cmd: &mut dyn Linker,\n                             sess: &Session,\n                             codegen_results: &CodegenResults,\n                             crate_type: config::CrateType,\n@@ -1350,7 +1350,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     // it's packed in a .rlib, it contains stuff that are not objects that will\n     // make the linker error. So we must remove those bits from the .rlib before\n     // linking it.\n-    fn link_sanitizer_runtime(cmd: &mut Linker,\n+    fn link_sanitizer_runtime(cmd: &mut dyn Linker,\n                               sess: &Session,\n                               codegen_results: &CodegenResults,\n                               tmpdir: &Path,\n@@ -1419,7 +1419,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     // (aka we're making an executable), we can just pass the rlib blindly to\n     // the linker (fast) because it's fine if it's not actually included as\n     // we're at the end of the dependency chain.\n-    fn add_static_crate(cmd: &mut Linker,\n+    fn add_static_crate(cmd: &mut dyn Linker,\n                         sess: &Session,\n                         codegen_results: &CodegenResults,\n                         tmpdir: &Path,\n@@ -1524,7 +1524,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     }\n \n     // Same thing as above, but for dynamic crates instead of static crates.\n-    fn add_dynamic_crate(cmd: &mut Linker, sess: &Session, cratepath: &Path) {\n+    fn add_dynamic_crate(cmd: &mut dyn Linker, sess: &Session, cratepath: &Path) {\n         // If we're performing LTO, then it should have been previously required\n         // that all upstream rust dependencies were available in an rlib format.\n         assert!(!is_full_lto_enabled(sess));\n@@ -1559,7 +1559,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-fn add_upstream_native_libraries(cmd: &mut Linker,\n+fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n                                  sess: &Session,\n                                  codegen_results: &CodegenResults,\n                                  crate_type: config::CrateType) {"}, {"sha": "f5f486893854f8999d9ff6b959e9e58598c2c49b", "filename": "src/librustc_codegen_llvm/back/linker.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flinker.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -44,22 +44,22 @@ impl LinkerInfo {\n \n     pub fn to_linker<'a>(&'a self,\n                          cmd: Command,\n-                         sess: &'a Session) -> Box<Linker+'a> {\n+                         sess: &'a Session) -> Box<dyn Linker+'a> {\n         match sess.linker_flavor() {\n             LinkerFlavor::Lld(LldFlavor::Link) |\n             LinkerFlavor::Msvc => {\n                 Box::new(MsvcLinker {\n                     cmd,\n                     sess,\n                     info: self\n-                }) as Box<Linker>\n+                }) as Box<dyn Linker>\n             }\n             LinkerFlavor::Em =>  {\n                 Box::new(EmLinker {\n                     cmd,\n                     sess,\n                     info: self\n-                }) as Box<Linker>\n+                }) as Box<dyn Linker>\n             }\n             LinkerFlavor::Gcc =>  {\n                 Box::new(GccLinker {\n@@ -68,7 +68,7 @@ impl LinkerInfo {\n                     info: self,\n                     hinted_static: false,\n                     is_ld: false,\n-                }) as Box<Linker>\n+                }) as Box<dyn Linker>\n             }\n \n             LinkerFlavor::Lld(LldFlavor::Ld) |\n@@ -80,14 +80,14 @@ impl LinkerInfo {\n                     info: self,\n                     hinted_static: false,\n                     is_ld: true,\n-                }) as Box<Linker>\n+                }) as Box<dyn Linker>\n             }\n \n             LinkerFlavor::Lld(LldFlavor::Wasm) => {\n                 Box::new(WasmLd {\n                     cmd,\n                     sess,\n-                }) as Box<Linker>\n+                }) as Box<dyn Linker>\n             }\n         }\n     }"}, {"sha": "f46205cb59088741a00d000540a3711079bcf415", "filename": "src/librustc_codegen_llvm/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Frpath.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -22,7 +22,7 @@ pub struct RPathConfig<'a> {\n     pub is_like_osx: bool,\n     pub has_rpath: bool,\n     pub linker_is_gnu: bool,\n-    pub get_install_prefix_lib_path: &'a mut FnMut() -> PathBuf,\n+    pub get_install_prefix_lib_path: &'a mut dyn FnMut() -> PathBuf,\n }\n \n pub fn get_rpath_flags(config: &mut RPathConfig) -> Vec<String> {"}, {"sha": "467782518f6738b7a9dcded8ee495d333530e1e0", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -140,7 +140,7 @@ pub fn create_target_machine(sess: &Session, find_features: bool) -> TargetMachi\n // that `is_pie_binary` is false. When we discover LLVM target features\n // `sess.crate_types` is uninitialized so we cannot access it.\n pub fn target_machine_factory(sess: &Session, find_features: bool)\n-    -> Arc<Fn() -> Result<TargetMachineRef, String> + Send + Sync>\n+    -> Arc<dyn Fn() -> Result<TargetMachineRef, String> + Send + Sync>\n {\n     let reloc_model = get_reloc_model(sess);\n \n@@ -343,7 +343,7 @@ pub struct CodegenContext {\n     regular_module_config: Arc<ModuleConfig>,\n     metadata_module_config: Arc<ModuleConfig>,\n     allocator_module_config: Arc<ModuleConfig>,\n-    pub tm_factory: Arc<Fn() -> Result<TargetMachineRef, String> + Send + Sync>,\n+    pub tm_factory: Arc<dyn Fn() -> Result<TargetMachineRef, String> + Send + Sync>,\n     pub msvc_imps_needed: bool,\n     pub target_pointer_width: String,\n     debuginfo: config::DebugInfoLevel,\n@@ -362,7 +362,7 @@ pub struct CodegenContext {\n     // compiling incrementally\n     pub incr_comp_session_dir: Option<PathBuf>,\n     // Channel back to the main control thread to send messages to\n-    coordinator_send: Sender<Box<Any + Send>>,\n+    coordinator_send: Sender<Box<dyn Any + Send>>,\n     // A reference to the TimeGraph so we can register timings. None means that\n     // measuring is disabled.\n     time_graph: Option<TimeGraph>,\n@@ -884,7 +884,7 @@ pub fn start_async_codegen(tcx: TyCtxt,\n                                time_graph: Option<TimeGraph>,\n                                link: LinkMeta,\n                                metadata: EncodedMetadata,\n-                               coordinator_receive: Receiver<Box<Any + Send>>,\n+                               coordinator_receive: Receiver<Box<dyn Any + Send>>,\n                                total_cgus: usize)\n                                -> OngoingCodegen {\n     let sess = tcx.sess;\n@@ -1412,7 +1412,7 @@ fn start_executing_work(tcx: TyCtxt,\n                         crate_info: &CrateInfo,\n                         shared_emitter: SharedEmitter,\n                         codegen_worker_send: Sender<Message>,\n-                        coordinator_receive: Receiver<Box<Any + Send>>,\n+                        coordinator_receive: Receiver<Box<dyn Any + Send>>,\n                         total_cgus: usize,\n                         jobserver: Client,\n                         time_graph: Option<TimeGraph>,\n@@ -1976,7 +1976,7 @@ fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n         // Set up a destructor which will fire off a message that we're done as\n         // we exit.\n         struct Bomb {\n-            coordinator_send: Sender<Box<Any + Send>>,\n+            coordinator_send: Sender<Box<dyn Any + Send>>,\n             result: Option<WorkItemResult>,\n             worker_id: usize,\n         }\n@@ -2056,7 +2056,7 @@ pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n                             config: &ModuleConfig,\n                             opt_level: llvm::CodeGenOptLevel,\n                             prepare_for_thin_lto: bool,\n-                            f: &mut FnMut(llvm::PassManagerBuilderRef)) {\n+                            f: &mut dyn FnMut(llvm::PassManagerBuilderRef)) {\n     use std::ptr;\n \n     // Create the PassManagerBuilder for LLVM. We configure it with\n@@ -2243,7 +2243,7 @@ pub struct OngoingCodegen {\n     linker_info: LinkerInfo,\n     crate_info: CrateInfo,\n     time_graph: Option<TimeGraph>,\n-    coordinator_send: Sender<Box<Any + Send>>,\n+    coordinator_send: Sender<Box<dyn Any + Send>>,\n     codegen_worker_receive: Receiver<Message>,\n     shared_emitter_main: SharedEmitterMain,\n     future: thread::JoinHandle<Result<CompiledModules, ()>>,"}, {"sha": "ea26e271c9bb3edad6c6221b951f28b6b36c3f26", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -717,7 +717,7 @@ pub fn iter_globals(llmod: llvm::ModuleRef) -> ValueIter {\n }\n \n pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             rx: mpsc::Receiver<Box<Any + Send>>)\n+                             rx: mpsc::Receiver<Box<dyn Any + Send>>)\n                              -> OngoingCodegen {\n \n     check_for_rustc_errors_attr(tcx);"}, {"sha": "7625e4c7e0f29e2ecacc1ad982b1b993f72dc23b", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -916,7 +916,7 @@ fn gen_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n                     name: &str,\n                     inputs: Vec<Ty<'tcx>>,\n                     output: Ty<'tcx>,\n-                    codegen: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n+                    codegen: &mut dyn for<'b> FnMut(Builder<'b, 'tcx>))\n                     -> ValueRef {\n     let rust_fn_ty = cx.tcx.mk_fn_ptr(ty::Binder::bind(cx.tcx.mk_fn_sig(\n         inputs.into_iter(),\n@@ -936,7 +936,7 @@ fn gen_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n //\n // This function is only generated once and is then cached.\n fn get_rust_try_fn<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n-                             codegen: &mut for<'b> FnMut(Builder<'b, 'tcx>))\n+                             codegen: &mut dyn for<'b> FnMut(Builder<'b, 'tcx>))\n                              -> ValueRef {\n     if let Some(llfn) = cx.rust_try_fn.get() {\n         return llfn;"}, {"sha": "8aa7902021f240891e2b8686c43b7e2f0931a136", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -23,6 +23,7 @@\n #![feature(custom_attribute)]\n #![feature(fs_read_write)]\n #![allow(unused_attributes)]\n+#![deny(bare_trait_objects)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(range_contains)]\n@@ -125,7 +126,7 @@ impl !Send for LlvmCodegenBackend {} // Llvm is on a per-thread basis\n impl !Sync for LlvmCodegenBackend {}\n \n impl LlvmCodegenBackend {\n-    pub fn new() -> Box<CodegenBackend> {\n+    pub fn new() -> Box<dyn CodegenBackend> {\n         box LlvmCodegenBackend(())\n     }\n }\n@@ -178,7 +179,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n         target_features(sess)\n     }\n \n-    fn metadata_loader(&self) -> Box<MetadataLoader + Sync> {\n+    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync> {\n         box metadata::LlvmMetadataLoader\n     }\n \n@@ -198,14 +199,14 @@ impl CodegenBackend for LlvmCodegenBackend {\n     fn codegen_crate<'a, 'tcx>(\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        rx: mpsc::Receiver<Box<Any + Send>>\n-    ) -> Box<Any> {\n+        rx: mpsc::Receiver<Box<dyn Any + Send>>\n+    ) -> Box<dyn Any> {\n         box base::codegen_crate(tcx, rx)\n     }\n \n     fn join_codegen_and_link(\n         &self,\n-        ongoing_codegen: Box<Any>,\n+        ongoing_codegen: Box<dyn Any>,\n         sess: &Session,\n         dep_graph: &DepGraph,\n         outputs: &OutputFilenames,\n@@ -247,7 +248,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n \n /// This is the entrypoint for a hot plugged rustc_codegen_llvm\n #[no_mangle]\n-pub fn __rustc_codegen_backend() -> Box<CodegenBackend> {\n+pub fn __rustc_codegen_backend() -> Box<dyn CodegenBackend> {\n     LlvmCodegenBackend::new()\n }\n "}, {"sha": "3f230dd5d451b5545f241a6d8a9d5ce3ce0a69e5", "filename": "src/librustc_codegen_utils/codegen_backend.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fcodegen_backend.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -56,23 +56,23 @@ pub trait CodegenBackend {\n     fn print_version(&self) {}\n     fn diagnostics(&self) -> &[(&'static str, &'static str)] { &[] }\n \n-    fn metadata_loader(&self) -> Box<MetadataLoader + Sync>;\n+    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync>;\n     fn provide(&self, _providers: &mut Providers);\n     fn provide_extern(&self, _providers: &mut Providers);\n     fn codegen_crate<'a, 'tcx>(\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        rx: mpsc::Receiver<Box<Any + Send>>\n-    ) -> Box<Any>;\n+        rx: mpsc::Receiver<Box<dyn Any + Send>>\n+    ) -> Box<dyn Any>;\n \n-    /// This is called on the returned `Box<Any>` from `codegen_backend`\n+    /// This is called on the returned `Box<dyn Any>` from `codegen_backend`\n     ///\n     /// # Panics\n     ///\n-    /// Panics when the passed `Box<Any>` was not returned by `codegen_backend`.\n+    /// Panics when the passed `Box<dyn Any>` was not returned by `codegen_backend`.\n     fn join_codegen_and_link(\n         &self,\n-        ongoing_codegen: Box<Any>,\n+        ongoing_codegen: Box<dyn Any>,\n         sess: &Session,\n         dep_graph: &DepGraph,\n         outputs: &OutputFilenames,\n@@ -105,7 +105,7 @@ pub struct OngoingCodegen {\n }\n \n impl MetadataOnlyCodegenBackend {\n-    pub fn new() -> Box<CodegenBackend> {\n+    pub fn new() -> Box<dyn CodegenBackend> {\n         box MetadataOnlyCodegenBackend(())\n     }\n }\n@@ -125,7 +125,7 @@ impl CodegenBackend for MetadataOnlyCodegenBackend {\n         }\n     }\n \n-    fn metadata_loader(&self) -> Box<MetadataLoader + Sync> {\n+    fn metadata_loader(&self) -> Box<dyn MetadataLoader + Sync> {\n         box NoLlvmMetadataLoader\n     }\n \n@@ -145,8 +145,8 @@ impl CodegenBackend for MetadataOnlyCodegenBackend {\n     fn codegen_crate<'a, 'tcx>(\n         &self,\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        _rx: mpsc::Receiver<Box<Any + Send>>\n-    ) -> Box<Any> {\n+        _rx: mpsc::Receiver<Box<dyn Any + Send>>\n+    ) -> Box<dyn Any> {\n         use rustc_mir::monomorphize::item::MonoItem;\n \n         ::check_for_rustc_errors_attr(tcx);\n@@ -193,13 +193,13 @@ impl CodegenBackend for MetadataOnlyCodegenBackend {\n \n     fn join_codegen_and_link(\n         &self,\n-        ongoing_codegen: Box<Any>,\n+        ongoing_codegen: Box<dyn Any>,\n         sess: &Session,\n         _dep_graph: &DepGraph,\n         outputs: &OutputFilenames,\n     ) -> Result<(), CompileIncomplete> {\n         let ongoing_codegen = ongoing_codegen.downcast::<OngoingCodegen>()\n-            .expect(\"Expected MetadataOnlyCodegenBackend's OngoingCodegen, found Box<Any>\");\n+            .expect(\"Expected MetadataOnlyCodegenBackend's OngoingCodegen, found Box<dyn Any>\");\n         for &crate_type in sess.opts.crate_types.iter() {\n             if crate_type != CrateType::CrateTypeRlib && crate_type != CrateType::CrateTypeDylib {\n                 continue;"}, {"sha": "e9031007a4eedbdce4b6b6d50035c925c16adbc6", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -20,6 +20,7 @@\n #![feature(box_syntax)]\n #![feature(custom_attribute)]\n #![allow(unused_attributes)]\n+#![deny(bare_trait_objects)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n "}, {"sha": "2cca31f70a092ce82fa07146bad432148d121e10", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -16,6 +16,8 @@\n //!\n //! This API is completely unstable and subject to change.\n \n+#![deny(bare_trait_objects)]\n+\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"https://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]"}, {"sha": "02640a71010e2daf5a7d501987a839451be0203f", "filename": "src/librustc_data_structures/owning_ref/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -1046,7 +1046,7 @@ unsafe impl<O, T: ?Sized> Send for OwningRefMut<O, T>\n unsafe impl<O, T: ?Sized> Sync for OwningRefMut<O, T>\n     where O: Sync, for<'a> (&'a mut T): Sync {}\n \n-impl Debug for Erased {\n+impl Debug for dyn Erased {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"<Erased>\",)\n     }\n@@ -1166,35 +1166,35 @@ pub type MutexGuardRefMut<'a, T, U = T> = OwningRefMut<MutexGuard<'a, T>, U>;\n pub type RwLockWriteGuardRefMut<'a, T, U = T> = OwningRef<RwLockWriteGuard<'a, T>, U>;\n \n unsafe impl<'a, T: 'a> IntoErased<'a> for Box<T> {\n-    type Erased = Box<Erased + 'a>;\n+    type Erased = Box<dyn Erased + 'a>;\n     fn into_erased(self) -> Self::Erased {\n         self\n     }\n }\n unsafe impl<'a, T: 'a> IntoErased<'a> for Rc<T> {\n-    type Erased = Rc<Erased + 'a>;\n+    type Erased = Rc<dyn Erased + 'a>;\n     fn into_erased(self) -> Self::Erased {\n         self\n     }\n }\n unsafe impl<'a, T: 'a> IntoErased<'a> for Arc<T> {\n-    type Erased = Arc<Erased + 'a>;\n+    type Erased = Arc<dyn Erased + 'a>;\n     fn into_erased(self) -> Self::Erased {\n         self\n     }\n }\n \n unsafe impl<'a, T: Send + 'a> IntoErasedSend<'a> for Box<T> {\n-    type Erased = Box<Erased + Send + 'a>;\n+    type Erased = Box<dyn Erased + Send + 'a>;\n     fn into_erased_send(self) -> Self::Erased {\n         self\n     }\n }\n \n unsafe impl<'a, T: Send + 'a> IntoErasedSendSync<'a> for Box<T> {\n-    type Erased = Box<Erased + Sync + Send + 'a>;\n+    type Erased = Box<dyn Erased + Sync + Send + 'a>;\n     fn into_erased_send_sync(self) -> Self::Erased {\n-        let result: Box<Erased + Send + 'a> = self;\n+        let result: Box<dyn Erased + Send + 'a> = self;\n         // This is safe since Erased can always implement Sync\n         // Only the destructor is available and it takes &mut self\n         unsafe {\n@@ -1204,21 +1204,21 @@ unsafe impl<'a, T: Send + 'a> IntoErasedSendSync<'a> for Box<T> {\n }\n \n unsafe impl<'a, T: Send + Sync + 'a> IntoErasedSendSync<'a> for Arc<T> {\n-    type Erased = Arc<Erased + Send + Sync + 'a>;\n+    type Erased = Arc<dyn Erased + Send + Sync + 'a>;\n     fn into_erased_send_sync(self) -> Self::Erased {\n         self\n     }\n }\n \n /// Typedef of a owning reference that uses an erased `Box` as the owner.\n-pub type ErasedBoxRef<U> = OwningRef<Box<Erased>, U>;\n+pub type ErasedBoxRef<U> = OwningRef<Box<dyn Erased>, U>;\n /// Typedef of a owning reference that uses an erased `Rc` as the owner.\n-pub type ErasedRcRef<U> = OwningRef<Rc<Erased>, U>;\n+pub type ErasedRcRef<U> = OwningRef<Rc<dyn Erased>, U>;\n /// Typedef of a owning reference that uses an erased `Arc` as the owner.\n-pub type ErasedArcRef<U> = OwningRef<Arc<Erased>, U>;\n+pub type ErasedArcRef<U> = OwningRef<Arc<dyn Erased>, U>;\n \n /// Typedef of a mutable owning reference that uses an erased `Box` as the owner.\n-pub type ErasedBoxRefMut<U> = OwningRefMut<Box<Erased>, U>;\n+pub type ErasedBoxRefMut<U> = OwningRefMut<Box<dyn Erased>, U>;\n \n #[cfg(test)]\n mod tests {\n@@ -1443,8 +1443,8 @@ mod tests {\n             let c: OwningRef<Rc<Vec<u8>>, [u8]> = unsafe {a.map_owner(Rc::new)};\n             let d: OwningRef<Rc<Box<[u8]>>, [u8]> = unsafe {b.map_owner(Rc::new)};\n \n-            let e: OwningRef<Rc<Erased>, [u8]> = c.erase_owner();\n-            let f: OwningRef<Rc<Erased>, [u8]> = d.erase_owner();\n+            let e: OwningRef<Rc<dyn Erased>, [u8]> = c.erase_owner();\n+            let f: OwningRef<Rc<dyn Erased>, [u8]> = d.erase_owner();\n \n             let _g = e.clone();\n             let _h = f.clone();\n@@ -1460,16 +1460,16 @@ mod tests {\n             let c: OwningRef<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n             let d: OwningRef<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n \n-            let _e: OwningRef<Box<Erased>, [u8]> = c.erase_owner();\n-            let _f: OwningRef<Box<Erased>, [u8]> = d.erase_owner();\n+            let _e: OwningRef<Box<dyn Erased>, [u8]> = c.erase_owner();\n+            let _f: OwningRef<Box<dyn Erased>, [u8]> = d.erase_owner();\n         }\n \n         #[test]\n         fn try_map1() {\n             use std::any::Any;\n \n             let x = Box::new(123_i32);\n-            let y: Box<Any> = x;\n+            let y: Box<dyn Any> = x;\n \n             OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok();\n         }\n@@ -1479,7 +1479,7 @@ mod tests {\n             use std::any::Any;\n \n             let x = Box::new(123_i32);\n-            let y: Box<Any> = x;\n+            let y: Box<dyn Any> = x;\n \n             OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err();\n         }\n@@ -1843,8 +1843,8 @@ mod tests {\n             let c: OwningRefMut<Box<Vec<u8>>, [u8]> = unsafe {a.map_owner(Box::new)};\n             let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = unsafe {b.map_owner(Box::new)};\n \n-            let _e: OwningRefMut<Box<Erased>, [u8]> = c.erase_owner();\n-            let _f: OwningRefMut<Box<Erased>, [u8]> = d.erase_owner();\n+            let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n+            let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n         }\n \n         #[test]\n@@ -1857,16 +1857,16 @@ mod tests {\n             let c: OwningRefMut<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n             let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n \n-            let _e: OwningRefMut<Box<Erased>, [u8]> = c.erase_owner();\n-            let _f: OwningRefMut<Box<Erased>, [u8]> = d.erase_owner();\n+            let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n+            let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n         }\n \n         #[test]\n         fn try_map1() {\n             use std::any::Any;\n \n             let x = Box::new(123_i32);\n-            let y: Box<Any> = x;\n+            let y: Box<dyn Any> = x;\n \n             OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_ok();\n         }\n@@ -1876,7 +1876,7 @@ mod tests {\n             use std::any::Any;\n \n             let x = Box::new(123_i32);\n-            let y: Box<Any> = x;\n+            let y: Box<dyn Any> = x;\n \n             OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_err();\n         }\n@@ -1886,7 +1886,7 @@ mod tests {\n             use std::any::Any;\n \n             let x = Box::new(123_i32);\n-            let y: Box<Any> = x;\n+            let y: Box<dyn Any> = x;\n \n             OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok();\n         }\n@@ -1896,7 +1896,7 @@ mod tests {\n             use std::any::Any;\n \n             let x = Box::new(123_i32);\n-            let y: Box<Any> = x;\n+            let y: Box<dyn Any> = x;\n \n             OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err();\n         }"}, {"sha": "d4c6b1c2ced812fc4ddce1fedc8988180ec8665d", "filename": "src/librustc_data_structures/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_data_structures%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_data_structures%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsync.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -88,7 +88,7 @@ cfg_if! {\n             t.into_iter()\n         }\n \n-        pub type MetadataRef = OwningRef<Box<Erased>, [u8]>;\n+        pub type MetadataRef = OwningRef<Box<dyn Erased>, [u8]>;\n \n         pub use std::rc::Rc as Lrc;\n         pub use std::rc::Weak as Weak;\n@@ -268,7 +268,7 @@ cfg_if! {\n             t.into_par_iter()\n         }\n \n-        pub type MetadataRef = OwningRef<Box<Erased + Send + Sync>, [u8]>;\n+        pub type MetadataRef = OwningRef<Box<dyn Erased + Send + Sync>, [u8]>;\n \n         /// This makes locks panic if they are already held.\n         /// It is only useful when you are running in a single thread"}, {"sha": "359b056b5a2d1f5da0fe7e14e6cbeb10e31c14a1", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -293,6 +293,11 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             reference: \"issue #50589 <https://github.com/rust-lang/rust/issues/50589>\",\n             edition: None,\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(PROC_MACRO_DERIVE_RESOLUTION_FALLBACK),\n+            reference: \"issue #50504 <https://github.com/rust-lang/rust/issues/50504>\",\n+            edition: None,\n+        },\n         ]);\n \n     // Register renamed and removed lints"}, {"sha": "1e227b8a1a6596b08aa2170dc3435da77418a8fb", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -536,7 +536,7 @@ impl<'a> CrateLoader<'a> {\n                 Ok(f) => f,\n                 Err(err) => self.sess.span_fatal(span, &err),\n             };\n-            mem::transmute::<*mut u8, fn(&mut Registry)>(sym)\n+            mem::transmute::<*mut u8, fn(&mut dyn Registry)>(sym)\n         };\n \n         struct MyRegistrar {\n@@ -1019,7 +1019,7 @@ impl<'a> CrateLoader<'a> {\n     fn inject_dependency_if(&self,\n                             krate: CrateNum,\n                             what: &str,\n-                            needs_dep: &Fn(&cstore::CrateMetadata) -> bool) {\n+                            needs_dep: &dyn Fn(&cstore::CrateMetadata) -> bool) {\n         // don't perform this validation if the session has errors, as one of\n         // those errors may indicate a circular dependency which could cause\n         // this to stack overflow."}, {"sha": "d93a7f9526e1aed9377d69d89acba136b4d24de8", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -90,11 +90,11 @@ pub struct CStore {\n     metas: RwLock<IndexVec<CrateNum, Option<Lrc<CrateMetadata>>>>,\n     /// Map from NodeId's of local extern crate statements to crate numbers\n     extern_mod_crate_map: Lock<NodeMap<CrateNum>>,\n-    pub metadata_loader: Box<MetadataLoader + Sync>,\n+    pub metadata_loader: Box<dyn MetadataLoader + Sync>,\n }\n \n impl CStore {\n-    pub fn new(metadata_loader: Box<MetadataLoader + Sync>) -> CStore {\n+    pub fn new(metadata_loader: Box<dyn MetadataLoader + Sync>) -> CStore {\n         CStore {\n             // We add an empty entry for LOCAL_CRATE (which maps to zero) in\n             // order to make array indices in `metas` match with the"}, {"sha": "d5078642147681488abb37c11e75d9a027217306", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -413,11 +413,11 @@ pub fn provide<'tcx>(providers: &mut Providers<'tcx>) {\n }\n \n impl CrateStore for cstore::CStore {\n-    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<Any> {\n+    fn crate_data_as_rc_any(&self, krate: CrateNum) -> Lrc<dyn Any> {\n         self.get_crate_data(krate)\n     }\n \n-    fn metadata_loader(&self) -> &MetadataLoader {\n+    fn metadata_loader(&self) -> &dyn MetadataLoader {\n         &*self.metadata_loader\n     }\n "}, {"sha": "b8c643839506637b85f504285dc858e9bbed6086", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -391,7 +391,7 @@ impl<'a, 'tcx> MetadataBlob {\n     }\n \n     pub fn list_crate_metadata(&self,\n-                               out: &mut io::Write) -> io::Result<()> {\n+                               out: &mut dyn io::Write) -> io::Result<()> {\n         write!(out, \"=External Dependencies=\\n\")?;\n         let root = self.get_root();\n         for (i, dep) in root.crate_deps"}, {"sha": "5c9915e94e56d34a15b5a3eee3234cc3d43df5c6", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deny(bare_trait_objects)]\n+\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]"}, {"sha": "b747624338c83c8208e8eef55739019fa583de66", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -273,7 +273,7 @@ pub struct Context<'a> {\n     pub rejected_via_filename: Vec<CrateMismatch>,\n     pub should_match_name: bool,\n     pub is_proc_macro: Option<bool>,\n-    pub metadata_loader: &'a MetadataLoader,\n+    pub metadata_loader: &'a dyn MetadataLoader,\n }\n \n pub struct CratePaths {\n@@ -842,7 +842,7 @@ impl<'a> Context<'a> {\n fn get_metadata_section(target: &Target,\n                         flavor: CrateFlavor,\n                         filename: &Path,\n-                        loader: &MetadataLoader)\n+                        loader: &dyn MetadataLoader)\n                         -> Result<MetadataBlob, String> {\n     let start = Instant::now();\n     let ret = get_metadata_section_imp(target, flavor, filename, loader);\n@@ -855,7 +855,7 @@ fn get_metadata_section(target: &Target,\n fn get_metadata_section_imp(target: &Target,\n                             flavor: CrateFlavor,\n                             filename: &Path,\n-                            loader: &MetadataLoader)\n+                            loader: &dyn MetadataLoader)\n                             -> Result<MetadataBlob, String> {\n     if !filename.exists() {\n         return Err(format!(\"no such file: '{}'\", filename.display()));\n@@ -904,8 +904,8 @@ fn get_metadata_section_imp(target: &Target,\n // A diagnostic function for dumping crate metadata to an output stream\n pub fn list_file_metadata(target: &Target,\n                           path: &Path,\n-                          loader: &MetadataLoader,\n-                          out: &mut io::Write)\n+                          loader: &dyn MetadataLoader,\n+                          out: &mut dyn io::Write)\n                           -> io::Result<()> {\n     let filename = path.file_name().unwrap().to_str().unwrap();\n     let flavor = if filename.ends_with(\".rlib\") {"}, {"sha": "7768e96d036125f007511c52794f4b7eab6791e7", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -85,7 +85,9 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 let func_ty = func.ty(self.mir, self.tcx);\n                 let sig = func_ty.fn_sig(self.tcx);\n                 if let hir::Unsafety::Unsafe = sig.unsafety() {\n-                    self.require_unsafe(\"call to unsafe function\")\n+                    self.require_unsafe(\"call to unsafe function\",\n+                        \"consult the function's documentation for information on how to avoid \\\n+                         undefined behavior\")\n                 }\n             }\n         }\n@@ -112,7 +114,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n \n             StatementKind::InlineAsm { .. } => {\n-                self.require_unsafe(\"use of inline assembly\")\n+                self.require_unsafe(\"use of inline assembly\",\n+                    \"inline assembly is entirely unchecked and can cause undefined behavior\")\n             },\n         }\n         self.super_statement(block, statement, location);\n@@ -151,6 +154,11 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 self.register_violations(&[UnsafetyViolation {\n                     source_info,\n                     description: Symbol::intern(\"borrow of packed field\").as_interned_str(),\n+                    details:\n+                        Symbol::intern(\"fields of packed structs might be misaligned: \\\n+                                        dereferencing a misaligned pointer or even just creating a \\\n+                                        misaligned reference is undefined behavior\")\n+                            .as_interned_str(),\n                     kind: UnsafetyViolationKind::BorrowPacked(lint_root)\n                 }], &[]);\n             }\n@@ -172,7 +180,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n                 match base_ty.sty {\n                     ty::TyRawPtr(..) => {\n-                        self.require_unsafe(\"dereference of raw pointer\")\n+                        self.require_unsafe(\"dereference of raw pointer\",\n+                            \"raw pointers may be NULL, dangling or unaligned; they can violate \\\n+                             aliasing rules and cause data races: all of these are undefined \\\n+                             behavior\")\n                     }\n                     ty::TyAdt(adt, _) => {\n                         if adt.is_union() {\n@@ -190,12 +201,17 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                                 if elem_ty.moves_by_default(self.tcx, self.param_env,\n                                                             self.source_info.span) {\n                                     self.require_unsafe(\n-                                        \"assignment to non-`Copy` union field\")\n+                                        \"assignment to non-`Copy` union field\",\n+                                        \"the previous content of the field will be dropped, which \\\n+                                         causes undefined behavior if the field was not properly \\\n+                                         initialized\")\n                                 } else {\n                                     // write to non-move union, safe\n                                 }\n                             } else {\n-                                self.require_unsafe(\"access to union field\")\n+                                self.require_unsafe(\"access to union field\",\n+                                    \"the field may not be properly initialized: using \\\n+                                     uninitialized data will cause undefined behavior\")\n                             }\n                         }\n                     }\n@@ -208,14 +224,21 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             }\n             &Place::Static(box Static { def_id, ty: _ }) => {\n                 if self.tcx.is_static(def_id) == Some(hir::Mutability::MutMutable) {\n-                    self.require_unsafe(\"use of mutable static\");\n+                    self.require_unsafe(\"use of mutable static\",\n+                        \"mutable statics can be mutated by multiple threads: aliasing violations \\\n+                         or data races will cause undefined behavior\");\n                 } else if self.tcx.is_foreign_item(def_id) {\n                     let source_info = self.source_info;\n                     let lint_root =\n                         self.source_scope_local_data[source_info.scope].lint_root;\n                     self.register_violations(&[UnsafetyViolation {\n                         source_info,\n                         description: Symbol::intern(\"use of extern static\").as_interned_str(),\n+                        details:\n+                            Symbol::intern(\"extern statics are not controlled by the Rust type \\\n+                                            system: invalid data, aliasing violations or data \\\n+                                            races will cause undefined behavior\")\n+                                .as_interned_str(),\n                         kind: UnsafetyViolationKind::ExternStatic(lint_root)\n                     }], &[]);\n                 }\n@@ -227,12 +250,14 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n \n impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n     fn require_unsafe(&mut self,\n-                      description: &'static str)\n+                      description: &'static str,\n+                      details: &'static str)\n     {\n         let source_info = self.source_info;\n         self.register_violations(&[UnsafetyViolation {\n             source_info,\n             description: Symbol::intern(description).as_interned_str(),\n+            details: Symbol::intern(details).as_interned_str(),\n             kind: UnsafetyViolationKind::General,\n         }], &[]);\n     }\n@@ -437,33 +462,36 @@ pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     } = tcx.unsafety_check_result(def_id);\n \n     for &UnsafetyViolation {\n-        source_info, description, kind\n+        source_info, description, details, kind\n     } in violations.iter() {\n         // Report an error.\n         match kind {\n             UnsafetyViolationKind::General => {\n                 struct_span_err!(\n                     tcx.sess, source_info.span, E0133,\n-                    \"{} requires unsafe function or block\", description)\n+                    \"{} is unsafe and requires unsafe function or block\", description)\n                     .span_label(source_info.span, &description.as_str()[..])\n+                    .note(&details.as_str()[..])\n                     .emit();\n             }\n             UnsafetyViolationKind::ExternStatic(lint_node_id) => {\n-                tcx.lint_node(SAFE_EXTERN_STATICS,\n+                tcx.lint_node_note(SAFE_EXTERN_STATICS,\n                               lint_node_id,\n                               source_info.span,\n-                              &format!(\"{} requires unsafe function or \\\n-                                        block (error E0133)\", &description.as_str()[..]));\n+                              &format!(\"{} is unsafe and requires unsafe function or block \\\n+                                        (error E0133)\", &description.as_str()[..]),\n+                              &details.as_str()[..]);\n             }\n             UnsafetyViolationKind::BorrowPacked(lint_node_id) => {\n                 if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id) {\n                     tcx.unsafe_derive_on_repr_packed(impl_def_id);\n                 } else {\n-                    tcx.lint_node(SAFE_PACKED_BORROWS,\n+                    tcx.lint_node_note(SAFE_PACKED_BORROWS,\n                                   lint_node_id,\n                                   source_info.span,\n-                                  &format!(\"{} requires unsafe function or \\\n-                                            block (error E0133)\", &description.as_str()[..]));\n+                                  &format!(\"{} is unsafe and requires unsafe function or block \\\n+                                            (error E0133)\", &description.as_str()[..]),\n+                                  &details.as_str()[..]);\n                 }\n             }\n         }"}, {"sha": "8a47b8ea6485a341ab8de71453186ccd5b562260", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 61, "deletions": 30, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -55,7 +55,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n use syntax::attr;\n-use syntax::ast::{Arm, IsAsync, BindingMode, Block, Crate, Expr, ExprKind};\n+use syntax::ast::{CRATE_NODE_ID, Arm, IsAsync, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParamKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n@@ -1891,7 +1891,12 @@ impl<'a> Resolver<'a> {\n \n         ident.span = ident.span.modern();\n         loop {\n-            module = unwrap_or!(self.hygienic_lexical_parent(module, &mut ident.span), break);\n+            let (opt_module, poisoned) = if record_used {\n+                self.hygienic_lexical_parent_with_compatibility_fallback(module, &mut ident.span)\n+            } else {\n+                (self.hygienic_lexical_parent(module, &mut ident.span), false)\n+            };\n+            module = unwrap_or!(opt_module, break);\n             let orig_current_module = self.current_module;\n             self.current_module = module; // Lexical resolutions can never be a privacy error.\n             let result = self.resolve_ident_in_module_unadjusted(\n@@ -1900,7 +1905,19 @@ impl<'a> Resolver<'a> {\n             self.current_module = orig_current_module;\n \n             match result {\n-                Ok(binding) => return Some(LexicalScopeBinding::Item(binding)),\n+                Ok(binding) => {\n+                    if poisoned {\n+                        self.session.buffer_lint_with_diagnostic(\n+                            lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n+                            CRATE_NODE_ID, ident.span,\n+                            &format!(\"cannot find {} `{}` in this scope\", ns.descr(), ident),\n+                            lint::builtin::BuiltinLintDiagnostics::\n+                                ProcMacroDeriveResolutionFallback(ident.span),\n+                        );\n+                    }\n+                    return Some(LexicalScopeBinding::Item(binding))\n+                }\n+                _ if poisoned => break,\n                 Err(Undetermined) => return None,\n                 Err(Determined) => {}\n             }\n@@ -1935,7 +1952,7 @@ impl<'a> Resolver<'a> {\n         None\n     }\n \n-    fn hygienic_lexical_parent(&mut self, mut module: Module<'a>, span: &mut Span)\n+    fn hygienic_lexical_parent(&mut self, module: Module<'a>, span: &mut Span)\n                                -> Option<Module<'a>> {\n         if !module.expansion.is_descendant_of(span.ctxt().outer()) {\n             return Some(self.macro_def_scope(span.remove_mark()));\n@@ -1945,22 +1962,41 @@ impl<'a> Resolver<'a> {\n             return Some(module.parent.unwrap());\n         }\n \n-        let mut module_expansion = module.expansion.modern(); // for backward compatibility\n-        while let Some(parent) = module.parent {\n-            let parent_expansion = parent.expansion.modern();\n-            if module_expansion.is_descendant_of(parent_expansion) &&\n-               parent_expansion != module_expansion {\n-                return if parent_expansion.is_descendant_of(span.ctxt().outer()) {\n-                    Some(parent)\n-                } else {\n-                    None\n-                };\n+        None\n+    }\n+\n+    fn hygienic_lexical_parent_with_compatibility_fallback(\n+        &mut self, module: Module<'a>, span: &mut Span) -> (Option<Module<'a>>, /* poisoned */ bool\n+    ) {\n+        if let module @ Some(..) = self.hygienic_lexical_parent(module, span) {\n+            return (module, false);\n+        }\n+\n+        // We need to support the next case under a deprecation warning\n+        // ```\n+        // struct MyStruct;\n+        // ---- begin: this comes from a proc macro derive\n+        // mod implementation_details {\n+        //     // Note that `MyStruct` is not in scope here.\n+        //     impl SomeTrait for MyStruct { ... }\n+        // }\n+        // ---- end\n+        // ```\n+        // So we have to fall back to the module's parent during lexical resolution in this case.\n+        if let Some(parent) = module.parent {\n+            // Inner module is inside the macro, parent module is outside of the macro.\n+            if module.expansion != parent.expansion &&\n+            module.expansion.is_descendant_of(parent.expansion) {\n+                // The macro is a proc macro derive\n+                if module.expansion.looks_like_proc_macro_derive() {\n+                    if parent.expansion.is_descendant_of(span.ctxt().outer()) {\n+                        return (module.parent, true);\n+                    }\n+                }\n             }\n-            module = parent;\n-            module_expansion = parent_expansion;\n         }\n \n-        None\n+        (None, false)\n     }\n \n     fn resolve_ident_in_module(&mut self,\n@@ -1996,17 +2032,17 @@ impl<'a> Resolver<'a> {\n             let mut iter = ctxt.marks().into_iter().rev().peekable();\n             let mut result = None;\n             // Find the last modern mark from the end if it exists.\n-            while let Some(&mark) = iter.peek() {\n-                if mark.transparency() == Transparency::Opaque {\n+            while let Some(&(mark, transparency)) = iter.peek() {\n+                if transparency == Transparency::Opaque {\n                     result = Some(mark);\n                     iter.next();\n                 } else {\n                     break;\n                 }\n             }\n             // Then find the last legacy mark from the end if it exists.\n-            for mark in iter {\n-                if mark.transparency() == Transparency::SemiTransparent {\n+            for (mark, transparency) in iter {\n+                if transparency == Transparency::SemiTransparent {\n                     result = Some(mark);\n                 } else {\n                     break;\n@@ -4037,8 +4073,9 @@ impl<'a> Resolver<'a> {\n         let mut search_module = self.current_module;\n         loop {\n             self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n-            search_module =\n-                unwrap_or!(self.hygienic_lexical_parent(search_module, &mut ident.span), break);\n+            search_module = unwrap_or!(\n+                self.hygienic_lexical_parent(search_module, &mut ident.span), break\n+            );\n         }\n \n         if let Some(prelude) = self.prelude {\n@@ -4406,12 +4443,6 @@ impl<'a> Resolver<'a> {\n             (TypeNS, _) => \"type\",\n         };\n \n-        let namespace = match ns {\n-            ValueNS => \"value\",\n-            MacroNS => \"macro\",\n-            TypeNS => \"type\",\n-        };\n-\n         let msg = format!(\"the name `{}` is defined multiple times\", name);\n \n         let mut err = match (old_binding.is_extern_crate(), new_binding.is_extern_crate()) {\n@@ -4429,7 +4460,7 @@ impl<'a> Resolver<'a> {\n \n         err.note(&format!(\"`{}` must be defined only once in the {} namespace of this {}\",\n                           name,\n-                          namespace,\n+                          ns.descr(),\n                           container));\n \n         err.span_label(span, format!(\"`{}` re{} here\", name, new_participle));"}, {"sha": "9ce1e21d0d03ebfef3fb899ed2a8db6f5820d63d", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -24,7 +24,7 @@ use syntax::errors::DiagnosticBuilder;\n use syntax::ext::base::{self, Annotatable, Determinacy, MultiModifier, MultiDecorator};\n use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n use syntax::ext::expand::{self, AstFragment, AstFragmentKind, Invocation, InvocationKind};\n-use syntax::ext::hygiene::{self, Mark, Transparency};\n+use syntax::ext::hygiene::{self, Mark};\n use syntax::ext::placeholders::placeholder;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{self, emit_feature_err, GateIssue};\n@@ -331,13 +331,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n         self.unused_macros.remove(&def_id);\n         let ext = self.get_macro(def);\n-        if ext.is_modern() {\n-            let transparency =\n-                if ext.is_transparent() { Transparency::Transparent } else { Transparency::Opaque };\n-            invoc.expansion_data.mark.set_transparency(transparency);\n-        } else if def_id.krate == BUILTIN_MACROS_CRATE {\n-            invoc.expansion_data.mark.set_is_builtin(true);\n-        }\n+        invoc.expansion_data.mark.set_default_transparency(ext.default_transparency());\n+        invoc.expansion_data.mark.set_is_builtin(def_id.krate == BUILTIN_MACROS_CRATE);\n         Ok(Some(ext))\n     }\n "}, {"sha": "51c42995d5e71947c60783b12935bc17e9940eb1", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -149,9 +149,9 @@ struct Waiter {\n \n // Helper struct used to clean up after a closure call with a `Drop`\n // implementation to also run on panic.\n-struct Finish {\n+struct Finish<'a> {\n     panicked: bool,\n-    me: &'static Once,\n+    me: &'a Once,\n }\n \n impl Once {\n@@ -218,7 +218,7 @@ impl Once {\n     ///\n     /// [poison]: struct.Mutex.html#poisoning\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn call_once<F>(&'static self, f: F) where F: FnOnce() {\n+    pub fn call_once<F>(&self, f: F) where F: FnOnce() {\n         // Fast path, just see if we've completed initialization.\n         if self.state.load(Ordering::SeqCst) == COMPLETE {\n             return\n@@ -275,7 +275,7 @@ impl Once {\n     /// INIT.call_once(|| {});\n     /// ```\n     #[unstable(feature = \"once_poison\", issue = \"33577\")]\n-    pub fn call_once_force<F>(&'static self, f: F) where F: FnOnce(&OnceState) {\n+    pub fn call_once_force<F>(&self, f: F) where F: FnOnce(&OnceState) {\n         // same as above, just with a different parameter to `call_inner`.\n         if self.state.load(Ordering::SeqCst) == COMPLETE {\n             return\n@@ -299,7 +299,7 @@ impl Once {\n     // currently no way to take an `FnOnce` and call it via virtual dispatch\n     // without some allocation overhead.\n     #[cold]\n-    fn call_inner(&'static self,\n+    fn call_inner(&self,\n                   ignore_poisoning: bool,\n                   init: &mut FnMut(bool)) {\n         let mut state = self.state.load(Ordering::SeqCst);\n@@ -390,7 +390,7 @@ impl fmt::Debug for Once {\n     }\n }\n \n-impl Drop for Finish {\n+impl<'a> Drop for Finish<'a> {\n     fn drop(&mut self) {\n         // Swap out our state with however we finished. We should only ever see\n         // an old state which was RUNNING."}, {"sha": "0a9991d33b186c5a98bd2d5757f1af3662bd61fc", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -131,7 +131,7 @@ pub(super) struct CodeMapFiles {\n \n pub struct CodeMap {\n     pub(super) files: Lock<CodeMapFiles>,\n-    file_loader: Box<FileLoader + Sync + Send>,\n+    file_loader: Box<dyn FileLoader + Sync + Send>,\n     // This is used to apply the file path remapping as specified via\n     // --remap-path-prefix to all FileMaps allocated within this CodeMap.\n     path_mapping: FilePathMapping,\n@@ -162,7 +162,7 @@ impl CodeMap {\n \n     }\n \n-    pub fn with_file_loader(file_loader: Box<FileLoader + Sync + Send>,\n+    pub fn with_file_loader(file_loader: Box<dyn FileLoader + Sync + Send>,\n                             path_mapping: FilePathMapping)\n                             -> CodeMap {\n         CodeMap {"}, {"sha": "61b0579a3e76bc137722c31eb1072242fbc9c325", "filename": "src/libsyntax/diagnostics/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -73,7 +73,7 @@ fn get_metadata_path(directory: PathBuf, name: &str) -> PathBuf {\n /// For our current purposes the prefix is the target architecture and the name is a crate name.\n /// If an error occurs steps will be taken to ensure that no file is created.\n pub fn output_metadata(ecx: &ExtCtxt, prefix: &str, name: &str, err_map: &ErrorMap)\n-    -> Result<(), Box<Error>>\n+    -> Result<(), Box<dyn Error>>\n {\n     // Create the directory to place the file in.\n     let metadata_dir = get_metadata_dir(prefix);"}, {"sha": "72ce2740190d421ba4d2c1c25adb43b1604ed2d7", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -42,7 +42,7 @@ pub type ErrorMap = BTreeMap<Name, ErrorInfo>;\n pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n                                    span: Span,\n                                    token_tree: &[TokenTree])\n-                                   -> Box<MacResult+'cx> {\n+                                   -> Box<dyn MacResult+'cx> {\n     let code = match (token_tree.len(), token_tree.get(0)) {\n         (1, Some(&TokenTree::Token(_, token::Ident(code, _)))) => code,\n         _ => unreachable!()\n@@ -75,7 +75,7 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n                                        span: Span,\n                                        token_tree: &[TokenTree])\n-                                       -> Box<MacResult+'cx> {\n+                                       -> Box<dyn MacResult+'cx> {\n     let (code, description) = match (\n         token_tree.len(),\n         token_tree.get(0),\n@@ -145,7 +145,7 @@ pub fn expand_register_diagnostic<'cx>(ecx: &'cx mut ExtCtxt,\n pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n                                           span: Span,\n                                           token_tree: &[TokenTree])\n-                                          -> Box<MacResult+'cx> {\n+                                          -> Box<dyn MacResult+'cx> {\n     assert_eq!(token_tree.len(), 3);\n     let (crate_name, name) = match (&token_tree[0], &token_tree[2]) {\n         ("}, {"sha": "e49a521040fddb17c95ad630385c80b0eca48aad", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -17,7 +17,7 @@ use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n use edition::Edition;\n use errors::{DiagnosticBuilder, DiagnosticId};\n use ext::expand::{self, AstFragment, Invocation};\n-use ext::hygiene::{self, Mark, SyntaxContext};\n+use ext::hygiene::{self, Mark, SyntaxContext, Transparency};\n use fold::{self, Folder};\n use parse::{self, parser, DirectoryOwnership};\n use parse::token;\n@@ -153,18 +153,18 @@ pub trait MultiItemDecorator {\n               sp: Span,\n               meta_item: &ast::MetaItem,\n               item: &Annotatable,\n-              push: &mut FnMut(Annotatable));\n+              push: &mut dyn FnMut(Annotatable));\n }\n \n impl<F> MultiItemDecorator for F\n-    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, &Annotatable, &mut FnMut(Annotatable))\n+    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, &Annotatable, &mut dyn FnMut(Annotatable))\n {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               sp: Span,\n               meta_item: &ast::MetaItem,\n               item: &Annotatable,\n-              push: &mut FnMut(Annotatable)) {\n+              push: &mut dyn FnMut(Annotatable)) {\n         (*self)(ecx, sp, meta_item, item, push)\n     }\n }\n@@ -247,18 +247,19 @@ impl<F> AttrProcMacro for F\n /// Represents a thing that maps token trees to Macro Results\n pub trait TTMacroExpander {\n     fn expand<'cx>(&self, ecx: &'cx mut ExtCtxt, span: Span, input: TokenStream)\n-                   -> Box<MacResult+'cx>;\n+                   -> Box<dyn MacResult+'cx>;\n }\n \n pub type MacroExpanderFn =\n     for<'cx> fn(&'cx mut ExtCtxt, Span, &[tokenstream::TokenTree])\n-                -> Box<MacResult+'cx>;\n+                -> Box<dyn MacResult+'cx>;\n \n impl<F> TTMacroExpander for F\n-    where F: for<'cx> Fn(&'cx mut ExtCtxt, Span, &[tokenstream::TokenTree]) -> Box<MacResult+'cx>\n+    where F: for<'cx> Fn(&'cx mut ExtCtxt, Span, &[tokenstream::TokenTree])\n+    -> Box<dyn MacResult+'cx>\n {\n     fn expand<'cx>(&self, ecx: &'cx mut ExtCtxt, span: Span, input: TokenStream)\n-                   -> Box<MacResult+'cx> {\n+                   -> Box<dyn MacResult+'cx> {\n         struct AvoidInterpolatedIdents;\n \n         impl Folder for AvoidInterpolatedIdents {\n@@ -289,23 +290,23 @@ pub trait IdentMacroExpander {\n                    sp: Span,\n                    ident: ast::Ident,\n                    token_tree: Vec<tokenstream::TokenTree>)\n-                   -> Box<MacResult+'cx>;\n+                   -> Box<dyn MacResult+'cx>;\n }\n \n pub type IdentMacroExpanderFn =\n     for<'cx> fn(&'cx mut ExtCtxt, Span, ast::Ident, Vec<tokenstream::TokenTree>)\n-                -> Box<MacResult+'cx>;\n+                -> Box<dyn MacResult+'cx>;\n \n impl<F> IdentMacroExpander for F\n     where F : for<'cx> Fn(&'cx mut ExtCtxt, Span, ast::Ident,\n-                          Vec<tokenstream::TokenTree>) -> Box<MacResult+'cx>\n+                          Vec<tokenstream::TokenTree>) -> Box<dyn MacResult+'cx>\n {\n     fn expand<'cx>(&self,\n                    cx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    ident: ast::Ident,\n                    token_tree: Vec<tokenstream::TokenTree>)\n-                   -> Box<MacResult+'cx>\n+                   -> Box<dyn MacResult+'cx>\n     {\n         (*self)(cx, sp, ident, token_tree)\n     }\n@@ -378,7 +379,7 @@ macro_rules! make_MacEager {\n \n         impl MacEager {\n             $(\n-                pub fn $fld(v: $t) -> Box<MacResult> {\n+                pub fn $fld(v: $t) -> Box<dyn MacResult> {\n                     Box::new(MacEager {\n                         $fld: Some(v),\n                         ..Default::default()\n@@ -462,7 +463,7 @@ impl DummyResult {\n     ///\n     /// Use this as a return value after hitting any errors and\n     /// calling `span_err`.\n-    pub fn any(sp: Span) -> Box<MacResult+'static> {\n+    pub fn any(sp: Span) -> Box<dyn MacResult+'static> {\n         Box::new(DummyResult { expr_only: false, span: sp })\n     }\n \n@@ -471,7 +472,7 @@ impl DummyResult {\n     /// Use this for macros that must expand to an expression, so even\n     /// if an error is encountered internally, the user will receive\n     /// an error that they also used it in the wrong place.\n-    pub fn expr(sp: Span) -> Box<MacResult+'static> {\n+    pub fn expr(sp: Span) -> Box<dyn MacResult+'static> {\n         Box::new(DummyResult { expr_only: true, span: sp })\n     }\n \n@@ -559,7 +560,7 @@ impl MacResult for DummyResult {\n }\n \n pub type BuiltinDeriveFn =\n-    for<'cx> fn(&'cx mut ExtCtxt, Span, &MetaItem, &Annotatable, &mut FnMut(Annotatable));\n+    for<'cx> fn(&'cx mut ExtCtxt, Span, &MetaItem, &Annotatable, &mut dyn FnMut(Annotatable));\n \n /// Represents different kinds of macro invocations that can be resolved.\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -590,15 +591,15 @@ pub enum SyntaxExtension {\n     /// `#[derive(...)]` is a `MultiItemDecorator`.\n     ///\n     /// Prefer ProcMacro or MultiModifier since they are more flexible.\n-    MultiDecorator(Box<MultiItemDecorator + sync::Sync + sync::Send>),\n+    MultiDecorator(Box<dyn MultiItemDecorator + sync::Sync + sync::Send>),\n \n     /// A syntax extension that is attached to an item and modifies it\n     /// in-place. Also allows decoration, i.e., creating new items.\n-    MultiModifier(Box<MultiItemModifier + sync::Sync + sync::Send>),\n+    MultiModifier(Box<dyn MultiItemModifier + sync::Sync + sync::Send>),\n \n     /// A function-like procedural macro. TokenStream -> TokenStream.\n     ProcMacro {\n-        expander: Box<ProcMacro + sync::Sync + sync::Send>,\n+        expander: Box<dyn ProcMacro + sync::Sync + sync::Send>,\n         allow_internal_unstable: bool,\n         edition: Edition,\n     },\n@@ -607,13 +608,13 @@ pub enum SyntaxExtension {\n     /// The first TokenSteam is the attribute, the second is the annotated item.\n     /// Allows modification of the input items and adding new items, similar to\n     /// MultiModifier, but uses TokenStreams, rather than AST nodes.\n-    AttrProcMacro(Box<AttrProcMacro + sync::Sync + sync::Send>, Edition),\n+    AttrProcMacro(Box<dyn AttrProcMacro + sync::Sync + sync::Send>, Edition),\n \n     /// A normal, function-like syntax extension.\n     ///\n     /// `bytes!` is a `NormalTT`.\n     NormalTT {\n-        expander: Box<TTMacroExpander + sync::Sync + sync::Send>,\n+        expander: Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n         def_info: Option<(ast::NodeId, Span)>,\n         /// Whether the contents of the macro can\n         /// directly use `#[unstable]` things (true == yes).\n@@ -633,21 +634,21 @@ pub enum SyntaxExtension {\n     /// A function-like syntax extension that has an extra ident before\n     /// the block.\n     ///\n-    IdentTT(Box<IdentMacroExpander + sync::Sync + sync::Send>, Option<Span>, bool),\n+    IdentTT(Box<dyn IdentMacroExpander + sync::Sync + sync::Send>, Option<Span>, bool),\n \n     /// An attribute-like procedural macro. TokenStream -> TokenStream.\n     /// The input is the annotated item.\n     /// Allows generating code to implement a Trait for a given struct\n     /// or enum item.\n-    ProcMacroDerive(Box<MultiItemModifier + sync::Sync + sync::Send>,\n+    ProcMacroDerive(Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n                     Vec<Symbol> /* inert attribute names */, Edition),\n \n     /// An attribute-like procedural macro that derives a builtin trait.\n     BuiltinDerive(BuiltinDeriveFn),\n \n     /// A declarative macro, e.g. `macro m() {}`.\n     DeclMacro {\n-        expander: Box<TTMacroExpander + sync::Sync + sync::Send>,\n+        expander: Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n         def_info: Option<(ast::NodeId, Span)>,\n         is_transparent: bool,\n         edition: Edition,\n@@ -673,20 +674,14 @@ impl SyntaxExtension {\n         }\n     }\n \n-    pub fn is_modern(&self) -> bool {\n+    pub fn default_transparency(&self) -> Transparency {\n         match *self {\n-            SyntaxExtension::DeclMacro { .. } |\n             SyntaxExtension::ProcMacro { .. } |\n             SyntaxExtension::AttrProcMacro(..) |\n-            SyntaxExtension::ProcMacroDerive(..) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_transparent(&self) -> bool {\n-        match *self {\n-            SyntaxExtension::DeclMacro { is_transparent, .. } => is_transparent,\n-            _ => false,\n+            SyntaxExtension::ProcMacroDerive(..) |\n+            SyntaxExtension::DeclMacro { is_transparent: false, .. } => Transparency::Opaque,\n+            SyntaxExtension::DeclMacro { is_transparent: true, .. } => Transparency::Transparent,\n+            _ => Transparency::SemiTransparent,\n         }\n     }\n \n@@ -784,7 +779,7 @@ pub struct ExtCtxt<'a> {\n     pub parse_sess: &'a parse::ParseSess,\n     pub ecfg: expand::ExpansionConfig<'a>,\n     pub root_path: PathBuf,\n-    pub resolver: &'a mut Resolver,\n+    pub resolver: &'a mut dyn Resolver,\n     pub resolve_err_count: usize,\n     pub current_expansion: ExpansionData,\n     pub expansions: HashMap<Span, Vec<String>>,\n@@ -793,7 +788,7 @@ pub struct ExtCtxt<'a> {\n impl<'a> ExtCtxt<'a> {\n     pub fn new(parse_sess: &'a parse::ParseSess,\n                ecfg: expand::ExpansionConfig<'a>,\n-               resolver: &'a mut Resolver)\n+               resolver: &'a mut dyn Resolver)\n                -> ExtCtxt<'a> {\n         ExtCtxt {\n             parse_sess,"}, {"sha": "865cb3d0d45783d65580cd93f4f8f5ed1fa2e3f8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -71,7 +71,7 @@ macro_rules! ast_fragments {\n                 }\n             }\n \n-            fn make_from<'a>(self, result: Box<MacResult + 'a>) -> Option<AstFragment> {\n+            fn make_from<'a>(self, result: Box<dyn MacResult + 'a>) -> Option<AstFragment> {\n                 match self {\n                     AstFragmentKind::OptExpr =>\n                         result.make_expr().map(Some).map(AstFragment::OptExpr),"}, {"sha": "1ace4d4a880e212f9e75b6bd26954bb8d2f4e918", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -452,7 +452,7 @@ pub fn parse_path_panic(parser: &mut Parser, mode: PathStyle) -> ast::Path {\n pub fn expand_quote_tokens<'cx>(cx: &'cx mut ExtCtxt,\n                                 sp: Span,\n                                 tts: &[TokenTree])\n-                                -> Box<base::MacResult+'cx> {\n+                                -> Box<dyn base::MacResult+'cx> {\n     let (cx_expr, expr) = expand_tts(cx, sp, tts);\n     let expanded = expand_wrapper(cx, sp, cx_expr, expr, &[&[\"syntax\", \"ext\", \"quote\", \"rt\"]]);\n     base::MacEager::expr(expanded)\n@@ -461,55 +461,55 @@ pub fn expand_quote_tokens<'cx>(cx: &'cx mut ExtCtxt,\n pub fn expand_quote_expr<'cx>(cx: &'cx mut ExtCtxt,\n                               sp: Span,\n                               tts: &[TokenTree])\n-                              -> Box<base::MacResult+'cx> {\n+                              -> Box<dyn base::MacResult+'cx> {\n     let expanded = expand_parse_call(cx, sp, \"parse_expr_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_item<'cx>(cx: &'cx mut ExtCtxt,\n                               sp: Span,\n                               tts: &[TokenTree])\n-                              -> Box<base::MacResult+'cx> {\n+                              -> Box<dyn base::MacResult+'cx> {\n     let expanded = expand_parse_call(cx, sp, \"parse_item_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_pat<'cx>(cx: &'cx mut ExtCtxt,\n                              sp: Span,\n                              tts: &[TokenTree])\n-                             -> Box<base::MacResult+'cx> {\n+                             -> Box<dyn base::MacResult+'cx> {\n     let expanded = expand_parse_call(cx, sp, \"parse_pat_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_arm(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n-                        -> Box<base::MacResult+'static> {\n+                        -> Box<dyn base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_arm_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_ty(cx: &mut ExtCtxt,\n                        sp: Span,\n                        tts: &[TokenTree])\n-                       -> Box<base::MacResult+'static> {\n+                       -> Box<dyn base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_ty_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[TokenTree])\n-                         -> Box<base::MacResult+'static> {\n+                         -> Box<dyn base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_stmt_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_attr(cx: &mut ExtCtxt,\n                          sp: Span,\n                          tts: &[TokenTree])\n-                         -> Box<base::MacResult+'static> {\n+                         -> Box<dyn base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_attribute_panic\",\n                                     vec![cx.expr_bool(sp, true)], tts);\n \n@@ -519,31 +519,31 @@ pub fn expand_quote_attr(cx: &mut ExtCtxt,\n pub fn expand_quote_arg(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n-                        -> Box<base::MacResult+'static> {\n+                        -> Box<dyn base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_arg_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_block(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n-                        -> Box<base::MacResult+'static> {\n+                        -> Box<dyn base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_block_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_meta_item(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n-                        -> Box<base::MacResult+'static> {\n+                        -> Box<dyn base::MacResult+'static> {\n     let expanded = expand_parse_call(cx, sp, \"parse_meta_item_panic\", vec![], tts);\n     base::MacEager::expr(expanded)\n }\n \n pub fn expand_quote_path(cx: &mut ExtCtxt,\n                         sp: Span,\n                         tts: &[TokenTree])\n-                        -> Box<base::MacResult+'static> {\n+                        -> Box<dyn base::MacResult+'static> {\n     let mode = mk_parser_path(cx, sp, &[\"PathStyle\", \"Type\"]);\n     let expanded = expand_parse_call(cx, sp, \"parse_path_panic\", vec![mode], tts);\n     base::MacEager::expr(expanded)"}, {"sha": "0c36c072a03023a4304d3c3f3656f72d215f4674", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -32,7 +32,7 @@ use rustc_data_structures::sync::Lrc;\n \n /// line!(): expands to the current line number\n pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                   -> Box<base::MacResult+'static> {\n+                   -> Box<dyn base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"line!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n@@ -43,7 +43,7 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n \n /* column!(): expands to the current column number */\n pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                  -> Box<base::MacResult+'static> {\n+                  -> Box<dyn base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"column!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n@@ -54,7 +54,7 @@ pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n \n /* __rust_unstable_column!(): expands to the current column number */\n pub fn expand_column_gated(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                  -> Box<base::MacResult+'static> {\n+                  -> Box<dyn base::MacResult+'static> {\n     if sp.allows_unstable() {\n         expand_column(cx, sp, tts)\n     } else {\n@@ -66,7 +66,7 @@ pub fn expand_column_gated(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Token\n /// The filemap (`loc.file`) contains a bunch more information we could spit\n /// out if we wanted.\n pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                   -> Box<base::MacResult+'static> {\n+                   -> Box<dyn base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"file!\");\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n@@ -75,13 +75,13 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                        -> Box<base::MacResult+'static> {\n+                        -> Box<dyn base::MacResult+'static> {\n     let s = pprust::tts_to_string(tts);\n     base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&s)))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                  -> Box<base::MacResult+'static> {\n+                  -> Box<dyn base::MacResult+'static> {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     let mod_path = &cx.current_expansion.module.mod_path;\n     let string = mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n@@ -93,7 +93,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n /// This is generally a bad idea because it's going to behave\n /// unhygienically.\n pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                           -> Box<base::MacResult+'cx> {\n+                           -> Box<dyn base::MacResult+'cx> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include!\") {\n         Some(f) => f,\n         None => return DummyResult::expr(sp),\n@@ -131,7 +131,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::T\n \n // include_str! : read the given file, insert it as a literal string expr\n pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                          -> Box<base::MacResult+'static> {\n+                          -> Box<dyn base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_str!\") {\n         Some(f) => f,\n         None => return DummyResult::expr(sp)\n@@ -168,7 +168,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n }\n \n pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n-                            -> Box<base::MacResult+'static> {\n+                            -> Box<dyn base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_bytes!\") {\n         Some(f) => f,\n         None => return DummyResult::expr(sp)"}, {"sha": "9ebead1062ebcfc3c6b1bb5ea3915e1833f7ecc7", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -73,7 +73,7 @@ impl TTMacroExpander for MacroRulesMacroExpander {\n                    cx: &'cx mut ExtCtxt,\n                    sp: Span,\n                    input: TokenStream)\n-                   -> Box<MacResult+'cx> {\n+                   -> Box<dyn MacResult+'cx> {\n         if !self.valid {\n             return DummyResult::any(sp);\n         }\n@@ -99,7 +99,7 @@ fn generic_extension<'cx>(cx: &'cx mut ExtCtxt,\n                           arg: TokenStream,\n                           lhses: &[quoted::TokenTree],\n                           rhses: &[quoted::TokenTree])\n-                          -> Box<MacResult+'cx> {\n+                          -> Box<dyn MacResult+'cx> {\n     if cx.trace_macros() {\n         trace_macros_note(cx, sp, format!(\"expanding `{}! {{ {} }}`\", name, arg));\n     }"}, {"sha": "65de1503966bfdc2020aa1aceecc64be687e2a66", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -34,9 +34,9 @@ use std::sync::{Arc, Mutex};\n use rustc_serialize::json::{as_json, as_pretty_json};\n \n pub struct JsonEmitter {\n-    dst: Box<Write + Send>,\n+    dst: Box<dyn Write + Send>,\n     registry: Option<Registry>,\n-    cm: Lrc<CodeMapper + sync::Send + sync::Sync>,\n+    cm: Lrc<dyn CodeMapper + sync::Send + sync::Sync>,\n     pretty: bool,\n     ui_testing: bool,\n }\n@@ -60,7 +60,7 @@ impl JsonEmitter {\n                             pretty)\n     }\n \n-    pub fn new(dst: Box<Write + Send>,\n+    pub fn new(dst: Box<dyn Write + Send>,\n                registry: Option<Registry>,\n                code_map: Lrc<CodeMap>,\n                pretty: bool) -> JsonEmitter {"}, {"sha": "ffaad9bf94c187313f7abfbea487d2a8981a9356", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -14,6 +14,8 @@\n //!\n //! This API is completely unstable and subject to change.\n \n+#![deny(bare_trait_objects)]\n+\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\","}, {"sha": "20a585b6601a51da4b3cf4f273991efc37958200", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -357,7 +357,7 @@ pub struct Literal {\n \n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n-pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut Read)\n+pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut dyn Read)\n                                     -> (Vec<Comment>, Vec<Literal>) {\n     let mut src = Vec::new();\n     srdr.read_to_end(&mut src).unwrap();"}, {"sha": "086de35d531c7f8db1d6b49e25749ba55c6b9ce2", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -241,7 +241,7 @@ pub struct PrintStackElem {\n \n const SIZE_INFINITY: isize = 0xffff;\n \n-pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n+pub fn mk_printer<'a>(out: Box<dyn io::Write+'a>, linewidth: usize) -> Printer<'a> {\n     // Yes 55, it makes the ring buffers big enough to never fall behind.\n     let n: usize = 55 * linewidth;\n     debug!(\"mk_printer {}\", linewidth);\n@@ -264,7 +264,7 @@ pub fn mk_printer<'a>(out: Box<io::Write+'a>, linewidth: usize) -> Printer<'a> {\n }\n \n pub struct Printer<'a> {\n-    out: Box<io::Write+'a>,\n+    out: Box<dyn io::Write+'a>,\n     buf_max_len: usize,\n     /// Width of lines we're constrained to\n     margin: isize,"}, {"sha": "c5ba7daaeb8f687753c849e9c03c12d289bde4fb", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -62,10 +62,10 @@ pub struct State<'a> {\n     literals: Peekable<vec::IntoIter<comments::Literal>>,\n     cur_cmnt: usize,\n     boxes: Vec<pp::Breaks>,\n-    ann: &'a (PpAnn+'a),\n+    ann: &'a (dyn PpAnn+'a),\n }\n \n-fn rust_printer<'a>(writer: Box<Write+'a>, ann: &'a PpAnn) -> State<'a> {\n+fn rust_printer<'a>(writer: Box<dyn Write+'a>, ann: &'a dyn PpAnn) -> State<'a> {\n     State {\n         s: pp::mk_printer(writer, DEFAULT_COLUMNS),\n         cm: None,\n@@ -88,9 +88,9 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n                        sess: &ParseSess,\n                        krate: &ast::Crate,\n                        filename: FileName,\n-                       input: &mut Read,\n-                       out: Box<Write+'a>,\n-                       ann: &'a PpAnn,\n+                       input: &mut dyn Read,\n+                       out: Box<dyn Write+'a>,\n+                       ann: &'a dyn PpAnn,\n                        is_expanded: bool) -> io::Result<()> {\n     let mut s = State::new_from_input(cm, sess, filename, input, out, ann, is_expanded);\n \n@@ -121,9 +121,9 @@ impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a CodeMap,\n                           sess: &ParseSess,\n                           filename: FileName,\n-                          input: &mut Read,\n-                          out: Box<Write+'a>,\n-                          ann: &'a PpAnn,\n+                          input: &mut dyn Read,\n+                          out: Box<dyn Write+'a>,\n+                          ann: &'a dyn PpAnn,\n                           is_expanded: bool) -> State<'a> {\n         let (cmnts, lits) = comments::gather_comments_and_literals(sess, filename, input);\n \n@@ -139,8 +139,8 @@ impl<'a> State<'a> {\n     }\n \n     pub fn new(cm: &'a CodeMap,\n-               out: Box<Write+'a>,\n-               ann: &'a PpAnn,\n+               out: Box<dyn Write+'a>,\n+               ann: &'a dyn PpAnn,\n                comments: Option<Vec<comments::Comment>>,\n                literals: Option<Vec<comments::Literal>>) -> State<'a> {\n         State {"}, {"sha": "4d5b0b327dd2e32784fd602c53279ee15bea2b2d", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -72,7 +72,7 @@ struct TestCtxt<'a> {\n // Traverse the crate, collecting all the test functions, eliding any\n // existing main functions, and synthesizing a main test harness\n pub fn modify_for_testing(sess: &ParseSess,\n-                          resolver: &mut Resolver,\n+                          resolver: &mut dyn Resolver,\n                           should_test: bool,\n                           krate: ast::Crate,\n                           span_diagnostic: &errors::Handler,\n@@ -278,7 +278,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n }\n \n fn generate_test_harness(sess: &ParseSess,\n-                         resolver: &mut Resolver,\n+                         resolver: &mut dyn Resolver,\n                          reexport_test_harness_main: Option<Symbol>,\n                          krate: ast::Crate,\n                          sd: &errors::Handler,"}, {"sha": "1c6f0089503e20d0e1c003ce45b0467916f6c256", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -12,48 +12,53 @@ use syntax::ast;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n use syntax::symbol::Symbol;\n-use syntax_pos;\n use syntax::tokenstream;\n+use syntax_pos;\n \n use std::string::String;\n \n-pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n-                         sp: syntax_pos::Span,\n-                         tts: &[tokenstream::TokenTree])\n-                         -> Box<base::MacResult + 'static> {\n+pub fn expand_syntax_ext(\n+    cx: &mut base::ExtCtxt,\n+    sp: syntax_pos::Span,\n+    tts: &[tokenstream::TokenTree],\n+) -> Box<base::MacResult + 'static> {\n     let es = match base::get_exprs_from_tts(cx, sp, tts) {\n         Some(e) => e,\n         None => return base::DummyResult::expr(sp),\n     };\n     let mut accumulator = String::new();\n     for e in es {\n         match e.node {\n-            ast::ExprKind::Lit(ref lit) => {\n-                match lit.node {\n-                    ast::LitKind::Str(ref s, _) |\n-                    ast::LitKind::Float(ref s, _) |\n-                    ast::LitKind::FloatUnsuffixed(ref s) => {\n-                        accumulator.push_str(&s.as_str());\n-                    }\n-                    ast::LitKind::Char(c) => {\n-                        accumulator.push(c);\n-                    }\n-                    ast::LitKind::Int(i, ast::LitIntType::Unsigned(_)) |\n-                    ast::LitKind::Int(i, ast::LitIntType::Signed(_)) |\n-                    ast::LitKind::Int(i, ast::LitIntType::Unsuffixed) => {\n-                        accumulator.push_str(&format!(\"{}\", i));\n-                    }\n-                    ast::LitKind::Bool(b) => {\n-                        accumulator.push_str(&format!(\"{}\", b));\n-                    }\n-                    ast::LitKind::Byte(..) |\n-                    ast::LitKind::ByteStr(..) => {\n-                        cx.span_err(e.span, \"cannot concatenate a byte string literal\");\n-                    }\n+            ast::ExprKind::Lit(ref lit) => match lit.node {\n+                ast::LitKind::Str(ref s, _)\n+                | ast::LitKind::Float(ref s, _)\n+                | ast::LitKind::FloatUnsuffixed(ref s) => {\n+                    accumulator.push_str(&s.as_str());\n                 }\n-            }\n+                ast::LitKind::Char(c) => {\n+                    accumulator.push(c);\n+                }\n+                ast::LitKind::Int(i, ast::LitIntType::Unsigned(_))\n+                | ast::LitKind::Int(i, ast::LitIntType::Signed(_))\n+                | ast::LitKind::Int(i, ast::LitIntType::Unsuffixed) => {\n+                    accumulator.push_str(&format!(\"{}\", i));\n+                }\n+                ast::LitKind::Bool(b) => {\n+                    accumulator.push_str(&format!(\"{}\", b));\n+                }\n+                ast::LitKind::Byte(..) | ast::LitKind::ByteStr(..) => {\n+                    cx.span_err(e.span, \"cannot concatenate a byte string literal\");\n+                }\n+            },\n             _ => {\n-                cx.span_err(e.span, \"expected a literal\");\n+                let mut err = cx.struct_span_err(e.span, \"expected a literal\");\n+                let snippet = cx.codemap().span_to_snippet(e.span).unwrap();\n+                err.span_suggestion(\n+                    e.span,\n+                    \"you might be missing a string literal to format with\",\n+                    format!(\"\\\"{{}}\\\", {}\", snippet),\n+                );\n+                err.emit();\n             }\n         }\n     }"}, {"sha": "c7076478332f4c01b1fb7c3ca22ef089576a0c99", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 79, "deletions": 61, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -27,16 +27,17 @@ use std::fmt;\n \n /// A SyntaxContext represents a chain of macro expansions (represented by marks).\n #[derive(Clone, Copy, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n-pub struct SyntaxContext(pub(super) u32);\n+pub struct SyntaxContext(u32);\n \n #[derive(Copy, Clone, Debug)]\n-pub struct SyntaxContextData {\n-    pub outer_mark: Mark,\n-    pub prev_ctxt: SyntaxContext,\n+struct SyntaxContextData {\n+    outer_mark: Mark,\n+    transparency: Transparency,\n+    prev_ctxt: SyntaxContext,\n     // This context, but with all transparent and semi-transparent marks filtered away.\n-    pub opaque: SyntaxContext,\n+    opaque: SyntaxContext,\n     // This context, but with all transparent marks filtered away.\n-    pub opaque_and_semitransparent: SyntaxContext,\n+    opaque_and_semitransparent: SyntaxContext,\n }\n \n /// A mark is a unique id associated with a macro expansion.\n@@ -46,14 +47,14 @@ pub struct Mark(u32);\n #[derive(Clone, Debug)]\n struct MarkData {\n     parent: Mark,\n-    transparency: Transparency,\n+    default_transparency: Transparency,\n     is_builtin: bool,\n     expn_info: Option<ExpnInfo>,\n }\n \n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug)]\n pub enum Transparency {\n     /// Identifier produced by a transparent expansion is always resolved at call-site.\n     /// Call-site spans in procedural macros, hygiene opt-out in `macro` should use this.\n@@ -71,26 +72,16 @@ pub enum Transparency {\n }\n \n impl Mark {\n-    fn fresh_with_data(mark_data: MarkData, data: &mut HygieneData) -> Self {\n-        data.marks.push(mark_data);\n-        Mark(data.marks.len() as u32 - 1)\n-    }\n-\n     pub fn fresh(parent: Mark) -> Self {\n         HygieneData::with(|data| {\n-            Mark::fresh_with_data(MarkData {\n+            data.marks.push(MarkData {\n                 parent,\n                 // By default expansions behave like `macro_rules`.\n-                transparency: Transparency::SemiTransparent,\n+                default_transparency: Transparency::SemiTransparent,\n                 is_builtin: false,\n                 expn_info: None,\n-            }, data)\n-        })\n-    }\n-\n-    pub fn fresh_cloned(clone_from: Mark) -> Self {\n-        HygieneData::with(|data| {\n-            Mark::fresh_with_data(data.marks[clone_from.0 as usize].clone(), data)\n+            });\n+            Mark(data.marks.len() as u32 - 1)\n         })\n     }\n \n@@ -127,34 +118,21 @@ impl Mark {\n         })\n     }\n \n-    pub fn modern(mut self) -> Mark {\n-        HygieneData::with(|data| {\n-            while data.marks[self.0 as usize].transparency != Transparency::Opaque {\n-                self = data.marks[self.0 as usize].parent;\n-            }\n-            self\n-        })\n-    }\n-\n-    #[inline]\n-    pub fn transparency(self) -> Transparency {\n-        assert_ne!(self, Mark::root());\n-        HygieneData::with(|data| data.marks[self.0 as usize].transparency)\n-    }\n-\n     #[inline]\n-    pub fn set_transparency(self, transparency: Transparency) {\n+    pub fn set_default_transparency(self, transparency: Transparency) {\n         assert_ne!(self, Mark::root());\n-        HygieneData::with(|data| data.marks[self.0 as usize].transparency = transparency)\n+        HygieneData::with(|data| data.marks[self.0 as usize].default_transparency = transparency)\n     }\n \n     #[inline]\n     pub fn is_builtin(self) -> bool {\n+        assert_ne!(self, Mark::root());\n         HygieneData::with(|data| data.marks[self.0 as usize].is_builtin)\n     }\n \n     #[inline]\n     pub fn set_is_builtin(self, is_builtin: bool) {\n+        assert_ne!(self, Mark::root());\n         HygieneData::with(|data| data.marks[self.0 as usize].is_builtin = is_builtin)\n     }\n \n@@ -195,29 +173,48 @@ impl Mark {\n             b\n         })\n     }\n+\n+    // Used for enabling some compatibility fallback in resolve.\n+    #[inline]\n+    pub fn looks_like_proc_macro_derive(self) -> bool {\n+        HygieneData::with(|data| {\n+            let mark_data = &data.marks[self.0 as usize];\n+            if mark_data.default_transparency == Transparency::Opaque {\n+                if let Some(expn_info) = &mark_data.expn_info {\n+                    if let ExpnFormat::MacroAttribute(name) = expn_info.format {\n+                        if name.as_str().starts_with(\"derive(\") {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            false\n+        })\n+    }\n }\n \n #[derive(Debug)]\n-pub struct HygieneData {\n+crate struct HygieneData {\n     marks: Vec<MarkData>,\n     syntax_contexts: Vec<SyntaxContextData>,\n-    markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n+    markings: HashMap<(SyntaxContext, Mark, Transparency), SyntaxContext>,\n     default_edition: Edition,\n }\n \n impl HygieneData {\n-    pub fn new() -> Self {\n+    crate fn new() -> Self {\n         HygieneData {\n             marks: vec![MarkData {\n                 parent: Mark::root(),\n                 // If the root is opaque, then loops searching for an opaque mark\n                 // will automatically stop after reaching it.\n-                transparency: Transparency::Opaque,\n+                default_transparency: Transparency::Opaque,\n                 is_builtin: true,\n                 expn_info: None,\n             }],\n             syntax_contexts: vec![SyntaxContextData {\n                 outer_mark: Mark::root(),\n+                transparency: Transparency::Opaque,\n                 prev_ctxt: SyntaxContext(0),\n                 opaque: SyntaxContext(0),\n                 opaque_and_semitransparent: SyntaxContext(0),\n@@ -249,6 +246,14 @@ impl SyntaxContext {\n         SyntaxContext(0)\n     }\n \n+    crate fn as_u32(self) -> u32 {\n+        self.0\n+    }\n+\n+    crate fn from_u32(raw: u32) -> SyntaxContext {\n+        SyntaxContext(raw)\n+    }\n+\n     // Allocate a new SyntaxContext with the given ExpnInfo. This is used when\n     // deserializing Spans from the incr. comp. cache.\n     // FIXME(mw): This method does not restore MarkData::parent or\n@@ -259,7 +264,7 @@ impl SyntaxContext {\n         HygieneData::with(|data| {\n             data.marks.push(MarkData {\n                 parent: Mark::root(),\n-                transparency: Transparency::SemiTransparent,\n+                default_transparency: Transparency::SemiTransparent,\n                 is_builtin: false,\n                 expn_info: Some(expansion_info),\n             });\n@@ -268,6 +273,7 @@ impl SyntaxContext {\n \n             data.syntax_contexts.push(SyntaxContextData {\n                 outer_mark: mark,\n+                transparency: Transparency::SemiTransparent,\n                 prev_ctxt: SyntaxContext::empty(),\n                 opaque: SyntaxContext::empty(),\n                 opaque_and_semitransparent: SyntaxContext::empty(),\n@@ -276,22 +282,32 @@ impl SyntaxContext {\n         })\n     }\n \n-    /// Extend a syntax context with a given mark\n+    /// Extend a syntax context with a given mark and default transparency for that mark.\n     pub fn apply_mark(self, mark: Mark) -> SyntaxContext {\n-        if mark.transparency() == Transparency::Opaque {\n-            return self.apply_mark_internal(mark);\n+        assert_ne!(mark, Mark::root());\n+        self.apply_mark_with_transparency(\n+            mark, HygieneData::with(|data| data.marks[mark.0 as usize].default_transparency)\n+        )\n+    }\n+\n+    /// Extend a syntax context with a given mark and transparency\n+    pub fn apply_mark_with_transparency(self, mark: Mark, transparency: Transparency)\n+                                        -> SyntaxContext {\n+        assert_ne!(mark, Mark::root());\n+        if transparency == Transparency::Opaque {\n+            return self.apply_mark_internal(mark, transparency);\n         }\n \n         let call_site_ctxt =\n             mark.expn_info().map_or(SyntaxContext::empty(), |info| info.call_site.ctxt());\n-        let call_site_ctxt = if mark.transparency() == Transparency::SemiTransparent {\n+        let call_site_ctxt = if transparency == Transparency::SemiTransparent {\n             call_site_ctxt.modern()\n         } else {\n             call_site_ctxt.modern_and_legacy()\n         };\n \n         if call_site_ctxt == SyntaxContext::empty() {\n-            return self.apply_mark_internal(mark);\n+            return self.apply_mark_internal(mark, transparency);\n         }\n \n         // Otherwise, `mark` is a macros 1.0 definition and the call site is in a\n@@ -304,27 +320,26 @@ impl SyntaxContext {\n         //\n         // See the example at `test/run-pass/hygiene/legacy_interaction.rs`.\n         let mut ctxt = call_site_ctxt;\n-        for mark in self.marks() {\n-            ctxt = ctxt.apply_mark_internal(mark);\n+        for (mark, transparency) in self.marks() {\n+            ctxt = ctxt.apply_mark_internal(mark, transparency);\n         }\n-        ctxt.apply_mark_internal(mark)\n+        ctxt.apply_mark_internal(mark, transparency)\n     }\n \n-    fn apply_mark_internal(self, mark: Mark) -> SyntaxContext {\n+    fn apply_mark_internal(self, mark: Mark, transparency: Transparency) -> SyntaxContext {\n         HygieneData::with(|data| {\n             let syntax_contexts = &mut data.syntax_contexts;\n-            let transparency = data.marks[mark.0 as usize].transparency;\n-\n             let mut opaque = syntax_contexts[self.0 as usize].opaque;\n             let mut opaque_and_semitransparent =\n                 syntax_contexts[self.0 as usize].opaque_and_semitransparent;\n \n             if transparency >= Transparency::Opaque {\n                 let prev_ctxt = opaque;\n-                opaque = *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+                opaque = *data.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n                     let new_opaque = SyntaxContext(syntax_contexts.len() as u32);\n                     syntax_contexts.push(SyntaxContextData {\n                         outer_mark: mark,\n+                        transparency,\n                         prev_ctxt,\n                         opaque: new_opaque,\n                         opaque_and_semitransparent: new_opaque,\n@@ -336,11 +351,12 @@ impl SyntaxContext {\n             if transparency >= Transparency::SemiTransparent {\n                 let prev_ctxt = opaque_and_semitransparent;\n                 opaque_and_semitransparent =\n-                        *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+                        *data.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n                     let new_opaque_and_semitransparent =\n                         SyntaxContext(syntax_contexts.len() as u32);\n                     syntax_contexts.push(SyntaxContextData {\n                         outer_mark: mark,\n+                        transparency,\n                         prev_ctxt,\n                         opaque,\n                         opaque_and_semitransparent: new_opaque_and_semitransparent,\n@@ -350,11 +366,12 @@ impl SyntaxContext {\n             }\n \n             let prev_ctxt = self;\n-            *data.markings.entry((prev_ctxt, mark)).or_insert_with(|| {\n+            *data.markings.entry((prev_ctxt, mark, transparency)).or_insert_with(|| {\n                 let new_opaque_and_semitransparent_and_transparent =\n                     SyntaxContext(syntax_contexts.len() as u32);\n                 syntax_contexts.push(SyntaxContextData {\n                     outer_mark: mark,\n+                    transparency,\n                     prev_ctxt,\n                     opaque,\n                     opaque_and_semitransparent,\n@@ -388,12 +405,13 @@ impl SyntaxContext {\n         })\n     }\n \n-    pub fn marks(mut self) -> Vec<Mark> {\n+    pub fn marks(mut self) -> Vec<(Mark, Transparency)> {\n         HygieneData::with(|data| {\n             let mut marks = Vec::new();\n             while self != SyntaxContext::empty() {\n-                marks.push(data.syntax_contexts[self.0 as usize].outer_mark);\n-                self = data.syntax_contexts[self.0 as usize].prev_ctxt;\n+                let ctxt_data = &data.syntax_contexts[self.0 as usize];\n+                marks.push((ctxt_data.outer_mark, ctxt_data.transparency));\n+                self = ctxt_data.prev_ctxt;\n             }\n             marks.reverse();\n             marks"}, {"sha": "61af70af47d85a42287a303669ffbcdf77977156", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -19,10 +19,10 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n #![feature(const_fn)]\n+#![feature(crate_visibility_modifier)]\n #![feature(custom_attribute)]\n #![feature(non_exhaustive)]\n #![feature(optin_builtin_traits)]\n-#![allow(unused_attributes)]\n #![feature(specialization)]\n #![feature(stdsimd)]\n "}, {"sha": "473aa1bd1b8a471e2e1c6de98169c8cc9965818d", "filename": "src/libsyntax_pos/span_encoding.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax_pos%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Flibsyntax_pos%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fspan_encoding.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -100,7 +100,7 @@ const INTERNED_INDEX_OFFSET: u32 = 1;\n \n #[inline]\n fn encode(sd: &SpanData) -> Span {\n-    let (base, len, ctxt) = (sd.lo.0, sd.hi.0 - sd.lo.0, sd.ctxt.0);\n+    let (base, len, ctxt) = (sd.lo.0, sd.hi.0 - sd.lo.0, sd.ctxt.as_u32());\n \n     let val = if (base >> INLINE_SIZES[BASE_INDEX]) == 0 &&\n                  (len >> INLINE_SIZES[LEN_INDEX]) == 0 &&\n@@ -132,7 +132,7 @@ fn decode(span: Span) -> SpanData {\n         let index = extract(INTERNED_INDEX_OFFSET, INTERNED_INDEX_SIZE);\n         return with_span_interner(|interner| *interner.get(index));\n     };\n-    SpanData { lo: BytePos(base), hi: BytePos(base + len), ctxt: SyntaxContext(ctxt) }\n+    SpanData { lo: BytePos(base), hi: BytePos(base + len), ctxt: SyntaxContext::from_u32(ctxt) }\n }\n \n #[derive(Default)]"}, {"sha": "5fad4c3677c0d79b1360f124ad155fe54fcb2764", "filename": "src/test/compile-fail/foreign-unsafe-fn-called.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn-called.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn-called.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fforeign-unsafe-fn-called.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -17,5 +17,5 @@ mod test {\n \n fn main() {\n     test::free();\n-    //~^ ERROR call to unsafe function requires unsafe function or block\n+    //~^ ERROR call to unsafe function is unsafe\n }"}, {"sha": "9e599cebd7a1ceb8266a4ef1716a3d2be643f7da", "filename": "src/test/compile-fail/init-unsafe.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Finit-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Finit-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finit-unsafe.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -12,7 +12,7 @@\n \n use std::intrinsics::{init};\n \n-// Test that the `forget` and `init` intrinsics are really unsafe\n+// Test that the `init` intrinsic is really unsafe\n pub fn main() {\n-    let stuff = init::<isize>(); //~ ERROR call to unsafe function requires unsafe\n+    let stuff = init::<isize>(); //~ ERROR call to unsafe function is unsafe\n }", "previous_filename": "src/test/compile-fail/forget-init-unsafe.rs"}, {"sha": "7b1364ff41c4023754343aa601bd9c38ccd74cf7", "filename": "src/test/compile-fail/issue-43733.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -27,12 +27,12 @@ fn __getit() -> std::option::Option<\n     &'static std::cell::UnsafeCell<\n         std::option::Option<Foo>>>\n {\n-    __KEY.get() //~ ERROR call to unsafe function requires unsafe\n+    __KEY.get() //~ ERROR call to unsafe function is unsafe\n }\n \n static FOO: std::thread::LocalKey<Foo> =\n     std::thread::LocalKey::new(__getit, Default::default);\n-//~^ ERROR call to unsafe function requires unsafe\n+//~^ ERROR call to unsafe function is unsafe\n \n fn main() {\n     FOO.with(|foo| println!(\"{}\", foo.borrow()));"}, {"sha": "5af0bf6be56e93147665903733a5106a985724cd", "filename": "src/test/compile-fail/issue-45087-unreachable-unsafe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Fissue-45087-unreachable-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Fissue-45087-unreachable-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-45087-unreachable-unsafe.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -11,5 +11,5 @@\n fn main() {\n     return;\n     *(1 as *mut u32) = 42;\n-    //~^ ERROR dereference of raw pointer requires unsafe\n+    //~^ ERROR dereference of raw pointer is unsafe\n }"}, {"sha": "b42ced07583f4f0fc63df3fe40f5c11047a9850d", "filename": "src/test/compile-fail/issue-45729-unsafe-in-generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Fissue-45729-unsafe-in-generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Fissue-45729-unsafe-in-generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-45729-unsafe-in-generator.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -13,7 +13,7 @@\n fn main() {\n     let _ = || {\n         *(1 as *mut u32) = 42;\n-        //~^ ERROR dereference of raw pointer requires unsafe\n+        //~^ ERROR dereference of raw pointer is unsafe\n         yield;\n     };\n }"}, {"sha": "683ef876f4e37ca7ac3b4e0bb3c9bdde1d275589", "filename": "src/test/compile-fail/issue-47412.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Fissue-47412.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Fissue-47412.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-47412.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -19,13 +19,13 @@ fn union_field() {\n     union Union { unit: (), void: Void }\n     let u = Union { unit: () };\n     match u.void {}\n-    //~^ ERROR access to union field requires unsafe function or block\n+    //~^ ERROR access to union field is unsafe\n }\n \n fn raw_ptr_deref() {\n     let ptr = std::ptr::null::<Void>();\n     match *ptr {}\n-    //~^ ERROR dereference of raw pointer requires unsafe function or block\n+    //~^ ERROR dereference of raw pointer is unsafe\n }\n \n fn main() {}"}, {"sha": "35ea6dd52c4f28fe29ff3cc19f326ca5e9fb46b4", "filename": "src/test/compile-fail/safe-extern-statics-mut.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Fsafe-extern-statics-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Fsafe-extern-statics-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsafe-extern-statics-mut.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -18,8 +18,8 @@ extern {\n }\n \n fn main() {\n-    let b = B; //~ ERROR use of mutable static requires unsafe function or block\n-    let rb = &B; //~ ERROR use of mutable static requires unsafe function or block\n-    let xb = XB; //~ ERROR use of mutable static requires unsafe function or block\n-    let xrb = &XB; //~ ERROR use of mutable static requires unsafe function or block\n+    let b = B; //~ ERROR use of mutable static is unsafe\n+    let rb = &B; //~ ERROR use of mutable static is unsafe\n+    let xb = XB; //~ ERROR use of mutable static is unsafe\n+    let xrb = &XB; //~ ERROR use of mutable static is unsafe\n }"}, {"sha": "83aa4b3316da0b7b9781ac2df49f1e977525c66c", "filename": "src/test/compile-fail/safe-extern-statics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Fsafe-extern-statics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Fsafe-extern-statics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsafe-extern-statics.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -20,12 +20,12 @@ extern {\n }\n \n fn main() {\n-    let a = A; //~ ERROR use of extern static requires unsafe function or block\n+    let a = A; //~ ERROR use of extern static is unsafe\n                //~^ WARN this was previously accepted by the compiler\n-    let ra = &A; //~ ERROR use of extern static requires unsafe function or block\n+    let ra = &A; //~ ERROR use of extern static is unsafe\n                  //~^ WARN this was previously accepted by the compiler\n-    let xa = XA; //~ ERROR use of extern static requires unsafe function or block\n+    let xa = XA; //~ ERROR use of extern static is unsafe\n                  //~^ WARN this was previously accepted by the compiler\n-    let xra = &XA; //~ ERROR use of extern static requires unsafe function or block\n+    let xra = &XA; //~ ERROR use of extern static is unsafe\n                    //~^ WARN this was previously accepted by the compiler\n }"}, {"sha": "d993816e6f476f6234f1e8db55766ef8362bb0c8", "filename": "src/test/compile-fail/union/union-unsafe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-unsafe.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -28,7 +28,7 @@ union U4<T: Copy> {\n \n fn generic_noncopy<T: Default>() {\n     let mut u3 = U3 { a: T::default() };\n-    u3.a = T::default(); //~ ERROR assignment to non-`Copy` union field requires unsafe\n+    u3.a = T::default(); //~ ERROR assignment to non-`Copy` union field is unsafe\n }\n \n fn generic_copy<T: Copy + Default>() {\n@@ -40,16 +40,16 @@ fn generic_copy<T: Copy + Default>() {\n \n fn main() {\n     let mut u1 = U1 { a: 10 }; // OK\n-    let a = u1.a; //~ ERROR access to union field requires unsafe\n+    let a = u1.a; //~ ERROR access to union field is unsafe\n     u1.a = 11; // OK\n-    let U1 { a } = u1; //~ ERROR access to union field requires unsafe\n-    if let U1 { a: 12 } = u1 {} //~ ERROR access to union field requires unsafe\n+    let U1 { a } = u1; //~ ERROR access to union field is unsafe\n+    if let U1 { a: 12 } = u1 {} //~ ERROR access to union field is unsafe\n     // let U1 { .. } = u1; // OK\n \n     let mut u2 = U2 { a: String::from(\"old\") }; // OK\n-    u2.a = String::from(\"new\"); //~ ERROR assignment to non-`Copy` union field requires unsafe\n+    u2.a = String::from(\"new\"); //~ ERROR assignment to non-`Copy` union field is unsafe\n     let mut u3 = U3 { a: 0 }; // OK\n     u3.a = 1; // OK\n     let mut u3 = U3 { a: String::from(\"old\") }; // OK\n-    u3.a = String::from(\"new\"); //~ ERROR assignment to non-`Copy` union field requires unsafe\n+    u3.a = String::from(\"new\"); //~ ERROR assignment to non-`Copy` union field is unsafe\n }"}, {"sha": "baf2002a94fc905157f2e3403c5219e98a5c2a67", "filename": "src/test/compile-fail/unsafe-fn-assign-deref-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-assign-deref-ptr.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -11,7 +11,7 @@\n \n \n fn f(p: *mut u8) {\n-    *p = 0; //~ ERROR dereference of raw pointer requires unsafe function or block\n+    *p = 0; //~ ERROR dereference of raw pointer is unsafe\n     return;\n }\n "}, {"sha": "46f28da43d03b4493cbc5ce12750482fe2009f8a", "filename": "src/test/compile-fail/unsafe-fn-called-from-safe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Funsafe-fn-called-from-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Funsafe-fn-called-from-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-called-from-safe.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -12,5 +12,5 @@\n unsafe fn f() { return; }\n \n fn main() {\n-    f(); //~ ERROR call to unsafe function requires unsafe function or block\n+    f(); //~ ERROR call to unsafe function is unsafe\n }"}, {"sha": "8e3ce8ff9b57d84fa1c373afeb7ae1f8b73ca21d", "filename": "src/test/compile-fail/unsafe-fn-deref-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Funsafe-fn-deref-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Funsafe-fn-deref-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-deref-ptr.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -10,7 +10,7 @@\n \n \n fn f(p: *const u8) -> u8 {\n-    return *p; //~ ERROR dereference of raw pointer requires unsafe function or block\n+    return *p; //~ ERROR dereference of raw pointer is unsafe\n }\n \n fn main() {"}, {"sha": "f09a0c7107a8a847e41bf8ab86d32669068c94ab", "filename": "src/test/compile-fail/unsafe-fn-used-as-value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-as-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-as-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-fn-used-as-value.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -13,5 +13,5 @@ unsafe fn f() { return; }\n \n fn main() {\n     let x = f;\n-    x();    //~ ERROR call to unsafe function requires unsafe function or block\n+    x();    //~ ERROR call to unsafe function is unsafe\n }"}, {"sha": "b4e425e7bbff130ecdaa3c230735d5ca1200408e", "filename": "src/test/compile-fail/unsafe-move-val-init.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Funsafe-move-val-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fcompile-fail%2Funsafe-move-val-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-move-val-init.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -16,5 +16,5 @@ use std::intrinsics;\n // as unsafe.\n fn main() {\n     intrinsics::move_val_init(1 as *mut u32, 1);\n-    //~^ ERROR dereference of raw pointer requires unsafe function or block\n+    //~^ ERROR dereference of raw pointer is unsafe\n }"}, {"sha": "6a8d545db49b966241cf62aaa97b36f350907391", "filename": "src/test/ui-fulldeps/proc-macro/auxiliary/generate-mod.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fauxiliary%2Fgenerate-mod.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-pass\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::*;\n+\n+#[proc_macro]\n+pub fn check(_: TokenStream) -> TokenStream {\n+    \"\n+    type Alias = FromOutside; // OK\n+    struct Outer;\n+    mod inner {\n+        type Alias = FromOutside; // `FromOutside` shouldn't be available from here\n+        type Inner = Outer; // `Outer` shouldn't be available from here\n+    }\n+    \".parse().unwrap()\n+}\n+\n+#[proc_macro_attribute]\n+pub fn check_attr(_: TokenStream, _: TokenStream) -> TokenStream {\n+    \"\n+    type AliasAttr = FromOutside; // OK\n+    struct OuterAttr;\n+    mod inner_attr {\n+        type Alias = FromOutside; // `FromOutside` shouldn't be available from here\n+        type Inner = OuterAttr; // `OuterAttr` shouldn't be available from here\n+    }\n+    \".parse().unwrap()\n+}\n+\n+#[proc_macro_derive(CheckDerive)]\n+pub fn check_derive(_: TokenStream) -> TokenStream {\n+    \"\n+    type AliasDerive = FromOutside; // OK\n+    struct OuterDerive;\n+    mod inner_derive {\n+        type Alias = FromOutside; // `FromOutside` shouldn't be available from here\n+        type Inner = OuterDerive; // `OuterDerive` shouldn't be available from here\n+    }\n+    \".parse().unwrap()\n+}"}, {"sha": "ff64421047fb8b4b7799f3bdae6379af4934600d", "filename": "src/test/ui-fulldeps/proc-macro/generate-mod.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Modules generated by transparent proc macros still acts as barriers for names (issue #50504).\n+\n+// aux-build:generate-mod.rs\n+\n+#![feature(proc_macro, proc_macro_gen, proc_macro_path_invoc)]\n+\n+extern crate generate_mod;\n+\n+struct FromOutside;\n+\n+generate_mod::check!(); //~ ERROR cannot find type `FromOutside` in this scope\n+                        //~| ERROR cannot find type `Outer` in this scope\n+\n+#[generate_mod::check_attr] //~ ERROR cannot find type `FromOutside` in this scope\n+                            //~| ERROR cannot find type `OuterAttr` in this scope\n+struct S;\n+\n+#[derive(generate_mod::CheckDerive)] //~ WARN cannot find type `FromOutside` in this scope\n+                                     //~| WARN cannot find type `OuterDerive` in this scope\n+                                     //~| WARN this was previously accepted\n+                                     //~| WARN this was previously accepted\n+struct Z;\n+\n+fn main() {}"}, {"sha": "c024aeffbb08675a33f0c1ad24e213f2e47a285b", "filename": "src/test/ui-fulldeps/proc-macro/generate-mod.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fgenerate-mod.stderr?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -0,0 +1,46 @@\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:21:1\n+   |\n+LL | generate_mod::check!(); //~ ERROR cannot find type `FromOutside` in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `Outer` in this scope\n+  --> $DIR/generate-mod.rs:21:1\n+   |\n+LL | generate_mod::check!(); //~ ERROR cannot find type `FromOutside` in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:24:1\n+   |\n+LL | #[generate_mod::check_attr] //~ ERROR cannot find type `FromOutside` in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `OuterAttr` in this scope\n+  --> $DIR/generate-mod.rs:24:1\n+   |\n+LL | #[generate_mod::check_attr] //~ ERROR cannot find type `FromOutside` in this scope\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n+\n+warning: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:28:10\n+   |\n+LL | #[derive(generate_mod::CheckDerive)] //~ WARN cannot find type `FromOutside` in this scope\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |\n+   = note: #[warn(proc_macro_derive_resolution_fallback)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #50504 <https://github.com/rust-lang/rust/issues/50504>\n+\n+warning: cannot find type `OuterDerive` in this scope\n+  --> $DIR/generate-mod.rs:28:10\n+   |\n+LL | #[derive(generate_mod::CheckDerive)] //~ WARN cannot find type `FromOutside` in this scope\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #50504 <https://github.com/rust-lang/rust/issues/50504>\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "9be80f8f21baa4dcb6c8b62f2fa0a5c9cd035679", "filename": "src/test/ui/error-codes/E0133.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Ferror-codes%2FE0133.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Ferror-codes%2FE0133.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0133.stderr?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -1,8 +1,10 @@\n-error[E0133]: call to unsafe function requires unsafe function or block\n+error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n   --> $DIR/E0133.rs:14:5\n    |\n LL |     f();\n    |     ^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n \n error: aborting due to previous error\n "}, {"sha": "958133e7ec5891b30a4ef2d93dba768df61c1947", "filename": "src/test/ui/hygiene/arguments.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fhygiene%2Farguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fhygiene%2Farguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Farguments.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -23,5 +23,5 @@ macro m($t:ty, $e:expr) {\n \n fn main() {\n     struct S;\n-    m!(S, S);\n+    m!(S, S); //~ ERROR cannot find type `S` in this scope\n }", "previous_filename": "src/test/run-pass/hygiene/arguments.rs"}, {"sha": "1b0c23eff297e95cdceb12391892f124f9ea3c79", "filename": "src/test/ui/hygiene/arguments.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fhygiene%2Farguments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fhygiene%2Farguments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Farguments.stderr?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -0,0 +1,9 @@\n+error[E0412]: cannot find type `S` in this scope\n+  --> $DIR/arguments.rs:26:8\n+   |\n+LL |     m!(S, S); //~ ERROR cannot find type `S` in this scope\n+   |        ^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "2b2108558a0f385908c02d0b9b75a3f1afd8badd", "filename": "src/test/ui/hygiene/generate-mod.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -12,13 +12,46 @@\n \n #![feature(decl_macro, rustc_attrs)]\n \n+macro genmod($FromOutside: ident, $Outer: ident) {\n+    type A = $FromOutside;\n+    struct $Outer;\n+    mod inner {\n+        type A = $FromOutside; // `FromOutside` shouldn't be available from here\n+        type Inner = $Outer; // `Outer` shouldn't be available from here\n+    }\n+}\n+\n #[rustc_transparent_macro]\n-macro genmod() {\n-    mod m {\n-        type A = S; //~ ERROR cannot find type `S` in this scope\n+macro genmod_transparent() {\n+    type A = FromOutside;\n+    struct Outer;\n+    mod inner {\n+        type A = FromOutside; //~ ERROR cannot find type `FromOutside` in this scope\n+        type Inner = Outer; //~ ERROR cannot find type `Outer` in this scope\n     }\n }\n \n-struct S;\n+macro_rules! genmod_legacy { () => {\n+    type A = FromOutside;\n+    struct Outer;\n+    mod inner {\n+        type A = FromOutside; //~ ERROR cannot find type `FromOutside` in this scope\n+        type Inner = Outer; //~ ERROR cannot find type `Outer` in this scope\n+    }\n+}}\n \n-genmod!();\n+fn check() {\n+    struct FromOutside;\n+    genmod!(FromOutside, Outer); //~ ERROR cannot find type `FromOutside` in this scope\n+                                 //~| ERROR cannot find type `Outer` in this scope\n+}\n+\n+fn check_transparent() {\n+    struct FromOutside;\n+    genmod_transparent!();\n+}\n+\n+fn check_legacy() {\n+    struct FromOutside;\n+    genmod_legacy!();\n+}"}, {"sha": "0c5905c5acb4fdc9ba2f93595feabfc269f30b66", "filename": "src/test/ui/hygiene/generate-mod.stderr", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fgenerate-mod.stderr?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -1,17 +1,56 @@\n-error[E0412]: cannot find type `S` in this scope\n-  --> $DIR/generate-mod.rs:18:18\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:45:13\n    |\n-LL |         type A = S; //~ ERROR cannot find type `S` in this scope\n-   |                  ^ did you mean `A`?\n+LL |     genmod!(FromOutside, Outer); //~ ERROR cannot find type `FromOutside` in this scope\n+   |             ^^^^^^^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `Outer` in this scope\n+  --> $DIR/generate-mod.rs:45:26\n+   |\n+LL |     genmod!(FromOutside, Outer); //~ ERROR cannot find type `FromOutside` in this scope\n+   |                          ^^^^^ not found in this scope\n+\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:29:18\n+   |\n+LL |         type A = FromOutside; //~ ERROR cannot find type `FromOutside` in this scope\n+   |                  ^^^^^^^^^^^ not found in this scope\n+...\n+LL |     genmod_transparent!();\n+   |     ---------------------- in this macro invocation\n+\n+error[E0412]: cannot find type `Outer` in this scope\n+  --> $DIR/generate-mod.rs:30:22\n+   |\n+LL |         type Inner = Outer; //~ ERROR cannot find type `Outer` in this scope\n+   |                      ^^^^^ not found in this scope\n+...\n+LL |     genmod_transparent!();\n+   |     ---------------------- in this macro invocation\n+\n+error[E0412]: cannot find type `FromOutside` in this scope\n+  --> $DIR/generate-mod.rs:38:18\n+   |\n+LL |         type A = FromOutside; //~ ERROR cannot find type `FromOutside` in this scope\n+   |                  ^^^^^^^^^^^ not found in this scope\n+...\n+LL |     genmod_legacy!();\n+   |     ----------------- in this macro invocation\n+\n+error[E0412]: cannot find type `Outer` in this scope\n+  --> $DIR/generate-mod.rs:39:22\n+   |\n+LL |         type Inner = Outer; //~ ERROR cannot find type `Outer` in this scope\n+   |                      ^^^^^ not found in this scope\n ...\n-LL | genmod!();\n-   | ---------- in this macro invocation\n+LL |     genmod_legacy!();\n+   |     ----------------- in this macro invocation\n \n error[E0601]: `main` function not found in crate `generate_mod`\n    |\n    = note: consider adding a `main` function to `$DIR/generate-mod.rs`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 7 previous errors\n \n Some errors occurred: E0412, E0601.\n For more information about an error, try `rustc --explain E0412`."}, {"sha": "9785ce6c0048eae04227e9dc0a34130237f751b9", "filename": "src/test/ui/hygiene/globs.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fhygiene%2Fglobs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fhygiene%2Fglobs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fglobs.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -57,12 +57,26 @@ macro n($i:ident) {\n                 }\n             }\n         }\n+        macro n_with_super($j:ident) {\n+            mod test {\n+                use super::*;\n+                fn g() {\n+                    let _: u32 = $i();\n+                    let _: () = f();\n+                    super::$j();\n+                }\n+            }\n+        }\n \n-        n!(f);\n+        n!(f); //~ ERROR cannot find function `f` in this scope\n+        n_with_super!(f);\n         mod test2 {\n             super::n! {\n                 f //~ ERROR cannot find function `f` in this scope\n             }\n+            super::n_with_super! {\n+                f\n+            }\n         }\n     }\n }"}, {"sha": "7df2e31f9a752f79edac498a4564590ebd7f61a5", "filename": "src/test/ui/hygiene/globs.stderr", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fglobs.stderr?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -30,20 +30,30 @@ LL | use bar::g;\n    |\n LL | use foo::test2::test::g;\n    |\n-LL | use foo::test::g;\n+LL | use foo::test2::test::g;\n    |\n LL | use foo::test::g;\n    |\n+and 2 other candidates\n+\n+error[E0425]: cannot find function `f` in this scope\n+  --> $DIR/globs.rs:71:12\n+   |\n+LL | n!(f);\n+   | ------ in this macro invocation\n+...\n+LL |         n!(f); //~ ERROR cannot find function `f` in this scope\n+   |            ^ not found in this scope\n \n error[E0425]: cannot find function `f` in this scope\n-  --> $DIR/globs.rs:64:17\n+  --> $DIR/globs.rs:75:17\n    |\n LL | n!(f);\n    | ------ in this macro invocation\n ...\n LL |                 f //~ ERROR cannot find function `f` in this scope\n    |                 ^ not found in this scope\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}, {"sha": "f88c2137e77ef44353eb51728ff18e35d2133a90", "filename": "src/test/ui/issue-27060.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fissue-27060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fissue-27060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27060.rs?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -33,9 +33,9 @@ fn main() {\n         let _ = &good.data2[0]; // ok\n     }\n \n-    let _ = &good.data; //~ ERROR borrow of packed field requires unsafe\n+    let _ = &good.data; //~ ERROR borrow of packed field is unsafe\n                         //~| hard error\n-    let _ = &good.data2[0]; //~ ERROR borrow of packed field requires unsafe\n+    let _ = &good.data2[0]; //~ ERROR borrow of packed field is unsafe\n                             //~| hard error\n     let _ = &*good.data; // ok, behind a pointer\n     let _ = &good.aligned; // ok, has align 1", "previous_filename": "src/test/compile-fail/issue-27060.rs"}, {"sha": "bd01f75d8fbc991ba2eef7bdc47bf705d5789119", "filename": "src/test/ui/issue-27060.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fissue-27060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fissue-27060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27060.stderr?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -0,0 +1,27 @@\n+error: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n+  --> $DIR/issue-27060.rs:36:13\n+   |\n+LL |     let _ = &good.data; //~ ERROR borrow of packed field is unsafe\n+   |             ^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/issue-27060.rs:23:8\n+   |\n+LL | #[deny(safe_packed_borrows)]\n+   |        ^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+\n+error: borrow of packed field is unsafe and requires unsafe function or block (error E0133)\n+  --> $DIR/issue-27060.rs:38:13\n+   |\n+LL |     let _ = &good.data2[0]; //~ ERROR borrow of packed field is unsafe\n+   |             ^^^^^^^^^^^^^^\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "aef0d9cd1d8c6bba1267a8490c8d56e38a2acf09", "filename": "src/test/ui/issue-28776.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fissue-28776.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fissue-28776.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-28776.stderr?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -1,8 +1,10 @@\n-error[E0133]: call to unsafe function requires unsafe function or block\n+error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n   --> $DIR/issue-28776.rs:14:5\n    |\n LL |     (&ptr::write)(1 as *mut _, 42);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n \n error: aborting due to previous error\n "}, {"sha": "0bfb060f84416783187b263866d6aa886b2d34f2", "filename": "src/test/ui/macros/bad_hello.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fmacros%2Fbad_hello.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Fmacros%2Fbad_hello.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fbad_hello.stderr?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -3,6 +3,10 @@ error: expected a literal\n    |\n LL |     println!(3 + 4); //~ ERROR expected a literal\n    |              ^^^^^\n+help: you might be missing a string literal to format with\n+   |\n+LL |     println!(\"{}\", 3 + 4); //~ ERROR expected a literal\n+   |              ^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "0b7b6e6167867b08e4ea7e17a71e7fdde84223c7", "filename": "src/test/ui/trait-safety-fn-body.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Ftrait-safety-fn-body.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Ftrait-safety-fn-body.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrait-safety-fn-body.stderr?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -1,8 +1,10 @@\n-error[E0133]: dereference of raw pointer requires unsafe function or block\n+error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\n   --> $DIR/trait-safety-fn-body.rs:21:9\n    |\n LL |         *self += 1;\n    |         ^^^^^^^^^^ dereference of raw pointer\n+   |\n+   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n error: aborting due to previous error\n "}, {"sha": "d4b3ed687e5e43b956c595f7004e9f29cb1d9e00", "filename": "src/test/ui/unsafe-const-fn.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Funsafe-const-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/704af2d7e1474ba60a0b70a5aa78e29905abb4e1/src%2Ftest%2Fui%2Funsafe-const-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe-const-fn.stderr?ref=704af2d7e1474ba60a0b70a5aa78e29905abb4e1", "patch": "@@ -1,8 +1,10 @@\n-error[E0133]: call to unsafe function requires unsafe function or block\n+error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n   --> $DIR/unsafe-const-fn.rs:19:18\n    |\n LL | const VAL: u32 = dummy(0xFFFF);\n    |                  ^^^^^^^^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n \n error: aborting due to previous error\n "}]}