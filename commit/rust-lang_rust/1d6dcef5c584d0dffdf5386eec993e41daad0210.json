{"sha": "1d6dcef5c584d0dffdf5386eec993e41daad0210", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNmRjZWY1YzU4NGQwZGZmZGY1Mzg2ZWVjOTkzZTQxZGFhZDAyMTA=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-27T10:08:34Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-27T10:08:34Z"}, "message": "Merge #332\n\n332: Struct types r=matklad a=flodiebold\n\nInfer types for struct fields, and add basic field completions. There's also some code for enums, but I focused on getting structs working.\r\n\r\nThere's still ways to go before this becomes useful: There's no autoderef (or even reference types) and no inference for `self`, for example.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "1e67675b7031115b1811863d0f186ad1f98b1fce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e67675b7031115b1811863d0f186ad1f98b1fce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d6dcef5c584d0dffdf5386eec993e41daad0210", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d6dcef5c584d0dffdf5386eec993e41daad0210", "html_url": "https://github.com/rust-lang/rust/commit/1d6dcef5c584d0dffdf5386eec993e41daad0210", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d6dcef5c584d0dffdf5386eec993e41daad0210/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "700165cf17290561dea511565278b9869ed61625", "url": "https://api.github.com/repos/rust-lang/rust/commits/700165cf17290561dea511565278b9869ed61625", "html_url": "https://github.com/rust-lang/rust/commit/700165cf17290561dea511565278b9869ed61625"}, {"sha": "bc745a139674f289386f3081458793f756cab5b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc745a139674f289386f3081458793f756cab5b9", "html_url": "https://github.com/rust-lang/rust/commit/bc745a139674f289386f3081458793f756cab5b9"}], "stats": {"total": 1836, "additions": 1518, "deletions": 318}, "files": [{"sha": "fe580700ff942c27c2767c9d57b8487e2c9fc25e", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -1,6 +1,7 @@\n mod completion_item;\n mod completion_context;\n \n+mod complete_dot;\n mod complete_fn_param;\n mod complete_keyword;\n mod complete_snippet;\n@@ -20,13 +21,13 @@ use crate::{\n \n pub use crate::completion::completion_item::{CompletionItem, InsertText, CompletionItemKind};\n \n-/// Main entry point for copmletion. We run comletion as a two-phase process.\n+/// Main entry point for completion. We run completion as a two-phase process.\n ///\n /// First, we look at the position and collect a so-called `CompletionContext.\n /// This is a somewhat messy process, because, during completion, syntax tree is\n-/// incomplete and can look readlly weired.\n+/// incomplete and can look really weird.\n ///\n-/// Once the context is collected, we run a series of completion routines whihc\n+/// Once the context is collected, we run a series of completion routines which\n /// look at the context and produce completion items.\n pub(crate) fn completions(\n     db: &db::RootDatabase,\n@@ -43,6 +44,7 @@ pub(crate) fn completions(\n     complete_snippet::complete_item_snippet(&mut acc, &ctx);\n     complete_path::complete_path(&mut acc, &ctx)?;\n     complete_scope::complete_scope(&mut acc, &ctx)?;\n+    complete_dot::complete_dot(&mut acc, &ctx)?;\n \n     Ok(Some(acc))\n }"}, {"sha": "93d657576813bf0827a6ba84b3940001b61ebd36", "filename": "crates/ra_analysis/src/completion/complete_dot.rs", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -0,0 +1,98 @@\n+use ra_syntax::ast::AstNode;\n+use hir::{Ty, Def};\n+\n+use crate::Cancelable;\n+use crate::completion::{CompletionContext, Completions, CompletionKind, CompletionItem, CompletionItemKind};\n+\n+/// Complete dot accesses, i.e. fields or methods (currently only fields).\n+pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) -> Cancelable<()> {\n+    let module = if let Some(module) = &ctx.module {\n+        module\n+    } else {\n+        return Ok(());\n+    };\n+    let function = if let Some(fn_def) = ctx.enclosing_fn {\n+        hir::source_binder::function_from_module(ctx.db, module, fn_def)\n+    } else {\n+        return Ok(());\n+    };\n+    let receiver = if let Some(receiver) = ctx.dot_receiver {\n+        receiver\n+    } else {\n+        return Ok(());\n+    };\n+    let infer_result = function.infer(ctx.db)?;\n+    let receiver_ty = if let Some(ty) = infer_result.type_of_node(receiver.syntax()) {\n+        ty\n+    } else {\n+        return Ok(());\n+    };\n+    if !ctx.is_method_call {\n+        complete_fields(acc, ctx, receiver_ty)?;\n+    }\n+    Ok(())\n+}\n+\n+fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) -> Cancelable<()> {\n+    // TODO: autoderef etc.\n+    match receiver {\n+        Ty::Adt { def_id, .. } => {\n+            match def_id.resolve(ctx.db)? {\n+                Def::Struct(s) => {\n+                    let variant_data = s.variant_data(ctx.db)?;\n+                    for field in variant_data.fields() {\n+                        CompletionItem::new(CompletionKind::Reference, field.name().to_string())\n+                            .kind(CompletionItemKind::Field)\n+                            .add_to(acc);\n+                    }\n+                }\n+                // TODO unions\n+                _ => {}\n+            }\n+        }\n+        Ty::Tuple(fields) => {\n+            for (i, _ty) in fields.iter().enumerate() {\n+                CompletionItem::new(CompletionKind::Reference, i.to_string())\n+                    .kind(CompletionItemKind::Field)\n+                    .add_to(acc);\n+            }\n+        }\n+        _ => {}\n+    };\n+    Ok(())\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::completion::*;\n+\n+    fn check_ref_completion(code: &str, expected_completions: &str) {\n+        check_completion(code, expected_completions, CompletionKind::Reference);\n+    }\n+\n+    #[test]\n+    fn test_struct_field_completion() {\n+        check_ref_completion(\n+            r\"\n+            struct A { the_field: u32 }\n+            fn foo(a: A) {\n+               a.<|>\n+            }\n+            \",\n+            r#\"the_field\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_no_struct_field_completion_for_method_call() {\n+        check_ref_completion(\n+            r\"\n+            struct A { the_field: u32 }\n+            fn foo(a: A) {\n+               a.<|>()\n+            }\n+            \",\n+            r#\"\"#,\n+        );\n+    }\n+}"}, {"sha": "aaa2c7ceec10844564cb07bd1f70f78e79c88adc", "filename": "crates/ra_analysis/src/completion/complete_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_path.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -8,7 +8,7 @@ pub(super) fn complete_path(acc: &mut Completions, ctx: &CompletionContext) -> C\n         (Some(path), Some(module)) => (path.clone(), module),\n         _ => return Ok(()),\n     };\n-    let def_id = match module.resolve_path(ctx.db, path)? {\n+    let def_id = match module.resolve_path(ctx.db, &path)?.take_types() {\n         Some(it) => it,\n         None => return Ok(()),\n     };"}, {"sha": "978772fd447f969136fd7be3612a9be87e0df54c", "filename": "crates/ra_analysis/src/completion/completion_context.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -1,12 +1,13 @@\n use ra_editor::find_node_at_offset;\n use ra_text_edit::AtomTextEdit;\n use ra_syntax::{\n-    algo::find_leaf_at_offset,\n+    algo::{find_leaf_at_offset, find_covering_node},\n     ast,\n     AstNode,\n     SyntaxNodeRef,\n     SourceFileNode,\n     TextUnit,\n+    TextRange,\n     SyntaxKind::*,\n };\n use hir::source_binder;\n@@ -31,6 +32,10 @@ pub(super) struct CompletionContext<'a> {\n     pub(super) is_stmt: bool,\n     /// Something is typed at the \"top\" level, in module or impl/trait.\n     pub(super) is_new_item: bool,\n+    /// The receiver if this is a field or method access, i.e. writing something.<|>\n+    pub(super) dot_receiver: Option<ast::Expr<'a>>,\n+    /// If this is a method call in particular, i.e. the () are already there.\n+    pub(super) is_method_call: bool,\n }\n \n impl<'a> CompletionContext<'a> {\n@@ -54,12 +59,14 @@ impl<'a> CompletionContext<'a> {\n             after_if: false,\n             is_stmt: false,\n             is_new_item: false,\n+            dot_receiver: None,\n+            is_method_call: false,\n         };\n         ctx.fill(original_file, position.offset);\n         Ok(Some(ctx))\n     }\n \n-    fn fill(&mut self, original_file: &SourceFileNode, offset: TextUnit) {\n+    fn fill(&mut self, original_file: &'a SourceFileNode, offset: TextUnit) {\n         // Insert a fake ident to get a valid parse tree. We will use this file\n         // to determine context, though the original_file will be used for\n         // actual completion.\n@@ -76,7 +83,7 @@ impl<'a> CompletionContext<'a> {\n                 self.is_param = true;\n                 return;\n             }\n-            self.classify_name_ref(&file, name_ref);\n+            self.classify_name_ref(original_file, name_ref);\n         }\n \n         // Otherwise, see if this is a declaration. We can use heuristics to\n@@ -88,7 +95,7 @@ impl<'a> CompletionContext<'a> {\n             }\n         }\n     }\n-    fn classify_name_ref(&mut self, file: &SourceFileNode, name_ref: ast::NameRef) {\n+    fn classify_name_ref(&mut self, original_file: &'a SourceFileNode, name_ref: ast::NameRef) {\n         let name_range = name_ref.syntax().range();\n         let top_node = name_ref\n             .syntax()\n@@ -105,6 +112,12 @@ impl<'a> CompletionContext<'a> {\n             _ => (),\n         }\n \n+        self.enclosing_fn = self\n+            .leaf\n+            .ancestors()\n+            .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n+            .find_map(ast::FnDef::cast);\n+\n         let parent = match name_ref.syntax().parent() {\n             Some(it) => it,\n             None => return,\n@@ -120,11 +133,6 @@ impl<'a> CompletionContext<'a> {\n             }\n             if path.qualifier().is_none() {\n                 self.is_trivial_path = true;\n-                self.enclosing_fn = self\n-                    .leaf\n-                    .ancestors()\n-                    .take_while(|it| it.kind() != SOURCE_FILE && it.kind() != MODULE)\n-                    .find_map(ast::FnDef::cast);\n \n                 self.is_stmt = match name_ref\n                     .syntax()\n@@ -137,17 +145,43 @@ impl<'a> CompletionContext<'a> {\n                 };\n \n                 if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n-                    if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n+                    if let Some(if_expr) =\n+                        find_node_at_offset::<ast::IfExpr>(original_file.syntax(), off)\n+                    {\n                         if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n                             self.after_if = true;\n                         }\n                     }\n                 }\n             }\n         }\n+        if let Some(field_expr) = ast::FieldExpr::cast(parent) {\n+            // The receiver comes before the point of insertion of the fake\n+            // ident, so it should have the same range in the non-modified file\n+            self.dot_receiver = field_expr\n+                .expr()\n+                .map(|e| e.syntax().range())\n+                .and_then(|r| find_node_with_range(original_file.syntax(), r));\n+        }\n+        if let Some(method_call_expr) = ast::MethodCallExpr::cast(parent) {\n+            // As above\n+            self.dot_receiver = method_call_expr\n+                .expr()\n+                .map(|e| e.syntax().range())\n+                .and_then(|r| find_node_with_range(original_file.syntax(), r));\n+            self.is_method_call = true;\n+        }\n     }\n }\n \n+fn find_node_with_range<'a, N: AstNode<'a>>(\n+    syntax: SyntaxNodeRef<'a>,\n+    range: TextRange,\n+) -> Option<N> {\n+    let node = find_covering_node(syntax, range);\n+    node.ancestors().find_map(N::cast)\n+}\n+\n fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n     match node.ancestors().filter_map(N::cast).next() {\n         None => false,"}, {"sha": "c9f9f495da88098b5ee7a96765c7d1efd2c1d003", "filename": "crates/ra_analysis/src/completion/completion_item.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -1,5 +1,7 @@\n use crate::db;\n \n+use hir::PerNs;\n+\n /// `CompletionItem` describes a single completion variant in the editor pop-up.\n /// It is basically a POD with various properties. To construct a\n /// `CompletionItem`, use `new` method and the `Builder` struct.\n@@ -25,7 +27,10 @@ pub enum CompletionItemKind {\n     Keyword,\n     Module,\n     Function,\n+    Struct,\n+    Enum,\n     Binding,\n+    Field,\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -117,16 +122,27 @@ impl Builder {\n         db: &db::RootDatabase,\n         resolution: &hir::Resolution,\n     ) -> Builder {\n-        if let Some(def_id) = resolution.def_id {\n-            if let Ok(def) = def_id.resolve(db) {\n-                let kind = match def {\n-                    hir::Def::Module(..) => CompletionItemKind::Module,\n-                    hir::Def::Function(..) => CompletionItemKind::Function,\n-                    _ => return self,\n-                };\n-                self.kind = Some(kind);\n-            }\n-        }\n+        let resolved = resolution.def_id.and_then(|d| d.resolve(db).ok());\n+        let kind = match resolved {\n+            PerNs {\n+                types: Some(hir::Def::Module(..)),\n+                ..\n+            } => CompletionItemKind::Module,\n+            PerNs {\n+                types: Some(hir::Def::Struct(..)),\n+                ..\n+            } => CompletionItemKind::Struct,\n+            PerNs {\n+                types: Some(hir::Def::Enum(..)),\n+                ..\n+            } => CompletionItemKind::Enum,\n+            PerNs {\n+                values: Some(hir::Def::Function(..)),\n+                ..\n+            } => CompletionItemKind::Function,\n+            _ => return self,\n+        };\n+        self.kind = Some(kind);\n         self\n     }\n }"}, {"sha": "036e284bfbb0ff680ba1c5e5de6e7dd3f97b89c4", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -95,6 +95,9 @@ salsa::database_storage! {\n             fn submodules() for hir::db::SubmodulesQuery;\n             fn infer() for hir::db::InferQuery;\n             fn type_for_def() for hir::db::TypeForDefQuery;\n+            fn type_for_field() for hir::db::TypeForFieldQuery;\n+            fn struct_data() for hir::db::StructDataQuery;\n+            fn enum_data() for hir::db::EnumDataQuery;\n         }\n     }\n }"}, {"sha": "65c461148aa4cdbdad0cd3f1ed16e5acb79a398d", "filename": "crates/ra_hir/src/adt.rs", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fadt.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -0,0 +1,194 @@\n+use std::sync::Arc;\n+\n+use ra_syntax::{SmolStr, ast::{self, NameOwner, StructFlavor}};\n+\n+use crate::{\n+    DefId, Cancelable,\n+    db::{HirDatabase},\n+    type_ref::TypeRef,\n+};\n+\n+pub struct Struct {\n+    def_id: DefId,\n+}\n+\n+impl Struct {\n+    pub(crate) fn new(def_id: DefId) -> Self {\n+        Struct { def_id }\n+    }\n+\n+    pub fn def_id(&self) -> DefId {\n+        self.def_id\n+    }\n+\n+    pub fn variant_data(&self, db: &impl HirDatabase) -> Cancelable<Arc<VariantData>> {\n+        Ok(db.struct_data(self.def_id)?.variant_data.clone())\n+    }\n+\n+    pub fn struct_data(&self, db: &impl HirDatabase) -> Cancelable<Arc<StructData>> {\n+        Ok(db.struct_data(self.def_id)?)\n+    }\n+\n+    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<SmolStr>> {\n+        Ok(db.struct_data(self.def_id)?.name.clone())\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct StructData {\n+    name: Option<SmolStr>,\n+    variant_data: Arc<VariantData>,\n+}\n+\n+impl StructData {\n+    pub(crate) fn new(struct_def: ast::StructDef) -> StructData {\n+        let name = struct_def.name().map(|n| n.text());\n+        let variant_data = VariantData::new(struct_def.flavor());\n+        let variant_data = Arc::new(variant_data);\n+        StructData { name, variant_data }\n+    }\n+\n+    pub fn name(&self) -> Option<&SmolStr> {\n+        self.name.as_ref()\n+    }\n+\n+    pub fn variant_data(&self) -> &Arc<VariantData> {\n+        &self.variant_data\n+    }\n+}\n+\n+pub struct Enum {\n+    def_id: DefId,\n+}\n+\n+impl Enum {\n+    pub(crate) fn new(def_id: DefId) -> Self {\n+        Enum { def_id }\n+    }\n+\n+    pub fn def_id(&self) -> DefId {\n+        self.def_id\n+    }\n+\n+    pub fn name(&self, db: &impl HirDatabase) -> Cancelable<Option<SmolStr>> {\n+        Ok(db.enum_data(self.def_id)?.name.clone())\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct EnumData {\n+    name: Option<SmolStr>,\n+    variants: Vec<(SmolStr, Arc<VariantData>)>,\n+}\n+\n+impl EnumData {\n+    pub(crate) fn new(enum_def: ast::EnumDef) -> Self {\n+        let name = enum_def.name().map(|n| n.text());\n+        let variants = if let Some(evl) = enum_def.variant_list() {\n+            evl.variants()\n+                .map(|v| {\n+                    (\n+                        v.name()\n+                            .map(|n| n.text())\n+                            .unwrap_or_else(|| SmolStr::new(\"[error]\")),\n+                        Arc::new(VariantData::new(v.flavor())),\n+                    )\n+                })\n+                .collect()\n+        } else {\n+            Vec::new()\n+        };\n+        EnumData { name, variants }\n+    }\n+}\n+\n+/// A single field of an enum variant or struct\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct StructField {\n+    name: SmolStr,\n+    type_ref: TypeRef,\n+}\n+\n+impl StructField {\n+    pub fn name(&self) -> SmolStr {\n+        self.name.clone()\n+    }\n+    pub fn type_ref(&self) -> &TypeRef {\n+        &self.type_ref\n+    }\n+}\n+\n+/// Fields of an enum variant or struct\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum VariantData {\n+    Struct(Vec<StructField>),\n+    Tuple(Vec<StructField>),\n+    Unit,\n+}\n+\n+impl VariantData {\n+    pub fn new(flavor: StructFlavor) -> Self {\n+        match flavor {\n+            StructFlavor::Tuple(fl) => {\n+                let fields = fl\n+                    .fields()\n+                    .enumerate()\n+                    .map(|(i, fd)| StructField {\n+                        name: SmolStr::new(i.to_string()),\n+                        type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n+                    })\n+                    .collect();\n+                VariantData::Tuple(fields)\n+            }\n+            StructFlavor::Named(fl) => {\n+                let fields = fl\n+                    .fields()\n+                    .map(|fd| StructField {\n+                        name: fd\n+                            .name()\n+                            .map(|n| n.text())\n+                            .unwrap_or_else(|| SmolStr::new(\"[error]\")),\n+                        type_ref: TypeRef::from_ast_opt(fd.type_ref()),\n+                    })\n+                    .collect();\n+                VariantData::Struct(fields)\n+            }\n+            StructFlavor::Unit => VariantData::Unit,\n+        }\n+    }\n+\n+    pub(crate) fn get_field_type_ref(&self, field_name: &str) -> Option<&TypeRef> {\n+        self.fields()\n+            .iter()\n+            .find(|f| f.name == field_name)\n+            .map(|f| &f.type_ref)\n+    }\n+\n+    pub fn fields(&self) -> &[StructField] {\n+        match *self {\n+            VariantData::Struct(ref fields) | VariantData::Tuple(ref fields) => fields,\n+            _ => &[],\n+        }\n+    }\n+    pub fn is_struct(&self) -> bool {\n+        if let VariantData::Struct(..) = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+    pub fn is_tuple(&self) -> bool {\n+        if let VariantData::Tuple(..) = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+    pub fn is_unit(&self) -> bool {\n+        if let VariantData::Unit = *self {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "e7f9afa77d5ce4a0c31c4603c21365fc335e4549", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -1,6 +1,7 @@\n use std::sync::Arc;\n \n use ra_syntax::{\n+    SmolStr,\n     SyntaxNode,\n     ast::FnDefNode,\n };\n@@ -15,6 +16,7 @@ use crate::{\n     module::{ModuleId, ModuleTree, ModuleSource,\n     nameres::{ItemMap, InputModuleItems}},\n     ty::{InferenceResult, Ty},\n+    adt::{StructData, EnumData},\n };\n \n salsa::query_group! {\n@@ -31,6 +33,16 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::fn_syntax;\n     }\n \n+    fn struct_data(def_id: DefId) -> Cancelable<Arc<StructData>> {\n+        type StructDataQuery;\n+        use fn query_definitions::struct_data;\n+    }\n+\n+    fn enum_data(def_id: DefId) -> Cancelable<Arc<EnumData>> {\n+        type EnumDataQuery;\n+        use fn query_definitions::enum_data;\n+    }\n+\n     fn infer(fn_id: FnId) -> Cancelable<Arc<InferenceResult>> {\n         type InferQuery;\n         use fn query_definitions::infer;\n@@ -41,6 +53,11 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::type_for_def;\n     }\n \n+    fn type_for_field(def_id: DefId, field: SmolStr) -> Cancelable<Ty> {\n+        type TypeForFieldQuery;\n+        use fn query_definitions::type_for_field;\n+    }\n+\n     fn file_items(file_id: FileId) -> Arc<SourceFileItems> {\n         type SourceFileItemsQuery;\n         use fn query_definitions::file_items;"}, {"sha": "01f0f3a662545a36346fae98b9b295b5030665ed", "filename": "crates/ra_hir/src/function.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -46,8 +46,7 @@ impl Function {\n     }\n \n     pub fn module(&self, db: &impl HirDatabase) -> Cancelable<Module> {\n-        let loc = self.fn_id.0.loc(db);\n-        Module::new(db, loc.source_root_id, loc.module_id)\n+        self.fn_id.0.module(db)\n     }\n }\n "}, {"sha": "f1cc0ccd085cefe8b4157dea8873be690e96810a", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -25,6 +25,8 @@ pub mod source_binder;\n mod krate;\n mod module;\n mod function;\n+mod adt;\n+mod type_ref;\n mod ty;\n \n use std::ops::Index;\n@@ -40,8 +42,10 @@ use crate::{\n pub use self::{\n     path::{Path, PathKind},\n     krate::Crate,\n-    module::{Module, ModuleId, Problem, nameres::ItemMap, ModuleScope, Resolution},\n+    module::{Module, ModuleId, Problem, nameres::{ItemMap, PerNs, Namespace}, ModuleScope, Resolution},\n     function::{Function, FnScopes},\n+    adt::{Struct, Enum},\n+    ty::Ty,\n };\n \n pub use self::function::FnSignatureInfo;\n@@ -56,7 +60,11 @@ ra_db::impl_numeric_id!(DefId);\n pub(crate) enum DefKind {\n     Module,\n     Function,\n+    Struct,\n+    Enum,\n     Item,\n+\n+    StructCtor,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n@@ -68,18 +76,18 @@ pub struct DefLoc {\n }\n \n impl DefKind {\n-    pub(crate) fn for_syntax_kind(kind: SyntaxKind) -> Option<DefKind> {\n+    pub(crate) fn for_syntax_kind(kind: SyntaxKind) -> PerNs<DefKind> {\n         match kind {\n-            SyntaxKind::FN_DEF => Some(DefKind::Function),\n-            SyntaxKind::MODULE => Some(DefKind::Module),\n+            SyntaxKind::FN_DEF => PerNs::values(DefKind::Function),\n+            SyntaxKind::MODULE => PerNs::types(DefKind::Module),\n+            SyntaxKind::STRUCT_DEF => PerNs::both(DefKind::Struct, DefKind::StructCtor),\n+            SyntaxKind::ENUM_DEF => PerNs::types(DefKind::Enum),\n             // These define items, but don't have their own DefKinds yet:\n-            SyntaxKind::STRUCT_DEF => Some(DefKind::Item),\n-            SyntaxKind::ENUM_DEF => Some(DefKind::Item),\n-            SyntaxKind::TRAIT_DEF => Some(DefKind::Item),\n-            SyntaxKind::TYPE_DEF => Some(DefKind::Item),\n-            SyntaxKind::CONST_DEF => Some(DefKind::Item),\n-            SyntaxKind::STATIC_DEF => Some(DefKind::Item),\n-            _ => None,\n+            SyntaxKind::TRAIT_DEF => PerNs::types(DefKind::Item),\n+            SyntaxKind::TYPE_DEF => PerNs::types(DefKind::Item),\n+            SyntaxKind::CONST_DEF => PerNs::values(DefKind::Item),\n+            SyntaxKind::STATIC_DEF => PerNs::values(DefKind::Item),\n+            _ => PerNs::none(),\n         }\n     }\n }\n@@ -99,6 +107,8 @@ impl DefLoc {\n pub enum Def {\n     Module(Module),\n     Function(Function),\n+    Struct(Struct),\n+    Enum(Enum),\n     Item,\n }\n \n@@ -114,10 +124,25 @@ impl DefId {\n                 let function = Function::new(self);\n                 Def::Function(function)\n             }\n+            DefKind::Struct => {\n+                let struct_def = Struct::new(self);\n+                Def::Struct(struct_def)\n+            }\n+            DefKind::Enum => {\n+                let enum_def = Enum::new(self);\n+                Def::Enum(enum_def)\n+            }\n+            DefKind::StructCtor => Def::Item,\n             DefKind::Item => Def::Item,\n         };\n         Ok(res)\n     }\n+\n+    /// For a module, returns that module; for any other def, returns the containing module.\n+    pub fn module(self, db: &impl HirDatabase) -> Cancelable<Module> {\n+        let loc = self.loc(db);\n+        Module::new(db, loc.source_root_id, loc.module_id)\n+    }\n }\n \n /// Identifier of item within a specific file. This is stable over reparses, so"}, {"sha": "f6882cb77198581660b452505f4d64f23c8f1e38", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -193,6 +193,9 @@ salsa::database_storage! {\n             fn submodules() for db::SubmodulesQuery;\n             fn infer() for db::InferQuery;\n             fn type_for_def() for db::TypeForDefQuery;\n+            fn type_for_field() for db::TypeForFieldQuery;\n+            fn struct_data() for db::StructDataQuery;\n+            fn enum_data() for db::EnumDataQuery;\n         }\n     }\n }"}, {"sha": "b9d36f01f0b3b1a567383ab1e7f068b94a9cf5b7", "filename": "crates/ra_hir/src/module.rs", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -17,7 +17,7 @@ use crate::{\n     arena::{Arena, Id},\n };\n \n-pub use self::nameres::{ModuleScope, Resolution};\n+pub use self::nameres::{ModuleScope, Resolution, Namespace, PerNs};\n \n /// `Module` is API entry point to get all the information\n /// about a particular module.\n@@ -115,37 +115,55 @@ impl Module {\n         Ok(res)\n     }\n \n-    pub fn resolve_path(&self, db: &impl HirDatabase, path: Path) -> Cancelable<Option<DefId>> {\n-        let mut curr = match path.kind {\n-            PathKind::Crate => self.crate_root(),\n-            PathKind::Self_ | PathKind::Plain => self.clone(),\n-            PathKind::Super => ctry!(self.parent()),\n-        }\n-        .def_id(db);\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> Cancelable<PerNs<DefId>> {\n+        let mut curr_per_ns = PerNs::types(\n+            match path.kind {\n+                PathKind::Crate => self.crate_root(),\n+                PathKind::Self_ | PathKind::Plain => self.clone(),\n+                PathKind::Super => {\n+                    if let Some(p) = self.parent() {\n+                        p\n+                    } else {\n+                        return Ok(PerNs::none());\n+                    }\n+                }\n+            }\n+            .def_id(db),\n+        );\n \n-        let segments = path.segments;\n+        let segments = &path.segments;\n         for name in segments.iter() {\n+            let curr = if let Some(r) = curr_per_ns.as_ref().take(Namespace::Types) {\n+                r\n+            } else {\n+                return Ok(PerNs::none());\n+            };\n             let module = match curr.loc(db) {\n                 DefLoc {\n                     kind: DefKind::Module,\n                     source_root_id,\n                     module_id,\n                     ..\n                 } => Module::new(db, source_root_id, module_id)?,\n-                _ => return Ok(None),\n+                // TODO here would be the place to handle enum variants...\n+                _ => return Ok(PerNs::none()),\n             };\n             let scope = module.scope(db)?;\n-            curr = ctry!(ctry!(scope.get(&name)).def_id);\n+            curr_per_ns = if let Some(r) = scope.get(&name) {\n+                r.def_id\n+            } else {\n+                return Ok(PerNs::none());\n+            };\n         }\n-        Ok(Some(curr))\n+        Ok(curr_per_ns)\n     }\n \n     pub fn problems(&self, db: &impl HirDatabase) -> Vec<(SyntaxNode, Problem)> {\n         self.module_id.problems(&self.tree, db)\n     }\n }\n \n-/// Phisically, rust source is organized as a set of files, but logically it is\n+/// Physically, rust source is organized as a set of files, but logically it is\n /// organized as a tree of modules. Usually, a single file corresponds to a\n /// single module, but it is not nessary the case.\n ///"}, {"sha": "98cd225ddec5622583fdd098d4bac6738a1c6b2f", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 118, "deletions": 36, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -118,22 +118,96 @@ enum ImportKind {\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Resolution {\n     /// None for unresolved\n-    pub def_id: Option<DefId>,\n+    pub def_id: PerNs<DefId>,\n     /// ident by whitch this is imported into local scope.\n     pub import: Option<NamedImport>,\n }\n \n-// #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-// enum Namespace {\n-//     Types,\n-//     Values,\n-// }\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum Namespace {\n+    Types,\n+    Values,\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct PerNs<T> {\n+    pub types: Option<T>,\n+    pub values: Option<T>,\n+}\n+\n+impl<T> PerNs<T> {\n+    pub fn none() -> PerNs<T> {\n+        PerNs {\n+            types: None,\n+            values: None,\n+        }\n+    }\n+\n+    pub fn values(t: T) -> PerNs<T> {\n+        PerNs {\n+            types: None,\n+            values: Some(t),\n+        }\n+    }\n+\n+    pub fn types(t: T) -> PerNs<T> {\n+        PerNs {\n+            types: Some(t),\n+            values: None,\n+        }\n+    }\n+\n+    pub fn both(types: T, values: T) -> PerNs<T> {\n+        PerNs {\n+            types: Some(types),\n+            values: Some(values),\n+        }\n+    }\n+\n+    pub fn is_none(&self) -> bool {\n+        self.types.is_none() && self.values.is_none()\n+    }\n+\n+    pub fn take(self, namespace: Namespace) -> Option<T> {\n+        match namespace {\n+            Namespace::Types => self.types,\n+            Namespace::Values => self.values,\n+        }\n+    }\n+\n+    pub fn take_types(self) -> Option<T> {\n+        self.types\n+    }\n+\n+    pub fn take_values(self) -> Option<T> {\n+        self.values\n+    }\n \n-// #[derive(Debug)]\n-// struct PerNs<T> {\n-//     types: Option<T>,\n-//     values: Option<T>,\n-// }\n+    pub fn get(&self, namespace: Namespace) -> Option<&T> {\n+        self.as_ref().take(namespace)\n+    }\n+\n+    pub fn as_ref(&self) -> PerNs<&T> {\n+        PerNs {\n+            types: self.types.as_ref(),\n+            values: self.values.as_ref(),\n+        }\n+    }\n+\n+    pub fn and_then<U>(self, f: impl Fn(T) -> Option<U>) -> PerNs<U> {\n+        PerNs {\n+            types: self.types.and_then(&f),\n+            values: self.values.and_then(&f),\n+        }\n+    }\n+\n+    pub fn map<U>(self, f: impl Fn(T) -> U) -> PerNs<U> {\n+        PerNs {\n+            types: self.types.map(&f),\n+            values: self.values.map(&f),\n+        }\n+    }\n+}\n \n impl InputModuleItems {\n     pub(crate) fn new<'a>(\n@@ -254,7 +328,7 @@ where\n                 for dep in krate.dependencies(self.db) {\n                     if let Some(module) = dep.krate.root_module(self.db)? {\n                         let def_id = module.def_id(self.db);\n-                        self.add_module_item(&mut module_items, dep.name, def_id);\n+                        self.add_module_item(&mut module_items, dep.name, PerNs::types(def_id));\n                     }\n                 }\n             };\n@@ -265,7 +339,7 @@ where\n                     module_items.items.insert(\n                         name.clone(),\n                         Resolution {\n-                            def_id: None,\n+                            def_id: PerNs::none(),\n                             import: Some(import),\n                         },\n                     );\n@@ -277,18 +351,23 @@ where\n             if item.kind == MODULE {\n                 continue;\n             }\n-            let def_loc = DefLoc {\n-                kind: DefKind::for_syntax_kind(item.kind).unwrap_or(DefKind::Item),\n-                source_root_id: self.source_root,\n-                module_id,\n-                source_item_id: SourceItemId {\n-                    file_id,\n-                    item_id: Some(item.id),\n-                },\n-            };\n-            let def_id = def_loc.id(self.db);\n+            // depending on the item kind, the location can define something in\n+            // the values namespace, the types namespace, or both\n+            let kind = DefKind::for_syntax_kind(item.kind);\n+            let def_id = kind.map(|k| {\n+                let def_loc = DefLoc {\n+                    kind: k,\n+                    source_root_id: self.source_root,\n+                    module_id,\n+                    source_item_id: SourceItemId {\n+                        file_id,\n+                        item_id: Some(item.id),\n+                    },\n+                };\n+                def_loc.id(self.db)\n+            });\n             let resolution = Resolution {\n-                def_id: Some(def_id),\n+                def_id,\n                 import: None,\n             };\n             module_items.items.insert(item.name.clone(), resolution);\n@@ -303,16 +382,16 @@ where\n                 source_item_id: module_id.source(&self.module_tree).0,\n             };\n             let def_id = def_loc.id(self.db);\n-            self.add_module_item(&mut module_items, name, def_id);\n+            self.add_module_item(&mut module_items, name, PerNs::types(def_id));\n         }\n \n         self.result.per_module.insert(module_id, module_items);\n         Ok(())\n     }\n \n-    fn add_module_item(&self, module_items: &mut ModuleScope, name: SmolStr, def_id: DefId) {\n+    fn add_module_item(&self, module_items: &mut ModuleScope, name: SmolStr, def_id: PerNs<DefId>) {\n         let resolution = Resolution {\n-            def_id: Some(def_id),\n+            def_id,\n             import: None,\n         };\n         module_items.items.insert(name, resolution);\n@@ -347,15 +426,17 @@ where\n             let is_last = i == import.path.segments.len() - 1;\n \n             let def_id = match self.result.per_module[&curr].items.get(name) {\n-                None => return Ok(()),\n-                Some(res) => match res.def_id {\n-                    Some(it) => it,\n-                    None => return Ok(()),\n-                },\n+                Some(res) if !res.def_id.is_none() => res.def_id,\n+                _ => return Ok(()),\n             };\n \n             if !is_last {\n-                curr = match def_id.loc(self.db) {\n+                let type_def_id = if let Some(d) = def_id.take(Namespace::Types) {\n+                    d\n+                } else {\n+                    return Ok(());\n+                };\n+                curr = match type_def_id.loc(self.db) {\n                     DefLoc {\n                         kind: DefKind::Module,\n                         module_id: target_module_id,\n@@ -370,10 +451,11 @@ where\n                                 segments: import.path.segments[i + 1..].iter().cloned().collect(),\n                                 kind: PathKind::Crate,\n                             };\n-                            if let Some(def_id) = module.resolve_path(self.db, path)? {\n+                            let def_id = module.resolve_path(self.db, &path)?;\n+                            if !def_id.is_none() {\n                                 self.update(module_id, |items| {\n                                     let res = Resolution {\n-                                        def_id: Some(def_id),\n+                                        def_id: def_id,\n                                         import: Some(ptr),\n                                     };\n                                     items.items.insert(name.clone(), res);\n@@ -387,7 +469,7 @@ where\n             } else {\n                 self.update(module_id, |items| {\n                     let res = Resolution {\n-                        def_id: Some(def_id),\n+                        def_id: def_id,\n                         import: Some(ptr),\n                     };\n                     items.items.insert(name.clone(), res);"}, {"sha": "03ea5c1d6c0ee474a07becefcab8a99d22fb7e3b", "filename": "crates/ra_hir/src/module/nameres/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -40,7 +40,7 @@ fn item_map_smoke_test() {\n     );\n     let name = SmolStr::from(\"Baz\");\n     let resolution = &item_map.per_module[&module_id].items[&name];\n-    assert!(resolution.def_id.is_some());\n+    assert!(resolution.def_id.take_types().is_some());\n }\n \n #[test]\n@@ -59,7 +59,7 @@ fn test_self() {\n     );\n     let name = SmolStr::from(\"Baz\");\n     let resolution = &item_map.per_module[&module_id].items[&name];\n-    assert!(resolution.def_id.is_some());\n+    assert!(resolution.def_id.take_types().is_some());\n }\n \n #[test]\n@@ -92,7 +92,7 @@ fn item_map_across_crates() {\n \n     let name = SmolStr::from(\"Baz\");\n     let resolution = &item_map.per_module[&module_id].items[&name];\n-    assert!(resolution.def_id.is_some());\n+    assert!(resolution.def_id.take_types().is_some());\n }\n \n #[test]"}, {"sha": "0b260072cc26ad80e6181e7518c5f1e2f948dc96", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -1,12 +1,12 @@\n use ra_syntax::{SmolStr, ast, AstNode, TextRange};\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     pub kind: PathKind,\n     pub segments: Vec<SmolStr>,\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum PathKind {\n     Plain,\n     Self_,"}, {"sha": "4a7958a1224ef7c16e1b2362fd7ebe1ff42e082f", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -19,7 +19,8 @@ use crate::{\n         imp::Submodule,\n         nameres::{InputModuleItems, ItemMap, Resolver},\n     },\n-    ty::{self, InferenceResult, Ty}\n+    ty::{self, InferenceResult, Ty},\n+    adt::{StructData, EnumData},\n };\n \n /// Resolve `FnId` to the corresponding `SyntaxNode`\n@@ -45,6 +46,32 @@ pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<T\n     ty::type_for_def(db, def_id)\n }\n \n+pub(super) fn type_for_field(\n+    db: &impl HirDatabase,\n+    def_id: DefId,\n+    field: SmolStr,\n+) -> Cancelable<Ty> {\n+    ty::type_for_field(db, def_id, field)\n+}\n+\n+pub(super) fn struct_data(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<StructData>> {\n+    let def_loc = def_id.loc(db);\n+    assert!(def_loc.kind == DefKind::Struct);\n+    let syntax = db.file_item(def_loc.source_item_id);\n+    let struct_def =\n+        ast::StructDef::cast(syntax.borrowed()).expect(\"struct def should point to StructDef node\");\n+    Ok(Arc::new(StructData::new(struct_def.borrowed())))\n+}\n+\n+pub(super) fn enum_data(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<EnumData>> {\n+    let def_loc = def_id.loc(db);\n+    assert!(def_loc.kind == DefKind::Enum);\n+    let syntax = db.file_item(def_loc.source_item_id);\n+    let enum_def =\n+        ast::EnumDef::cast(syntax.borrowed()).expect(\"enum def should point to EnumDef node\");\n+    Ok(Arc::new(EnumData::new(enum_def.borrowed())))\n+}\n+\n pub(super) fn file_items(db: &impl HirDatabase, file_id: FileId) -> Arc<SourceFileItems> {\n     let mut res = SourceFileItems::new(file_id);\n     let source_file = db.source_file(file_id);"}, {"sha": "67b523c2cc507d9b8392790a7b87203515847711", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 271, "deletions": 177, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -11,13 +11,18 @@ use rustc_hash::{FxHashMap};\n use ra_db::{LocalSyntaxPtr, Cancelable};\n use ra_syntax::{\n     SmolStr,\n-    ast::{self, AstNode, LoopBodyOwner, ArgListOwner},\n+    ast::{self, AstNode, LoopBodyOwner, ArgListOwner, PrefixOp},\n     SyntaxNodeRef\n };\n \n-use crate::{Def, DefId, FnScopes, Module, Function, Path, db::HirDatabase};\n+use crate::{\n+    Def, DefId, FnScopes, Module, Function, Struct, Enum, Path,\n+    db::HirDatabase,\n+    adt::VariantData,\n+    type_ref::{TypeRef, Mutability},\n+};\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Ty {\n     /// The primitive boolean type. Written as `bool`.\n     Bool,\n@@ -35,8 +40,15 @@ pub enum Ty {\n     /// A primitive floating-point type. For example, `f64`.\n     Float(primitive::FloatTy),\n \n-    // Structures, enumerations and unions.\n-    // Adt(AdtDef, Substs),\n+    /// Structures, enumerations and unions.\n+    Adt {\n+        /// The DefId of the struct/enum.\n+        def_id: DefId,\n+        /// The name, for displaying.\n+        name: SmolStr,\n+        // later we'll need generic substitutions here\n+    },\n+\n     /// The pointee of a string slice. Written as `str`.\n     Str,\n \n@@ -45,12 +57,13 @@ pub enum Ty {\n     /// The pointee of an array slice.  Written as `[T]`.\n     Slice(TyRef),\n \n-    // A raw pointer. Written as `*mut T` or `*const T`\n-    // RawPtr(TypeAndMut<'tcx>),\n+    /// A raw pointer. Written as `*mut T` or `*const T`\n+    RawPtr(TyRef, Mutability),\n+\n+    /// A reference; a pointer with an associated lifetime. Written as\n+    /// `&'a mut T` or `&'a T`.\n+    Ref(TyRef, Mutability),\n \n-    // A reference; a pointer with an associated lifetime. Written as\n-    // `&'a mut T` or `&'a T`.\n-    // Ref(Ty<'tcx>, hir::Mutability),\n     /// A pointer to a function.  Written as `fn() -> i32`.\n     ///\n     /// For example the type of `bar` here:\n@@ -107,58 +120,104 @@ pub enum Ty {\n \n type TyRef = Arc<Ty>;\n \n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct FnSig {\n     input: Vec<Ty>,\n     output: Ty,\n }\n \n impl Ty {\n-    pub fn new(_db: &impl HirDatabase, node: ast::TypeRef) -> Cancelable<Self> {\n-        use ra_syntax::ast::TypeRef::*;\n-        Ok(match node {\n-            ParenType(_inner) => Ty::Unknown, // TODO\n-            TupleType(_inner) => Ty::Unknown, // TODO\n-            NeverType(..) => Ty::Never,\n-            PathType(inner) => {\n-                let path = if let Some(p) = inner.path() {\n-                    p\n-                } else {\n-                    return Ok(Ty::Unknown);\n+    pub(crate) fn from_hir(\n+        db: &impl HirDatabase,\n+        module: &Module,\n+        type_ref: &TypeRef,\n+    ) -> Cancelable<Self> {\n+        Ok(match type_ref {\n+            TypeRef::Never => Ty::Never,\n+            TypeRef::Tuple(inner) => {\n+                let inner_tys = inner\n+                    .iter()\n+                    .map(|tr| Ty::from_hir(db, module, tr))\n+                    .collect::<Cancelable<_>>()?;\n+                Ty::Tuple(inner_tys)\n+            }\n+            TypeRef::Path(path) => Ty::from_hir_path(db, module, path)?,\n+            TypeRef::RawPtr(inner, mutability) => {\n+                let inner_ty = Ty::from_hir(db, module, inner)?;\n+                Ty::RawPtr(Arc::new(inner_ty), *mutability)\n+            }\n+            TypeRef::Array(_inner) => Ty::Unknown, // TODO\n+            TypeRef::Slice(inner) => {\n+                let inner_ty = Ty::from_hir(db, module, inner)?;\n+                Ty::Slice(Arc::new(inner_ty))\n+            }\n+            TypeRef::Reference(inner, mutability) => {\n+                let inner_ty = Ty::from_hir(db, module, inner)?;\n+                Ty::Ref(Arc::new(inner_ty), *mutability)\n+            }\n+            TypeRef::Placeholder => Ty::Unknown, // TODO\n+            TypeRef::Fn(params) => {\n+                let mut inner_tys = params\n+                    .iter()\n+                    .map(|tr| Ty::from_hir(db, module, tr))\n+                    .collect::<Cancelable<Vec<_>>>()?;\n+                let return_ty = inner_tys\n+                    .pop()\n+                    .expect(\"TypeRef::Fn should always have at least return type\");\n+                let sig = FnSig {\n+                    input: inner_tys,\n+                    output: return_ty,\n                 };\n-                if path.qualifier().is_none() {\n-                    let name = path\n-                        .segment()\n-                        .and_then(|s| s.name_ref())\n-                        .map(|n| n.text())\n-                        .unwrap_or(SmolStr::new(\"\"));\n-                    if let Some(int_ty) = primitive::IntTy::from_string(&name) {\n-                        Ty::Int(int_ty)\n-                    } else if let Some(uint_ty) = primitive::UintTy::from_string(&name) {\n-                        Ty::Uint(uint_ty)\n-                    } else if let Some(float_ty) = primitive::FloatTy::from_string(&name) {\n-                        Ty::Float(float_ty)\n-                    } else {\n-                        // TODO\n-                        Ty::Unknown\n-                    }\n-                } else {\n-                    // TODO\n-                    Ty::Unknown\n-                }\n+                Ty::FnPtr(Arc::new(sig))\n             }\n-            PointerType(_inner) => Ty::Unknown,     // TODO\n-            ArrayType(_inner) => Ty::Unknown,       // TODO\n-            SliceType(_inner) => Ty::Unknown,       // TODO\n-            ReferenceType(_inner) => Ty::Unknown,   // TODO\n-            PlaceholderType(_inner) => Ty::Unknown, // TODO\n-            FnPointerType(_inner) => Ty::Unknown,   // TODO\n-            ForType(_inner) => Ty::Unknown,         // TODO\n-            ImplTraitType(_inner) => Ty::Unknown,   // TODO\n-            DynTraitType(_inner) => Ty::Unknown,    // TODO\n+            TypeRef::Error => Ty::Unknown,\n         })\n     }\n \n+    pub(crate) fn from_hir_path(\n+        db: &impl HirDatabase,\n+        module: &Module,\n+        path: &Path,\n+    ) -> Cancelable<Self> {\n+        if path.is_ident() {\n+            let name = &path.segments[0];\n+            if let Some(int_ty) = primitive::IntTy::from_string(&name) {\n+                return Ok(Ty::Int(int_ty));\n+            } else if let Some(uint_ty) = primitive::UintTy::from_string(&name) {\n+                return Ok(Ty::Uint(uint_ty));\n+            } else if let Some(float_ty) = primitive::FloatTy::from_string(&name) {\n+                return Ok(Ty::Float(float_ty));\n+            }\n+        }\n+\n+        // Resolve in module (in type namespace)\n+        let resolved = if let Some(r) = module.resolve_path(db, path)?.take_types() {\n+            r\n+        } else {\n+            return Ok(Ty::Unknown);\n+        };\n+        let ty = db.type_for_def(resolved)?;\n+        Ok(ty)\n+    }\n+\n+    // TODO: These should not be necessary long-term, since everything will work on HIR\n+    pub(crate) fn from_ast_opt(\n+        db: &impl HirDatabase,\n+        module: &Module,\n+        node: Option<ast::TypeRef>,\n+    ) -> Cancelable<Self> {\n+        node.map(|n| Ty::from_ast(db, module, n))\n+            .unwrap_or(Ok(Ty::Unknown))\n+    }\n+\n+    pub(crate) fn from_ast(\n+        db: &impl HirDatabase,\n+        module: &Module,\n+        node: ast::TypeRef,\n+    ) -> Cancelable<Self> {\n+        Ty::from_hir(db, module, &TypeRef::from_ast(node))\n+    }\n+\n     pub fn unit() -> Self {\n         Ty::Tuple(Vec::new())\n     }\n@@ -174,6 +233,8 @@ impl fmt::Display for Ty {\n             Ty::Float(t) => write!(f, \"{}\", t.ty_to_string()),\n             Ty::Str => write!(f, \"str\"),\n             Ty::Slice(t) => write!(f, \"[{}]\", t),\n+            Ty::RawPtr(t, m) => write!(f, \"*{}{}\", m.as_keyword_for_ptr(), t),\n+            Ty::Ref(t, m) => write!(f, \"&{}{}\", m.as_keyword_for_ref(), t),\n             Ty::Never => write!(f, \"!\"),\n             Ty::Tuple(ts) => {\n                 write!(f, \"(\")?;\n@@ -189,41 +250,48 @@ impl fmt::Display for Ty {\n                 }\n                 write!(f, \") -> {}\", sig.output)\n             }\n+            Ty::Adt { name, .. } => write!(f, \"{}\", name),\n             Ty::Unknown => write!(f, \"[unknown]\"),\n         }\n     }\n }\n \n pub fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n     let syntax = f.syntax(db);\n+    let module = f.module(db)?;\n     let node = syntax.borrowed();\n     // TODO we ignore type parameters for now\n     let input = node\n         .param_list()\n         .map(|pl| {\n             pl.params()\n-                .map(|p| {\n-                    p.type_ref()\n-                        .map(|t| Ty::new(db, t))\n-                        .unwrap_or(Ok(Ty::Unknown))\n-                })\n+                .map(|p| Ty::from_ast_opt(db, &module, p.type_ref()))\n                 .collect()\n         })\n         .unwrap_or_else(|| Ok(Vec::new()))?;\n-    let output = node\n-        .ret_type()\n-        .and_then(|rt| rt.type_ref())\n-        .map(|t| Ty::new(db, t))\n-        .unwrap_or(Ok(Ty::Unknown))?;\n+    let output = Ty::from_ast_opt(db, &module, node.ret_type().and_then(|rt| rt.type_ref()))?;\n     let sig = FnSig { input, output };\n     Ok(Ty::FnPtr(Arc::new(sig)))\n }\n \n-// TODO this should probably be per namespace (i.e. types vs. values), since for\n-// a tuple struct `struct Foo(Bar)`, Foo has function type as a value, but\n-// defines the struct type Foo when used in the type namespace. rustc has a\n-// separate DefId for the constructor, but with the current DefId approach, that\n-// seems complicated.\n+pub fn type_for_struct(db: &impl HirDatabase, s: Struct) -> Cancelable<Ty> {\n+    Ok(Ty::Adt {\n+        def_id: s.def_id(),\n+        name: s\n+            .name(db)?\n+            .unwrap_or_else(|| SmolStr::new(\"[unnamed struct]\")),\n+    })\n+}\n+\n+pub fn type_for_enum(db: &impl HirDatabase, s: Enum) -> Cancelable<Ty> {\n+    Ok(Ty::Adt {\n+        def_id: s.def_id(),\n+        name: s\n+            .name(db)?\n+            .unwrap_or_else(|| SmolStr::new(\"[unnamed enum]\")),\n+    })\n+}\n+\n pub fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n     let def = def_id.resolve(db)?;\n     match def {\n@@ -232,13 +300,42 @@ pub fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n             Ok(Ty::Unknown)\n         }\n         Def::Function(f) => type_for_fn(db, f),\n+        Def::Struct(s) => type_for_struct(db, s),\n+        Def::Enum(e) => type_for_enum(db, e),\n         Def::Item => {\n             log::debug!(\"trying to get type for item of unknown type {:?}\", def_id);\n             Ok(Ty::Unknown)\n         }\n     }\n }\n \n+pub(super) fn type_for_field(\n+    db: &impl HirDatabase,\n+    def_id: DefId,\n+    field: SmolStr,\n+) -> Cancelable<Ty> {\n+    let def = def_id.resolve(db)?;\n+    let variant_data = match def {\n+        Def::Struct(s) => {\n+            let variant_data = s.variant_data(db)?;\n+            variant_data\n+        }\n+        // TODO: unions\n+        // TODO: enum variants\n+        _ => panic!(\n+            \"trying to get type for field in non-struct/variant {:?}\",\n+            def_id\n+        ),\n+    };\n+    let module = def_id.module(db)?;\n+    let type_ref = if let Some(tr) = variant_data.get_field_type_ref(&field) {\n+        tr\n+    } else {\n+        return Ok(Ty::Unknown);\n+    };\n+    Ty::from_hir(db, &module, &type_ref)\n+}\n+\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n     type_of: FxHashMap<LocalSyntaxPtr, Ty>,\n@@ -305,95 +402,92 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n \n         // resolve in module\n-        let resolved = ctry!(self.module.resolve_path(self.db, path)?);\n+        let resolved = ctry!(self.module.resolve_path(self.db, &path)?.take_values());\n         let ty = self.db.type_for_def(resolved)?;\n         // TODO we will need to add type variables for type parameters etc. here\n         Ok(Some(ty))\n     }\n \n+    fn resolve_variant(\n+        &self,\n+        path: Option<ast::Path>,\n+    ) -> Cancelable<(Ty, Option<Arc<VariantData>>)> {\n+        let path = if let Some(path) = path.and_then(Path::from_ast) {\n+            path\n+        } else {\n+            return Ok((Ty::Unknown, None));\n+        };\n+        let def_id = if let Some(def_id) = self.module.resolve_path(self.db, &path)?.take_types() {\n+            def_id\n+        } else {\n+            return Ok((Ty::Unknown, None));\n+        };\n+        Ok(match def_id.resolve(self.db)? {\n+            Def::Struct(s) => {\n+                let struct_data = self.db.struct_data(def_id)?;\n+                let ty = type_for_struct(self.db, s)?;\n+                (ty, Some(struct_data.variant_data().clone()))\n+            }\n+            _ => (Ty::Unknown, None),\n+        })\n+    }\n+\n+    fn infer_expr_opt(&mut self, expr: Option<ast::Expr>) -> Cancelable<Ty> {\n+        if let Some(e) = expr {\n+            self.infer_expr(e)\n+        } else {\n+            Ok(Ty::Unknown)\n+        }\n+    }\n+\n     fn infer_expr(&mut self, expr: ast::Expr) -> Cancelable<Ty> {\n         let ty = match expr {\n             ast::Expr::IfExpr(e) => {\n                 if let Some(condition) = e.condition() {\n-                    if let Some(e) = condition.expr() {\n-                        // TODO if no pat, this should be bool\n-                        self.infer_expr(e)?;\n-                    }\n+                    // TODO if no pat, this should be bool\n+                    self.infer_expr_opt(condition.expr())?;\n                     // TODO write type for pat\n                 };\n-                let if_ty = if let Some(block) = e.then_branch() {\n-                    self.infer_block(block)?\n-                } else {\n-                    Ty::Unknown\n-                };\n-                let else_ty = if let Some(block) = e.else_branch() {\n-                    self.infer_block(block)?\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let if_ty = self.infer_block_opt(e.then_branch())?;\n+                let else_ty = self.infer_block_opt(e.else_branch())?;\n                 if let Some(ty) = self.unify(&if_ty, &else_ty) {\n                     ty\n                 } else {\n                     // TODO report diagnostic\n                     Ty::Unknown\n                 }\n             }\n-            ast::Expr::BlockExpr(e) => {\n-                if let Some(block) = e.block() {\n-                    self.infer_block(block)?\n-                } else {\n-                    Ty::Unknown\n-                }\n-            }\n+            ast::Expr::BlockExpr(e) => self.infer_block_opt(e.block())?,\n             ast::Expr::LoopExpr(e) => {\n-                if let Some(block) = e.loop_body() {\n-                    self.infer_block(block)?;\n-                };\n+                self.infer_block_opt(e.loop_body())?;\n                 // TODO never, or the type of the break param\n                 Ty::Unknown\n             }\n             ast::Expr::WhileExpr(e) => {\n                 if let Some(condition) = e.condition() {\n-                    if let Some(e) = condition.expr() {\n-                        // TODO if no pat, this should be bool\n-                        self.infer_expr(e)?;\n-                    }\n+                    // TODO if no pat, this should be bool\n+                    self.infer_expr_opt(condition.expr())?;\n                     // TODO write type for pat\n                 };\n-                if let Some(block) = e.loop_body() {\n-                    // TODO\n-                    self.infer_block(block)?;\n-                };\n+                self.infer_block_opt(e.loop_body())?;\n                 // TODO always unit?\n                 Ty::Unknown\n             }\n             ast::Expr::ForExpr(e) => {\n-                if let Some(expr) = e.iterable() {\n-                    self.infer_expr(expr)?;\n-                }\n+                let _iterable_ty = self.infer_expr_opt(e.iterable());\n                 if let Some(_pat) = e.pat() {\n                     // TODO write type for pat\n                 }\n-                if let Some(block) = e.loop_body() {\n-                    self.infer_block(block)?;\n-                }\n+                self.infer_block_opt(e.loop_body())?;\n                 // TODO always unit?\n                 Ty::Unknown\n             }\n             ast::Expr::LambdaExpr(e) => {\n-                let _body_ty = if let Some(body) = e.body() {\n-                    self.infer_expr(body)?\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let _body_ty = self.infer_expr_opt(e.body())?;\n                 Ty::Unknown\n             }\n             ast::Expr::CallExpr(e) => {\n-                let callee_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)?\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let callee_ty = self.infer_expr_opt(e.expr())?;\n                 if let Some(arg_list) = e.arg_list() {\n                     for arg in arg_list.args() {\n                         // TODO unify / expect argument type\n@@ -410,11 +504,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 }\n             }\n             ast::Expr::MethodCallExpr(e) => {\n-                let _receiver_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)?\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let _receiver_ty = self.infer_expr_opt(e.expr())?;\n                 if let Some(arg_list) = e.arg_list() {\n                     for arg in arg_list.args() {\n                         // TODO unify / expect argument type\n@@ -424,20 +514,12 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 Ty::Unknown\n             }\n             ast::Expr::MatchExpr(e) => {\n-                let _ty = if let Some(match_expr) = e.expr() {\n-                    self.infer_expr(match_expr)?\n-                } else {\n-                    Ty::Unknown\n-                };\n+                let _ty = self.infer_expr_opt(e.expr())?;\n                 if let Some(match_arm_list) = e.match_arm_list() {\n                     for arm in match_arm_list.arms() {\n                         // TODO type the bindings in pat\n                         // TODO type the guard\n-                        let _ty = if let Some(e) = arm.expr() {\n-                            self.infer_expr(e)?\n-                        } else {\n-                            Ty::Unknown\n-                        };\n+                        let _ty = self.infer_expr_opt(arm.expr())?;\n                     }\n                     // TODO unify all the match arm types\n                     Ty::Unknown\n@@ -450,68 +532,78 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             ast::Expr::PathExpr(e) => self.infer_path_expr(e)?.unwrap_or(Ty::Unknown),\n             ast::Expr::ContinueExpr(_e) => Ty::Never,\n             ast::Expr::BreakExpr(_e) => Ty::Never,\n-            ast::Expr::ParenExpr(e) => {\n-                if let Some(e) = e.expr() {\n-                    self.infer_expr(e)?\n-                } else {\n-                    Ty::Unknown\n-                }\n-            }\n+            ast::Expr::ParenExpr(e) => self.infer_expr_opt(e.expr())?,\n             ast::Expr::Label(_e) => Ty::Unknown,\n             ast::Expr::ReturnExpr(e) => {\n-                if let Some(e) = e.expr() {\n-                    // TODO unify with return type\n-                    self.infer_expr(e)?;\n-                };\n+                self.infer_expr_opt(e.expr())?;\n                 Ty::Never\n             }\n             ast::Expr::MatchArmList(_) | ast::Expr::MatchArm(_) | ast::Expr::MatchGuard(_) => {\n                 // Can this even occur outside of a match expression?\n                 Ty::Unknown\n             }\n-            ast::Expr::StructLit(_e) => Ty::Unknown,\n+            ast::Expr::StructLit(e) => {\n+                let (ty, _variant_data) = self.resolve_variant(e.path())?;\n+                if let Some(nfl) = e.named_field_list() {\n+                    for field in nfl.fields() {\n+                        // TODO unify with / expect field type\n+                        self.infer_expr_opt(field.expr())?;\n+                    }\n+                }\n+                ty\n+            }\n             ast::Expr::NamedFieldList(_) | ast::Expr::NamedField(_) => {\n                 // Can this even occur outside of a struct literal?\n                 Ty::Unknown\n             }\n             ast::Expr::IndexExpr(_e) => Ty::Unknown,\n-            ast::Expr::FieldExpr(_e) => Ty::Unknown,\n-            ast::Expr::TryExpr(e) => {\n-                let _inner_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)?\n+            ast::Expr::FieldExpr(e) => {\n+                let receiver_ty = self.infer_expr_opt(e.expr())?;\n+                if let Some(nr) = e.name_ref() {\n+                    let text = nr.text();\n+                    match receiver_ty {\n+                        Ty::Tuple(fields) => {\n+                            let i = text.parse::<usize>().ok();\n+                            i.and_then(|i| fields.get(i).cloned())\n+                                .unwrap_or(Ty::Unknown)\n+                        }\n+                        Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, text)?,\n+                        _ => Ty::Unknown,\n+                    }\n                 } else {\n                     Ty::Unknown\n-                };\n+                }\n+            }\n+            ast::Expr::TryExpr(e) => {\n+                let _inner_ty = self.infer_expr_opt(e.expr())?;\n                 Ty::Unknown\n             }\n             ast::Expr::CastExpr(e) => {\n-                let _inner_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)?\n-                } else {\n-                    Ty::Unknown\n-                };\n-                let cast_ty = e\n-                    .type_ref()\n-                    .map(|t| Ty::new(self.db, t))\n-                    .unwrap_or(Ok(Ty::Unknown))?;\n+                let _inner_ty = self.infer_expr_opt(e.expr())?;\n+                let cast_ty = Ty::from_ast_opt(self.db, &self.module, e.type_ref())?;\n                 // TODO do the coercion...\n                 cast_ty\n             }\n             ast::Expr::RefExpr(e) => {\n-                let _inner_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)?\n-                } else {\n-                    Ty::Unknown\n-                };\n-                Ty::Unknown\n+                let inner_ty = self.infer_expr_opt(e.expr())?;\n+                let m = Mutability::from_mutable(e.is_mut());\n+                // TODO reference coercions etc.\n+                Ty::Ref(Arc::new(inner_ty), m)\n             }\n             ast::Expr::PrefixExpr(e) => {\n-                let _inner_ty = if let Some(e) = e.expr() {\n-                    self.infer_expr(e)?\n-                } else {\n-                    Ty::Unknown\n-                };\n-                Ty::Unknown\n+                let inner_ty = self.infer_expr_opt(e.expr())?;\n+                match e.op() {\n+                    Some(PrefixOp::Deref) => {\n+                        match inner_ty {\n+                            // builtin deref:\n+                            Ty::Ref(ref_inner, _) => (*ref_inner).clone(),\n+                            Ty::RawPtr(ptr_inner, _) => (*ptr_inner).clone(),\n+                            // TODO Deref::deref\n+                            _ => Ty::Unknown,\n+                        }\n+                    }\n+                    _ => Ty::Unknown,\n+                }\n             }\n             ast::Expr::RangeExpr(_e) => Ty::Unknown,\n             ast::Expr::BinExpr(_e) => Ty::Unknown,\n@@ -521,15 +613,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         Ok(ty)\n     }\n \n+    fn infer_block_opt(&mut self, node: Option<ast::Block>) -> Cancelable<Ty> {\n+        if let Some(b) = node {\n+            self.infer_block(b)\n+        } else {\n+            Ok(Ty::Unknown)\n+        }\n+    }\n+\n     fn infer_block(&mut self, node: ast::Block) -> Cancelable<Ty> {\n         for stmt in node.statements() {\n             match stmt {\n                 ast::Stmt::LetStmt(stmt) => {\n-                    let decl_ty = if let Some(type_ref) = stmt.type_ref() {\n-                        Ty::new(self.db, type_ref)?\n-                    } else {\n-                        Ty::Unknown\n-                    };\n+                    let decl_ty = Ty::from_ast_opt(self.db, &self.module, stmt.type_ref())?;\n                     let ty = if let Some(expr) = stmt.initializer() {\n                         // TODO pass expectation\n                         let expr_ty = self.infer_expr(expr)?;\n@@ -544,9 +640,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     };\n                 }\n                 ast::Stmt::ExprStmt(expr_stmt) => {\n-                    if let Some(expr) = expr_stmt.expr() {\n-                        self.infer_expr(expr)?;\n-                    }\n+                    self.infer_expr_opt(expr_stmt.expr())?;\n                 }\n             }\n         }\n@@ -576,7 +670,7 @@ pub fn infer(db: &impl HirDatabase, function: Function) -> Cancelable<InferenceR\n                 continue;\n             };\n             if let Some(type_ref) = param.type_ref() {\n-                let ty = Ty::new(db, type_ref)?;\n+                let ty = Ty::from_ast(db, &ctx.module, type_ref)?;\n                 ctx.type_of.insert(LocalSyntaxPtr::new(pat.syntax()), ty);\n             } else {\n                 // TODO self param"}, {"sha": "a76925b58ee130f27df0c6f011b23f5d71322fee", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -68,6 +68,51 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn infer_struct() {\n+    check_inference(\n+        r#\"\n+struct A {\n+    b: B,\n+    c: C,\n+}\n+struct B;\n+struct C(usize);\n+\n+fn test() {\n+    let c = C(1);\n+    B;\n+    let a: A = A { b: B, c: C(1) };\n+    a.b;\n+    a.c;\n+}\n+\"#,\n+        \"0004_struct.txt\",\n+    );\n+}\n+\n+#[test]\n+fn infer_refs_and_ptrs() {\n+    check_inference(\n+        r#\"\n+fn test(a: &u32, b: &mut u32, c: *const u32, d: *mut u32) {\n+    a;\n+    *a;\n+    &a;\n+    &mut a;\n+    b;\n+    *b;\n+    &b;\n+    c;\n+    *c;\n+    d;\n+    *d;\n+}\n+\"#,\n+        \"0005_refs.txt\",\n+    );\n+}\n+\n fn infer(content: &str) -> String {\n     let (db, _, file_id) = MockDatabase::with_single_file(content);\n     let source_file = db.source_file(file_id);"}, {"sha": "212e92e0008a6b21573a3a9bcbc48c0733f52e80", "filename": "crates/ra_hir/src/ty/tests/data/0001_basics.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.txt?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -1,4 +1,4 @@\n-[33; 34) 'd': [unknown]\n+[33; 34) 'd': &[unknown]\n [88; 94) '1isize': [unknown]\n [48; 49) 'a': u32\n [55; 56) 'b': isize\n@@ -10,4 +10,4 @@\n [17; 18) 'b': isize\n [100; 106) '\"test\"': [unknown]\n [42; 121) '{     ...f32; }': ()\n-[69; 70) 'd': [unknown]\n+[69; 70) 'd': &[unknown]"}, {"sha": "cc8f3665bf6354c974e7a71ab91b55412c66484a", "filename": "crates/ra_hir/src/ty/tests/data/0004_struct.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -0,0 +1,16 @@\n+[86; 90) 'C(1)': [unknown]\n+[121; 122) 'B': [unknown]\n+[86; 87) 'C': [unknown]\n+[129; 130) '1': [unknown]\n+[107; 108) 'a': A\n+[127; 128) 'C': [unknown]\n+[139; 142) 'a.b': B\n+[114; 133) 'A { b:...C(1) }': A\n+[148; 151) 'a.c': C\n+[148; 149) 'a': A\n+[139; 140) 'a': A\n+[72; 154) '{     ...a.c; }': ()\n+[96; 97) 'B': [unknown]\n+[88; 89) '1': [unknown]\n+[82; 83) 'c': [unknown]\n+[127; 131) 'C(1)': [unknown]"}, {"sha": "296e955c19ef919775acebfecce11c4da533cda1", "filename": "crates/ra_hir/src/ty/tests/data/0005_refs.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0005_refs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0005_refs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0005_refs.txt?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -0,0 +1,23 @@\n+[115; 117) '&b': &&mut u32\n+[88; 94) '&mut a': &mut &u32\n+[146; 147) 'd': *mut u32\n+[145; 147) '*d': u32\n+[65; 66) 'a': &u32\n+[46; 47) 'd': *mut u32\n+[59; 150) '{     ... *d; }': ()\n+[116; 117) 'b': &mut u32\n+[131; 132) 'c': *const u32\n+[130; 132) '*c': u32\n+[72; 74) '*a': u32\n+[107; 109) '*b': u32\n+[108; 109) 'b': &mut u32\n+[9; 10) 'a': &u32\n+[18; 19) 'b': &mut u32\n+[93; 94) 'a': &u32\n+[100; 101) 'b': &mut u32\n+[81; 82) 'a': &u32\n+[80; 82) '&a': &&u32\n+[73; 74) 'a': &u32\n+[123; 124) 'c': *const u32\n+[31; 32) 'c': *const u32\n+[138; 139) 'd': *mut u32"}, {"sha": "b36bb35d89414da38b2d83c051d6be82e570541f", "filename": "crates/ra_hir/src/type_ref.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -0,0 +1,110 @@\n+//! HIR for references to types. Paths in these are not yet resolved. They can\n+//! be directly created from an ast::TypeRef, without further queries.\n+\n+use ra_syntax::ast;\n+\n+use crate::Path;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum Mutability {\n+    Shared,\n+    Mut,\n+}\n+\n+impl Mutability {\n+    pub fn from_mutable(mutable: bool) -> Mutability {\n+        if mutable {\n+            Mutability::Mut\n+        } else {\n+            Mutability::Shared\n+        }\n+    }\n+\n+    pub fn as_keyword_for_ref(self) -> &'static str {\n+        match self {\n+            Mutability::Shared => \"\",\n+            Mutability::Mut => \"mut \",\n+        }\n+    }\n+\n+    pub fn as_keyword_for_ptr(self) -> &'static str {\n+        match self {\n+            Mutability::Shared => \"const \",\n+            Mutability::Mut => \"mut \",\n+        }\n+    }\n+}\n+\n+/// Compare ty::Ty\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum TypeRef {\n+    Never,\n+    Placeholder,\n+    Tuple(Vec<TypeRef>),\n+    Path(Path),\n+    RawPtr(Box<TypeRef>, Mutability),\n+    Reference(Box<TypeRef>, Mutability),\n+    Array(Box<TypeRef> /*, Expr*/),\n+    Slice(Box<TypeRef>),\n+    /// A fn pointer. Last element of the vector is the return type.\n+    Fn(Vec<TypeRef>),\n+    // For\n+    // ImplTrait,\n+    // DynTrait,\n+    Error,\n+}\n+\n+impl TypeRef {\n+    /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n+    pub(crate) fn from_ast(node: ast::TypeRef) -> Self {\n+        use ra_syntax::ast::TypeRef::*;\n+        match node {\n+            ParenType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n+            TupleType(inner) => TypeRef::Tuple(inner.fields().map(TypeRef::from_ast).collect()),\n+            NeverType(..) => TypeRef::Never,\n+            PathType(inner) => inner\n+                .path()\n+                .and_then(Path::from_ast)\n+                .map(TypeRef::Path)\n+                .unwrap_or(TypeRef::Error),\n+            PointerType(inner) => {\n+                let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n+                let mutability = Mutability::from_mutable(inner.is_mut());\n+                TypeRef::RawPtr(Box::new(inner_ty), mutability)\n+            }\n+            ArrayType(inner) => TypeRef::Array(Box::new(TypeRef::from_ast_opt(inner.type_ref()))),\n+            SliceType(inner) => TypeRef::Slice(Box::new(TypeRef::from_ast_opt(inner.type_ref()))),\n+            ReferenceType(inner) => {\n+                let inner_ty = TypeRef::from_ast_opt(inner.type_ref());\n+                let mutability = Mutability::from_mutable(inner.is_mut());\n+                TypeRef::Reference(Box::new(inner_ty), mutability)\n+            }\n+            PlaceholderType(_inner) => TypeRef::Placeholder,\n+            FnPointerType(inner) => {\n+                let ret_ty = TypeRef::from_ast_opt(inner.ret_type().and_then(|rt| rt.type_ref()));\n+                let mut params = if let Some(pl) = inner.param_list() {\n+                    pl.params()\n+                        .map(|p| p.type_ref())\n+                        .map(TypeRef::from_ast_opt)\n+                        .collect()\n+                } else {\n+                    Vec::new()\n+                };\n+                params.push(ret_ty);\n+                TypeRef::Fn(params)\n+            }\n+            // for types are close enough for our purposes to the inner type for now...\n+            ForType(inner) => TypeRef::from_ast_opt(inner.type_ref()),\n+            ImplTraitType(_inner) => TypeRef::Error,\n+            DynTraitType(_inner) => TypeRef::Error,\n+        }\n+    }\n+\n+    pub(crate) fn from_ast_opt(node: Option<ast::TypeRef>) -> Self {\n+        if let Some(node) = node {\n+            TypeRef::from_ast(node)\n+        } else {\n+            TypeRef::Error\n+        }\n+    }\n+}"}, {"sha": "5f7038f6311975e132c3350702b3805420fa07d4", "filename": "crates/ra_lsp_server/src/caps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -19,7 +19,7 @@ pub fn server_capabilities() -> ServerCapabilities {\n         hover_provider: Some(true),\n         completion_provider: Some(CompletionOptions {\n             resolve_provider: None,\n-            trigger_characters: Some(vec![\":\".to_string()]),\n+            trigger_characters: Some(vec![\":\".to_string(), \".\".to_string()]),\n         }),\n         signature_help_provider: Some(SignatureHelpOptions {\n             trigger_characters: Some(vec![\"(\".to_string(), \",\".to_string(), \")\".to_string()]),"}, {"sha": "c0e4e3a36a86aaec491c34a865549e683752a4bf", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -55,7 +55,10 @@ impl Conv for CompletionItemKind {\n             CompletionItemKind::Snippet => Snippet,\n             CompletionItemKind::Module => Module,\n             CompletionItemKind::Function => Function,\n+            CompletionItemKind::Struct => Struct,\n+            CompletionItemKind::Enum => Enum,\n             CompletionItemKind::Binding => Variable,\n+            CompletionItemKind::Field => Field,\n         }\n     }\n }"}, {"sha": "8fb6b64083f7f9a677f55ae402ab00cad0e866b2", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -363,3 +363,73 @@ impl<'a, N: AstNode<'a>> Iterator for AstChildren<'a, N> {\n         }\n     }\n }\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum StructFlavor<'a> {\n+    Tuple(PosFieldList<'a>),\n+    Named(NamedFieldDefList<'a>),\n+    Unit,\n+}\n+\n+impl<'a> StructFlavor<'a> {\n+    fn from_node<N: AstNode<'a>>(node: N) -> StructFlavor<'a> {\n+        if let Some(nfdl) = child_opt::<_, NamedFieldDefList>(node) {\n+            StructFlavor::Named(nfdl)\n+        } else if let Some(pfl) = child_opt::<_, PosFieldList>(node) {\n+            StructFlavor::Tuple(pfl)\n+        } else {\n+            StructFlavor::Unit\n+        }\n+    }\n+}\n+\n+impl<'a> StructDef<'a> {\n+    pub fn flavor(self) -> StructFlavor<'a> {\n+        StructFlavor::from_node(self)\n+    }\n+}\n+\n+impl<'a> EnumVariant<'a> {\n+    pub fn flavor(self) -> StructFlavor<'a> {\n+        StructFlavor::from_node(self)\n+    }\n+}\n+\n+impl<'a> PointerType<'a> {\n+    pub fn is_mut(&self) -> bool {\n+        self.syntax().children().any(|n| n.kind() == MUT_KW)\n+    }\n+}\n+\n+impl<'a> ReferenceType<'a> {\n+    pub fn is_mut(&self) -> bool {\n+        self.syntax().children().any(|n| n.kind() == MUT_KW)\n+    }\n+}\n+\n+impl<'a> RefExpr<'a> {\n+    pub fn is_mut(&self) -> bool {\n+        self.syntax().children().any(|n| n.kind() == MUT_KW)\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum PrefixOp {\n+    /// The `*` operator for dereferencing\n+    Deref,\n+    /// The `!` operator for logical inversion\n+    Not,\n+    /// The `-` operator for negation\n+    Neg,\n+}\n+\n+impl<'a> PrefixExpr<'a> {\n+    pub fn op(&self) -> Option<PrefixOp> {\n+        match self.syntax().first_child()?.kind() {\n+            STAR => Some(PrefixOp::Deref),\n+            EXCL => Some(PrefixOp::Not),\n+            MINUS => Some(PrefixOp::Neg),\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "c22e026cf9ddcf69570a051ee117a38f01ac8446", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 302, "deletions": 19, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -131,7 +131,15 @@ impl<R: TreeRoot<RaTypes>> ArrayTypeNode<R> {\n }\n \n \n-impl<'a> ArrayType<'a> {}\n+impl<'a> ArrayType<'a> {\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n+\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // Attr\n #[derive(Debug, Clone, Copy,)]\n@@ -806,7 +814,94 @@ impl<'a> ast::NameOwner<'a> for EnumDef<'a> {}\n impl<'a> ast::TypeParamsOwner<'a> for EnumDef<'a> {}\n impl<'a> ast::AttrsOwner<'a> for EnumDef<'a> {}\n impl<'a> ast::DocCommentsOwner<'a> for EnumDef<'a> {}\n-impl<'a> EnumDef<'a> {}\n+impl<'a> EnumDef<'a> {\n+    pub fn variant_list(self) -> Option<EnumVariantList<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n+\n+// EnumVariant\n+#[derive(Debug, Clone, Copy,)]\n+pub struct EnumVariantNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n+    pub(crate) syntax: SyntaxNode<R>,\n+}\n+pub type EnumVariant<'a> = EnumVariantNode<RefRoot<'a>>;\n+\n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<EnumVariantNode<R1>> for EnumVariantNode<R2> {\n+    fn eq(&self, other: &EnumVariantNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for EnumVariantNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for EnumVariantNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n+impl<'a> AstNode<'a> for EnumVariant<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            ENUM_VARIANT => Some(EnumVariant { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<R: TreeRoot<RaTypes>> EnumVariantNode<R> {\n+    pub fn borrowed(&self) -> EnumVariant {\n+        EnumVariantNode { syntax: self.syntax.borrowed() }\n+    }\n+    pub fn owned(&self) -> EnumVariantNode {\n+        EnumVariantNode { syntax: self.syntax.owned() }\n+    }\n+}\n+\n+\n+impl<'a> ast::NameOwner<'a> for EnumVariant<'a> {}\n+impl<'a> EnumVariant<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n+\n+// EnumVariantList\n+#[derive(Debug, Clone, Copy,)]\n+pub struct EnumVariantListNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n+    pub(crate) syntax: SyntaxNode<R>,\n+}\n+pub type EnumVariantList<'a> = EnumVariantListNode<RefRoot<'a>>;\n+\n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<EnumVariantListNode<R1>> for EnumVariantListNode<R2> {\n+    fn eq(&self, other: &EnumVariantListNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for EnumVariantListNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for EnumVariantListNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n+impl<'a> AstNode<'a> for EnumVariantList<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            ENUM_VARIANT_LIST => Some(EnumVariantList { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<R: TreeRoot<RaTypes>> EnumVariantListNode<R> {\n+    pub fn borrowed(&self) -> EnumVariantList {\n+        EnumVariantListNode { syntax: self.syntax.borrowed() }\n+    }\n+    pub fn owned(&self) -> EnumVariantListNode {\n+        EnumVariantListNode { syntax: self.syntax.owned() }\n+    }\n+}\n+\n+\n+impl<'a> EnumVariantList<'a> {\n+    pub fn variants(self) -> impl Iterator<Item = EnumVariant<'a>> + 'a {\n+        super::children(self)\n+    }\n+}\n \n // Expr\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n@@ -1036,7 +1131,15 @@ impl<R: TreeRoot<RaTypes>> FieldExprNode<R> {\n }\n \n \n-impl<'a> FieldExpr<'a> {}\n+impl<'a> FieldExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+\n+    pub fn name_ref(self) -> Option<NameRef<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // FieldPatList\n #[derive(Debug, Clone, Copy,)]\n@@ -1163,7 +1266,15 @@ impl<R: TreeRoot<RaTypes>> FnPointerTypeNode<R> {\n }\n \n \n-impl<'a> FnPointerType<'a> {}\n+impl<'a> FnPointerType<'a> {\n+    pub fn param_list(self) -> Option<ParamList<'a>> {\n+        super::child_opt(self)\n+    }\n+\n+    pub fn ret_type(self) -> Option<RetType<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // ForExpr\n #[derive(Debug, Clone, Copy,)]\n@@ -1246,7 +1357,11 @@ impl<R: TreeRoot<RaTypes>> ForTypeNode<R> {\n }\n \n \n-impl<'a> ForType<'a> {}\n+impl<'a> ForType<'a> {\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // IfExpr\n #[derive(Debug, Clone, Copy,)]\n@@ -1935,6 +2050,10 @@ impl<'a> MethodCallExpr<'a> {\n     pub fn expr(self) -> Option<Expr<'a>> {\n         super::child_opt(self)\n     }\n+\n+    pub fn name_ref(self) -> Option<NameRef<'a>> {\n+        super::child_opt(self)\n+    }\n }\n \n // Module\n@@ -2142,7 +2261,15 @@ impl<R: TreeRoot<RaTypes>> NamedFieldNode<R> {\n }\n \n \n-impl<'a> NamedField<'a> {}\n+impl<'a> NamedField<'a> {\n+    pub fn name_ref(self) -> Option<NameRef<'a>> {\n+        super::child_opt(self)\n+    }\n+\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // NamedFieldDef\n #[derive(Debug, Clone, Copy,)]\n@@ -2181,7 +2308,52 @@ impl<R: TreeRoot<RaTypes>> NamedFieldDefNode<R> {\n \n impl<'a> ast::NameOwner<'a> for NamedFieldDef<'a> {}\n impl<'a> ast::AttrsOwner<'a> for NamedFieldDef<'a> {}\n-impl<'a> NamedFieldDef<'a> {}\n+impl<'a> NamedFieldDef<'a> {\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n+\n+// NamedFieldDefList\n+#[derive(Debug, Clone, Copy,)]\n+pub struct NamedFieldDefListNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n+    pub(crate) syntax: SyntaxNode<R>,\n+}\n+pub type NamedFieldDefList<'a> = NamedFieldDefListNode<RefRoot<'a>>;\n+\n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<NamedFieldDefListNode<R1>> for NamedFieldDefListNode<R2> {\n+    fn eq(&self, other: &NamedFieldDefListNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for NamedFieldDefListNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for NamedFieldDefListNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n+impl<'a> AstNode<'a> for NamedFieldDefList<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            NAMED_FIELD_DEF_LIST => Some(NamedFieldDefList { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<R: TreeRoot<RaTypes>> NamedFieldDefListNode<R> {\n+    pub fn borrowed(&self) -> NamedFieldDefList {\n+        NamedFieldDefListNode { syntax: self.syntax.borrowed() }\n+    }\n+    pub fn owned(&self) -> NamedFieldDefListNode {\n+        NamedFieldDefListNode { syntax: self.syntax.owned() }\n+    }\n+}\n+\n+\n+impl<'a> NamedFieldDefList<'a> {\n+    pub fn fields(self) -> impl Iterator<Item = NamedFieldDef<'a>> + 'a {\n+        super::children(self)\n+    }\n+}\n \n // NamedFieldList\n #[derive(Debug, Clone, Copy,)]\n@@ -2218,7 +2390,11 @@ impl<R: TreeRoot<RaTypes>> NamedFieldListNode<R> {\n }\n \n \n-impl<'a> NamedFieldList<'a> {}\n+impl<'a> NamedFieldList<'a> {\n+    pub fn fields(self) -> impl Iterator<Item = NamedField<'a>> + 'a {\n+        super::children(self)\n+    }\n+}\n \n // NeverType\n #[derive(Debug, Clone, Copy,)]\n@@ -2451,7 +2627,11 @@ impl<R: TreeRoot<RaTypes>> ParenTypeNode<R> {\n }\n \n \n-impl<'a> ParenType<'a> {}\n+impl<'a> ParenType<'a> {\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // Pat\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n@@ -2816,7 +2996,94 @@ impl<R: TreeRoot<RaTypes>> PointerTypeNode<R> {\n }\n \n \n-impl<'a> PointerType<'a> {}\n+impl<'a> PointerType<'a> {\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n+\n+// PosField\n+#[derive(Debug, Clone, Copy,)]\n+pub struct PosFieldNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n+    pub(crate) syntax: SyntaxNode<R>,\n+}\n+pub type PosField<'a> = PosFieldNode<RefRoot<'a>>;\n+\n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PosFieldNode<R1>> for PosFieldNode<R2> {\n+    fn eq(&self, other: &PosFieldNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for PosFieldNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for PosFieldNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n+impl<'a> AstNode<'a> for PosField<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            POS_FIELD => Some(PosField { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<R: TreeRoot<RaTypes>> PosFieldNode<R> {\n+    pub fn borrowed(&self) -> PosField {\n+        PosFieldNode { syntax: self.syntax.borrowed() }\n+    }\n+    pub fn owned(&self) -> PosFieldNode {\n+        PosFieldNode { syntax: self.syntax.owned() }\n+    }\n+}\n+\n+\n+impl<'a> ast::AttrsOwner<'a> for PosField<'a> {}\n+impl<'a> PosField<'a> {\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n+\n+// PosFieldList\n+#[derive(Debug, Clone, Copy,)]\n+pub struct PosFieldListNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n+    pub(crate) syntax: SyntaxNode<R>,\n+}\n+pub type PosFieldList<'a> = PosFieldListNode<RefRoot<'a>>;\n+\n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<PosFieldListNode<R1>> for PosFieldListNode<R2> {\n+    fn eq(&self, other: &PosFieldListNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for PosFieldListNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for PosFieldListNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n+impl<'a> AstNode<'a> for PosFieldList<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            POS_FIELD_LIST => Some(PosFieldList { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<R: TreeRoot<RaTypes>> PosFieldListNode<R> {\n+    pub fn borrowed(&self) -> PosFieldList {\n+        PosFieldListNode { syntax: self.syntax.borrowed() }\n+    }\n+    pub fn owned(&self) -> PosFieldListNode {\n+        PosFieldListNode { syntax: self.syntax.owned() }\n+    }\n+}\n+\n+\n+impl<'a> PosFieldList<'a> {\n+    pub fn fields(self) -> impl Iterator<Item = PosField<'a>> + 'a {\n+        super::children(self)\n+    }\n+}\n \n // PrefixExpr\n #[derive(Debug, Clone, Copy,)]\n@@ -3046,7 +3313,11 @@ impl<R: TreeRoot<RaTypes>> ReferenceTypeNode<R> {\n }\n \n \n-impl<'a> ReferenceType<'a> {}\n+impl<'a> ReferenceType<'a> {\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // RetType\n #[derive(Debug, Clone, Copy,)]\n@@ -3239,7 +3510,11 @@ impl<R: TreeRoot<RaTypes>> SliceTypeNode<R> {\n }\n \n \n-impl<'a> SliceType<'a> {}\n+impl<'a> SliceType<'a> {\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // SourceFile\n #[derive(Debug, Clone, Copy,)]\n@@ -3426,11 +3701,7 @@ impl<'a> ast::NameOwner<'a> for StructDef<'a> {}\n impl<'a> ast::TypeParamsOwner<'a> for StructDef<'a> {}\n impl<'a> ast::AttrsOwner<'a> for StructDef<'a> {}\n impl<'a> ast::DocCommentsOwner<'a> for StructDef<'a> {}\n-impl<'a> StructDef<'a> {\n-    pub fn fields(self) -> impl Iterator<Item = NamedFieldDef<'a>> + 'a {\n-        super::children(self)\n-    }\n-}\n+impl<'a> StructDef<'a> {}\n \n // StructLit\n #[derive(Debug, Clone, Copy,)]\n@@ -3467,7 +3738,15 @@ impl<R: TreeRoot<RaTypes>> StructLitNode<R> {\n }\n \n \n-impl<'a> StructLit<'a> {}\n+impl<'a> StructLit<'a> {\n+    pub fn path(self) -> Option<Path<'a>> {\n+        super::child_opt(self)\n+    }\n+\n+    pub fn named_field_list(self) -> Option<NamedFieldList<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // StructPat\n #[derive(Debug, Clone, Copy,)]\n@@ -3770,7 +4049,11 @@ impl<R: TreeRoot<RaTypes>> TupleTypeNode<R> {\n }\n \n \n-impl<'a> TupleType<'a> {}\n+impl<'a> TupleType<'a> {\n+    pub fn fields(self) -> impl Iterator<Item = TypeRef<'a>> + 'a {\n+        super::children(self)\n+    }\n+}\n \n // TypeDef\n #[derive(Debug, Clone, Copy,)]"}, {"sha": "4bcff4e144bfb35f99dfb8703953f46d01bfb2c4", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -261,18 +261,20 @@ Grammar(\n                 \"TypeParamsOwner\",\n                 \"AttrsOwner\",\n                 \"DocCommentsOwner\"\n-            ],\n-            collections: [\n-                [\"fields\", \"NamedFieldDef\"]\n             ]\n         ),\n-        \"NamedFieldDef\": ( traits: [\"NameOwner\", \"AttrsOwner\"] ),\n+        \"NamedFieldDefList\": (collections: [[\"fields\", \"NamedFieldDef\"]]),\n+        \"NamedFieldDef\": ( traits: [\"NameOwner\", \"AttrsOwner\"], options: [\"TypeRef\"] ),\n+        \"PosFieldList\": (collections: [[\"fields\", \"PosField\"]]),\n+        \"PosField\": ( traits: [\"AttrsOwner\"], options: [\"TypeRef\"]),\n         \"EnumDef\": ( traits: [\n             \"NameOwner\",\n             \"TypeParamsOwner\",\n             \"AttrsOwner\",\n             \"DocCommentsOwner\"\n-        ] ),\n+        ], options: [[\"variant_list\", \"EnumVariantList\"]] ),\n+        \"EnumVariantList\": ( collections: [[\"variants\", \"EnumVariant\"]] ),\n+        \"EnumVariant\": ( traits: [\"NameOwner\"], options: [\"Expr\"] ),\n         \"TraitDef\": ( traits: [\"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\"] ),\n         \"Module\": (\n             traits: [\"NameOwner\", \"AttrsOwner\", \"DocCommentsOwner\" ],\n@@ -301,17 +303,17 @@ Grammar(\n         ] ),\n         \"ImplItem\": (),\n \n-        \"ParenType\": (),\n-        \"TupleType\": (),\n+        \"ParenType\": (options: [\"TypeRef\"]),\n+        \"TupleType\": ( collections: [[\"fields\", \"TypeRef\"]] ),\n         \"NeverType\": (),\n         \"PathType\": (options: [\"Path\"]),\n-        \"PointerType\": (),\n-        \"ArrayType\": (),\n-        \"SliceType\": (),\n-        \"ReferenceType\": (),\n+        \"PointerType\": (options: [\"TypeRef\"]),\n+        \"ArrayType\": ( options: [\"TypeRef\", \"Expr\"] ),\n+        \"SliceType\": ( options: [\"TypeRef\"] ),\n+        \"ReferenceType\": (options: [\"TypeRef\"]),\n         \"PlaceholderType\": (),\n-        \"FnPointerType\": (),\n-        \"ForType\": (),\n+        \"FnPointerType\": (options: [\"ParamList\", \"RetType\"]),\n+        \"ForType\": (options: [\"TypeRef\"]),\n         \"ImplTraitType\": (),\n         \"DynTraitType\": (),\n \n@@ -392,19 +394,19 @@ Grammar(\n             collections: [ [ \"pats\", \"Pat\" ] ]\n         ),\n         \"MatchGuard\": (),\n-        \"StructLit\": (),\n-        \"NamedFieldList\": (),\n-        \"NamedField\": (),\n+        \"StructLit\": (options: [\"Path\", \"NamedFieldList\"]),\n+        \"NamedFieldList\": (collections: [ [\"fields\", \"NamedField\"] ]),\n+        \"NamedField\": (options: [\"NameRef\", \"Expr\"]),\n         \"CallExpr\": (\n             traits: [\"ArgListOwner\"],\n             options: [ \"Expr\" ],\n         ),\n         \"MethodCallExpr\": (\n             traits: [\"ArgListOwner\"],\n-            options: [ \"Expr\" ],\n+            options: [ \"Expr\", \"NameRef\" ],\n         ),\n         \"IndexExpr\": (),\n-        \"FieldExpr\": (),\n+        \"FieldExpr\": (options: [\"Expr\", \"NameRef\"]),\n         \"TryExpr\": (options: [\"Expr\"]),\n         \"CastExpr\": (options: [\"Expr\", \"TypeRef\"]),\n         \"RefExpr\": (options: [\"Expr\"]),"}, {"sha": "2d1f174912c62cfd65bfc41d4c3141d305295231", "filename": "crates/ra_syntax/src/grammar/expressions.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -283,14 +283,10 @@ fn postfix_expr(\n             // }\n             L_PAREN if allow_calls => call_expr(p, lhs),\n             L_BRACK if allow_calls => index_expr(p, lhs),\n-            DOT if p.nth(1) == IDENT => {\n-                if p.nth(2) == L_PAREN || p.nth(2) == COLONCOLON {\n-                    method_call_expr(p, lhs)\n-                } else {\n-                    field_expr(p, lhs)\n-                }\n+            DOT if p.nth(1) == IDENT && (p.nth(2) == L_PAREN || p.nth(2) == COLONCOLON) => {\n+                method_call_expr(p, lhs)\n             }\n-            DOT if p.nth(1) == INT_NUMBER => field_expr(p, lhs),\n+            DOT => field_expr(p, lhs),\n             // test postfix_range\n             // fn foo() { let x = 1..; }\n             DOTDOT | DOTDOTEQ if !EXPR_FIRST.contains(p.nth(1)) => {\n@@ -355,13 +351,15 @@ fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n //     x.0.bar;\n // }\n fn field_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(p.at(DOT) && (p.nth(1) == IDENT || p.nth(1) == INT_NUMBER));\n+    assert!(p.at(DOT));\n     let m = lhs.precede(p);\n     p.bump();\n     if p.at(IDENT) {\n         name_ref(p)\n-    } else {\n+    } else if p.at(INT_NUMBER) {\n         p.bump()\n+    } else {\n+        p.error(\"expected field name or number\")\n     }\n     m.complete(p, FIELD_EXPR)\n }"}, {"sha": "a7cdc17bb112a9ddb3d5c4b69a51c48178673a6e", "filename": "crates/ra_syntax/tests/data/parser/err/0029_field_completion.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0029_field_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0029_field_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0029_field_completion.rs?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -0,0 +1,3 @@\n+fn foo(a: A) {\n+    a.\n+}"}, {"sha": "fd2a3f37b74f3876d16db23d270c258f2ae65420", "filename": "crates/ra_syntax/tests/data/parser/err/0029_field_completion.txt", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0029_field_completion.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1d6dcef5c584d0dffdf5386eec993e41daad0210/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0029_field_completion.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Fdata%2Fparser%2Ferr%2F0029_field_completion.txt?ref=1d6dcef5c584d0dffdf5386eec993e41daad0210", "patch": "@@ -0,0 +1,35 @@\n+SOURCE_FILE@[0; 24)\n+  FN_DEF@[0; 23)\n+    FN_KW@[0; 2)\n+    WHITESPACE@[2; 3)\n+    NAME@[3; 6)\n+      IDENT@[3; 6) \"foo\"\n+    PARAM_LIST@[6; 12)\n+      L_PAREN@[6; 7)\n+      PARAM@[7; 11)\n+        BIND_PAT@[7; 8)\n+          NAME@[7; 8)\n+            IDENT@[7; 8) \"a\"\n+        COLON@[8; 9)\n+        WHITESPACE@[9; 10)\n+        PATH_TYPE@[10; 11)\n+          PATH@[10; 11)\n+            PATH_SEGMENT@[10; 11)\n+              NAME_REF@[10; 11)\n+                IDENT@[10; 11) \"A\"\n+      R_PAREN@[11; 12)\n+    WHITESPACE@[12; 13)\n+    BLOCK@[13; 23)\n+      L_CURLY@[13; 14)\n+      WHITESPACE@[14; 19)\n+      FIELD_EXPR@[19; 21)\n+        PATH_EXPR@[19; 20)\n+          PATH@[19; 20)\n+            PATH_SEGMENT@[19; 20)\n+              NAME_REF@[19; 20)\n+                IDENT@[19; 20) \"a\"\n+        DOT@[20; 21)\n+        err: `expected field name or number`\n+      WHITESPACE@[21; 22)\n+      R_CURLY@[22; 23)\n+  WHITESPACE@[23; 24)"}]}