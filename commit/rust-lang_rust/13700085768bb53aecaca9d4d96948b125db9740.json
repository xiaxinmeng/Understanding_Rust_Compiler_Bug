{"sha": "13700085768bb53aecaca9d4d96948b125db9740", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNzAwMDg1NzY4YmI1M2FlY2FjYTlkNGQ5Njk0OGIxMjVkYjk3NDA=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-13T04:15:59Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-13T04:15:59Z"}, "message": "Restructure aggregates and pave the way for enums.", "tree": {"sha": "a5ef3cea70cf56107789b7ad7f4223c910ae8046", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5ef3cea70cf56107789b7ad7f4223c910ae8046"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13700085768bb53aecaca9d4d96948b125db9740", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13700085768bb53aecaca9d4d96948b125db9740", "html_url": "https://github.com/rust-lang/rust/commit/13700085768bb53aecaca9d4d96948b125db9740", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13700085768bb53aecaca9d4d96948b125db9740/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11d4bf9b954d9fe3cdba1971b56ef7b69e708b24", "url": "https://api.github.com/repos/rust-lang/rust/commits/11d4bf9b954d9fe3cdba1971b56ef7b69e708b24", "html_url": "https://github.com/rust-lang/rust/commit/11d4bf9b954d9fe3cdba1971b56ef7b69e708b24"}], "stats": {"total": 128, "additions": 96, "deletions": 32}, "files": [{"sha": "c8e73e9fb2298fc3cd2e6688fd2313b427ff25cd", "filename": "src/interpreter.rs", "status": "modified", "additions": 64, "deletions": 22, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/13700085768bb53aecaca9d4d96948b125db9740/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13700085768bb53aecaca9d4d96948b125db9740/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=13700085768bb53aecaca9d4d96948b125db9740", "patch": "@@ -269,6 +269,20 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         self.memory.write_int(dest, n)\n     }\n \n+    fn assign_to_product(&mut self, dest: Pointer, dest_repr: Repr,\n+                         operands: &[mir::Operand<'tcx>]) -> EvalResult<()> {\n+        match dest_repr {\n+            Repr::Product { ref fields, .. } => {\n+                for (field, operand) in fields.iter().zip(operands) {\n+                    let src = try!(self.operand_to_ptr(operand));\n+                    try!(self.memory.copy(src, dest.offset(field.offset), field.repr.size()));\n+                }\n+            }\n+            _ => panic!(\"expected Repr::Product target\"),\n+        }\n+        Ok(())\n+    }\n+\n     fn eval_assignment(&mut self, lvalue: &mir::Lvalue<'tcx>, rvalue: &mir::Rvalue<'tcx>)\n         -> EvalResult<()>\n     {\n@@ -298,8 +312,23 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 self.memory.write_int(dest, n)\n             }\n \n-            Aggregate(ref _kind, ref operands) => {\n-                // TODO(tsion): Handle different `kind` variants.\n+            Aggregate(ref kind, ref operands) => {\n+                use rustc::mir::repr::AggregateKind::*;\n+                match *kind {\n+                    Tuple => self.assign_to_product(dest, dest_repr, operands),\n+\n+                    Adt(ref adt_def, variant_idx, _) => {\n+                        use rustc::middle::ty::AdtKind::*;\n+                        match adt_def.adt_kind() {\n+                            Struct => self.assign_to_product(dest, dest_repr, operands),\n+\n+                            Enum => unimplemented!(),\n+                        }\n+                    }\n+\n+                    Vec => unimplemented!(),\n+                    Closure(..) => unimplemented!(),\n+                }\n \n                 // let max_fields = adt_def.variants\n                 //     .iter()\n@@ -312,19 +341,6 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n                 //     self.write_pointer(ptr.offset(i), val);\n                 // }\n                 // Value::Adt { variant: variant, data_ptr: ptr }\n-\n-                match dest_repr {\n-                    Repr::Aggregate { ref fields, .. } => {\n-                        for (field, operand) in fields.iter().zip(operands) {\n-                            let src = try!(self.operand_to_ptr(operand));\n-                            try!(self.memory.copy(src, dest.offset(field.offset),\n-                                                  field.repr.size()));\n-                        }\n-                        Ok(())\n-                    }\n-\n-                    _ => unimplemented!(),\n-                }\n             }\n \n             // Ref(_region, _kind, ref lvalue) => {\n@@ -426,29 +442,55 @@ impl<'a, 'tcx: 'a> Interpreter<'a, 'tcx> {\n         }\n     }\n \n-    fn make_aggregate_repr<I>(&self, iter: I) -> Repr where I: IntoIterator<Item = ty::Ty<'tcx>> {\n+    fn make_product_repr<I>(&self, iter: I) -> Repr where I: IntoIterator<Item = ty::Ty<'tcx>> {\n         let mut size = 0;\n         let fields = iter.into_iter().map(|ty| {\n             let repr = self.ty_to_repr(ty);\n             let old_size = size;\n             size += repr.size();\n             FieldRepr { offset: old_size, repr: repr }\n         }).collect();\n-        Repr::Aggregate { size: size, fields: fields }\n+        Repr::Product { size: size, fields: fields }\n     }\n \n     // TODO(tsion): Cache these outputs.\n     fn ty_to_repr(&self, ty: ty::Ty<'tcx>) -> Repr {\n         match ty.sty {\n             ty::TyBool => Repr::Bool,\n             ty::TyInt(_) => Repr::Int,\n-            ty::TyTuple(ref fields) => self.make_aggregate_repr(fields.iter().cloned()),\n+            ty::TyTuple(ref fields) => self.make_product_repr(fields.iter().cloned()),\n+\n+            ty::TyEnum(adt_def, ref subst) => {\n+                let num_variants = adt_def.variants.len();\n+\n+                let discr_size = if num_variants <= 1 {\n+                    0\n+                } else if num_variants <= 1 << 8 {\n+                    1\n+                } else if num_variants <= 1 << 16 {\n+                    2\n+                } else if num_variants <= 1 << 32 {\n+                    4\n+                } else {\n+                    8\n+                };\n+\n+                let variants: Vec<Repr> = adt_def.variants.iter().map(|v| {\n+                    let field_tys = v.fields.iter().map(|f| f.ty(self.tcx, subst));\n+                    self.make_product_repr(field_tys)\n+                }).collect();\n+\n+                Repr::Sum {\n+                    discr_size: discr_size,\n+                    max_variant_size: variants.iter().map(Repr::size).max().unwrap_or(0),\n+                    variants: variants,\n+                }\n+            }\n \n-            ty::TyEnum(adt_def, ref subst) | ty::TyStruct(adt_def, ref subst) => {\n-                // TODO(tsion): Support multi-variant enums.\n-                assert!(adt_def.variants.len() == 1);\n+            ty::TyStruct(adt_def, ref subst) => {\n+                assert_eq!(adt_def.variants.len(), 1);\n                 let field_tys = adt_def.variants[0].fields.iter().map(|f| f.ty(self.tcx, subst));\n-                self.make_aggregate_repr(field_tys)\n+                self.make_product_repr(field_tys)\n             }\n \n             ref t => panic!(\"can't convert type to repr: {:?}\", t),"}, {"sha": "352f19dcdf0224d31b38d7d75f6b1aca27d59a8e", "filename": "src/memory.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/13700085768bb53aecaca9d4d96948b125db9740/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13700085768bb53aecaca9d4d96948b125db9740/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=13700085768bb53aecaca9d4d96948b125db9740", "patch": "@@ -36,10 +36,31 @@ pub struct FieldRepr {\n pub enum Repr {\n     Bool,\n     Int,\n-    Aggregate {\n+\n+    /// The representation for product types including tuples, structs, and the contents of enum\n+    /// variants.\n+    Product {\n+        /// Size in bytes.\n         size: usize,\n         fields: Vec<FieldRepr>,\n     },\n+\n+    /// The representation for a sum type, i.e. a Rust enum.\n+    Sum {\n+        /// The size of the discriminant in bytes.\n+        discr_size: usize,\n+\n+        /// The size of the largest variant in bytes.\n+        max_variant_size: usize,\n+\n+        variants: Vec<Repr>,\n+    },\n+\n+    // Array {\n+    //     /// Number of elements.\n+    //     length: usize,\n+    //     elem: Repr,\n+    // },\n }\n \n impl Memory {\n@@ -144,7 +165,8 @@ impl Repr {\n         match *self {\n             Repr::Bool => 1,\n             Repr::Int => mem::size_of::<i64>(),\n-            Repr::Aggregate { size, .. } => size,\n+            Repr::Product { size, .. } => size,\n+            Repr::Sum { discr_size, max_variant_size, .. } => discr_size + max_variant_size,\n         }\n     }\n }"}, {"sha": "bb01e64ae047b27ec78843e63ddccd0f303f62a8", "filename": "test/sums.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/13700085768bb53aecaca9d4d96948b125db9740/test%2Fsums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13700085768bb53aecaca9d4d96948b125db9740/test%2Fsums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fsums.rs?ref=13700085768bb53aecaca9d4d96948b125db9740", "patch": "@@ -24,11 +24,11 @@\n //     }\n // }\n \n-// #[miri_run(expected = \"Int(13)\")]\n-// fn match_opt_some() -> i32 {\n-//     let x = Some(13);\n-//     match x {\n-//         Some(data)  => data,\n-//         None => 42,\n-//     }\n-// }\n+#[miri_run]\n+fn match_opt_some() -> i64 {\n+    let x = Some(13);\n+    match x {\n+        Some(data) => data,\n+        None => 42,\n+    }\n+}"}]}