{"sha": "e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5YmFjYmFhMmM5Yzg4YWFlY2YwN2VlMzBmMDJkMDhhMTk5OWU1YzY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-01T20:30:08Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-01T20:30:08Z"}, "message": "rollup merge of #23951: alexcrichton/splitn\n\nThis commit is an implementation of [RFC 979][rfc] which changes the meaning of\nthe count parameter to the `splitn` function on strings and slices. The\nparameter now means the number of items that are returned from the iterator, not\nthe number of splits that are made.\n\n[rfc]: https://github.com/rust-lang/rfcs/pull/979\n\nCloses #23911\n[breaking-change]", "tree": {"sha": "83ee5701b24c3f0608af96758fd4d5f78b9c8bae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83ee5701b24c3f0608af96758fd4d5f78b9c8bae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "html_url": "https://github.com/rust-lang/rust/commit/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb4029f8eadbf77a8d7a53fadb58decf3a1a49bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb4029f8eadbf77a8d7a53fadb58decf3a1a49bc", "html_url": "https://github.com/rust-lang/rust/commit/fb4029f8eadbf77a8d7a53fadb58decf3a1a49bc"}, {"sha": "e98dce3e00a7b6bfd264418ef993bbf9cdb1f0b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e98dce3e00a7b6bfd264418ef993bbf9cdb1f0b6", "html_url": "https://github.com/rust-lang/rust/commit/e98dce3e00a7b6bfd264418ef993bbf9cdb1f0b6"}], "stats": {"total": 151, "additions": 85, "deletions": 66}, "files": [{"sha": "f5505b6e83a6738dd073b68513a4ef5755a339e4", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "patch": "@@ -311,7 +311,7 @@ fn parse_exec_env(line: &str) -> Option<(String, String)> {\n     parse_name_value_directive(line, \"exec-env\").map(|nv| {\n         // nv is either FOO or FOO=BAR\n         let mut strs: Vec<String> = nv\n-                                      .splitn(1, '=')\n+                                      .splitn(2, '=')\n                                       .map(|s| s.to_string())\n                                       .collect();\n "}, {"sha": "d35173cbebf4cfd3d48b9d9c278ebb218058afa3", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "patch": "@@ -328,17 +328,20 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// `pred`, limited to returning at most `n` items.  The matched element is\n     /// not contained in the subslices.\n     ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n+    ///\n     /// # Examples\n     ///\n     /// Print the slice split once by numbers divisible by 3 (i.e. `[10, 40]`,\n     /// `[20, 60, 50]`):\n     ///\n     /// ```\n     /// let v = [10, 40, 30, 20, 60, 50];\n-    /// for group in v.splitn(1, |num| *num % 3 == 0) {\n+    /// for group in v.splitn(2, |num| *num % 3 == 0) {\n     ///     println!(\"{:?}\", group);\n     /// }\n     /// ```\n@@ -349,18 +352,21 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// `pred` limited to returning at most `n` items. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n     ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n+    ///\n     /// # Examples\n     ///\n     /// Print the slice split once, starting from the end, by numbers divisible\n     /// by 3 (i.e. `[50]`, `[10, 40, 30, 20]`):\n     ///\n     /// ```\n     /// let v = [10, 40, 30, 20, 60, 50];\n-    /// for group in v.rsplitn(1, |num| *num % 3 == 0) {\n+    /// for group in v.rsplitn(2, |num| *num % 3 == 0) {\n     ///     println!(\"{:?}\", group);\n     /// }\n     /// ```\n@@ -626,8 +632,11 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n-    /// `pred`, limited to splitting at most `n` times.  The matched element is\n+    /// `pred`, limited to returning at most `n` items.  The matched element is\n     /// not contained in the subslices.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn splitn_mut<F>(&mut self, n: usize, pred: F) -> SplitNMut<T, F>\n@@ -636,9 +645,12 @@ impl<T> [T] {\n     }\n \n     /// Returns an iterator over subslices separated by elements that match\n-    /// `pred` limited to splitting at most `n` times. This starts at the end of\n+    /// `pred` limited to returning at most `n` items. This starts at the end of\n     /// the slice and works backwards.  The matched element is not contained in\n     /// the subslices.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// slice.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn rsplitn_mut<F>(&mut self,  n: usize, pred: F) -> RSplitNMut<T, F>"}, {"sha": "c22b6fb9286d192382c9dd8c7ec1f112677aaa6b", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "patch": "@@ -610,24 +610,27 @@ impl str {\n         core_str::StrExt::split(&self[..], pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters matched by a pattern,\n-    /// restricted to splitting at most `count` times.\n+    /// An iterator over substrings of `self`, separated by characters matched\n+    /// by a pattern, returning most `count` items.\n     ///\n     /// The pattern can be a simple `&str`, or a closure that determines\n     /// the split.\n     ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// string.\n+    ///\n     /// # Examples\n     ///\n     /// Simple `&str` patterns:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n-    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n+    /// assert_eq!(v, [\"Mary\", \"had a little lambda\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n-    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n+    /// assert_eq!(v, [\"lion\", \"XtigerXleopard\"]);\n     ///\n-    /// let v: Vec<&str> = \"abcXdef\".splitn(0, 'X').collect();\n+    /// let v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\n     /// assert_eq!(v, [\"abcXdef\"]);\n     ///\n     /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n@@ -637,7 +640,7 @@ impl str {\n     /// More complex patterns with a lambda:\n     ///\n     /// ```\n-    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".splitn(2, |c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, [\"abc\", \"def2ghi\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -705,25 +708,28 @@ impl str {\n     }\n \n     /// An iterator over substrings of `self`, separated by a pattern,\n-    /// starting from the end of the string, restricted to splitting\n-    /// at most `count` times.\n+    /// starting from the end of the string, restricted to returning\n+    /// at most `count` items.\n+    ///\n+    /// The last element returned, if any, will contain the remainder of the\n+    /// string.\n     ///\n     /// # Examples\n     ///\n     /// Simple patterns:\n     ///\n     /// ```\n-    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n+    /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\n     /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(1, \"::\").collect();\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\n     /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n     ///\n     /// ```\n-    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n+    /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(2, |c: char| c.is_numeric()).collect();\n     /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "9dc12aa5bd9b4956e5e076047fcc596de144245e", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "patch": "@@ -867,37 +867,37 @@ fn test_splitnator() {\n     let xs = &[1,2,3,4,5];\n \n     let splits: &[&[_]] = &[&[1,2,3,4,5]];\n-    assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+    assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                splits);\n     let splits: &[&[_]] = &[&[1], &[3,4,5]];\n-    assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+    assert_eq!(xs.splitn(2, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                splits);\n     let splits: &[&[_]] = &[&[], &[], &[], &[4,5]];\n-    assert_eq!(xs.splitn(3, |_| true).collect::<Vec<_>>(),\n+    assert_eq!(xs.splitn(4, |_| true).collect::<Vec<_>>(),\n                splits);\n \n     let xs: &[i32] = &[];\n     let splits: &[&[i32]] = &[&[]];\n-    assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<_>>(), splits);\n+    assert_eq!(xs.splitn(2, |x| *x == 5).collect::<Vec<_>>(), splits);\n }\n \n #[test]\n fn test_splitnator_mut() {\n     let xs = &mut [1,2,3,4,5];\n \n     let splits: &[&mut[_]] = &[&mut [1,2,3,4,5]];\n-    assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+    assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                splits);\n     let splits: &[&mut[_]] = &[&mut [1], &mut [3,4,5]];\n-    assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+    assert_eq!(xs.splitn_mut(2, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                splits);\n     let splits: &[&mut[_]] = &[&mut [], &mut [], &mut [], &mut [4,5]];\n-    assert_eq!(xs.splitn_mut(3, |_| true).collect::<Vec<_>>(),\n+    assert_eq!(xs.splitn_mut(4, |_| true).collect::<Vec<_>>(),\n                splits);\n \n     let xs: &mut [i32] = &mut [];\n     let splits: &[&mut[i32]] = &[&mut []];\n-    assert_eq!(xs.splitn_mut(1, |x| *x == 5).collect::<Vec<_>>(),\n+    assert_eq!(xs.splitn_mut(2, |x| *x == 5).collect::<Vec<_>>(),\n                splits);\n }\n \n@@ -928,18 +928,19 @@ fn test_rsplitnator() {\n     let xs = &[1,2,3,4,5];\n \n     let splits: &[&[_]] = &[&[1,2,3,4,5]];\n-    assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+    assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                splits);\n     let splits: &[&[_]] = &[&[5], &[1,2,3]];\n-    assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<_>>(),\n+    assert_eq!(xs.rsplitn(2, |x| *x % 2 == 0).collect::<Vec<_>>(),\n                splits);\n     let splits: &[&[_]] = &[&[], &[], &[], &[1,2]];\n-    assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<_>>(),\n+    assert_eq!(xs.rsplitn(4, |_| true).collect::<Vec<_>>(),\n                splits);\n \n     let xs: &[i32]  = &[];\n     let splits: &[&[i32]] = &[&[]];\n-    assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n+    assert_eq!(xs.rsplitn(2, |x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n+    assert!(xs.rsplitn(0, |x| *x % 2 == 0).next().is_none());\n }\n \n #[test]"}, {"sha": "495a961fa360e2564bb72cbf7a8d91e717c4f20e", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "patch": "@@ -885,17 +885,17 @@ fn test_char_indices_revator() {\n fn test_splitn_char_iterator() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-    let split: Vec<&str> = data.splitn(3, ' ').collect();\n+    let split: Vec<&str> = data.splitn(4, ' ').collect();\n     assert_eq!(split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n-    let split: Vec<&str> = data.splitn(3, |c: char| c == ' ').collect();\n+    let split: Vec<&str> = data.splitn(4, |c: char| c == ' ').collect();\n     assert_eq!(split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n     // Unicode\n-    let split: Vec<&str> = data.splitn(3, '\u00e4').collect();\n+    let split: Vec<&str> = data.splitn(4, '\u00e4').collect();\n     assert_eq!(split, [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n-    let split: Vec<&str> = data.splitn(3, |c: char| c == '\u00e4').collect();\n+    let split: Vec<&str> = data.splitn(4, |c: char| c == '\u00e4').collect();\n     assert_eq!(split, [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n }\n \n@@ -928,13 +928,13 @@ fn test_rsplit() {\n fn test_rsplitn() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-    let split: Vec<&str> = data.rsplitn(1, ' ').collect();\n+    let split: Vec<&str> = data.rsplitn(2, ' ').collect();\n     assert_eq!(split, [\"l\u00e4mb\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle\"]);\n \n-    let split: Vec<&str> = data.rsplitn(1, \"l\u00e4mb\").collect();\n+    let split: Vec<&str> = data.rsplitn(2, \"l\u00e4mb\").collect();\n     assert_eq!(split, [\"\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle \"]);\n \n-    let split: Vec<&str> = data.rsplitn(1, |c: char| c == '\u00e4').collect();\n+    let split: Vec<&str> = data.rsplitn(2, |c: char| c == '\u00e4').collect();\n     assert_eq!(split, [\"mb\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\"]);\n }\n "}, {"sha": "70e60adf64c2a3649b9d2256a7eadd8a46ff7346", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "patch": "@@ -1126,18 +1126,20 @@ impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n \n     #[inline]\n     fn next(&mut self) -> Option<T> {\n-        if self.count == 0 {\n-            self.iter.finish()\n-        } else {\n-            self.count -= 1;\n-            if self.invert { self.iter.next_back() } else { self.iter.next() }\n+        match self.count {\n+            0 => None,\n+            1 => { self.count -= 1; self.iter.finish() }\n+            _ => {\n+                self.count -= 1;\n+                if self.invert {self.iter.next_back()} else {self.iter.next()}\n+            }\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lower, upper_opt) = self.iter.size_hint();\n-        (lower, upper_opt.map(|upper| cmp::min(self.count + 1, upper)))\n+        (lower, upper_opt.map(|upper| cmp::min(self.count, upper)))\n     }\n }\n "}, {"sha": "f07c988c2b4eec29f8ba6683de8e88e9eca316bb", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "patch": "@@ -489,7 +489,7 @@ struct CharSplits<'a, P: Pattern<'a>> {\n /// splitting at most `count` times.\n struct CharSplitsN<'a, P: Pattern<'a>> {\n     iter: CharSplits<'a, P>,\n-    /// The number of splits remaining\n+    /// The number of items remaining\n     count: usize,\n }\n \n@@ -596,11 +596,10 @@ impl<'a, P: Pattern<'a>> Iterator for CharSplitsN<'a, P> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n-        if self.count != 0 {\n-            self.count -= 1;\n-            self.iter.next()\n-        } else {\n-            self.iter.get_end()\n+        match self.count {\n+            0 => None,\n+            1 => { self.count = 0; self.iter.get_end() }\n+            _ => { self.count -= 1; self.iter.next() }\n         }\n     }\n }\n@@ -650,11 +649,10 @@ impl<'a, P: Pattern<'a>> Iterator for RCharSplitsN<'a, P>\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n-        if self.count != 0 {\n-            self.count -= 1;\n-            self.iter.next()\n-        } else {\n-            self.iter.get_remainder()\n+        match self.count {\n+            0 => None,\n+            1 => { self.count -= 1; self.iter.get_remainder() }\n+            _ => { self.count -= 1; self.iter.next() }\n         }\n     }\n }"}, {"sha": "5fce527d9798df979a3183c2d3a433f191d05234", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "patch": "@@ -65,20 +65,20 @@ fn test_strslice_contains() {\n fn test_rsplitn_char_iterator() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n-    let mut split: Vec<&str> = data.rsplitn(3, ' ').collect();\n+    let mut split: Vec<&str> = data.rsplitn(4, ' ').collect();\n     split.reverse();\n     assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n-    let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == ' ').collect();\n+    let mut split: Vec<&str> = data.rsplitn(4, |c: char| c == ' ').collect();\n     split.reverse();\n     assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     // Unicode\n-    let mut split: Vec<&str> = data.rsplitn(3, '\u00e4').collect();\n+    let mut split: Vec<&str> = data.rsplitn(4, '\u00e4').collect();\n     split.reverse();\n     assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n-    let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == '\u00e4').collect();\n+    let mut split: Vec<&str> = data.rsplitn(4, |c: char| c == '\u00e4').collect();\n     split.reverse();\n     assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n }"}, {"sha": "5a5989211952913ea800c291818e7576510006ed", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "patch": "@@ -304,7 +304,7 @@ macro_rules! options {\n     {\n         let mut op = $defaultfn();\n         for option in matches.opt_strs($prefix) {\n-            let mut iter = option.splitn(1, '=');\n+            let mut iter = option.splitn(2, '=');\n             let key = iter.next().unwrap();\n             let value = iter.next();\n             let option_to_lookup = key.replace(\"-\", \"_\");\n@@ -958,7 +958,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     }\n \n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n-        let mut parts = s.splitn(1, '=');\n+        let mut parts = s.splitn(2, '=');\n         let kind = parts.next().unwrap();\n         let (name, kind) = match (parts.next(), kind) {\n             (None, name) |\n@@ -1010,7 +1010,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let mut externs = HashMap::new();\n     for arg in &matches.opt_strs(\"extern\") {\n-        let mut parts = arg.splitn(1, '=');\n+        let mut parts = arg.splitn(2, '=');\n         let name = match parts.next() {\n             Some(s) => s,\n             None => early_error(\"--extern value must not be empty\"),"}, {"sha": "e5847400496833a6cf7274019d4fba7076ccdc53", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "patch": "@@ -74,7 +74,7 @@ pub enum PpMode {\n pub fn parse_pretty(sess: &Session,\n                     name: &str,\n                     extended: bool) -> (PpMode, Option<UserIdentifiedItem>) {\n-    let mut split = name.splitn(1, '=');\n+    let mut split = name.splitn(2, '=');\n     let first = split.next().unwrap();\n     let opt_second = split.next();\n     let first = match (first, extended) {"}, {"sha": "d1dcfc26008686624e92cdd22ce8085caf612980", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "patch": "@@ -333,7 +333,7 @@ fn acquire_input(input: &str,\n fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n     let mut externs = HashMap::new();\n     for arg in &matches.opt_strs(\"extern\") {\n-        let mut parts = arg.splitn(1, '=');\n+        let mut parts = arg.splitn(2, '=');\n         let name = match parts.next() {\n             Some(s) => s,\n             None => {"}, {"sha": "886f252fb192672b086bc347b87f8b0acae2d130", "filename": "src/libstd/net/addr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibstd%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibstd%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Faddr.rs?ref=e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "patch": "@@ -441,7 +441,7 @@ impl ToSocketAddrs for str {\n         }\n \n         // split the string by ':' and convert the second part to u16\n-        let mut parts_iter = self.rsplitn(1, ':');\n+        let mut parts_iter = self.rsplitn(2, ':');\n         let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n         let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n         let port: u16 = try_opt!(port_str.parse().ok(), \"invalid port value\");"}, {"sha": "4471b5afa84c888b600cd0def724eca4013466c8", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "patch": "@@ -415,7 +415,7 @@ fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n         // contents of the encoding and (2) new &OsStr values are produced\n         // only from ASCII-bounded slices of existing &OsStr values.\n \n-        let mut iter = os_str_as_u8_slice(file).rsplitn(1, |b| *b == b'.');\n+        let mut iter = os_str_as_u8_slice(file).rsplitn(2, |b| *b == b'.');\n         let after = iter.next();\n         let before = iter.next();\n         if before == Some(b\"\") {"}, {"sha": "d2220bdec32b78fa1f054a720742c900ac7a6e63", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=e9bacbaa2c9c88aaecf07ee30f02d08a1999e5c6", "patch": "@@ -409,7 +409,7 @@ pub fn env() -> Env {\n     };\n \n     fn parse(input: &[u8]) -> (OsString, OsString) {\n-        let mut it = input.splitn(1, |b| *b == b'=');\n+        let mut it = input.splitn(2, |b| *b == b'=');\n         let key = it.next().unwrap().to_vec();\n         let default: &[u8] = &[];\n         let val = it.next().unwrap_or(default).to_vec();"}]}