{"sha": "fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNmE1NGQyMjA3YzlhYjJjNWViNWFhM2M5NDg4ZDkyYzdjODZiZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-31T23:30:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-31T23:30:57Z"}, "message": "Auto merge of #56878 - petrochenkov:privdyn, r=arielb1\n\nprivacy: Use common `DefId` visiting infrastructure for all privacy visitors\n\nOne repeating pattern in privacy checking is going through a type, visiting all `DefId`s inside it and doing something with them.\nThis is the case because visibilities and reachabilities are attached to `DefId`s.\n\nPreviously various privacy visitors visited types slightly differently using their own methods, with most recently written `TypePrivacyVisitor` being the \"gold standard\".\nThis mostly worked okay, but differences could manifest in overly conservative reachability analysis, some errors being reported twice, some private-in-public lints (not errors) being wrongly reported or not reported.\n\nThis PR does something that I wanted to do since https://github.com/rust-lang/rust/pull/32674#discussion_r58291608 - factoring out the common visiting logic!\nNow all the common logic is contained in `struct DefIdVisitorSkeleton`, with specific privacy visitors deciding only what to do with visited `DefId`s (via `trait DefIdVisitor`).\n\nA bunch of cleanups is also applied in the process.\nThis area is somewhat tricky due to lots of easily miss-able details, but thankfully it's was well covered by tests in https://github.com/rust-lang/rust/pull/46083 and previous PRs, so I'm relatively sure in the refactoring correctness.\n\nFixes https://github.com/rust-lang/rust/pull/56837#discussion_r241962239 in particular.\nAlso this will help with implementing https://github.com/rust-lang/rust/issues/48054.", "tree": {"sha": "6679295c9f2d8390701a58a66e0124bd647dc9dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6679295c9f2d8390701a58a66e0124bd647dc9dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "html_url": "https://github.com/rust-lang/rust/commit/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9eac386342c601b14311b435f2b6d314fc817bb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/9eac386342c601b14311b435f2b6d314fc817bb5", "html_url": "https://github.com/rust-lang/rust/commit/9eac386342c601b14311b435f2b6d314fc817bb5"}, {"sha": "60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "url": "https://api.github.com/repos/rust-lang/rust/commits/60d1fa70bbb017632f43c206e5f16b0b5bbd0149", "html_url": "https://github.com/rust-lang/rust/commit/60d1fa70bbb017632f43c206e5f16b0b5bbd0149"}], "stats": {"total": 1180, "additions": 621, "deletions": 559}, "files": [{"sha": "7e87171a5edf7579adb492fcd076d2b20e19a2fd", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -2090,6 +2090,15 @@ impl VisibilityKind {\n             VisibilityKind::Restricted { .. } => true,\n         }\n     }\n+\n+    pub fn descr(&self) -> &'static str {\n+        match *self {\n+            VisibilityKind::Public => \"public\",\n+            VisibilityKind::Inherited => \"private\",\n+            VisibilityKind::Crate(..) => \"crate-visible\",\n+            VisibilityKind::Restricted { .. } => \"restricted\",\n+        }\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "318d7adb1901107f70a0fbf539968fc0908ad176", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -709,6 +709,9 @@ define_print! {\n \n define_print! {\n     ('tcx) ty::ExistentialTraitRef<'tcx>, (self, f, cx) {\n+        display {\n+            cx.parameterized(f, self.substs, self.def_id, &[])\n+        }\n         debug {\n             ty::tls::with(|tcx| {\n                 let dummy_self = tcx.mk_infer(ty::FreshTy(0));"}, {"sha": "c6626c1551f4a17e66faf7c2881b6e65cd60ae1d", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 446, "deletions": 514, "changes": 960, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -20,22 +20,279 @@ use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n use rustc::lint;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n-use rustc::ty::{self, TyCtxt, Ty, TypeFoldable, GenericParamDefKind};\n+use rustc::ty::{self, TyCtxt, Ty, TraitRef, TypeFoldable, GenericParamDefKind};\n use rustc::ty::fold::TypeVisitor;\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::UnpackedKind;\n+use rustc::ty::subst::Substs;\n use rustc::util::nodemap::NodeSet;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast::{self, CRATE_NODE_ID, Ident};\n+use syntax::attr;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n \n-use std::cmp;\n-use std::mem::replace;\n+use std::{cmp, fmt, mem};\n+use std::marker::PhantomData;\n \n mod diagnostics;\n \n+////////////////////////////////////////////////////////////////////////////////\n+/// Generic infrastructure used to implement specific visitors below.\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// Implemented to visit all `DefId`s in a type.\n+/// Visiting `DefId`s is useful because visibilities and reachabilities are attached to them.\n+/// The idea is to visit \"all components of a type\", as documented in\n+/// https://github.com/rust-lang/rfcs/blob/master/text/2145-type-privacy.md#how-to-determine-visibility-of-a-type\n+/// Default type visitor (`TypeVisitor`) does most of the job, but it has some shortcomings.\n+/// First, it doesn't have overridable `fn visit_trait_ref`, so we have to catch trait def-ids\n+/// manually. Second, it doesn't visit some type components like signatures of fn types, or traits\n+/// in `impl Trait`, see individual commits in `DefIdVisitorSkeleton::visit_ty`.\n+trait DefIdVisitor<'a, 'tcx: 'a> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+    fn recurse_into_assoc_tys(&self) -> bool { true }\n+    fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool;\n+\n+    /// Not overridden, but used to actually visit types and traits.\n+    fn skeleton(&mut self) -> DefIdVisitorSkeleton<'_, 'a, 'tcx, Self> {\n+        DefIdVisitorSkeleton {\n+            def_id_visitor: self,\n+            visited_opaque_tys: Default::default(),\n+            dummy: Default::default(),\n+        }\n+    }\n+    fn visit(&mut self, ty_fragment: impl TypeFoldable<'tcx>) -> bool {\n+        ty_fragment.visit_with(&mut self.skeleton())\n+    }\n+    fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n+        self.skeleton().visit_trait(trait_ref)\n+    }\n+    fn visit_predicates(&mut self, predicates: Lrc<ty::GenericPredicates<'tcx>>) -> bool {\n+        self.skeleton().visit_predicates(predicates)\n+    }\n+}\n+\n+struct DefIdVisitorSkeleton<'v, 'a, 'tcx, V>\n+    where V: DefIdVisitor<'a, 'tcx> + ?Sized\n+{\n+    def_id_visitor: &'v mut V,\n+    visited_opaque_tys: FxHashSet<DefId>,\n+    dummy: PhantomData<TyCtxt<'a, 'tcx, 'tcx>>,\n+}\n+\n+impl<'a, 'tcx, V> DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n+    where V: DefIdVisitor<'a, 'tcx> + ?Sized\n+{\n+    fn visit_trait(&mut self, trait_ref: TraitRef<'tcx>) -> bool {\n+        let TraitRef { def_id, substs } = trait_ref;\n+        self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref) || substs.visit_with(self)\n+    }\n+\n+    fn visit_predicates(&mut self, predicates: Lrc<ty::GenericPredicates<'tcx>>) -> bool {\n+        let ty::GenericPredicates { parent: _, predicates } = &*predicates;\n+        for (predicate, _span) in predicates {\n+            match predicate {\n+                ty::Predicate::Trait(poly_predicate) => {\n+                    let ty::TraitPredicate { trait_ref } = *poly_predicate.skip_binder();\n+                    if self.visit_trait(trait_ref) {\n+                        return true;\n+                    }\n+                }\n+                ty::Predicate::Projection(poly_predicate) => {\n+                    let ty::ProjectionPredicate { projection_ty, ty } =\n+                        *poly_predicate.skip_binder();\n+                    if ty.visit_with(self) {\n+                        return true;\n+                    }\n+                    if self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx())) {\n+                        return true;\n+                    }\n+                }\n+                ty::Predicate::TypeOutlives(poly_predicate) => {\n+                    let ty::OutlivesPredicate(ty, _region) = *poly_predicate.skip_binder();\n+                    if ty.visit_with(self) {\n+                        return true;\n+                    }\n+                }\n+                ty::Predicate::RegionOutlives(..) => {},\n+                _ => bug!(\"unexpected predicate: {:?}\", predicate),\n+            }\n+        }\n+        false\n+    }\n+}\n+\n+impl<'a, 'tcx, V> TypeVisitor<'tcx> for DefIdVisitorSkeleton<'_, 'a, 'tcx, V>\n+    where V: DefIdVisitor<'a, 'tcx> + ?Sized\n+{\n+    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n+        let tcx = self.def_id_visitor.tcx();\n+        // Substs are not visited here because they are visited below in `super_visit_with`.\n+        match ty.sty {\n+            ty::Adt(&ty::AdtDef { did: def_id, .. }, ..) |\n+            ty::Foreign(def_id) |\n+            ty::FnDef(def_id, ..) |\n+            ty::Closure(def_id, ..) |\n+            ty::Generator(def_id, ..) => {\n+                if self.def_id_visitor.visit_def_id(def_id, \"type\", ty) {\n+                    return true;\n+                }\n+                // Default type visitor doesn't visit signatures of fn types.\n+                // Something like `fn() -> Priv {my_func}` is considered a private type even if\n+                // `my_func` is public, so we need to visit signatures.\n+                if let ty::FnDef(..) = ty.sty {\n+                    if tcx.fn_sig(def_id).visit_with(self) {\n+                        return true;\n+                    }\n+                }\n+                // Inherent static methods don't have self type in substs.\n+                // Something like `fn() {my_method}` type of the method\n+                // `impl Pub<Priv> { pub fn my_method() {} }` is considered a private type,\n+                // so we need to visit the self type additionally.\n+                if let Some(assoc_item) = tcx.opt_associated_item(def_id) {\n+                    if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n+                        if tcx.type_of(impl_def_id).visit_with(self) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            ty::Projection(proj) | ty::UnnormalizedProjection(proj) => {\n+                if !self.def_id_visitor.recurse_into_assoc_tys() {\n+                    // Visitors searching for minimal visibility/reachability want to\n+                    // conservatively approximate associated types like `<Type as Trait>::Alias`\n+                    // as visible/reachable even if both `Type` and `Trait` are private.\n+                    // Ideally, associated types should be substituted in the same way as\n+                    // free type aliases, but this isn't done yet.\n+                    return false;\n+                }\n+                // This will also visit substs, so we don't need to recurse.\n+                return self.visit_trait(proj.trait_ref(tcx));\n+            }\n+            ty::Dynamic(predicates, ..) => {\n+                for predicate in *predicates.skip_binder() {\n+                    let trait_ref = match *predicate {\n+                        ty::ExistentialPredicate::Trait(trait_ref) => trait_ref,\n+                        ty::ExistentialPredicate::Projection(proj) => proj.trait_ref(tcx),\n+                        ty::ExistentialPredicate::AutoTrait(def_id) =>\n+                            ty::ExistentialTraitRef { def_id, substs: Substs::empty() },\n+                    };\n+                    let ty::ExistentialTraitRef { def_id, substs: _ } = trait_ref;\n+                    if self.def_id_visitor.visit_def_id(def_id, \"trait\", &trait_ref) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            ty::Opaque(def_id, ..) => {\n+                // Skip repeated `Opaque`s to avoid infinite recursion.\n+                if self.visited_opaque_tys.insert(def_id) {\n+                    // Default type visitor doesn't visit traits in `impl Trait`.\n+                    // Something like `impl PrivTr` is considered a private type,\n+                    // so we need to visit the traits additionally.\n+                    if self.visit_predicates(tcx.predicates_of(def_id)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            // These types don't have their own def-ids (but may have subcomponents\n+            // with def-ids that should be visited recursively).\n+            ty::Bool | ty::Char | ty::Int(..) | ty::Uint(..) |\n+            ty::Float(..) | ty::Str | ty::Never |\n+            ty::Array(..) | ty::Slice(..) | ty::Tuple(..) |\n+            ty::RawPtr(..) | ty::Ref(..) | ty::FnPtr(..) |\n+            ty::Param(..) | ty::Error | ty::GeneratorWitness(..) => {}\n+            ty::Bound(..) | ty::Placeholder(..) | ty::Infer(..) =>\n+                bug!(\"unexpected type: {:?}\", ty),\n+        }\n+\n+        ty.super_visit_with(self)\n+    }\n+}\n+\n+fn def_id_visibility<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n+                               -> (ty::Visibility, Span, &'static str) {\n+    match tcx.hir().as_local_node_id(def_id) {\n+        Some(node_id) => {\n+            let vis = match tcx.hir().get(node_id) {\n+                Node::Item(item) => &item.vis,\n+                Node::ForeignItem(foreign_item) => &foreign_item.vis,\n+                Node::TraitItem(..) | Node::Variant(..) => {\n+                    return def_id_visibility(tcx, tcx.hir().get_parent_did(node_id));\n+                }\n+                Node::ImplItem(impl_item) => {\n+                    match tcx.hir().get(tcx.hir().get_parent(node_id)) {\n+                        Node::Item(item) => match &item.node {\n+                            hir::ItemKind::Impl(.., None, _, _) => &impl_item.vis,\n+                            hir::ItemKind::Impl(.., Some(trait_ref), _, _)\n+                                => return def_id_visibility(tcx, trait_ref.path.def.def_id()),\n+                            kind => bug!(\"unexpected item kind: {:?}\", kind),\n+                        }\n+                        node => bug!(\"unexpected node kind: {:?}\", node),\n+                    }\n+                }\n+                Node::StructCtor(vdata) => {\n+                    let struct_node_id = tcx.hir().get_parent(node_id);\n+                    let item = match tcx.hir().get(struct_node_id) {\n+                        Node::Item(item) => item,\n+                        node => bug!(\"unexpected node kind: {:?}\", node),\n+                    };\n+                    let (mut ctor_vis, mut span, mut descr) =\n+                        (ty::Visibility::from_hir(&item.vis, struct_node_id, tcx),\n+                         item.vis.span, item.vis.node.descr());\n+                    for field in vdata.fields() {\n+                        let field_vis = ty::Visibility::from_hir(&field.vis, node_id, tcx);\n+                        if ctor_vis.is_at_least(field_vis, tcx) {\n+                            ctor_vis = field_vis;\n+                            span = field.vis.span;\n+                            descr = field.vis.node.descr();\n+                        }\n+                    }\n+\n+                    // If the structure is marked as non_exhaustive then lower the\n+                    // visibility to within the crate.\n+                    if ctor_vis == ty::Visibility::Public {\n+                        let adt_def = tcx.adt_def(tcx.hir().get_parent_did(node_id));\n+                        if adt_def.non_enum_variant().is_field_list_non_exhaustive() {\n+                            ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n+                            span = attr::find_by_name(&item.attrs, \"non_exhaustive\").unwrap().span;\n+                            descr = \"crate-visible\";\n+                        }\n+                    }\n+\n+                    return (ctor_vis, span, descr);\n+                }\n+                Node::Expr(expr) => {\n+                    return (ty::Visibility::Restricted(tcx.hir().get_module_parent(expr.id)),\n+                            expr.span, \"private\")\n+                }\n+                node => bug!(\"unexpected node kind: {:?}\", node)\n+            };\n+            (ty::Visibility::from_hir(vis, node_id, tcx), vis.span, vis.node.descr())\n+        }\n+        None => {\n+            let vis = tcx.visibility(def_id);\n+            let descr = if vis == ty::Visibility::Public { \"public\" } else { \"private\" };\n+            (vis, tcx.def_span(def_id), descr)\n+        }\n+    }\n+}\n+\n+// Set the correct `TypeckTables` for the given `item_id` (or an empty table if\n+// there is no `TypeckTables` for the item).\n+fn item_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         node_id: ast::NodeId,\n+                         empty_tables: &'a ty::TypeckTables<'tcx>)\n+                         -> &'a ty::TypeckTables<'tcx> {\n+    let def_id = tcx.hir().local_def_id(node_id);\n+    if tcx.has_typeck_tables(def_id) { tcx.typeck_tables_of(def_id) } else { empty_tables }\n+}\n+\n+fn min<'a, 'tcx>(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                 -> ty::Visibility {\n+    if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n /// Visitor used to determine if pub(restricted) is used anywhere in the crate.\n ///\n@@ -56,6 +313,59 @@ impl<'a, 'tcx> Visitor<'tcx> for PubRestrictedVisitor<'a, 'tcx> {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+/// Visitor used to determine impl visibility and reachability.\n+////////////////////////////////////////////////////////////////////////////////\n+\n+struct FindMin<'a, 'tcx, VL: VisibilityLike> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    access_levels: &'a AccessLevels,\n+    min: VL,\n+}\n+\n+impl<'a, 'tcx, VL: VisibilityLike> DefIdVisitor<'a, 'tcx> for FindMin<'a, 'tcx, VL> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+    fn recurse_into_assoc_tys(&self) -> bool { false }\n+    fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n+        self.min = VL::new_min(self, def_id);\n+        false\n+    }\n+}\n+\n+trait VisibilityLike: Sized {\n+    const MAX: Self;\n+    fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self;\n+\n+    // Returns an over-approximation (`recurse_into_assoc_tys` = false) of visibility due to\n+    // associated types for which we can't determine visibility precisely.\n+    fn of_impl<'a, 'tcx>(node_id: ast::NodeId, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                         access_levels: &'a AccessLevels) -> Self {\n+        let mut find = FindMin { tcx, access_levels, min: Self::MAX };\n+        let def_id = tcx.hir().local_def_id(node_id);\n+        find.visit(tcx.type_of(def_id));\n+        if let Some(trait_ref) = tcx.impl_trait_ref(def_id) {\n+            find.visit_trait(trait_ref);\n+        }\n+        find.min\n+    }\n+}\n+impl VisibilityLike for ty::Visibility {\n+    const MAX: Self = ty::Visibility::Public;\n+    fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self {\n+        min(def_id_visibility(find.tcx, def_id).0, find.min, find.tcx)\n+    }\n+}\n+impl VisibilityLike for Option<AccessLevel> {\n+    const MAX: Self = Some(AccessLevel::Public);\n+    fn new_min<'a, 'tcx>(find: &FindMin<'a, 'tcx, Self>, def_id: DefId) -> Self {\n+        cmp::min(if let Some(node_id) = find.tcx.hir().as_local_node_id(def_id) {\n+            find.access_levels.map.get(&node_id).cloned()\n+        } else {\n+            Self::MAX\n+        }, find.min)\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n /// The embargo visitor, used to determine the exports of the ast\n ////////////////////////////////////////////////////////////////////////////////\n@@ -78,30 +388,6 @@ struct ReachEverythingInTheInterfaceVisitor<'b, 'a: 'b, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n-    fn item_ty_level(&self, item_def_id: DefId) -> Option<AccessLevel> {\n-        let ty_def_id = match self.tcx.type_of(item_def_id).sty {\n-            ty::Adt(adt, _) => adt.did,\n-            ty::Foreign(did) => did,\n-            ty::Dynamic(ref obj, ..) => obj.principal().def_id(),\n-            ty::Projection(ref proj) => proj.trait_ref(self.tcx).def_id,\n-            _ => return Some(AccessLevel::Public)\n-        };\n-        if let Some(node_id) = self.tcx.hir().as_local_node_id(ty_def_id) {\n-            self.get(node_id)\n-        } else {\n-            Some(AccessLevel::Public)\n-        }\n-    }\n-\n-    fn impl_trait_level(&self, impl_def_id: DefId) -> Option<AccessLevel> {\n-        if let Some(trait_ref) = self.tcx.impl_trait_ref(impl_def_id) {\n-            if let Some(node_id) = self.tcx.hir().as_local_node_id(trait_ref.def_id) {\n-                return self.get(node_id);\n-            }\n-        }\n-        Some(AccessLevel::Public)\n-    }\n-\n     fn get(&self, id: ast::NodeId) -> Option<AccessLevel> {\n         self.access_levels.map.get(&id).cloned()\n     }\n@@ -119,10 +405,10 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn reach<'b>(&'b mut self, item_id: ast::NodeId)\n-                 -> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+    fn reach(&mut self, item_id: ast::NodeId, access_level: Option<AccessLevel>)\n+             -> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n         ReachEverythingInTheInterfaceVisitor {\n-            access_level: self.prev_level.map(|l| l.min(AccessLevel::Reachable)),\n+            access_level: cmp::min(access_level, Some(AccessLevel::Reachable)),\n             item_def_id: self.tcx.hir().local_def_id(item_id),\n             ev: self,\n         }\n@@ -138,15 +424,10 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let inherited_item_level = match item.node {\n-            // Impls inherit level from their types and traits.\n-            hir::ItemKind::Impl(..) => {\n-                let def_id = self.tcx.hir().local_def_id(item.id);\n-                cmp::min(self.item_ty_level(def_id), self.impl_trait_level(def_id))\n-            }\n+            hir::ItemKind::Impl(..) =>\n+                Option::<AccessLevel>::of_impl(item.id, self.tcx, &self.access_levels),\n             // Foreign modules inherit level from parents.\n-            hir::ItemKind::ForeignMod(..) => {\n-                self.prev_level\n-            }\n+            hir::ItemKind::ForeignMod(..) => self.prev_level,\n             // Other `pub` items inherit levels from parents.\n             hir::ItemKind::Const(..) | hir::ItemKind::Enum(..) | hir::ItemKind::ExternCrate(..) |\n             hir::ItemKind::GlobalAsm(..) | hir::ItemKind::Fn(..) | hir::ItemKind::Mod(..) |\n@@ -171,18 +452,13 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            hir::ItemKind::Impl(.., None, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n                 for impl_item_ref in impl_item_refs {\n-                    if impl_item_ref.vis.node.is_pub() {\n+                    if trait_ref.is_some() || impl_item_ref.vis.node.is_pub() {\n                         self.update(impl_item_ref.id.node_id, item_level);\n                     }\n                 }\n             }\n-            hir::ItemKind::Impl(.., Some(_), _, ref impl_item_refs) => {\n-                for impl_item_ref in impl_item_refs {\n-                    self.update(impl_item_ref.id.node_id, item_level);\n-                }\n-            }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n                     self.update(trait_item_ref.id.node_id, item_level);\n@@ -205,15 +481,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n                     }\n                 }\n             }\n-            // Impl trait return types mark their parent function.\n-            // It (and its children) are revisited if the change applies.\n-            hir::ItemKind::Existential(ref ty_data) => {\n-                if let Some(impl_trait_fn) = ty_data.impl_trait_fn {\n-                    if let Some(node_id) = self.tcx.hir().as_local_node_id(impl_trait_fn) {\n-                        self.update(node_id, Some(AccessLevel::ReachableFromImplTrait));\n-                    }\n-                }\n-            }\n+            hir::ItemKind::Existential(..) |\n             hir::ItemKind::Use(..) |\n             hir::ItemKind::Static(..) |\n             hir::ItemKind::Const(..) |\n@@ -225,10 +493,6 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemKind::ExternCrate(..) => {}\n         }\n \n-        // Store this node's access level here to propagate the correct\n-        // reachability level through interfaces and children.\n-        let orig_level = replace(&mut self.prev_level, item_level);\n-\n         // Mark all items in interfaces of reachable items as reachable.\n         match item.node {\n             // The interface is empty.\n@@ -239,26 +503,26 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             hir::ItemKind::Use(..) => {}\n             // The interface is empty.\n             hir::ItemKind::GlobalAsm(..) => {}\n-            hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: Some(_), .. }) => {\n-                if item_level.is_some() {\n-                    // Reach the (potentially private) type and the API being exposed.\n-                    self.reach(item.id).ty().predicates();\n-                }\n+            hir::ItemKind::Existential(..) => {\n+                // FIXME: This is some serious pessimization intended to workaround deficiencies\n+                // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n+                // reachable if they are returned via `impl Trait`, even from private functions.\n+                let exist_level = cmp::max(item_level, Some(AccessLevel::ReachableFromImplTrait));\n+                self.reach(item.id, exist_level).generics().predicates().ty();\n             }\n             // Visit everything.\n             hir::ItemKind::Const(..) | hir::ItemKind::Static(..) |\n-            hir::ItemKind::Existential(..) |\n             hir::ItemKind::Fn(..) | hir::ItemKind::Ty(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id).generics().predicates().ty();\n+                    self.reach(item.id, item_level).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id).generics().predicates();\n+                    self.reach(item.id, item_level).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n-                        let mut reach = self.reach(trait_item_ref.id.node_id);\n+                        let mut reach = self.reach(trait_item_ref.id.node_id, item_level);\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == hir::AssociatedItemKind::Type &&\n@@ -272,18 +536,19 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id).generics().predicates();\n+                    self.reach(item.id, item_level).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n-            hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n+            hir::ItemKind::Impl(.., ref impl_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id).generics().predicates().impl_trait_ref();\n+                    self.reach(item.id, item_level).generics().predicates();\n \n                     for impl_item_ref in impl_item_refs {\n-                        let id = impl_item_ref.id.node_id;\n-                        if trait_ref.is_some() || self.get(id).is_some() {\n-                            self.reach(id).generics().predicates().ty();\n+                        let impl_item_level = self.get(impl_item_ref.id.node_id);\n+                        if impl_item_level.is_some() {\n+                            self.reach(impl_item_ref.id.node_id, impl_item_level)\n+                                .generics().predicates().ty();\n                         }\n                     }\n                 }\n@@ -292,54 +557,56 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id).generics().predicates();\n+                    self.reach(item.id, item_level).generics().predicates();\n                 }\n                 for variant in &def.variants {\n-                    if self.get(variant.node.data.id()).is_some() {\n+                    let variant_level = self.get(variant.node.data.id());\n+                    if variant_level.is_some() {\n                         for field in variant.node.data.fields() {\n-                            self.reach(field.id).ty();\n+                            self.reach(field.id, variant_level).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n-                        self.update(item.id, Some(AccessLevel::Reachable));\n+                        self.update(item.id, variant_level);\n                     }\n                 }\n             }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    if self.get(foreign_item.id).is_some() {\n-                        self.reach(foreign_item.id).generics().predicates().ty();\n+                    let foreign_item_level = self.get(foreign_item.id);\n+                    if foreign_item_level.is_some() {\n+                        self.reach(foreign_item.id, foreign_item_level)\n+                            .generics().predicates().ty();\n                     }\n                 }\n             }\n             // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) |\n             hir::ItemKind::Union(ref struct_def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.id).generics().predicates();\n+                    self.reach(item.id, item_level).generics().predicates();\n                     for field in struct_def.fields() {\n-                        if self.get(field.id).is_some() {\n-                            self.reach(field.id).ty();\n+                        let field_level = self.get(field.id);\n+                        if field_level.is_some() {\n+                            self.reach(field.id, field_level).ty();\n                         }\n                     }\n                 }\n             }\n         }\n \n+        let orig_level = mem::replace(&mut self.prev_level, item_level);\n         intravisit::walk_item(self, item);\n-\n         self.prev_level = orig_level;\n     }\n \n     fn visit_block(&mut self, b: &'tcx hir::Block) {\n-        let orig_level = replace(&mut self.prev_level, None);\n-\n         // Blocks can have public items, for example impls, but they always\n         // start as completely private regardless of publicity of a function,\n         // constant, type, field, etc., in which this block resides.\n+        let orig_level = mem::replace(&mut self.prev_level, None);\n         intravisit::walk_block(self, b);\n-\n         self.prev_level = orig_level;\n     }\n \n@@ -410,13 +677,13 @@ impl<'a, 'tcx> Visitor<'tcx> for EmbargoVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n+impl<'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n     fn generics(&mut self) -> &mut Self {\n         for param in &self.ev.tcx.generics_of(self.item_def_id).params {\n             match param.kind {\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     if has_default {\n-                        self.ev.tcx.type_of(param.def_id).visit_with(self);\n+                        self.visit(self.ev.tcx.type_of(param.def_id));\n                     }\n                 }\n                 GenericParamDefKind::Lifetime => {}\n@@ -426,73 +693,23 @@ impl<'b, 'a, 'tcx> ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n     }\n \n     fn predicates(&mut self) -> &mut Self {\n-        let predicates = self.ev.tcx.predicates_of(self.item_def_id);\n-        for (predicate, _) in &predicates.predicates {\n-            predicate.visit_with(self);\n-            match predicate {\n-                &ty::Predicate::Trait(poly_predicate) => {\n-                    self.check_trait_ref(poly_predicate.skip_binder().trait_ref);\n-                },\n-                &ty::Predicate::Projection(poly_predicate) => {\n-                    let tcx = self.ev.tcx;\n-                    self.check_trait_ref(\n-                        poly_predicate.skip_binder().projection_ty.trait_ref(tcx)\n-                    );\n-                },\n-                _ => (),\n-            };\n-        }\n+        self.visit_predicates(self.ev.tcx.predicates_of(self.item_def_id));\n         self\n     }\n \n     fn ty(&mut self) -> &mut Self {\n-        let ty = self.ev.tcx.type_of(self.item_def_id);\n-        ty.visit_with(self);\n-        if let ty::FnDef(def_id, _) = ty.sty {\n-            if def_id == self.item_def_id {\n-                self.ev.tcx.fn_sig(def_id).visit_with(self);\n-            }\n-        }\n-        self\n-    }\n-\n-    fn impl_trait_ref(&mut self) -> &mut Self {\n-        if let Some(impl_trait_ref) = self.ev.tcx.impl_trait_ref(self.item_def_id) {\n-            self.check_trait_ref(impl_trait_ref);\n-            impl_trait_ref.super_visit_with(self);\n-        }\n+        self.visit(self.ev.tcx.type_of(self.item_def_id));\n         self\n     }\n-\n-    fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) {\n-        if let Some(node_id) = self.ev.tcx.hir().as_local_node_id(trait_ref.def_id) {\n-            let item = self.ev.tcx.hir().expect_item(node_id);\n-            self.ev.update(item.id, self.access_level);\n-        }\n-    }\n }\n \n-impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b, 'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-        let ty_def_id = match ty.sty {\n-            ty::Adt(adt, _) => Some(adt.did),\n-            ty::Foreign(did) => Some(did),\n-            ty::Dynamic(ref obj, ..) => Some(obj.principal().def_id()),\n-            ty::Projection(ref proj) => Some(proj.item_def_id),\n-            ty::FnDef(def_id, ..) |\n-            ty::Closure(def_id, ..) |\n-            ty::Generator(def_id, ..) |\n-            ty::Opaque(def_id, _) => Some(def_id),\n-            _ => None\n-        };\n-\n-        if let Some(def_id) = ty_def_id {\n-            if let Some(node_id) = self.ev.tcx.hir().as_local_node_id(def_id) {\n-                self.ev.update(node_id, self.access_level);\n-            }\n+impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.ev.tcx }\n+    fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n+        if let Some(node_id) = self.ev.tcx.hir().as_local_node_id(def_id) {\n+            self.ev.update(node_id, self.access_level);\n         }\n-\n-        ty.super_visit_with(self)\n+        false\n     }\n }\n \n@@ -528,22 +745,6 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-// Set the correct `TypeckTables` for the given `item_id` (or an empty table if\n-// there is no `TypeckTables` for the item).\n-fn update_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           item_id: ast::NodeId,\n-                           tables: &mut &'a ty::TypeckTables<'tcx>,\n-                           empty_tables: &'a ty::TypeckTables<'tcx>)\n-                           -> &'a ty::TypeckTables<'tcx> {\n-    let def_id = tcx.hir().local_def_id(item_id);\n-\n-    if tcx.has_typeck_tables(def_id) {\n-        replace(tables, tcx.typeck_tables_of(def_id))\n-    } else {\n-        replace(tables, empty_tables)\n-    }\n-}\n-\n impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n@@ -552,28 +753,31 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let orig_tables = replace(&mut self.tables, self.tcx.body_tables(body));\n+        let orig_tables = mem::replace(&mut self.tables, self.tcx.body_tables(body));\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n         self.tables = orig_tables;\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_current_item = replace(&mut self.current_item, item.id);\n-        let orig_tables = update_tables(self.tcx, item.id, &mut self.tables, self.empty_tables);\n+        let orig_current_item = mem::replace(&mut self.current_item, item.id);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, item.id, self.empty_tables));\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n         self.tables = orig_tables;\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        let orig_tables = update_tables(self.tcx, ti.id, &mut self.tables, self.empty_tables);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ti.id, self.empty_tables));\n         intravisit::walk_trait_item(self, ti);\n         self.tables = orig_tables;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        let orig_tables = update_tables(self.tcx, ii.id, &mut self.tables, self.empty_tables);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ii.id, self.empty_tables));\n         intravisit::walk_impl_item(self, ii);\n         self.tables = orig_tables;\n     }\n@@ -644,88 +848,35 @@ struct TypePrivacyVisitor<'a, 'tcx: 'a> {\n     in_body: bool,\n     span: Span,\n     empty_tables: &'a ty::TypeckTables<'tcx>,\n-    visited_opaque_tys: FxHashSet<DefId>\n }\n \n impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n-    fn def_id_visibility(&self, did: DefId) -> ty::Visibility {\n-        match self.tcx.hir().as_local_node_id(did) {\n-            Some(node_id) => {\n-                let vis = match self.tcx.hir().get(node_id) {\n-                    Node::Item(item) => &item.vis,\n-                    Node::ForeignItem(foreign_item) => &foreign_item.vis,\n-                    Node::ImplItem(impl_item) => &impl_item.vis,\n-                    Node::TraitItem(..) |\n-                    Node::Variant(..) => {\n-                        return self.def_id_visibility(self.tcx.hir().get_parent_did(node_id));\n-                    }\n-                    Node::StructCtor(vdata) => {\n-                        let struct_node_id = self.tcx.hir().get_parent(node_id);\n-                        let struct_vis = match self.tcx.hir().get(struct_node_id) {\n-                            Node::Item(item) => &item.vis,\n-                            node => bug!(\"unexpected node kind: {:?}\", node),\n-                        };\n-                        let mut ctor_vis\n-                            = ty::Visibility::from_hir(struct_vis, struct_node_id, self.tcx);\n-                        for field in vdata.fields() {\n-                            let field_vis = ty::Visibility::from_hir(&field.vis, node_id, self.tcx);\n-                            if ctor_vis.is_at_least(field_vis, self.tcx) {\n-                                ctor_vis = field_vis;\n-                            }\n-                        }\n-\n-                        // If the structure is marked as non_exhaustive then lower the\n-                        // visibility to within the crate.\n-                        let struct_def_id = self.tcx.hir().get_parent_did(node_id);\n-                        let adt_def = self.tcx.adt_def(struct_def_id);\n-                        if adt_def.non_enum_variant().is_field_list_non_exhaustive()\n-                            && ctor_vis == ty::Visibility::Public\n-                        {\n-                            ctor_vis = ty::Visibility::Restricted(\n-                                DefId::local(CRATE_DEF_INDEX));\n-                        }\n-\n-                        return ctor_vis;\n-                    }\n-                    node => bug!(\"unexpected node kind: {:?}\", node)\n-                };\n-                ty::Visibility::from_hir(vis, node_id, self.tcx)\n-            }\n-            None => self.tcx.visibility(did),\n-        }\n-    }\n-\n     fn item_is_accessible(&self, did: DefId) -> bool {\n-        self.def_id_visibility(did).is_accessible_from(self.current_item, self.tcx)\n+        def_id_visibility(self.tcx, did).0.is_accessible_from(self.current_item, self.tcx)\n     }\n \n     // Take node-id of an expression or pattern and check its type for privacy.\n     fn check_expr_pat_type(&mut self, id: hir::HirId, span: Span) -> bool {\n         self.span = span;\n-        if self.tables.node_id_to_type(id).visit_with(self) {\n-            return true;\n-        }\n-        if self.tables.node_substs(id).visit_with(self) {\n+        if self.visit(self.tables.node_id_to_type(id)) || self.visit(self.tables.node_substs(id)) {\n             return true;\n         }\n         if let Some(adjustments) = self.tables.adjustments().get(id) {\n             for adjustment in adjustments {\n-                if adjustment.target.visit_with(self) {\n+                if self.visit(adjustment.target) {\n                     return true;\n                 }\n             }\n         }\n         false\n     }\n \n-    fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n-        if !self.item_is_accessible(trait_ref.def_id) {\n-            let msg = format!(\"trait `{}` is private\", trait_ref);\n-            self.tcx.sess.span_err(self.span, &msg);\n-            return true;\n+    fn check_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n+        let is_error = !self.item_is_accessible(def_id);\n+        if is_error {\n+            self.tcx.sess.span_err(self.span, &format!(\"{} `{}` is private\", kind, descr));\n         }\n-\n-        trait_ref.super_visit_with(self)\n+        is_error\n     }\n }\n \n@@ -737,8 +888,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let orig_tables = replace(&mut self.tables, self.tcx.body_tables(body));\n-        let orig_in_body = replace(&mut self.in_body, true);\n+        let orig_tables = mem::replace(&mut self.tables, self.tcx.body_tables(body));\n+        let orig_in_body = mem::replace(&mut self.in_body, true);\n         let body = self.tcx.hir().body(body);\n         self.visit_body(body);\n         self.tables = orig_tables;\n@@ -749,14 +900,14 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         self.span = hir_ty.span;\n         if self.in_body {\n             // Types in bodies.\n-            if self.tables.node_id_to_type(hir_ty.hir_id).visit_with(self) {\n+            if self.visit(self.tables.node_id_to_type(hir_ty.hir_id)) {\n                 return;\n             }\n         } else {\n             // Types in signatures.\n             // FIXME: This is very ineffective. Ideally each HIR type should be converted\n             // into a semantic type only once and the result should be cached somehow.\n-            if rustc_typeck::hir_ty_to_ty(self.tcx, hir_ty).visit_with(self) {\n+            if self.visit(rustc_typeck::hir_ty_to_ty(self.tcx, hir_ty)) {\n                 return;\n             }\n         }\n@@ -771,12 +922,13 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             // The traits' privacy in bodies is already checked as a part of trait object types.\n             let (principal, projections) =\n                 rustc_typeck::hir_trait_to_predicates(self.tcx, trait_ref);\n-            if self.check_trait_ref(*principal.skip_binder()) {\n+            if self.visit_trait(*principal.skip_binder()) {\n                 return;\n             }\n             for (poly_predicate, _) in projections {\n                 let tcx = self.tcx;\n-                if self.check_trait_ref(poly_predicate.skip_binder().projection_ty.trait_ref(tcx)) {\n+                if self.visit(poly_predicate.skip_binder().ty) ||\n+                   self.visit_trait(poly_predicate.skip_binder().projection_ty.trait_ref(tcx)) {\n                     return;\n                 }\n             }\n@@ -802,8 +954,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n                 // Method calls have to be checked specially.\n                 self.span = span;\n                 if let Some(def) = self.tables.type_dependent_defs().get(expr.hir_id) {\n-                    let def_id = def.def_id();\n-                    if self.tcx.type_of(def_id).visit_with(self) {\n+                    if self.visit(self.tcx.type_of(def.def_id())) {\n                         return;\n                     }\n                 } else {\n@@ -827,7 +978,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         let def = match *qpath {\n             hir::QPath::Resolved(_, ref path) => match path.def {\n                 Def::Method(..) | Def::AssociatedConst(..) |\n-                Def::AssociatedTy(..) | Def::Static(..) => Some(path.def),\n+                Def::AssociatedTy(..) | Def::AssociatedExistential(..) |\n+                Def::Static(..) => Some(path.def),\n                 _ => None,\n             }\n             hir::QPath::TypeRelative(..) => {\n@@ -874,122 +1026,36 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let orig_current_item = self.current_item;\n-        let orig_tables = update_tables(self.tcx,\n-                                        item.id,\n-                                        &mut self.tables,\n-                                        self.empty_tables);\n-        let orig_in_body = replace(&mut self.in_body, false);\n-        self.current_item = self.tcx.hir().local_def_id(item.id);\n+        let orig_current_item =\n+            mem::replace(&mut self.current_item, self.tcx.hir().local_def_id(item.id));\n+        let orig_in_body = mem::replace(&mut self.in_body, false);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, item.id, self.empty_tables));\n         intravisit::walk_item(self, item);\n         self.tables = orig_tables;\n         self.in_body = orig_in_body;\n         self.current_item = orig_current_item;\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n-        let orig_tables = update_tables(self.tcx, ti.id, &mut self.tables, self.empty_tables);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ti.id, self.empty_tables));\n         intravisit::walk_trait_item(self, ti);\n         self.tables = orig_tables;\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n-        let orig_tables = update_tables(self.tcx, ii.id, &mut self.tables, self.empty_tables);\n+        let orig_tables =\n+            mem::replace(&mut self.tables, item_tables(self.tcx, ii.id, self.empty_tables));\n         intravisit::walk_impl_item(self, ii);\n         self.tables = orig_tables;\n     }\n }\n \n-impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-        match ty.sty {\n-            ty::Adt(&ty::AdtDef { did: def_id, .. }, ..) |\n-            ty::FnDef(def_id, ..) |\n-            ty::Foreign(def_id) => {\n-                if !self.item_is_accessible(def_id) {\n-                    let msg = format!(\"type `{}` is private\", ty);\n-                    self.tcx.sess.span_err(self.span, &msg);\n-                    return true;\n-                }\n-                if let ty::FnDef(..) = ty.sty {\n-                    if self.tcx.fn_sig(def_id).visit_with(self) {\n-                        return true;\n-                    }\n-                }\n-                // Inherent static methods don't have self type in substs,\n-                // we have to check it additionally.\n-                if let Some(assoc_item) = self.tcx.opt_associated_item(def_id) {\n-                    if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n-                        if self.tcx.type_of(impl_def_id).visit_with(self) {\n-                            return true;\n-                        }\n-                    }\n-                }\n-            }\n-            ty::Dynamic(ref predicates, ..) => {\n-                let is_private = predicates.skip_binder().iter().any(|predicate| {\n-                    let def_id = match *predicate {\n-                        ty::ExistentialPredicate::Trait(trait_ref) => trait_ref.def_id,\n-                        ty::ExistentialPredicate::Projection(proj) =>\n-                            proj.trait_ref(self.tcx).def_id,\n-                        ty::ExistentialPredicate::AutoTrait(def_id) => def_id,\n-                    };\n-                    !self.item_is_accessible(def_id)\n-                });\n-                if is_private {\n-                    let msg = format!(\"type `{}` is private\", ty);\n-                    self.tcx.sess.span_err(self.span, &msg);\n-                    return true;\n-                }\n-            }\n-            ty::Projection(ref proj) => {\n-                let tcx = self.tcx;\n-                if self.check_trait_ref(proj.trait_ref(tcx)) {\n-                    return true;\n-                }\n-            }\n-            ty::Opaque(def_id, ..) => {\n-                for (predicate, _) in &self.tcx.predicates_of(def_id).predicates {\n-                    let trait_ref = match *predicate {\n-                        ty::Predicate::Trait(ref poly_trait_predicate) => {\n-                            Some(poly_trait_predicate.skip_binder().trait_ref)\n-                        }\n-                        ty::Predicate::Projection(ref poly_projection_predicate) => {\n-                            if poly_projection_predicate.skip_binder().ty.visit_with(self) {\n-                                return true;\n-                            }\n-                            Some(poly_projection_predicate.skip_binder()\n-                                                          .projection_ty.trait_ref(self.tcx))\n-                        }\n-                        ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => None,\n-                        _ => bug!(\"unexpected predicate: {:?}\", predicate),\n-                    };\n-                    if let Some(trait_ref) = trait_ref {\n-                        if !self.item_is_accessible(trait_ref.def_id) {\n-                            let msg = format!(\"trait `{}` is private\", trait_ref);\n-                            self.tcx.sess.span_err(self.span, &msg);\n-                            return true;\n-                        }\n-                        for subst in trait_ref.substs.iter() {\n-                            // Skip repeated `Opaque`s to avoid infinite recursion.\n-                            if let UnpackedKind::Type(ty) = subst.unpack() {\n-                                if let ty::Opaque(def_id, ..) = ty.sty {\n-                                    if !self.visited_opaque_tys.insert(def_id) {\n-                                        continue;\n-                                    }\n-                                }\n-                            }\n-                            if subst.visit_with(self) {\n-                                return true;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        ty.super_visit_with(self)\n+impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+    fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n+        self.check_def_id(def_id, kind, descr)\n     }\n }\n \n@@ -1283,13 +1349,13 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n         for predicate in &generics.where_clause.predicates {\n             match predicate {\n-                &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n+                hir::WherePredicate::BoundPredicate(bound_pred) => {\n                     for bound in bound_pred.bounds.iter() {\n                         self.check_generic_bound(bound)\n                     }\n                 }\n-                &hir::WherePredicate::RegionPredicate(_) => {}\n-                &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n+                hir::WherePredicate::RegionPredicate(_) => {}\n+                hir::WherePredicate::EqPredicate(eq_pred) => {\n                     self.visit_ty(&eq_pred.rhs_ty);\n                 }\n             }\n@@ -1349,8 +1415,6 @@ struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     span: Span,\n     /// The visitor checks that each component type is at least this visible.\n     required_visibility: ty::Visibility,\n-    /// The visibility of the least visible component that has been visited.\n-    min_visibility: ty::Visibility,\n     has_pub_restricted: bool,\n     has_old_errors: bool,\n     in_assoc_ty: bool,\n@@ -1362,7 +1426,7 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n             match param.kind {\n                 GenericParamDefKind::Type { has_default, .. } => {\n                     if has_default {\n-                        self.tcx.type_of(param.def_id).visit_with(self);\n+                        self.visit(self.tcx.type_of(param.def_id));\n                     }\n                 }\n                 GenericParamDefKind::Lifetime => {}\n@@ -1378,140 +1442,54 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n         // consider the ones that the user wrote. This is important\n         // for the inferred outlives rules; see\n         // `src/test/ui/rfc-2093-infer-outlives/privacy.rs`.\n-        let predicates = self.tcx.explicit_predicates_of(self.item_def_id);\n-        for (predicate, _) in &predicates.predicates {\n-            predicate.visit_with(self);\n-            match predicate {\n-                &ty::Predicate::Trait(poly_predicate) => {\n-                    self.check_trait_ref(poly_predicate.skip_binder().trait_ref);\n-                },\n-                &ty::Predicate::Projection(poly_predicate) => {\n-                    let tcx = self.tcx;\n-                    self.check_trait_ref(\n-                        poly_predicate.skip_binder().projection_ty.trait_ref(tcx)\n-                    );\n-                },\n-                _ => (),\n-            };\n-        }\n+        self.visit_predicates(self.tcx.explicit_predicates_of(self.item_def_id));\n         self\n     }\n \n     fn ty(&mut self) -> &mut Self {\n-        let ty = self.tcx.type_of(self.item_def_id);\n-        ty.visit_with(self);\n-        if let ty::FnDef(def_id, _) = ty.sty {\n-            if def_id == self.item_def_id {\n-                self.tcx.fn_sig(def_id).visit_with(self);\n-            }\n-        }\n+        self.visit(self.tcx.type_of(self.item_def_id));\n         self\n     }\n \n-    fn impl_trait_ref(&mut self) -> &mut Self {\n-        if let Some(impl_trait_ref) = self.tcx.impl_trait_ref(self.item_def_id) {\n-            self.check_trait_ref(impl_trait_ref);\n-            impl_trait_ref.super_visit_with(self);\n-        }\n-        self\n-    }\n+    fn check_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n+        let node_id = match self.tcx.hir().as_local_node_id(def_id) {\n+            Some(node_id) => node_id,\n+            None => return false,\n+        };\n \n-    fn check_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) {\n-        // Non-local means public (private items can't leave their crate, modulo bugs).\n-        if let Some(node_id) = self.tcx.hir().as_local_node_id(trait_ref.def_id) {\n-            let item = self.tcx.hir().expect_item(node_id);\n-            let vis = ty::Visibility::from_hir(&item.vis, node_id, self.tcx);\n-            if !vis.is_at_least(self.min_visibility, self.tcx) {\n-                self.min_visibility = vis;\n-            }\n-            if !vis.is_at_least(self.required_visibility, self.tcx) {\n-                if self.has_pub_restricted || self.has_old_errors || self.in_assoc_ty {\n-                    struct_span_err!(self.tcx.sess, self.span, E0445,\n-                                     \"private trait `{}` in public interface\", trait_ref)\n-                        .span_label(self.span, format!(\n-                                    \"can't leak private trait\"))\n-                        .emit();\n+        let (vis, vis_span, vis_descr) = def_id_visibility(self.tcx, def_id);\n+        if !vis.is_at_least(self.required_visibility, self.tcx) {\n+            let msg = format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr);\n+            if self.has_pub_restricted || self.has_old_errors || self.in_assoc_ty {\n+                let mut err = if kind == \"trait\" {\n+                    struct_span_err!(self.tcx.sess, self.span, E0445, \"{}\", msg)\n                 } else {\n-                    self.tcx.lint_node(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                       node_id,\n-                                       self.span,\n-                                       &format!(\"private trait `{}` in public \\\n-                                                 interface (error E0445)\", trait_ref));\n-                }\n+                    struct_span_err!(self.tcx.sess, self.span, E0446, \"{}\", msg)\n+                };\n+                err.span_label(self.span, format!(\"can't leak {} {}\", vis_descr, kind));\n+                err.span_label(vis_span, format!(\"`{}` declared as {}\", descr, vis_descr));\n+                err.emit();\n+            } else {\n+                let err_code = if kind == \"trait\" { \"E0445\" } else { \"E0446\" };\n+                self.tcx.lint_node(lint::builtin::PRIVATE_IN_PUBLIC, node_id, self.span,\n+                                   &format!(\"{} (error {})\", msg, err_code));\n             }\n         }\n+        false\n     }\n }\n \n-impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> bool {\n-        let ty_def_id = match ty.sty {\n-            ty::Adt(adt, _) => Some(adt.did),\n-            ty::Foreign(did) => Some(did),\n-            ty::Dynamic(ref obj, ..) => Some(obj.principal().def_id()),\n-            ty::Projection(ref proj) => {\n-                if self.required_visibility == ty::Visibility::Invisible {\n-                    // Conservatively approximate the whole type alias as public without\n-                    // recursing into its components when determining impl publicity.\n-                    // For example, `impl <Type as Trait>::Alias {...}` may be a public impl\n-                    // even if both `Type` and `Trait` are private.\n-                    // Ideally, associated types should be substituted in the same way as\n-                    // free type aliases, but this isn't done yet.\n-                    return false;\n-                }\n-                let trait_ref = proj.trait_ref(self.tcx);\n-                Some(trait_ref.def_id)\n-            }\n-            _ => None\n-        };\n-\n-        if let Some(def_id) = ty_def_id {\n-            // Non-local means public (private items can't leave their crate, modulo bugs).\n-            if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n-                let hir_vis = match self.tcx.hir().find(node_id) {\n-                    Some(Node::Item(item)) => &item.vis,\n-                    Some(Node::ForeignItem(item)) => &item.vis,\n-                    _ => bug!(\"expected item of foreign item\"),\n-                };\n-\n-                let vis = ty::Visibility::from_hir(hir_vis, node_id, self.tcx);\n-\n-                if !vis.is_at_least(self.min_visibility, self.tcx) {\n-                    self.min_visibility = vis;\n-                }\n-                if !vis.is_at_least(self.required_visibility, self.tcx) {\n-                    let vis_adj = match hir_vis.node {\n-                        hir::VisibilityKind::Crate(_) => \"crate-visible\",\n-                        hir::VisibilityKind::Restricted { .. } => \"restricted\",\n-                        _ => \"private\"\n-                    };\n-\n-                    if self.has_pub_restricted || self.has_old_errors || self.in_assoc_ty {\n-                        let mut err = struct_span_err!(self.tcx.sess, self.span, E0446,\n-                            \"{} type `{}` in public interface\", vis_adj, ty);\n-                        err.span_label(self.span, format!(\"can't leak {} type\", vis_adj));\n-                        err.span_label(hir_vis.span, format!(\"`{}` declared as {}\", ty, vis_adj));\n-                        err.emit();\n-                    } else {\n-                        self.tcx.lint_node(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                           node_id,\n-                                           self.span,\n-                                           &format!(\"{} type `{}` in public \\\n-                                                     interface (error E0446)\", vis_adj, ty));\n-                    }\n-                }\n-            }\n-        }\n-\n-        ty.super_visit_with(self)\n+impl<'a, 'tcx> DefIdVisitor<'a, 'tcx> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.tcx }\n+    fn visit_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n+        self.check_def_id(def_id, kind, descr)\n     }\n }\n \n struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     has_pub_restricted: bool,\n     old_error_set: &'a NodeSet,\n-    inner_visibility: ty::Visibility,\n }\n \n impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n@@ -1544,7 +1522,6 @@ impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n             tcx: self.tcx,\n             item_def_id: self.tcx.hir().local_def_id(item_id),\n             span: self.tcx.hir().span(item_id),\n-            min_visibility: ty::Visibility::Public,\n             required_visibility,\n             has_pub_restricted: self.has_pub_restricted,\n             has_old_errors,\n@@ -1560,10 +1537,6 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let tcx = self.tcx;\n-        let min = |vis1: ty::Visibility, vis2| {\n-            if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n-        };\n-\n         let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, tcx);\n \n         match item.node {\n@@ -1575,23 +1548,10 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             hir::ItemKind::Use(..) => {}\n             // No subitems.\n             hir::ItemKind::GlobalAsm(..) => {}\n-            hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: Some(_), .. }) => {\n-                // Check the traits being exposed, as they're separate,\n-                // e.g., `impl Iterator<Item=T>` has two predicates,\n-                // `X: Iterator` and `<X as Iterator>::Item == T`,\n-                // where `X` is the `impl Iterator<Item=T>` itself,\n-                // stored in `predicates_of`, not in the `Ty` itself.\n-                self.check(item.id, item_visibility).predicates();\n-            }\n             // Subitems of these items have inherited publicity.\n             hir::ItemKind::Const(..) | hir::ItemKind::Static(..) | hir::ItemKind::Fn(..) |\n-            hir::ItemKind::Existential(..) |\n-            hir::ItemKind::Ty(..) => {\n+            hir::ItemKind::Existential(..) | hir::ItemKind::Ty(..) => {\n                 self.check(item.id, item_visibility).generics().predicates().ty();\n-\n-                // Recurse for e.g., `impl Trait` (see `visit_ty`).\n-                self.inner_visibility = item_visibility;\n-                intravisit::walk_item(self, item);\n             }\n             hir::ItemKind::Trait(.., ref trait_item_refs) => {\n                 self.check(item.id, item_visibility).generics().predicates();\n@@ -1635,56 +1595,30 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n                 for field in struct_def.fields() {\n                     let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, tcx);\n-                    self.check(field.id, min(item_visibility, field_visibility)).ty();\n+                    self.check(field.id, min(item_visibility, field_visibility, tcx)).ty();\n                 }\n             }\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity.\n-            hir::ItemKind::Impl(.., None, _, ref impl_item_refs) => {\n-                let ty_vis =\n-                    self.check(item.id, ty::Visibility::Invisible).ty().min_visibility;\n-                self.check(item.id, ty_vis).generics().predicates();\n-\n-                for impl_item_ref in impl_item_refs {\n-                    let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n-                    let impl_item_vis = ty::Visibility::from_hir(&impl_item.vis, item.id, tcx);\n-                    let mut check = self.check(impl_item.id, min(impl_item_vis, ty_vis));\n-                    check.in_assoc_ty = impl_item_ref.kind == hir::AssociatedItemKind::Type;\n-                    check.generics().predicates().ty();\n-\n-                    // Recurse for e.g., `impl Trait` (see `visit_ty`).\n-                    self.inner_visibility = impl_item_vis;\n-                    intravisit::walk_impl_item(self, impl_item);\n-                }\n-            }\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity.\n-            hir::ItemKind::Impl(.., Some(_), _, ref impl_item_refs) => {\n-                let vis = self.check(item.id, ty::Visibility::Invisible)\n-                              .ty().impl_trait_ref().min_visibility;\n-                self.check(item.id, vis).generics().predicates();\n+            hir::ItemKind::Impl(.., ref trait_ref, _, ref impl_item_refs) => {\n+                let impl_vis = ty::Visibility::of_impl(item.id, tcx, &Default::default());\n+                self.check(item.id, impl_vis).generics().predicates();\n                 for impl_item_ref in impl_item_refs {\n-                    let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n-                    let mut check = self.check(impl_item.id, vis);\n+                    let impl_item = tcx.hir().impl_item(impl_item_ref.id);\n+                    let impl_item_vis = if trait_ref.is_none() {\n+                        min(ty::Visibility::from_hir(&impl_item.vis, item.id, tcx), impl_vis, tcx)\n+                    } else {\n+                        impl_vis\n+                    };\n+                    let mut check = self.check(impl_item.id, impl_item_vis);\n                     check.in_assoc_ty = impl_item_ref.kind == hir::AssociatedItemKind::Type;\n                     check.generics().predicates().ty();\n-\n-                    // Recurse for e.g., `impl Trait` (see `visit_ty`).\n-                    self.inner_visibility = vis;\n-                    intravisit::walk_impl_item(self, impl_item);\n                 }\n             }\n         }\n     }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &'tcx hir::ImplItem) {\n-        // Handled in `visit_item` above.\n-    }\n-\n-    // Don't recurse into expressions in array sizes or const initializers.\n-    fn visit_expr(&mut self, _: &'tcx hir::Expr) {}\n-    // Don't recurse into patterns in function arguments.\n-    fn visit_pat(&mut self, _: &'tcx hir::Pat) {}\n }\n \n pub fn provide(providers: &mut Providers) {\n@@ -1724,7 +1658,6 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         in_body: false,\n         span: krate.span,\n         empty_tables: &empty_tables,\n-        visited_opaque_tys: FxHashSet::default()\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n \n@@ -1770,7 +1703,6 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             tcx,\n             has_pub_restricted,\n             old_error_set: &visitor.old_error_set,\n-            inner_visibility: ty::Visibility::Public,\n         };\n         krate.visit_all_item_likes(&mut DeepVisitor::new(&mut visitor));\n     }"}, {"sha": "855efbd3eb5d6261b62e5ee269770ad8dd697f8f", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -160,11 +160,6 @@ impl RawHandle {\n         }\n     }\n \n-    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        let mut me = self;\n-        (&mut me).read_to_end(buf)\n-    }\n-\n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let mut amt = 0;\n         let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;"}, {"sha": "a4f4bd22cd921ad259911b919c2fafe70c3a37ac", "filename": "src/libstd/sys/windows/stdio.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstdio.rs?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -128,11 +128,6 @@ impl Stdin {\n         // MemReader shouldn't error here since we just filled it\n         utf8.read(buf)\n     }\n-\n-    pub fn read_to_end(&self, buf: &mut Vec<u8>) -> io::Result<usize> {\n-        let mut me = self;\n-        (&mut me).read_to_end(buf)\n-    }\n }\n \n #[unstable(reason = \"not public\", issue = \"0\", feature = \"fd_read\")]"}, {"sha": "a9a3aee2500fb5549c5f87aa57b345f5c7ca1069", "filename": "src/test/ui/error-codes/E0445.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Ferror-codes%2FE0445.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Ferror-codes%2FE0445.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0445.rs?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -4,12 +4,9 @@ trait Foo {\n \n pub trait Bar : Foo {}\n //~^ ERROR private trait `Foo` in public interface [E0445]\n-//~| NOTE can't leak private trait\n pub struct Bar2<T: Foo>(pub T);\n //~^ ERROR private trait `Foo` in public interface [E0445]\n-//~| NOTE can't leak private trait\n pub fn foo<T: Foo> (t: T) {}\n //~^ ERROR private trait `Foo` in public interface [E0445]\n-//~| NOTE can't leak private trait\n \n fn main() {}"}, {"sha": "d0d6ebe16c7f7cbcf5325fae4d2f471a5c6de1ad", "filename": "src/test/ui/error-codes/E0445.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Ferror-codes%2FE0445.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Ferror-codes%2FE0445.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0445.stderr?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -5,13 +5,13 @@ LL | pub trait Bar : Foo {}\n    | ^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `Foo` in public interface\n-  --> $DIR/E0445.rs:8:1\n+  --> $DIR/E0445.rs:7:1\n    |\n LL | pub struct Bar2<T: Foo>(pub T);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `Foo` in public interface\n-  --> $DIR/E0445.rs:11:1\n+  --> $DIR/E0445.rs:9:1\n    |\n LL | pub fn foo<T: Foo> (t: T) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait"}, {"sha": "13671b8dbf448f2d4ef92d24fca8a987edf9f059", "filename": "src/test/ui/impl-trait/issue-49376.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-49376.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-49376.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-49376.rs?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -9,9 +9,11 @@ fn gen() -> impl PartialOrd + PartialEq + Debug { }\n \n struct Bar {}\n trait Foo<T = Self> {}\n+trait FooNested<T = Option<Self>> {}\n impl Foo for Bar {}\n+impl FooNested for Bar {}\n \n-fn foo() -> impl Foo {\n+fn foo() -> impl Foo + FooNested {\n     Bar {}\n }\n "}, {"sha": "02ff6b6d5bff4b3d426397def063d0a97dc5b629", "filename": "src/test/ui/issues/issue-18389.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fissues%2Fissue-18389.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fissues%2Fissue-18389.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18389.stderr?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -1,6 +1,9 @@\n error[E0445]: private trait `Private<<Self as Public>::P, <Self as Public>::R>` in public interface\n   --> $DIR/issue-18389.rs:7:1\n    |\n+LL |   trait Private<P, R> {\n+   |   - `Private<<Self as Public>::P, <Self as Public>::R>` declared as private\n+...\n LL | / pub trait Public: Private<\n LL | | //~^ ERROR private trait `Private<<Self as Public>::P, <Self as Public>::R>` in public interface\n LL | |     <Self as Public>::P,"}, {"sha": "591e9df81eb0b7ce8d1d6b58923bde60f26aa47d", "filename": "src/test/ui/privacy/associated-item-privacy-type-binding.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.rs?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -9,19 +9,19 @@ mod priv_trait {\n \n     pub macro mac1() {\n         let _: Box<PubTr<AssocTy = u8>>;\n-        //~^ ERROR type `(dyn priv_trait::PubTr<AssocTy=u8> + '<empty>)` is private\n-        //~| ERROR type `(dyn priv_trait::PubTr<AssocTy=u8> + '<empty>)` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n+        //~| ERROR trait `priv_trait::PrivTr` is private\n         type InSignatureTy2 = Box<PubTr<AssocTy = u8>>;\n-        //~^ ERROR type `(dyn priv_trait::PubTr<AssocTy=u8> + 'static)` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n         trait InSignatureTr2: PubTr<AssocTy = u8> {}\n         //~^ ERROR trait `priv_trait::PrivTr` is private\n     }\n     pub macro mac2() {\n         let _: Box<PrivTr<AssocTy = u8>>;\n-        //~^ ERROR type `(dyn priv_trait::PrivTr<AssocTy=u8> + '<empty>)` is private\n-        //~| ERROR type `(dyn priv_trait::PrivTr<AssocTy=u8> + '<empty>)` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n+        //~| ERROR trait `priv_trait::PrivTr` is private\n         type InSignatureTy1 = Box<PrivTr<AssocTy = u8>>;\n-        //~^ ERROR type `(dyn priv_trait::PrivTr<AssocTy=u8> + 'static)` is private\n+        //~^ ERROR trait `priv_trait::PrivTr` is private\n         trait InSignatureTr1: PrivTr<AssocTy = u8> {}\n         //~^ ERROR trait `priv_trait::PrivTr` is private\n     }"}, {"sha": "7f6886d7f9ad446e17b6dbda3cf5e44a5ad0198b", "filename": "src/test/ui/privacy/associated-item-privacy-type-binding.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-type-binding.stderr?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -1,4 +1,4 @@\n-error: type `(dyn priv_trait::PubTr<AssocTy=u8> + '<empty>)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:11:13\n    |\n LL |         let _: Box<PubTr<AssocTy = u8>>;\n@@ -7,7 +7,7 @@ LL |         let _: Box<PubTr<AssocTy = u8>>;\n LL |     priv_trait::mac1!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PubTr<AssocTy=u8> + '<empty>)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:11:16\n    |\n LL |         let _: Box<PubTr<AssocTy = u8>>;\n@@ -16,7 +16,7 @@ LL |         let _: Box<PubTr<AssocTy = u8>>;\n LL |     priv_trait::mac1!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PubTr<AssocTy=u8> + 'static)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:14:31\n    |\n LL |         type InSignatureTy2 = Box<PubTr<AssocTy = u8>>;\n@@ -34,7 +34,7 @@ LL |         trait InSignatureTr2: PubTr<AssocTy = u8> {}\n LL |     priv_trait::mac1!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PrivTr<AssocTy=u8> + '<empty>)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:20:13\n    |\n LL |         let _: Box<PrivTr<AssocTy = u8>>;\n@@ -43,7 +43,7 @@ LL |         let _: Box<PrivTr<AssocTy = u8>>;\n LL |     priv_trait::mac2!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PrivTr<AssocTy=u8> + '<empty>)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:20:16\n    |\n LL |         let _: Box<PrivTr<AssocTy = u8>>;\n@@ -52,7 +52,7 @@ LL |         let _: Box<PrivTr<AssocTy = u8>>;\n LL |     priv_trait::mac2!();\n    |     -------------------- in this macro invocation\n \n-error: type `(dyn priv_trait::PrivTr<AssocTy=u8> + 'static)` is private\n+error: trait `priv_trait::PrivTr` is private\n   --> $DIR/associated-item-privacy-type-binding.rs:23:31\n    |\n LL |         type InSignatureTy1 = Box<PrivTr<AssocTy = u8>>;"}, {"sha": "a3e53bdf45de3f6a95540c1b625de4af2ce49bda", "filename": "src/test/ui/privacy/private-in-public-expr-pat.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-expr-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-expr-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-expr-pat.rs?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -0,0 +1,13 @@\n+// Patterns and expressions are not interface parts and don't produce private-in-public errors.\n+\n+// compile-pass\n+\n+struct Priv1(usize);\n+struct Priv2;\n+\n+pub struct Pub(Priv2);\n+\n+pub fn public_expr(_: [u8; Priv1(0).0]) {} // OK\n+pub fn public_pat(Pub(Priv2): Pub) {} // OK\n+\n+fn main() {}"}, {"sha": "02fd92aa7a4ef95573d8ba68605b0bb030bbc644", "filename": "src/test/ui/privacy/private-in-public-non-principal-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.rs?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -0,0 +1,13 @@\n+#![feature(optin_builtin_traits)]\n+\n+#[allow(private_in_public)]\n+mod m {\n+    pub trait PubPrincipal {}\n+    auto trait PrivNonPrincipal {}\n+    pub fn leak_dyn_nonprincipal() -> Box<PubPrincipal + PrivNonPrincipal> { loop {} }\n+}\n+\n+fn main() {\n+    m::leak_dyn_nonprincipal();\n+    //~^ ERROR trait `m::PrivNonPrincipal` is private\n+}"}, {"sha": "2db49257226424fad138f7520313007411104320", "filename": "src/test/ui/privacy/private-in-public-non-principal-2.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal-2.stderr?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -0,0 +1,8 @@\n+error: trait `m::PrivNonPrincipal` is private\n+  --> $DIR/private-in-public-non-principal-2.rs:11:5\n+   |\n+LL |     m::leak_dyn_nonprincipal();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "5de5a685208cde885035827d35f66bf92231836a", "filename": "src/test/ui/privacy/private-in-public-non-principal.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.rs?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -0,0 +1,20 @@\n+#![feature(optin_builtin_traits)]\n+\n+pub trait PubPrincipal {}\n+auto trait PrivNonPrincipal {}\n+\n+pub fn leak_dyn_nonprincipal() -> Box<PubPrincipal + PrivNonPrincipal> { loop {} }\n+//~^ WARN private trait `PrivNonPrincipal` in public interface\n+//~| WARN this was previously accepted\n+\n+#[deny(missing_docs)]\n+fn container() {\n+    impl dyn PubPrincipal {\n+        pub fn check_doc_lint() {} //~ ERROR missing documentation for a method\n+    }\n+    impl dyn PubPrincipal + PrivNonPrincipal {\n+        pub fn check_doc_lint() {} // OK, no missing doc lint\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "996740558977709fb5c5f8402c337aa7e9c4845e", "filename": "src/test/ui/privacy/private-in-public-non-principal.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-non-principal.stderr?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -0,0 +1,24 @@\n+warning: private trait `PrivNonPrincipal` in public interface (error E0445)\n+  --> $DIR/private-in-public-non-principal.rs:6:1\n+   |\n+LL | pub fn leak_dyn_nonprincipal() -> Box<PubPrincipal + PrivNonPrincipal> { loop {} }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: #[warn(private_in_public)] on by default\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n+\n+error: missing documentation for a method\n+  --> $DIR/private-in-public-non-principal.rs:13:9\n+   |\n+LL |         pub fn check_doc_lint() {} //~ ERROR missing documentation for a method\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/private-in-public-non-principal.rs:10:8\n+   |\n+LL | #[deny(missing_docs)]\n+   |        ^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "29f365b69be4df85230ecca05fb7de164e10d540", "filename": "src/test/ui/privacy/private-in-public-warn.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.rs?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -213,6 +213,15 @@ mod aliases_pub {\n     impl PrivUseAliasTr for <Priv as PrivTr>::AssocAlias {\n         type Check = Priv; //~ ERROR private type `aliases_pub::Priv` in public interface\n     }\n+    impl PrivUseAliasTr for Option<<Priv as PrivTr>::AssocAlias> {\n+        type Check = Priv; //~ ERROR private type `aliases_pub::Priv` in public interface\n+    }\n+    impl PrivUseAliasTr for (<Priv as PrivTr>::AssocAlias, Priv) {\n+        type Check = Priv; // OK\n+    }\n+    impl PrivUseAliasTr for Option<(<Priv as PrivTr>::AssocAlias, Priv)> {\n+        type Check = Priv; // OK\n+    }\n }\n \n mod aliases_priv {"}, {"sha": "8f9e7cd74f9926008e8741e806a63e750efcbc34", "filename": "src/test/ui/privacy/private-in-public-warn.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public-warn.stderr?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -297,33 +297,42 @@ LL |     struct Priv;\n LL |         type Check = Priv; //~ ERROR private type `aliases_pub::Priv` in public interface\n    |         ^^^^^^^^^^^^^^^^^^ can't leak private type\n \n+error[E0446]: private type `aliases_pub::Priv` in public interface\n+  --> $DIR/private-in-public-warn.rs:217:9\n+   |\n+LL |     struct Priv;\n+   |     - `aliases_pub::Priv` declared as private\n+...\n+LL |         type Check = Priv; //~ ERROR private type `aliases_pub::Priv` in public interface\n+   |         ^^^^^^^^^^^^^^^^^^ can't leak private type\n+\n error: private trait `aliases_priv::PrivTr1` in public interface (error E0445)\n-  --> $DIR/private-in-public-warn.rs:238:5\n+  --> $DIR/private-in-public-warn.rs:247:5\n    |\n LL |     pub trait Tr1: PrivUseAliasTr {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n-error: private type `aliases_priv::Priv2` in public interface (error E0446)\n-  --> $DIR/private-in-public-warn.rs:241:5\n+error: private trait `aliases_priv::PrivTr1<aliases_priv::Priv2>` in public interface (error E0445)\n+  --> $DIR/private-in-public-warn.rs:250:5\n    |\n LL |     pub trait Tr2: PrivUseAliasTr<PrivAlias> {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n-error: private trait `aliases_priv::PrivTr1<aliases_priv::Priv2>` in public interface (error E0445)\n-  --> $DIR/private-in-public-warn.rs:241:5\n+error: private type `aliases_priv::Priv2` in public interface (error E0446)\n+  --> $DIR/private-in-public-warn.rs:250:5\n    |\n LL |     pub trait Tr2: PrivUseAliasTr<PrivAlias> {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #34537 <https://github.com/rust-lang/rust/issues/34537>\n \n-error: aborting due to 35 previous errors\n+error: aborting due to 36 previous errors\n \n For more information about this error, try `rustc --explain E0446`."}, {"sha": "08c00f44f22690e8a1cade0344eb3c86867f7d89", "filename": "src/test/ui/privacy/private-in-public.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.rs?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -102,7 +102,7 @@ mod aliases_pub {\n \n     // This should be OK, but associated type aliases are not substituted yet\n     pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n-    //~^ ERROR private type `<aliases_pub::Priv as aliases_pub::PrivTr>::Assoc` in public interface\n+    //~^ ERROR private trait `aliases_pub::PrivTr` in public interface\n     //~| ERROR private type `aliases_pub::Priv` in public interface\n \n     impl PrivUseAlias {\n@@ -131,7 +131,7 @@ mod aliases_priv {\n     pub fn f1(arg: PrivUseAlias) {} //~ ERROR private type `aliases_priv::Priv1` in public interface\n     pub fn f2(arg: PrivAlias) {} //~ ERROR private type `aliases_priv::Priv2` in public interface\n     pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n-    //~^ ERROR private type `<aliases_priv::Priv as aliases_priv::PrivTr>::Assoc` in public\n+    //~^ ERROR private trait `aliases_priv::PrivTr` in public interface\n     //~| ERROR private type `aliases_priv::Priv` in public interface\n }\n "}, {"sha": "bf88a83e633cc82227b36647f04d5b6baaddae61", "filename": "src/test/ui/privacy/private-in-public.stderr", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-in-public.stderr?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -82,24 +82,36 @@ LL |         pub fn f2() -> Priv { panic!() } //~ ERROR private type `types::Pri\n error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:31:5\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits::PrivTr` declared as private\n+...\n LL |     pub enum E<T: PrivTr> { V(T) } //~ ERROR private trait `traits::PrivTr` in public interface\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:32:5\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits::PrivTr` declared as private\n+...\n LL |     pub fn f<T: PrivTr>(arg: T) {} //~ ERROR private trait `traits::PrivTr` in public interface\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:33:5\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits::PrivTr` declared as private\n+...\n LL |     pub struct S1<T: PrivTr>(T); //~ ERROR private trait `traits::PrivTr` in public interface\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:34:5\n    |\n+LL |       trait PrivTr {}\n+   |       - `traits::PrivTr` declared as private\n+...\n LL | /     impl<T: PrivTr> Pub<T> { //~ ERROR private trait `traits::PrivTr` in public interface\n LL | |         pub fn f<U: PrivTr>(arg: U) {} //~ ERROR private trait `traits::PrivTr` in public interface\n LL | |     }\n@@ -108,30 +120,45 @@ LL | |     }\n error[E0445]: private trait `traits::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:35:9\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits::PrivTr` declared as private\n+...\n LL |         pub fn f<U: PrivTr>(arg: U) {} //~ ERROR private trait `traits::PrivTr` in public interface\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:44:5\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits_where::PrivTr` declared as private\n+...\n LL |     pub enum E<T> where T: PrivTr { V(T) }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:46:5\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits_where::PrivTr` declared as private\n+...\n LL |     pub fn f<T>(arg: T) where T: PrivTr {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:48:5\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits_where::PrivTr` declared as private\n+...\n LL |     pub struct S1<T>(T) where T: PrivTr;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:50:5\n    |\n+LL |       trait PrivTr {}\n+   |       - `traits_where::PrivTr` declared as private\n+...\n LL | /     impl<T> Pub<T> where T: PrivTr {\n LL | |     //~^ ERROR private trait `traits_where::PrivTr` in public interface\n LL | |         pub fn f<U>(arg: U) where U: PrivTr {}\n@@ -142,6 +169,9 @@ LL | |     }\n error[E0445]: private trait `traits_where::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:52:9\n    |\n+LL |     trait PrivTr {}\n+   |     - `traits_where::PrivTr` declared as private\n+...\n LL |         pub fn f<U>(arg: U) where U: PrivTr {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n@@ -181,14 +211,14 @@ LL |     struct Priv;\n LL |         pub fn f(arg: Priv) {} //~ ERROR private type `impls::Priv` in public interface\n    |         ^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n-error[E0446]: private type `<aliases_pub::Priv as aliases_pub::PrivTr>::Assoc` in public interface\n+error[E0445]: private trait `aliases_pub::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:104:5\n    |\n LL |     trait PrivTr {\n-   |     - `<aliases_pub::Priv as aliases_pub::PrivTr>::Assoc` declared as private\n+   |     - `aliases_pub::PrivTr` declared as private\n ...\n LL |     pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0446]: private type `aliases_pub::Priv` in public interface\n   --> $DIR/private-in-public.rs:104:5\n@@ -226,14 +256,14 @@ LL |     struct Priv2;\n LL |     pub fn f2(arg: PrivAlias) {} //~ ERROR private type `aliases_priv::Priv2` in public interface\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n \n-error[E0446]: private type `<aliases_priv::Priv as aliases_priv::PrivTr>::Assoc` in public interface\n+error[E0445]: private trait `aliases_priv::PrivTr` in public interface\n   --> $DIR/private-in-public.rs:133:5\n    |\n LL |     trait PrivTr {\n-   |     - `<aliases_priv::Priv as aliases_priv::PrivTr>::Assoc` declared as private\n+   |     - `aliases_priv::PrivTr` declared as private\n ...\n LL |     pub fn f3(arg: <Priv as PrivTr>::Assoc) {}\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private type\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't leak private trait\n \n error[E0446]: private type `aliases_priv::Priv` in public interface\n   --> $DIR/private-in-public.rs:133:5"}, {"sha": "69b60a56c67f1c8313f02a896c3c3979c94c05b7", "filename": "src/test/ui/privacy/private-inferred-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -119,7 +119,7 @@ fn main() {\n     m::leak_anon2(); //~ ERROR type `m::Priv` is private\n     m::leak_anon3(); //~ ERROR type `m::Priv` is private\n \n-    m::leak_dyn1(); //~ ERROR type `(dyn m::Trait + 'static)` is private\n+    m::leak_dyn1(); //~ ERROR trait `m::Trait` is private\n     m::leak_dyn2(); //~ ERROR type `m::Priv` is private\n     m::leak_dyn3(); //~ ERROR type `m::Priv` is private\n "}, {"sha": "80a475f7dceea2266002e1897d0d930768aa09e0", "filename": "src/test/ui/privacy/private-inferred-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr?ref=fe6a54d2207c9ab2c5eb5aa3c9488d92c7c86bfb", "patch": "@@ -160,10 +160,10 @@ error: type `m::Priv` is private\n LL |     m::leak_anon3(); //~ ERROR type `m::Priv` is private\n    |     ^^^^^^^^^^^^^^^\n \n-error: type `(dyn m::Trait + 'static)` is private\n+error: trait `m::Trait` is private\n   --> $DIR/private-inferred-type.rs:122:5\n    |\n-LL |     m::leak_dyn1(); //~ ERROR type `(dyn m::Trait + 'static)` is private\n+LL |     m::leak_dyn1(); //~ ERROR trait `m::Trait` is private\n    |     ^^^^^^^^^^^^^^\n \n error: type `m::Priv` is private"}]}