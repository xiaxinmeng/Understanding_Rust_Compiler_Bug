{"sha": "98c500cf8361ef1a6b7152a321515146e02cbd10", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4YzUwMGNmODM2MWVmMWE2YjcxNTJhMzIxNTE1MTQ2ZTAyY2JkMTA=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-07-16T19:41:19Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-07-18T01:49:19Z"}, "message": "Factor BinOp utils", "tree": {"sha": "d9ba45b21953d7248e2a361b94ac143dc62a7b37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9ba45b21953d7248e2a361b94ac143dc62a7b37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98c500cf8361ef1a6b7152a321515146e02cbd10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98c500cf8361ef1a6b7152a321515146e02cbd10", "html_url": "https://github.com/rust-lang/rust/commit/98c500cf8361ef1a6b7152a321515146e02cbd10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98c500cf8361ef1a6b7152a321515146e02cbd10/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efbf7ca61e6d024cd73c75bbbe43999350b55ac1", "url": "https://api.github.com/repos/rust-lang/rust/commits/efbf7ca61e6d024cd73c75bbbe43999350b55ac1", "html_url": "https://github.com/rust-lang/rust/commit/efbf7ca61e6d024cd73c75bbbe43999350b55ac1"}], "stats": {"total": 283, "additions": 95, "deletions": 188}, "files": [{"sha": "17ce3cd809f6fcb9e88618b955750b5fd9372516", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 27, "deletions": 64, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/98c500cf8361ef1a6b7152a321515146e02cbd10/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c500cf8361ef1a6b7152a321515146e02cbd10/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=98c500cf8361ef1a6b7152a321515146e02cbd10", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{eq_expr_value, get_trait_def_id, trait_ref_of_method};\n-use clippy_utils::{paths, sugg};\n+use clippy_utils::{binop_traits, sugg};\n+use clippy_utils::{eq_expr_value, trait_ref_of_method};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n@@ -85,71 +85,34 @@ impl<'tcx> LateLintPass<'tcx> for AssignOps {\n                     let lint = |assignee: &hir::Expr<'_>, rhs: &hir::Expr<'_>| {\n                         let ty = cx.typeck_results().expr_ty(assignee);\n                         let rty = cx.typeck_results().expr_ty(rhs);\n-                        macro_rules! ops {\n-                            ($op:expr,\n-                             $cx:expr,\n-                             $ty:expr,\n-                             $rty:expr,\n-                             $($trait_name:ident),+) => {\n-                                match $op {\n-                                    $(hir::BinOpKind::$trait_name => {\n-                                        let [krate, module] = paths::OPS_MODULE;\n-                                        let path: [&str; 3] = [krate, module, concat!(stringify!($trait_name), \"Assign\")];\n-                                        let trait_id = if let Some(trait_id) = get_trait_def_id($cx, &path) {\n-                                            trait_id\n-                                        } else {\n-                                            return; // useless if the trait doesn't exist\n-                                        };\n-                                        // check that we are not inside an `impl AssignOp` of this exact operation\n-                                        let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id);\n-                                        if_chain! {\n-                                            if let Some(trait_ref) = trait_ref_of_method(cx, parent_fn);\n-                                            if trait_ref.path.res.def_id() == trait_id;\n-                                            then { return; }\n+                        if_chain! {\n+                            if let Some((_, lang_item)) = binop_traits(op.node);\n+                            if let Ok(trait_id) = cx.tcx.lang_items().require(lang_item);\n+                            let parent_fn = cx.tcx.hir().get_parent_item(e.hir_id);\n+                            if trait_ref_of_method(cx, parent_fn)\n+                                .map_or(true, |t| t.path.res.def_id() != trait_id);\n+                            if implements_trait(cx, ty, trait_id, &[rty.into()]);\n+                            then {\n+                                span_lint_and_then(\n+                                    cx,\n+                                    ASSIGN_OP_PATTERN,\n+                                    expr.span,\n+                                    \"manual implementation of an assign operation\",\n+                                    |diag| {\n+                                        if let (Some(snip_a), Some(snip_r)) =\n+                                            (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span))\n+                                        {\n+                                            diag.span_suggestion(\n+                                                expr.span,\n+                                                \"replace it with\",\n+                                                format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n+                                                Applicability::MachineApplicable,\n+                                            );\n                                         }\n-                                        implements_trait($cx, $ty, trait_id, &[$rty])\n-                                    },)*\n-                                    _ => false,\n-                                }\n+                                    },\n+                                );\n                             }\n                         }\n-                        if ops!(\n-                            op.node,\n-                            cx,\n-                            ty,\n-                            rty.into(),\n-                            Add,\n-                            Sub,\n-                            Mul,\n-                            Div,\n-                            Rem,\n-                            And,\n-                            Or,\n-                            BitAnd,\n-                            BitOr,\n-                            BitXor,\n-                            Shr,\n-                            Shl\n-                        ) {\n-                            span_lint_and_then(\n-                                cx,\n-                                ASSIGN_OP_PATTERN,\n-                                expr.span,\n-                                \"manual implementation of an assign operation\",\n-                                |diag| {\n-                                    if let (Some(snip_a), Some(snip_r)) =\n-                                        (snippet_opt(cx, assignee.span), snippet_opt(cx, rhs.span))\n-                                    {\n-                                        diag.span_suggestion(\n-                                            expr.span,\n-                                            \"replace it with\",\n-                                            format!(\"{} {}= {}\", snip_a, op.node.as_str(), snip_r),\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                    }\n-                                },\n-                            );\n-                        }\n                     };\n \n                     let mut visitor = ExprVisitor {"}, {"sha": "f2bffd553210b1d5d0c531543a60a7b02b286bd9", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 28, "deletions": 115, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/98c500cf8361ef1a6b7152a321515146e02cbd10/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c500cf8361ef1a6b7152a321515146e02cbd10/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=98c500cf8361ef1a6b7152a321515146e02cbd10", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{get_trait_def_id, paths, trait_ref_of_method};\n+use clippy_utils::{binop_traits, trait_ref_of_method, BINOP_TRAITS, OP_ASSIGN_TRAITS};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n@@ -55,135 +55,48 @@ declare_lint_pass!(SuspiciousImpl => [SUSPICIOUS_ARITHMETIC_IMPL, SUSPICIOUS_OP_\n \n impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if let hir::ExprKind::Binary(binop, _, _) | hir::ExprKind::AssignOp(binop, ..) = expr.kind {\n-            match binop.node {\n-                hir::BinOpKind::Eq\n-                | hir::BinOpKind::Lt\n-                | hir::BinOpKind::Le\n-                | hir::BinOpKind::Ne\n-                | hir::BinOpKind::Ge\n-                | hir::BinOpKind::Gt => return,\n-                _ => {},\n-            }\n+        if_chain! {\n+            if let hir::ExprKind::Binary(binop, _, _) | hir::ExprKind::AssignOp(binop, ..) = expr.kind;\n+            if let Some((binop_trait_lang, op_assign_trait_lang)) = binop_traits(binop.node);\n+            if let Ok(binop_trait_id) = cx.tcx.lang_items().require(binop_trait_lang);\n+            if let Ok(op_assign_trait_id) = cx.tcx.lang_items().require(op_assign_trait_lang);\n \n             // Check for more than one binary operation in the implemented function\n             // Linting when multiple operations are involved can result in false positives\n             let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);\n-            if_chain! {\n-                if let hir::Node::ImplItem(impl_item) = cx.tcx.hir().get(parent_fn);\n-                if let hir::ImplItemKind::Fn(_, body_id) = impl_item.kind;\n-                then {\n-                    let body = cx.tcx.hir().body(body_id);\n-                    let mut visitor = BinaryExprVisitor { nb_binops: 0 };\n-                    walk_expr(&mut visitor, &body.value);\n-                    if visitor.nb_binops > 1 {\n-                        return;\n-                    }\n-                }\n-            }\n-\n-            if let Some(impl_trait) = check_binop(\n-                cx,\n-                expr,\n-                binop.node,\n-                &[\n-                    \"Add\", \"Sub\", \"Mul\", \"Div\", \"Rem\", \"BitAnd\", \"BitOr\", \"BitXor\", \"Shl\", \"Shr\",\n-                ],\n-                &[\n-                    hir::BinOpKind::Add,\n-                    hir::BinOpKind::Sub,\n-                    hir::BinOpKind::Mul,\n-                    hir::BinOpKind::Div,\n-                    hir::BinOpKind::Rem,\n-                    hir::BinOpKind::BitAnd,\n-                    hir::BinOpKind::BitOr,\n-                    hir::BinOpKind::BitXor,\n-                    hir::BinOpKind::Shl,\n-                    hir::BinOpKind::Shr,\n-                ],\n-            ) {\n-                span_lint(\n-                    cx,\n-                    SUSPICIOUS_ARITHMETIC_IMPL,\n-                    binop.span,\n-                    &format!(\"suspicious use of binary operator in `{}` impl\", impl_trait),\n-                );\n-            }\n-\n-            if let Some(impl_trait) = check_binop(\n-                cx,\n-                expr,\n-                binop.node,\n-                &[\n-                    \"AddAssign\",\n-                    \"SubAssign\",\n-                    \"MulAssign\",\n-                    \"DivAssign\",\n-                    \"BitAndAssign\",\n-                    \"BitOrAssign\",\n-                    \"BitXorAssign\",\n-                    \"RemAssign\",\n-                    \"ShlAssign\",\n-                    \"ShrAssign\",\n-                ],\n-                &[\n-                    hir::BinOpKind::Add,\n-                    hir::BinOpKind::Sub,\n-                    hir::BinOpKind::Mul,\n-                    hir::BinOpKind::Div,\n-                    hir::BinOpKind::BitAnd,\n-                    hir::BinOpKind::BitOr,\n-                    hir::BinOpKind::BitXor,\n-                    hir::BinOpKind::Rem,\n-                    hir::BinOpKind::Shl,\n-                    hir::BinOpKind::Shr,\n-                ],\n-            ) {\n+            if let hir::Node::ImplItem(impl_item) = cx.tcx.hir().get(parent_fn);\n+            if let hir::ImplItemKind::Fn(_, body_id) = impl_item.kind;\n+            let body = cx.tcx.hir().body(body_id);\n+            let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);\n+            if let Some(trait_ref) = trait_ref_of_method(cx, parent_fn);\n+            let trait_id = trait_ref.path.res.def_id();\n+            if ![binop_trait_id, op_assign_trait_id].contains(&trait_id);\n+            if let Some(&(_, lint)) = [\n+                (&BINOP_TRAITS, SUSPICIOUS_ARITHMETIC_IMPL),\n+                (&OP_ASSIGN_TRAITS, SUSPICIOUS_OP_ASSIGN_IMPL),\n+            ]\n+                .iter()\n+                .find(|&(ts, _)| ts.iter().any(|&t| Ok(trait_id) == cx.tcx.lang_items().require(t)));\n+            if count_binops(&body.value) == 1;\n+            then {\n                 span_lint(\n                     cx,\n-                    SUSPICIOUS_OP_ASSIGN_IMPL,\n+                    lint,\n                     binop.span,\n-                    &format!(\"suspicious use of binary operator in `{}` impl\", impl_trait),\n+                    &format!(\"suspicious use of `{}` in `{}` impl\", binop.node.as_str(), cx.tcx.item_name(trait_id)),\n                 );\n             }\n         }\n     }\n }\n \n-fn check_binop(\n-    cx: &LateContext<'_>,\n-    expr: &hir::Expr<'_>,\n-    binop: hir::BinOpKind,\n-    traits: &[&'static str],\n-    expected_ops: &[hir::BinOpKind],\n-) -> Option<&'static str> {\n-    let mut trait_ids = vec![];\n-    let [krate, module] = paths::OPS_MODULE;\n-\n-    for &t in traits {\n-        let path = [krate, module, t];\n-        if let Some(trait_id) = get_trait_def_id(cx, &path) {\n-            trait_ids.push(trait_id);\n-        } else {\n-            return None;\n-        }\n-    }\n-\n-    // Get the actually implemented trait\n-    let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);\n-\n-    if_chain! {\n-        if let Some(trait_ref) = trait_ref_of_method(cx, parent_fn);\n-        if let Some(idx) = trait_ids.iter().position(|&tid| tid == trait_ref.path.res.def_id());\n-        if binop != expected_ops[idx];\n-        then{\n-            return Some(traits[idx])\n-        }\n-    }\n-\n-    None\n+fn count_binops(expr: &hir::Expr<'_>) -> u32 {\n+    let mut visitor = BinaryExprVisitor::default();\n+    visitor.visit_expr(expr);\n+    visitor.nb_binops\n }\n \n+#[derive(Default)]\n struct BinaryExprVisitor {\n     nb_binops: u32,\n }"}, {"sha": "1fbbf4ac81f0b0056e51503339adfc2c04440371", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/98c500cf8361ef1a6b7152a321515146e02cbd10/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98c500cf8361ef1a6b7152a321515146e02cbd10/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=98c500cf8361ef1a6b7152a321515146e02cbd10", "patch": "@@ -1710,3 +1710,34 @@ pub fn is_test_module_or_function(tcx: TyCtxt<'_>, item: &Item<'_>) -> bool {\n \n     matches!(item.kind, ItemKind::Mod(..)) && item.ident.name.as_str().contains(\"test\")\n }\n+\n+macro_rules! op_utils {\n+    ($($name:ident $assign:ident)*) => {\n+        /// Binary operation traits like `LangItem::Add`\n+        pub static BINOP_TRAITS: &[LangItem] = &[$(LangItem::$name,)*];\n+\n+        /// Operator-Assign traits like `LangItem::AddAssign`\n+        pub static OP_ASSIGN_TRAITS: &[LangItem] = &[$(LangItem::$assign,)*];\n+\n+        /// Converts `BinOpKind::Add` to `(LangItem::Add, LangItem::AddAssign)`, for example\n+        pub fn binop_traits(kind: hir::BinOpKind) -> Option<(LangItem, LangItem)> {\n+            match kind {\n+                $(hir::BinOpKind::$name => Some((LangItem::$name, LangItem::$assign)),)*\n+                _ => None,\n+            }\n+        }\n+    };\n+}\n+\n+op_utils! {\n+    Add    AddAssign\n+    Sub    SubAssign\n+    Mul    MulAssign\n+    Div    DivAssign\n+    Rem    RemAssign\n+    BitXor BitXorAssign\n+    BitAnd BitAndAssign\n+    BitOr  BitOrAssign\n+    Shl    ShlAssign\n+    Shr    ShrAssign\n+}"}, {"sha": "ced1305874e58611862db7bdccddc65428b911fa", "filename": "tests/ui/suspicious_arithmetic_impl.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/98c500cf8361ef1a6b7152a321515146e02cbd10/tests%2Fui%2Fsuspicious_arithmetic_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/98c500cf8361ef1a6b7152a321515146e02cbd10/tests%2Fui%2Fsuspicious_arithmetic_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_arithmetic_impl.stderr?ref=98c500cf8361ef1a6b7152a321515146e02cbd10", "patch": "@@ -1,56 +1,56 @@\n-error: suspicious use of binary operator in `Add` impl\n+error: suspicious use of `-` in `Add` impl\n   --> $DIR/suspicious_arithmetic_impl.rs:13:20\n    |\n LL |         Foo(self.0 - other.0)\n    |                    ^\n    |\n    = note: `-D clippy::suspicious-arithmetic-impl` implied by `-D warnings`\n \n-error: suspicious use of binary operator in `AddAssign` impl\n+error: suspicious use of `-` in `AddAssign` impl\n   --> $DIR/suspicious_arithmetic_impl.rs:19:23\n    |\n LL |         *self = *self - other;\n    |                       ^\n    |\n    = note: `-D clippy::suspicious-op-assign-impl` implied by `-D warnings`\n \n-error: suspicious use of binary operator in `MulAssign` impl\n+error: suspicious use of `/` in `MulAssign` impl\n   --> $DIR/suspicious_arithmetic_impl.rs:32:16\n    |\n LL |         self.0 /= other.0;\n    |                ^^\n \n-error: suspicious use of binary operator in `Rem` impl\n+error: suspicious use of `/` in `Rem` impl\n   --> $DIR/suspicious_arithmetic_impl.rs:70:20\n    |\n LL |         Foo(self.0 / other.0)\n    |                    ^\n \n-error: suspicious use of binary operator in `BitAnd` impl\n+error: suspicious use of `|` in `BitAnd` impl\n   --> $DIR/suspicious_arithmetic_impl.rs:78:20\n    |\n LL |         Foo(self.0 | other.0)\n    |                    ^\n \n-error: suspicious use of binary operator in `BitOr` impl\n+error: suspicious use of `^` in `BitOr` impl\n   --> $DIR/suspicious_arithmetic_impl.rs:86:20\n    |\n LL |         Foo(self.0 ^ other.0)\n    |                    ^\n \n-error: suspicious use of binary operator in `BitXor` impl\n+error: suspicious use of `&` in `BitXor` impl\n   --> $DIR/suspicious_arithmetic_impl.rs:94:20\n    |\n LL |         Foo(self.0 & other.0)\n    |                    ^\n \n-error: suspicious use of binary operator in `Shl` impl\n+error: suspicious use of `>>` in `Shl` impl\n   --> $DIR/suspicious_arithmetic_impl.rs:102:20\n    |\n LL |         Foo(self.0 >> other.0)\n    |                    ^^\n \n-error: suspicious use of binary operator in `Shr` impl\n+error: suspicious use of `<<` in `Shr` impl\n   --> $DIR/suspicious_arithmetic_impl.rs:110:20\n    |\n LL |         Foo(self.0 << other.0)"}]}