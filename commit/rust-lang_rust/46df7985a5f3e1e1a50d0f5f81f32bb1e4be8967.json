{"sha": "46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZGY3OTg1YTVmM2UxZTFhNTBkMGY1ZjgxZjMyYmIxZTRiZTg5Njc=", "commit": {"author": {"name": "Matthew McPherrin", "email": "matthew@mcpherrin.ca", "date": "2013-02-08T20:21:46Z"}, "committer": {"name": "Matthew McPherrin", "email": "matthew@mcpherrin.ca", "date": "2013-02-08T20:21:46Z"}, "message": "Merge branch 'master' of https://github.com/mozilla/rust", "tree": {"sha": "4780d31268ce0e252a6ca47765bd6e8430e370da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4780d31268ce0e252a6ca47765bd6e8430e370da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "html_url": "https://github.com/rust-lang/rust/commit/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/comments", "author": {"login": "mcpherrinm", "id": 47425, "node_id": "MDQ6VXNlcjQ3NDI1", "avatar_url": "https://avatars.githubusercontent.com/u/47425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcpherrinm", "html_url": "https://github.com/mcpherrinm", "followers_url": "https://api.github.com/users/mcpherrinm/followers", "following_url": "https://api.github.com/users/mcpherrinm/following{/other_user}", "gists_url": "https://api.github.com/users/mcpherrinm/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcpherrinm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcpherrinm/subscriptions", "organizations_url": "https://api.github.com/users/mcpherrinm/orgs", "repos_url": "https://api.github.com/users/mcpherrinm/repos", "events_url": "https://api.github.com/users/mcpherrinm/events{/privacy}", "received_events_url": "https://api.github.com/users/mcpherrinm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcpherrinm", "id": 47425, "node_id": "MDQ6VXNlcjQ3NDI1", "avatar_url": "https://avatars.githubusercontent.com/u/47425?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcpherrinm", "html_url": "https://github.com/mcpherrinm", "followers_url": "https://api.github.com/users/mcpherrinm/followers", "following_url": "https://api.github.com/users/mcpherrinm/following{/other_user}", "gists_url": "https://api.github.com/users/mcpherrinm/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcpherrinm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcpherrinm/subscriptions", "organizations_url": "https://api.github.com/users/mcpherrinm/orgs", "repos_url": "https://api.github.com/users/mcpherrinm/repos", "events_url": "https://api.github.com/users/mcpherrinm/events{/privacy}", "received_events_url": "https://api.github.com/users/mcpherrinm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "64fedfbc4ef37b56f7bb12e2864f4011e4031ac5", "url": "https://api.github.com/repos/rust-lang/rust/commits/64fedfbc4ef37b56f7bb12e2864f4011e4031ac5", "html_url": "https://github.com/rust-lang/rust/commit/64fedfbc4ef37b56f7bb12e2864f4011e4031ac5"}, {"sha": "3764cfbf57646becdeefa2996f812cbe40b016e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/3764cfbf57646becdeefa2996f812cbe40b016e7", "html_url": "https://github.com/rust-lang/rust/commit/3764cfbf57646becdeefa2996f812cbe40b016e7"}], "stats": {"total": 7147, "additions": 2999, "deletions": 4148}, "files": [{"sha": "64120f66351e6d4baea74d4af3fa4a30c5aad022", "filename": "RELEASES.txt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -1,3 +1,9 @@\n+Version 0.6 (?)\n+---------------------------\n+\n+   * Libraries\n+     * `core::send_map` renamed to `core::hashmap`\n+\n Version 0.5 (December 2012)\n ---------------------------\n "}, {"sha": "9813f0ec6b6f8e56e905b0197ad72f44ee2b1630", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/configure", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -515,7 +515,7 @@ then\n                       | cut -d ' ' -f 2)\n \n     case $CFG_CLANG_VERSION in\n-        (3.0svn | 3.0 | 3.1* | 3.2* | 4.0* | 4.1*)\n+        (3.0svn | 3.0 | 3.1* | 3.2* | 4.0* | 4.1* | 4.2*)\n         step_msg \"found ok version of CLANG: $CFG_CLANG_VERSION\"\n         CFG_C_COMPILER=\"clang\"\n         ;;"}, {"sha": "36e8bee7f7abcdeff2c8f1d996b5638493e1bc14", "filename": "mk/docs.mk", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -45,7 +45,7 @@ doc/rust.html: rust.md doc/version_info.html doc/rust.css doc/manual.css\n          --from=markdown --to=html \\\n          --css=rust.css \\\n          --css=manual.css \\\n-\t --include-before-body=doc/version_info.html \\\n+\t     --include-before-body=doc/version_info.html \\\n          --output=$@\n   endif\n \n@@ -66,6 +66,7 @@ doc/rust.tex: rust.md doc/version.md\n \t\"$(CFG_PANDOC)\" \\\n          --standalone --toc \\\n          --number-sections \\\n+\t     --include-before-body=doc/version.md \\\n          --from=markdown --to=latex \\\n          --output=$@\n \n@@ -199,16 +200,17 @@ ifdef CFG_DISABLE_DOCS\n endif\n \n \n-doc/version.md: $(MKFILE_DEPS) rust.md\n+doc/version.md: $(MKFILE_DEPS) $(wildcard $(S)doc/*.*)\n \t@$(call E, version-stamp: $@)\n \t$(Q)echo \"$(CFG_VERSION)\" >$@\n \n-doc/version_info.html: version_info.html.template\n+doc/version_info.html: version_info.html.template $(MKFILE_DEPS) \\\n+                       $(wildcard $(S)doc/*.*)\n \t@$(call E, version-info: $@)\n \tsed -e \"s/VERSION/$(CFG_RELEASE)/; s/SHORT_HASH/$(shell echo \\\n                     $(CFG_VER_HASH) | head -c 8)/;\\\n \t            s/STAMP/$(CFG_VER_HASH)/;\" $< >$@\n \n-GENERATED += doc/version.md\n+GENERATED += doc/version.md doc/version_info.html\n \n docs: $(DOCS)"}, {"sha": "b63ac5e75a270953883068ec435ff00561040478", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -159,7 +159,7 @@ pub fn test_opts(config: config) -> test::TestOpts {\n     }\n }\n \n-pub fn make_tests(config: config) -> ~[test::TestDesc] {\n+pub fn make_tests(config: config) -> ~[test::TestDescAndFn] {\n     debug!(\"making tests from %s\",\n            config.src_base.to_str());\n     let mut tests = ~[];\n@@ -196,13 +196,14 @@ pub fn is_test(config: config, testfile: &Path) -> bool {\n     return valid;\n }\n \n-pub fn make_test(config: config, testfile: &Path) ->\n-   test::TestDesc {\n-    test::TestDesc {\n-        name: make_test_name(config, testfile),\n+pub fn make_test(config: config, testfile: &Path) -> test::TestDescAndFn {\n+    test::TestDescAndFn {\n+        desc: test::TestDesc {\n+            name: make_test_name(config, testfile),\n+            ignore: header::is_test_ignored(config, testfile),\n+            should_fail: false\n+        },\n         testfn: make_test_closure(config, testfile),\n-        ignore: header::is_test_ignored(config, testfile),\n-        should_fail: false\n     }\n }\n "}, {"sha": "cff44ed5ef235f2161c090c7ddc4856117341da9", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -731,7 +731,7 @@ pub fn configure(opts: Options) -> Cargo {\n     need_dir(&c.bindir);\n \n     for sources.each_key_ref |&k| {\n-        let mut s = sources.get(k);\n+        let mut s = sources.get(&k);\n         load_source_packages(&c, s);\n         sources.insert(k, s);\n     }\n@@ -981,7 +981,7 @@ pub fn install_named(c: &mut Cargo, wd: &Path, name: ~str) {\n \n pub fn install_uuid_specific(c: &mut Cargo, wd: &Path, src: ~str,\n                              uuid: ~str) {\n-    match c.sources.find(src) {\n+    match c.sources.find(&src) {\n         Some(s) => {\n             for s.packages.each |p| {\n                 if p.uuid == uuid {\n@@ -997,7 +997,7 @@ pub fn install_uuid_specific(c: &mut Cargo, wd: &Path, src: ~str,\n \n pub fn install_named_specific(c: &mut Cargo, wd: &Path, src: ~str,\n                               name: ~str) {\n-    match c.sources.find(src) {\n+    match c.sources.find(&src) {\n         Some(s) => {\n             for s.packages.each |p| {\n                 if p.name == name {\n@@ -1064,7 +1064,7 @@ pub fn cmd_uninstall(c: &Cargo) {\n }\n \n pub fn install_query(c: &mut Cargo, wd: &Path, target: ~str) {\n-    match c.dep_cache.find(target) {\n+    match c.dep_cache.find(&target) {\n         Some(inst) => {\n             if inst {\n                 return;\n@@ -1156,7 +1156,7 @@ pub fn cmd_install(c: &mut Cargo) {\n \n pub fn sync(c: &Cargo) {\n     for c.sources.each_key_ref |&k| {\n-        let mut s = c.sources.get(k);\n+        let mut s = c.sources.get(&k);\n         sync_one(c, s);\n         c.sources.insert(k, s);\n     }\n@@ -1558,7 +1558,7 @@ pub fn cmd_list(c: &Cargo) {\n             if !valid_pkg_name(*name) {\n                 error(fmt!(\"'%s' is an invalid source name\", *name));\n             } else {\n-                match c.sources.find(*name) {\n+                match c.sources.find(name) {\n                     Some(source) => {\n                         print_source(source);\n                     }\n@@ -1754,7 +1754,7 @@ pub fn cmd_sources(c: &Cargo) {\n                 return;\n             }\n \n-            match c.sources.find(name) {\n+            match c.sources.find(&name) {\n                 Some(source) => {\n                     let old = copy source.url;\n                     let method = assume_source_method(url);\n@@ -1785,7 +1785,7 @@ pub fn cmd_sources(c: &Cargo) {\n                 return;\n             }\n \n-            match c.sources.find(name) {\n+            match c.sources.find(&name) {\n                 Some(source) => {\n                     let old = copy source.method;\n \n@@ -1823,7 +1823,7 @@ pub fn cmd_sources(c: &Cargo) {\n                 return;\n             }\n \n-            match c.sources.find(name) {\n+            match c.sources.find(&name) {\n                 Some(source) => {\n                     c.sources.remove(&name);\n                     c.sources.insert(newn, source);"}, {"sha": "75db5359e2e31e01836c67f82b14bc06965865ce", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,10 +10,6 @@\n \n //! Managed vectors\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cast::transmute;\n use kinds::Copy;\n use iter;"}, {"sha": "1eebb716a5973564cb9ca690fa4d69651e024629", "filename": "src/libcore/bool.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -9,10 +9,6 @@\n // except according to those terms.\n \n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n //! Boolean logic\n \n use bool;"}, {"sha": "14cc79ceaffedda279ab40e65a7677551141a813", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Unsafe operations\n-#[forbid(deprecated_mode)]\n-\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n     fn forget<T>(-x: T);"}, {"sha": "f7a369489d1ab3599e6878eb5a53466fb9ed3c02", "filename": "src/libcore/char.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,10 +10,6 @@\n \n //! Utilities for manipulating the char type\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use char;\n use cmp::Eq;\n use option::{None, Option, Some};"}, {"sha": "11a4cad5d1bbb72559b7ef20bfa8c2db0c1bcb8e", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,10 +10,6 @@\n \n #[doc(hidden)];\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use libc::{c_char, c_void, intptr_t, uintptr_t};\n use ptr::{mut_null, null, to_unsafe_ptr};\n use repr::BoxRepr;"}, {"sha": "e1ec8c7737c7d23243eb9f7123a0a8674b5e15ee", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -20,10 +20,6 @@ and `Eq` to overload the `==` and `!=` operators.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n /**\n * Trait for values that can be compared for equality\n * and inequality."}, {"sha": "2a5ca7d8dfa6c784e4ed5b48ae92dd72906eca1b", "filename": "src/libcore/container.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,9 +10,6 @@\n \n //! Container traits\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use option::Option;\n \n pub trait Container {"}, {"sha": "64b480818b1e7b4ceefa9850d76d8992316f53a6", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -48,8 +48,6 @@ Implicitly, all crates behave as if they included the following prologue:\n // Don't link to core. We are core.\n #[no_core];\n \n-#[warn(deprecated_mode)];\n-#[warn(deprecated_pattern)];\n #[warn(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n #[allow(deprecated_self)];"}, {"sha": "ed67e010b405588bf7699a7862280e75082ce129", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -18,10 +18,6 @@ Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use kinds::Copy;\n use managed;\n use option::{None, Option, Some};"}, {"sha": "fe36ed159603cccb5e3036545c8961e4d89b05ff", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -19,10 +19,6 @@ Note that recursive use is not permitted.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cast;\n use cast::reinterpret_cast;\n use prelude::*;"}, {"sha": "7efde62c4ca6b672dee86e41394ad65fe4fa067e", "filename": "src/libcore/either.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n //! A type that represents one of two alternatives\n \n use cmp::Eq;"}, {"sha": "4d2a1b2afe08d47841750494915898e7eb82e98d", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -51,10 +51,6 @@\n //! * s - str (any flavor)\n //! * ? - arbitrary type (does not use the to_str trait)\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n // Transitional\n #[allow(structural_records)]; // Macros -- needs a snapshot\n \n@@ -499,12 +495,6 @@ pub mod rt {\n \n     pub enum Ty { TyDefault, TyBits, TyHexUpper, TyHexLower, TyOctal, }\n \n-    #[cfg(stage0)]\n-    pub type Conv = {flags: u32, width: Count, precision: Count, ty: Ty};\n-\n-    #[cfg(stage1)]\n-    #[cfg(stage2)]\n-    #[cfg(stage3)]\n     pub struct Conv {\n         flags: u32,\n         width: Count,"}, {"sha": "6b5c083662b84989f3c9b147c5686592b09aa2e8", "filename": "src/libcore/flate.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fflate.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -14,10 +14,6 @@ Simple compression\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use libc;\n use libc::{c_void, size_t, c_int};\n use ptr;"}, {"sha": "9322c7e7cb822baddfc323db9e4b830af4d63241", "filename": "src/libcore/from_str.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Ffrom_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Ffrom_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffrom_str.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,10 +10,6 @@\n \n //! The trait for types that can be created from strings\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use option::Option;\n \n pub trait FromStr {"}, {"sha": "d0c40ccf19aa07ab36af0667e4788d51d6ddce4f", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -35,9 +35,6 @@ with destructors.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n // Transitional\n #[allow(structural_records)];\n "}, {"sha": "692cfee536581b3e2a692be610ed692fe624f673", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n /*!\n  * Implementation of SipHash 2-4\n  *"}, {"sha": "be785863f71ec3d9030dca39bc0d69a77016e25b", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,10 +10,6 @@\n \n //! Sendable hash maps.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use container::{Container, Mutable, Map, Set};\n use cmp::Eq;\n use hash::Hash;\n@@ -49,9 +45,8 @@ pub mod linear {\n         buckets: ~[Option<Bucket<K, V>>],\n     }\n \n-    // FIXME(#3148) -- we could rewrite FoundEntry\n-    // to have type Option<&Bucket<K, V>> which would be nifty\n-    // However, that won't work until #3148 is fixed\n+    // We could rewrite FoundEntry to have type Option<&Bucket<K, V>>\n+    // which would be nifty\n     enum SearchResult {\n         FoundEntry(uint), FoundHole(uint), TableFull\n     }\n@@ -296,8 +291,6 @@ pub mod linear {\n                 FoundEntry(idx) => {\n                     match self.buckets[idx] {\n                         Some(ref bkt) => {\n-                            // FIXME(#3148)---should be inferred\n-                            let bkt: &self/Bucket<K, V> = bkt;\n                             Some(&bkt.value)\n                         }\n                         None => {"}, {"sha": "721a6584c650677e136cbbbde7dc23ab8f0d5534", "filename": "src/libcore/io.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -14,9 +14,6 @@ Basic input/output\n \n */\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use result::Result;\n \n use cmp::Eq;\n@@ -490,25 +487,25 @@ pub fn FILERes(f: *libc::FILE) -> FILERes {\n     }\n }\n \n-pub fn FILE_reader(f: *libc::FILE, cleanup: bool) -> Reader {\n+pub fn FILE_reader(f: *libc::FILE, cleanup: bool) -> @Reader {\n     if cleanup {\n-        Wrapper { base: f, cleanup: FILERes(f) } as Reader\n+        @Wrapper { base: f, cleanup: FILERes(f) } as @Reader\n     } else {\n-        f as Reader\n+        @f as @Reader\n     }\n }\n \n // FIXME (#2004): this should either be an trait-less impl, a set of\n // top-level functions that take a reader, or a set of default methods on\n // reader (which can then be called reader)\n \n-pub fn stdin() -> Reader {\n+pub fn stdin() -> @Reader {\n     unsafe {\n-        rustrt::rust_get_stdin() as Reader\n+        rustrt::rust_get_stdin() as @Reader\n     }\n }\n \n-pub fn file_reader(path: &Path) -> Result<Reader, ~str> {\n+pub fn file_reader(path: &Path) -> Result<@Reader, ~str> {\n     unsafe {\n         let f = os::as_c_charp(path.to_str(), |pathbuf| {\n             os::as_c_charp(\"r\", |modebuf|\n@@ -555,11 +552,11 @@ impl BytesReader: Reader {\n     fn tell(&self) -> uint { self.pos }\n }\n \n-pub pure fn with_bytes_reader<t>(bytes: &[u8], f: fn(Reader) -> t) -> t {\n-    f(BytesReader { bytes: bytes, pos: 0u } as Reader)\n+pub pure fn with_bytes_reader<t>(bytes: &[u8], f: fn(@Reader) -> t) -> t {\n+    f(@BytesReader { bytes: bytes, pos: 0u } as @Reader)\n }\n \n-pub pure fn with_str_reader<T>(s: &str, f: fn(Reader) -> T) -> T {\n+pub pure fn with_str_reader<T>(s: &str, f: fn(@Reader) -> T) -> T {\n     str::byte_slice(s, |bytes| with_bytes_reader(bytes, f))\n }\n "}, {"sha": "df2aa6271d1f839cbb8dd4e76d20a8740a37fb19", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -12,9 +12,6 @@\n // workaround our lack of traits and lack of macros.  See core.{rc,rs} for\n // how this file is used.\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp::{Eq, Ord};\n use iter::BaseIter;\n use iter;"}, {"sha": "c414ab0f5f3e551fb70d9394e62a0048de6c8252", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -14,9 +14,6 @@ The iteration traits and common implementation\n \n */\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp::{Eq, Ord};\n use kinds::Copy;\n use option::{None, Option, Some};"}, {"sha": "6976c83a6f407f0bc7229ddb01bda74cea09eb08", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n /*!\n * Bindings for libc.\n *"}, {"sha": "357a3415ac2da03a5f78ff33aa3416fc4e182bf6", "filename": "src/libcore/logging.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flogging.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,10 +10,6 @@\n \n //! Logging\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cast::transmute;\n use io;\n use libc;"}, {"sha": "700feee9839435408a58daa2b4d43164f243eebf", "filename": "src/libcore/managed.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fmanaged.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fmanaged.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmanaged.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,10 +10,6 @@\n \n //! Operations on managed box types\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cast::transmute;\n use cmp::{Eq, Ord};\n use managed::raw::BoxRepr;"}, {"sha": "3c44c197f5ef67418443d6e185bbb495070d3225", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -18,8 +18,6 @@ dynamic checks: your program will fail if you attempt to perform\n mutation when the data structure should be immutable.\n \n */\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n \n use util::with;\n use cast::transmute_immut;"}, {"sha": "8f03a1b6e3498cd2a7091a44706f0f5f73ee1ef3", "filename": "src/libcore/nil.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fnil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fnil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnil.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -14,10 +14,6 @@ Functions for the unit type.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp::{Eq, Ord};\n \n #[cfg(notest)]"}, {"sha": "c030dfc589977784816c453713c2a2f25a34375a", "filename": "src/libcore/num/cmath.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fnum%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fnum%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fcmath.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -9,9 +9,6 @@\n // except according to those terms.\n \n #[doc(hidden)]; // FIXME #3538\n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n \n use libc::c_int;\n use libc::c_float;"}, {"sha": "738445b5cd94616f84db218598d2990e2ce6ae38", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n //! Operations and constants for `f32`\n \n use cmath;"}, {"sha": "f09d874803c3d852c9fee27f993b9b25b3e30932", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n //! Operations and constants for `f64`\n \n use cmath;"}, {"sha": "f5ae05ebffb4e6cbd0e7a20d1b97b02c24e75c7f", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n //! Operations and constants for `float`\n \n // Even though this module exports everything defined in it,"}, {"sha": "1856781b1d7799a9fb62388558a789a11f6e0e4a", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use T = self::inst::T;\n \n use char;"}, {"sha": "f8bbb35204add49672320e10a324a790c2bcf2db", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use T = self::inst::T;\n use T_SIGNED = self::inst::T_SIGNED;\n "}, {"sha": "aaa4ab3fecfee33fcdc91230afa0c4df8ec63aba", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,9 +10,6 @@\n \n // Core operators\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n #[lang=\"drop\"]\n pub trait Drop {\n     fn finalize(&self);  // FIXME(#4332): Rename to \"drop\"? --pcwalton"}, {"sha": "e5d703eec4aeffc7a46635d11f34664f2573646b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -41,9 +41,6 @@ let unwrapped_msg = match move msg {\n \n */\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp::Eq;\n use kinds::Copy;\n use option;"}, {"sha": "a14abd23cc3cadab309db32e25abd8c740549ff4", "filename": "src/libcore/os.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n #[allow(structural_records)];\n \n /*!"}, {"sha": "d841188501d967756a2cc9e297d59a7369e45666", "filename": "src/libcore/owned.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fowned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fowned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fowned.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,10 +10,6 @@\n \n //! Operations on unique pointer types\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp::{Eq, Ord};\n \n #[cfg(notest)]"}, {"sha": "bf1f1c713a9945be7638f94e0ae927760dce43df", "filename": "src/libcore/path.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -14,10 +14,6 @@ Cross-platform file path handling\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp::Eq;\n use libc;\n use option::{None, Option, Some};"}, {"sha": "3f0aecb887d251672a8cbc1f88856c75e12354a4", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 0, "deletions": 319, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -82,11 +82,6 @@ bounded and unbounded protocols allows for less code duplication.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-// tjc: allowing deprecated modes due to function issue,\n-// re-forbid after snapshot\n-#[forbid(deprecated_pattern)];\n-\n // Transitional -- needs snapshot\n #[allow(structural_records)];\n \n@@ -142,15 +137,6 @@ pub fn BufferHeader() -> BufferHeader {\n \n // This is for protocols to associate extra data to thread around.\n #[doc(hidden)]\n-#[cfg(stage0)]\n-type Buffer<T: Owned> = {\n-    header: BufferHeader,\n-    data: T,\n-};\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n pub struct Buffer<T> {\n     header: BufferHeader,\n     data: T,\n@@ -212,14 +198,6 @@ impl PacketHeader {\n }\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-pub struct Packet<T: Owned> {\n-    header: PacketHeader,\n-    mut payload: Option<T>,\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub struct Packet<T> {\n     header: PacketHeader,\n     mut payload: Option<T>,\n@@ -228,16 +206,12 @@ pub struct Packet<T> {\n #[doc(hidden)]\n pub trait HasBuffer {\n     fn set_buffer(b: *libc::c_void);\n-    // FIXME #4421 remove after snapshot\n-    fn set_buffer_(b: *libc::c_void);\n }\n \n impl<T: Owned> Packet<T>: HasBuffer {\n     fn set_buffer(b: *libc::c_void) {\n         self.header.buffer = b;\n     }\n-    // FIXME #4421 remove after snapshot\n-    fn set_buffer_(b: *libc::c_void) { self.set_buffer(b) }\n }\n \n #[doc(hidden)]\n@@ -247,27 +221,7 @@ pub fn mk_packet<T: Owned>() -> Packet<T> {\n         payload: None,\n     }\n }\n-\n-#[doc(hidden)]\n-#[cfg(stage0)]\n-fn unibuffer<T: Owned>() -> ~Buffer<Packet<T>> {\n-    let b = ~{\n-        header: BufferHeader(),\n-        data: Packet {\n-            header: PacketHeader(),\n-            payload: None,\n-        }\n-    };\n-\n-    unsafe {\n-        b.data.header.buffer = reinterpret_cast(&b);\n-    }\n-    move b\n-}\n #[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n-#[cfg(stage3)]\n fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n     let b = ~Buffer {\n         header: BufferHeader(),\n@@ -284,17 +238,6 @@ fn unibuffer<T>() -> ~Buffer<Packet<T>> {\n }\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-pub fn packet<T: Owned>() -> *Packet<T> {\n-    let b = unibuffer();\n-    let p = ptr::addr_of(&(b.data));\n-    // We'll take over memory management from here.\n-    unsafe { forget(move b) }\n-    p\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn packet<T>() -> *Packet<T> {\n     let b = unibuffer();\n     let p = ptr::addr_of(&(b.data));\n@@ -405,42 +348,11 @@ fn swap_state_rel(dst: &mut State, src: State) -> State {\n }\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-pub unsafe fn get_buffer<T: Owned>(p: *PacketHeader) -> ~Buffer<T> {\n-    transmute((*p).buf_header())\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub unsafe fn get_buffer<T>(p: *PacketHeader) -> ~Buffer<T> {\n     transmute((*p).buf_header())\n }\n \n // This could probably be done with SharedMutableState to avoid move_it!().\n-#[cfg(stage0)]\n-struct BufferResource<T: Owned> {\n-    buffer: ~Buffer<T>,\n-\n-    drop {\n-        unsafe {\n-            let b = move_it!(self.buffer);\n-            //let p = ptr::addr_of(*b);\n-            //error!(\"drop %?\", p);\n-            let old_count = atomic_sub_rel(&mut b.header.ref_count, 1);\n-            //let old_count = atomic_xchng_rel(b.header.ref_count, 0);\n-            if old_count == 1 {\n-                // The new count is 0.\n-\n-                // go go gadget drop glue\n-            }\n-            else {\n-                forget(move b)\n-            }\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n struct BufferResource<T> {\n     buffer: ~Buffer<T>,\n \n@@ -463,19 +375,6 @@ struct BufferResource<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-fn BufferResource<T: Owned>(b: ~Buffer<T>) -> BufferResource<T> {\n-    //let p = ptr::addr_of(*b);\n-    //error!(\"take %?\", p);\n-    atomic_add_acq(&mut b.header.ref_count, 1);\n-\n-    BufferResource {\n-        // tjc: ????\n-        buffer: move b\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n fn BufferResource<T>(b: ~Buffer<T>) -> BufferResource<T> {\n     //let p = ptr::addr_of(*b);\n     //error!(\"take %?\", p);\n@@ -488,51 +387,6 @@ fn BufferResource<T>(b: ~Buffer<T>) -> BufferResource<T> {\n }\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-pub fn send<T: Owned, Tbuffer: Owned>(p: SendPacketBuffered<T, Tbuffer>,\n-                                    payload: T) -> bool {\n-    let header = p.header();\n-    let p_ = p.unwrap();\n-    let p = unsafe { &*p_ };\n-    assert ptr::addr_of(&(p.header)) == header;\n-    assert p.payload.is_none();\n-    p.payload = move Some(move payload);\n-    let old_state = swap_state_rel(&mut p.header.state, Full);\n-    match old_state {\n-        Empty => {\n-            // Yay, fastpath.\n-\n-            // The receiver will eventually clean this up.\n-            //unsafe { forget(p); }\n-            return true;\n-        }\n-        Full => die!(~\"duplicate send\"),\n-        Blocked => {\n-            debug!(\"waking up task for %?\", p_);\n-            let old_task = swap_task(&mut p.header.blocked_task, ptr::null());\n-            if !old_task.is_null() {\n-                unsafe {\n-                    rustrt::task_signal_event(\n-                        old_task,\n-                        ptr::addr_of(&(p.header)) as *libc::c_void);\n-                    rustrt::rust_task_deref(old_task);\n-                }\n-            }\n-\n-            // The receiver will eventually clean this up.\n-            //unsafe { forget(p); }\n-            return true;\n-        }\n-        Terminated => {\n-            // The receiver will never receive this. Rely on drop_glue\n-            // to clean everything up.\n-            return false;\n-        }\n-    }\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn send<T,Tbuffer>(p: SendPacketBuffered<T,Tbuffer>, payload: T) -> bool {\n     let header = p.header();\n     let p_ = p.unwrap();\n@@ -918,44 +772,13 @@ pub fn select<T: Owned, Tb: Owned>(endpoints: ~[RecvPacketBuffered<T, Tb>])\n message.\n \n */\n-#[cfg(stage0)]\n-pub type SendPacket<T: Owned> = SendPacketBuffered<T, Packet<T>>;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub type SendPacket<T> = SendPacketBuffered<T, Packet<T>>;\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-pub fn SendPacket<T: Owned>(p: *Packet<T>) -> SendPacket<T> {\n-    SendPacketBuffered(p)\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn SendPacket<T>(p: *Packet<T>) -> SendPacket<T> {\n     SendPacketBuffered(p)\n }\n \n-#[cfg(stage0)]\n-pub struct SendPacketBuffered<T: Owned, Tbuffer: Owned> {\n-    mut p: Option<*Packet<T>>,\n-    mut buffer: Option<BufferResource<Tbuffer>>,\n-    drop {\n-        //if self.p != none {\n-        //    debug!(\"drop send %?\", option::get(self.p));\n-        //}\n-        if self.p != None {\n-            let mut p = None;\n-            p <-> self.p;\n-            sender_terminate(option::unwrap(move p))\n-        }\n-        //unsafe { error!(\"send_drop: %?\",\n-        //                if self.buffer == none {\n-        //                    \"none\"\n-        //                } else { \"some\" }); }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub struct SendPacketBuffered<T, Tbuffer> {\n     mut p: Option<*Packet<T>>,\n     mut buffer: Option<BufferResource<Tbuffer>>,\n@@ -978,20 +801,6 @@ impl<T:Owned,Tbuffer:Owned> SendPacketBuffered<T,Tbuffer> : ::ops::Drop {\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn SendPacketBuffered<T: Owned, Tbuffer: Owned>(p: *Packet<T>)\n-    -> SendPacketBuffered<T, Tbuffer> {\n-        //debug!(\"take send %?\", p);\n-    SendPacketBuffered {\n-        p: Some(p),\n-        buffer: unsafe {\n-            Some(BufferResource(\n-                get_buffer(ptr::addr_of(&((*p).header)))))\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn SendPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n     -> SendPacketBuffered<T, Tbuffer> {\n         //debug!(\"take send %?\", p);\n@@ -1004,35 +813,6 @@ pub fn SendPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T:Owned,Tbuffer:Owned> SendPacketBuffered<T,Tbuffer> {\n-    fn unwrap() -> *Packet<T> {\n-        let mut p = None;\n-        p <-> self.p;\n-        option::unwrap(move p)\n-    }\n-\n-    pure fn header() -> *PacketHeader {\n-        match self.p {\n-          Some(packet) => unsafe {\n-            let packet = &*packet;\n-            let header = ptr::addr_of(&(packet.header));\n-            //forget(packet);\n-            header\n-          },\n-          None => die!(~\"packet already consumed\")\n-        }\n-    }\n-\n-    fn reuse_buffer() -> BufferResource<Tbuffer> {\n-        //error!(\"send reuse_buffer\");\n-        let mut tmp = None;\n-        tmp <-> self.buffer;\n-        option::unwrap(move tmp)\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n     fn unwrap() -> *Packet<T> {\n         let mut p = None;\n@@ -1062,45 +842,12 @@ impl<T,Tbuffer> SendPacketBuffered<T,Tbuffer> {\n \n /// Represents the receive end of a pipe. It can receive exactly one\n /// message.\n-#[cfg(stage0)]\n-pub type RecvPacket<T: Owned> = RecvPacketBuffered<T, Packet<T>>;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub type RecvPacket<T> = RecvPacketBuffered<T, Packet<T>>;\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-pub fn RecvPacket<T: Owned>(p: *Packet<T>) -> RecvPacket<T> {\n-    RecvPacketBuffered(p)\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn RecvPacket<T>(p: *Packet<T>) -> RecvPacket<T> {\n     RecvPacketBuffered(p)\n }\n-\n-#[cfg(stage0)]\n-pub struct RecvPacketBuffered<T: Owned, Tbuffer: Owned> {\n-    mut p: Option<*Packet<T>>,\n-    mut buffer: Option<BufferResource<Tbuffer>>,\n-    drop {\n-        //if self.p != none {\n-        //    debug!(\"drop recv %?\", option::get(self.p));\n-        //}\n-        if self.p != None {\n-            let mut p = None;\n-            p <-> self.p;\n-            receiver_terminate(option::unwrap(move p))\n-        }\n-        //unsafe { error!(\"recv_drop: %?\",\n-        //                if self.buffer == none {\n-        //                    \"none\"\n-        //                } else { \"some\" }); }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub struct RecvPacketBuffered<T, Tbuffer> {\n     mut p: Option<*Packet<T>>,\n     mut buffer: Option<BufferResource<Tbuffer>>,\n@@ -1152,20 +899,6 @@ impl<T: Owned, Tbuffer: Owned> RecvPacketBuffered<T, Tbuffer> : Selectable {\n     }\n }\n \n-#[cfg(stage0)]\n-pub fn RecvPacketBuffered<T: Owned, Tbuffer: Owned>(p: *Packet<T>)\n-    -> RecvPacketBuffered<T, Tbuffer> {\n-    //debug!(\"take recv %?\", p);\n-    RecvPacketBuffered {\n-        p: Some(p),\n-        buffer: unsafe {\n-            Some(BufferResource(\n-                get_buffer(ptr::addr_of(&((*p).header)))))\n-        }\n-    }\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn RecvPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n     -> RecvPacketBuffered<T,Tbuffer> {\n     //debug!(\"take recv %?\", p);\n@@ -1179,14 +912,6 @@ pub fn RecvPacketBuffered<T,Tbuffer>(p: *Packet<T>)\n }\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-pub fn entangle<T: Owned>() -> (SendPacket<T>, RecvPacket<T>) {\n-    let p = packet();\n-    (SendPacket(p), RecvPacket(p))\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub fn entangle<T>() -> (SendPacket<T>, RecvPacket<T>) {\n     let p = packet();\n     (SendPacket(p), RecvPacket(p))\n@@ -1282,47 +1007,21 @@ pub trait Peekable<T> {\n }\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-struct Chan_<T:Owned> {\n-    mut endp: Option<streamp::client::Open<T>>\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n struct Chan_<T> {\n     mut endp: Option<streamp::client::Open<T>>\n }\n \n /// An endpoint that can send many messages.\n-#[cfg(stage0)]\n-pub enum Chan<T:Owned> {\n-    Chan_(Chan_<T>)\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub enum Chan<T> {\n     Chan_(Chan_<T>)\n }\n \n #[doc(hidden)]\n-#[cfg(stage0)]\n-struct Port_<T:Owned> {\n-    mut endp: Option<streamp::server::Open<T>>,\n-}\n-#[doc(hidden)]\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n struct Port_<T> {\n     mut endp: Option<streamp::server::Open<T>>,\n }\n \n /// An endpoint that can receive many messages.\n-#[cfg(stage0)]\n-pub enum Port<T:Owned> {\n-    Port_(Port_<T>)\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub enum Port<T> {\n     Port_(Port_<T>)\n }\n@@ -1411,12 +1110,6 @@ impl<T: Owned> Port<T>: Selectable {\n }\n \n /// Treat many ports as one.\n-#[cfg(stage0)]\n-pub struct PortSet<T: Owned> {\n-    mut ports: ~[pipes::Port<T>],\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub struct PortSet<T> {\n     mut ports: ~[pipes::Port<T>],\n }\n@@ -1482,10 +1175,6 @@ impl<T: Owned> PortSet<T> : Peekable<T> {\n }\n \n /// A channel that can be shared between many senders.\n-#[cfg(stage0)]\n-pub type SharedChan<T: Owned> = private::Exclusive<Chan<T>>;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub type SharedChan<T> = private::Exclusive<Chan<T>>;\n \n impl<T: Owned> SharedChan<T>: GenericChan<T> {\n@@ -1554,16 +1243,8 @@ proto! oneshot (\n )\n \n /// The send end of a oneshot pipe.\n-#[cfg(stage0)]\n-pub type ChanOne<T: Owned> = oneshot::client::Oneshot<T>;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub type ChanOne<T> = oneshot::client::Oneshot<T>;\n /// The receive end of a oneshot pipe.\n-#[cfg(stage0)]\n-pub type PortOne<T: Owned> = oneshot::server::Oneshot<T>;\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub type PortOne<T> = oneshot::server::Oneshot<T>;\n \n /// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair."}, {"sha": "a798d8c866a3f2307331e8baf87808c2e2ae6ddb", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -36,7 +36,7 @@ pub use path::PosixPath;\n pub use path::WindowsPath;\n pub use pipes::{GenericChan, GenericPort};\n pub use ptr::Ptr;\n-pub use str::{StrSlice, Trimmable};\n+pub use str::{StrSlice, Trimmable, OwnedStr};\n pub use to_bytes::IterBytes;\n pub use to_str::ToStr;\n pub use tuple::{CopyableTuple, ImmutableTuple, ExtendedTupleOps};"}, {"sha": "d4cf39ad2625e194cea6803766a48e999feddcac", "filename": "src/libcore/private.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,11 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-// tjc: Re-forbid deprecated modes once a snapshot fixes the\n-// function problem\n-#[forbid(deprecated_pattern)];\n-\n #[doc(hidden)];\n \n use cast;\n@@ -486,7 +481,7 @@ pub mod tests {\n         res.recv();\n     }\n \n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    #[test] #[should_fail] #[ignore(reason = \"random red\")]\n     pub fn exclusive_unwrap_conflict() {\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());"}, {"sha": "50c5ea70cbb40c0168e8a0378d9b24ee4654651c", "filename": "src/libcore/private/finally.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fprivate%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fprivate%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Ffinally.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -26,10 +26,19 @@ do || {\n use ops::Drop;\n use task::{spawn, failing};\n \n+#[cfg(stage0)]\n pub trait Finally<T> {\n     fn finally(&self, +dtor: &fn()) -> T;\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub trait Finally<T> {\n+    fn finally(&self, dtor: &fn()) -> T;\n+}\n+\n+#[cfg(stage0)]\n impl<T> &fn() -> T: Finally<T> {\n     // FIXME #4518: Should not require a mode here\n     fn finally(&self, +dtor: &fn()) -> T {\n@@ -41,6 +50,19 @@ impl<T> &fn() -> T: Finally<T> {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<T> &fn() -> T: Finally<T> {\n+    fn finally(&self, dtor: &fn()) -> T {\n+        let _d = Finallyalizer {\n+            dtor: dtor\n+        };\n+\n+        (*self)()\n+    }\n+}\n+\n struct Finallyalizer {\n     dtor: &fn()\n }"}, {"sha": "ad0bcb5cff8a21c5ac43c7d77d6c47bc60c79971", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,9 +10,6 @@\n \n //! Unsafe pointer utility functions\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cast;\n use cmp::{Eq, Ord};\n use libc;"}, {"sha": "452ab9452510b90a25f3e2cfa79048304471e7f1", "filename": "src/libcore/rand.rs", "status": "modified", "additions": 100, "deletions": 4, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frand.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,10 +10,6 @@\n \n //! Random number generation\n \n-// NB: transitional, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use int;\n use prelude::*;\n use str;\n@@ -23,6 +19,102 @@ use uint;\n use util;\n use vec;\n \n+/// A type that can be randomly generated using an RNG\n+pub trait Rand {\n+    static fn rand(rng: rand::Rng) -> Self;\n+}\n+\n+impl int: Rand {\n+    static fn rand(rng: rand::Rng) -> int {\n+        rng.gen_int()\n+    }\n+}\n+\n+impl i8: Rand {\n+    static fn rand(rng: rand::Rng) -> i8 {\n+        rng.gen_i8()\n+    }\n+}\n+\n+impl i16: Rand {\n+    static fn rand(rng: rand::Rng) -> i16 {\n+        rng.gen_i16()\n+    }\n+}\n+\n+impl i32: Rand {\n+    static fn rand(rng: rand::Rng) -> i32 {\n+        rng.gen_i32()\n+    }\n+}\n+\n+impl i64: Rand {\n+    static fn rand(rng: rand::Rng) -> i64 {\n+        rng.gen_i64()\n+    }\n+}\n+\n+impl u8: Rand {\n+    static fn rand(rng: rand::Rng) -> u8 {\n+        rng.gen_u8()\n+    }\n+}\n+\n+impl u16: Rand {\n+    static fn rand(rng: rand::Rng) -> u16 {\n+        rng.gen_u16()\n+    }\n+}\n+\n+impl u32: Rand {\n+    static fn rand(rng: rand::Rng) -> u32 {\n+        rng.gen_u32()\n+    }\n+}\n+\n+impl u64: Rand {\n+    static fn rand(rng: rand::Rng) -> u64 {\n+        rng.gen_u64()\n+    }\n+}\n+\n+impl float: Rand {\n+    static fn rand(rng: rand::Rng) -> float {\n+        rng.gen_float()\n+    }\n+}\n+\n+impl f32: Rand {\n+    static fn rand(rng: rand::Rng) -> f32 {\n+        rng.gen_f32()\n+    }\n+}\n+\n+impl f64: Rand {\n+    static fn rand(rng: rand::Rng) -> f64 {\n+        rng.gen_f64()\n+    }\n+}\n+\n+impl char: Rand {\n+    static fn rand(rng: rand::Rng) -> char {\n+        rng.gen_char()\n+    }\n+}\n+\n+impl bool: Rand {\n+    static fn rand(rng: rand::Rng) -> bool {\n+        rng.gen_bool()\n+    }\n+}\n+\n+impl<T: Rand> Option<T>: Rand {\n+    static fn rand(rng: rand::Rng) -> Option<T> {\n+        if rng.gen_bool() { Some(Rand::rand(rng)) }\n+        else { None }\n+    }\n+}\n+\n #[allow(non_camel_case_types)] // runtime type\n enum rctx {}\n \n@@ -49,6 +141,10 @@ pub struct Weighted<T> {\n \n /// Extension methods for random number generators\n impl Rng {\n+    /// Return a random value for a Rand type\n+    fn gen<T: Rand>() -> T {\n+        Rand::rand(self)\n+    }\n \n     /// Return a random int\n     fn gen_int() -> int {"}, {"sha": "de94100d7a50615f095a81cd8da46009fb1b1f7f", "filename": "src/libcore/reflect.rs", "status": "modified", "additions": 0, "deletions": 431, "changes": 431, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Freflect.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -14,9 +14,6 @@ Runtime type reflection\n \n */\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use intrinsic::{TyDesc, get_tydesc, visit_tydesc, TyVisitor};\n use libc::c_void;\n use sys;\n@@ -75,434 +72,6 @@ impl<V: TyVisitor MovePtr> MovePtrAdaptor<V> {\n }\n \n /// Abstract type-directed pointer-movement using the MovePtr trait\n-#[cfg(stage0)]\n-impl<V: TyVisitor MovePtr> MovePtrAdaptor<V>: TyVisitor {\n-    fn visit_bot() -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner.visit_bot() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_nil() -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner.visit_nil() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_bool() -> bool {\n-        self.align_to::<bool>();\n-        if ! self.inner.visit_bool() { return false; }\n-        self.bump_past::<bool>();\n-        true\n-    }\n-\n-    fn visit_int() -> bool {\n-        self.align_to::<int>();\n-        if ! self.inner.visit_int() { return false; }\n-        self.bump_past::<int>();\n-        true\n-    }\n-\n-    fn visit_i8() -> bool {\n-        self.align_to::<i8>();\n-        if ! self.inner.visit_i8() { return false; }\n-        self.bump_past::<i8>();\n-        true\n-    }\n-\n-    fn visit_i16() -> bool {\n-        self.align_to::<i16>();\n-        if ! self.inner.visit_i16() { return false; }\n-        self.bump_past::<i16>();\n-        true\n-    }\n-\n-    fn visit_i32() -> bool {\n-        self.align_to::<i32>();\n-        if ! self.inner.visit_i32() { return false; }\n-        self.bump_past::<i32>();\n-        true\n-    }\n-\n-    fn visit_i64() -> bool {\n-        self.align_to::<i64>();\n-        if ! self.inner.visit_i64() { return false; }\n-        self.bump_past::<i64>();\n-        true\n-    }\n-\n-    fn visit_uint() -> bool {\n-        self.align_to::<uint>();\n-        if ! self.inner.visit_uint() { return false; }\n-        self.bump_past::<uint>();\n-        true\n-    }\n-\n-    fn visit_u8() -> bool {\n-        self.align_to::<u8>();\n-        if ! self.inner.visit_u8() { return false; }\n-        self.bump_past::<u8>();\n-        true\n-    }\n-\n-    fn visit_u16() -> bool {\n-        self.align_to::<u16>();\n-        if ! self.inner.visit_u16() { return false; }\n-        self.bump_past::<u16>();\n-        true\n-    }\n-\n-    fn visit_u32() -> bool {\n-        self.align_to::<u32>();\n-        if ! self.inner.visit_u32() { return false; }\n-        self.bump_past::<u32>();\n-        true\n-    }\n-\n-    fn visit_u64() -> bool {\n-        self.align_to::<u64>();\n-        if ! self.inner.visit_u64() { return false; }\n-        self.bump_past::<u64>();\n-        true\n-    }\n-\n-    fn visit_float() -> bool {\n-        self.align_to::<float>();\n-        if ! self.inner.visit_float() { return false; }\n-        self.bump_past::<float>();\n-        true\n-    }\n-\n-    fn visit_f32() -> bool {\n-        self.align_to::<f32>();\n-        if ! self.inner.visit_f32() { return false; }\n-        self.bump_past::<f32>();\n-        true\n-    }\n-\n-    fn visit_f64() -> bool {\n-        self.align_to::<f64>();\n-        if ! self.inner.visit_f64() { return false; }\n-        self.bump_past::<f64>();\n-        true\n-    }\n-\n-    fn visit_char() -> bool {\n-        self.align_to::<char>();\n-        if ! self.inner.visit_char() { return false; }\n-        self.bump_past::<char>();\n-        true\n-    }\n-\n-    fn visit_str() -> bool {\n-        self.align_to::<~str>();\n-        if ! self.inner.visit_str() { return false; }\n-        self.bump_past::<~str>();\n-        true\n-    }\n-\n-    fn visit_estr_box() -> bool {\n-        self.align_to::<@str>();\n-        if ! self.inner.visit_estr_box() { return false; }\n-        self.bump_past::<@str>();\n-        true\n-    }\n-\n-    fn visit_estr_uniq() -> bool {\n-        self.align_to::<~str>();\n-        if ! self.inner.visit_estr_uniq() { return false; }\n-        self.bump_past::<~str>();\n-        true\n-    }\n-\n-    fn visit_estr_slice() -> bool {\n-        self.align_to::<&static/str>();\n-        if ! self.inner.visit_estr_slice() { return false; }\n-        self.bump_past::<&static/str>();\n-        true\n-    }\n-\n-    fn visit_estr_fixed(n: uint,\n-                        sz: uint,\n-                        align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_estr_fixed(n, sz, align) { return false; }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_box(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<@u8>();\n-        if ! self.inner.visit_box(mtbl, inner) { return false; }\n-        self.bump_past::<@u8>();\n-        true\n-    }\n-\n-    fn visit_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~u8>();\n-        if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<~u8>();\n-        true\n-    }\n-\n-    fn visit_ptr(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<*u8>();\n-        if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n-        self.bump_past::<*u8>();\n-        true\n-    }\n-\n-    fn visit_rptr(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&static/u8>();\n-        if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n-        self.bump_past::<&static/u8>();\n-        true\n-    }\n-\n-    fn visit_unboxed_vec(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<vec::UnboxedVecRepr>();\n-        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_vec(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner.visit_vec(mtbl, inner) { return false; }\n-        self.bump_past::<~[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_box(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<@[u8]>();\n-        if ! self.inner.visit_evec_box(mtbl, inner) { return false; }\n-        self.bump_past::<@[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner.visit_evec_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<~[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_slice(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&static/[u8]>();\n-        if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n-        self.bump_past::<&static/[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_fixed(n: uint, sz: uint, align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_evec_fixed(n, sz, align, mtbl, inner) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_enter_rec(n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_rec_field(i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_rec_field(i, name, mtbl, inner) {\n-            return false;\n-        }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_rec(n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_class(n_fields: uint, sz: uint, align: uint)\n-                      -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_class(n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_class_field(i: uint, name: &str,\n-                         mtbl: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_class_field(i, name, mtbl, inner) {\n-            return false;\n-        }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_class(n_fields: uint, sz: uint, align: uint)\n-                      -> bool {\n-        if ! self.inner.visit_leave_class(n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_tup(n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_tup_field(i: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_tup_field(i, inner) { return false; }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_tup(n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_fn(purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n-            return false\n-        }\n-        true\n-    }\n-\n-    fn visit_fn_input(i: uint, mode: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_fn_output(retstyle: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_fn_output(retstyle, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_leave_fn(purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_enum(n_variants: uint, sz: uint, align: uint)\n-                     -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_enum(n_variants, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_enum_variant(variant: uint,\n-                                disr_val: int,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        self.inner.push_ptr();\n-        if ! self.inner.visit_enter_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enum_variant_field(i: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_enum_variant_field(i, inner) { return false; }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_enum_variant(variant: uint,\n-                                disr_val: int,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        if ! self.inner.visit_leave_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        self.inner.pop_ptr();\n-        true\n-    }\n-\n-    fn visit_leave_enum(n_variants: uint, sz: uint, align: uint)\n-                     -> bool {\n-        if ! self.inner.visit_leave_enum(n_variants, sz, align) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_trait() -> bool {\n-        self.align_to::<TyVisitor>();\n-        if ! self.inner.visit_trait() { return false; }\n-        self.bump_past::<TyVisitor>();\n-        true\n-    }\n-\n-    fn visit_var() -> bool {\n-        if ! self.inner.visit_var() { return false; }\n-        true\n-    }\n-\n-    fn visit_var_integral() -> bool {\n-        if ! self.inner.visit_var_integral() { return false; }\n-        true\n-    }\n-\n-    fn visit_param(i: uint) -> bool {\n-        if ! self.inner.visit_param(i) { return false; }\n-        true\n-    }\n-\n-    fn visit_self() -> bool {\n-        self.align_to::<&static/u8>();\n-        if ! self.inner.visit_self() { return false; }\n-        self.align_to::<&static/u8>();\n-        true\n-    }\n-\n-    fn visit_type() -> bool {\n-        if ! self.inner.visit_type() { return false; }\n-        true\n-    }\n-\n-    fn visit_opaque_box() -> bool {\n-        self.align_to::<@u8>();\n-        if ! self.inner.visit_opaque_box() { return false; }\n-        self.bump_past::<@u8>();\n-        true\n-    }\n-\n-    fn visit_constr(inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_constr(inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_closure_ptr(ck: uint) -> bool {\n-        self.align_to::<fn@()>();\n-        if ! self.inner.visit_closure_ptr(ck) { return false; }\n-        self.bump_past::<fn@()>();\n-        true\n-    }\n-}\n-\n-/// Abstract type-directed pointer-movement using the MovePtr trait\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl<V: TyVisitor MovePtr> MovePtrAdaptor<V>: TyVisitor {\n     fn visit_bot(&self) -> bool {\n         self.align_to::<()>();"}, {"sha": "a47bad008b872ca5ad38d70eb605c7caee8d2eec", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 0, "deletions": 300, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -14,9 +14,6 @@ More runtime type reflection\n \n */\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cast::transmute;\n use cast;\n use char;\n@@ -265,303 +262,6 @@ impl ReprVisitor {\n \n }\n \n-#[cfg(stage0)]\n-impl ReprVisitor : TyVisitor {\n-    fn visit_bot() -> bool {\n-        self.writer.write_str(\"!\");\n-        true\n-    }\n-    fn visit_nil() -> bool { self.write::<()>() }\n-    fn visit_bool() -> bool { self.write::<bool>() }\n-    fn visit_int() -> bool { self.write::<int>() }\n-    fn visit_i8() -> bool { self.write::<i8>() }\n-    fn visit_i16() -> bool { self.write::<i16>() }\n-    fn visit_i32() -> bool { self.write::<i32>()  }\n-    fn visit_i64() -> bool { self.write::<i64>() }\n-\n-    fn visit_uint() -> bool { self.write::<uint>() }\n-    fn visit_u8() -> bool { self.write::<u8>() }\n-    fn visit_u16() -> bool { self.write::<u16>() }\n-    fn visit_u32() -> bool { self.write::<u32>() }\n-    fn visit_u64() -> bool { self.write::<u64>() }\n-\n-    fn visit_float() -> bool { self.write::<float>() }\n-    fn visit_f32() -> bool { self.write::<f32>() }\n-    fn visit_f64() -> bool { self.write::<f64>() }\n-\n-    fn visit_char() -> bool {\n-        do self.get::<char> |&ch| {\n-            self.writer.write_char('\\'');\n-            self.writer.write_escaped_char(ch);\n-            self.writer.write_char('\\'');\n-        }\n-    }\n-\n-    // Type no longer exists, vestigial function.\n-    fn visit_str() -> bool { die!(); }\n-\n-    fn visit_estr_box() -> bool {\n-        do self.get::<@str> |s| {\n-            self.writer.write_char('@');\n-            self.write_escaped_slice(*s);\n-        }\n-    }\n-    fn visit_estr_uniq() -> bool {\n-        do self.get::<~str> |s| {\n-            self.writer.write_char('~');\n-            self.write_escaped_slice(*s);\n-        }\n-    }\n-    fn visit_estr_slice() -> bool {\n-        do self.get::<&str> |s| {\n-            self.write_escaped_slice(*s);\n-        }\n-    }\n-\n-    // Type no longer exists, vestigial function.\n-    fn visit_estr_fixed(_n: uint, _sz: uint,\n-                        _align: uint) -> bool { die!(); }\n-\n-    fn visit_box(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write_char('@');\n-        self.write_mut_qualifier(mtbl);\n-        do self.get::<&managed::raw::BoxRepr> |b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            self.visit_ptr_inner(p, inner);\n-        }\n-    }\n-\n-    fn visit_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write_char('~');\n-        self.write_mut_qualifier(mtbl);\n-        do self.get::<&managed::raw::BoxRepr> |b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            self.visit_ptr_inner(p, inner);\n-        }\n-    }\n-\n-    fn visit_ptr(_mtbl: uint, _inner: *TyDesc) -> bool {\n-        do self.get::<*c_void> |p| {\n-            self.writer.write_str(fmt!(\"(0x%x as *())\",\n-                                       *p as uint));\n-        }\n-    }\n-\n-    fn visit_rptr(mtbl: uint, inner: *TyDesc) -> bool {\n-        self.writer.write_char('&');\n-        self.write_mut_qualifier(mtbl);\n-        do self.get::<*c_void> |p| {\n-            self.visit_ptr_inner(*p, inner);\n-        }\n-    }\n-\n-    // Type no longer exists, vestigial function.\n-    fn visit_vec(_mtbl: uint, _inner: *TyDesc) -> bool { die!(); }\n-\n-\n-    fn visit_unboxed_vec(mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<vec::UnboxedVecRepr> |b| {\n-            self.write_unboxed_vec_repr(mtbl, b, inner);\n-        }\n-    }\n-\n-    fn visit_evec_box(mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&VecRepr> |b| {\n-            self.writer.write_char('@');\n-            self.write_unboxed_vec_repr(mtbl, &b.unboxed, inner);\n-        }\n-    }\n-\n-    fn visit_evec_uniq(mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<&VecRepr> |b| {\n-            self.writer.write_char('~');\n-            self.write_unboxed_vec_repr(mtbl, &b.unboxed, inner);\n-        }\n-    }\n-\n-    fn visit_evec_slice(mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<SliceRepr> |s| {\n-            self.writer.write_char('&');\n-            self.write_vec_range(mtbl, s.data, s.len, inner);\n-        }\n-    }\n-\n-    fn visit_evec_fixed(_n: uint, sz: uint, _align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool {\n-        do self.get::<u8> |b| {\n-            self.write_vec_range(mtbl, ptr::to_unsafe_ptr(b), sz, inner);\n-        }\n-    }\n-\n-    fn visit_enter_rec(_n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('{');\n-        true\n-    }\n-\n-    fn visit_rec_field(i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            self.writer.write_str(\", \");\n-        }\n-        self.write_mut_qualifier(mtbl);\n-        self.writer.write_str(name);\n-        self.writer.write_str(\": \");\n-        self.visit_inner(inner);\n-        true\n-    }\n-\n-    fn visit_leave_rec(_n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('}');\n-        true\n-    }\n-\n-    fn visit_enter_class(_n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('{');\n-        true\n-    }\n-    fn visit_class_field(i: uint, name: &str,\n-                         mtbl: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            self.writer.write_str(\", \");\n-        }\n-        self.write_mut_qualifier(mtbl);\n-        self.writer.write_str(name);\n-        self.writer.write_str(\": \");\n-        self.visit_inner(inner);\n-        true\n-    }\n-    fn visit_leave_class(_n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('}');\n-        true\n-    }\n-\n-    fn visit_enter_tup(_n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char('(');\n-        true\n-    }\n-    fn visit_tup_field(i: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            self.writer.write_str(\", \");\n-        }\n-        self.visit_inner(inner);\n-        true\n-    }\n-    fn visit_leave_tup(_n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        self.writer.write_char(')');\n-        true\n-    }\n-\n-    fn visit_enter_enum(n_variants: uint,\n-                        _sz: uint, _align: uint) -> bool {\n-        if n_variants == 1 {\n-            self.var_stk.push(Degenerate)\n-        } else {\n-            self.var_stk.push(TagMatch)\n-        }\n-        true\n-    }\n-    fn visit_enter_enum_variant(_variant: uint,\n-                                disr_val: int,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        let mut write = false;\n-        match self.var_stk.pop() {\n-            Degenerate => {\n-                write = true;\n-                self.var_stk.push(Degenerate);\n-            }\n-            TagMatch | TagMismatch => {\n-                do self.get::<int>() |t| {\n-                    if disr_val == *t {\n-                        write = true;\n-                        self.var_stk.push(TagMatch);\n-                    } else {\n-                        self.var_stk.push(TagMismatch);\n-                    }\n-                };\n-                self.bump_past::<int>();\n-            }\n-        }\n-\n-        if write {\n-            self.writer.write_str(name);\n-            if n_fields > 0 {\n-                self.writer.write_char('(');\n-            }\n-        }\n-        true\n-    }\n-    fn visit_enum_variant_field(i: uint, inner: *TyDesc) -> bool {\n-        match self.var_stk.last() {\n-            Degenerate | TagMatch => {\n-                if i != 0 {\n-                    self.writer.write_str(\", \");\n-                }\n-                if ! self.visit_inner(inner) {\n-                    return false;\n-                }\n-            }\n-            TagMismatch => ()\n-        }\n-        true\n-    }\n-    fn visit_leave_enum_variant(_variant: uint,\n-                                _disr_val: int,\n-                                n_fields: uint,\n-                                _name: &str) -> bool {\n-        match self.var_stk.last() {\n-            Degenerate | TagMatch => {\n-                if n_fields > 0 {\n-                    self.writer.write_char(')');\n-                }\n-            }\n-            TagMismatch => ()\n-        }\n-        true\n-    }\n-    fn visit_leave_enum(_n_variants: uint,\n-                        _sz: uint, _align: uint) -> bool {\n-        self.var_stk.pop();\n-        true\n-    }\n-\n-    fn visit_enter_fn(_purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-    fn visit_fn_input(_i: uint, _mode: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_fn_output(_retstyle: uint, _inner: *TyDesc) -> bool { true }\n-    fn visit_leave_fn(_purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-\n-\n-    fn visit_trait() -> bool { true }\n-    fn visit_var() -> bool { true }\n-    fn visit_var_integral() -> bool { true }\n-    fn visit_param(_i: uint) -> bool { true }\n-    fn visit_self() -> bool { true }\n-    fn visit_type() -> bool { true }\n-\n-    fn visit_opaque_box() -> bool {\n-        self.writer.write_char('@');\n-        do self.get::<&managed::raw::BoxRepr> |b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n-            self.visit_ptr_inner(p, b.header.type_desc);\n-        }\n-    }\n-\n-    // Type no longer exists, vestigial function.\n-    fn visit_constr(_inner: *TyDesc) -> bool { die!(); }\n-\n-    fn visit_closure_ptr(_ck: uint) -> bool { true }\n-}\n-\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n impl ReprVisitor : TyVisitor {\n     fn visit_bot(&self) -> bool {\n         self.writer.write_str(\"!\");"}, {"sha": "7f1513173786b2878807e1c9bdea85b8c4a935a7", "filename": "src/libcore/result.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -12,9 +12,6 @@\n \n // NB: transitionary, de-mode-ing.\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp;\n use cmp::Eq;\n use either;"}, {"sha": "33d76cb3c685999acb476af6f752cee06b871d2c", "filename": "src/libcore/rt.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n //! Runtime calls emitted by the compiler.\n \n use cast::transmute;"}, {"sha": "e44bd2aab81728ae8b968a773123d91968670853", "filename": "src/libcore/run.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frun.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n #[allow(structural_records)];\n \n //! Process spawning"}, {"sha": "2e24df86c7809933159760e94590481d42f450b6", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -11,12 +11,7 @@\n #[doc(hidden)]; // FIXME #3538\n \n #[legacy_modes]; // tjc: remove after snapshot\n-\n-// NB: transitionary, de-mode-ing.\n-// FIXME #4425: Can't forbid this because frame_address needs a deprecated\n-// mode.\n #[allow(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n \n use cast::reinterpret_cast;\n use ptr::offset;"}, {"sha": "9b25f92ede2a47f10fece711bd4c2b10c22186c7", "filename": "src/libcore/str.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -17,9 +17,6 @@\n  * some heavy-duty uses, try std::rope.\n  */\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use at_vec;\n use cast;\n use char;\n@@ -2314,6 +2311,21 @@ impl &str: StrSlice {\n     pure fn char_at(i: uint) -> char { char_at(self, i) }\n }\n \n+pub trait OwnedStr {\n+    fn push_str(&mut self, v: &str);\n+    fn push_char(&mut self, c: char);\n+}\n+\n+pub impl ~str : OwnedStr {\n+    fn push_str(&mut self, v: &str) {\n+        push_str(self, v);\n+    }\n+\n+    fn push_char(&mut self, c: char) {\n+        push_char(self, c);\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use char;"}, {"sha": "1571e645117849b68bbb9ee6af0790446519498a", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,10 +10,6 @@\n \n //! Misc low level stuff\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cast;\n use cmp::{Eq, Ord};\n use gc;"}, {"sha": "9240a67c69a3dfd97b1435f51de751d3021adca9", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,11 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-// tjc: Deprecated modes allowed because of function arg issue\n-// in task::spawn. Re-forbid after snapshot.\n-#[forbid(deprecated_pattern)];\n-\n /*!\n  * Task management.\n  *"}, {"sha": "22a0c870de6495d7100984206bb4e8c6496440a1", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -71,7 +71,6 @@\n  ****************************************************************************/\n \n #[doc(hidden)]; // FIXME #3538\n-#[warn(deprecated_mode)];\n \n use cast;\n use container::Map;"}, {"sha": "b4647d0c621a112a37237e36300da876968fcaf5", "filename": "src/libcore/to_bytes.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_bytes.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -14,16 +14,12 @@ The `ToBytes` and `IterBytes` traits\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use io;\n use io::Writer;\n use option::{None, Option, Some};\n use str;\n \n-pub type Cb = fn(buf: &[const u8]) -> bool;\n+pub type Cb = &fn(buf: &[const u8]) -> bool;\n \n /**\n  * A trait to implement in order to make a type hashable;"}, {"sha": "d98e341eab8a36c6a59430fde366fa1e60f2745e", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -14,10 +14,6 @@ The `ToStr` trait for converting to strings\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use kinds::Copy;\n use str;\n use vec;"}, {"sha": "484fc1a5a276556bbdb8031281ee1e7f2d662a03", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n //! Operations on tuples\n \n use cmp::{Eq, Ord};"}, {"sha": "ff3b908186a18b21b54b46b05a118443ed5b772c", "filename": "src/libcore/unicode.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -9,9 +9,6 @@\n // except according to those terms.\n \n #[doc(hidden)]; // FIXME #3538\n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n \n pub mod general_category {\n     pub pure fn Cc(c: char) -> bool {"}, {"sha": "3b6a134bc52cd497c2969d43b56d173efa2cc444", "filename": "src/libcore/util.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -14,10 +14,6 @@ Miscellaneous helpers for common patterns.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n-\n use cmp::Eq;\n use prelude::*;\n "}, {"sha": "9ad5d9f32da366ead0b74f1ab61b888e2d923384", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 84, "deletions": 20, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,8 +10,6 @@\n \n //! Vectors\n \n-#[forbid(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n #[warn(non_camel_case_types)];\n \n use container::{Container, Mutable};\n@@ -841,14 +839,37 @@ pub pure fn map2<T: Copy, U: Copy, V>(v0: &[T], v1: &[U],\n     u\n }\n \n-/**\n- * Apply a function to each element of a vector and return the results\n- *\n- * If function `f` returns `none` then that element is excluded from\n- * the resulting vector.\n- */\n-pub pure fn filter_map<T, U: Copy>(v: &[T], f: fn(t: &T) -> Option<U>)\n-    -> ~[U] {\n+pub fn filter_map<T, U>(\n+    v: ~[T],\n+    f: fn(t: T) -> Option<U>) -> ~[U]\n+{\n+    /*!\n+     *\n+     * Apply a function to each element of a vector and return the results.\n+     * Consumes the input vector.  If function `f` returns `None` then that\n+     * element is excluded from the resulting vector.\n+     */\n+\n+    let mut result = ~[];\n+    do consume(v) |_, elem| {\n+        match f(elem) {\n+            None => {}\n+            Some(result_elem) => { result.push(result_elem); }\n+        }\n+    }\n+    result\n+}\n+\n+pub pure fn filter_mapped<T, U: Copy>(\n+    v: &[T],\n+    f: fn(t: &T) -> Option<U>) -> ~[U]\n+{\n+    /*!\n+     *\n+     * Like `filter_map()`, but operates on a borrowed slice\n+     * and does not consume the input.\n+     */\n+\n     let mut result = ~[];\n     for each(v) |elem| {\n         match f(elem) {\n@@ -1695,7 +1716,7 @@ pub trait ImmutableVector<T> {\n     fn map_r<U>(&self, f: fn(x: &T) -> U) -> ~[U];\n     pure fn alli(&self, f: fn(uint, t: &T) -> bool) -> bool;\n     pure fn flat_map<U>(&self, f: fn(t: &T) -> ~[U]) -> ~[U];\n-    pure fn filter_map<U: Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U];\n+    pure fn filter_mapped<U: Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U];\n }\n \n /// Extension methods for vectors\n@@ -1758,8 +1779,8 @@ impl<T> &[T]: ImmutableVector<T> {\n      * the resulting vector.\n      */\n     #[inline]\n-    pure fn filter_map<U: Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U] {\n-        filter_map(*self, f)\n+    pure fn filter_mapped<U: Copy>(&self, f: fn(t: &T) -> Option<U>) -> ~[U] {\n+        filter_mapped(*self, f)\n     }\n }\n \n@@ -2439,10 +2460,14 @@ mod tests {\n \n     pure fn is_equal(x: &uint, y:&uint) -> bool { return *x == *y; }\n \n-    fn square_if_odd(n: &uint) -> Option<uint> {\n+    fn square_if_odd_r(n: &uint) -> Option<uint> {\n         return if *n % 2u == 1u { Some(*n * *n) } else { None };\n     }\n \n+    fn square_if_odd_v(n: uint) -> Option<uint> {\n+        return if n % 2u == 1u { Some(n * n) } else { None };\n+    }\n+\n     fn add(x: uint, y: &uint) -> uint { return x + *y; }\n \n     #[test]\n@@ -2775,17 +2800,17 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_filter_map() {\n+    fn test_filter_mapped() {\n         // Test on-stack filter-map.\n         let mut v = ~[1u, 2u, 3u];\n-        let mut w = filter_map(v, square_if_odd);\n+        let mut w = filter_mapped(v, square_if_odd_r);\n         assert (len(w) == 2u);\n         assert (w[0] == 1u);\n         assert (w[1] == 9u);\n \n         // Test on-heap filter-map.\n         v = ~[1u, 2u, 3u, 4u, 5u];\n-        w = filter_map(v, square_if_odd);\n+        w = filter_mapped(v, square_if_odd_r);\n         assert (len(w) == 3u);\n         assert (w[0] == 1u);\n         assert (w[1] == 9u);\n@@ -2804,7 +2829,46 @@ mod tests {\n         let all_odd2: ~[int] = ~[];\n         let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n         let mix_dest: ~[int] = ~[1, 3, 0, 0];\n-        assert (filter_map(all_even, halve) == map(all_even, halve_for_sure));\n+        assert (filter_mapped(all_even, halve) ==\n+                map(all_even, halve_for_sure));\n+        assert (filter_mapped(all_odd1, halve) == ~[]);\n+        assert (filter_mapped(all_odd2, halve) == ~[]);\n+        assert (filter_mapped(mix, halve) == mix_dest);\n+    }\n+\n+    #[test]\n+    fn test_filter_map() {\n+        // Test on-stack filter-map.\n+        let mut v = ~[1u, 2u, 3u];\n+        let mut w = filter_map(v, square_if_odd_v);\n+        assert (len(w) == 2u);\n+        assert (w[0] == 1u);\n+        assert (w[1] == 9u);\n+\n+        // Test on-heap filter-map.\n+        v = ~[1u, 2u, 3u, 4u, 5u];\n+        w = filter_map(v, square_if_odd_v);\n+        assert (len(w) == 3u);\n+        assert (w[0] == 1u);\n+        assert (w[1] == 9u);\n+        assert (w[2] == 25u);\n+\n+        fn halve(i: int) -> Option<int> {\n+            if i % 2 == 0 {\n+                return option::Some::<int>(i / 2);\n+            } else {\n+                return option::None::<int>;\n+            }\n+        }\n+        fn halve_for_sure(i: &int) -> int { return *i / 2; }\n+        let all_even: ~[int] = ~[0, 2, 8, 6];\n+        let all_even0: ~[int] = copy all_even;\n+        let all_odd1: ~[int] = ~[1, 7, 3];\n+        let all_odd2: ~[int] = ~[];\n+        let mix: ~[int] = ~[9, 2, 6, 7, 1, 0, 0, 3];\n+        let mix_dest: ~[int] = ~[1, 3, 0, 0];\n+        assert (filter_map(all_even, halve) ==\n+                map(all_even0, halve_for_sure));\n         assert (filter_map(all_odd1, halve) == ~[]);\n         assert (filter_map(all_odd2, halve) == ~[]);\n         assert (filter_map(mix, halve) == mix_dest);\n@@ -3664,10 +3728,10 @@ mod tests {\n     #[ignore(windows)]\n     #[should_fail]\n     #[allow(non_implicitly_copyable_typarams)]\n-    fn test_filter_map_fail() {\n+    fn test_filter_mapped_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do filter_map(v) |_elt| {\n+        do filter_mapped(v) |_elt| {\n             if i == 2 {\n                 die!()\n             }"}, {"sha": "de7c52520ccd77d04ffcf872c805010b30b96c40", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -596,7 +596,7 @@ pub fn symbol_hash(tcx: ty::ctxt, symbol_hasher: &hash::State, t: ty::t,\n }\n \n pub fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> @str {\n-    match ccx.type_hashcodes.find(t) {\n+    match ccx.type_hashcodes.find(&t) {\n       Some(h) => h,\n       None => {\n         let hash = symbol_hash(ccx.tcx, ccx.symbol_hasher, t, ccx.link_meta);"}, {"sha": "5bbf3f839adf422a0e711e98d1946f44ba9f348c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -538,7 +538,7 @@ pub fn build_session_options(+binary: ~str,\n                                 getopts::opt_strs(matches, level_name));\n         for flags.each |lint_name| {\n             let lint_name = str::replace(*lint_name, ~\"-\", ~\"_\");\n-            match lint_dict.find(/*bad*/ copy lint_name) {\n+            match lint_dict.find(&lint_name) {\n               None => {\n                 early_error(demitter, fmt!(\"unknown %s flag: %s\",\n                                            level_name, lint_name));"}, {"sha": "cf75db3a900140dfb349abd711b9cc7b2c0458b5", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -64,12 +64,13 @@ fn filter_view_item(cx: ctxt, &&view_item: @ast::view_item\n }\n \n fn fold_mod(cx: ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n-    let filtered_items = vec::filter_map(m.items, |a| filter_item(cx, *a));\n-    let filtered_view_items = vec::filter_map(m.view_items,\n-                                              |a| filter_view_item(cx, *a));\n+    let filtered_items =\n+        m.items.filter_mapped(|a| filter_item(cx, *a));\n+    let filtered_view_items =\n+        m.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n     ast::_mod {\n         view_items: filtered_view_items.map(|x| fld.fold_view_item(*x)),\n-        items: filtered_items.filter_map(|x| fld.fold_item(*x)),\n+        items: vec::filter_map(filtered_items, |x| fld.fold_item(x))\n     }\n }\n \n@@ -85,10 +86,10 @@ fn fold_foreign_mod(\n     nm: ast::foreign_mod,\n     fld: fold::ast_fold\n ) -> ast::foreign_mod {\n-    let filtered_items = vec::filter_map(nm.items,\n-                                         |a| filter_foreign_item(cx, *a));\n-    let filtered_view_items = vec::filter_map(nm.view_items,\n-                                              |a| filter_view_item(cx, *a));\n+    let filtered_items =\n+        nm.items.filter_mapped(|a| filter_foreign_item(cx, *a));\n+    let filtered_view_items =\n+        nm.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n     ast::foreign_mod {\n         sort: nm.sort,\n         abi: nm.abi,\n@@ -136,7 +137,8 @@ fn fold_block(\n     b: ast::blk_,\n     fld: fold::ast_fold\n ) -> ast::blk_ {\n-    let filtered_stmts = vec::filter_map(b.stmts, |a| filter_stmt(cx, *a));\n+    let filtered_stmts =\n+        b.stmts.filter_mapped(|a| filter_stmt(cx, *a));\n     ast::blk_ {\n         view_items: /*bad*/copy b.view_items,\n         stmts: vec::map(filtered_stmts, |x| fld.fold_stmt(*x)),\n@@ -183,8 +185,9 @@ pub fn metas_in_cfg(cfg: ast::crate_cfg,\n     // Pull the inner meta_items from the #[cfg(meta_item, ...)]  attributes,\n     // so we can match against them. This is the list of configurations for\n     // which the item is valid\n-    let cfg_metas = vec::concat(vec::filter_map(cfg_metas,\n-        |i| attr::get_meta_item_list(*i)));\n+    let cfg_metas =\n+        vec::concat(\n+            vec::filter_map(cfg_metas, |i| attr::get_meta_item_list(i)));\n \n     let has_cfg_metas = vec::len(cfg_metas) > 0u;\n     if !has_cfg_metas { return true; }"}, {"sha": "9fa1cea3e103f9106782aed90fd2f8f7ee316507", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 45, "deletions": 68, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -168,9 +168,11 @@ fn is_test_fn(i: @ast::item) -> bool {\n fn is_ignored(cx: test_ctxt, i: @ast::item) -> bool {\n     let ignoreattrs = attr::find_attrs_by_name(i.attrs, \"ignore\");\n     let ignoreitems = attr::attr_metas(ignoreattrs);\n-    let cfg_metas = vec::concat(vec::filter_map(ignoreitems,\n-        |i| attr::get_meta_item_list(*i)));\n     return if !ignoreitems.is_empty() {\n+        let cfg_metas =\n+            vec::concat(\n+                vec::filter_map(ignoreitems,\n+                                |i| attr::get_meta_item_list(i)));\n         config::metas_in_cfg(/*bad*/copy cx.crate.node.config, cfg_metas)\n     } else {\n         false\n@@ -277,7 +279,7 @@ fn mk_std(cx: test_ctxt) -> @ast::view_item {\n }\n \n fn mk_tests(cx: test_ctxt) -> @ast::item {\n-    let ret_ty = mk_test_desc_vec_ty(cx);\n+    let ret_ty = mk_test_desc_and_fn_vec_ty(cx);\n \n     let decl = ast::fn_decl {\n         inputs: ~[],\n@@ -286,7 +288,7 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n     };\n \n     // The vector of test_descs for this crate\n-    let test_descs = mk_test_desc_vec(cx);\n+    let test_descs = mk_test_desc_and_fn_vec(cx);\n \n     let body_: ast::blk_ =\n         default_block(~[], option::Some(test_descs), cx.sess.next_node_id());\n@@ -327,19 +329,21 @@ fn mk_path(cx: test_ctxt, +path: ~[ast::ident]) -> @ast::path {\n     }\n }\n \n-// The ast::Ty of ~[std::test::test_desc]\n-fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::Ty {\n-    let test_desc_ty_path =\n+// The ast::Ty of ~[std::test::TestDescAndFn]\n+fn mk_test_desc_and_fn_vec_ty(cx: test_ctxt) -> @ast::Ty {\n+    let test_desc_and_fn_ty_path =\n         mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n-                      cx.sess.ident_of(~\"TestDesc\")]);\n+                      cx.sess.ident_of(~\"TestDescAndFn\")]);\n \n-    let test_desc_ty = ast::Ty {\n+    let test_desc_and_fn_ty = ast::Ty {\n         id: cx.sess.next_node_id(),\n-        node: ast::ty_path(test_desc_ty_path, cx.sess.next_node_id()),\n+        node: ast::ty_path(test_desc_and_fn_ty_path,\n+                           cx.sess.next_node_id()),\n         span: dummy_sp(),\n     };\n \n-    let vec_mt = ast::mt {ty: @test_desc_ty, mutbl: ast::m_imm};\n+    let vec_mt = ast::mt {ty: @test_desc_and_fn_ty,\n+                          mutbl: ast::m_imm};\n \n     let inner_ty = @ast::Ty {\n         id: cx.sess.next_node_id(),\n@@ -354,11 +358,11 @@ fn mk_test_desc_vec_ty(cx: test_ctxt) -> @ast::Ty {\n     }\n }\n \n-fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n+fn mk_test_desc_and_fn_vec(cx: test_ctxt) -> @ast::expr {\n     debug!(\"building test vector from %u tests\", cx.testfns.len());\n     let mut descs = ~[];\n     for cx.testfns.each |test| {\n-        descs.push(mk_test_desc_rec(cx, *test));\n+        descs.push(mk_test_desc_and_fn_rec(cx, *test));\n     }\n \n     let inner_expr = @ast::expr {\n@@ -376,7 +380,7 @@ fn mk_test_desc_vec(cx: test_ctxt) -> @ast::expr {\n     }\n }\n \n-fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n+fn mk_test_desc_and_fn_rec(cx: test_ctxt, test: test) -> @ast::expr {\n     let span = test.span;\n     let path = /*bad*/copy test.path;\n \n@@ -407,23 +411,6 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n         expr: @name_expr,\n     });\n \n-    let fn_path = path_node_global(path);\n-\n-    let fn_expr = ast::expr {\n-        id: cx.sess.next_node_id(),\n-        callee_id: cx.sess.next_node_id(),\n-        node: ast::expr_path(fn_path),\n-        span: span,\n-    };\n-\n-    let fn_wrapper_expr = mk_test_wrapper(cx, fn_expr, span);\n-\n-    let fn_field = nospan(ast::field_ {\n-        mutbl: ast::m_imm,\n-        ident: cx.sess.ident_of(~\"testfn\"),\n-        expr: fn_wrapper_expr,\n-    });\n-\n     let ignore_lit: ast::lit = nospan(ast::lit_bool(test.ignore));\n \n     let ignore_expr = ast::expr {\n@@ -460,62 +447,52 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n \n     let desc_rec_ = ast::expr_struct(\n         test_desc_path,\n-        ~[name_field, fn_field, ignore_field, fail_field],\n+        ~[name_field, ignore_field, fail_field],\n         option::None\n     );\n \n-    let desc_rec = ast::expr {\n+    let desc_rec = @ast::expr {\n         id: cx.sess.next_node_id(),\n         callee_id: cx.sess.next_node_id(),\n         node: desc_rec_,\n         span: span,\n     };\n \n-    return @desc_rec;\n-}\n+    let desc_field = nospan(ast::field_ {\n+        mutbl: ast::m_imm,\n+        ident: cx.sess.ident_of(~\"desc\"),\n+        expr: desc_rec\n+    });\n \n-// Produces a bare function that wraps the test function\n+    let fn_path = path_node_global(path);\n \n-// FIXME (#1281): This can go away once fn is the type of bare function.\n-fn mk_test_wrapper(cx: test_ctxt,\n-                   +fn_path_expr: ast::expr,\n-                   span: span) -> @ast::expr {\n-    let call_expr = ast::expr {\n+    let fn_expr = @ast::expr {\n         id: cx.sess.next_node_id(),\n         callee_id: cx.sess.next_node_id(),\n-        node: ast::expr_call(@fn_path_expr, ~[], false),\n+        node: ast::expr_path(fn_path),\n         span: span,\n     };\n \n-    let call_stmt: ast::stmt = nospan(\n-        ast::stmt_semi(@call_expr, cx.sess.next_node_id()));\n-\n-    let wrapper_decl = ast::fn_decl {\n-        inputs: ~[],\n-        output: @ast::Ty {\n-            id: cx.sess.next_node_id(),\n-            node: ast::ty_nil,\n-            span: span,\n-        },\n-        cf: ast::return_val\n-    };\n-\n-    let wrapper_body = nospan(ast::blk_ {\n-        view_items: ~[],\n-        stmts: ~[@call_stmt],\n-        expr: option::None,\n-        id: cx.sess.next_node_id(),\n-        rules: ast::default_blk\n+    let fn_field = nospan(ast::field_ {\n+        mutbl: ast::m_imm,\n+        ident: cx.sess.ident_of(~\"testfn\"),\n+        expr: fn_expr,\n     });\n \n-    let wrapper_expr = ast::expr  {\n+    let test_desc_and_fn_path =\n+        mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n+                      cx.sess.ident_of(~\"TestDescAndFn\")]);\n+\n+    let desc_and_fn_rec = @ast::expr {\n         id: cx.sess.next_node_id(),\n         callee_id: cx.sess.next_node_id(),\n-        node: ast::expr_fn(ast::ProtoBare, wrapper_decl, wrapper_body, @()),\n-        span: span\n+        node: ast::expr_struct(test_desc_and_fn_path,\n+                               ~[fn_field, desc_field],\n+                               option::None),\n+        span: span,\n     };\n \n-    return @wrapper_expr;\n+    return desc_and_fn_rec;\n }\n \n fn mk_main(cx: test_ctxt) -> @ast::item {\n@@ -567,7 +544,7 @@ fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n     let args_call_expr = ast::expr {\n         id: cx.sess.next_node_id(),\n         callee_id: cx.sess.next_node_id(),\n-        node: ast::expr_call(@args_path_expr, ~[], false),\n+        node: ast::expr_call(@args_path_expr, ~[], ast::NoSugar),\n         span: dummy_sp(),\n     };\n \n@@ -584,7 +561,7 @@ fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n     let test_call_expr = ast::expr {\n         id: cx.sess.next_node_id(),\n         callee_id: cx.sess.next_node_id(),\n-        node: ast::expr_call(@test_path_expr, ~[], false),\n+        node: ast::expr_call(@test_path_expr, ~[], ast::NoSugar),\n         span: dummy_sp(),\n     };\n \n@@ -606,7 +583,7 @@ fn mk_test_main_call(cx: test_ctxt) -> @ast::expr {\n         node: ast::expr_call(\n             @test_main_path_expr,\n             ~[@args_call_expr, @test_call_expr],\n-            false\n+            ast::NoSugar\n         ),\n         span: dummy_sp(),\n     };"}, {"sha": "2e3967021c1d3398bf69484fe5efed26b1469a82", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -445,14 +445,19 @@ pub extern mod llvm {\n                                            Count: c_uint,\n                                            Packed: Bool) -> ValueRef;\n \n-    pub unsafe fn LLVMConstString(Str: *c_char, Length: c_uint,\n-                       DontNullTerminate: Bool) -> ValueRef;\n-    pub unsafe fn LLVMConstArray(ElementTy: TypeRef, ConstantVals: *ValueRef,\n-                      Length: c_uint) -> ValueRef;\n+    pub unsafe fn LLVMConstString(Str: *c_char,\n+                                  Length: c_uint,\n+                                  DontNullTerminate: Bool)\n+                               -> ValueRef;\n+    pub unsafe fn LLVMConstArray(ElementTy: TypeRef,\n+                                 ConstantVals: *ValueRef,\n+                                 Length: c_uint)\n+                              -> ValueRef;\n     pub unsafe fn LLVMConstStruct(ConstantVals: *ValueRef,\n-                       Count: c_uint, Packed: Bool) -> ValueRef;\n+                                  Count: c_uint,\n+                                  Packed: Bool) -> ValueRef;\n     pub unsafe fn LLVMConstVector(ScalarConstantVals: *ValueRef,\n-                       Size: c_uint) -> ValueRef;\n+                                  Size: c_uint) -> ValueRef;\n \n     /* Constant expressions */\n     pub unsafe fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n@@ -463,8 +468,8 @@ pub extern mod llvm {\n     pub unsafe fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n     pub unsafe fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n     pub unsafe fn LLVMConstAdd(LHSConstant: ValueRef,\n-                           RHSConstant: ValueRef)\n-                        -> ValueRef;\n+                               RHSConstant: ValueRef)\n+                            -> ValueRef;\n     pub unsafe fn LLVMConstNSWAdd(LHSConstant: ValueRef,\n                               RHSConstant: ValueRef)\n                            -> ValueRef;\n@@ -475,14 +480,14 @@ pub extern mod llvm {\n                             RHSConstant: ValueRef)\n                          -> ValueRef;\n     pub unsafe fn LLVMConstSub(LHSConstant: ValueRef,\n-                           RHSConstant: ValueRef)\n-                        -> ValueRef;\n+                               RHSConstant: ValueRef)\n+                            -> ValueRef;\n     pub unsafe fn LLVMConstNSWSub(LHSConstant: ValueRef,\n-                              RHSConstant: ValueRef)\n-                           -> ValueRef;\n+                                  RHSConstant: ValueRef)\n+                               -> ValueRef;\n     pub unsafe fn LLVMConstNUWSub(LHSConstant: ValueRef,\n-                              RHSConstant: ValueRef)\n-                           -> ValueRef;\n+                                  RHSConstant: ValueRef)\n+                               -> ValueRef;\n     pub unsafe fn LLVMConstFSub(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n@@ -1331,11 +1336,11 @@ pub fn associate_type(tn: type_names, s: @str, t: TypeRef) {\n }\n \n pub fn type_has_name(tn: type_names, t: TypeRef) -> Option<@str> {\n-    return tn.type_names.find(t);\n+    return tn.type_names.find(&t);\n }\n \n pub fn name_has_type(tn: type_names, s: @str) -> Option<TypeRef> {\n-    return tn.named_types.find(s);\n+    return tn.named_types.find(&s);\n }\n \n pub fn mk_type_names() -> type_names {"}, {"sha": "1faf8e13fda5562a10f2e3bff328ef2615d5e7f9", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -74,7 +74,7 @@ pub fn mk_cstore(intr: @ident_interner) -> CStore {\n \n pub fn get_crate_data(cstore: CStore, cnum: ast::crate_num)\n                    -> crate_metadata {\n-    return p(cstore).metas.get(cnum);\n+    return p(cstore).metas.get(&cnum);\n }\n \n pub fn get_crate_hash(cstore: CStore, cnum: ast::crate_num) -> ~str {\n@@ -139,7 +139,7 @@ pub fn add_use_stmt_cnum(cstore: CStore, use_id: ast::node_id,\n \n pub fn find_use_stmt_cnum(cstore: CStore,\n                           use_id: ast::node_id) -> Option<ast::crate_num> {\n-    p(cstore).use_crate_map.find(use_id)\n+    p(cstore).use_crate_map.find(&use_id)\n }\n \n // returns hashes of crates directly used by this crate. Hashes are"}, {"sha": "67498ad5aafe6425babdac100d3b1202bbdac88f", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -586,10 +586,8 @@ pub fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                                 item, tcx, cdata);\n         let name = item_name(intr, item);\n         let arg_tys = match ty::get(ctor_ty).sty {\n-          ty::ty_fn(ref f) => (*f).sig.inputs.map(|a| a.ty),\n-\n-          // Nullary enum variant.\n-          _ => ~[],\n+          ty::ty_bare_fn(ref f) => f.sig.inputs.map(|a| a.ty),\n+          _ => ~[], // Nullary enum variant.\n         };\n         match variant_disr_val(item) {\n           Some(val) => { disr_val = val; }\n@@ -705,11 +703,12 @@ pub fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n         let ty = doc_type(mth, tcx, cdata);\n         let def_id = item_def_id(mth, cdata);\n         let fty = match ty::get(ty).sty {\n-          ty::ty_fn(ref f) => (/*bad*/copy *f),\n-          _ => {\n-            tcx.diag.handler().bug(\n-                ~\"get_trait_methods: id has non-function type\");\n-        } };\n+            ty::ty_bare_fn(ref f) => copy *f,\n+            _ => {\n+                tcx.diag.handler().bug(\n+                    ~\"get_trait_methods: id has non-function type\");\n+            }\n+        };\n         let self_ty = get_self_ty(mth);\n         result.push({ident: name, tps: bounds, fty: fty, self_ty: self_ty,\n                      vis: ast::public, def_id: def_id});\n@@ -734,14 +733,13 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: cmd,\n         let name = item_name(intr, mth);\n         let ty = doc_type(mth, tcx, cdata);\n \n-        let fty;\n-        match ty::get(ty).sty {\n-            ty::ty_fn(ref f) => fty = (/*bad*/copy *f),\n+        let fty = match ty::get(ty).sty {\n+            ty::ty_bare_fn(ref f) => copy *f,\n             _ => {\n                 tcx.diag.handler().bug(~\"get_provided_trait_methods(): id \\\n                                          has non-function type\");\n             }\n-        }\n+        };\n \n         let self_ty = get_self_ty(mth);\n         let ty_method = {ident: name, tps: bounds, fty: fty, self_ty: self_ty,\n@@ -1099,7 +1097,7 @@ pub fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n         return ast::def_id { crate: cdata.cnum, node: did.node };\n     }\n \n-    match cdata.cnum_map.find(did.crate) {\n+    match cdata.cnum_map.find(&did.crate) {\n       option::Some(n) => ast::def_id { crate: n, node: did.node },\n       option::None => die!(~\"didn't find a crate in the cnum_map\")\n     }"}, {"sha": "b0a424447b35ec78eed00e9182178d13fc813ea9", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -118,7 +118,7 @@ pub fn encode_def_id(ebml_w: writer::Encoder, id: def_id) {\n \n fn encode_region_param(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                        it: @ast::item) {\n-    let opt_rp = ecx.tcx.region_paramd_items.find(it.id);\n+    let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n     for opt_rp.each |rp| {\n         do ebml_w.wr_tag(tag_region_param) {\n             (*rp).encode(&ebml_w);\n@@ -184,7 +184,7 @@ fn encode_ty_type_param_bounds(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n fn encode_type_param_bounds(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n                             params: &[ty_param]) {\n     let ty_param_bounds =\n-        @params.map(|param| ecx.tcx.ty_param_bounds.get(param.id));\n+        @params.map(|param| ecx.tcx.ty_param_bounds.get(&param.id));\n     encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n }\n \n@@ -224,7 +224,7 @@ fn encode_type(ecx: @encode_ctxt, ebml_w: writer::Encoder, typ: ty::t) {\n \n fn encode_symbol(ecx: @encode_ctxt, ebml_w: writer::Encoder, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    let sym = match ecx.item_symbols.find(id) {\n+    let sym = match ecx.item_symbols.find(&id) {\n       Some(ref x) => (/*bad*/copy *x),\n       None => {\n         ecx.diag.handler().bug(\n@@ -238,7 +238,7 @@ fn encode_symbol(ecx: @encode_ctxt, ebml_w: writer::Encoder, id: node_id) {\n fn encode_discriminant(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                        id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n-    ebml_w.writer.write(str::to_bytes(ecx.discrim_symbols.get(id)));\n+    ebml_w.writer.write(str::to_bytes(ecx.discrim_symbols.get(&id)));\n     ebml_w.end_tag();\n }\n \n@@ -349,7 +349,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n \n     // Encode the reexports of this module.\n     debug!(\"(encoding info for module) encoding reexports for %d\", id);\n-    match ecx.reexports2.find(id) {\n+    match ecx.reexports2.find(&id) {\n         Some(ref exports) => {\n             debug!(\"(encoding info for module) found reexports for %d\", id);\n             for (*exports).each |exp| {\n@@ -768,8 +768,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                 encode_name(ecx, ebml_w, mty.ident);\n                 encode_type_param_bounds(ebml_w, ecx,\n                                          (*ty_m).tps);\n-                encode_type(ecx, ebml_w, ty::mk_fn(tcx, /*bad*/copy mty.fty));\n-                encode_family(ebml_w, purity_fn_family(mty.fty.meta.purity));\n+                encode_type(ecx, ebml_w,\n+                            ty::mk_bare_fn(tcx, copy mty.fty));\n+                encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n                 encode_method_sort(ebml_w, 'r');\n                 ebml_w.end_tag();\n@@ -781,8 +782,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                 encode_def_id(ebml_w, local_def(m.id));\n                 encode_name(ecx, ebml_w, mty.ident);\n                 encode_type_param_bounds(ebml_w, ecx, m.tps);\n-                encode_type(ecx, ebml_w, ty::mk_fn(tcx, /*bad*/copy mty.fty));\n-                encode_family(ebml_w, purity_fn_family(mty.fty.meta.purity));\n+                encode_type(ecx, ebml_w,\n+                            ty::mk_bare_fn(tcx, copy mty.fty));\n+                encode_family(ebml_w, purity_fn_family(mty.fty.purity));\n                 encode_self_type(ebml_w, mty.self_ty);\n                 encode_method_sort(ebml_w, 'p');\n                 ebml_w.end_tag();\n@@ -813,7 +815,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             encode_name(ecx, ebml_w, ty_m.ident);\n             encode_family(ebml_w,\n                           purity_static_method_family(ty_m.purity));\n-            let polyty = ecx.tcx.tcache.get(local_def(ty_m.id));\n+            let polyty = ecx.tcx.tcache.get(&local_def(ty_m.id));\n             encode_ty_type_param_bounds(ebml_w, ecx, polyty.bounds);\n             encode_type(ecx, ebml_w, polyty.ty);\n             let mut m_path = vec::append(~[], path); // :-(\n@@ -881,7 +883,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             let ebml_w = copy ebml_w;\n             |i, cx, v| {\n                 visit::visit_item(i, cx, v);\n-                match ecx.tcx.items.get(i.id) {\n+                match ecx.tcx.items.get(&i.id) {\n                     ast_map::node_item(_, pt) => {\n                         encode_info_for_item(ecx, ebml_w, i,\n                                              index, *pt);\n@@ -894,7 +896,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n             let ebml_w = copy ebml_w;\n             |ni, cx, v| {\n                 visit::visit_foreign_item(ni, cx, v);\n-                match ecx.tcx.items.get(ni.id) {\n+                match ecx.tcx.items.get(&ni.id) {\n                     ast_map::node_foreign_item(_, abi, pt) => {\n                         encode_info_for_foreign_item(ecx, ebml_w, ni,\n                                                      index, /*bad*/copy *pt,"}, {"sha": "3f989339e275e2dd05ab8c7e35f7022152dc022f", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 49, "deletions": 32, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -17,8 +17,6 @@\n use core::prelude::*;\n \n use middle::ty;\n-use middle::ty::{FnTyBase, FnMeta, FnSig, arg, creader_cache_key, field};\n-use middle::ty::{substs};\n \n use core::io;\n use core::str;\n@@ -124,17 +122,12 @@ fn parse_path(st: @pstate) -> @ast::path {\n     };\n }\n \n-fn parse_ty_rust_fn(st: @pstate, conv: conv_did) -> ty::t {\n-    return ty::mk_fn(st.tcx, parse_ty_fn(st, conv));\n-}\n-\n-fn parse_proto(st: @pstate) -> ast::Proto {\n+fn parse_sigil(st: @pstate) -> ast::Sigil {\n     match next(st) {\n-        '_' => ast::ProtoBare,\n-        '@' => ast::ProtoBox,\n-        '~' => ast::ProtoUniq,\n-        '&' => ast::ProtoBorrowed,\n-        _ => die!(~\"parse_proto(): bad input\")\n+        '@' => ast::ManagedSigil,\n+        '~' => ast::OwnedSigil,\n+        '&' => ast::BorrowedSigil,\n+        c => st.tcx.sess.bug(fmt!(\"parse_sigil(): bad input '%c'\", c))\n     }\n }\n \n@@ -152,7 +145,7 @@ fn parse_vstore(st: @pstate) -> ty::vstore {\n       '~' => ty::vstore_uniq,\n       '@' => ty::vstore_box,\n       '&' => ty::vstore_slice(parse_region(st)),\n-      _ => die!(~\"parse_vstore: bad input\")\n+      c => st.tcx.sess.bug(fmt!(\"parse_vstore(): bad input '%c'\", c))\n     }\n }\n \n@@ -166,7 +159,7 @@ fn parse_substs(st: @pstate, conv: conv_did) -> ty::substs {\n     while peek(st) != ']' { params.push(parse_ty(st, conv)); }\n     st.pos = st.pos + 1u;\n \n-    return substs {\n+    return ty::substs {\n         self_r: self_r,\n         self_ty: self_ty,\n         tps: params\n@@ -316,20 +309,25 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         return ty::mk_tup(st.tcx, params);\n       }\n       'f' => {\n-        parse_ty_rust_fn(st, conv)\n+        return ty::mk_closure(st.tcx, parse_closure_ty(st, conv));\n+      }\n+      'F' => {\n+        return ty::mk_bare_fn(st.tcx, parse_bare_fn_ty(st, conv));\n       }\n       'Y' => return ty::mk_type(st.tcx),\n       'C' => {\n-        let proto = parse_proto(st);\n-        return ty::mk_opaque_closure_ptr(st.tcx, proto);\n+        let sigil = parse_sigil(st);\n+        return ty::mk_opaque_closure_ptr(st.tcx, sigil);\n       }\n       '#' => {\n         let pos = parse_hex(st);\n         assert (next(st) == ':');\n         let len = parse_hex(st);\n         assert (next(st) == '#');\n-        let key = creader_cache_key { cnum: st.crate, pos: pos, len: len };\n-        match st.tcx.rcache.find(key) {\n+        let key = ty::creader_cache_key {cnum: st.crate,\n+                                         pos: pos,\n+                                         len: len };\n+        match st.tcx.rcache.find(&key) {\n           Some(tt) => return tt,\n           None => {\n             let ps = @{pos: pos ,.. copy *st};\n@@ -408,6 +406,13 @@ fn parse_purity(c: char) -> purity {\n     }\n }\n \n+fn parse_abi(c: char) -> Abi {\n+    match c {\n+      'r' => ast::RustAbi,\n+      _ => die!(fmt!(\"parse_abi: bad ABI '%c'\", c))\n+    }\n+}\n+\n fn parse_onceness(c: char) -> ast::Onceness {\n     match c {\n         'o' => ast::Once,\n@@ -430,12 +435,33 @@ fn parse_mode(st: @pstate) -> ast::mode {\n     return m;\n }\n \n-fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::FnTy {\n-    let proto = parse_proto(st);\n+fn parse_closure_ty(st: @pstate, conv: conv_did) -> ty::ClosureTy {\n+    let sigil = parse_sigil(st);\n     let purity = parse_purity(next(st));\n     let onceness = parse_onceness(next(st));\n     let region = parse_region(st);\n-    let bounds = parse_bounds(st, conv);\n+    let sig = parse_sig(st, conv);\n+    ty::ClosureTy {\n+        purity: purity,\n+        sigil: sigil,\n+        onceness: onceness,\n+        region: region,\n+        sig: sig\n+    }\n+}\n+\n+fn parse_bare_fn_ty(st: @pstate, conv: conv_did) -> ty::BareFnTy {\n+    let purity = parse_purity(next(st));\n+    let abi = parse_abi(next(st));\n+    let sig = parse_sig(st, conv);\n+    ty::BareFnTy {\n+        purity: purity,\n+        abi: abi,\n+        sig: sig\n+    }\n+}\n+\n+fn parse_sig(st: @pstate, conv: conv_did) -> ty::FnSig {\n     assert (next(st) == '[');\n     let mut inputs: ~[ty::arg] = ~[];\n     while peek(st) != ']' {\n@@ -444,18 +470,9 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::FnTy {\n     }\n     st.pos += 1u; // eat the ']'\n     let ret_ty = parse_ty(st, conv);\n-    return FnTyBase {\n-        meta: FnMeta {purity: purity,\n-                      proto: proto,\n-                      onceness: onceness,\n-                      bounds: bounds,\n-                      region: region},\n-        sig: FnSig {inputs: inputs,\n-                    output: ret_ty}\n-    };\n+    ty::FnSig {inputs: inputs, output: ret_ty}\n }\n \n-\n // Rust metadata parsing\n pub fn parse_def_id(buf: &[u8]) -> ast::def_id {\n     let mut colon_idx = 0u;"}, {"sha": "a87ce02d5a30ae7d19f6458608455b08be839c2d", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -56,7 +56,7 @@ fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n pub fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n-        let result_str = match cx.tcx.short_names_cache.find(t) {\n+        let result_str = match cx.tcx.short_names_cache.find(&t) {\n             Some(s) => /*bad*/copy *s,\n             None => {\n                 let s = do io::with_str_writer |wr| {\n@@ -69,7 +69,7 @@ pub fn enc_ty(w: io::Writer, cx: @ctxt, t: ty::t) {\n         w.write_str(result_str);\n       }\n       ac_use_abbrevs(abbrevs) => {\n-        match abbrevs.find(t) {\n+        match abbrevs.find(&t) {\n           Some(a) => { w.write_str(*a.s); return; }\n           None => {\n             let pos = w.tell();\n@@ -288,8 +288,13 @@ fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n         }\n         w.write_char(']');\n       }\n-      ty::ty_fn(ref f) => {\n-        enc_ty_fn(w, cx, (*f));\n+      ty::ty_closure(ref f) => {\n+        w.write_char('f');\n+        enc_closure_ty(w, cx, f);\n+      }\n+      ty::ty_bare_fn(ref f) => {\n+        w.write_char('F');\n+        enc_bare_fn_ty(w, cx, f);\n       }\n       ty::ty_infer(_) => {\n         cx.diag.handler().bug(~\"Cannot encode inference variable types\");\n@@ -306,7 +311,7 @@ fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n       ty::ty_type => w.write_char('Y'),\n       ty::ty_opaque_closure_ptr(p) => {\n           w.write_str(&\"C&\");\n-          enc_proto(w, p);\n+          enc_sigil(w, p);\n       }\n       ty::ty_opaque_box => w.write_char('B'),\n       ty::ty_struct(def, ref substs) => {\n@@ -325,13 +330,11 @@ fn enc_sty(w: io::Writer, cx: @ctxt, +st: ty::sty) {\n     }\n }\n \n-fn enc_proto(w: io::Writer, proto: Proto) {\n-    w.write_str(&\"f\");\n-    match proto {\n-        ProtoBare => w.write_str(&\"_\"),\n-        ProtoBox => w.write_str(&\"@\"),\n-        ProtoUniq => w.write_str(&\"~\"),\n-        ProtoBorrowed => w.write_str(&\"&\"),\n+fn enc_sigil(w: io::Writer, sigil: Sigil) {\n+    match sigil {\n+        ManagedSigil => w.write_str(\"@\"),\n+        OwnedSigil => w.write_str(\"~\"),\n+        BorrowedSigil => w.write_str(\"&\"),\n     }\n }\n \n@@ -357,25 +360,40 @@ fn enc_purity(w: io::Writer, p: purity) {\n     }\n }\n \n+fn enc_abi(w: io::Writer, a: Abi) {\n+    match a {\n+        RustAbi => w.write_char('r'),\n+    }\n+}\n+\n fn enc_onceness(w: io::Writer, o: Onceness) {\n     match o {\n         Once => w.write_char('o'),\n         Many => w.write_char('m')\n     }\n }\n \n-fn enc_ty_fn(w: io::Writer, cx: @ctxt, ft: ty::FnTy) {\n-    enc_proto(w, ft.meta.proto);\n-    enc_purity(w, ft.meta.purity);\n-    enc_onceness(w, ft.meta.onceness);\n-    enc_region(w, cx, ft.meta.region);\n-    enc_bounds(w, cx, ft.meta.bounds);\n+fn enc_bare_fn_ty(w: io::Writer, cx: @ctxt, ft: &ty::BareFnTy) {\n+    enc_purity(w, ft.purity);\n+    enc_abi(w, ft.abi);\n+    enc_fn_sig(w, cx, &ft.sig);\n+}\n+\n+fn enc_closure_ty(w: io::Writer, cx: @ctxt, ft: &ty::ClosureTy) {\n+    enc_sigil(w, ft.sigil);\n+    enc_purity(w, ft.purity);\n+    enc_onceness(w, ft.onceness);\n+    enc_region(w, cx, ft.region);\n+    enc_fn_sig(w, cx, &ft.sig);\n+}\n+\n+fn enc_fn_sig(w: io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n     w.write_char('[');\n-    for ft.sig.inputs.each |arg| {\n+    for fsig.inputs.each |arg| {\n         enc_arg(w, cx, *arg);\n     }\n     w.write_char(']');\n-    enc_ty(w, cx, ft.sig.output);\n+    enc_ty(w, cx, fsig.output);\n }\n \n pub fn enc_bounds(w: io::Writer, cx: @ctxt, bs: @~[ty::param_bound]) {"}, {"sha": "71599463382963242f659176ab65fa9ec9bbf137", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -838,7 +838,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n \n     debug!(\"Encoding side tables for id %d\", id);\n \n-    do option::iter(&tcx.def_map.find(id)) |def| {\n+    do option::iter(&tcx.def_map.find(&id)) |def| {\n         do ebml_w.tag(c::tag_table_def) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -855,7 +855,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&tcx.node_type_substs.find(id)) |tys| {\n+    do option::iter(&tcx.node_type_substs.find(&id)) |tys| {\n         do ebml_w.tag(c::tag_table_node_type_subst) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -864,7 +864,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&tcx.freevars.find(id)) |fv| {\n+    do option::iter(&tcx.freevars.find(&id)) |fv| {\n         do ebml_w.tag(c::tag_table_freevars) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -876,7 +876,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     }\n \n     let lid = ast::def_id { crate: ast::local_crate, node: id };\n-    do option::iter(&tcx.tcache.find(lid)) |tpbt| {\n+    do option::iter(&tcx.tcache.find(&lid)) |tpbt| {\n         do ebml_w.tag(c::tag_table_tcache) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -885,7 +885,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&tcx.ty_param_bounds.find(id)) |pbs| {\n+    do option::iter(&tcx.ty_param_bounds.find(&id)) |pbs| {\n         do ebml_w.tag(c::tag_table_param_bounds) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -899,7 +899,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     // is what we actually use in trans, all modes will have been\n     // resolved.\n     //\n-    //option::iter(tcx.inferred_modes.find(id)) {|m|\n+    //option::iter(tcx.inferred_modes.find(&id)) {|m|\n     //    ebml_w.tag(c::tag_table_inferred_modes) {||\n     //        ebml_w.id(id);\n     //        ebml_w.tag(c::tag_table_val) {||\n@@ -908,13 +908,13 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n     //    }\n     //}\n \n-    do option::iter(&maps.mutbl_map.find(id)) |_m| {\n+    do option::iter(&maps.mutbl_map.find(&id)) |_m| {\n         do ebml_w.tag(c::tag_table_mutbl) {\n             ebml_w.id(id);\n         }\n     }\n \n-    do option::iter(&maps.last_use_map.find(id)) |m| {\n+    do option::iter(&maps.last_use_map.find(&id)) |m| {\n         do ebml_w.tag(c::tag_table_last_use) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -925,7 +925,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&maps.method_map.find(id)) |mme| {\n+    do option::iter(&maps.method_map.find(&id)) |mme| {\n         do ebml_w.tag(c::tag_table_method_map) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -934,7 +934,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&maps.vtable_map.find(id)) |dr| {\n+    do option::iter(&maps.vtable_map.find(&id)) |dr| {\n         do ebml_w.tag(c::tag_table_vtable_map) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -943,7 +943,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&tcx.adjustments.find(id)) |adj| {\n+    do option::iter(&tcx.adjustments.find(&id)) |adj| {\n         do ebml_w.tag(c::tag_table_adjustments) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n@@ -952,19 +952,19 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         }\n     }\n \n-    do option::iter(&tcx.legacy_boxed_traits.find(id)) |_x| {\n+    do option::iter(&tcx.legacy_boxed_traits.find(&id)) |_x| {\n         do ebml_w.tag(c::tag_table_legacy_boxed_trait) {\n             ebml_w.id(id);\n         }\n     }\n \n-    for maps.moves_map.find(id).each |_| {\n+    for maps.moves_map.find(&id).each |_| {\n         do ebml_w.tag(c::tag_table_moves_map) {\n             ebml_w.id(id);\n         }\n     }\n \n-    for maps.capture_map.find(id).each |cap_vars| {\n+    for maps.capture_map.find(&id).each |cap_vars| {\n         do ebml_w.tag(c::tag_table_capture_map) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {"}, {"sha": "dfc26000116a6e1dd2243ac0258351a3bd013ae9", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 47, "deletions": 33, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -126,12 +126,12 @@ impl check_loan_ctxt {\n         let region_map = self.tcx().region_map;\n         let pure_map = self.req_maps.pure_map;\n         loop {\n-            match pure_map.find(scope_id) {\n+            match pure_map.find(&scope_id) {\n               None => (),\n               Some(ref e) => return Some(pc_cmt((*e)))\n             }\n \n-            match region_map.find(scope_id) {\n+            match region_map.find(&scope_id) {\n               None => return default_purity,\n               Some(next_scope_id) => scope_id = next_scope_id\n             }\n@@ -144,13 +144,13 @@ impl check_loan_ctxt {\n         let req_loan_map = self.req_maps.req_loan_map;\n \n         loop {\n-            for req_loan_map.find(scope_id).each |loans| {\n+            for req_loan_map.find(&scope_id).each |loans| {\n                 for loans.each |loan| {\n                     if !f(loan) { return; }\n                 }\n             }\n \n-            match region_map.find(scope_id) {\n+            match region_map.find(&scope_id) {\n               None => return,\n               Some(next_scope_id) => scope_id = next_scope_id,\n             }\n@@ -199,7 +199,7 @@ impl check_loan_ctxt {\n           Some(expr) => {\n             match expr.node {\n               ast::expr_path(_) if pc == pc_pure_fn => {\n-                let def = self.tcx().def_map.get(expr.id);\n+                let def = self.tcx().def_map.get(&expr.id);\n                 let did = ast_util::def_id_of_def(def);\n                 let is_fn_arg =\n                     did.crate == ast::local_crate &&\n@@ -221,33 +221,37 @@ impl check_loan_ctxt {\n \n         let callee_ty = ty::node_id_to_type(tcx, callee_id);\n         match ty::get(callee_ty).sty {\n-          ty::ty_fn(ref fn_ty) => {\n-            match fn_ty.meta.purity {\n-              ast::pure_fn => return, // case (c) above\n-              ast::impure_fn | ast::unsafe_fn | ast::extern_fn => {\n-                self.report_purity_error(\n-                    pc, callee_span,\n-                    fmt!(\"access to %s function\",\n-                         fn_ty.meta.purity.to_str()));\n-              }\n+            ty::ty_bare_fn(ty::BareFnTy {purity: purity, _}) |\n+            ty::ty_closure(ty::ClosureTy {purity: purity, _}) => {\n+                match purity {\n+                    ast::pure_fn => return, // case (c) above\n+                    ast::impure_fn | ast::unsafe_fn | ast::extern_fn => {\n+                        self.report_purity_error(\n+                            pc, callee_span,\n+                            fmt!(\"access to %s function\",\n+                                 purity.to_str()));\n+                    }\n+                }\n             }\n-          }\n-          _ => return, // case (d) above\n+            _ => return, // case (d) above\n         }\n     }\n \n     // True if the expression with the given `id` is a stack closure.\n     // The expression must be an expr_fn(*) or expr_fn_block(*)\n     fn is_stack_closure(id: ast::node_id) -> bool {\n         let fn_ty = ty::node_id_to_type(self.tcx(), id);\n-        let proto = ty::ty_fn_proto(fn_ty);\n-        return proto == ast::ProtoBorrowed;\n+        match ty::get(fn_ty).sty {\n+            ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n+                                          _}) => true,\n+            _ => false\n+        }\n     }\n \n     fn is_allowed_pure_arg(expr: @ast::expr) -> bool {\n         return match expr.node {\n           ast::expr_path(_) => {\n-            let def = self.tcx().def_map.get(expr.id);\n+            let def = self.tcx().def_map.get(&expr.id);\n             let did = ast_util::def_id_of_def(def);\n             did.crate == ast::local_crate &&\n                 (*self.fn_args).contains(&(did.node))\n@@ -262,14 +266,14 @@ impl check_loan_ctxt {\n     fn check_for_conflicting_loans(scope_id: ast::node_id) {\n         debug!(\"check_for_conflicting_loans(scope_id=%?)\", scope_id);\n \n-        let new_loans = match self.req_maps.req_loan_map.find(scope_id) {\n+        let new_loans = match self.req_maps.req_loan_map.find(&scope_id) {\n             None => return,\n             Some(loans) => loans\n         };\n \n         debug!(\"new_loans has length %?\", new_loans.len());\n \n-        let par_scope_id = self.tcx().region_map.get(scope_id);\n+        let par_scope_id = self.tcx().region_map.get(&scope_id);\n         for self.walk_loans(par_scope_id) |old_loan| {\n             debug!(\"old_loan=%?\", self.bccx.loan_to_repr(old_loan));\n \n@@ -325,7 +329,7 @@ impl check_loan_ctxt {\n     fn check_assignment(at: assignment_type, ex: @ast::expr) {\n         // We don't use cat_expr() here because we don't want to treat\n         // auto-ref'd parameters in overloaded operators as rvalues.\n-        let cmt = match self.bccx.tcx.adjustments.find(ex.id) {\n+        let cmt = match self.bccx.tcx.adjustments.find(&ex.id) {\n             None => self.bccx.cat_expr_unadjusted(ex),\n             Some(adj) => self.bccx.cat_expr_autoderefd(ex, adj)\n         };\n@@ -564,17 +568,27 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n {\n     let is_stack_closure = self.is_stack_closure(id);\n     let fty = ty::node_id_to_type(self.tcx(), id);\n-    let fty_proto = ty::ty_fn_proto(fty);\n \n-    check_moves_from_captured_variables(self, id, fty_proto);\n+    let declared_purity;\n+    match fk {\n+        visit::fk_item_fn(*) | visit::fk_method(*) |\n+        visit::fk_dtor(*) => {\n+            declared_purity = ty::ty_fn_purity(fty);\n+        }\n+\n+        visit::fk_anon(*) | visit::fk_fn_block(*) => {\n+            let fty_sigil = ty::ty_closure_sigil(fty);\n+            check_moves_from_captured_variables(self, id, fty_sigil);\n+            declared_purity = ty::determine_inherited_purity(\n+                copy self.declared_purity, ty::ty_fn_purity(fty),\n+                fty_sigil);\n+        }\n+    }\n \n     debug!(\"purity on entry=%?\", copy self.declared_purity);\n     do save_and_restore(&mut(self.declared_purity)) {\n         do save_and_restore(&mut(self.fn_args)) {\n-            self.declared_purity = ty::determine_inherited_purity(\n-                copy self.declared_purity,\n-                ty::ty_fn_purity(fty),\n-                fty_proto);\n+            self.declared_purity = declared_purity;\n \n             match fk {\n                 visit::fk_anon(*) |\n@@ -608,11 +622,11 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n \n     fn check_moves_from_captured_variables(&&self: check_loan_ctxt,\n                                            id: ast::node_id,\n-                                           fty_proto: ast::Proto)\n+                                           fty_sigil: ast::Sigil)\n     {\n-        match fty_proto {\n-            ast::ProtoBox | ast::ProtoUniq => {\n-                let cap_vars = self.bccx.capture_map.get(id);\n+        match fty_sigil {\n+            ast::ManagedSigil | ast::OwnedSigil => {\n+                let cap_vars = self.bccx.capture_map.get(&id);\n                 for cap_vars.each |cap_var| {\n                     match cap_var.mode {\n                         moves::CapRef | moves::CapCopy => { loop; }\n@@ -646,7 +660,7 @@ fn check_loans_in_fn(fk: visit::fn_kind, decl: ast::fn_decl, body: ast::blk,\n                 }\n             }\n \n-            ast::ProtoBorrowed | ast::ProtoBare => {}\n+            ast::BorrowedSigil => {}\n         }\n     }\n }"}, {"sha": "8029b4c27139401f30057e359fced1100e8c0226", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -126,7 +126,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n \n     // If this expression is borrowed, have to ensure it remains valid:\n     if !self.ignore_adjustments.contains(&ex.id) {\n-        for tcx.adjustments.find(ex.id).each |adjustments| {\n+        for tcx.adjustments.find(&ex.id).each |adjustments| {\n             self.guarantee_adjustments(ex, *adjustments);\n         }\n     }\n@@ -172,7 +172,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n             }\n         }\n \n-        match self.bccx.method_map.find(ex.id) {\n+        match self.bccx.method_map.find(&ex.id) {\n             Some(ref method_map_entry) => {\n                 match (*method_map_entry).explicit_self {\n                     ast::sty_by_ref => {\n@@ -250,7 +250,7 @@ fn req_loans_in_expr(ex: @ast::expr,\n         // (if used like `a.b(...)`), the call where it's an argument\n         // (if used like `x(a.b)`), or the block (if used like `let x\n         // = a.b`).\n-        let scope_r = ty::re_scope(self.tcx().region_map.get(ex.id));\n+        let scope_r = ty::re_scope(self.tcx().region_map.get(&ex.id));\n         let rcvr_cmt = self.bccx.cat_expr(rcvr);\n         self.guarantee_valid(rcvr_cmt, m_imm, scope_r);\n         visit::visit_expr(ex, self, vt);\n@@ -536,7 +536,7 @@ impl gather_loan_ctxt {\n \n     fn add_loans_to_scope_id(&self, scope_id: ast::node_id, +loans: ~[Loan]) {\n         debug!(\"adding %u loans to scope_id %?\", loans.len(), scope_id);\n-        match self.req_maps.req_loan_map.find(scope_id) {\n+        match self.req_maps.req_loan_map.find(&scope_id) {\n             Some(req_loans) => {\n                 req_loans.push_all(loans);\n             }"}, {"sha": "7248d29aa0418e0b43eefe2f5aafdfc5e46094e7", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -129,7 +129,7 @@ impl LoanContext {\n                 ~\"rvalue with a non-none lp\");\n           }\n           cat_local(local_id) | cat_arg(local_id) | cat_self(local_id) => {\n-            let local_scope_id = self.tcx().region_map.get(local_id);\n+            let local_scope_id = self.tcx().region_map.get(&local_id);\n             self.issue_loan(cmt, ty::re_scope(local_scope_id), req_mutbl,\n                             owns_lent_data)\n           }"}, {"sha": "1946ba09ec7bfadacb49b4f33f9512b373f9546e", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -109,7 +109,7 @@ impl PreserveCtxt {\n                 // Maybe if we pass in the parent instead here,\n                 // we can prevent the \"scope not found\" error\n                 debug!(\"scope_region thing: %? \", cmt.id);\n-                ty::re_scope(self.tcx().region_map.get(cmt.id))\n+                ty::re_scope(self.tcx().region_map.get(&cmt.id))\n             };\n \n             self.compare_scope(cmt, scope_region)\n@@ -129,26 +129,26 @@ impl PreserveCtxt {\n                     cmt.span,\n                     ~\"preserve() called with local and !root_managed_data\");\n             }\n-            let local_scope_id = self.tcx().region_map.get(local_id);\n+            let local_scope_id = self.tcx().region_map.get(&local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n           cat_binding(local_id) => {\n             // Bindings are these kind of weird implicit pointers (cc\n             // #2329).  We require (in gather_loans) that they be\n             // rooted in an immutable location.\n-            let local_scope_id = self.tcx().region_map.get(local_id);\n+            let local_scope_id = self.tcx().region_map.get(&local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n           cat_arg(local_id) => {\n             // This can happen as not all args are lendable (e.g., &&\n             // modes).  In that case, the caller guarantees stability\n             // for at least the scope of the fn.  This is basically a\n             // deref of a region ptr.\n-            let local_scope_id = self.tcx().region_map.get(local_id);\n+            let local_scope_id = self.tcx().region_map.get(&local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n           cat_self(local_id) => {\n-            let local_scope_id = self.tcx().region_map.get(local_id);\n+            let local_scope_id = self.tcx().region_map.get(&local_id);\n             self.compare_scope(cmt, ty::re_scope(local_scope_id))\n           }\n           cat_comp(cmt_base, comp_field(*)) |"}, {"sha": "ad46d3b6f4de07e56d125c88460aab56e9346052", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -126,7 +126,7 @@ pub fn check_expr(sess: Session,\n                     e.span, ~\"paths in constants may only refer to \\\n                               items without type parameters\");\n             }\n-            match def_map.find(e.id) {\n+            match def_map.find(&e.id) {\n               Some(def_const(def_id)) |\n                 Some(def_fn(def_id, _)) |\n                 Some(def_variant(_, def_id)) |\n@@ -150,8 +150,8 @@ pub fn check_expr(sess: Session,\n               }\n             }\n           }\n-          expr_call(callee, _, false) => {\n-            match def_map.find(callee.id) {\n+          expr_call(callee, _, NoSugar) => {\n+            match def_map.find(&callee.id) {\n                 Some(def_struct(*)) => {}    // OK.\n                 Some(def_variant(*)) => {}    // OK.\n                 _ => {\n@@ -247,9 +247,9 @@ pub fn check_item_recursion(sess: Session,\n     fn visit_expr(e: @expr, &&env: env, v: visit::vt<env>) {\n         match e.node {\n           expr_path(*) => {\n-            match env.def_map.find(e.id) {\n+            match env.def_map.find(&e.id) {\n               Some(def_const(def_id)) => {\n-                match env.ast_map.get(def_id.node) {\n+                match env.ast_map.get(&def_id.node) {\n                   ast_map::node_item(it, _) => {\n                     (v.visit_item)(it, env, v);\n                   }"}, {"sha": "38450de6b540cabf4041571ea516bb81be1acb20", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -39,8 +39,8 @@ pub fn check_crate(tcx: ty::ctxt, crate: @crate) {\n                 (v.visit_block)((*b), {in_loop: false, can_ret: false}, v);\n               }\n               expr_loop_body(@expr {node: expr_fn_block(_, ref b), _}) => {\n-                let proto = ty::ty_fn_proto(ty::expr_ty(tcx, e));\n-                let blk = (proto == ProtoBorrowed);\n+                let sigil = ty::ty_closure_sigil(ty::expr_ty(tcx, e));\n+                let blk = (sigil == BorrowedSigil);\n                 (v.visit_block)((*b), {in_loop: true, can_ret: blk}, v);\n               }\n               expr_break(_) => {"}, {"sha": "6f9fe1edca5beed25cbde536ca611ffeecb4b1d3", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -100,7 +100,7 @@ pub fn check_expr(cx: @MatchCheckCtxt, ex: @expr, &&s: (), v: visit::vt<()>) {\n           }\n           _ => { /* We assume only enum types can be uninhabited */ }\n        }\n-       let arms = vec::concat(vec::filter_map((*arms), unguarded_pat));\n+       let arms = vec::concat(arms.filter_mapped(unguarded_pat));\n        check_exhaustive(cx, ex.span, arms);\n      }\n      _ => ()\n@@ -255,7 +255,8 @@ pub fn is_useful(cx: @MatchCheckCtxt, +m: matrix, +v: &[@pat]) -> useful {\n             }\n           }\n           Some(ref ctor) => {\n-            match is_useful(cx, vec::filter_map(m, |r| default(cx, copy *r)),\n+            match is_useful(cx,\n+                            vec::filter_map(m, |r| default(cx, r)),\n                             vec::tail(v)) {\n               useful_ => useful(left_ty, (/*bad*/copy *ctor)),\n               ref u => (/*bad*/copy *u)\n@@ -277,8 +278,7 @@ pub fn is_useful_specialized(cx: @MatchCheckCtxt,\n                              arity: uint,\n                              lty: ty::t)\n                           -> useful {\n-    let ms = vec::filter_map(m, |r| specialize(cx, *r,\n-                                               ctor, arity, lty));\n+    let ms = m.filter_mapped(|r| specialize(cx, *r, ctor, arity, lty));\n     let could_be_useful = is_useful(\n         cx, ms, specialize(cx, v, ctor, arity, lty).get());\n     match could_be_useful {\n@@ -292,7 +292,7 @@ pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n     match /*bad*/copy pat.node {\n       pat_wild => { None }\n       pat_ident(_, _, _) | pat_enum(_, _) => {\n-        match cx.tcx.def_map.find(pat.id) {\n+        match cx.tcx.def_map.find(&pat.id) {\n           Some(def_variant(_, id)) => Some(variant(id)),\n           Some(def_const(did)) => {\n             let const_expr = lookup_const_by_id(cx.tcx, did).get();\n@@ -306,7 +306,7 @@ pub fn pat_ctor_id(cx: @MatchCheckCtxt, p: @pat) -> Option<ctor> {\n         Some(range(eval_const_expr(cx.tcx, lo), eval_const_expr(cx.tcx, hi)))\n       }\n       pat_struct(*) => {\n-        match cx.tcx.def_map.find(pat.id) {\n+        match cx.tcx.def_map.find(&pat.id) {\n           Some(def_variant(_, id)) => Some(variant(id)),\n           _ => Some(single)\n         }\n@@ -329,7 +329,7 @@ pub fn is_wild(cx: @MatchCheckCtxt, p: @pat) -> bool {\n     match pat.node {\n       pat_wild => { true }\n       pat_ident(_, _, _) => {\n-        match cx.tcx.def_map.find(pat.id) {\n+        match cx.tcx.def_map.find(&pat.id) {\n           Some(def_variant(_, _)) | Some(def_const(*)) => { false }\n           _ => { true }\n         }\n@@ -387,9 +387,9 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n       ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n \n         // Find the lengths and tails of all vector patterns.\n-        let vec_pat_lens = do m.filter_map |r| {\n-            match /*bad*/copy r[0].node {\n-                pat_vec(elems, tail) => {\n+        let vec_pat_lens = do m.filter_mapped |r| {\n+            match r[0].node {\n+                pat_vec(ref elems, ref tail) => {\n                     Some((elems.len(), tail.is_some()))\n                 }\n                 _ => None\n@@ -480,7 +480,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             pat_wild => Some(vec::append(vec::from_elem(arity, wild()),\n                                          vec::tail(r))),\n             pat_ident(_, _, _) => {\n-                match cx.tcx.def_map.find(pat_id) {\n+                match cx.tcx.def_map.find(&pat_id) {\n                     Some(def_variant(_, id)) => {\n                         if variant(id) == ctor_id { Some(vec::tail(r)) }\n                         else { None }\n@@ -505,7 +505,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                 }\n             }\n             pat_enum(_, args) => {\n-                match cx.tcx.def_map.get(pat_id) {\n+                match cx.tcx.def_map.get(&pat_id) {\n                     def_variant(_, id) if variant(id) == ctor_id => {\n                         let args = match args {\n                             Some(args) => args,\n@@ -541,7 +541,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n             }\n             pat_struct(_, ref flds, _) => {\n                 // Is this a struct or an enum variant?\n-                match cx.tcx.def_map.get(pat_id) {\n+                match cx.tcx.def_map.get(&pat_id) {\n                     def_variant(_, variant_id) => {\n                         if variant(variant_id) == ctor_id {\n                             // FIXME #4731: Is this right? --pcw\n@@ -678,7 +678,7 @@ pub fn check_fn(cx: @MatchCheckCtxt,\n }\n \n pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n-    match cx.tcx.def_map.find(pat.id) {\n+    match cx.tcx.def_map.find(&pat.id) {\n       Some(def_variant(enum_id, _)) => {\n         if vec::len(*ty::enum_variants(cx.tcx, enum_id)) != 1u {\n             return true;"}, {"sha": "e01595d8d939de3bb2fdf8478e83670687d869f4", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -78,7 +78,7 @@ pub fn classify(e: @expr,\n                 tcx: ty::ctxt)\n              -> constness {\n     let did = ast_util::local_def(e.id);\n-    match tcx.ccache.find(did) {\n+    match tcx.ccache.find(&did) {\n       Some(x) => x,\n       None => {\n         let cn =\n@@ -170,7 +170,7 @@ pub fn classify(e: @expr,\n }\n \n pub fn lookup_const(tcx: ty::ctxt, e: @expr) -> Option<@expr> {\n-    match tcx.def_map.find(e.id) {\n+    match tcx.def_map.find(&e.id) {\n         Some(ast::def_const(def_id)) => lookup_const_by_id(tcx, def_id),\n         _ => None\n     }\n@@ -180,7 +180,7 @@ pub fn lookup_const_by_id(tcx: ty::ctxt,\n                           def_id: ast::def_id)\n                        -> Option<@expr> {\n     if ast_util::is_local(def_id) {\n-        match tcx.items.find(def_id.node) {\n+        match tcx.items.find(&def_id.node) {\n             None => None,\n             Some(ast_map::node_item(it, _)) => match it.node {\n                 item_const(_, const_expr) => Some(const_expr),"}, {"sha": "e609107721048889ed6f19c07a7a986e10e0dc53", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -48,17 +48,15 @@ fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n \n     let walk_expr = fn@(expr: @ast::expr, &&depth: int, v: visit::vt<int>) {\n             match expr.node {\n-              ast::expr_fn(proto, _, _, _) => {\n-                if proto != ast::ProtoBare {\n-                    visit::visit_expr(expr, depth + 1, v);\n-                }\n+              ast::expr_fn(_, _, _, _) => {\n+                visit::visit_expr(expr, depth + 1, v);\n               }\n               ast::expr_fn_block(*) => {\n                 visit::visit_expr(expr, depth + 1, v);\n               }\n               ast::expr_path(*) => {\n                   let mut i = 0;\n-                  match def_map.find(expr.id) {\n+                  match def_map.find(&expr.id) {\n                     None => die!(~\"path not found\"),\n                     Some(df) => {\n                       let mut def = df;\n@@ -118,7 +116,7 @@ pub fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n }\n \n pub fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n-    match tcx.freevars.find(fid) {\n+    match tcx.freevars.find(&fid) {\n       None => die!(~\"get_freevars: \" + int::str(fid) + ~\" has no freevars\"),\n       Some(d) => return d\n     }"}, {"sha": "35d5595fefd43508ff380a46e3074526c37e8362", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 22, "deletions": 46, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -150,11 +150,23 @@ fn with_appropriate_checker(cx: ctx, id: node_id, b: fn(check_fn)) {\n     }\n \n     let fty = ty::node_id_to_type(cx.tcx, id);\n-    match ty::ty_fn_proto(fty) {\n-        ProtoUniq => b(check_for_uniq),\n-        ProtoBox => b(check_for_box),\n-        ProtoBare => b(check_for_bare),\n-        ProtoBorrowed => b(check_for_block),\n+    match ty::get(fty).sty {\n+        ty::ty_closure(ty::ClosureTy {sigil: OwnedSigil, _}) => {\n+            b(check_for_uniq)\n+        }\n+        ty::ty_closure(ty::ClosureTy {sigil: ManagedSigil, _}) => {\n+            b(check_for_box)\n+        }\n+        ty::ty_closure(ty::ClosureTy {sigil: BorrowedSigil, _}) => {\n+            b(check_for_block)\n+        }\n+        ty::ty_bare_fn(_) => {\n+            b(check_for_bare)\n+        }\n+        ref s => {\n+            cx.tcx.sess.bug(\n+                fmt!(\"expect fn type in kind checker, not %?\", s));\n+        }\n     }\n }\n \n@@ -195,10 +207,10 @@ pub fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         expr_unary(*)|expr_binary(*)|expr_method_call(*) => e.callee_id,\n         _ => e.id\n     };\n-    do option::iter(&cx.tcx.node_type_substs.find(type_parameter_id)) |ts| {\n+    do option::iter(&cx.tcx.node_type_substs.find(&type_parameter_id)) |ts| {\n         let bounds = match e.node {\n           expr_path(_) => {\n-            let did = ast_util::def_id_of_def(cx.tcx.def_map.get(e.id));\n+            let did = ast_util::def_id_of_def(cx.tcx.def_map.get(&e.id));\n             ty::lookup_item_type(cx.tcx, did).bounds\n           }\n           _ => {\n@@ -240,42 +252,6 @@ pub fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n                        expr.span,\n                        \"explicit copy requires a copyable argument\");\n         }\n-        expr_rec(ref fields, def) | expr_struct(_, ref fields, def) => {\n-            match def {\n-                Some(ex) => {\n-                    // All noncopyable fields must be overridden\n-                    let t = ty::expr_ty(cx.tcx, ex);\n-                    let ty_fields = match ty::get(t).sty {\n-                        ty::ty_rec(ref f) => {\n-                            copy *f\n-                        }\n-                        ty::ty_struct(did, ref substs) => {\n-                            ty::struct_fields(cx.tcx, did, substs)\n-                        }\n-                        _ => {\n-                            cx.tcx.sess.span_bug(\n-                                ex.span,\n-                                ~\"bad base expr type in record\")\n-                        }\n-                    };\n-                    for ty_fields.each |tf| {\n-                        // If this field would not be copied, ok.\n-                        if fields.any(|f| f.node.ident == tf.ident) { loop; }\n-\n-                        // If this field is copyable, ok.\n-                        let kind = ty::type_kind(cx.tcx, tf.mt.ty);\n-                        if ty::kind_can_be_copied(kind) { loop; }\n-\n-                        cx.tcx.sess.span_err(\n-                            e.span,\n-                            fmt!(\"cannot copy field `%s` of base expression, \\\n-                                  which has a noncopyable type\",\n-                                 *cx.tcx.sess.intr().get(tf.ident)));\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n         expr_repeat(element, count_expr, _) => {\n             let count = ty::eval_repeat_count(cx.tcx, count_expr, e.span);\n             if count > 1 {\n@@ -292,8 +268,8 @@ pub fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n fn check_ty(aty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n     match aty.node {\n       ty_path(_, id) => {\n-        do option::iter(&cx.tcx.node_type_substs.find(id)) |ts| {\n-            let did = ast_util::def_id_of_def(cx.tcx.def_map.get(id));\n+        do option::iter(&cx.tcx.node_type_substs.find(&id)) |ts| {\n+            let did = ast_util::def_id_of_def(cx.tcx.def_map.get(&id));\n             let bounds = ty::lookup_item_type(cx.tcx, did).bounds;\n             for vec::each2(*ts, *bounds) |ty, bound| {\n                 check_bounds(cx, aty.id, aty.span, *ty, *bound)\n@@ -334,7 +310,7 @@ pub fn check_bounds(cx: ctx, id: node_id, sp: span,\n fn is_nullary_variant(cx: ctx, ex: @expr) -> bool {\n     match ex.node {\n       expr_path(_) => {\n-        match cx.tcx.def_map.get(ex.id) {\n+        match cx.tcx.def_map.get(&ex.id) {\n           def_variant(edid, vdid) => {\n             vec::len(ty::enum_variant_with_id(cx.tcx, edid, vdid).args) == 0u\n           }"}, {"sha": "b4500f87eb0b9f402dc2fa545427b5e2da52e900", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -352,7 +352,7 @@ impl LanguageItemCollector {\n             return;    // Didn't match.\n         }\n \n-        match self.item_refs.find(/*bad*/copy value) {\n+        match self.item_refs.find(&value) {\n             None => {\n                 // Didn't match.\n             }"}, {"sha": "51bbdfdc19cc357ba539165e30ff2615b4914813", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -265,7 +265,7 @@ pub fn get_lint_settings_level(settings: lint_settings,\n                                _expr_id: ast::node_id,\n                                item_id: ast::node_id)\n                             -> level {\n-    match settings.settings_map.find(item_id) {\n+    match settings.settings_map.find(&item_id) {\n       Some(modes) => get_lint_level(modes, lint_mode),\n       None => get_lint_level(settings.default_settings, lint_mode)\n     }\n@@ -346,7 +346,7 @@ impl ctxt {\n \n         for triples.each |pair| {\n             let (meta, level, lintname) = /*bad*/copy *pair;\n-            match self.dict.find(/*bad*/ copy lintname) {\n+            match self.dict.find(&lintname) {\n               None => {\n                 self.span_lint(\n                     new_ctxt.get_level(unrecognized_lint),\n@@ -684,7 +684,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n               ast::ty_path(_, id) => {\n-                match cx.def_map.get(id) {\n+                match cx.def_map.get(&id) {\n                   ast::def_prim_ty(ast::ty_int(ast::ty_i)) => {\n                     cx.sess.span_lint(\n                         ctypes, id, fn_id,\n@@ -897,9 +897,10 @@ fn check_fn(tcx: ty::ctxt, fk: visit::fn_kind, decl: ast::fn_decl,\n fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: ast::fn_decl,\n                              span: span, id: ast::node_id) {\n     match ty::get(fn_ty).sty {\n-        ty::ty_fn(ref fn_ty) => {\n+        ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) |\n+        ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) => {\n             let mut counter = 0;\n-            for vec::each2(fn_ty.sig.inputs, decl.inputs) |arg_ty, arg_ast| {\n+            for vec::each2(sig.inputs, decl.inputs) |arg_ty, arg_ast| {\n                 counter += 1;\n                 debug!(\"arg %d, ty=%s, mode=%s\",\n                        counter,\n@@ -938,13 +939,14 @@ fn check_fn_deprecated_modes(tcx: ty::ctxt, fn_ty: ty::t, decl: ast::fn_decl,\n                 }\n \n                 match ty::get(arg_ty.ty).sty {\n-                    ty::ty_fn(*) => {\n+                    ty::ty_closure(*) | ty::ty_bare_fn(*) => {\n                         let span = arg_ast.ty.span;\n                         // Recurse to check fn-type argument\n                         match arg_ast.ty.node {\n-                            ast::ty_fn(f) => {\n+                            ast::ty_closure(@ast::TyClosure{decl: ref d, _}) |\n+                            ast::ty_bare_fn(@ast::TyBareFn{decl: ref d, _})=>{\n                                 check_fn_deprecated_modes(tcx, arg_ty.ty,\n-                                                          f.decl, span, id);\n+                                                          *d, span, id);\n                             }\n                             ast::ty_path(*) => {\n                                 // This is probably a typedef, so we can't\n@@ -976,10 +978,11 @@ fn check_item_deprecated_modes(tcx: ty::ctxt, it: @ast::item) {\n     match it.node {\n         ast::item_ty(ty, _) => {\n             match ty.node {\n-                ast::ty_fn(f) => {\n+                ast::ty_closure(@ast::TyClosure {decl: ref decl, _}) |\n+                ast::ty_bare_fn(@ast::TyBareFn {decl: ref decl, _}) => {\n                     let fn_ty = ty::node_id_to_type(tcx, it.id);\n                     check_fn_deprecated_modes(\n-                        tcx, fn_ty, f.decl, ty.span, it.id)\n+                        tcx, fn_ty, *decl, ty.span, it.id)\n                 }\n                 _ => ()\n             }"}, {"sha": "9240bc5fbc88e35fb0c77c74dfde05b71e01c4b0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -368,7 +368,7 @@ impl IrMaps {\n     }\n \n     fn variable(node_id: node_id, span: span) -> Variable {\n-        match self.variable_map.find(node_id) {\n+        match self.variable_map.find(&node_id) {\n           Some(var) => var,\n           None => {\n             self.tcx.sess.span_bug(\n@@ -390,7 +390,7 @@ impl IrMaps {\n     }\n \n     fn captures(expr: @expr) -> @~[CaptureInfo] {\n-        match self.capture_info_map.find(expr.id) {\n+        match self.capture_info_map.find(&expr.id) {\n           Some(caps) => caps,\n           None => {\n             self.tcx.sess.span_bug(expr.span, ~\"no registered caps\");\n@@ -410,7 +410,7 @@ impl IrMaps {\n           Local(LocalInfo {id: id, kind: FromLetNoInitializer, _}) |\n           Local(LocalInfo {id: id, kind: FromLetWithInitializer, _}) |\n           Local(LocalInfo {id: id, kind: FromMatch(_), _}) => {\n-            let v = match self.last_use_map.find(expr_id) {\n+            let v = match self.last_use_map.find(&expr_id) {\n               Some(v) => v,\n               None => {\n                 let v = @DVec();\n@@ -552,7 +552,7 @@ fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) => {\n-        let def = self.tcx.def_map.get(expr.id);\n+        let def = self.tcx.def_map.get(&expr.id);\n         debug!(\"expr %d: path that leads to %?\", expr.id, def);\n         if relevant_def(def).is_some() {\n             self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -569,7 +569,7 @@ fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n         // being the location that the variable is used.  This results\n         // in better error messages than just pointing at the closure\n         // construction site.\n-        let cvs = self.capture_map.get(expr.id);\n+        let cvs = self.capture_map.get(&expr.id);\n         let mut call_caps = ~[];\n         for cvs.each |cv| {\n             match relevant_def(cv.def) {\n@@ -685,7 +685,7 @@ fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n \n impl Liveness {\n     fn live_node(node_id: node_id, span: span) -> LiveNode {\n-        match self.ir.live_node_map.find(node_id) {\n+        match self.ir.live_node_map.find(&node_id) {\n           Some(ln) => ln,\n           None => {\n             // This must be a mismatch between the ir_map construction\n@@ -702,7 +702,7 @@ impl Liveness {\n     fn variable_from_path(expr: @expr) -> Option<Variable> {\n         match expr.node {\n           expr_path(_) => {\n-            let def = self.tcx.def_map.get(expr.id);\n+            let def = self.tcx.def_map.get(&expr.id);\n             relevant_def(def).map(\n                 |rdef| self.variable(*rdef, expr.span)\n             )\n@@ -717,7 +717,7 @@ impl Liveness {\n \n     fn variable_from_def_map(node_id: node_id,\n                              span: span) -> Option<Variable> {\n-        match self.tcx.def_map.find(node_id) {\n+        match self.tcx.def_map.find(&node_id) {\n           Some(def) => {\n             relevant_def(def).map(\n                 |rdef| self.variable(*rdef, span)\n@@ -837,7 +837,7 @@ impl Liveness {\n         match opt_label {\n             Some(_) => // Refers to a labeled loop. Use the results of resolve\n                       // to find with one\n-                match self.tcx.def_map.find(id) {\n+                match self.tcx.def_map.find(&id) {\n                     Some(def_label(loop_id)) => loop_id,\n                     _ => self.tcx.sess.span_bug(sp, ~\"Label on break/loop \\\n                                                     doesn't refer to a loop\")\n@@ -1203,7 +1203,7 @@ impl Liveness {\n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n \n-              match self.break_ln.find(sc) {\n+              match self.break_ln.find(&sc) {\n                   Some(b) => b,\n                   None => self.tcx.sess.span_bug(expr.span,\n                                 ~\"Break to unknown label\")\n@@ -1217,7 +1217,7 @@ impl Liveness {\n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n \n-              match self.cont_ln.find(sc) {\n+              match self.cont_ln.find(&sc) {\n                   Some(b) => b,\n                   None => self.tcx.sess.span_bug(expr.span,\n                                 ~\"Loop to unknown label\")\n@@ -1424,7 +1424,7 @@ impl Liveness {\n     }\n \n     fn access_path(expr: @expr, succ: LiveNode, acc: uint) -> LiveNode {\n-        let def = self.tcx.def_map.get(expr.id);\n+        let def = self.tcx.def_map.get(&expr.id);\n         match relevant_def(def) {\n           Some(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n@@ -1560,7 +1560,7 @@ fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n             let ln = self.live_node(expr.id, expr.span);\n             self.consider_last_use(expr, ln, *var);\n \n-            match self.ir.variable_moves_map.find(expr.id) {\n+            match self.ir.variable_moves_map.find(&expr.id) {\n                 None => {}\n                 Some(entire_expr) => {\n                     debug!(\"(checking expr) is a move: `%s`\",\n@@ -1689,7 +1689,7 @@ impl @Liveness {\n     fn check_lvalue(expr: @expr, vt: vt<@Liveness>) {\n         match expr.node {\n           expr_path(_) => {\n-            match self.tcx.def_map.get(expr.id) {\n+            match self.tcx.def_map.get(&expr.id) {\n               def_local(nid, false) => {\n                 // Assignment to an immutable variable or argument:\n                 // only legal if there is no later assignment."}, {"sha": "07de99870964f2a494b17b3b19dfe7cd559c6c78", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 47, "deletions": 60, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -146,63 +146,55 @@ pub enum deref_kind {deref_ptr(ptr_kind), deref_comp(comp_kind)}\n // pointer adjustment).\n pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n     match ty::get(t).sty {\n-      ty::ty_uniq(*) |\n-      ty::ty_evec(_, ty::vstore_uniq) |\n-      ty::ty_estr(ty::vstore_uniq) => {\n-        Some(deref_ptr(uniq_ptr))\n-      }\n-\n-      ty::ty_fn(ref f) if (*f).meta.proto == ast::ProtoUniq => {\n-        Some(deref_ptr(uniq_ptr))\n-      }\n-\n-      ty::ty_rptr(r, mt) |\n-      ty::ty_evec(mt, ty::vstore_slice(r)) => {\n-        Some(deref_ptr(region_ptr(mt.mutbl, r)))\n-      }\n-\n-      ty::ty_estr(ty::vstore_slice(r)) => {\n-        Some(deref_ptr(region_ptr(ast::m_imm, r)))\n-      }\n+        ty::ty_uniq(*) |\n+        ty::ty_evec(_, ty::vstore_uniq) |\n+        ty::ty_estr(ty::vstore_uniq) |\n+        ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) => {\n+            Some(deref_ptr(uniq_ptr))\n+        }\n \n-      ty::ty_fn(ref f) if (*f).meta.proto == ast::ProtoBorrowed => {\n-        Some(deref_ptr(region_ptr(ast::m_imm, (*f).meta.region)))\n-      }\n+        ty::ty_rptr(r, mt) |\n+        ty::ty_evec(mt, ty::vstore_slice(r)) => {\n+            Some(deref_ptr(region_ptr(mt.mutbl, r)))\n+        }\n \n-      ty::ty_box(mt) |\n-      ty::ty_evec(mt, ty::vstore_box) => {\n-        Some(deref_ptr(gc_ptr(mt.mutbl)))\n-      }\n+        ty::ty_estr(ty::vstore_slice(r)) |\n+        ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n+                                      region: r, _}) => {\n+            Some(deref_ptr(region_ptr(ast::m_imm, r)))\n+        }\n \n-      ty::ty_estr(ty::vstore_box) => {\n-        Some(deref_ptr(gc_ptr(ast::m_imm)))\n-      }\n+        ty::ty_box(mt) |\n+        ty::ty_evec(mt, ty::vstore_box) => {\n+            Some(deref_ptr(gc_ptr(mt.mutbl)))\n+        }\n \n-      ty::ty_fn(ref f) if (*f).meta.proto == ast::ProtoBox => {\n-        Some(deref_ptr(gc_ptr(ast::m_imm)))\n-      }\n+        ty::ty_estr(ty::vstore_box) |\n+        ty::ty_closure(ty::ClosureTy {sigil: ast::ManagedSigil, _}) => {\n+            Some(deref_ptr(gc_ptr(ast::m_imm)))\n+        }\n \n-      ty::ty_ptr(*) => {\n-        Some(deref_ptr(unsafe_ptr))\n-      }\n+        ty::ty_ptr(*) => {\n+            Some(deref_ptr(unsafe_ptr))\n+        }\n \n-      ty::ty_enum(did, _) => {\n-        Some(deref_comp(comp_variant(did)))\n-      }\n+        ty::ty_enum(did, _) => {\n+            Some(deref_comp(comp_variant(did)))\n+        }\n \n-      ty::ty_struct(_, _) => {\n-        Some(deref_comp(comp_anon_field))\n-      }\n+        ty::ty_struct(_, _) => {\n+            Some(deref_comp(comp_anon_field))\n+        }\n \n-      ty::ty_evec(mt, ty::vstore_fixed(_)) => {\n-        Some(deref_comp(comp_index(t, mt.mutbl)))\n-      }\n+        ty::ty_evec(mt, ty::vstore_fixed(_)) => {\n+            Some(deref_comp(comp_index(t, mt.mutbl)))\n+        }\n \n-      ty::ty_estr(ty::vstore_fixed(_)) => {\n-        Some(deref_comp(comp_index(t, m_imm)))\n-      }\n+        ty::ty_estr(ty::vstore_fixed(_)) => {\n+            Some(deref_comp(comp_index(t, m_imm)))\n+        }\n \n-      _ => None\n+        _ => None\n     }\n }\n \n@@ -308,7 +300,7 @@ pub struct mem_categorization_ctxt {\n \n pub impl &mem_categorization_ctxt {\n     fn cat_expr(expr: @ast::expr) -> cmt {\n-        match self.tcx.adjustments.find(expr.id) {\n+        match self.tcx.adjustments.find(&expr.id) {\n             None => {\n                 // No adjustments.\n                 self.cat_expr_unadjusted(expr)\n@@ -375,7 +367,7 @@ pub impl &mem_categorization_ctxt {\n           }\n \n           ast::expr_path(_) => {\n-            let def = self.tcx.def_map.get(expr.id);\n+            let def = self.tcx.def_map.get(&expr.id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -473,9 +465,9 @@ pub impl &mem_categorization_ctxt {\n \n           ast::def_upvar(_, inner, fn_node_id, _) => {\n             let ty = ty::node_id_to_type(self.tcx, fn_node_id);\n-            let proto = ty::ty_fn_proto(ty);\n-            match proto {\n-                ast::ProtoBorrowed => {\n+            let sigil = ty::ty_closure_sigil(ty);\n+            match sigil {\n+                ast::BorrowedSigil => {\n                     let upcmt = self.cat_def(id, span, expr_ty, *inner);\n                     @cmt_ {\n                         id:id,\n@@ -486,7 +478,7 @@ pub impl &mem_categorization_ctxt {\n                         ty:upcmt.ty\n                     }\n                 }\n-                ast::ProtoUniq | ast::ProtoBox => {\n+                ast::OwnedSigil | ast::ManagedSigil => {\n                     // FIXME #2152 allow mutation of moved upvars\n                     @cmt_ {\n                         id:id,\n@@ -497,11 +489,6 @@ pub impl &mem_categorization_ctxt {\n                         ty:expr_ty\n                     }\n                 }\n-                ast::ProtoBare => {\n-                    self.tcx.sess.span_bug(\n-                        span,\n-                        fmt!(\"Upvar in a bare closure?\"));\n-                }\n             }\n           }\n \n@@ -840,7 +827,7 @@ pub impl &mem_categorization_ctxt {\n             // variant(*)\n           }\n           ast::pat_enum(_, Some(ref subpats)) => {\n-            match self.tcx.def_map.find(pat.id) {\n+            match self.tcx.def_map.find(&pat.id) {\n                 Some(ast::def_variant(enum_did, _)) => {\n                     // variant(x, y, z)\n                     for subpats.each |subpat| {\n@@ -1063,7 +1050,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n         }\n       }\n       ty::ty_enum(*) => {\n-        match tcx.def_map.get(node_id) {\n+        match tcx.def_map.get(&node_id) {\n           ast::def_variant(_, variant_id) => {\n             for ty::lookup_struct_fields(tcx, variant_id).each |fld| {\n                 if fld.ident == f_name {"}, {"sha": "aaa3156e27c2574ac947880f673cfb205a2429be", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 33, "deletions": 5, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -409,7 +409,7 @@ impl VisitContext {\n         // `expr_mode` refers to the post-adjustment value.  If one of\n         // those adjustments is to take a reference, then it's only\n         // reading the underlying expression, not moving it.\n-        let comp_mode = match self.tcx.adjustments.find(expr.id) {\n+        let comp_mode = match self.tcx.adjustments.find(&expr.id) {\n             Some(adj) if adj.autoref.is_some() => Read,\n             _ => expr_mode.component_mode(expr)\n         };\n@@ -474,7 +474,35 @@ impl VisitContext {\n                 }\n \n                 for opt_with.each |with_expr| {\n-                    self.consume_expr(*with_expr, visitor);\n+                    // If there are any fields whose type is move-by-default,\n+                    // then `with` is consumed, otherwise it is only read\n+                    let with_ty = ty::expr_ty(self.tcx, *with_expr);\n+                    let with_fields = match ty::get(with_ty).sty {\n+                        ty::ty_rec(ref f) => copy *f,\n+                        ty::ty_struct(did, ref substs) => {\n+                            ty::struct_fields(self.tcx, did, substs)\n+                        }\n+                        ref r => {\n+                           self.tcx.sess.span_bug(\n+                                with_expr.span,\n+                                fmt!(\"bad base expr type in record: %?\", r))\n+                        }\n+                    };\n+\n+                    // The `with` expr must be consumed if it contains\n+                    // any fields which (1) were not explicitly\n+                    // specified and (2) have a type that\n+                    // moves-by-default:\n+                    let consume_with = with_fields.any(|tf| {\n+                        !fields.any(|f| f.node.ident == tf.ident) &&\n+                            ty::type_implicitly_moves(self.tcx, tf.mt.ty)\n+                    });\n+\n+                    if consume_with {\n+                        self.consume_expr(*with_expr, visitor);\n+                    } else {\n+                        self.use_expr(*with_expr, Read, visitor);\n+                    }\n                 }\n             }\n \n@@ -713,7 +741,7 @@ impl VisitContext {\n                     receiver_expr: @expr,\n                     visitor: vt<VisitContext>)\n     {\n-        let callee_mode = match self.method_map.find(expr_id) {\n+        let callee_mode = match self.method_map.find(&expr_id) {\n             Some(ref method_map_entry) => {\n                 match method_map_entry.explicit_self {\n                     sty_by_ref => by_ref,\n@@ -786,9 +814,9 @@ impl VisitContext {\n         let _indenter = indenter();\n \n         let fn_ty = ty::node_id_to_type(self.tcx, fn_expr_id);\n-        let proto = ty::ty_fn_proto(fn_ty);\n+        let sigil = ty::ty_closure_sigil(fn_ty);\n         let freevars = freevars::get_freevars(self.tcx, fn_expr_id);\n-        if proto == ProtoBorrowed {\n+        if sigil == BorrowedSigil {\n             // &fn() captures everything by ref\n             at_vec::from_fn(freevars.len(), |i| {\n                 let fvar = &freevars[i];"}, {"sha": "823af16c6054c8a33d11096c39082a3d3b264824", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -35,7 +35,7 @@ pub fn pat_id_map(dm: resolve::DefMap, pat: @pat) -> PatIdMap {\n pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: @pat) -> bool {\n     match pat.node {\n         pat_enum(_, _) | pat_ident(_, _, None) | pat_struct(*) => {\n-            match dm.find(pat.id) {\n+            match dm.find(&pat.id) {\n                 Some(def_variant(*)) | Some(def_struct(*)) => true,\n                 _ => false\n             }\n@@ -47,7 +47,7 @@ pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: @pat) -> bool {\n pub fn pat_is_const(dm: resolve::DefMap, pat: &pat) -> bool {\n     match pat.node {\n         pat_ident(_, _, None) => {\n-            match dm.find(pat.id) {\n+            match dm.find(&pat.id) {\n                 Some(def_const(*)) => true,\n                 _ => false\n             }"}, {"sha": "3ec1cf3a7058e02cc31622f3edd5842150cef58a", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -105,7 +105,7 @@ pub fn check_crate(tcx: ty::ctxt,\n         match *origin {\n             method_static(method_id) => {\n                 if method_id.crate == local_crate {\n-                    match tcx.items.find(method_id.node) {\n+                    match tcx.items.find(&method_id.node) {\n                         Some(node_method(method, impl_id, _)) => {\n                             if method.vis == private &&\n                                     (impl_id.crate != local_crate ||\n@@ -143,7 +143,7 @@ pub fn check_crate(tcx: ty::ctxt,\n             method_self(trait_id, method_num) |\n             method_super(trait_id, method_num) => {\n                 if trait_id.crate == local_crate {\n-                    match tcx.items.find(trait_id.node) {\n+                    match tcx.items.find(&trait_id.node) {\n                         Some(node_item(item, _)) => {\n                             match item.node {\n                                 item_trait(_, _, ref methods) => {\n@@ -221,7 +221,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                         ty_struct(id, _)\n                         if id.crate != local_crate ||\n                            !privileged_items.contains(&(id.node)) => {\n-                            match method_map.find(expr.id) {\n+                            match method_map.find(&expr.id) {\n                                 None => {\n                                     debug!(\"(privacy checking) checking \\\n                                             field access\");\n@@ -244,7 +244,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                         ty_struct(id, _)\n                         if id.crate != local_crate ||\n                            !privileged_items.contains(&(id.node)) => {\n-                            match method_map.find(expr.id) {\n+                            match method_map.find(&expr.id) {\n                                 None => {\n                                     tcx.sess.span_bug(expr.span,\n                                                       ~\"method call not in \\\n@@ -276,7 +276,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                         ty_enum(id, _) => {\n                             if id.crate != local_crate ||\n                                     !privileged_items.contains(&(id.node)) {\n-                                match tcx.def_map.get(expr.id) {\n+                                match tcx.def_map.get(&expr.id) {\n                                     def_variant(_, variant_id) => {\n                                         for (*fields).each |field| {\n                                                 debug!(\"(privacy checking) \\\n@@ -343,7 +343,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                             if enum_id.crate != local_crate ||\n                                     !privileged_items.contains(\n                                         &enum_id.node) {\n-                                match tcx.def_map.find(pattern.id) {\n+                                match tcx.def_map.find(&pattern.id) {\n                                     Some(def_variant(_, variant_id)) => {\n                                         for fields.each |field| {\n                                             debug!(\"(privacy checking) \\"}, {"sha": "68e41b329e366ac2ef1755c3e2f3fff63f935da9", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -115,7 +115,7 @@ pub fn scope_contains(region_map: region_map, superscope: ast::node_id,\n                       subscope: ast::node_id) -> bool {\n     let mut subscope = subscope;\n     while superscope != subscope {\n-        match region_map.find(subscope) {\n+        match region_map.find(&subscope) {\n             None => return false,\n             Some(scope) => subscope = scope\n         }\n@@ -159,7 +159,7 @@ pub fn nearest_common_ancestor(region_map: region_map,\n         let mut result = ~[scope];\n         let mut scope = scope;\n         loop {\n-            match region_map.find(scope) {\n+            match region_map.find(&scope) {\n                 None => return result,\n                 Some(superscope) => {\n                     result.push(superscope);\n@@ -237,7 +237,7 @@ pub fn resolve_arm(arm: ast::arm, cx: ctxt, visitor: visit::vt<ctxt>) {\n pub fn resolve_pat(pat: @ast::pat, cx: ctxt, visitor: visit::vt<ctxt>) {\n     match pat.node {\n       ast::pat_ident(*) => {\n-        let defn_opt = cx.def_map.find(pat.id);\n+        let defn_opt = cx.def_map.find(&pat.id);\n         match defn_opt {\n           Some(ast::def_variant(_,_)) => {\n             /* Nothing to do; this names a variant. */\n@@ -475,7 +475,7 @@ pub impl determine_rp_ctxt {\n     /// the new variance is joined with the old variance.\n     fn add_rp(id: ast::node_id, variance: region_variance) {\n         assert id != 0;\n-        let old_variance = self.region_paramd_items.find(id);\n+        let old_variance = self.region_paramd_items.find(&id);\n         let joined_variance = match old_variance {\n           None => variance,\n           Some(v) => join_variance(v, variance)\n@@ -505,7 +505,7 @@ pub impl determine_rp_ctxt {\n                ast_map::node_id_to_str(self.ast_map, self.item_id,\n                                        self.sess.parse_sess.interner),\n                copy self.ambient_variance);\n-        let vec = match self.dep_map.find(from) {\n+        let vec = match self.dep_map.find(&from) {\n             Some(vec) => vec,\n             None => {\n                 let vec = @DVec();\n@@ -657,7 +657,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n             }\n         }\n \n-        ast::ty_fn(f) => {\n+        ast::ty_closure(ref f) => {\n             debug!(\"referenced fn type: %s\",\n                    pprust::ty_to_str(ty, cx.sess.intr()));\n             match f.region {\n@@ -668,7 +668,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n                     }\n                 }\n                 None => {\n-                    if f.proto == ast::ProtoBorrowed && cx.anon_implies_rp {\n+                    if f.sigil == ast::BorrowedSigil && cx.anon_implies_rp {\n                         cx.add_rp(cx.item_id,\n                                   cx.add_variance(rv_contravariant));\n                     }\n@@ -685,7 +685,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     // that as a direct dependency.\n     match ty.node {\n       ast::ty_path(path, id) => {\n-        match cx.def_map.find(id) {\n+        match cx.def_map.find(&id) {\n           Some(ast::def_ty(did)) | Some(ast::def_struct(did)) => {\n             if did.crate == ast::local_crate {\n                 if cx.opt_region_is_relevant(path.rp) {\n@@ -732,18 +732,18 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n         }\n       }\n \n-      ast::ty_fn(f) => {\n+      ast::ty_closure(@ast::TyClosure {decl: ref decl, _}) |\n+      ast::ty_bare_fn(@ast::TyBareFn {decl: ref decl, _}) => {\n         // fn() binds the & region, so do not consider &T types that\n         // appear *inside* a fn() type to affect the enclosing item:\n         do cx.with(cx.item_id, false) {\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n-                for f.decl.inputs.each |a| {\n+                for decl.inputs.each |a| {\n                     (visitor.visit_ty)(a.ty, cx, visitor);\n                 }\n             }\n-            visit::visit_ty_param_bounds(f.bounds, cx, visitor);\n-            (visitor.visit_ty)(f.decl.output, cx, visitor);\n+            (visitor.visit_ty)(decl.output, cx, visitor);\n         }\n       }\n \n@@ -818,9 +818,9 @@ pub fn determine_rp_in_crate(sess: Session,\n     // update the region-parameterization of D to reflect the result.\n     while cx.worklist.len() != 0 {\n         let c_id = cx.worklist.pop();\n-        let c_variance = cx.region_paramd_items.get(c_id);\n+        let c_variance = cx.region_paramd_items.get(&c_id);\n         debug!(\"popped %d from worklist\", c_id);\n-        match cx.dep_map.find(c_id) {\n+        match cx.dep_map.find(&c_id) {\n           None => {}\n           Some(deps) => {\n             for deps.each |dep| {"}, {"sha": "c647e4db262a64479427c1bcfc031f9abfdfce7b", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -947,7 +947,7 @@ pub impl Resolver {\n \n         // Add or reuse the child.\n         let new_parent = ModuleReducedGraphParent(module_);\n-        match module_.children.find(name) {\n+        match module_.children.find(&name) {\n             None => {\n                 let child = @NameBindings();\n                 module_.children.insert(name, child);\n@@ -1558,7 +1558,7 @@ pub impl Resolver {\n                         %s\", final_ident);\n                 let parent_link = self.get_parent_link(new_parent, ident);\n \n-                match modules.find(def_id) {\n+                match modules.find(&def_id) {\n                   None => {\n                     child_name_bindings.define_module(Public,\n                                                       parent_link,\n@@ -1582,7 +1582,8 @@ pub impl Resolver {\n                         die!(~\"can't happen\");\n                       }\n                       ModuleParentLink(parent_module, ident) => {\n-                        let name_bindings = parent_module.children.get(ident);\n+                        let name_bindings = parent_module.children.get(\n+                            &ident);\n                         resolution.type_target =\n                             Some(Target(parent_module, name_bindings));\n                       }\n@@ -1841,7 +1842,7 @@ pub impl Resolver {\n                        self.idents_to_str(module_path.get()),\n                        self.session.str_of(target));\n \n-                match module_.import_resolutions.find(target) {\n+                match module_.import_resolutions.find(&target) {\n                     Some(resolution) => {\n                         debug!(\"(building import directive) bumping \\\n                                 reference\");\n@@ -2112,7 +2113,7 @@ pub impl Resolver {\n         let mut type_result = UnknownResult;\n \n         // Search for direct children of the containing module.\n-        match containing_module.children.find(source) {\n+        match containing_module.children.find(&source) {\n             None => {\n                 // Continue.\n             }\n@@ -2148,7 +2149,7 @@ pub impl Resolver {\n                 // Now search the exported imports within the containing\n                 // module.\n \n-                match containing_module.import_resolutions.find(source) {\n+                match containing_module.import_resolutions.find(&source) {\n                     None => {\n                         // The containing module definitely doesn't have an\n                         // exported import with the name in question. We can\n@@ -2212,7 +2213,7 @@ pub impl Resolver {\n \n         // We've successfully resolved the import. Write the results in.\n         assert module_.import_resolutions.contains_key_ref(&target);\n-        let import_resolution = module_.import_resolutions.get(target);\n+        let import_resolution = module_.import_resolutions.get(&target);\n \n         match value_result {\n             BoundResult(target_module, name_bindings) => {\n@@ -2297,7 +2298,7 @@ pub impl Resolver {\n         let mut module_result = UnknownResult;\n \n         // Search for direct children of the containing module.\n-        match containing_module.children.find(source) {\n+        match containing_module.children.find(&source) {\n             None => {\n                 // Continue.\n             }\n@@ -2327,7 +2328,7 @@ pub impl Resolver {\n \n                 // Now search the exported imports within the containing\n                 // module.\n-                match containing_module.import_resolutions.find(source) {\n+                match containing_module.import_resolutions.find(&source) {\n                     None => {\n                         // The containing module definitely doesn't have an\n                         // exported import with the name in question. We can\n@@ -2371,7 +2372,7 @@ pub impl Resolver {\n \n         // We've successfully resolved the import. Write the results in.\n         assert module_.import_resolutions.contains_key_ref(&target);\n-        let import_resolution = module_.import_resolutions.get(target);\n+        let import_resolution = module_.import_resolutions.get(&target);\n \n         match module_result {\n             BoundResult(target_module, name_bindings) => {\n@@ -2439,7 +2440,7 @@ pub impl Resolver {\n                    self.module_to_str(module_));\n \n             // Here we merge two import resolutions.\n-            match module_.import_resolutions.find(ident) {\n+            match module_.import_resolutions.find(&ident) {\n                 None => {\n                     // Simple: just copy the old import resolution.\n                     let new_import_resolution =\n@@ -2482,7 +2483,7 @@ pub impl Resolver {\n         // Add all children from the containing module.\n         for containing_module.children.each_ref |&ident, &name_bindings| {\n             let mut dest_import_resolution;\n-            match module_.import_resolutions.find(ident) {\n+            match module_.import_resolutions.find(&ident) {\n                 None => {\n                     // Create a new import resolution from this child.\n                     dest_import_resolution = @ImportResolution(privacy, span);\n@@ -2686,7 +2687,7 @@ pub impl Resolver {\n         // The current module node is handled specially. First, check for\n         // its immediate children.\n \n-        match module_.children.find(name) {\n+        match module_.children.find(&name) {\n             Some(name_bindings)\n                     if (*name_bindings).defined_in_namespace(namespace) => {\n                 return Success(Target(module_, name_bindings));\n@@ -2699,7 +2700,7 @@ pub impl Resolver {\n         // adjacent import statements are processed as though they mutated the\n         // current scope.\n \n-        match module_.import_resolutions.find(name) {\n+        match module_.import_resolutions.find(&name) {\n             None => {\n                 // Not found; continue.\n             }\n@@ -2923,7 +2924,7 @@ pub impl Resolver {\n                self.module_to_str(module_));\n \n         // First, check the direct children of the module.\n-        match module_.children.find(name) {\n+        match module_.children.find(&name) {\n             Some(name_bindings)\n                     if (*name_bindings).defined_in_namespace(namespace) => {\n \n@@ -2944,7 +2945,7 @@ pub impl Resolver {\n         }\n \n         // Otherwise, we check the list of resolved imports.\n-        match module_.import_resolutions.find(name) {\n+        match module_.import_resolutions.find(&name) {\n             Some(import_resolution) => {\n                 if import_resolution.outstanding_references != 0 {\n                     debug!(\"(resolving name in module) import unresolved; \\\n@@ -3114,7 +3115,7 @@ pub impl Resolver {\n         }\n \n         // Otherwise, proceed and write in the bindings.\n-        match module_.import_resolutions.find(target_name) {\n+        match module_.import_resolutions.find(&target_name) {\n             None => {\n                 die!(~\"(resolving one-level renaming import) reduced graph \\\n                       construction or glob importing should have created the \\\n@@ -3328,7 +3329,7 @@ pub impl Resolver {\n                 // Nothing to do.\n             }\n             Some(name) => {\n-                match orig_module.children.find(name) {\n+                match orig_module.children.find(&name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `%s` in `%s`\",\n                                self.session.str_of(name),\n@@ -3405,7 +3406,7 @@ pub impl Resolver {\n                   // If the def is a ty param, and came from the parent\n                   // item, it's ok\n                   match def {\n-                    def_ty_param(did, _) if self.def_map.find(copy(did.node))\n+                    def_ty_param(did, _) if self.def_map.find(&did.node)\n                       == Some(def_typaram_binder(item_id)) => {\n                       // ok\n                     }\n@@ -3477,7 +3478,7 @@ pub impl Resolver {\n         while i != 0 {\n             i -= 1;\n             let rib = (*ribs).get_elt(i);\n-            match rib.bindings.find(name) {\n+            match rib.bindings.find(&name) {\n                 Some(def_like) => {\n                     return self.upvarify(ribs, i, def_like, span,\n                                       allow_capturing_self);\n@@ -4069,7 +4070,7 @@ pub impl Resolver {\n             let map_i = self.binding_mode_map(*p);\n \n             for map_0.each_ref |&key, &binding_0| {\n-                match map_i.find(key) {\n+                match map_i.find(&key) {\n                   None => {\n                     self.session.span_err(\n                         p.span,\n@@ -4126,7 +4127,7 @@ pub impl Resolver {\n \n         // Move down in the graph, if there's an anonymous module rooted here.\n         let orig_module = self.current_module;\n-        match self.current_module.anonymous_children.find(block.node.id) {\n+        match self.current_module.anonymous_children.find(&block.node.id) {\n             None => { /* Nothing to do. */ }\n             Some(anonymous_module) => {\n                 debug!(\"(resolving block) found anonymous module, moving \\\n@@ -4161,7 +4162,7 @@ pub impl Resolver {\n \n                     match self.primitive_type_table\n                             .primitive_types\n-                            .find(name) {\n+                            .find(&name) {\n \n                         Some(primitive_type) => {\n                             result_def =\n@@ -4327,7 +4328,7 @@ pub impl Resolver {\n                                     bindings_list.insert(ident, pat_id);\n                                 }\n                                 Some(b) => {\n-                                  if b.find(ident) == Some(pat_id) {\n+                                  if b.find(&ident) == Some(pat_id) {\n                                       // Then this is a duplicate variable\n                                       // in the same disjunct, which is an\n                                       // error\n@@ -4526,7 +4527,7 @@ pub impl Resolver {\n                                          -> NameDefinition {\n \n         // First, search children.\n-        match containing_module.children.find(name) {\n+        match containing_module.children.find(&name) {\n             Some(child_name_bindings) => {\n                 match (child_name_bindings.def_for_namespace(namespace),\n                        child_name_bindings.privacy_for_namespace(namespace)) {\n@@ -4549,7 +4550,7 @@ pub impl Resolver {\n         }\n \n         // Next, search import resolutions.\n-        match containing_module.import_resolutions.find(name) {\n+        match containing_module.import_resolutions.find(&name) {\n             Some(import_resolution) if import_resolution.privacy == Public ||\n                                        xray == Xray => {\n                 match (*import_resolution).target_for_namespace(namespace) {\n@@ -5076,7 +5077,7 @@ pub impl Resolver {\n                trait_def_id.node,\n                self.session.str_of(name));\n \n-        match self.trait_info.find(trait_def_id) {\n+        match self.trait_info.find(&trait_def_id) {\n             Some(trait_info) if trait_info.contains_key_ref(&name) => {\n                 debug!(\"(adding trait info if containing method) found trait \\\n                         %d:%d for method '%s'\","}, {"sha": "ebd6d9f905642d9622f5ff202bb6a03a1a09d734", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 26, "deletions": 14, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -282,7 +282,7 @@ pub fn trans_opt(bcx: block, o: &Opt) -> opt_result {\n }\n \n pub fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> Opt {\n-    match tcx.def_map.get(pat_id) {\n+    match tcx.def_map.get(&pat_id) {\n         ast::def_variant(enum_id, var_id) => {\n             let variants = ty::enum_variants(tcx, enum_id);\n             for vec::each(*variants) |v| {\n@@ -377,7 +377,7 @@ pub fn expand_nested_bindings(bcx: block, m: &[@Match/&r],\n                                 vec::view(br.pats, col + 1u, br.pats.len())));\n \n                 let binding_info =\n-                    br.data.bindings_map.get(path_to_ident(path));\n+                    br.data.bindings_map.get(&path_to_ident(path));\n \n                 Store(bcx, val, binding_info.llmatch);\n                 @Match {pats: pats, data: br.data}\n@@ -424,7 +424,8 @@ pub fn enter_match(bcx: block, dm: DefMap, m: &[@Match/&r],\n                     ast::pat_ident(_, path, None) => {\n                         if pat_is_binding(dm, self) {\n                             let binding_info =\n-                                br.data.bindings_map.get(path_to_ident(path));\n+                                br.data.bindings_map.get(\n+                                    &path_to_ident(path));\n                             Store(bcx, val, binding_info.llmatch);\n                         }\n                     }\n@@ -518,7 +519,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                 }\n             }\n             ast::pat_ident(_, _, None) if pat_is_const(tcx.def_map, p) => {\n-                let const_def = tcx.def_map.get(p.id);\n+                let const_def = tcx.def_map.get(&p.id);\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n                 if opt_eq(tcx, &lit(ConstLit(const_def_id)), opt) {\n                     Some(~[])\n@@ -536,7 +537,7 @@ pub fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                 if opt_eq(tcx, &variant_opt(tcx, p.id), opt) {\n                     // Look up the struct variant ID.\n                     let struct_id;\n-                    match tcx.def_map.get(p.id) {\n+                    match tcx.def_map.get(&p.id) {\n                         ast::def_variant(_, found_struct_id) => {\n                             struct_id = found_struct_id;\n                         }\n@@ -774,7 +775,7 @@ pub fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n             ast::pat_ident(*) => {\n                 // This is one of: an enum variant, a unit-like struct, or a\n                 // variable binding.\n-                match ccx.tcx.def_map.find(cur.id) {\n+                match ccx.tcx.def_map.find(&cur.id) {\n                     Some(ast::def_variant(*)) => {\n                         add_to_set(ccx.tcx, &found,\n                                    variant_opt(ccx.tcx, cur.id));\n@@ -793,7 +794,7 @@ pub fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n             ast::pat_enum(*) | ast::pat_struct(*) => {\n                 // This could be one of: a tuple-like enum variant, a\n                 // struct-like enum variant, or a struct.\n-                match ccx.tcx.def_map.find(cur.id) {\n+                match ccx.tcx.def_map.find(&cur.id) {\n                     Some(ast::def_variant(*)) => {\n                         add_to_set(ccx.tcx, &found,\n                                    variant_opt(ccx.tcx, cur.id));\n@@ -926,7 +927,7 @@ pub fn root_pats_as_necessary(bcx: block,\n         let pat_id = br.pats[col].id;\n \n         let key = root_map_key {id: pat_id, derefs: 0u };\n-        match bcx.ccx().maps.root_map.find(key) {\n+        match bcx.ccx().maps.root_map.find(&key) {\n             None => (),\n             Some(root_info) => {\n                 // Note: the scope_id will always be the id of the match.  See\n@@ -981,7 +982,7 @@ pub fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n         let pat = br.pats[col];\n         match pat.node {\n             ast::pat_enum(_, Some(_)) => {\n-                match bcx.tcx().def_map.find(pat.id) {\n+                match bcx.tcx().def_map.find(&pat.id) {\n                     Some(ast::def_struct(*)) => true,\n                     _ => false\n                 }\n@@ -1027,6 +1028,8 @@ pub fn pick_col(m: &[@Match]) -> uint {\n pub enum branch_kind { no_branch, single, switch, compare, compare_vec_len, }\n \n // Compiles a comparison between two things.\n+//\n+// NB: This must produce an i1, not a Rust bool (i8).\n pub fn compare_values(cx: block,\n                       lhs: ValueRef,\n                       rhs: ValueRef,\n@@ -1052,7 +1055,11 @@ pub fn compare_values(cx: block,\n                                                           scratch_rhs],\n                                                         expr::SaveIn(\n                                                          scratch_result.val));\n-            return scratch_result.to_result(bcx);\n+            let result = scratch_result.to_result(bcx);\n+            Result {\n+                bcx: result.bcx,\n+                val: bool_to_i1(result.bcx, result.val)\n+            }\n         }\n         ty::ty_estr(_) => {\n             let scratch_result = scratch_datum(cx, ty::mk_bool(cx.tcx()),\n@@ -1062,7 +1069,11 @@ pub fn compare_values(cx: block,\n                                                         ~[lhs, rhs],\n                                                         expr::SaveIn(\n                                                          scratch_result.val));\n-            return scratch_result.to_result(bcx);\n+            let result = scratch_result.to_result(bcx);\n+            Result {\n+                bcx: result.bcx,\n+                val: bool_to_i1(result.bcx, result.val)\n+            }\n         }\n         _ => {\n             cx.tcx().sess.bug(~\"only scalars and strings supported in \\\n@@ -1175,6 +1186,7 @@ pub fn compile_guard(bcx: block,\n             expr::trans_to_datum(bcx, guard_expr).to_result()\n         }\n     });\n+    let val = bool_to_i1(bcx, val);\n \n     // Revoke the temp cleanups now that the guard successfully executed.\n     for temp_cleanups.each |llval| {\n@@ -1640,7 +1652,7 @@ pub fn trans_match_inner(scope_cx: block,\n         // insert bindings into the lllocals map and add cleanups\n         bcx = insert_lllocals(bcx, *arm_data, true);\n \n-        bcx = controlflow::trans_block(bcx, arm_data.arm.body, dest);\n+        bcx = controlflow::trans_block(bcx, &arm_data.arm.body, dest);\n         bcx = trans_block_cleanups(bcx, block_cleanups(arm_data.bodycx));\n         arm_cxs.push(bcx);\n     }\n@@ -1717,9 +1729,9 @@ pub fn bind_irrefutable_pat(bcx: block,\n             }\n         }\n         ast::pat_enum(_, sub_pats) => {\n-            match bcx.tcx().def_map.find(pat.id) {\n+            match bcx.tcx().def_map.find(&pat.id) {\n                 Some(ast::def_variant(*)) => {\n-                    let pat_def = ccx.tcx.def_map.get(pat.id);\n+                    let pat_def = ccx.tcx.def_map.get(&pat.id);\n                     let vdefs = ast_util::variant_def_ids(pat_def);\n                     let args = extract_variant_args(bcx, pat.id, vdefs, val);\n                     for sub_pats.each |sub_pat| {"}, {"sha": "588e2916e47e3c49ec9abe342906259103e3f1cc", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 60, "deletions": 72, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -137,7 +137,7 @@ pub fn log_fn_time(ccx: @crate_ctxt, +name: ~str, start: time::Timespec,\n     ccx.stats.fn_times.push({ident: name, time: elapsed});\n }\n \n-pub fn decl_fn(llmod: ModuleRef, name: ~str, cc: lib::llvm::CallConv,\n+pub fn decl_fn(llmod: ModuleRef, name: &str, cc: lib::llvm::CallConv,\n                llty: TypeRef) -> ValueRef {\n     let llfn: ValueRef = str::as_c_str(name, |buf| {\n         unsafe {\n@@ -150,7 +150,7 @@ pub fn decl_fn(llmod: ModuleRef, name: ~str, cc: lib::llvm::CallConv,\n     return llfn;\n }\n \n-pub fn decl_cdecl_fn(llmod: ModuleRef, +name: ~str, llty: TypeRef)\n+pub fn decl_cdecl_fn(llmod: ModuleRef, name: &str, llty: TypeRef)\n                   -> ValueRef {\n     return decl_fn(llmod, name, lib::llvm::CCallConv, llty);\n }\n@@ -164,22 +164,21 @@ pub fn decl_internal_cdecl_fn(llmod: ModuleRef, +name: ~str, llty: TypeRef) ->\n     return llfn;\n }\n \n-pub fn get_extern_fn(externs: HashMap<~str, ValueRef>,\n+pub fn get_extern_fn(externs: ExternMap,\n                      llmod: ModuleRef,\n-                     +name: ~str,\n+                     name: @str,\n                      cc: lib::llvm::CallConv,\n                      ty: TypeRef) -> ValueRef {\n-    if externs.contains_key_ref(&name) { return externs.get(name); }\n-    // XXX: Bad copy.\n-    let f = decl_fn(llmod, copy name, cc, ty);\n+    if externs.contains_key_ref(&name) { return externs.get(&name); }\n+    let f = decl_fn(llmod, name, cc, ty);\n     externs.insert(name, f);\n     return f;\n }\n \n-pub fn get_extern_const(externs: HashMap<~str, ValueRef>, llmod: ModuleRef,\n-                        +name: ~str, ty: TypeRef) -> ValueRef {\n+pub fn get_extern_const(externs: ExternMap, llmod: ModuleRef,\n+                        name: @str, ty: TypeRef) -> ValueRef {\n     unsafe {\n-        if externs.contains_key_ref(&name) { return externs.get(name); }\n+        if externs.contains_key_ref(&name) { return externs.get(&name); }\n         let c = str::as_c_str(name, |buf| {\n             llvm::LLVMAddGlobal(llmod, ty, buf)\n         });\n@@ -189,9 +188,9 @@ pub fn get_extern_const(externs: HashMap<~str, ValueRef>, llmod: ModuleRef,\n }\n \n     fn get_simple_extern_fn(cx: block,\n-                            externs: HashMap<~str, ValueRef>,\n+                            externs: ExternMap,\n                             llmod: ModuleRef,\n-                            +name: ~str,\n+                            name: @str,\n                             n_args: int) -> ValueRef {\n     let _icx = cx.insn_ctxt(\"get_simple_extern_fn\");\n     let ccx = cx.fcx.ccx;\n@@ -201,8 +200,8 @@ pub fn get_extern_const(externs: HashMap<~str, ValueRef>, llmod: ModuleRef,\n     return get_extern_fn(externs, llmod, name, lib::llvm::CCallConv, t);\n }\n \n-pub fn trans_foreign_call(cx: block, externs: HashMap<~str, ValueRef>,\n-                          llmod: ModuleRef, +name: ~str, args: ~[ValueRef]) ->\n+pub fn trans_foreign_call(cx: block, externs: ExternMap,\n+                          llmod: ModuleRef, name: @str, args: ~[ValueRef]) ->\n    ValueRef {\n     let _icx = cx.insn_ctxt(\"trans_foreign_call\");\n     let n = args.len() as int;\n@@ -372,7 +371,7 @@ pub fn get_tydesc_simple(ccx: @crate_ctxt, t: ty::t) -> ValueRef {\n }\n \n pub fn get_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n-    match ccx.tydescs.find(t) {\n+    match ccx.tydescs.find(&t) {\n       Some(inf) => inf,\n       _ => {\n         ccx.stats.n_static_tydescs += 1u;\n@@ -474,6 +473,7 @@ pub fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id,\n         let class_ty = ty::subst_tps(tcx, substs, None,\n                           ty::lookup_item_type(tcx, parent_id).ty);\n         let llty = type_of_dtor(ccx, class_ty);\n+        let name = name.to_managed(); // :-(\n         get_extern_fn(ccx.externs, ccx.llmod, name, lib::llvm::CCallConv,\n                       llty)\n     }\n@@ -494,8 +494,13 @@ pub fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: ~str) {\n // Used only for creating scalar comparison glue.\n pub enum scalar_type { nil_type, signed_int, unsigned_int, floating_point, }\n \n-pub fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n-                            t: ty::t, op: ast::binop) -> Result {\n+// NB: This produces an i1, not a Rust bool (i8).\n+pub fn compare_scalar_types(cx: block,\n+                            lhs: ValueRef,\n+                            rhs: ValueRef,\n+                            t: ty::t,\n+                            op: ast::binop)\n+                         -> Result {\n     let f = |a| compare_scalar_values(cx, lhs, rhs, a, op);\n \n     match ty::get(t).sty {\n@@ -521,8 +526,12 @@ pub fn compare_scalar_types(cx: block, lhs: ValueRef, rhs: ValueRef,\n \n \n // A helper function to do the actual comparison of scalar values.\n-pub fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n-                             nt: scalar_type, op: ast::binop) -> ValueRef {\n+pub fn compare_scalar_values(cx: block,\n+                             lhs: ValueRef,\n+                             rhs: ValueRef,\n+                             nt: scalar_type,\n+                             op: ast::binop)\n+                          -> ValueRef {\n     let _icx = cx.insn_ctxt(\"compare_scalar_values\");\n     fn die(cx: block) -> ! {\n         cx.tcx().sess.bug(~\"compare_scalar_values: must be a\\\n@@ -533,8 +542,8 @@ pub fn compare_scalar_values(cx: block, lhs: ValueRef, rhs: ValueRef,\n         // We don't need to do actual comparisons for nil.\n         // () == () holds but () < () does not.\n         match op {\n-          ast::eq | ast::le | ast::ge => return C_bool(true),\n-          ast::ne | ast::lt | ast::gt => return C_bool(false),\n+          ast::eq | ast::le | ast::ge => return C_i1(true),\n+          ast::ne | ast::lt | ast::gt => return C_i1(false),\n           // refinements would be nice\n           _ => die(cx)\n         }\n@@ -604,7 +613,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         let ccx = cx.ccx();\n         let mut cx = cx;\n         match ty::get(fn_ty).sty {\n-          ty::ty_fn(ref fn_ty) => {\n+          ty::ty_bare_fn(ref fn_ty) => {\n             let mut j = 0u;\n             let v_id = variant.id;\n             for vec::each(fn_ty.sig.inputs) |a| {\n@@ -766,12 +775,12 @@ pub fn null_env_ptr(bcx: block) -> ValueRef {\n \n pub fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     -> ValueRef {\n-    let name = csearch::get_symbol(ccx.sess.cstore, did);\n+    let name = csearch::get_symbol(ccx.sess.cstore, did).to_managed(); // Sad\n     match ty::get(t).sty {\n-      ty::ty_fn(_) => {\n+      ty::ty_bare_fn(_) | ty::ty_closure(_) => {\n         let llty = type_of_fn_from_ty(ccx, t);\n         return get_extern_fn(ccx.externs, ccx.llmod, name,\n-                          lib::llvm::CCallConv, llty);\n+                             lib::llvm::CCallConv, llty);\n       }\n       _ => {\n         let llty = type_of(ccx, t);\n@@ -804,27 +813,6 @@ pub fn get_discrim_val(cx: @crate_ctxt, span: span, enum_did: ast::def_id,\n     }\n }\n \n-pub fn lookup_discriminant(ccx: @crate_ctxt, vid: ast::def_id) -> ValueRef {\n-    unsafe {\n-        let _icx = ccx.insn_ctxt(\"lookup_discriminant\");\n-        match ccx.discrims.find(vid) {\n-            None => {\n-                // It's an external discriminant that we haven't seen yet.\n-                assert (vid.crate != ast::local_crate);\n-                let sym = csearch::get_symbol(ccx.sess.cstore, vid);\n-                let gvar = str::as_c_str(sym, |buf| {\n-                    llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n-                });\n-                lib::llvm::SetLinkage(gvar, lib::llvm::ExternalLinkage);\n-                llvm::LLVMSetGlobalConstant(gvar, True);\n-                ccx.discrims.insert(vid, gvar);\n-                return gvar;\n-            }\n-            Some(llval) => return llval,\n-        }\n-    }\n-}\n-\n pub fn invoke(bcx: block, llfn: ValueRef, +llargs: ~[ValueRef]) -> block {\n     let _icx = bcx.insn_ctxt(\"invoke_\");\n     if bcx.unreachable { return bcx; }\n@@ -1095,7 +1083,7 @@ pub fn init_local(bcx: block, local: @ast::local) -> block {\n         }\n     }\n \n-    let llptr = match bcx.fcx.lllocals.find(local.node.id) {\n+    let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n       Some(local_mem(v)) => v,\n       _ => { bcx.tcx().sess.span_bug(local.span,\n                         ~\"init_local: Someone forgot to document why it's\\\n@@ -1375,7 +1363,7 @@ pub fn with_scope_datumblock(bcx: block, opt_node_info: Option<node_info>,\n     DatumBlock {bcx: leave_block(bcx, scope_cx), datum: datum}\n }\n \n-pub fn block_locals(b: ast::blk, it: fn(@ast::local)) {\n+pub fn block_locals(b: &ast::blk, it: fn(@ast::local)) {\n     for vec::each(b.node.stmts) |s| {\n         match s.node {\n           ast::stmt_decl(d, _) => {\n@@ -1437,12 +1425,12 @@ pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef,\n       session::arch_x86 | session::arch_arm => ~\"llvm.memcpy.p0i8.p0i8.i32\",\n       session::arch_x86_64 => ~\"llvm.memcpy.p0i8.p0i8.i64\"\n     };\n-    let memcpy = ccx.intrinsics.get(key);\n+    let memcpy = ccx.intrinsics.get(&key);\n     let src_ptr = PointerCast(cx, src, T_ptr(T_i8()));\n     let dst_ptr = PointerCast(cx, dst, T_ptr(T_i8()));\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n     let align = C_i32(1i32);\n-    let volatile = C_bool(false);\n+    let volatile = C_i1(false);\n     Call(cx, memcpy, ~[dst_ptr, src_ptr, size, align, volatile]);\n }\n \n@@ -1484,12 +1472,12 @@ pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n         }\n     }\n \n-    let llintrinsicfn = ccx.intrinsics.get(intrinsic_key);\n+    let llintrinsicfn = ccx.intrinsics.get(&intrinsic_key);\n     let llptr = PointerCast(cx, llptr, T_ptr(T_i8()));\n     let llzeroval = C_u8(0);\n     let size = IntCast(cx, machine::llsize_of(ccx, llty), ccx.int_type);\n     let align = C_i32(1i32);\n-    let volatile = C_bool(false);\n+    let volatile = C_i1(false);\n     Call(cx, llintrinsicfn, ~[llptr, llzeroval, size, align, volatile]);\n }\n \n@@ -1739,8 +1727,8 @@ pub enum self_arg { impl_self(ty::t), impl_owned_self(ty::t), no_self, }\n // returned.\n pub fn trans_closure(ccx: @crate_ctxt,\n                      +path: path,\n-                     decl: ast::fn_decl,\n-                     body: ast::blk,\n+                     decl: &ast::fn_decl,\n+                     body: &ast::blk,\n                      llfndecl: ValueRef,\n                      ty_self: self_arg,\n                      +param_substs: Option<param_substs>,\n@@ -1803,8 +1791,8 @@ pub fn trans_closure(ccx: @crate_ctxt,\n // function.\n pub fn trans_fn(ccx: @crate_ctxt,\n                 +path: path,\n-                decl: ast::fn_decl,\n-                body: ast::blk,\n+                decl: &ast::fn_decl,\n+                body: &ast::blk,\n                 llfndecl: ValueRef,\n                 ty_self: self_arg,\n                 +param_substs: Option<param_substs>,\n@@ -1884,7 +1872,7 @@ pub fn trans_enum_variant(ccx: @crate_ctxt,\n         // If this argument to this function is a enum, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n-        let llarg = match fcx.llargs.find(va.id) {\n+        let llarg = match fcx.llargs.find(&va.id) {\n             Some(local_mem(x)) => x,\n             _ => die!(~\"trans_enum_variant: how do we know this works?\"),\n         };\n@@ -1930,7 +1918,7 @@ pub fn trans_tuple_struct(ccx: @crate_ctxt,\n \n     for fields.eachi |i, field| {\n         let lldestptr = GEPi(bcx, fcx.llretptr, [0, 0, i]);\n-        let llarg = match fcx.llargs.get(field.node.id) {\n+        let llarg = match fcx.llargs.get(&field.node.id) {\n             local_mem(x) => x,\n             _ => {\n                 ccx.tcx.sess.bug(~\"trans_tuple_struct: llarg wasn't \\\n@@ -1947,7 +1935,7 @@ pub fn trans_tuple_struct(ccx: @crate_ctxt,\n \n pub fn trans_struct_dtor(ccx: @crate_ctxt,\n                          +path: path,\n-                         body: ast::blk,\n+                         body: &ast::blk,\n                          dtor_id: ast::node_id,\n                          +psubsts: Option<param_substs>,\n                          hash_id: Option<mono_id>,\n@@ -1978,8 +1966,9 @@ pub fn trans_struct_dtor(ccx: @crate_ctxt,\n     ccx.monomorphized.insert(*h_id, lldecl);\n   }\n   /* Translate the dtor body */\n-  trans_fn(ccx, path, ast_util::dtor_dec(),\n-           body, lldecl, impl_self(class_ty), psubsts, dtor_id, None);\n+  let decl = ast_util::dtor_dec();\n+  trans_fn(ccx, path, &decl, body, lldecl,\n+           impl_self(class_ty), psubsts, dtor_id, None);\n   lldecl\n }\n \n@@ -2019,26 +2008,25 @@ pub fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n \n pub fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_item\");\n-    let path = match ccx.tcx.items.get(item.id) {\n+    let path = match ccx.tcx.items.get(&item.id) {\n         ast_map::node_item(_, p) => p,\n         // tjc: ?\n         _ => die!(~\"trans_item\"),\n     };\n     match /*bad*/copy item.node {\n-      // XXX: Bad copies.\n-      ast::item_fn(copy decl, purity, copy tps, ref body) => {\n+      ast::item_fn(ref decl, purity, ref tps, ref body) => {\n         if purity == ast::extern_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_foreign_fn(ccx,\n                                      vec::append(\n                                          /*bad*/copy *path,\n                                          ~[path_name(item.ident)]),\n-                                     decl, (*body), llfndecl, item.id);\n+                                      decl, body, llfndecl, item.id);\n         } else if tps.is_empty() {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n                      vec::append(/*bad*/copy *path, ~[path_name(item.ident)]),\n-                     decl, (*body), llfndecl, no_self, None, item.id, None);\n+                     decl, body, llfndecl, no_self, None, item.id, None);\n         } else {\n             for vec::each((*body).node.stmts) |stmt| {\n                 match stmt.node {\n@@ -2090,7 +2078,7 @@ pub fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n                         id: ast::node_id) {\n     // Translate the destructor.\n     do option::iter(&struct_def.dtor) |dtor| {\n-        trans_struct_dtor(ccx, /*bad*/copy *path, dtor.node.body,\n+        trans_struct_dtor(ccx, /*bad*/copy *path, &dtor.node.body,\n                          dtor.node.id, None, None, local_def(id));\n     };\n \n@@ -2275,7 +2263,7 @@ pub fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n \n pub fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n     vec::append(\n-        /*bad*/copy *match ccx.tcx.items.get(i.id) {\n+        /*bad*/copy *match ccx.tcx.items.get(&i.id) {\n             ast_map::node_item(_, p) => p,\n                 // separate map for paths?\n             _ => die!(~\"item_path\")\n@@ -2291,7 +2279,7 @@ pub fn get_dtor_symbol(ccx: @crate_ctxt,\n                        +substs: Option<param_substs>)\n                     -> ~str {\n   let t = ty::node_id_to_type(ccx.tcx, id);\n-  match ccx.item_symbols.find(id) {\n+  match ccx.item_symbols.find(&id) {\n      Some(ref s) => (/*bad*/copy *s),\n      None if substs.is_none() => {\n        let s = mangle_exported_name(\n@@ -2326,12 +2314,12 @@ pub fn get_dtor_symbol(ccx: @crate_ctxt,\n pub fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n     debug!(\"get_item_val(id=`%?`)\", id);\n     let tcx = ccx.tcx;\n-    match ccx.item_vals.find(id) {\n+    match ccx.item_vals.find(&id) {\n       Some(v) => v,\n       None => {\n \n         let mut exprt = false;\n-        let val = match ccx.tcx.items.get(id) {\n+        let val = match ccx.tcx.items.get(&id) {\n           ast_map::node_item(i, pth) => {\n             let my_path = vec::append(/*bad*/copy *pth,\n                                       ~[path_name(i.ident)]);\n@@ -2770,7 +2758,7 @@ pub fn declare_dbg_intrinsics(llmod: ModuleRef,\n \n pub fn trap(bcx: block) {\n     let v: ~[ValueRef] = ~[];\n-    match bcx.ccx().intrinsics.find(~\"llvm.trap\") {\n+    match bcx.ccx().intrinsics.find(&~\"llvm.trap\") {\n       Some(x) => { Call(bcx, x, v); },\n       _ => bcx.sess().bug(~\"unbound llvm.trap in trap\")\n     }"}, {"sha": "24e9d967facd28913cb595ff6bfa0d75cc00ce02", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -70,7 +70,7 @@ pub fn count_insn(cx: block, category: &str) {\n         i = 0u;\n         while i < len {\n             let e = /*bad*/copy v[i];\n-            i = mm.get(/*bad*/ copy e);\n+            i = mm.get(&e);\n             s += ~\"/\";\n             s += e;\n             i += 1u;\n@@ -79,7 +79,7 @@ pub fn count_insn(cx: block, category: &str) {\n         s += ~\"/\";\n         s += category;\n \n-        let n = match h.find(/*bad*/ copy s) {\n+        let n = match h.find(&s) {\n           Some(n) => n,\n           _ => 0u\n         };"}, {"sha": "4af74b3623f5ada7108f24dd8a9236d19b04dfad", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -70,7 +70,7 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n             return trans_def(bcx, bcx.def(expr.id), expr);\n         }\n         ast::expr_field(base, _, _) => {\n-            match bcx.ccx().maps.method_map.find(expr.id) {\n+            match bcx.ccx().maps.method_map.find(&expr.id) {\n                 Some(ref origin) => { // An impl method\n                     return meth::trans_method_callee(bcx, expr.id,\n                                                      base, (*origin));\n@@ -208,7 +208,7 @@ pub fn trans_fn_ref_with_vtables(\n     // Modify the def_id if this is a default method; we want to be\n     // monomorphizing the trait's code.\n     let (def_id, opt_impl_did) =\n-            match tcx.provided_method_sources.find(def_id) {\n+            match tcx.provided_method_sources.find(&def_id) {\n         None => (def_id, None),\n         Some(source) => (source.method_id, Some(source.impl_id))\n     };\n@@ -234,7 +234,7 @@ pub fn trans_fn_ref_with_vtables(\n     } else if def_id.crate == ast::local_crate {\n         let map_node = session::expect(\n             ccx.sess,\n-            ccx.tcx.items.find(def_id.node),\n+            ccx.tcx.items.find(&def_id.node),\n             || fmt!(\"local item should be in ast map\"));\n \n         match map_node {\n@@ -313,7 +313,7 @@ pub fn trans_method_call(in_cx: block,\n         node_id_type(in_cx, call_ex.callee_id),\n         expr_ty(in_cx, call_ex),\n         |cx| {\n-            match cx.ccx().maps.method_map.find(call_ex.id) {\n+            match cx.ccx().maps.method_map.find(&call_ex.id) {\n                 Some(ref origin) => {\n                     meth::trans_method_callee(cx,\n                                               call_ex.callee_id,\n@@ -438,7 +438,9 @@ pub fn trans_call_inner(\n             let flag = alloca(bcx, T_bool());\n             Store(bcx, C_bool(false), flag);\n             Some(flag)\n-        } else { None };\n+        } else {\n+            None\n+        };\n \n         let (llfn, llenv) = unsafe {\n             match callee.data {\n@@ -506,7 +508,8 @@ pub fn trans_call_inner(\n         if ty::type_is_bot(ret_ty) {\n             Unreachable(bcx);\n         } else if ret_in_loop {\n-            bcx = do with_cond(bcx, Load(bcx, ret_flag.get())) |bcx| {\n+            let ret_flag_result = bool_to_i1(bcx, Load(bcx, ret_flag.get()));\n+            bcx = do with_cond(bcx, ret_flag_result) |bcx| {\n                 do option::iter(&copy bcx.fcx.loop_ret) |lret| {\n                     Store(bcx, C_bool(true), lret.flagptr);\n                     Store(bcx, C_bool(false), bcx.fcx.llretptr);\n@@ -624,18 +627,17 @@ pub fn trans_arg_expr(bcx: block,\n         Some(_) => {\n             match arg_expr.node {\n                 ast::expr_loop_body(\n-                    // XXX: Bad copy.\n-                    blk@@ast::expr {\n-                        node: ast::expr_fn_block(copy decl, ref body),\n+                    blk @ @ast::expr {\n+                        node: ast::expr_fn_block(ref decl, ref body),\n                         _\n                     }) =>\n                 {\n                     let scratch_ty = expr_ty(bcx, arg_expr);\n                     let scratch = alloc_ty(bcx, scratch_ty);\n                     let arg_ty = expr_ty(bcx, arg_expr);\n-                    let proto = ty::ty_fn_proto(arg_ty);\n+                    let sigil = ty::ty_closure_sigil(arg_ty);\n                     let bcx = closure::trans_expr_fn(\n-                        bcx, proto, decl, /*bad*/copy *body, arg_expr.id,\n+                        bcx, sigil, decl, body, arg_expr.id,\n                         blk.id, Some(ret_flag), expr::SaveIn(scratch));\n                     DatumBlock {bcx: bcx,\n                                 datum: Datum {val: scratch,"}, {"sha": "c70425da9fa39cdfbc57be8ba0fd5b263d036df8", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 55, "deletions": 63, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -160,7 +160,7 @@ pub fn mk_closure_tys(tcx: ty::ctxt,\n     return cdata_ty;\n }\n \n-pub fn allocate_cbox(bcx: block, proto: ast::Proto, cdata_ty: ty::t)\n+pub fn allocate_cbox(bcx: block, sigil: ast::Sigil, cdata_ty: ty::t)\n                   -> Result {\n     let _icx = bcx.insn_ctxt(\"closure::allocate_cbox\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n@@ -176,23 +176,19 @@ pub fn allocate_cbox(bcx: block, proto: ast::Proto, cdata_ty: ty::t)\n     }\n \n     // Allocate and initialize the box:\n-    match proto {\n-        ast::ProtoBox => {\n+    match sigil {\n+        ast::ManagedSigil => {\n             malloc_raw(bcx, cdata_ty, heap_shared)\n         }\n-        ast::ProtoUniq => {\n+        ast::OwnedSigil => {\n             malloc_raw(bcx, cdata_ty, heap_exchange)\n         }\n-        ast::ProtoBorrowed => {\n+        ast::BorrowedSigil => {\n             let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n             let llbox = base::alloc_ty(bcx, cbox_ty);\n             nuke_ref_count(bcx, llbox);\n             rslt(bcx, llbox)\n         }\n-        ast::ProtoBare => {\n-            let cdata_llty = type_of(bcx.ccx(), cdata_ty);\n-            rslt(bcx, C_null(cdata_llty))\n-        }\n     }\n }\n \n@@ -208,7 +204,7 @@ pub type closure_result = {\n // Otherwise, it is stack allocated and copies pointers to the upvars.\n pub fn store_environment(bcx: block,\n                          bound_values: ~[EnvValue],\n-                         proto: ast::Proto) -> closure_result {\n+                         sigil: ast::Sigil) -> closure_result {\n     let _icx = bcx.insn_ctxt(\"closure::store_environment\");\n     let ccx = bcx.ccx(), tcx = ccx.tcx;\n \n@@ -217,7 +213,7 @@ pub fn store_environment(bcx: block,\n     let cdata_ty = mk_closure_tys(tcx, copy bound_values);\n \n     // allocate closure in the heap\n-    let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, proto, cdata_ty);\n+    let Result {bcx: bcx, val: llbox} = allocate_cbox(bcx, sigil, cdata_ty);\n     let mut temp_cleanups = ~[];\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n@@ -265,7 +261,7 @@ pub fn store_environment(bcx: block,\n // collects the upvars and packages them up for store_environment.\n pub fn build_closure(bcx0: block,\n                      cap_vars: &[moves::CaptureVar],\n-                     proto: ast::Proto,\n+                     sigil: ast::Sigil,\n                      include_ret_handle: Option<ValueRef>) -> closure_result {\n     let _icx = bcx0.insn_ctxt(\"closure::build_closure\");\n     // If we need to, package up the iterator body to call\n@@ -279,7 +275,7 @@ pub fn build_closure(bcx0: block,\n         let datum = expr::trans_local_var(bcx, cap_var.def);\n         match cap_var.mode {\n             moves::CapRef => {\n-                assert proto == ast::ProtoBorrowed;\n+                assert sigil == ast::BorrowedSigil;\n                 env_vals.push(EnvValue {action: EnvRef,\n                                         datum: datum});\n             }\n@@ -316,7 +312,7 @@ pub fn build_closure(bcx0: block,\n                                 datum: ret_datum});\n     }\n \n-    return store_environment(bcx, env_vals, proto);\n+    return store_environment(bcx, env_vals, sigil);\n }\n \n // Given an enclosing block context, a new function context, a closure type,\n@@ -326,7 +322,7 @@ pub fn load_environment(fcx: fn_ctxt,\n                         cdata_ty: ty::t,\n                         cap_vars: &[moves::CaptureVar],\n                         load_ret_handle: bool,\n-                        proto: ast::Proto) {\n+                        sigil: ast::Sigil) {\n     let _icx = fcx.insn_ctxt(\"closure::load_environment\");\n \n     let llloadenv = match fcx.llloadenv {\n@@ -352,9 +348,9 @@ pub fn load_environment(fcx: fn_ctxt,\n     let mut i = 0u;\n     for cap_vars.each |cap_var| {\n         let mut upvarptr = GEPi(bcx, llcdata, [0u, i]);\n-        match proto {\n-            ast::ProtoBorrowed => { upvarptr = Load(bcx, upvarptr); }\n-            ast::ProtoBox | ast::ProtoUniq | ast::ProtoBare => {}\n+        match sigil {\n+            ast::BorrowedSigil => { upvarptr = Load(bcx, upvarptr); }\n+            ast::ManagedSigil | ast::OwnedSigil => {}\n         }\n         let def_id = ast_util::def_id_of_def(cap_var.def);\n         fcx.llupvars.insert(def_id.node, upvarptr);\n@@ -369,9 +365,9 @@ pub fn load_environment(fcx: fn_ctxt,\n }\n \n pub fn trans_expr_fn(bcx: block,\n-                     proto: ast::Proto,\n-                     +decl: ast::fn_decl,\n-                     +body: ast::blk,\n+                     sigil: ast::Sigil,\n+                     decl: &ast::fn_decl,\n+                     body: &ast::blk,\n                      outer_id: ast::node_id,\n                      user_id: ast::node_id,\n                      is_loop_body: Option<Option<ValueRef>>,\n@@ -381,7 +377,7 @@ pub fn trans_expr_fn(bcx: block,\n      *\n      * Translates the body of a closure expression.\n      *\n-     * - `proto`\n+     * - `sigil`\n      * - `decl`\n      * - `body`\n      * - `outer_id`: The id of the closure expression with the correct\n@@ -417,53 +413,49 @@ pub fn trans_expr_fn(bcx: block,\n                                                  ~\"expr_fn\");\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n-    let Result {bcx: bcx, val: closure} = match proto {\n-        ast::ProtoBorrowed | ast::ProtoBox | ast::ProtoUniq => {\n-            let cap_vars = ccx.maps.capture_map.get(user_id);\n+    let Result {bcx: bcx, val: closure} = match sigil {\n+        ast::BorrowedSigil | ast::ManagedSigil | ast::OwnedSigil => {\n+            let cap_vars = ccx.maps.capture_map.get(&user_id);\n             let ret_handle = match is_loop_body {Some(x) => x,\n                                                  None => None};\n-            let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, proto,\n+            let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, sigil,\n                                                        ret_handle);\n             trans_closure(ccx, sub_path, decl,\n                           body, llfn, no_self,\n                           /*bad*/ copy bcx.fcx.param_substs, user_id, None,\n                           |fcx| load_environment(fcx, cdata_ty, cap_vars,\n-                                                 ret_handle.is_some(), proto),\n+                                                 ret_handle.is_some(), sigil),\n                           |bcx| {\n                               if is_loop_body.is_some() {\n                                   Store(bcx, C_bool(true), bcx.fcx.llretptr);\n                               }\n                           });\n             rslt(bcx, llbox)\n         }\n-        ast::ProtoBare => {\n-            trans_closure(ccx, sub_path, decl, body, llfn, no_self, None,\n-                          user_id, None, |_fcx| { }, |_bcx| { });\n-            rslt(bcx, C_null(T_opaque_box_ptr(ccx)))\n-        }\n     };\n     fill_fn_pair(bcx, dest_addr, llfn, closure);\n \n     return bcx;\n }\n \n-pub fn make_fn_glue(cx: block,\n-                    v: ValueRef,\n-                    t: ty::t,\n-                    glue_fn: fn@(block, v: ValueRef, t: ty::t) -> block)\n-                 -> block {\n-    let _icx = cx.insn_ctxt(\"closure::make_fn_glue\");\n+pub fn make_closure_glue(\n+    cx: block,\n+    v: ValueRef,\n+    t: ty::t,\n+    glue_fn: fn@(block, v: ValueRef, t: ty::t) -> block) -> block\n+{\n+    let _icx = cx.insn_ctxt(\"closure::make_closure_glue\");\n     let bcx = cx;\n     let tcx = cx.tcx();\n \n-    let proto = ty::ty_fn_proto(t);\n-    match proto {\n-        ast::ProtoBare | ast::ProtoBorrowed => bcx,\n-        ast::ProtoUniq | ast::ProtoBox => {\n+    let sigil = ty::ty_closure_sigil(t);\n+    match sigil {\n+        ast::BorrowedSigil => bcx,\n+        ast::OwnedSigil | ast::ManagedSigil => {\n             let box_cell_v = GEPi(cx, v, [0u, abi::fn_field_box]);\n             let box_ptr_v = Load(cx, box_cell_v);\n             do with_cond(cx, IsNotNull(cx, box_ptr_v)) |bcx| {\n-                let closure_ty = ty::mk_opaque_closure_ptr(tcx, proto);\n+                let closure_ty = ty::mk_opaque_closure_ptr(tcx, sigil);\n                 glue_fn(bcx, box_cell_v, closure_ty)\n             }\n         }\n@@ -472,20 +464,20 @@ pub fn make_fn_glue(cx: block,\n \n pub fn make_opaque_cbox_take_glue(\n     bcx: block,\n-    proto: ast::Proto,\n+    sigil: ast::Sigil,\n     cboxptr: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n     // Easy cases:\n     let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_take_glue\");\n-    match proto {\n-        ast::ProtoBare | ast::ProtoBorrowed => {\n+    match sigil {\n+        ast::BorrowedSigil => {\n             return bcx;\n         }\n-        ast::ProtoBox => {\n+        ast::ManagedSigil => {\n             glue::incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr));\n             return bcx;\n         }\n-        ast::ProtoUniq => {\n+        ast::OwnedSigil => {\n             /* hard case: fallthrough to code below */\n         }\n     }\n@@ -531,36 +523,36 @@ pub fn make_opaque_cbox_take_glue(\n \n pub fn make_opaque_cbox_drop_glue(\n     bcx: block,\n-    proto: ast::Proto,\n+    sigil: ast::Sigil,\n     cboxptr: ValueRef)     // ptr to the opaque closure\n     -> block {\n     let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_drop_glue\");\n-    match proto {\n-        ast::ProtoBare | ast::ProtoBorrowed => bcx,\n-        ast::ProtoBox => {\n+    match sigil {\n+        ast::BorrowedSigil => bcx,\n+        ast::ManagedSigil => {\n             glue::decr_refcnt_maybe_free(\n                 bcx, Load(bcx, cboxptr),\n-                ty::mk_opaque_closure_ptr(bcx.tcx(), proto))\n+                ty::mk_opaque_closure_ptr(bcx.tcx(), sigil))\n         }\n-        ast::ProtoUniq => {\n+        ast::OwnedSigil => {\n             glue::free_ty(\n                 bcx, cboxptr,\n-                ty::mk_opaque_closure_ptr(bcx.tcx(), proto))\n+                ty::mk_opaque_closure_ptr(bcx.tcx(), sigil))\n         }\n     }\n }\n \n pub fn make_opaque_cbox_free_glue(\n     bcx: block,\n-    proto: ast::Proto,\n+    sigil: ast::Sigil,\n     cbox: ValueRef)     // ptr to ptr to the opaque closure\n     -> block {\n     let _icx = bcx.insn_ctxt(\"closure::make_opaque_cbox_free_glue\");\n-    match proto {\n-        ast::ProtoBare | ast::ProtoBorrowed => {\n+    match sigil {\n+        ast::BorrowedSigil => {\n             return bcx;\n         }\n-        ast::ProtoBox | ast::ProtoUniq => {\n+        ast::ManagedSigil | ast::OwnedSigil => {\n             /* hard cases: fallthrough to code below */\n         }\n     }\n@@ -580,10 +572,10 @@ pub fn make_opaque_cbox_free_glue(\n                                     abi::tydesc_field_drop_glue, None);\n \n         // Free the ty descr (if necc) and the box itself\n-        match proto {\n-            ast::ProtoBox => glue::trans_free(bcx, cbox),\n-            ast::ProtoUniq => glue::trans_unique_free(bcx, cbox),\n-            ast::ProtoBare | ast::ProtoBorrowed => {\n+        match sigil {\n+            ast::ManagedSigil => glue::trans_free(bcx, cbox),\n+            ast::OwnedSigil => glue::trans_unique_free(bcx, cbox),\n+            ast::BorrowedSigil => {\n                 bcx.sess().bug(~\"impossible\")\n             }\n         }"}, {"sha": "f12bb0eb0a647c8a3725bec4d2fe166904200c2c", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -152,13 +152,15 @@ pub fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n     }\n }\n \n+type ExternMap = HashMap<@str, ValueRef>;\n+\n // Crate context.  Every crate we compile has one of these.\n pub struct crate_ctxt {\n      sess: session::Session,\n      llmod: ModuleRef,\n      td: target_data,\n      tn: type_names,\n-     externs: HashMap<~str, ValueRef>,\n+     externs: ExternMap,\n      intrinsics: HashMap<~str, ValueRef>,\n      item_vals: HashMap<ast::node_id, ValueRef>,\n      exp_map2: resolve::ExportMap2,\n@@ -700,7 +702,7 @@ pub impl block {\n     }\n \n     fn def(nid: ast::node_id) -> ast::def {\n-        match self.tcx().def_map.find(nid) {\n+        match self.tcx().def_map.find(&nid) {\n             Some(v) => v,\n             None => {\n                 self.tcx().sess.bug(fmt!(\n@@ -759,7 +761,7 @@ pub fn T_f32() -> TypeRef { unsafe { return llvm::LLVMFloatType(); } }\n \n pub fn T_f64() -> TypeRef { unsafe { return llvm::LLVMDoubleType(); } }\n \n-pub fn T_bool() -> TypeRef { return T_i1(); }\n+pub fn T_bool() -> TypeRef { return T_i8(); }\n \n pub fn T_int(targ_cfg: @session::config) -> TypeRef {\n     return match targ_cfg.arch {\n@@ -1109,6 +1111,10 @@ pub fn C_bool(b: bool) -> ValueRef {\n     C_integral(T_bool(), if b { 1u64 } else { 0u64 }, False)\n }\n \n+pub fn C_i1(b: bool) -> ValueRef {\n+    return C_integral(T_i1(), if b { 1 } else { 0 }, False);\n+}\n+\n pub fn C_i32(i: i32) -> ValueRef {\n     return C_integral(T_i32(), i as u64, True);\n }\n@@ -1134,7 +1140,7 @@ pub fn C_u8(i: uint) -> ValueRef {\n // our boxed-and-length-annotated strings.\n pub fn C_cstr(cx: @crate_ctxt, +s: ~str) -> ValueRef {\n     unsafe {\n-        match cx.const_cstr_cache.find(/*bad*/copy s) {\n+        match cx.const_cstr_cache.find(&s) {\n           Some(llval) => return llval,\n           None => ()\n         }\n@@ -1356,7 +1362,7 @@ pub fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n \n pub fn node_vtables(bcx: block, id: ast::node_id)\n                  -> Option<typeck::vtable_res> {\n-    let raw_vtables = bcx.ccx().maps.vtable_map.find(id);\n+    let raw_vtables = bcx.ccx().maps.vtable_map.find(&id);\n     raw_vtables.map(\n         |vts| resolve_vtables_in_fn_ctxt(bcx.fcx, *vts))\n }\n@@ -1435,6 +1441,11 @@ pub fn struct_dtor() -> [uint * 2] {\n     [0, 1]\n }\n \n+// Casts a Rust bool value to an i1.\n+pub fn bool_to_i1(bcx: block, llval: ValueRef) -> ValueRef {\n+    build::ICmp(bcx, lib::llvm::IntNE, llval, C_bool(false))\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "34f1f1f2314fb8b8ce3d306e6c848d78d718306e", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -82,7 +82,7 @@ pub fn const_vec(cx: @crate_ctxt, e: @ast::expr, es: &[@ast::expr])\n \n pub fn const_deref(cx: @crate_ctxt, v: ValueRef) -> ValueRef {\n     unsafe {\n-        let v = match cx.const_globals.find(v as int) {\n+        let v = match cx.const_globals.find(&(v as int)) {\n             Some(v) => v,\n             None => v\n         };\n@@ -127,7 +127,7 @@ pub fn get_const_val(cx: @crate_ctxt, def_id: ast::def_id) -> ValueRef {\n         cx.tcx.sess.bug(~\"cross-crate constants\");\n     }\n     if !cx.const_values.contains_key_ref(&def_id.node) {\n-        match cx.tcx.items.get(def_id.node) {\n+        match cx.tcx.items.get(&def_id.node) {\n             ast_map::node_item(@ast::item {\n                 node: ast::item_const(_, subexpr), _\n             }, _) => {\n@@ -136,7 +136,7 @@ pub fn get_const_val(cx: @crate_ctxt, def_id: ast::def_id) -> ValueRef {\n             _ => cx.tcx.sess.bug(~\"expected a const to be an item\")\n         }\n     }\n-    cx.const_values.get(def_id.node)\n+    cx.const_values.get(&def_id.node)\n }\n \n pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n@@ -204,7 +204,18 @@ pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n               ast::box(_)  |\n               ast::uniq(_) |\n               ast::deref  => const_deref(cx, te),\n-              ast::not    => llvm::LLVMConstNot(te),\n+              ast::not    => {\n+                match ty::get(ty).sty {\n+                    ty::ty_bool => {\n+                        // Somewhat questionable, but I believe this is\n+                        // correct.\n+                        let te = llvm::LLVMConstTrunc(te, T_i1());\n+                        let te = llvm::LLVMConstNot(te);\n+                        llvm::LLVMConstZExt(te, T_bool())\n+                    }\n+                    _ => llvm::LLVMConstNot(te),\n+                }\n+              }\n               ast::neg    => {\n                 if is_float { llvm::LLVMConstFNeg(te) }\n                 else        { llvm::LLVMConstNeg(te) }\n@@ -402,7 +413,7 @@ pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n           }\n           ast::expr_path(pth) => {\n             assert pth.types.len() == 0;\n-            match cx.tcx.def_map.find(e.id) {\n+            match cx.tcx.def_map.find(&e.id) {\n                 Some(ast::def_fn(def_id, purity)) => {\n                     assert ast_util::is_local(def_id);\n                     let f = base::get_item_val(cx, def_id.node);\n@@ -437,7 +448,7 @@ pub fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n             }\n           }\n           ast::expr_call(callee, args, _) => {\n-            match cx.tcx.def_map.find(callee.id) {\n+            match cx.tcx.def_map.find(&callee.id) {\n                 Some(ast::def_struct(def_id)) => {\n                     let ety = ty::expr_ty(cx.tcx, e);\n                     let llty = type_of::type_of(cx, ety);\n@@ -482,7 +493,7 @@ pub fn trans_const(ccx: @crate_ctxt, _e: @ast::expr, id: ast::node_id) {\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = ccx.const_values.get(id);\n+        let v = ccx.const_values.get(&id);\n         llvm::LLVMSetInitializer(g, v);\n         llvm::LLVMSetGlobalConstant(g, True);\n     }"}, {"sha": "0933eedd5e4bb0e91ef96b569f6897ca5f947c60", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -23,7 +23,7 @@ pub fn macros() {\n     include!(\"macros.rs\");\n }\n \n-pub fn trans_block(bcx: block, b: ast::blk, dest: expr::Dest) -> block {\n+pub fn trans_block(bcx: block, b: &ast::blk, dest: expr::Dest) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_block\");\n     let mut bcx = bcx;\n     do block_locals(b) |local| {\n@@ -47,7 +47,7 @@ pub fn trans_block(bcx: block, b: ast::blk, dest: expr::Dest) -> block {\n \n pub fn trans_if(bcx: block,\n             cond: @ast::expr,\n-            thn: ast::blk,\n+            thn: &ast::blk,\n             els: Option<@ast::expr>,\n             dest: expr::Dest)\n          -> block {\n@@ -62,6 +62,8 @@ pub fn trans_if(bcx: block,\n \n     let then_bcx_in = scope_block(bcx, thn.info(), ~\"then\");\n     let else_bcx_in = scope_block(bcx, els.info(), ~\"else\");\n+\n+    let cond_val = bool_to_i1(bcx, cond_val);\n     CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n \n     debug!(\"then_bcx_in=%s, else_bcx_in=%s\",\n@@ -80,10 +82,10 @@ pub fn trans_if(bcx: block,\n         match elexpr.node {\n           ast::expr_if(_, _, _) => {\n             let elseif_blk = ast_util::block_from_expr(elexpr);\n-            trans_block(else_bcx_in, elseif_blk, dest)\n+            trans_block(else_bcx_in, &elseif_blk, dest)\n           }\n           ast::expr_block(ref blk) => {\n-            trans_block(else_bcx_in, (*blk), dest)\n+            trans_block(else_bcx_in, blk, dest)\n           }\n           // would be nice to have a constraint on ifs\n           _ => bcx.tcx().sess.bug(~\"strange alternative in if\")\n@@ -112,7 +114,7 @@ pub fn join_blocks(parent_bcx: block, in_cxs: ~[block]) -> block {\n     return out;\n }\n \n-pub fn trans_while(bcx: block, cond: @ast::expr, body: ast::blk) -> block {\n+pub fn trans_while(bcx: block, cond: @ast::expr, body: &ast::blk) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_while\");\n     let next_bcx = sub_block(bcx, ~\"while next\");\n \n@@ -139,6 +141,7 @@ pub fn trans_while(bcx: block, cond: @ast::expr, body: ast::blk) -> block {\n     // compile the condition\n     let Result {bcx: cond_bcx_out, val: cond_val} =\n         expr::trans_to_datum(cond_bcx_in, cond).to_result();\n+    let cond_val = bool_to_i1(cond_bcx_out, cond_val);\n     let cond_bcx_out =\n         trans_block_cleanups(cond_bcx_out, block_cleanups(cond_bcx_in));\n     CondBr(cond_bcx_out, cond_val, body_bcx_in.llbb, next_bcx.llbb);\n@@ -151,7 +154,7 @@ pub fn trans_while(bcx: block, cond: @ast::expr, body: ast::blk) -> block {\n }\n \n pub fn trans_loop(bcx:block,\n-                  body: ast::blk,\n+                  body: &ast::blk,\n                   opt_label: Option<ident>)\n                -> block {\n     let _icx = bcx.insn_ctxt(\"trans_loop\");\n@@ -184,7 +187,7 @@ pub fn trans_log(log_ex: @ast::expr,\n     let modname = path_str(ccx.sess, copy modpath);\n \n     let global = if ccx.module_data.contains_key_ref(&modname) {\n-        ccx.module_data.get(modname)\n+        ccx.module_data.get(&modname)\n     } else {\n         let s = link::mangle_internal_name_by_path_and_seq(\n             ccx, modpath, ~\"loglevel\");\n@@ -324,6 +327,7 @@ pub fn trans_check_expr(bcx: block,\n             expr::trans_to_datum(bcx, pred_expr).to_result()\n         }\n     };\n+    let val = bool_to_i1(bcx, val);\n     do with_cond(bcx, Not(bcx, val)) |bcx| {\n         trans_fail(bcx, Some(pred_expr.span), /*bad*/copy expr_str)\n     }"}, {"sha": "af966e4df822a613036416943644d9d3e742a1e4", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -627,15 +627,15 @@ pub impl Datum {\n         //\n         // (Note: root'd values are always boxes)\n         let key = root_map_key { id: expr_id, derefs: derefs };\n-        let bcx = match ccx.maps.root_map.find(key) {\n+        let bcx = match ccx.maps.root_map.find(&key) {\n             None => bcx,\n             Some(root_info) => self.root(bcx, root_info)\n         };\n \n         // Perform the write guard, if necessary.\n         //\n         // (Note: write-guarded values are always boxes)\n-        let bcx = match ccx.maps.write_guard_map.find(key) {\n+        let bcx = match ccx.maps.write_guard_map.find(&key) {\n             None => bcx,\n             Some(_) => self.perform_write_guard(bcx)\n         };"}, {"sha": "ff842b5b4bed0c97be1132585506c6928e88f525", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -77,7 +77,7 @@ fn lli64(val: int) -> ValueRef {\n     C_i64(val as i64)\n }\n fn lli1(bval: bool) -> ValueRef {\n-    C_bool(bval)\n+    C_i1(bval)\n }\n fn llmdnode(elems: ~[ValueRef]) -> ValueRef {\n     unsafe {\n@@ -118,7 +118,7 @@ pub fn mk_ctxt(+crate: ~str, intr: @ident_interner) -> debug_ctxt {\n \n fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n     let existing = if cache.contains_key_ref(&mdtag) {\n-        cache.get(mdtag)\n+        cache.get(&mdtag)\n     } else {\n         ~[]\n     };\n@@ -177,7 +177,7 @@ fn cached_metadata<T: Copy>(cache: metadata_cache,\n                          -> Option<T> {\n     unsafe {\n         if cache.contains_key_ref(&mdtag) {\n-            let items = cache.get(mdtag);\n+            let items = cache.get(&mdtag);\n             for items.each |item| {\n                 let md: T = md_from_metadata::<T>(*item);\n                 if eq_fn(md) {\n@@ -289,7 +289,7 @@ fn create_block(cx: block) -> @metadata<block_md> {\n         Some(bcx) => create_block(bcx).node\n     };\n     let file_node = create_file(cx.ccx(), fname);\n-    let unique_id = match cache.find(LexicalBlockTag) {\n+    let unique_id = match cache.find(&LexicalBlockTag) {\n       option::Some(v) => vec::len(v) as int,\n       option::None => 0\n     };\n@@ -679,22 +679,22 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n         let mdval = @{node: mdnode, data: {id: local.node.id}};\n         update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n \n-        let llptr = match bcx.fcx.lllocals.find(local.node.id) {\n+        let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n           option::Some(local_mem(v)) => v,\n           option::Some(_) => {\n             bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n                     something weird\");\n           }\n           option::None => {\n-            match bcx.fcx.lllocals.get(local.node.pat.id) {\n+            match bcx.fcx.lllocals.get(&local.node.pat.id) {\n               local_imm(v) => v,\n               _ => bcx.tcx().sess.span_bug(local.span, ~\"local is bound to \\\n                                                          something weird\")\n             }\n           }\n         };\n         let declargs = ~[llmdnode(~[llptr]), mdnode];\n-        trans::build::Call(bcx, cx.intrinsics.get(~\"llvm.dbg.declare\"),\n+        trans::build::Call(bcx, cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n                            declargs);\n         return mdval;\n     }\n@@ -731,12 +731,12 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n                 let mdval = @{node: mdnode, data: {id: arg.id}};\n                 update_cache(cache, tg, argument_metadata(mdval));\n \n-                let llptr = match fcx.llargs.get(arg.id) {\n+                let llptr = match fcx.llargs.get(&arg.id) {\n                   local_mem(v) | local_imm(v) => v,\n                 };\n                 let declargs = ~[llmdnode(~[llptr]), mdnode];\n                 trans::build::Call(bcx,\n-                                   cx.intrinsics.get(~\"llvm.dbg.declare\"),\n+                                   cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n                                    declargs);\n                 return Some(mdval);\n             }\n@@ -774,7 +774,7 @@ pub fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n     let sp = fcx.span.get();\n     log(debug, cx.sess.codemap.span_to_str(sp));\n \n-    let (ident, ret_ty, id) = match cx.tcx.items.get(fcx.id) {\n+    let (ident, ret_ty, id) = match cx.tcx.items.get(&fcx.id) {\n       ast_map::node_item(item, _) => {\n         match /*bad*/copy item.node {\n           ast::item_fn(decl, _, _, _) => {"}, {"sha": "f2da47eb0eccaf4b16b2cddd1c42813d961f54c1", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 57, "deletions": 70, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -185,7 +185,7 @@ fn drop_and_cancel_clean(bcx: block, dat: Datum) -> block {\n \n pub fn trans_to_datum(bcx: block, expr: @ast::expr) -> DatumBlock {\n     debug!(\"trans_to_datum(expr=%s)\", bcx.expr_to_str(expr));\n-    return match bcx.tcx().adjustments.find(expr.id) {\n+    return match bcx.tcx().adjustments.find(&expr.id) {\n         None => {\n             trans_to_datum_unadjusted(bcx, expr)\n         }\n@@ -329,7 +329,7 @@ fn trans_lvalue(bcx: block, expr: @ast::expr) -> DatumBlock {\n      * instead, but sometimes we call trans_lvalue() directly as a\n      * means of asserting that a particular expression is an lvalue. */\n \n-    return match bcx.tcx().adjustments.find(expr.id) {\n+    return match bcx.tcx().adjustments.find(&expr.id) {\n         None => trans_lvalue_unadjusted(bcx, expr),\n         Some(_) => {\n             bcx.sess().span_bug(\n@@ -475,10 +475,10 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n             return controlflow::trans_check_expr(bcx, expr, a, ~\"Assertion\");\n         }\n         ast::expr_while(cond, ref body) => {\n-            return controlflow::trans_while(bcx, cond, (*body));\n+            return controlflow::trans_while(bcx, cond, body);\n         }\n         ast::expr_loop(ref body, opt_label) => {\n-            return controlflow::trans_loop(bcx, (*body), opt_label);\n+            return controlflow::trans_loop(bcx, body, opt_label);\n         }\n         ast::expr_assign(dst, src) => {\n             let src_datum = unpack_datum!(\n@@ -530,7 +530,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n                                             bcx.def(expr.id), dest);\n         }\n         ast::expr_if(cond, ref thn, els) => {\n-            return controlflow::trans_if(bcx, cond, *thn, els, dest);\n+            return controlflow::trans_if(bcx, cond, thn, els, dest);\n         }\n         ast::expr_match(discr, ref arms) => {\n             return _match::trans_match(bcx, expr, discr, /*bad*/copy *arms,\n@@ -539,7 +539,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_block(ref blk) => {\n             return do base::with_scope(bcx, blk.info(),\n                                        ~\"block-expr body\") |bcx| {\n-                controlflow::trans_block(bcx, (*blk), dest)\n+                controlflow::trans_block(bcx, blk, dest)\n             };\n         }\n         ast::expr_rec(ref fields, base) |\n@@ -562,58 +562,31 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         ast::expr_vec(*) | ast::expr_repeat(*) => {\n             return tvec::trans_fixed_vstore(bcx, expr, expr, dest);\n         }\n-        // XXX: Bad copy.\n-        ast::expr_fn(proto, copy decl, ref body, _) => {\n-            // Don't use this function for anything real. Use the one in\n-            // astconv instead.\n-            return closure::trans_expr_fn(bcx, proto, decl,\n-                                          /*bad*/copy *body,\n-                                          expr.id, expr.id,\n-                                          None, dest);\n-        }\n+        ast::expr_fn(_, ref decl, ref body, _) |\n         ast::expr_fn_block(ref decl, ref body) => {\n             let expr_ty = expr_ty(bcx, expr);\n-            match ty::get(expr_ty).sty {\n-                ty::ty_fn(ref fn_ty) => {\n-                    debug!(\"translating fn_block %s with type %s\",\n-                           expr_to_str(expr, tcx.sess.intr()),\n-                           ty_to_str(tcx, expr_ty));\n-                    return closure::trans_expr_fn(\n-                        bcx, fn_ty.meta.proto, /*bad*/copy *decl,\n-                        /*bad*/copy *body, expr.id, expr.id,\n-                        None, dest);\n-                }\n-                _ => {\n-                    bcx.sess().impossible_case(\n-                        expr.span, \"fn_block has body with a non-fn type\");\n-                }\n-            }\n+            let sigil = ty::ty_closure_sigil(expr_ty);\n+            debug!(\"translating fn_block %s with type %s\",\n+                   expr_to_str(expr, tcx.sess.intr()),\n+                   ty_to_str(tcx, expr_ty));\n+            return closure::trans_expr_fn(bcx, sigil, decl, body,\n+                                          expr.id, expr.id,\n+                                          None, dest);\n         }\n         ast::expr_loop_body(blk) => {\n-            match ty::get(expr_ty(bcx, expr)).sty {\n-                ty::ty_fn(ref fn_ty) => {\n-                    match blk.node {\n-                        ast::expr_fn_block(copy decl, ref body) => {\n-                            return closure::trans_expr_fn(\n-                                bcx,\n-                                fn_ty.meta.proto,\n-                                decl,\n-                                /*bad*/copy *body,\n-                                expr.id,\n-                                blk.id,\n-                                Some(None),\n-                                dest);\n-                        }\n-                        _ => {\n-                            bcx.sess().impossible_case(\n-                                expr.span,\n-                                \"loop_body has the wrong kind of contents\")\n-                        }\n-                    }\n+            let expr_ty = expr_ty(bcx, expr);\n+            let sigil = ty::ty_closure_sigil(expr_ty);\n+            match blk.node {\n+                ast::expr_fn_block(ref decl, ref body) => {\n+                    return closure::trans_expr_fn(bcx, sigil,\n+                                                  decl, body,\n+                                                  expr.id, blk.id,\n+                                                  Some(None), dest);\n                 }\n                 _ => {\n                     bcx.sess().impossible_case(\n-                        expr.span, \"loop_body has body with a non-fn type\")\n+                        expr.span,\n+                        \"loop_body has the wrong kind of contents\")\n                 }\n             }\n         }\n@@ -696,15 +669,15 @@ fn trans_def_dps_unadjusted(bcx: block, ref_expr: @ast::expr,\n             return fn_data_to_datum(bcx, impl_did, fn_data, lldest);\n         }\n         ast::def_variant(tid, vid) => {\n-            if ty::enum_variant_with_id(ccx.tcx, tid, vid).args.len() > 0u {\n+            let variant_info = ty::enum_variant_with_id(ccx.tcx, tid, vid);\n+            if variant_info.args.len() > 0u {\n                 // N-ary variant.\n                 let fn_data = callee::trans_fn_ref(bcx, vid, ref_expr.id);\n                 return fn_data_to_datum(bcx, vid, fn_data, lldest);\n             } else {\n                 // Nullary variant.\n                 let lldiscrimptr = GEPi(bcx, lldest, [0u, 0u]);\n-                let lldiscrim_gv = base::lookup_discriminant(ccx, vid);\n-                let lldiscrim = Load(bcx, lldiscrim_gv);\n+                let lldiscrim = C_int(bcx.ccx(), variant_info.disr_val);\n                 Store(bcx, lldiscrim, lldiscrimptr);\n                 return bcx;\n             }\n@@ -742,7 +715,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     // the lvalue in there, and then arrange for it to be cleaned up\n     // at the end of the scope with id `scope_id`:\n     let root_key = root_map_key { id: expr.id, derefs: 0u };\n-    for bcx.ccx().maps.root_map.find(root_key).each |&root_info| {\n+    for bcx.ccx().maps.root_map.find(&root_key).each |&root_info| {\n         bcx = unrooted_datum.root(bcx, root_info);\n     }\n \n@@ -934,7 +907,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n         ast::def_upvar(nid, _, _, _) => {\n             // Can't move upvars, so this is never a ZeroMemLastUse.\n             let local_ty = node_id_type(bcx, nid);\n-            match bcx.fcx.llupvars.find(nid) {\n+            match bcx.fcx.llupvars.find(&nid) {\n                 Some(val) => {\n                     Datum {\n                         val: val,\n@@ -987,7 +960,7 @@ pub fn trans_local_var(bcx: block, def: ast::def) -> Datum {\n     fn take_local(bcx: block,\n                   table: HashMap<ast::node_id, local_val>,\n                   nid: ast::node_id) -> Datum {\n-        let (v, mode) = match table.find(nid) {\n+        let (v, mode) = match table.find(&nid) {\n             Some(local_mem(v)) => (v, ByRef),\n             Some(local_imm(v)) => (v, ByValue),\n             None => {\n@@ -1066,7 +1039,7 @@ pub fn with_field_tys<R>(tcx: ty::ctxt,\n                         ty_to_str(tcx, ty)));\n                 }\n                 Some(node_id) => {\n-                    match tcx.def_map.get(node_id) {\n+                    match tcx.def_map.get(&node_id) {\n                         ast::def_variant(_, variant_id) => {\n                             op(false, struct_mutable_fields(\n                                 tcx, variant_id, substs))\n@@ -1120,7 +1093,7 @@ fn trans_rec_or_struct(bcx: block,\n     let tcx = bcx.tcx();\n     let addr = match ty::get(ty).sty {\n         ty::ty_enum(_, ref substs) => {\n-            match tcx.def_map.get(id) {\n+            match tcx.def_map.get(&id) {\n                 ast::def_variant(enum_id, variant_id) => {\n                     let variant_info = ty::enum_variant_with_id(\n                         tcx, enum_id, variant_id);\n@@ -1236,7 +1209,6 @@ fn trans_unary_datum(bcx: block,\n                      un_expr: @ast::expr,\n                      op: ast::unop,\n                      sub_expr: @ast::expr) -> DatumBlock {\n-\n     let _icx = bcx.insn_ctxt(\"trans_unary_datum\");\n \n     // if deref, would be LvalueExpr\n@@ -1251,7 +1223,21 @@ fn trans_unary_datum(bcx: block,\n     return match op {\n         ast::not => {\n             let Result {bcx, val} = trans_to_datum(bcx, sub_expr).to_result();\n-            immediate_rvalue_bcx(bcx, Not(bcx, val), un_ty)\n+\n+            // If this is a boolean type, we must not use the LLVM Not\n+            // instruction, as that is a *bitwise* not and we want *logical*\n+            // not on our 8-bit boolean values.\n+            let llresult = match ty::get(un_ty).sty {\n+                ty::ty_bool => {\n+                    let llcond = ICmp(bcx,\n+                                      lib::llvm::IntEQ,\n+                                      val,\n+                                      C_bool(false));\n+                    Select(bcx, llcond, C_bool(true), C_bool(false))\n+                }\n+                _ => Not(bcx, val)\n+            };\n+            immediate_rvalue_bcx(bcx, llresult, un_ty)\n         }\n         ast::neg => {\n             let Result {bcx, val} = trans_to_datum(bcx, sub_expr).to_result();\n@@ -1308,8 +1294,8 @@ fn trans_eager_binop(bcx: block,\n                      binop_ty: ty::t,\n                      op: ast::binop,\n                      lhs_datum: &Datum,\n-                     rhs_datum: &Datum) -> DatumBlock\n-{\n+                     rhs_datum: &Datum)\n+                  -> DatumBlock {\n     let mut bcx = bcx;\n     let _icx = bcx.insn_ctxt(\"trans_eager_binop\");\n \n@@ -1388,7 +1374,7 @@ fn trans_eager_binop(bcx: block,\n             }\n             let cmpr = base::compare_scalar_types(bcx, lhs, rhs, rhs_t, op);\n             bcx = cmpr.bcx;\n-            cmpr.val\n+            ZExt(bcx, cmpr.val, T_i8())\n         }\n       }\n       _ => {\n@@ -1406,8 +1392,7 @@ fn trans_lazy_binop(bcx: block,\n                     binop_expr: @ast::expr,\n                     op: lazy_binop_ty,\n                     a: @ast::expr,\n-                    b: @ast::expr) -> DatumBlock\n-{\n+                    b: @ast::expr) -> DatumBlock {\n     let _icx = bcx.insn_ctxt(\"trans_lazy_binop\");\n     let binop_ty = expr_ty(bcx, binop_expr);\n     let mut bcx = bcx;\n@@ -1425,10 +1410,12 @@ fn trans_lazy_binop(bcx: block,\n     let join = base::sub_block(bcx, ~\"join\");\n     let before_rhs = base::sub_block(bcx, ~\"rhs\");\n \n+    let lhs_i1 = bool_to_i1(past_lhs, lhs);\n     match op {\n-      lazy_and => CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb),\n-      lazy_or => CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb)\n+      lazy_and => CondBr(past_lhs, lhs_i1, before_rhs.llbb, join.llbb),\n+      lazy_or => CondBr(past_lhs, lhs_i1, join.llbb, before_rhs.llbb)\n     }\n+\n     let Result {bcx: past_rhs, val: rhs} = {\n         do base::with_scope_result(before_rhs, b.info(), ~\"rhs\") |bcx| {\n             trans_to_datum(bcx, b).to_result()\n@@ -1479,7 +1466,7 @@ fn trans_overloaded_op(bcx: block,\n                        dest: Dest,\n                        +autoref_arg: AutorefArg) -> block\n {\n-    let origin = bcx.ccx().maps.method_map.get(expr.id);\n+    let origin = bcx.ccx().maps.method_map.get(&expr.id);\n     let fty = node_id_type(bcx, expr.callee_id);\n     return callee::trans_call_inner(\n         bcx, expr.info(), fty,\n@@ -1636,7 +1623,7 @@ fn trans_assign_op(bcx: block,\n     let dst_datum = unpack_datum!(bcx, trans_lvalue_unadjusted(bcx, dst));\n \n     // A user-defined operator method\n-    if bcx.ccx().maps.method_map.find(expr.id).is_some() {\n+    if bcx.ccx().maps.method_map.find(&expr.id).is_some() {\n         // FIXME(#2528) evaluates the receiver twice!!\n         let scratch = scratch_datum(bcx, dst_datum.ty, false);\n         let bcx = trans_overloaded_op(bcx, expr, dst, ~[src],"}, {"sha": "bb14fce805354784ff4f12b74c6f80faf34438c8", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 74, "deletions": 76, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -31,7 +31,7 @@ use middle::trans::machine;\n use middle::trans::shape;\n use middle::trans::type_of::*;\n use middle::trans::type_of;\n-use middle::ty::{FnTyBase, FnMeta, FnSig, arg};\n+use middle::ty::{FnSig, arg};\n use util::ppaux::ty_to_str;\n \n use core::libc::c_uint;\n@@ -42,7 +42,7 @@ use syntax::parse::token::special_idents;\n \n fn abi_info(arch: session::arch) -> cabi::ABIInfo {\n     return match arch {\n-        arch_x86_64 => x86_64_abi_info(),\n+        arch_x86_64 | arch_arm => x86_64_abi_info(),\n         _ => cabi::llvm_abi_info()\n     }\n }\n@@ -66,10 +66,8 @@ type c_stack_tys = {\n fn c_arg_and_ret_lltys(ccx: @crate_ctxt,\n                        id: ast::node_id) -> (~[TypeRef], TypeRef, ty::t) {\n     match ty::get(ty::node_id_to_type(ccx.tcx, id)).sty {\n-        ty::ty_fn(ref fn_ty) => {\n-            let llargtys = type_of_explicit_args(\n-                ccx,\n-                fn_ty.sig.inputs);\n+        ty::ty_bare_fn(ref fn_ty) => {\n+            let llargtys = type_of_explicit_args(ccx, fn_ty.sig.inputs);\n             let llretty = type_of::type_of(ccx, fn_ty.sig.output);\n             (llargtys, llretty, fn_ty.sig.output)\n         }\n@@ -498,7 +496,7 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n             let tp_sz = machine::llbitsize_of_real(ccx, lltp_ty),\n             out_sz = machine::llbitsize_of_real(ccx, llout_ty);\n           if tp_sz != out_sz {\n-              let sp = match ccx.tcx.items.get(ref_id.get()) {\n+              let sp = match ccx.tcx.items.get(&ref_id.get()) {\n                   ast_map::node_expr(e) => e.span,\n                   _ => die!(~\"reinterpret_cast or forget has non-expr arg\")\n               };\n@@ -524,7 +522,8 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n         }\n         ~\"needs_drop\" => {\n             let tp_ty = substs.tys[0];\n-            Store(bcx, C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n+            Store(bcx,\n+                  C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n                   fcx.llretptr);\n         }\n         ~\"visit_tydesc\" => {\n@@ -535,17 +534,16 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n                                         abi::tydesc_field_visit_glue, None);\n         }\n         ~\"frame_address\" => {\n-            let frameaddress = ccx.intrinsics.get(~\"llvm.frameaddress\");\n+            let frameaddress = ccx.intrinsics.get(&~\"llvm.frameaddress\");\n             let frameaddress_val = Call(bcx, frameaddress, ~[C_i32(0i32)]);\n             let star_u8 = ty::mk_imm_ptr(\n                 bcx.tcx(),\n                 ty::mk_mach_uint(bcx.tcx(), ast::ty_u8));\n-            let fty = ty::mk_fn(bcx.tcx(), FnTyBase {\n-                meta: FnMeta {purity: ast::impure_fn,\n-                              proto: ast::ProtoBorrowed,\n-                              onceness: ast::Many,\n-                              region: ty::re_bound(ty::br_anon(0)),\n-                              bounds: @~[]},\n+            let fty = ty::mk_closure(bcx.tcx(), ty::ClosureTy {\n+                purity: ast::impure_fn,\n+                sigil: ast::BorrowedSigil,\n+                onceness: ast::Many,\n+                region: ty::re_bound(ty::br_anon(0)),\n                 sig: FnSig {inputs: ~[arg {mode: ast::expl(ast::by_copy),\n                                            ty: star_u8}],\n                             output: ty::mk_nil(bcx.tcx())}\n@@ -574,260 +572,260 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n             let src_ptr = get_param(decl, first_real_arg + 1);\n             let size = get_param(decl, first_real_arg + 2);\n             let align = C_i32(1);\n-            let volatile = C_bool(false);\n+            let volatile = C_i1(false);\n             let llfn = bcx.ccx().intrinsics.get(\n-                ~\"llvm.memmove.p0i8.p0i8.i32\");\n+                &~\"llvm.memmove.p0i8.p0i8.i32\");\n             Call(bcx, llfn, ~[dst_ptr, src_ptr, size, align, volatile]);\n         }\n         ~\"memmove64\" => {\n             let dst_ptr = get_param(decl, first_real_arg);\n             let src_ptr = get_param(decl, first_real_arg + 1);\n             let size = get_param(decl, first_real_arg + 2);\n             let align = C_i32(1);\n-            let volatile = C_bool(false);\n+            let volatile = C_i1(false);\n             let llfn = bcx.ccx().intrinsics.get(\n-                ~\"llvm.memmove.p0i8.p0i8.i64\");\n+                &~\"llvm.memmove.p0i8.p0i8.i64\");\n             Call(bcx, llfn, ~[dst_ptr, src_ptr, size, align, volatile]);\n         }\n         ~\"sqrtf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sqrtf = ccx.intrinsics.get(~\"llvm.sqrt.f32\");\n+            let sqrtf = ccx.intrinsics.get(&~\"llvm.sqrt.f32\");\n             Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr);\n         }\n         ~\"sqrtf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sqrtf = ccx.intrinsics.get(~\"llvm.sqrt.f64\");\n+            let sqrtf = ccx.intrinsics.get(&~\"llvm.sqrt.f64\");\n             Store(bcx, Call(bcx, sqrtf, ~[x]), fcx.llretptr);\n         }\n         ~\"powif32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powif = ccx.intrinsics.get(~\"llvm.powi.f32\");\n+            let powif = ccx.intrinsics.get(&~\"llvm.powi.f32\");\n             Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr);\n         }\n         ~\"powif64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powif = ccx.intrinsics.get(~\"llvm.powi.f64\");\n+            let powif = ccx.intrinsics.get(&~\"llvm.powi.f64\");\n             Store(bcx, Call(bcx, powif, ~[a, x]), fcx.llretptr);\n         }\n         ~\"sinf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sinf = ccx.intrinsics.get(~\"llvm.sin.f32\");\n+            let sinf = ccx.intrinsics.get(&~\"llvm.sin.f32\");\n             Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr);\n         }\n         ~\"sinf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sinf = ccx.intrinsics.get(~\"llvm.sin.f64\");\n+            let sinf = ccx.intrinsics.get(&~\"llvm.sin.f64\");\n             Store(bcx, Call(bcx, sinf, ~[x]), fcx.llretptr);\n         }\n         ~\"cosf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cosf = ccx.intrinsics.get(~\"llvm.cos.f32\");\n+            let cosf = ccx.intrinsics.get(&~\"llvm.cos.f32\");\n             Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr);\n         }\n         ~\"cosf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cosf = ccx.intrinsics.get(~\"llvm.cos.f64\");\n+            let cosf = ccx.intrinsics.get(&~\"llvm.cos.f64\");\n             Store(bcx, Call(bcx, cosf, ~[x]), fcx.llretptr);\n         }\n         ~\"powf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powf = ccx.intrinsics.get(~\"llvm.pow.f32\");\n+            let powf = ccx.intrinsics.get(&~\"llvm.pow.f32\");\n             Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr);\n         }\n         ~\"powf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powf = ccx.intrinsics.get(~\"llvm.pow.f64\");\n+            let powf = ccx.intrinsics.get(&~\"llvm.pow.f64\");\n             Store(bcx, Call(bcx, powf, ~[a, x]), fcx.llretptr);\n         }\n         ~\"expf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let expf = ccx.intrinsics.get(~\"llvm.exp.f32\");\n+            let expf = ccx.intrinsics.get(&~\"llvm.exp.f32\");\n             Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr);\n         }\n         ~\"expf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let expf = ccx.intrinsics.get(~\"llvm.exp.f64\");\n+            let expf = ccx.intrinsics.get(&~\"llvm.exp.f64\");\n             Store(bcx, Call(bcx, expf, ~[x]), fcx.llretptr);\n         }\n         ~\"exp2f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let exp2f = ccx.intrinsics.get(~\"llvm.exp2.f32\");\n+            let exp2f = ccx.intrinsics.get(&~\"llvm.exp2.f32\");\n             Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr);\n         }\n         ~\"exp2f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let exp2f = ccx.intrinsics.get(~\"llvm.exp2.f64\");\n+            let exp2f = ccx.intrinsics.get(&~\"llvm.exp2.f64\");\n             Store(bcx, Call(bcx, exp2f, ~[x]), fcx.llretptr);\n         }\n         ~\"logf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let logf = ccx.intrinsics.get(~\"llvm.log.f32\");\n+            let logf = ccx.intrinsics.get(&~\"llvm.log.f32\");\n             Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr);\n         }\n         ~\"logf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let logf = ccx.intrinsics.get(~\"llvm.log.f64\");\n+            let logf = ccx.intrinsics.get(&~\"llvm.log.f64\");\n             Store(bcx, Call(bcx, logf, ~[x]), fcx.llretptr);\n         }\n         ~\"log10f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log10f = ccx.intrinsics.get(~\"llvm.log10.f32\");\n+            let log10f = ccx.intrinsics.get(&~\"llvm.log10.f32\");\n             Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr);\n         }\n         ~\"log10f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log10f = ccx.intrinsics.get(~\"llvm.log10.f64\");\n+            let log10f = ccx.intrinsics.get(&~\"llvm.log10.f64\");\n             Store(bcx, Call(bcx, log10f, ~[x]), fcx.llretptr);\n         }\n         ~\"log2f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log2f = ccx.intrinsics.get(~\"llvm.log2.f32\");\n+            let log2f = ccx.intrinsics.get(&~\"llvm.log2.f32\");\n             Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr);\n         }\n         ~\"log2f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log2f = ccx.intrinsics.get(~\"llvm.log2.f64\");\n+            let log2f = ccx.intrinsics.get(&~\"llvm.log2.f64\");\n             Store(bcx, Call(bcx, log2f, ~[x]), fcx.llretptr);\n         }\n         ~\"fmaf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n-            let fmaf = ccx.intrinsics.get(~\"llvm.fma.f32\");\n+            let fmaf = ccx.intrinsics.get(&~\"llvm.fma.f32\");\n             Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr);\n         }\n         ~\"fmaf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n-            let fmaf = ccx.intrinsics.get(~\"llvm.fma.f64\");\n+            let fmaf = ccx.intrinsics.get(&~\"llvm.fma.f64\");\n             Store(bcx, Call(bcx, fmaf, ~[a, b, c]), fcx.llretptr);\n         }\n         ~\"fabsf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let fabsf = ccx.intrinsics.get(~\"llvm.fabs.f32\");\n+            let fabsf = ccx.intrinsics.get(&~\"llvm.fabs.f32\");\n             Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr);\n         }\n         ~\"fabsf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let fabsf = ccx.intrinsics.get(~\"llvm.fabs.f64\");\n+            let fabsf = ccx.intrinsics.get(&~\"llvm.fabs.f64\");\n             Store(bcx, Call(bcx, fabsf, ~[x]), fcx.llretptr);\n         }\n         ~\"floorf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let floorf = ccx.intrinsics.get(~\"llvm.floor.f32\");\n+            let floorf = ccx.intrinsics.get(&~\"llvm.floor.f32\");\n             Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr);\n         }\n         ~\"floorf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let floorf = ccx.intrinsics.get(~\"llvm.floor.f64\");\n+            let floorf = ccx.intrinsics.get(&~\"llvm.floor.f64\");\n             Store(bcx, Call(bcx, floorf, ~[x]), fcx.llretptr);\n         }\n         ~\"ceilf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ceilf = ccx.intrinsics.get(~\"llvm.ceil.f32\");\n+            let ceilf = ccx.intrinsics.get(&~\"llvm.ceil.f32\");\n             Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr);\n         }\n         ~\"ceilf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ceilf = ccx.intrinsics.get(~\"llvm.ceil.f64\");\n+            let ceilf = ccx.intrinsics.get(&~\"llvm.ceil.f64\");\n             Store(bcx, Call(bcx, ceilf, ~[x]), fcx.llretptr);\n         }\n         ~\"truncf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let truncf = ccx.intrinsics.get(~\"llvm.trunc.f32\");\n+            let truncf = ccx.intrinsics.get(&~\"llvm.trunc.f32\");\n             Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr);\n         }\n         ~\"truncf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let truncf = ccx.intrinsics.get(~\"llvm.trunc.f64\");\n+            let truncf = ccx.intrinsics.get(&~\"llvm.trunc.f64\");\n             Store(bcx, Call(bcx, truncf, ~[x]), fcx.llretptr);\n         }\n         ~\"ctpop8\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get(~\"llvm.ctpop.i8\");\n+            let ctpop = ccx.intrinsics.get(&~\"llvm.ctpop.i8\");\n             Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n         }\n         ~\"ctpop16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get(~\"llvm.ctpop.i16\");\n+            let ctpop = ccx.intrinsics.get(&~\"llvm.ctpop.i16\");\n             Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n         }\n         ~\"ctpop32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get(~\"llvm.ctpop.i32\");\n+            let ctpop = ccx.intrinsics.get(&~\"llvm.ctpop.i32\");\n             Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n         }\n         ~\"ctpop64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = ccx.intrinsics.get(~\"llvm.ctpop.i64\");\n+            let ctpop = ccx.intrinsics.get(&~\"llvm.ctpop.i64\");\n             Store(bcx, Call(bcx, ctpop, ~[x]), fcx.llretptr)\n         }\n         ~\"ctlz8\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n-            let ctlz = ccx.intrinsics.get(~\"llvm.ctlz.i8\");\n+            let y = C_i1(false);\n+            let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i8\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n-            let ctlz = ccx.intrinsics.get(~\"llvm.ctlz.i16\");\n+            let y = C_i1(false);\n+            let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i16\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n-            let ctlz = ccx.intrinsics.get(~\"llvm.ctlz.i32\");\n+            let y = C_i1(false);\n+            let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i32\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"ctlz64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n-            let ctlz = ccx.intrinsics.get(~\"llvm.ctlz.i64\");\n+            let y = C_i1(false);\n+            let ctlz = ccx.intrinsics.get(&~\"llvm.ctlz.i64\");\n             Store(bcx, Call(bcx, ctlz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz8\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n-            let cttz = ccx.intrinsics.get(~\"llvm.cttz.i8\");\n+            let y = C_i1(false);\n+            let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i8\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n-            let cttz = ccx.intrinsics.get(~\"llvm.cttz.i16\");\n+            let y = C_i1(false);\n+            let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i16\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n-            let cttz = ccx.intrinsics.get(~\"llvm.cttz.i32\");\n+            let y = C_i1(false);\n+            let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i32\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"cttz64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let y = C_bool(false);\n-            let cttz = ccx.intrinsics.get(~\"llvm.cttz.i64\");\n+            let y = C_i1(false);\n+            let cttz = ccx.intrinsics.get(&~\"llvm.cttz.i64\");\n             Store(bcx, Call(bcx, cttz, ~[x, y]), fcx.llretptr)\n         }\n         ~\"bswap16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get(~\"llvm.bswap.i16\");\n+            let cttz = ccx.intrinsics.get(&~\"llvm.bswap.i16\");\n             Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n         }\n         ~\"bswap32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get(~\"llvm.bswap.i32\");\n+            let cttz = ccx.intrinsics.get(&~\"llvm.bswap.i32\");\n             Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n         }\n         ~\"bswap64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = ccx.intrinsics.get(~\"llvm.bswap.i64\");\n+            let cttz = ccx.intrinsics.get(&~\"llvm.bswap.i64\");\n             Store(bcx, Call(bcx, cttz, ~[x]), fcx.llretptr)\n         }\n         _ => {\n@@ -842,14 +840,14 @@ pub fn trans_intrinsic(ccx: @crate_ctxt,\n \n pub fn trans_foreign_fn(ccx: @crate_ctxt,\n                         +path: ast_map::path,\n-                        decl: ast::fn_decl,\n-                        body: ast::blk,\n+                        decl: &ast::fn_decl,\n+                        body: &ast::blk,\n                         llwrapfn: ValueRef,\n                         id: ast::node_id) {\n     let _icx = ccx.insn_ctxt(\"foreign::build_foreign_fn\");\n \n     fn build_rust_fn(ccx: @crate_ctxt, +path: ast_map::path,\n-                     decl: ast::fn_decl, body: ast::blk,\n+                     decl: &ast::fn_decl, body: &ast::blk,\n                      id: ast::node_id) -> ValueRef {\n         let _icx = ccx.insn_ctxt(\"foreign::foreign::build_rust_fn\");\n         let t = ty::node_id_to_type(ccx.tcx, id);\n@@ -955,7 +953,7 @@ pub fn register_foreign_fn(ccx: @crate_ctxt,\n fn abi_of_foreign_fn(ccx: @crate_ctxt, i: @ast::foreign_item)\n     -> ast::foreign_abi {\n     match attr::first_attr_value_str_by_name(i.attrs, ~\"abi\") {\n-      None => match ccx.tcx.items.get(i.id) {\n+      None => match ccx.tcx.items.get(&i.id) {\n         ast_map::node_foreign_item(_, abi, _) => abi,\n         // ??\n         _ => die!(~\"abi_of_foreign_fn: not foreign\")"}, {"sha": "564460fd88e9b9a85a6e55d9cbc34965fd0caa43", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -172,7 +172,8 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n \n     if field == abi::tydesc_field_free_glue {\n         match ty::get(t).sty {\n-          ty::ty_fn(*) |\n+          ty::ty_bare_fn(*) |\n+          ty::ty_closure(*) |\n           ty::ty_box(*) |\n           ty::ty_opaque_box |\n           ty::ty_uniq(*) |\n@@ -381,7 +382,7 @@ pub fn make_visit_glue(bcx: block, v: ValueRef, t: ty::t) {\n     let mut bcx = bcx;\n     let ty_visitor_name = special_idents::ty_visitor;\n     assert bcx.ccx().tcx.intrinsic_defs.contains_key_ref(&ty_visitor_name);\n-    let (trait_id, ty) = bcx.ccx().tcx.intrinsic_defs.get(ty_visitor_name);\n+    let (trait_id, ty) = bcx.ccx().tcx.intrinsic_defs.get(&ty_visitor_name);\n     let v = PointerCast(bcx, v, T_ptr(type_of::type_of(bcx.ccx(), ty)));\n     bcx = reflect::emit_calls_to_trait_visit_ty(bcx, t, v, trait_id);\n     build_return(bcx);\n@@ -419,8 +420,8 @@ pub fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n                        tvec::expand_boxed_vec_ty(bcx.tcx(), t));\n         return;\n       }\n-      ty::ty_fn(_) => {\n-        closure::make_fn_glue(bcx, v, t, free_ty)\n+      ty::ty_closure(_) => {\n+        closure::make_closure_glue(bcx, v, t, free_ty)\n       }\n       ty::ty_opaque_closure_ptr(ck) => {\n         closure::make_opaque_cbox_free_glue(bcx, ck, v)\n@@ -528,8 +529,8 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n           }\n         }\n       }\n-      ty::ty_fn(_) => {\n-        closure::make_fn_glue(bcx, v0, t, drop_ty)\n+      ty::ty_closure(_) => {\n+        closure::make_closure_glue(bcx, v0, t, drop_ty)\n       }\n       ty::ty_trait(_, _, ty::vstore_box) => {\n         let llbox = Load(bcx, GEPi(bcx, v0, [0u, 1u]));\n@@ -594,8 +595,8 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n       | ty::ty_estr(ty::vstore_slice(_)) => {\n         bcx\n       }\n-      ty::ty_fn(_) => {\n-        closure::make_fn_glue(bcx, v, t, take_ty)\n+      ty::ty_closure(_) => {\n+        closure::make_closure_glue(bcx, v, t, take_ty)\n       }\n       ty::ty_trait(_, _, ty::vstore_box) => {\n         let llbox = Load(bcx, GEPi(bcx, v, [0u, 1u]));"}, {"sha": "c094db4ecca1f501cf3e431ab3074b61a9c25410", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -31,7 +31,7 @@ pub fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id,\n                                 translate: bool)\n     -> ast::def_id {\n     let _icx = ccx.insn_ctxt(\"maybe_instantiate_inline\");\n-    match ccx.external.find(fn_id) {\n+    match ccx.external.find(&fn_id) {\n       Some(Some(node_id)) => {\n         // Already inline\n         debug!(\"maybe_instantiate_inline(%s): already inline as node id %d\",\n@@ -108,8 +108,8 @@ pub fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id,\n                 };\n                 trans_fn(ccx,\n                          path,\n-                         mth.decl,\n-                         mth.body,\n+                         &mth.decl,\n+                         &mth.body,\n                          llfn,\n                          self_kind,\n                          None,"}, {"sha": "828b561939055e60be503f07c318679a799b1fe5", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -34,8 +34,11 @@ pub fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n           ty::ty_box(_) | ty::ty_opaque_box | ty::ty_uniq(_) |\n           ty::ty_evec(_, ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_box) |\n           ty::ty_estr(ty::vstore_uniq) | ty::ty_estr(ty::vstore_box) |\n-          ty::ty_ptr(_) | ty::ty_rptr(_,_) => nilptr(tcx),\n-          ty::ty_fn(_) => ty::mk_tup(tcx, ~[nilptr(tcx), nilptr(tcx)]),\n+          ty::ty_ptr(_) | ty::ty_rptr(*) => nilptr(tcx),\n+\n+          ty::ty_bare_fn(*) | // FIXME(#4804) Bare fn repr\n+          ty::ty_closure(*) => ty::mk_tup(tcx, ~[nilptr(tcx), nilptr(tcx)]),\n+\n           ty::ty_evec(_, ty::vstore_slice(_)) |\n           ty::ty_estr(ty::vstore_slice(_)) => {\n             ty::mk_tup(tcx, ~[nilptr(tcx), ty::mk_int(tcx)])\n@@ -178,7 +181,7 @@ pub fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n \n // Computes the size of the data part of an enum.\n pub fn static_size_of_enum(cx: @crate_ctxt, t: ty::t) -> uint {\n-    if cx.enum_sizes.contains_key_ref(&t) { return cx.enum_sizes.get(t); }\n+    if cx.enum_sizes.contains_key_ref(&t) { return cx.enum_sizes.get(&t); }\n     match ty::get(t).sty {\n       ty::ty_enum(tid, ref substs) => {\n         // Compute max(variant sizes)."}, {"sha": "1d48d2dde6bc5051a2463057dc67bdc00ee4d024", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -142,8 +142,8 @@ pub fn trans_method(ccx: @crate_ctxt,\n     // generate the actual code\n     trans_fn(ccx,\n              path,\n-             method.decl,\n-             method.body,\n+             &method.decl,\n+             &method.body,\n              llfn,\n              self_arg,\n              param_substs,\n@@ -308,7 +308,7 @@ pub fn trans_static_method_callee(bcx: block,\n     };\n \n     let mname = if method_id.crate == ast::local_crate {\n-        match bcx.tcx().items.get(method_id.node) {\n+        match bcx.tcx().items.get(&method_id.node) {\n             ast_map::node_trait_method(trait_method, _, _) => {\n                 ast_util::trait_method_to_ty_method(*trait_method).ident\n             }\n@@ -325,7 +325,7 @@ pub fn trans_static_method_callee(bcx: block,\n             name=%s\", method_id, callee_id, ccx.sess.str_of(mname));\n \n     let vtbls = resolve_vtables_in_fn_ctxt(\n-        bcx.fcx, ccx.maps.vtable_map.get(callee_id));\n+        bcx.fcx, ccx.maps.vtable_map.get(&callee_id));\n \n     match /*bad*/copy vtbls[bound_index] {\n         typeck::vtable_static(impl_did, rcvr_substs, rcvr_origins) => {\n@@ -362,7 +362,7 @@ pub fn method_from_methods(ms: ~[@ast::method], name: ast::ident)\n pub fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n                         name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n-        match ccx.tcx.items.get(impl_id.node) {\n+        match ccx.tcx.items.get(&impl_id.node) {\n           ast_map::node_item(@ast::item {\n                 node: ast::item_impl(_, _, _, ref ms),\n                 _\n@@ -379,7 +379,7 @@ pub fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n pub fn method_with_name_or_default(ccx: @crate_ctxt, impl_id: ast::def_id,\n                                    name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n-        match ccx.tcx.items.get(impl_id.node) {\n+        match ccx.tcx.items.get(&impl_id.node) {\n           ast_map::node_item(@ast::item {\n                 node: ast::item_impl(_, _, _, ref ms), _\n           }, _) => {\n@@ -389,7 +389,7 @@ pub fn method_with_name_or_default(ccx: @crate_ctxt, impl_id: ast::def_id,\n               } else {\n                   // Look for a default method\n                   let pmm = ccx.tcx.provided_methods;\n-                  match pmm.find(impl_id) {\n+                  match pmm.find(&impl_id) {\n                       Some(pmis) => {\n                           for pmis.each |pmi| {\n                               if pmi.method_info.ident == name {\n@@ -414,10 +414,10 @@ pub fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n                              i_id: ast::def_id) -> uint {\n     debug!(\"method_ty_param_count: m_id: %?, i_id: %?\", m_id, i_id);\n     if m_id.crate == ast::local_crate {\n-        match ccx.tcx.items.find(m_id.node) {\n+        match ccx.tcx.items.find(&m_id.node) {\n             Some(ast_map::node_method(m, _, _)) => m.tps.len(),\n             None => {\n-                match ccx.tcx.provided_method_sources.find(m_id) {\n+                match ccx.tcx.provided_method_sources.find(&m_id) {\n                     Some(source) => {\n                         method_ty_param_count(\n                             ccx, source.method_id, source.impl_id)\n@@ -779,7 +779,7 @@ pub fn get_vtable(ccx: @crate_ctxt,\n                -> ValueRef {\n     // XXX: Bad copy.\n     let hash_id = vtable_id(ccx, copy origin);\n-    match ccx.vtables.find(hash_id) {\n+    match ccx.vtables.find(&hash_id) {\n       Some(val) => val,\n       None => match origin {\n         typeck::vtable_static(id, substs, sub_vtables) => {\n@@ -822,7 +822,7 @@ pub fn make_impl_vtable(ccx: @crate_ctxt,\n     let has_tps = (*ty::lookup_item_type(ccx.tcx, impl_id).bounds).len() > 0u;\n     make_vtable(ccx, vec::map(*ty::trait_methods(tcx, trt_id), |im| {\n         let fty = ty::subst_tps(tcx, substs, None,\n-                                ty::mk_fn(tcx, copy im.fty));\n+                                ty::mk_bare_fn(tcx, copy im.fty));\n         if (*im.tps).len() > 0u || ty::type_has_self(fty) {\n             debug!(\"(making impl vtable) method has self or type params: %s\",\n                    tcx.sess.str_of(im.ident));\n@@ -916,7 +916,7 @@ pub fn trans_trait_cast(bcx: block,\n     }\n \n     // Store the vtable into the pair or triple.\n-    let orig = /*bad*/copy ccx.maps.vtable_map.get(id)[0];\n+    let orig = /*bad*/copy ccx.maps.vtable_map.get(&id)[0];\n     let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n     let vtable = get_vtable(bcx.ccx(), orig);\n     Store(bcx, vtable, PointerCast(bcx,"}, {"sha": "b09a41f2b7f06bb088891649d8b90d557e6c5650", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -26,7 +26,7 @@ use middle::trans::shape;\n use middle::trans::type_of::type_of_fn_from_ty;\n use middle::trans::type_of;\n use middle::trans::type_use;\n-use middle::ty::{FnTyBase, FnMeta, FnSig};\n+use middle::ty::{FnSig};\n use middle::typeck;\n \n use core::option;\n@@ -69,7 +69,7 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n            real_substs.map(|s| ty_to_str(ccx.tcx, *s)),\n            substs.map(|s| ty_to_str(ccx.tcx, *s)), hash_id);\n \n-    match ccx.monomorphized.find(hash_id) {\n+    match ccx.monomorphized.find(&hash_id) {\n       Some(val) => {\n         debug!(\"leaving monomorphic fn %s\",\n                ty::item_path_str(ccx.tcx, fn_id));\n@@ -81,7 +81,7 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n     let tpt = ty::lookup_item_type(ccx.tcx, fn_id);\n     let mut llitem_ty = tpt.ty;\n \n-    let map_node = session::expect(ccx.sess, ccx.tcx.items.find(fn_id.node),\n+    let map_node = session::expect(ccx.sess, ccx.tcx.items.find(&fn_id.node),\n      || fmt!(\"While monomorphizing %?, couldn't find it in the item map \\\n         (may have attempted to monomorphize an item defined in a different \\\n         crate?)\", fn_id));\n@@ -136,7 +136,7 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n \n     ccx.stats.n_monos += 1;\n \n-    let depth = option::get_or_default(ccx.monomorphizing.find(fn_id), 0u);\n+    let depth = option::get_or_default(ccx.monomorphizing.find(&fn_id), 0u);\n     // Random cut-off -- code that needs to instantiate the same function\n     // recursively more than ten times can probably safely be assumed to be\n     // causing an infinite expansion.\n@@ -166,12 +166,12 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n     let lldecl = match map_node {\n       ast_map::node_item(i@@ast::item {\n                 // XXX: Bad copy.\n-                node: ast::item_fn(copy decl, _, _, ref body),\n+                node: ast::item_fn(ref decl, _, _, ref body),\n                 _\n             }, _) => {\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(/*bad*/copy i.attrs, d);\n-        trans_fn(ccx, pt, decl, *body, d, no_self, psubsts, fn_id.node, None);\n+        trans_fn(ccx, pt, decl, body, d, no_self, psubsts, fn_id.node, None);\n         d\n       }\n       ast_map::node_item(*) => {\n@@ -224,7 +224,7 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n                 None      => ccx.sess.span_bug(dtor.span, ~\"Bad self ty in \\\n                                                             dtor\")\n         };\n-        trans_struct_dtor(ccx, /*bad*/copy *pt, dtor.node.body,\n+        trans_struct_dtor(ccx, /*bad*/copy *pt, &dtor.node.body,\n           dtor.node.id, psubsts, Some(hash_id), parent_id)\n       }\n       ast_map::node_trait_method(@ast::provided(mth), _, pt) => {\n@@ -267,38 +267,55 @@ pub fn monomorphic_fn(ccx: @crate_ctxt,\n pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n                                       ty: ty::t) -> Option<ty::t> {\n     // FIXME[mono] could do this recursively. is that worthwhile? (#2529)\n-    match ty::get(ty).sty {\n+    return match ty::get(ty).sty {\n         ty::ty_box(*) => {\n             Some(ty::mk_opaque_box(tcx))\n         }\n-        ty::ty_fn(ref fty) => {\n-            Some(ty::mk_fn(\n+        ty::ty_bare_fn(_) => {\n+            Some(ty::mk_bare_fn(\n                 tcx,\n-                FnTyBase {meta: FnMeta {purity: ast::impure_fn,\n-                                        proto: fty.meta.proto,\n-                                        onceness: ast::Many,\n-                                        region: ty::re_static,\n-                                        bounds: @~[]},\n-                          sig: FnSig {inputs: ~[],\n-                                      output: ty::mk_nil(tcx)}}))\n+                ty::BareFnTy {\n+                    purity: ast::impure_fn,\n+                    abi: ast::RustAbi,\n+                    sig: FnSig {inputs: ~[],\n+                                output: ty::mk_nil(tcx)}}))\n         }\n-        ty::ty_trait(_, _, _) => {\n-            Some(ty::mk_fn(\n-                tcx,\n-                FnTyBase {meta: FnMeta {purity: ast::impure_fn,\n-                                        proto: ast::ProtoBox,\n-                                        onceness: ast::Many,\n-                                        region: ty::re_static,\n-                                        bounds: @~[]},\n-                          sig: FnSig {inputs: ~[],\n-                                      output: ty::mk_nil(tcx)}}))\n+        ty::ty_closure(ref fty) => {\n+            Some(normalized_closure_ty(tcx, fty.sigil))\n+        }\n+        ty::ty_trait(_, _, ref vstore) => {\n+            let sigil = match *vstore {\n+                ty::vstore_uniq => ast::OwnedSigil,\n+                ty::vstore_box => ast::ManagedSigil,\n+                ty::vstore_slice(_) => ast::BorrowedSigil,\n+                ty::vstore_fixed(*) => {\n+                    tcx.sess.bug(fmt!(\"ty_trait with vstore_fixed\"));\n+                }\n+            };\n+\n+            // Traits have the same runtime representation as closures.\n+            Some(normalized_closure_ty(tcx, sigil))\n         }\n         ty::ty_ptr(_) => {\n             Some(ty::mk_uint(tcx))\n         }\n         _ => {\n             None\n         }\n+    };\n+\n+    fn normalized_closure_ty(tcx: ty::ctxt,\n+                             sigil: ast::Sigil) -> ty::t\n+    {\n+        ty::mk_closure(\n+            tcx,\n+            ty::ClosureTy {\n+                purity: ast::impure_fn,\n+                sigil: sigil,\n+                onceness: ast::Many,\n+                region: ty::re_static,\n+                sig: ty::FnSig {inputs: ~[],\n+                                output: ty::mk_nil(tcx)}})\n     }\n }\n "}, {"sha": "112b9ac4d0781c8920b18fbf385a932f870b91c9", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -54,7 +54,7 @@ pub fn find_reachable(crate_mod: _mod, exp_map2: resolve::ExportMap2,\n \n fn traverse_exports(cx: ctx, mod_id: node_id) -> bool {\n     let mut found_export = false;\n-    match cx.exp_map2.find(mod_id) {\n+    match cx.exp_map2.find(&mod_id) {\n       Some(ref exp2s) => {\n         for (*exp2s).each |e2| {\n             found_export = true;\n@@ -68,7 +68,7 @@ fn traverse_exports(cx: ctx, mod_id: node_id) -> bool {\n \n fn traverse_def_id(cx: ctx, did: def_id) {\n     if did.crate != local_crate { return; }\n-    let n = match cx.tcx.items.find(did.node) {\n+    let n = match cx.tcx.items.find(&did.node) {\n         None => return, // This can happen for self, for example\n         Some(ref n) => (/*bad*/copy *n)\n     };\n@@ -150,7 +150,7 @@ fn traverse_ty(ty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n \n     match ty.node {\n       ty_path(p, p_id) => {\n-        match cx.tcx.def_map.find(p_id) {\n+        match cx.tcx.def_map.find(&p_id) {\n           // Kind of a hack to check this here, but I'm not sure what else\n           // to do\n           Some(def_prim_ty(_)) => { /* do nothing */ }\n@@ -169,7 +169,7 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n     fn traverse_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         match e.node {\n           expr_path(_) => {\n-            match cx.tcx.def_map.find(e.id) {\n+            match cx.tcx.def_map.find(&e.id) {\n                 Some(d) => {\n                   traverse_def_id(cx, def_id_of_def(d));\n                 }\n@@ -179,7 +179,7 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n             }\n           }\n           expr_field(_, _, _) => {\n-            match cx.method_map.find(e.id) {\n+            match cx.method_map.find(&e.id) {\n               Some(typeck::method_map_entry {\n                   origin: typeck::method_static(did),\n                   _\n@@ -190,7 +190,7 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n             }\n           }\n           expr_method_call(*) => {\n-            match cx.method_map.find(e.id) {\n+            match cx.method_map.find(&e.id) {\n               Some(typeck::method_map_entry {\n                   origin: typeck::method_static(did),\n                   _"}, {"sha": "9466099904c1ac5e9c9cb15230ca417d026fa90d", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 59, "deletions": 37, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -86,9 +86,8 @@ pub impl reflector {\n             tcx.sess.ident_of(~\"visit_\" + ty_name),\n             *self.visitor_methods).expect(fmt!(\"Couldn't find visit method \\\n                                                 for %s\", ty_name));\n-        let mth_ty = ty::mk_fn(\n-            tcx,\n-            /*bad*/copy self.visitor_methods[mth_idx].fty);\n+        let mth_ty =\n+            ty::mk_bare_fn(tcx, copy self.visitor_methods[mth_idx].fty);\n         let v = self.visitor_val;\n         debug!(\"passing %u args:\", vec::len(args));\n         let bcx = self.bcx;\n@@ -109,6 +108,7 @@ pub impl reflector {\n                                                         ast::m_imm)),\n             ArgVals(args), SaveIn(scratch.val), DontAutorefArg);\n         let result = scratch.to_value_llval(bcx);\n+        let result = bool_to_i1(bcx, result);\n         let next_bcx = sub_block(bcx, ~\"next\");\n         CondBr(bcx, result, next_bcx.llbb, self.final_bcx.llbb);\n         self.bcx = next_bcx\n@@ -210,39 +210,33 @@ pub impl reflector {\n             }\n           }\n \n+          // FIXME (#2594): fetch constants out of intrinsic\n+          // FIXME (#4809): visitor should break out bare fns from other fns\n+          ty::ty_closure(ref fty) => {\n+            let pureval = ast_purity_constant(fty.purity);\n+            let sigilval = ast_sigil_constant(fty.sigil);\n+            let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n+            let extra = ~[self.c_uint(pureval),\n+                          self.c_uint(sigilval),\n+                          self.c_uint(vec::len(fty.sig.inputs)),\n+                          self.c_uint(retval)];\n+            self.visit(~\"enter_fn\", copy extra);    // XXX: Bad copy.\n+            self.visit_sig(retval, &fty.sig);\n+            self.visit(~\"leave_fn\", extra);\n+          }\n+\n           // FIXME (#2594): fetch constants out of intrinsic:: for the\n           // numbers.\n-          ty::ty_fn(ref fty) => {\n-            let pureval = match fty.meta.purity {\n-              ast::pure_fn => 0u,\n-              ast::unsafe_fn => 1u,\n-              ast::impure_fn => 2u,\n-              ast::extern_fn => 3u\n-            };\n-            let protoval = ast_proto_constant(fty.meta.proto);\n+          ty::ty_bare_fn(ref fty) => {\n+            let pureval = ast_purity_constant(fty.purity);\n+            let sigilval = 0u;\n             let retval = if ty::type_is_bot(fty.sig.output) {0u} else {1u};\n             let extra = ~[self.c_uint(pureval),\n-                          self.c_uint(protoval),\n+                          self.c_uint(sigilval),\n                           self.c_uint(vec::len(fty.sig.inputs)),\n                           self.c_uint(retval)];\n             self.visit(~\"enter_fn\", copy extra);    // XXX: Bad copy.\n-            for fty.sig.inputs.eachi |i, arg| {\n-                let modeval = match arg.mode {\n-                  ast::infer(_) => 0u,\n-                  ast::expl(e) => match e {\n-                    ast::by_ref => 1u,\n-                    ast::by_val => 2u,\n-                    ast::by_copy => 5u\n-                  }\n-                };\n-                self.visit(~\"fn_input\",\n-                           ~[self.c_uint(i),\n-                             self.c_uint(modeval),\n-                             self.c_tydesc(arg.ty)]);\n-            }\n-            self.visit(~\"fn_output\",\n-                       ~[self.c_uint(retval),\n-                         self.c_tydesc(fty.sig.output)]);\n+            self.visit_sig(retval, &fty.sig);\n             self.visit(~\"leave_fn\", extra);\n           }\n \n@@ -301,11 +295,31 @@ pub impl reflector {\n           ty::ty_type => self.leaf(~\"type\"),\n           ty::ty_opaque_box => self.leaf(~\"opaque_box\"),\n           ty::ty_opaque_closure_ptr(ck) => {\n-            let ckval = ast_proto_constant(ck);\n+            let ckval = ast_sigil_constant(ck);\n             self.visit(~\"closure_ptr\", ~[self.c_uint(ckval)])\n           }\n         }\n     }\n+\n+    fn visit_sig(&self, retval: uint, sig: &ty::FnSig) {\n+        for sig.inputs.eachi |i, arg| {\n+            let modeval = match arg.mode {\n+                ast::infer(_) => 0u,\n+                ast::expl(e) => match e {\n+                    ast::by_ref => 1u,\n+                    ast::by_val => 2u,\n+                    ast::by_copy => 5u\n+                }\n+            };\n+            self.visit(~\"fn_input\",\n+                       ~[self.c_uint(i),\n+                         self.c_uint(modeval),\n+                         self.c_tydesc(arg.ty)]);\n+        }\n+        self.visit(~\"fn_output\",\n+                   ~[self.c_uint(retval),\n+                     self.c_tydesc(sig.output)]);\n+    }\n }\n \n // Emit a sequence of calls to visit_ty::visit_foo\n@@ -317,7 +331,7 @@ pub fn emit_calls_to_trait_visit_ty(bcx: block,\n     use syntax::parse::token::special_idents::tydesc;\n     let final = sub_block(bcx, ~\"final\");\n     assert bcx.ccx().tcx.intrinsic_defs.contains_key_ref(&tydesc);\n-    let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get(tydesc);\n+    let (_, tydesc_ty) = bcx.ccx().tcx.intrinsic_defs.get(&tydesc);\n     let tydesc_ty = type_of::type_of(bcx.ccx(), tydesc_ty);\n     let r = reflector({\n         visitor_val: visitor_val,\n@@ -331,12 +345,20 @@ pub fn emit_calls_to_trait_visit_ty(bcx: block,\n     return final;\n }\n \n-pub fn ast_proto_constant(proto: ast::Proto) -> uint {\n-    match proto {\n-        ast::ProtoBare => 0u,\n-        ast::ProtoUniq => 2u,\n-        ast::ProtoBox => 3u,\n-        ast::ProtoBorrowed => 4u,\n+pub fn ast_sigil_constant(sigil: ast::Sigil) -> uint {\n+    match sigil {\n+        ast::OwnedSigil => 2u,\n+        ast::ManagedSigil => 3u,\n+        ast::BorrowedSigil => 4u,\n+    }\n+}\n+\n+pub fn ast_purity_constant(purity: ast::purity) -> uint {\n+    match purity {\n+        ast::pure_fn => 0u,\n+        ast::unsafe_fn => 1u,\n+        ast::impure_fn => 2u,\n+        ast::extern_fn => 3u\n     }\n }\n "}, {"sha": "f727b5a2de07454ac91b98f95992c1b86d329d2d", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -59,7 +59,13 @@ pub fn type_of_fn(cx: @crate_ctxt, inputs: &[ty::arg],\n \n // Given a function type and a count of ty params, construct an llvm type\n pub fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t) -> TypeRef {\n-    type_of_fn(cx, ty::ty_fn_args(fty), ty::ty_fn_ret(fty))\n+    match ty::get(fty).sty {\n+        ty::ty_closure(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n+        ty::ty_bare_fn(ref f) => type_of_fn(cx, f.sig.inputs, f.sig.output),\n+        _ => {\n+            cx.sess.bug(~\"type_of_fn_from_ty given non-closure, non-bare-fn\")\n+        }\n+    }\n }\n \n pub fn type_of_non_gc_box(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n@@ -87,7 +93,7 @@ pub fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n     debug!(\"type_of %?: %?\", t, ty::get(t));\n \n     // Check the cache.\n-    if cx.lltypes.contains_key_ref(&t) { return cx.lltypes.get(t); }\n+    if cx.lltypes.contains_key_ref(&t) { return cx.lltypes.get(&t); }\n \n     // Replace any typedef'd types with their equivalent non-typedef\n     // type. This ensures that all LLVM nominal types that contain\n@@ -170,7 +176,11 @@ pub fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         // structs\n         T_struct(~[T_struct(tys)])\n       }\n-      ty::ty_fn(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n+\n+      // FIXME(#4804) Bare fn repr\n+      // ty::ty_bare_fn(_) => T_ptr(type_of_fn_from_ty(cx, t)),\n+      ty::ty_bare_fn(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n+      ty::ty_closure(_) => T_fn_pair(cx, type_of_fn_from_ty(cx, t)),\n       ty::ty_trait(_, _, vstore) => T_opaque_trait(cx, vstore),\n       ty::ty_type => T_ptr(cx.tydesc_type),\n       ty::ty_tup(elts) => {"}, {"sha": "3fd334c2d15082a778fde4af19f4b3c5db933b3f", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -53,7 +53,7 @@ pub type ctx = {ccx: @crate_ctxt, uses: ~[mut type_uses]};\n \n pub fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n     -> ~[type_uses] {\n-    match ccx.type_use_cache.find(fn_id) {\n+    match ccx.type_use_cache.find(&fn_id) {\n       Some(uses) => return uses,\n       None => ()\n     }\n@@ -69,8 +69,9 @@ pub fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n \n     let cx = {ccx: ccx, uses: vec::cast_to_mut(vec::from_elem(n_tps, 0u))};\n     match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n-        ty::ty_fn(ref fn_ty) => {\n-            for vec::each(fn_ty.sig.inputs) |arg| {\n+        ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n+        ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n+            for vec::each(sig.inputs) |arg| {\n                 match ty::resolved_mode(ccx.tcx, arg.mode) {\n                     by_val | by_copy => {\n                         type_needs(cx, use_repr, arg.ty);\n@@ -87,7 +88,7 @@ pub fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n         ccx.type_use_cache.insert(fn_id, copy uses);\n         return uses;\n     }\n-    let map_node = match ccx.tcx.items.find(fn_id_loc.node) {\n+    let map_node = match ccx.tcx.items.find(&fn_id_loc.node) {\n         Some(ref x) => (/*bad*/copy *x),\n         None    => ccx.sess.bug(fmt!(\"type_uses_for: unbound item ID %?\",\n                                      fn_id_loc))\n@@ -197,8 +198,12 @@ pub fn type_needs_inner(cx: ctx,\n                  it, we depend on the drop glue for T (we have to write the\n                  right tydesc into the result)\n                  */\n-              ty::ty_fn(_) | ty::ty_ptr(_) | ty::ty_rptr(_, _)\n-               | ty::ty_trait(_, _, _) => false,\n+                ty::ty_closure(*) |\n+                ty::ty_bare_fn(*) |\n+                ty::ty_ptr(_) |\n+                ty::ty_rptr(_, _) |\n+                ty::ty_trait(_, _, _) => false,\n+\n               ty::ty_enum(did, ref substs) => {\n                 if option::is_none(&list::find(enums_seen, |id| *id == did)) {\n                     let seen = @Cons(did, enums_seen);\n@@ -226,10 +231,10 @@ pub fn node_type_needs(cx: ctx, use_: uint, id: node_id) {\n }\n \n pub fn mark_for_method_call(cx: ctx, e_id: node_id, callee_id: node_id) {\n-    do option::iter(&cx.ccx.maps.method_map.find(e_id)) |mth| {\n+    do option::iter(&cx.ccx.maps.method_map.find(&e_id)) |mth| {\n         match mth.origin {\n           typeck::method_static(did) => {\n-            do cx.ccx.tcx.node_type_substs.find(callee_id).iter |ts| {\n+            do cx.ccx.tcx.node_type_substs.find(&callee_id).iter |ts| {\n                 let type_uses = type_uses_for(cx.ccx, did, ts.len());\n                 for vec::each2(type_uses, *ts) |uses, subst| {\n                     type_needs(cx, *uses, *subst)\n@@ -278,24 +283,24 @@ pub fn mark_for_expr(cx: ctx, e: @expr) {\n         }\n       }\n       expr_path(_) => {\n-        do cx.ccx.tcx.node_type_substs.find(e.id).iter |ts| {\n-            let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get(e.id));\n+        do cx.ccx.tcx.node_type_substs.find(&e.id).iter |ts| {\n+            let id = ast_util::def_id_of_def(cx.ccx.tcx.def_map.get(&e.id));\n             let uses_for_ts = type_uses_for(cx.ccx, id, ts.len());\n             for vec::each2(uses_for_ts, *ts) |uses, subst| {\n                 type_needs(cx, *uses, *subst)\n             }\n         }\n       }\n       expr_fn(*) | expr_fn_block(*) => {\n-        match ty::ty_fn_proto(ty::expr_ty(cx.ccx.tcx, e)) {\n-          ast::ProtoBare | ast::ProtoUniq => {}\n-          ast::ProtoBox | ast::ProtoBorrowed => {\n-            for vec::each(*freevars::get_freevars(cx.ccx.tcx, e.id)) |fv| {\n-                let node_id = ast_util::def_id_of_def(fv.def).node;\n-                node_type_needs(cx, use_repr, node_id);\n-            }\n+          match ty::ty_closure_sigil(ty::expr_ty(cx.ccx.tcx, e)) {\n+              ast::OwnedSigil => {}\n+              ast::BorrowedSigil | ast::ManagedSigil => {\n+                  for freevars::get_freevars(cx.ccx.tcx, e.id).each |fv| {\n+                      let node_id = ast_util::def_id_of_def(fv.def).node;\n+                      node_type_needs(cx, use_repr, node_id);\n+                  }\n+              }\n           }\n-        }\n       }\n       expr_assign(val, _) | expr_swap(val, _) | expr_assign_op(_, val, _) |\n       expr_ret(Some(val)) => {"}, {"sha": "ef62fb3caf18ab199e5cbdd449f3f46b96eb5655", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 208, "deletions": 388, "changes": 596, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[warn(deprecated_pattern)];\n-\n use core::prelude::*;\n \n use driver::session;\n@@ -27,7 +25,7 @@ use middle;\n use session::Session;\n use util::ppaux::{note_and_explain_region, bound_region_to_str};\n use util::ppaux::{region_to_str, explain_region, vstore_to_str};\n-use util::ppaux::{ty_to_str, proto_ty_to_str, tys_to_str};\n+use util::ppaux::{ty_to_str, tys_to_str};\n \n use core::cast;\n use core::cmp;\n@@ -73,7 +71,7 @@ pub type param_bounds = @~[param_bound];\n pub type method = {\n     ident: ast::ident,\n     tps: @~[param_bounds],\n-    fty: FnTy,\n+    fty: BareFnTy,\n     self_ty: ast::self_ty_,\n     vis: ast::visibility,\n     def_id: ast::def_id\n@@ -344,22 +342,20 @@ pub pure fn type_contains_err(t: t) -> bool {\n pub pure fn type_def_id(t: t) -> Option<ast::def_id> { get(t).o_def_id }\n pub pure fn type_id(t: t) -> uint { get(t).id }\n \n-/**\n- * Meta information about a closure.\n- *\n- * - `purity` is the function's effect (pure, impure, unsafe).\n- * - `proto` is the protocol (fn@, fn~, etc).\n- * - `onceness` indicates whether the function can be called one time or many\n- *   times.\n- * - `region` is the region bound on the function's upvars (often &static).\n- * - `bounds` is the parameter bounds on the function's upvars. */\n #[deriving_eq]\n-pub struct FnMeta {\n+pub struct BareFnTy {\n+    purity: ast::purity,\n+    abi: Abi,\n+    sig: FnSig\n+}\n+\n+#[deriving_eq]\n+pub struct ClosureTy {\n     purity: ast::purity,\n-    proto: ast::Proto,\n+    sigil: ast::Sigil,\n     onceness: ast::Onceness,\n     region: Region,\n-    bounds: @~[param_bound]\n+    sig: FnSig\n }\n \n /**\n@@ -374,25 +370,19 @@ pub struct FnSig {\n     output: t\n }\n \n-/**\n- * Function type: combines the meta information and the\n- * type signature.  This particular type is parameterized\n- * by the meta information because, in some cases, the\n- * meta information is inferred. */\n-#[deriving_eq]\n-pub struct FnTyBase<M> {\n-    meta: M,        // Either FnMeta or FnVid\n-    sig: FnSig      // Types of arguments/return type\n+impl BareFnTy : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_3(&self.purity, &self.abi, &self.sig, lsb0, f)\n+    }\n }\n \n-impl<M: to_bytes::IterBytes> FnTyBase<M> : to_bytes::IterBytes {\n+impl ClosureTy : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_2(&self.meta, &self.sig, lsb0, f)\n+        to_bytes::iter_bytes_5(&self.purity, &self.sigil, &self.onceness,\n+                               &self.region, &self.sig, lsb0, f)\n     }\n }\n \n-pub type FnTy = FnTyBase<FnMeta>;\n-\n #[deriving_eq]\n pub struct param_ty {\n     idx: uint,\n@@ -491,6 +481,7 @@ pub struct substs {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in libsyntax/ast.rs as well.\n+#[deriving_eq]\n pub enum sty {\n     ty_nil,\n     ty_bot,\n@@ -506,7 +497,8 @@ pub enum sty {\n     ty_ptr(mt),\n     ty_rptr(Region, mt),\n     ty_rec(~[field]),\n-    ty_fn(FnTy),\n+    ty_bare_fn(BareFnTy),\n+    ty_closure(ClosureTy),\n     ty_trait(def_id, substs, vstore),\n     ty_struct(def_id, substs),\n     ty_tup(~[t]),\n@@ -522,7 +514,7 @@ pub enum sty {\n     // \"Fake\" types, used for trans purposes\n     ty_type, // type_desc*\n     ty_opaque_box, // used by monomorphizer to represent any @ box\n-    ty_opaque_closure_ptr(ast::Proto), // ptr to env for fn, fn@, fn~\n+    ty_opaque_closure_ptr(Sigil), // ptr to env for fn, fn@, fn~\n     ty_unboxed_vec(mt),\n }\n \n@@ -546,8 +538,9 @@ pub enum type_err {\n     terr_mismatch,\n     terr_purity_mismatch(expected_found<purity>),\n     terr_onceness_mismatch(expected_found<Onceness>),\n+    terr_abi_mismatch(expected_found<ast::Abi>),\n     terr_mutability,\n-    terr_proto_mismatch(expected_found<ast::Proto>),\n+    terr_sigil_mismatch(expected_found<ast::Sigil>),\n     terr_box_mutability,\n     terr_ptr_mutability,\n     terr_ref_mutability,\n@@ -744,6 +737,15 @@ pub impl RegionVid : to_bytes::IterBytes {\n     }\n }\n \n+pub fn kind_to_param_bounds(kind: Kind) -> param_bounds {\n+    let mut bounds = ~[];\n+    if kind_can_be_copied(kind) { bounds.push(bound_copy); }\n+    if kind_can_be_sent(kind) { bounds.push(bound_owned); }\n+    else if kind_is_durable(kind) { bounds.push(bound_durable); }\n+    if kind_is_const(kind) { bounds.push(bound_const); }\n+    return @bounds;\n+}\n+\n pub fn param_bounds_to_kind(bounds: param_bounds) -> Kind {\n     let mut kind = kind_noncopyable();\n     for vec::each(*bounds) |bound| {\n@@ -876,7 +878,7 @@ fn mk_t(cx: ctxt, +st: sty) -> t { mk_t_with_id(cx, st, None) }\n // and returns the box as cast to an unsafe ptr (see comments for t above).\n fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n     let key = intern_key { sty: to_unsafe_ptr(&st), o_def_id: o_def_id };\n-    match cx.interner.find(key) {\n+    match cx.interner.find(&key) {\n       Some(t) => unsafe { return cast::reinterpret_cast(&t); },\n       _ => ()\n     }\n@@ -925,8 +927,12 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n       }\n       &ty_rec(ref flds) => for flds.each |f| { flags |= get(f.mt.ty).flags; },\n       &ty_tup(ref ts) => for ts.each |tt| { flags |= get(*tt).flags; },\n-      &ty_fn(ref f) => {\n-        flags |= rflags(f.meta.region);\n+      &ty_bare_fn(ref f) => {\n+        for f.sig.inputs.each |a| { flags |= get(a.ty).flags; }\n+        flags |= get(f.sig.output).flags;\n+      }\n+      &ty_closure(ref f) => {\n+        flags |= rflags(f.region);\n         for f.sig.inputs.each |a| { flags |= get(a.ty).flags; }\n         flags |= get(f.sig.output).flags;\n       }\n@@ -1044,8 +1050,25 @@ pub fn mk_rec(cx: ctxt, +fs: ~[field]) -> t { mk_t(cx, ty_rec(fs)) }\n \n pub fn mk_tup(cx: ctxt, +ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n \n-// take a copy because we want to own the various vectors inside\n-pub fn mk_fn(cx: ctxt, +fty: FnTy) -> t { mk_t(cx, ty_fn(fty)) }\n+pub fn mk_closure(cx: ctxt, +fty: ClosureTy) -> t {\n+    mk_t(cx, ty_closure(fty))\n+}\n+\n+pub fn mk_bare_fn(cx: ctxt, +fty: BareFnTy) -> t {\n+    mk_t(cx, ty_bare_fn(fty))\n+}\n+\n+pub fn mk_ctor_fn(cx: ctxt, input_tys: &[ty::t], output: ty::t) -> t {\n+    let input_args = input_tys.map(|t| arg {mode: ast::expl(ast::by_copy),\n+                                            ty: *t});\n+    mk_bare_fn(cx,\n+               BareFnTy {\n+                   purity: ast::pure_fn,\n+                   abi: ast::RustAbi,\n+                   sig: FnSig {inputs: input_args,\n+                               output: output}})\n+}\n+\n \n pub fn mk_trait(cx: ctxt, did: ast::def_id, +substs: substs, vstore: vstore)\n          -> t {\n@@ -1074,8 +1097,8 @@ pub fn mk_param(cx: ctxt, n: uint, k: def_id) -> t {\n \n pub fn mk_type(cx: ctxt) -> t { mk_t(cx, ty_type) }\n \n-pub fn mk_opaque_closure_ptr(cx: ctxt, proto: ast::Proto) -> t {\n-    mk_t(cx, ty_opaque_closure_ptr(proto))\n+pub fn mk_opaque_closure_ptr(cx: ctxt, sigil: ast::Sigil) -> t {\n+    mk_t(cx, ty_opaque_closure_ptr(sigil))\n }\n \n pub fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n@@ -1097,13 +1120,11 @@ pub pure fn mach_sty(cfg: @session::config, t: t) -> sty {\n pub fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n         // FIXME(#2202) --- We retain by-ref for fn& things to workaround a\n         // memory leak that otherwise results when @fn is upcast to &fn.\n-    if type_is_fn(ty) {\n-        match ty_fn_proto(ty) {\n-            ast::ProtoBorrowed => {\n-                return ast::by_ref;\n-            }\n-            _ => {}\n+    match ty::get(ty).sty {\n+        ty::ty_closure(ClosureTy {sigil: ast::BorrowedSigil, _}) => {\n+            return ast::by_ref;\n         }\n+        _ => {}\n     }\n     return if tcx.legacy_modes {\n         if type_is_borrowed(ty) {\n@@ -1119,13 +1140,6 @@ pub fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n         ast::by_copy\n     };\n \n-    fn type_is_fn(ty: t) -> bool {\n-        match get(ty).sty {\n-            ty_fn(*) => true,\n-            _ => false\n-        }\n-    }\n-\n     fn type_is_borrowed(ty: t) -> bool {\n         match ty::get(ty).sty {\n             ty::ty_rptr(*) => true,\n@@ -1142,7 +1156,7 @@ pub fn default_arg_mode_for_ty(tcx: ctxt, ty: ty::t) -> ast::rmode {\n // Returns the narrowest lifetime enclosing the evaluation of the expression\n // with id `id`.\n pub fn encl_region(cx: ctxt, id: ast::node_id) -> ty::Region {\n-    match cx.region_map.find(id) {\n+    match cx.region_map.find(&id) {\n       Some(encl_scope) => ty::re_scope(encl_scope),\n       None => ty::re_static\n     }\n@@ -1171,7 +1185,11 @@ pub fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n         for fields.each |fl| { maybe_walk_ty(fl.mt.ty, f); }\n       }\n       ty_tup(ts) => { for ts.each |tt| { maybe_walk_ty(*tt, f); } }\n-      ty_fn(ref ft) => {\n+      ty_bare_fn(ref ft) => {\n+        for ft.sig.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n+        maybe_walk_ty(ft.sig.output, f);\n+      }\n+      ty_closure(ref ft) => {\n         for ft.sig.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n         maybe_walk_ty(ft.sig.output, f);\n       }\n@@ -1235,9 +1253,13 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n             let new_ts = vec::map(ts, |tt| fldop(*tt));\n             ty_tup(new_ts)\n         }\n-        ty_fn(ref f) => {\n+        ty_bare_fn(ref f) => {\n+            let sig = fold_sig(&f.sig, fldop);\n+            ty_bare_fn(BareFnTy {sig: sig, abi: f.abi, purity: f.purity})\n+        }\n+        ty_closure(ref f) => {\n             let sig = fold_sig(&f.sig, fldop);\n-            ty_fn(FnTyBase {meta: f.meta, sig: sig})\n+            ty_closure(ClosureTy {sig: sig, ..copy *f})\n         }\n         ty_rptr(r, tm) => {\n             ty_rptr(r, mt {ty: fldop(tm.ty), mutbl: tm.mutbl})\n@@ -1318,41 +1340,21 @@ pub fn fold_regions_and_ty(\n       ty_trait(def_id, ref substs, vst) => {\n         ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt), vst)\n       }\n-      ty_fn(ref f) => {\n-          ty::mk_fn(cx, FnTyBase {meta: FnMeta {region: fldr(f.meta.region),\n-                                                ..f.meta},\n-                                  sig: fold_sig(&f.sig, fldfnt)})\n+      ty_bare_fn(ref f) => {\n+          ty::mk_bare_fn(cx, BareFnTy {sig: fold_sig(&f.sig, fldfnt),\n+                                       ..copy *f})\n+      }\n+      ty_closure(ref f) => {\n+          ty::mk_closure(cx, ClosureTy {region: fldr(f.region),\n+                                        sig: fold_sig(&f.sig, fldfnt),\n+                                        ..copy *f})\n       }\n       ref sty => {\n         fold_sty_to_ty(cx, sty, |t| fldt(t))\n       }\n     }\n }\n \n-/* A little utility: it often happens that I have a `fn_ty`,\n- * but I want to use some function like `fold_regions_and_ty()`\n- * that is defined over all types.  This utility converts to\n- * a full type and back.  It's not the best way to do this (somewhat\n- * inefficient to do the conversion), it would be better to refactor\n- * all this folding business.  However, I've been waiting on that\n- * until trait support is improved. */\n-pub fn apply_op_on_t_to_ty_fn(\n-    cx: ctxt,\n-    f: &FnTy,\n-    t_op: fn(t) -> t) -> FnTy\n-{\n-    let t0 = ty::mk_fn(cx, /*bad*/copy *f);\n-    let t1 = t_op(t0);\n-    match ty::get(t1).sty {\n-        ty::ty_fn(copy f) => {\n-            move f\n-        }\n-        _ => {\n-            cx.sess.bug(~\"`t_op` did not return a function type\");\n-        }\n-    }\n-}\n-\n // n.b. this function is intended to eventually replace fold_region() below,\n // that is why its name is so similar.\n pub fn fold_regions(\n@@ -1372,41 +1374,6 @@ pub fn fold_regions(\n     do_fold(cx, ty, false, fldr)\n }\n \n-pub fn fold_region(cx: ctxt, t0: t, fldop: fn(Region, bool) -> Region) -> t {\n-    fn do_fold(cx: ctxt, t0: t, under_r: bool,\n-               fldop: fn(Region, bool) -> Region) -> t {\n-        let tb = get(t0);\n-        if !tbox_has_flag(tb, has_regions) { return t0; }\n-        match tb.sty {\n-          ty_rptr(r, mt {ty: t1, mutbl: m}) => {\n-            let m_r = fldop(r, under_r);\n-            let m_t1 = do_fold(cx, t1, true, fldop);\n-            ty::mk_rptr(cx, m_r, mt {ty: m_t1, mutbl: m})\n-          }\n-          ty_estr(vstore_slice(r)) => {\n-            let m_r = fldop(r, under_r);\n-            ty::mk_estr(cx, vstore_slice(m_r))\n-          }\n-          ty_evec(mt {ty: t1, mutbl: m}, vstore_slice(r)) => {\n-            let m_r = fldop(r, under_r);\n-            let m_t1 = do_fold(cx, t1, true, fldop);\n-            ty::mk_evec(cx, mt {ty: m_t1, mutbl: m}, vstore_slice(m_r))\n-          }\n-          ty_fn(_) => {\n-            // do not recurse into functions, which introduce fresh bindings\n-            t0\n-          }\n-          ref sty => {\n-            do fold_sty_to_ty(cx, sty) |t| {\n-                do_fold(cx, t, under_r, fldop)\n-            }\n-          }\n-      }\n-    }\n-\n-    do_fold(cx, t0, false, fldop)\n-}\n-\n // Substitute *only* type parameters.  Used in trans where regions are erased.\n pub fn subst_tps(cx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n     if tps.len() == 0u && self_ty_opt.is_none() { return typ; }\n@@ -1529,7 +1496,9 @@ pub fn type_is_bool(ty: t) -> bool { get(ty).sty == ty_bool }\n \n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_rec(_) | ty_struct(*) | ty_tup(_) | ty_enum(*) | ty_fn(_) |\n+      ty_rec(_) | ty_struct(*) | ty_tup(_) | ty_enum(*) |\n+      ty_closure(_) |\n+      ty_bare_fn(_) | // FIXME(#4804) Bare fn repr\n       ty_trait(*) |\n       ty_evec(_, vstore_fixed(_)) | ty_estr(vstore_fixed(_)) |\n       ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_))\n@@ -1653,7 +1622,7 @@ pub fn type_is_immediate(ty: t) -> bool {\n }\n \n pub fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n-    match cx.needs_drop_cache.find(ty) {\n+    match cx.needs_drop_cache.find(&ty) {\n       Some(result) => return result,\n       None => {/* fall through */ }\n     }\n@@ -1715,10 +1684,11 @@ pub fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n         }\n         accum\n       }\n-      ty_fn(ref fty) => {\n-        match fty.meta.proto {\n-          ast::ProtoBare | ast::ProtoBorrowed => false,\n-          ast::ProtoBox | ast::ProtoUniq => true,\n+      ty_bare_fn(*) => false,\n+      ty_closure(ref fty) => {\n+        match fty.sigil {\n+          ast::BorrowedSigil => false,\n+          ast::ManagedSigil | ast::OwnedSigil => true,\n         }\n       }\n     };\n@@ -1732,7 +1702,7 @@ pub fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n // that only contain scalars and shared boxes can avoid unwind\n // cleanups.\n pub fn type_needs_unwind_cleanup(cx: ctxt, ty: t) -> bool {\n-    match cx.needs_unwind_cleanup_cache.find(ty) {\n+    match cx.needs_unwind_cleanup_cache.find(&ty) {\n       Some(result) => return result,\n       None => ()\n     }\n@@ -1749,7 +1719,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n                               encountered_box: bool) -> bool {\n \n     // Prevent infinite recursion\n-    match tycache.find(ty) {\n+    match tycache.find(&ty) {\n       Some(_) => return false,\n       None => { tycache.insert(ty, ()); }\n     }\n@@ -1813,7 +1783,7 @@ pub enum Kind { kind_(u32) }\n const KIND_MASK_COPY         : u32 = 0b000000000000000000000000001_u32;\n \n /// no shared box, borrowed ptr (must imply DURABLE)\n-const KIND_MASK_OWNED         : u32 = 0b000000000000000000000000010_u32;\n+const KIND_MASK_OWNED        : u32 = 0b000000000000000000000000010_u32;\n \n /// is durable (no borrowed ptrs)\n const KIND_MASK_DURABLE      : u32 = 0b000000000000000000000000100_u32;\n@@ -1942,20 +1912,25 @@ pub pure fn kind_is_durable(k: Kind) -> bool {\n     *k & KIND_MASK_DURABLE == KIND_MASK_DURABLE\n }\n \n-pub fn meta_kind(p: FnMeta) -> Kind {\n-    match p.proto { // XXX consider the kind bounds!\n-        ast::ProtoBare => {\n-            kind_safe_for_default_mode_send() | kind_const() | kind_durable()\n-        }\n-        ast::ProtoBorrowed => {\n-            kind_noncopyable() | kind_(KIND_MASK_DEFAULT_MODE)\n-        }\n-        ast::ProtoBox => {\n-            kind_safe_for_default_mode() | kind_durable()\n-        }\n-        ast::ProtoUniq => {\n-            kind_owned_copy() | kind_durable()\n-        }\n+pure fn kind_is_const(k: Kind) -> bool {\n+    *k & KIND_MASK_CONST == KIND_MASK_CONST\n+}\n+\n+fn closure_kind(cty: &ClosureTy) -> Kind {\n+    let kind = match cty.sigil {\n+        ast::BorrowedSigil => kind_implicitly_copyable(),\n+        ast::ManagedSigil => kind_implicitly_copyable(),\n+        ast::OwnedSigil => kind_owned_only() | kind_durable(),\n+    };\n+\n+    let kind = match cty.region {\n+        re_static => kind | kind_durable(),\n+        _ => kind - kind_owned_only() - kind_durable()\n+    };\n+\n+    match cty.onceness {\n+        ast::Once => kind - kind_implicitly_copyable(),\n+        ast::Many => kind\n     }\n }\n \n@@ -2011,7 +1986,7 @@ pub fn type_kind(cx: ctxt, ty: t) -> Kind {\n // If `allow_ty_var` is true, then this is a conservative assumption; we\n // assume that type variables *do* have all kinds.\n pub fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n-    match cx.kind_cache.find(ty) {\n+    match cx.kind_cache.find(&ty) {\n       Some(result) => return result,\n       None => {/* fall through */ }\n     }\n@@ -2022,7 +1997,7 @@ pub fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n     let mut result = match /*bad*/copy get(ty).sty {\n       // Scalar and unique types are sendable, constant, and owned\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_ptr(_) => {\n+      ty_bare_fn(_) | ty_ptr(_) => {\n         kind_safe_for_default_mode_send() | kind_const() | kind_durable()\n       }\n \n@@ -2035,8 +2010,9 @@ pub fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n         }\n       }\n \n-      // functions depend on the protocol\n-      ty_fn(ref f) => meta_kind(f.meta),\n+      ty_closure(ref c) => {\n+          closure_kind(c)\n+      }\n \n       // Those with refcounts raise noncopyable to copyable,\n       // lower sendable to copyable. Therefore just set result to copyable.\n@@ -2165,7 +2141,7 @@ pub fn type_kind_ext(cx: ctxt, ty: t, allow_ty_var: bool) -> Kind {\n           // cross-crate inlining code to translate a def-id.\n           assert p.def_id.crate == ast::local_crate;\n \n-          param_bounds_to_kind(cx.ty_param_bounds.get(p.def_id.node))\n+          param_bounds_to_kind(cx.ty_param_bounds.get(&p.def_id.node))\n       }\n \n       // self is a special type parameter that can only appear in traits; it\n@@ -2215,7 +2191,8 @@ fn type_size(cx: ctxt, ty: t) -> uint {\n \n       ty_evec(_, vstore_slice(_)) |\n       ty_estr(vstore_slice(_)) |\n-      ty_fn(_) => {\n+      ty_bare_fn(*) |\n+      ty_closure(*) => {\n         2\n       }\n \n@@ -2297,7 +2274,8 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           ty_uint(_) |\n           ty_float(_) |\n           ty_estr(_) |\n-          ty_fn(_) |\n+          ty_bare_fn(_) |\n+          ty_closure(_) |\n           ty_infer(_) |\n           ty_err |\n           ty_param(_) |\n@@ -2435,7 +2413,7 @@ pub fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n \n pub fn type_is_integral(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_infer(IntVar(_)) | ty_int(_) | ty_uint(_) | ty_bool => true,\n+      ty_infer(IntVar(_)) | ty_int(_) | ty_uint(_) => true,\n       _ => false\n     }\n }\n@@ -2472,9 +2450,9 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     match /*bad*/copy get(ty).sty {\n       // Scalar types\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_type | ty_ptr(_) => result = true,\n+      ty_type | ty_ptr(_) | ty_bare_fn(_) => result = true,\n       // Boxed types\n-      ty_box(_) | ty_uniq(_) | ty_fn(_) |\n+      ty_box(_) | ty_uniq(_) | ty_closure(_) |\n       ty_estr(vstore_uniq) | ty_estr(vstore_box) |\n       ty_evec(_, vstore_uniq) | ty_evec(_, vstore_box) |\n       ty_trait(_, _, _) | ty_rptr(_,_) | ty_opaque_box => result = false,\n@@ -2700,14 +2678,9 @@ impl arg : to_bytes::IterBytes {\n     }\n }\n \n-impl FnMeta : to_bytes::IterBytes {\n+impl Kind : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_5(&self.purity,\n-                               &self.proto,\n-                               &self.onceness,\n-                               &self.region,\n-                               &self.bounds,\n-                               lsb0, f);\n+        (**self).iter_bytes(lsb0, f)\n     }\n }\n \n@@ -2755,7 +2728,7 @@ impl sty : to_bytes::IterBytes {\n           ty_rec(ref fs) =>\n           to_bytes::iter_bytes_2(&11u8, fs, lsb0, f),\n \n-          ty_fn(ref ft) =>\n+          ty_bare_fn(ref ft) =>\n           to_bytes::iter_bytes_2(&12u8, ft, lsb0, f),\n \n           ty_self => 13u8.iter_bytes(lsb0, f),\n@@ -2789,7 +2762,10 @@ impl sty : to_bytes::IterBytes {\n           ty_rptr(ref r, ref mt) =>\n           to_bytes::iter_bytes_3(&24u8, r, mt, lsb0, f),\n \n-          ty_err => 25u8.iter_bytes(lsb0, f)\n+          ty_err => 25u8.iter_bytes(lsb0, f),\n+\n+          ty_closure(ref ct) =>\n+          to_bytes::iter_bytes_2(&26u8, ct, lsb0, f),\n         }\n     }\n }\n@@ -2810,7 +2786,7 @@ pub fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n }\n \n pub fn node_id_to_type_params(cx: ctxt, id: ast::node_id) -> ~[t] {\n-    match cx.node_type_substs.find(id) {\n+    match cx.node_type_substs.find(&id) {\n       None => return ~[],\n       Some(ts) => return ts\n     }\n@@ -2823,36 +2799,48 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n // Type accessors for substructures of types\n pub fn ty_fn_args(fty: t) -> ~[arg] {\n     match get(fty).sty {\n-      ty_fn(ref f) => /*bad*/copy f.sig.inputs,\n-      _ => die!(~\"ty_fn_args() called on non-fn type\")\n+        ty_bare_fn(ref f) => copy f.sig.inputs,\n+        ty_closure(ref f) => copy f.sig.inputs,\n+        ref s => {\n+            die!(fmt!(\"ty_fn_args() called on non-fn type: %?\", s))\n+        }\n     }\n }\n \n-pub fn ty_fn_proto(fty: t) -> Proto {\n+pub fn ty_closure_sigil(fty: t) -> Sigil {\n     match get(fty).sty {\n-      ty_fn(ref f) => f.meta.proto,\n-      _ => die!(~\"ty_fn_proto() called on non-fn type\")\n+        ty_closure(ref f) => f.sigil,\n+        ref s => {\n+            die!(fmt!(\"ty_closure_sigil() called on non-closure type: %?\", s))\n+        }\n     }\n }\n \n pub fn ty_fn_purity(fty: t) -> ast::purity {\n     match get(fty).sty {\n-      ty_fn(ref f) => f.meta.purity,\n-      _ => die!(~\"ty_fn_purity() called on non-fn type\")\n+        ty_bare_fn(ref f) => f.purity,\n+        ty_closure(ref f) => f.purity,\n+        ref s => {\n+            die!(fmt!(\"ty_fn_purity() called on non-fn type: %?\", s))\n+        }\n     }\n }\n \n pub pure fn ty_fn_ret(fty: t) -> t {\n     match get(fty).sty {\n-        ty_fn(ref f) => f.sig.output,\n-        _ => die!(~\"ty_fn_ret() called on non-fn type\")\n+        ty_bare_fn(ref f) => f.sig.output,\n+        ty_closure(ref f) => f.sig.output,\n+        ref s => {\n+            die!(fmt!(\"ty_fn_ret() called on non-fn type: %?\", s))\n+        }\n     }\n }\n \n fn is_fn_ty(fty: t) -> bool {\n     match get(fty).sty {\n-      ty_fn(_) => true,\n-      _ => false\n+        ty_bare_fn(_) => true,\n+        ty_closure(_) => true,\n+        _ => false\n     }\n }\n \n@@ -2874,17 +2862,17 @@ pub fn ty_region(ty: t) -> Region {\n     }\n }\n \n-pub fn replace_fn_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n+pub fn replace_closure_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n     /*!\n      *\n      * Returns a new function type based on `fn_type` but returning a value of\n      * type `ret_type` instead. */\n \n     match ty::get(fn_type).sty {\n-        ty::ty_fn(ref fty) => {\n-            ty::mk_fn(tcx, FnTyBase {\n-                meta: fty.meta,\n-                sig: FnSig {output: ret_type, ..copy fty.sig}\n+        ty::ty_closure(ref fty) => {\n+            ty::mk_closure(tcx, ClosureTy {\n+                sig: FnSig {output: ret_type, ..copy fty.sig},\n+                ..copy *fty\n             })\n         }\n         _ => {\n@@ -2900,12 +2888,6 @@ pub fn tys_in_fn_sig(sig: &FnSig) -> ~[t] {\n     vec::append_one(sig.inputs.map(|a| a.ty), sig.output)\n }\n \n-// Just checks whether it's a fn that returns bool,\n-// not its purity.\n-pub fn is_pred_ty(fty: t) -> bool {\n-    is_fn_ty(fty) && type_is_bool(ty_fn_ret(fty))\n-}\n-\n // Type accessors for AST nodes\n pub fn block_ty(cx: ctxt, b: &ast::blk) -> t {\n     return node_id_to_type(cx, b.node.id);\n@@ -2950,7 +2932,7 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n \n     let unadjusted_ty = expr_ty(cx, expr);\n \n-    return match cx.adjustments.find(expr.id) {\n+    return match cx.adjustments.find(&expr.id) {\n         None => unadjusted_ty,\n \n         Some(adj) => {\n@@ -3023,11 +3005,12 @@ pub fn expr_ty_adjusted(cx: ctxt, expr: @ast::expr) -> t {\n     fn borrow_fn(cx: ctxt, expr: @ast::expr,\n                  autoref: &AutoRef, ty: ty::t) -> ty::t {\n         match get(ty).sty {\n-            ty_fn(ref fty) => {\n-                ty::mk_fn(cx, FnTyBase {meta: FnMeta {proto: ProtoBorrowed,\n-                                                      region: autoref.region,\n-                                                      ..copy fty.meta},\n-                                        sig: copy fty.sig})\n+            ty_closure(ref fty) => {\n+                ty::mk_closure(cx, ClosureTy {\n+                    sigil: BorrowedSigil,\n+                    region: autoref.region,\n+                    ..copy *fty\n+                })\n             }\n \n             ref s => {\n@@ -3054,7 +3037,7 @@ pub fn expr_has_ty_params(cx: ctxt, expr: @ast::expr) -> bool {\n pub fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n                           id: ast::node_id)\n     -> Option<@~[param_bounds]> {\n-    do method_map.find(id).map |method| {\n+    do method_map.find(&id).map |method| {\n         match method.origin {\n           typeck::method_static(did) => {\n             // n.b.: When we encode impl methods, the bounds\n@@ -3081,7 +3064,7 @@ pub fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n }\n \n fn resolve_expr(tcx: ctxt, expr: @ast::expr) -> ast::def {\n-    match tcx.def_map.find(expr.id) {\n+    match tcx.def_map.find(&expr.id) {\n         Some(def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, fmt!(\n@@ -3335,7 +3318,7 @@ pub fn occurs_check(tcx: ctxt, sp: span, vid: TyVid, rt: t) {\n fn canon<T:Copy cmp::Eq>(tbl: HashMap<ast::node_id, ast::inferable<T>>,\n                          +m0: ast::inferable<T>) -> ast::inferable<T> {\n     match m0 {\n-      ast::infer(id) => match tbl.find(id) {\n+      ast::infer(id) => match tbl.find(&id) {\n         None => m0,\n         Some(ref m1) => {\n             let cm1 = canon(tbl, (*m1));\n@@ -3417,7 +3400,8 @@ pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_ptr(_) => ~\"*-ptr\",\n       ty_rptr(_, _) => ~\"&-ptr\",\n       ty_rec(_) => ~\"record\",\n-      ty_fn(_) => ~\"fn\",\n+      ty_bare_fn(_) => ~\"extern fn\",\n+      ty_closure(_) => ~\"fn\",\n       ty_trait(id, _, _) => fmt!(\"trait %s\", item_path_str(cx, id)),\n       ty_struct(id, _) => fmt!(\"struct %s\", item_path_str(cx, id)),\n       ty_tup(_) => ~\"tuple\",\n@@ -3455,14 +3439,18 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n             fmt!(\"expected %s fn but found %s fn\",\n                  values.expected.to_str(), values.found.to_str())\n         }\n+        terr_abi_mismatch(values) => {\n+            fmt!(\"expected %s fn but found %s fn\",\n+                 values.expected.to_str(), values.found.to_str())\n+        }\n         terr_onceness_mismatch(values) => {\n             fmt!(\"expected %s fn but found %s fn\",\n                  values.expected.to_str(), values.found.to_str())\n         }\n-        terr_proto_mismatch(values) => {\n+        terr_sigil_mismatch(values) => {\n             fmt!(\"expected %s closure, found %s closure\",\n-                 proto_ty_to_str(cx, values.expected, false),\n-                 proto_ty_to_str(cx, values.found, false))\n+                 values.expected.to_str(),\n+                 values.found.to_str())\n         }\n         terr_mutability => ~\"values differ in mutability\",\n         terr_box_mutability => ~\"boxed values differ in mutability\",\n@@ -3597,7 +3585,7 @@ pub fn store_trait_methods(cx: ctxt, id: ast::node_id, ms: @~[method]) {\n \n pub fn provided_trait_methods(cx: ctxt, id: ast::def_id) -> ~[ast::ident] {\n     if is_local(id) {\n-        match cx.items.find(id.node) {\n+        match cx.items.find(&id.node) {\n             Some(ast_map::node_item(@ast::item {\n                         node: item_trait(_, _, ref ms),\n                         _\n@@ -3617,7 +3605,7 @@ pub fn trait_supertraits(cx: ctxt,\n                          id: ast::def_id)\n                       -> @~[InstantiatedTraitRef] {\n     // Check the cache.\n-    match cx.supertraits.find(id) {\n+    match cx.supertraits.find(&id) {\n         Some(instantiated_trait_info) => { return instantiated_trait_info; }\n         None => {}  // Continue.\n     }\n@@ -3646,7 +3634,7 @@ pub fn trait_supertraits(cx: ctxt,\n }\n \n pub fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n-    match cx.trait_method_cache.find(id) {\n+    match cx.trait_method_cache.find(&id) {\n       // Local traits are supposed to have been added explicitly.\n       Some(ms) => ms,\n       _ => {\n@@ -3680,7 +3668,7 @@ pub fn impl_traits(cx: ctxt, id: ast::def_id, vstore: vstore) -> ~[t] {\n \n     if id.crate == ast::local_crate {\n         debug!(\"(impl_traits) searching for trait impl %?\", id);\n-        match cx.items.find(id.node) {\n+        match cx.items.find(&id.node) {\n            Some(ast_map::node_item(@ast::item {\n                         node: ast::item_impl(_, opt_trait, _, _),\n                         _},\n@@ -3716,7 +3704,7 @@ fn struct_ctor_id(cx: ctxt, struct_did: ast::def_id) -> Option<ast::def_id> {\n         cx.sess.unimpl(~\"constructor ID of cross-crate tuple structs\");\n     }\n \n-    match cx.items.find(struct_did.node) {\n+    match cx.items.find(&struct_did.node) {\n         Some(ast_map::node_item(item, _)) => {\n             match item.node {\n                 ast::item_struct(struct_def, _) => {\n@@ -3782,13 +3770,13 @@ impl DtorKind {\n /* If struct_id names a struct with a dtor, return Some(the dtor's id).\n    Otherwise return none. */\n pub fn ty_dtor(cx: ctxt, struct_id: def_id) -> DtorKind {\n-    match cx.destructor_for_type.find(struct_id) {\n+    match cx.destructor_for_type.find(&struct_id) {\n         Some(method_def_id) => return TraitDtor(method_def_id),\n         None => {}  // Continue.\n     }\n \n     if is_local(struct_id) {\n-       match cx.items.find(struct_id.node) {\n+       match cx.items.find(&struct_id.node) {\n            Some(ast_map::node_item(@ast::item {\n                node: ast::item_struct(@ast::struct_def { dtor: Some(ref dtor),\n                                                          _ },\n@@ -3816,7 +3804,7 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n     if id.crate != ast::local_crate {\n         csearch::get_item_path(cx, id)\n     } else {\n-        let node = cx.items.get(id.node);\n+        let node = cx.items.get(&id.node);\n         match node {\n           ast_map::node_item(item, path) => {\n             let item_elt = match item.node {\n@@ -3880,7 +3868,7 @@ pub fn type_is_empty(cx: ctxt, t: t) -> bool {\n }\n \n pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n-    match cx.enum_var_cache.find(id) {\n+    match cx.enum_var_cache.find(&id) {\n       Some(variants) => return variants,\n       _ => { /* fallthrough */ }\n     }\n@@ -3893,7 +3881,7 @@ pub fn enum_variants(cx: ctxt, id: ast::def_id) -> @~[VariantInfo] {\n           call eval_const_expr, it should never get called twice for the same\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n-        match cx.items.get(id.node) {\n+        match cx.items.get(&id.node) {\n           ast_map::node_item(@ast::item {\n                     node: ast::item_enum(ref enum_definition, _),\n                     _\n@@ -3967,7 +3955,7 @@ pub fn enum_variant_with_id(cx: ctxt,\n pub fn lookup_item_type(cx: ctxt,\n                         did: ast::def_id)\n                      -> ty_param_bounds_and_ty {\n-    match cx.tcache.find(did) {\n+    match cx.tcache.find(&did) {\n       Some(tpt) => {\n         // The item is in this crate. The caller should have added it to the\n         // type cache already\n@@ -3993,7 +3981,7 @@ pub fn lookup_field_type(tcx: ctxt,\n         node_id_to_type(tcx, id.node)\n     }\n     else {\n-        match tcx.tcache.find(id) {\n+        match tcx.tcache.find(&id) {\n            Some(tpt) => tpt.ty,\n            None => {\n                let tpt = csearch::get_field_type(tcx, struct_id, id);\n@@ -4009,7 +3997,7 @@ pub fn lookup_field_type(tcx: ctxt,\n // Fails if the id is not bound to a struct.\n pub fn lookup_struct_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n   if did.crate == ast::local_crate {\n-    match cx.items.find(did.node) {\n+    match cx.items.find(&did.node) {\n        Some(ast_map::node_item(i,_)) => {\n          match i.node {\n             ast::item_struct(struct_def, _) => {\n@@ -4214,7 +4202,7 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n         }\n     }\n \n-    match cx.normalized_cache.find(t) {\n+    match cx.normalized_cache.find(&t) {\n       Some(t) => return t,\n       None => ()\n     }\n@@ -4232,13 +4220,10 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n             // This type has a region. Get rid of it\n             mk_rptr(cx, re_static, normalize_mt(cx, mt)),\n \n-        ty_fn(ref fn_ty) => {\n-            mk_fn(cx, FnTyBase {\n-                meta: FnMeta {\n-                    region: ty::re_static,\n-                    ..fn_ty.meta\n-                },\n-                sig: /*bad*/copy fn_ty.sig\n+        ty_closure(ref closure_ty) => {\n+            mk_closure(cx, ClosureTy {\n+                region: ty::re_static,\n+                ..copy *closure_ty\n             })\n         }\n \n@@ -4310,13 +4295,13 @@ pub fn eval_repeat_count(tcx: ctxt,\n // Determine what purity to check a nested function under\n pub pure fn determine_inherited_purity(parent_purity: ast::purity,\n                                        child_purity: ast::purity,\n-                                       child_proto: ast::Proto)\n+                                       child_sigil: ast::Sigil)\n                                     -> ast::purity {\n     // If the closure is a stack closure and hasn't had some non-standard\n     // purity inferred for it, then check it under its parent's purity.\n     // Otherwise, use its own\n-    match child_proto {\n-        ast::ProtoBorrowed if child_purity == ast::impure_fn => parent_purity,\n+    match child_sigil {\n+        ast::BorrowedSigil if child_purity == ast::impure_fn => parent_purity,\n         _ => child_purity\n     }\n }\n@@ -4397,8 +4382,8 @@ pub fn count_traits_and_supertraits(tcx: ctxt,\n \n // Given a trait and a type, returns the impl of that type\n pub fn get_impl_id(tcx: ctxt, trait_id: def_id, self_ty: t) -> def_id {\n-    match tcx.trait_impls.find(trait_id) {\n-        Some(ty_to_impl) => match ty_to_impl.find(self_ty) {\n+    match tcx.trait_impls.find(&trait_id) {\n+        Some(ty_to_impl) => match ty_to_impl.find(&self_ty) {\n             Some(the_impl) => the_impl.did,\n             None => // try autoderef!\n                 match deref(tcx, self_ty, false) {\n@@ -4526,171 +4511,6 @@ impl bound_region : cmp::Eq {\n     pure fn ne(&self, other: &bound_region) -> bool { !(*self).eq(other) }\n }\n \n-impl sty : cmp::Eq {\n-    pure fn eq(&self, other: &sty) -> bool {\n-        match (/*bad*/copy *self) {\n-            ty_nil => {\n-                match (*other) {\n-                    ty_nil => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bot => {\n-                match (*other) {\n-                    ty_bot => true,\n-                    _ => false\n-                }\n-            }\n-            ty_bool => {\n-                match (*other) {\n-                    ty_bool => true,\n-                    _ => false\n-                }\n-            }\n-            ty_int(e0a) => {\n-                match (*other) {\n-                    ty_int(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uint(e0a) => {\n-                match (*other) {\n-                    ty_uint(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_float(e0a) => {\n-                match (*other) {\n-                    ty_float(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_estr(e0a) => {\n-                match (*other) {\n-                    ty_estr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_enum(e0a, ref e1a) => {\n-                match (*other) {\n-                    ty_enum(e0b, ref e1b) => e0a == e0b && (*e1a) == (*e1b),\n-                    _ => false\n-                }\n-            }\n-            ty_box(e0a) => {\n-                match (*other) {\n-                    ty_box(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_uniq(e0a) => {\n-                match (*other) {\n-                    ty_uniq(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_evec(e0a, e1a) => {\n-                match (*other) {\n-                    ty_evec(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_ptr(e0a) => {\n-                match (*other) {\n-                    ty_ptr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_rptr(e0a, e1a) => {\n-                match (*other) {\n-                    ty_rptr(e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            ty_rec(e0a) => {\n-                match (/*bad*/copy *other) {\n-                    ty_rec(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_fn(ref e0a) => {\n-                match (*other) {\n-                    ty_fn(ref e0b) => (*e0a) == (*e0b),\n-                    _ => false\n-                }\n-            }\n-            ty_trait(e0a, ref e1a, e2a) => {\n-                match (*other) {\n-                    ty_trait(e0b, ref e1b, e2b) =>\n-                        e0a == e0b && (*e1a) == (*e1b) && e2a == e2b,\n-                    _ => false\n-                }\n-            }\n-            ty_struct(e0a, ref e1a) => {\n-                match (*other) {\n-                    ty_struct(e0b, ref e1b) => e0a == e0b && (*e1a) == (*e1b),\n-                    _ => false\n-                }\n-            }\n-            ty_tup(e0a) => {\n-                match (/*bad*/copy *other) {\n-                    ty_tup(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_infer(ref e0a) => {\n-                match (*other) {\n-                    ty_infer(ref e0b) => *e0a == *e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_err => {\n-                match (*other) {\n-                    ty_err => true,\n-                    _ => false\n-                }\n-            }\n-            ty_param(e0a) => {\n-                match (*other) {\n-                    ty_param(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_self => {\n-                match (*other) {\n-                    ty_self => true,\n-                    _ => false\n-                }\n-            }\n-            ty_type => {\n-                match (*other) {\n-                    ty_type => true,\n-                    _ => false\n-                }\n-            }\n-            ty_opaque_box => {\n-                match (*other) {\n-                    ty_opaque_box => true,\n-                    _ => false\n-                }\n-            }\n-            ty_opaque_closure_ptr(e0a) => {\n-                match (*other) {\n-                    ty_opaque_closure_ptr(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            ty_unboxed_vec(e0a) => {\n-                match (*other) {\n-                    ty_unboxed_vec(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &sty) -> bool { !(*self).eq(other) }\n-}\n-\n impl param_bound : cmp::Eq {\n     pure fn eq(&self, other: &param_bound) -> bool {\n         match (*self) {"}, {"sha": "0aafeac265aef412ab861ed0db99eb7f28a44cb6", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 88, "deletions": 64, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -55,7 +55,7 @@\n use core::prelude::*;\n \n use middle::pat_util::pat_id_map;\n-use middle::ty::{FnTyBase, FnMeta, FnSig, arg, field, substs};\n+use middle::ty::{arg, field, substs};\n use middle::ty::{ty_param_substs_and_ty};\n use middle::ty;\n use middle::typeck::check::fn_ctxt;\n@@ -70,7 +70,7 @@ use core::vec;\n use syntax::ast;\n use syntax::codemap::span;\n use syntax::print::pprust::path_to_str;\n-use util::common::indent;\n+use util::common::indenter;\n \n pub trait ast_conv {\n     fn tcx() -> ty::ctxt;\n@@ -211,7 +211,7 @@ pub fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n                 return ty::mk_evec(tcx, mt, vst);\n             }\n             ast::ty_path(path, id) if a_seq_ty.mutbl == ast::m_imm => {\n-                match tcx.def_map.find(id) {\n+                match tcx.def_map.find(&id) {\n                     Some(ast::def_prim_ty(ast::ty_str)) => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n                         return ty::mk_estr(tcx, vst);\n@@ -273,7 +273,7 @@ pub fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n \n     let tcx = self.tcx();\n \n-    match tcx.ast_ty_to_ty_cache.find(ast_ty) {\n+    match tcx.ast_ty_to_ty_cache.find(&ast_ty) {\n       Some(ty::atttce_resolved(ty)) => return ty,\n       Some(ty::atttce_unresolved) => {\n         tcx.sess.span_fatal(ast_ty.span, ~\"illegal recursive type; \\\n@@ -321,16 +321,19 @@ pub fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Durable>(\n         };\n         ty::mk_rec(tcx, flds)\n       }\n-      ast::ty_fn(f) => {\n-        let bounds = collect::compute_bounds(self.ccx(), f.bounds);\n-        let fn_decl = ty_of_fn_decl(self, rscope, f.proto,\n-                                    f.purity, f.onceness,\n-                                    bounds, f.region, f.decl, None,\n-                                    ast_ty.span);\n-        ty::mk_fn(tcx, fn_decl)\n+      ast::ty_bare_fn(bf) => {\n+          ty::mk_bare_fn(tcx, ty_of_bare_fn(self, rscope, bf.purity,\n+                                            bf.abi, bf.decl))\n+      }\n+      ast::ty_closure(f) => {\n+          let fn_decl = ty_of_closure(self, rscope, f.sigil,\n+                                      f.purity, f.onceness,\n+                                      f.region, f.decl, None,\n+                                      ast_ty.span);\n+          ty::mk_closure(tcx, fn_decl)\n       }\n       ast::ty_path(path, id) => {\n-        let a_def = match tcx.def_map.find(id) {\n+        let a_def = match tcx.def_map.find(&id) {\n           None => tcx.sess.span_fatal(\n               ast_ty.span, fmt!(\"unbound path %s\",\n                                 path_to_str(path, tcx.sess.intr()))),\n@@ -452,71 +455,92 @@ pub fn ty_of_arg<AC: ast_conv, RS: region_scope Copy Durable>(\n     arg {mode: mode, ty: ty}\n }\n \n-pub type expected_tys = Option<{inputs: ~[ty::arg],\n-                                output: ty::t}>;\n+pub fn ty_of_bare_fn<AC: ast_conv, RS: region_scope Copy Durable>(\n+    self: AC, rscope: RS,\n+    purity: ast::purity,\n+    abi: ast::Abi,\n+    decl: ast::fn_decl) -> ty::BareFnTy\n+{\n+    debug!(\"ty_of_fn_decl\");\n+\n+    // new region names that appear inside of the fn decl are bound to\n+    // that function type\n+    let rb = in_binding_rscope(rscope);\n+\n+    let input_tys = decl.inputs.map(|a| ty_of_arg(self, rb, *a, None));\n+    let output_ty = match decl.output.node {\n+        ast::ty_infer => self.ty_infer(decl.output.span),\n+        _ => ast_ty_to_ty(self, rb, decl.output)\n+    };\n+\n+    ty::BareFnTy {\n+        purity: purity,\n+        abi: abi,\n+        sig: ty::FnSig {inputs: input_tys, output: output_ty}\n+    }\n+}\n \n-pub fn ty_of_fn_decl<AC: ast_conv, RS: region_scope Copy Durable>(\n+pub fn ty_of_closure<AC: ast_conv, RS: region_scope Copy Durable>(\n     self: AC, rscope: RS,\n-    ast_proto: ast::Proto,\n+    sigil: ast::Sigil,\n     purity: ast::purity,\n     onceness: ast::Onceness,\n-    bounds: @~[ty::param_bound],\n     opt_region: Option<@ast::region>,\n     decl: ast::fn_decl,\n-    expected_tys: expected_tys,\n-    span: span) -> ty::FnTy {\n+    expected_tys: Option<ty::FnSig>,\n+    span: span) -> ty::ClosureTy\n+{\n     debug!(\"ty_of_fn_decl\");\n-    do indent {\n-        // resolve the function bound region in the original region\n-        // scope `rscope`, not the scope of the function parameters\n-        let bound_region = match opt_region {\n-            Some(region) => {\n-                ast_region_to_region(self, rscope, span, region)\n-            }\n-            None => {\n-                match ast_proto {\n-                    ast::ProtoBare | ast::ProtoUniq | ast::ProtoBox => {\n-                        // @fn(), ~fn() default to static as the bound\n-                        // on their upvars:\n-                        ty::re_static\n-                    }\n-                    ast::ProtoBorrowed => {\n-                        // &fn() defaults to an anonymous region:\n-                        let r_result = rscope.anon_region(span);\n-                        get_region_reporting_err(self.tcx(), span, r_result)\n-                    }\n+    let _i = indenter();\n+\n+    // resolve the function bound region in the original region\n+    // scope `rscope`, not the scope of the function parameters\n+    let bound_region = match opt_region {\n+        Some(region) => {\n+            ast_region_to_region(self, rscope, span, region)\n+        }\n+        None => {\n+            match sigil {\n+                ast::OwnedSigil | ast::ManagedSigil => {\n+                    // @fn(), ~fn() default to static as the bound\n+                    // on their upvars:\n+                    ty::re_static\n+                }\n+                ast::BorrowedSigil => {\n+                    // &fn() defaults to an anonymous region:\n+                    let r_result = rscope.anon_region(span);\n+                    get_region_reporting_err(self.tcx(), span, r_result)\n                 }\n             }\n-        };\n+        }\n+    };\n \n-        // new region names that appear inside of the fn decl are bound to\n-        // that function type\n-        let rb = in_binding_rscope(rscope);\n-\n-        let input_tys = do decl.inputs.mapi |i, a| {\n-            let expected_arg_ty = do expected_tys.chain_ref |e| {\n-                // no guarantee that the correct number of expected args\n-                // were supplied\n-                if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n-            };\n-            ty_of_arg(self, rb, *a, expected_arg_ty)\n-        };\n+    // new region names that appear inside of the fn decl are bound to\n+    // that function type\n+    let rb = in_binding_rscope(rscope);\n \n-        let expected_ret_ty = expected_tys.map(|e| e.output);\n-        let output_ty = match decl.output.node {\n-          ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.get(),\n-          ast::ty_infer => self.ty_infer(decl.output.span),\n-          _ => ast_ty_to_ty(self, rb, decl.output)\n+    let input_tys = do decl.inputs.mapi |i, a| {\n+        let expected_arg_ty = do expected_tys.chain_ref |e| {\n+            // no guarantee that the correct number of expected args\n+            // were supplied\n+            if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n         };\n+        ty_of_arg(self, rb, *a, expected_arg_ty)\n+    };\n \n-        FnTyBase {\n-            meta: FnMeta {purity: purity,\n-                          proto: ast_proto,\n-                          onceness: onceness,\n-                          region: bound_region,\n-                          bounds: bounds},\n-            sig: FnSig {inputs: input_tys,\n+    let expected_ret_ty = expected_tys.map(|e| e.output);\n+    let output_ty = match decl.output.node {\n+        ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.get(),\n+        ast::ty_infer => self.ty_infer(decl.output.span),\n+        _ => ast_ty_to_ty(self, rb, decl.output)\n+    };\n+\n+    ty::ClosureTy {\n+        purity: purity,\n+        sigil: sigil,\n+        onceness: onceness,\n+        region: bound_region,\n+        sig: ty::FnSig {inputs: input_tys,\n                         output: output_ty}\n-        }\n     }\n }"}, {"sha": "1d84cb32c94b5e181bf7f7a26d00b2f9f10e1d43", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -216,7 +216,7 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n     // Typecheck each field.\n     let found_fields = HashMap();\n     for fields.each |field| {\n-        match field_map.find(field.ident) {\n+        match field_map.find(&field.ident) {\n             Some(index) => {\n                 let class_field = class_fields[index];\n                 let field_type = ty::lookup_field_type(tcx,\n@@ -259,7 +259,7 @@ pub fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n     let class_fields = ty::lookup_struct_fields(tcx, class_id);\n \n     // Check to ensure that the struct is the one specified.\n-    match tcx.def_map.find(pat_id) {\n+    match tcx.def_map.find(&pat_id) {\n         Some(ast::def_struct(supplied_def_id))\n                 if supplied_def_id == class_id => {\n             // OK.\n@@ -300,7 +300,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n     let tcx = pcx.fcx.ccx.tcx;\n \n     // Find the variant that was specified.\n-    match tcx.def_map.find(pat_id) {\n+    match tcx.def_map.find(&pat_id) {\n         Some(ast::def_variant(found_enum_id, variant_id))\n                 if found_enum_id == enum_id => {\n             // Get the struct fields from this struct-like enum variant.\n@@ -360,7 +360,7 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         fcx.write_ty(pat.id, b_ty);\n       }\n       ast::pat_ident(*) if pat_is_const(tcx.def_map, pat) => {\n-        let const_did = ast_util::def_id_of_def(tcx.def_map.get(pat.id));\n+        let const_did = ast_util::def_id_of_def(tcx.def_map.get(&pat.id));\n         let const_tpt = ty::lookup_item_type(tcx, const_did);\n         fcx.write_ty(pat.id, const_tpt.ty);\n       }\n@@ -386,7 +386,7 @@ pub fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           }\n         }\n \n-        let canon_id = pcx.map.get(ast_util::path_to_ident(name));\n+        let canon_id = pcx.map.get(&ast_util::path_to_ident(name));\n         if canon_id != pat.id {\n             let ct = fcx.local_ty(pat.span, canon_id);\n             demand::eqtype(fcx, pat.span, ct, typ);"}, {"sha": "f5faa968791c54a16e9ed149182567631b307c75", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -323,14 +323,15 @@ pub impl LookupContext {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n-        let opt_applicable_traits = self.fcx.ccx.trait_map.find(self.expr.id);\n+        let opt_applicable_traits = self.fcx.ccx.trait_map.find(\n+            &self.expr.id);\n         for opt_applicable_traits.each |applicable_traits| {\n             for applicable_traits.each |trait_did| {\n                 let coherence_info = self.fcx.ccx.coherence_info;\n \n                 // Look for explicit implementations.\n                 let opt_impl_infos =\n-                    coherence_info.extension_methods.find(*trait_did);\n+                    coherence_info.extension_methods.find(trait_did);\n                 for opt_impl_infos.each |impl_infos| {\n                     for impl_infos.each |impl_info| {\n                         self.push_candidates_from_impl(\n@@ -339,7 +340,7 @@ pub impl LookupContext {\n                 }\n \n                 // Look for default methods.\n-                match self.tcx().provided_methods.find(*trait_did) {\n+                match self.tcx().provided_methods.find(trait_did) {\n                     Some(methods) => {\n                         self.push_candidates_from_provided_methods(\n                             &self.extension_candidates, self_ty, *trait_did,\n@@ -360,7 +361,7 @@ pub impl LookupContext {\n \n         let tcx = self.tcx();\n         let mut next_bound_idx = 0; // count only trait bounds\n-        let bounds = tcx.ty_param_bounds.get(param_ty.def_id.node);\n+        let bounds = tcx.ty_param_bounds.get(&param_ty.def_id.node);\n \n         for vec::each(*bounds) |bound| {\n             let bound_trait_ty = match *bound {\n@@ -607,7 +608,7 @@ pub impl LookupContext {\n \n     fn push_inherent_impl_candidates_for_type(did: def_id) {\n         let opt_impl_infos =\n-            self.fcx.ccx.coherence_info.inherent_methods.find(did);\n+            self.fcx.ccx.coherence_info.inherent_methods.find(&did);\n         for opt_impl_infos.each |impl_infos| {\n             for impl_infos.each |impl_info| {\n                 self.push_candidates_from_impl(\n@@ -882,7 +883,7 @@ pub impl LookupContext {\n                     })\n             }\n \n-            ty_trait(*) | ty_fn(*) => {\n+            ty_trait(*) | ty_closure(*) => {\n                 // NDM---eventually these should be some variant of autoref\n                 None\n             }\n@@ -905,14 +906,14 @@ pub impl LookupContext {\n \n         let tcx = self.tcx();\n         match ty::get(self_ty).sty {\n-            ty_box(*) | ty_uniq(*) | ty_rptr(*) |\n+            ty_bare_fn(*) | ty_box(*) | ty_uniq(*) | ty_rptr(*) |\n             ty_infer(IntVar(_)) |\n             ty_infer(FloatVar(_)) |\n             ty_self | ty_param(*) | ty_nil | ty_bot | ty_bool |\n             ty_int(*) | ty_uint(*) |\n             ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_rec(*) |\n             ty_struct(*) | ty_tup(*) | ty_estr(*) | ty_evec(*) |\n-            ty_trait(*) | ty_fn(*) => {\n+            ty_trait(*) | ty_closure(*) => {\n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoPtr, autoderefs, [m_const, m_imm, m_mutbl],\n                     |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))\n@@ -1211,7 +1212,7 @@ pub impl LookupContext {\n                                 trait_did: def_id,\n                                 method_num: uint) -> ty::t {\n             let trait_methods = ty::trait_methods(tcx, trait_did);\n-            ty::mk_fn(tcx, /*bad*/copy trait_methods[method_num].fty)\n+            ty::mk_bare_fn(tcx, copy trait_methods[method_num].fty)\n         }\n     }\n \n@@ -1232,7 +1233,7 @@ pub impl LookupContext {\n \n     fn report_static_candidate(&self, idx: uint, did: def_id) {\n         let span = if did.crate == ast::local_crate {\n-            match self.tcx().items.find(did.node) {\n+            match self.tcx().items.find(&did.node) {\n               Some(ast_map::node_method(m, _, _)) => m.span,\n               _ => die!(fmt!(\"report_static_candidate: bad item %?\", did))\n             }"}, {"sha": "074a0a565ae590c050a3d7cb47fe4b99fae47705", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 300, "deletions": 279, "changes": 579, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -81,7 +81,7 @@ use core::prelude::*;\n use middle::const_eval;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n-use middle::ty::{TyVid, Vid, FnTyBase, FnMeta, FnSig, VariantInfo_, field};\n+use middle::ty::{TyVid, Vid, FnSig, VariantInfo_, field};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n use middle::ty::{re_bound, br_cap_avoid, substs, arg, param_ty};\n use middle::ty;\n@@ -90,7 +90,6 @@ use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n use middle::typeck::astconv;\n use middle::typeck::check::_match::pat_ctxt;\n use middle::typeck::check::method::TransformTypeNormally;\n-use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_ty;\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n use middle::typeck::crate_ctxt;\n@@ -248,8 +247,9 @@ pub fn check_bare_fn(ccx: @crate_ctxt,\n                      self_info: Option<self_info>) {\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n     match ty::get(fty).sty {\n-        ty::ty_fn(ref fn_ty) => {\n-            check_fn(ccx, self_info, fn_ty, decl, body, Vanilla, None)\n+        ty::ty_bare_fn(ref fn_ty) => {\n+            check_fn(ccx, self_info, fn_ty.purity, None,\n+                     &fn_ty.sig, decl, body, Vanilla, None)\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n                                  \"check_bare_fn: function type expected\")\n@@ -258,12 +258,14 @@ pub fn check_bare_fn(ccx: @crate_ctxt,\n \n pub fn check_fn(ccx: @crate_ctxt,\n                 self_info: Option<self_info>,\n-                fn_ty: &ty::FnTy,\n+                purity: ast::purity,\n+                sigil: Option<ast::Sigil>,\n+                fn_sig: &ty::FnSig,\n                 decl: &ast::fn_decl,\n                 body: ast::blk,\n                 fn_kind: FnKind,\n-                old_fcx: Option<@fn_ctxt>) {\n-\n+                old_fcx: Option<@fn_ctxt>)\n+{\n     let tcx = ccx.tcx;\n     let indirect_ret = match fn_kind {\n         ForLoop => true, _ => false\n@@ -277,7 +279,7 @@ pub fn check_fn(ccx: @crate_ctxt,\n     let {isr, self_info, fn_sig} = {\n         let old_isr = option::map_default(&old_fcx, @Nil,\n                                           |fcx| fcx.in_scope_regions);\n-        replace_bound_regions_in_fn_sig(tcx, old_isr, self_info, &fn_ty.sig,\n+        replace_bound_regions_in_fn_sig(tcx, old_isr, self_info, fn_sig,\n                                         |br| ty::re_free(body.node.id, br))\n     };\n \n@@ -294,13 +296,10 @@ pub fn check_fn(ccx: @crate_ctxt,\n     // in the case of function expressions, based on the outer context.\n     let fcx: @fn_ctxt = {\n         let (purity, inherited) = match old_fcx {\n-            None => {\n-                (fn_ty.meta.purity,\n-                 blank_inherited(ccx))\n-            }\n+            None => (purity, blank_inherited(ccx)),\n             Some(fcx) => {\n-                (ty::determine_inherited_purity(fcx.purity, fn_ty.meta.purity,\n-                                                fn_ty.meta.proto),\n+                (ty::determine_inherited_purity(fcx.purity, purity,\n+                                                sigil.get()),\n                  fcx.inh)\n             }\n         };\n@@ -405,7 +404,7 @@ pub fn check_fn(ccx: @crate_ctxt,\n             assign(self_info.self_id, Some(self_info.self_ty));\n             debug!(\"self is assigned to %s\",\n                    fcx.infcx().ty_to_str(\n-                       fcx.inh.locals.get(self_info.self_id)));\n+                       fcx.inh.locals.get(&self_info.self_id)));\n         }\n \n         // Add formal parameters.\n@@ -438,7 +437,7 @@ pub fn check_fn(ccx: @crate_ctxt,\n             debug!(\"Local variable %s is assigned type %s\",\n                    fcx.pat_to_str(local.node.pat),\n                    fcx.infcx().ty_to_str(\n-                       fcx.inh.locals.get(local.node.id)));\n+                       fcx.inh.locals.get(&local.node.id)));\n             visit::visit_local(local, e, v);\n         };\n \n@@ -451,7 +450,7 @@ pub fn check_fn(ccx: @crate_ctxt,\n                 debug!(\"Pattern binding %s is assigned to %s\",\n                        tcx.sess.str_of(path.idents[0]),\n                        fcx.infcx().ty_to_str(\n-                           fcx.inh.locals.get(p.id)));\n+                           fcx.inh.locals.get(&p.id)));\n               }\n               _ => {}\n             }\n@@ -501,7 +500,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n \n     for fields.each |p| {\n         let (id, sp) = *p;\n-        match field_names.find(id) {\n+        match field_names.find(&id) {\n           Some(orig_sp) => {\n             tcx.sess.span_err(sp, fmt!(\"Duplicate field \\\n                                    name %s in record type declaration\",\n@@ -558,7 +557,7 @@ pub fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         check_bare_fn(ccx, decl, (*body), it.id, None);\n       }\n       ast::item_impl(_, _, ty, ms) => {\n-        let rp = ccx.tcx.region_paramd_items.find(it.id);\n+        let rp = ccx.tcx.region_paramd_items.find(&it.id);\n         debug!(\"item_impl %s with id %d rp %?\",\n                ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         let self_ty = ccx.to_ty(rscope::type_rscope(rp), ty);\n@@ -664,7 +663,7 @@ pub impl @fn_ctxt {\n     fn tag() -> ~str { fmt!(\"%x\", ptr::addr_of(&(*self)) as uint) }\n \n     fn local_ty(span: span, nid: ast::node_id) -> ty::t {\n-        match self.inh.locals.find(nid) {\n+        match self.inh.locals.find(&nid) {\n             Some(t) => t,\n             None => {\n                 self.tcx().sess.span_bug(\n@@ -740,7 +739,7 @@ pub impl @fn_ctxt {\n     }\n \n     fn expr_ty(ex: @ast::expr) -> ty::t {\n-        match self.inh.node_types.find(ex.id) {\n+        match self.inh.node_types.find(&ex.id) {\n             Some(t) => t,\n             None => {\n                 self.tcx().sess.bug(\n@@ -750,7 +749,7 @@ pub impl @fn_ctxt {\n         }\n     }\n     fn node_ty(id: ast::node_id) -> ty::t {\n-        match self.inh.node_types.find(id) {\n+        match self.inh.node_types.find(&id) {\n             Some(t) => t,\n             None => {\n                 self.tcx().sess.bug(\n@@ -763,7 +762,7 @@ pub impl @fn_ctxt {\n         }\n     }\n     fn node_ty_substs(id: ast::node_id) -> ty::substs {\n-        match self.inh.node_type_substs.find(id) {\n+        match self.inh.node_type_substs.find(&id) {\n             Some(ref ts) => (/*bad*/copy *ts),\n             None => {\n                 self.tcx().sess.bug(\n@@ -776,7 +775,7 @@ pub impl @fn_ctxt {\n         }\n     }\n     fn opt_node_ty_substs(id: ast::node_id) -> Option<ty::substs> {\n-        self.inh.node_type_substs.find(id)\n+        self.inh.node_type_substs.find(&id)\n     }\n \n \n@@ -1001,8 +1000,8 @@ pub fn impl_self_ty(vcx: &VtableContext,\n     let tcx = vcx.tcx();\n \n     let {n_tps, region_param, raw_ty} = if did.crate == ast::local_crate {\n-        let region_param = tcx.region_paramd_items.find(did.node);\n-        match tcx.items.find(did.node) {\n+        let region_param = tcx.region_paramd_items.find(&did.node);\n+        match tcx.items.find(&did.node) {\n           Some(ast_map::node_item(@ast::item {\n                   node: ast::item_impl(ref ts, _, st, _),\n                   _\n@@ -1092,8 +1091,9 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         in_fty: ty::t,\n         callee_expr: @ast::expr,\n         args: ~[@ast::expr],\n-        deref_args: DerefArgs) -> {fty: ty::t, bot: bool} {\n-\n+        sugar: ast::CallSugar,\n+        deref_args: DerefArgs) -> (ty::t, bool)\n+    {\n         let tcx = fcx.ccx.tcx;\n         let mut bot = false;\n \n@@ -1103,62 +1103,72 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         debug!(\"check_call_inner: before universal quant., in_fty=%s\",\n                fcx.infcx().ty_to_str(in_fty));\n \n-        let mut formal_tys;\n+        let formal_tys;\n \n         // This is subtle: we expect `fty` to be a function type, which\n         // normally introduce a level of binding.  In this case, we want to\n         // process the types bound by the function but not by any nested\n         // functions.  Therefore, we match one level of structure.\n-        let fty =\n-            match structure_of(fcx, sp, in_fty) {\n-              ty::ty_fn(ref fn_ty) => {\n-                  let fn_ty =\n-                    /*bad*/copy replace_bound_regions_in_fn_ty(tcx, @Nil,\n-                      None, fn_ty, |_br| fcx.infcx().next_region_var(sp,\n-                                                      call_expr_id)).fn_ty;\n-\n-                  let supplied_arg_count = args.len();\n-\n-                  bot |= ty::type_is_bot(fn_ty.sig.output);\n-\n-                  // Grab the argument types, supplying fresh type variables\n-                  // if the wrong number of arguments were supplied\n-                  let expected_arg_count = fn_ty.sig.inputs.len();\n-                  formal_tys = if expected_arg_count == supplied_arg_count {\n-                      fn_ty.sig.inputs.map(|a| a.ty)\n-                  } else {\n-                      tcx.sess.span_err(\n-                          sp, fmt!(\"this function takes %u parameter%s but \\\n-                                    %u parameter%s supplied\",\n+        let ret_ty = match structure_of(fcx, sp, in_fty) {\n+            ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n+            ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n+                let {fn_sig: sig, _} =\n+                    replace_bound_regions_in_fn_sig(\n+                        tcx, @Nil, None, sig,\n+                        |_br| fcx.infcx().next_region_var(\n+                            sp, call_expr_id));\n+\n+                let supplied_arg_count = args.len();\n+\n+                bot |= ty::type_is_bot(sig.output);\n+\n+                // Grab the argument types, supplying fresh type variables\n+                // if the wrong number of arguments were supplied\n+                let expected_arg_count = sig.inputs.len();\n+                formal_tys = if expected_arg_count == supplied_arg_count {\n+                    sig.inputs.map(|a| a.ty)\n+                } else {\n+                    let suffix = match sugar {\n+                        ast::NoSugar => \"\",\n+                        ast::DoSugar => \" (including the closure passed by \\\n+                                         the `do` keyword)\",\n+                        ast::ForSugar => \" (including the closure passed by \\\n+                                          the `for` keyword)\"\n+                    };\n+                    let msg = fmt!(\"this function takes %u parameter%s but \\\n+                                    %u parameter%s supplied%s\",\n                                    expected_arg_count,\n-                                   if expected_arg_count == 1 {\n-                                       ~\"\"\n-                                   } else {\n-                                       ~\"s\"\n-                                   },\n+                                   if expected_arg_count == 1 {\"\"}\n+                                   else {\"s\"},\n                                    supplied_arg_count,\n-                                   if supplied_arg_count == 1 {\n-                                       ~\" was\"\n-                                   } else {\n-                                       ~\"s were\"\n-                                   }));\n-                      fcx.infcx().next_ty_vars(supplied_arg_count)\n-                  };\n-                  ty::mk_fn(tcx, fn_ty)\n-              }\n-              _ => {\n-                  fcx.type_error_message(sp, |actual| {\n-                      fmt!(\"expected function or foreign function but \\\n-                            found `%s`\", actual) }, in_fty, None);\n-                  // check each arg against \"error\", in order to set up\n-                  // all the node type bindings\n-                  formal_tys = args.map(|_x| ty::mk_err(tcx));\n-                  ty::mk_err(tcx)\n-              }\n-            };\n+                                   if supplied_arg_count == 1 {\" was\"}\n+                                   else {\"s were\"},\n+                                   suffix);\n \n-        debug!(\"check_call_inner: after universal quant., fty=%s\",\n-               fcx.infcx().ty_to_str(fty));\n+                    tcx.sess.span_err(sp, msg);\n+\n+                    vec::from_fn(expected_arg_count, |_| ty::mk_err(tcx))\n+                };\n+\n+                sig.output\n+            }\n+\n+            _ => {\n+                fcx.type_error_message(sp, |actual| {\n+                    fmt!(\"expected function or foreign function but \\\n+                          found `%s`\", actual) }, in_fty, None);\n+\n+                // check each arg against \"error\", in order to set up\n+                // all the node type bindings\n+                formal_tys = args.map(|_x| ty::mk_err(tcx));\n+                ty::mk_err(tcx)\n+            }\n+        };\n+\n+        debug!(\"check_call_inner: after universal quant., \\\n+                formal_tys=%? ret_ty=%s\",\n+               formal_tys.map(|t| fcx.infcx().ty_to_str(*t)),\n+               fcx.infcx().ty_to_str(ret_ty));\n \n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n@@ -1209,7 +1219,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n             }\n         }\n \n-        {fty: fty, bot: bot}\n+        (ret_ty, bot)\n     }\n \n     // A generic function for checking assignment expressions\n@@ -1233,36 +1243,26 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                             fn_ty: ty::t,\n                             expr: @ast::expr,\n                             +args: ~[@ast::expr],\n-                            bot: bool)\n-                         -> bool {\n+                            bot: bool,\n+                            sugar: ast::CallSugar) -> bool\n+    {\n         let mut bot = bot;\n \n         // Call the generic checker.\n-        let fty = {\n-            let r = check_call_inner(fcx, sp, call_expr_id,\n-                                     fn_ty, expr, args, DontDerefArgs);\n-            bot |= r.bot;\n-            r.fty\n-        };\n+        let (ret_ty, b) = check_call_inner(fcx, sp, call_expr_id,\n+                                           fn_ty, expr, args, sugar,\n+                                           DontDerefArgs);\n+        bot |= b;\n \n         // Pull the return type out of the type of the function.\n-        match structure_of(fcx, sp, fty) {\n-          ty::ty_fn(ref f) => {\n-              fcx.write_ty(call_expr_id, f.sig.output);\n-              return bot;\n-          }\n-          _ => {\n-              fcx.write_ty(call_expr_id, ty::mk_err(fcx.ccx.tcx));\n-              fcx.type_error_message(sp, |_actual| {\n-                  ~\"expected function\"}, fty, None);\n-              return bot;\n-          }\n-        }\n+        fcx.write_ty(call_expr_id, ret_ty);\n+        return bot;\n     }\n \n     // A generic function for doing all of the checking for call expressions\n     fn check_call(fcx: @fn_ctxt, sp: span, call_expr_id: ast::node_id,\n-                  f: @ast::expr, +args: ~[@ast::expr]) -> bool {\n+                  f: @ast::expr, +args: ~[@ast::expr],\n+                  sugar: ast::CallSugar) -> bool {\n         // Index expressions need to be handled separately, to inform them\n         // that they appear in call position.\n         let mut bot = match /*bad*/copy f.node {\n@@ -1278,7 +1278,8 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                              fcx.expr_ty(f),\n                              f,\n                              args,\n-                             bot)\n+                             bot,\n+                             sugar)\n     }\n \n     // Checks a method call.\n@@ -1287,7 +1288,8 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                          rcvr: @ast::expr,\n                          method_name: ast::ident,\n                          +args: ~[@ast::expr],\n-                         tps: ~[@ast::Ty])\n+                         tps: ~[@ast::Ty],\n+                         sugar: ast::CallSugar)\n                       -> bool {\n         let bot = check_expr(fcx, rcvr);\n         let expr_t = structurally_resolved_type(fcx,\n@@ -1329,7 +1331,8 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                              fcx.node_ty(expr.callee_id),\n                              expr,\n                              args,\n-                             bot)\n+                             bot,\n+                             sugar)\n     }\n \n     // A generic function for checking for or for-each loops\n@@ -1378,13 +1381,11 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                              op_ex.callee_id, opname, self_t, ~[],\n                              deref_args) {\n           Some(ref origin) => {\n-            let {fty: method_ty, bot: bot} = {\n-                let method_ty = fcx.node_ty(op_ex.callee_id);\n-                check_call_inner(fcx, op_ex.span, op_ex.id,\n-                                 method_ty, op_ex, args, deref_args)\n-            };\n-            fcx.ccx.method_map.insert(op_ex.id, (*origin));\n-            Some((ty::ty_fn_ret(method_ty), bot))\n+              let method_ty = fcx.node_ty(op_ex.callee_id);\n+              fcx.ccx.method_map.insert(op_ex.id, *origin);\n+              Some(check_call_inner(fcx, op_ex.span, op_ex.id,\n+                                    method_ty, op_ex, args,\n+                                    ast::NoSugar, deref_args))\n           }\n           _ => None\n         }\n@@ -1472,13 +1473,14 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // If the or operator is used it might be that the user forgot to\n         // supply the do keyword.  Let's be more helpful in that situation.\n         if op == ast::or {\n-          match ty::get(lhs_resolved_t).sty {\n-            ty::ty_fn(_) => {\n-              tcx.sess.span_note(\n-                  ex.span, ~\"did you forget the `do` keyword for the call?\");\n+            match ty::get(lhs_resolved_t).sty {\n+                ty::ty_bare_fn(_) | ty::ty_closure(_) => {\n+                    tcx.sess.span_note(\n+                        ex.span, ~\"did you forget the `do` keyword \\\n+                                   for the call?\");\n+                }\n+                _ => ()\n             }\n-            _ => ()\n-          }\n         }\n \n         (lhs_resolved_t, false)\n@@ -1523,7 +1525,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n     fn check_expr_fn(fcx: @fn_ctxt,\n                      expr: @ast::expr,\n-                     ast_proto_opt: Option<ast::Proto>,\n+                     ast_sigil_opt: Option<ast::Sigil>,\n                      decl: &ast::fn_decl,\n                      body: ast::blk,\n                      fn_kind: FnKind,\n@@ -1534,50 +1536,44 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // avoid capture of bound regions in the expected type.  See\n         // def'n of br_cap_avoid() for a more lengthy explanation of\n         // what's going on here.\n-        // Also try to pick up inferred purity and proto, defaulting\n+        // Also try to pick up inferred purity and sigil, defaulting\n         // to impure and block. Note that we only will use those for\n         // block syntax lambdas; that is, lambdas without explicit\n-        // protos.\n+        // sigils.\n         let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n         let (expected_tys,\n              expected_purity,\n-             expected_proto,\n+             expected_sigil,\n              expected_onceness) = {\n             match expected_sty {\n-                Some(ty::ty_fn(ref fn_ty)) => {\n+                Some(ty::ty_closure(ref cenv)) => {\n                     let id = expr.id;\n-                    let {fn_ty: fn_ty, _} =\n-                        replace_bound_regions_in_fn_ty(\n-                            tcx, @Nil, None, fn_ty,\n+                    let {fn_sig: sig, _} =\n+                        replace_bound_regions_in_fn_sig(\n+                            tcx, @Nil, None, &cenv.sig,\n                             |br| ty::re_bound(ty::br_cap_avoid(id, @br)));\n-                    (Some({inputs: /*bad*/copy fn_ty.sig.inputs,\n-                           output: fn_ty.sig.output}),\n-                     fn_ty.meta.purity,\n-                     fn_ty.meta.proto,\n-                     fn_ty.meta.onceness)\n+                    (Some(sig), cenv.purity, cenv.sigil, cenv.onceness)\n                 }\n                 _ => {\n-                    (None, ast::impure_fn, ast::ProtoBorrowed, ast::Many)\n+                    (None, ast::impure_fn, ast::BorrowedSigil, ast::Many)\n                 }\n             }\n         };\n \n         // If the proto is specified, use that, otherwise select a\n         // proto based on inference.\n-        let (proto, purity) = match ast_proto_opt {\n+        let (sigil, purity) = match ast_sigil_opt {\n             Some(p) => (p, ast::impure_fn),\n-            None => (expected_proto, expected_purity)\n+            None => (expected_sigil, expected_purity)\n         };\n \n         // construct the function type\n-        let mut fn_ty = astconv::ty_of_fn_decl(\n+        let mut fn_ty = astconv::ty_of_closure(\n             fcx, fcx,\n-            proto, purity, expected_onceness,\n-            /*bounds:*/ @~[], /*opt_region:*/ None,\n-            *decl, expected_tys, expr.span);\n+            sigil, purity, expected_onceness,\n+            None, *decl, expected_tys, expr.span);\n \n-        // XXX: Bad copy.\n-        let fty = ty::mk_fn(tcx, copy fn_ty);\n+        let fty = ty::mk_closure(tcx, copy fn_ty);\n \n         debug!(\"check_expr_fn_with_unifier %s fty=%s\",\n                fcx.expr_to_str(expr),\n@@ -1587,8 +1583,8 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         // We inherit the same self info as the enclosing scope,\n         // since the function we're checking might capture `self`\n-        check_fn(fcx.ccx, fcx.self_info, &fn_ty, decl, body,\n-                 fn_kind, Some(fcx));\n+        check_fn(fcx.ccx, fcx.self_info, fn_ty.purity, Some(fn_ty.sigil),\n+                 &fn_ty.sig, decl, body, fn_kind, Some(fcx));\n     }\n \n \n@@ -1698,7 +1694,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n         // Typecheck each field.\n         for ast_fields.each |field| {\n-            match class_field_map.find(field.node.ident) {\n+            match class_field_map.find(&field.node.ident) {\n                 None => {\n                     tcx.sess.span_err(\n                         field.span,\n@@ -1734,7 +1730,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 let mut missing_fields = ~[];\n                 for field_types.each |class_field| {\n                     let name = class_field.ident;\n-                    let (_, seen) = class_field_map.get(name);\n+                    let (_, seen) = class_field_map.get(&name);\n                     if !seen {\n                         missing_fields.push(\n                             ~\"`\" + tcx.sess.str_of(name) + ~\"`\");\n@@ -1769,8 +1765,8 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let type_parameter_count, region_parameterized, raw_type;\n         if class_id.crate == ast::local_crate {\n             region_parameterized =\n-                tcx.region_paramd_items.find(class_id.node);\n-            match tcx.items.find(class_id.node) {\n+                tcx.region_paramd_items.find(&class_id.node);\n+            match tcx.items.find(&class_id.node) {\n                 Some(ast_map::node_item(@ast::item {\n                         node: ast::item_struct(_, ref type_parameters),\n                         _\n@@ -1852,8 +1848,8 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let type_parameter_count, region_parameterized, raw_type;\n         if enum_id.crate == ast::local_crate {\n             region_parameterized =\n-                tcx.region_paramd_items.find(enum_id.node);\n-            match tcx.items.find(enum_id.node) {\n+                tcx.region_paramd_items.find(&enum_id.node);\n+            match tcx.items.find(&enum_id.node) {\n                 Some(ast_map::node_item(@ast::item {\n                         node: ast::item_enum(_, ref type_parameters),\n                         _\n@@ -1913,6 +1909,119 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n         return bot;\n     }\n \n+    fn check_loop_body(fcx: @fn_ctxt,\n+                       expr: @ast::expr,\n+                       expected: Option<ty::t>,\n+                       loop_body: @ast::expr)\n+    {\n+        // a loop body is the special argument to a `for` loop.  We know that\n+        // there will be an expected type in this context because it can only\n+        // appear in the context of a call, so we get the expected type of the\n+        // parameter. The catch here is that we need to validate two things:\n+        // 1. a closure that returns a bool is expected\n+        // 2. the closure that was given returns unit\n+        let tcx = fcx.tcx();\n+        let mut err_happened = false;\n+        let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n+        let inner_ty = match expected_sty {\n+            Some(ty::ty_closure(ref fty)) => {\n+                match fcx.mk_subty(false, expr.span,\n+                                   fty.sig.output, ty::mk_bool(tcx)) {\n+                    result::Ok(_) => {\n+                        ty::mk_closure(tcx, ty::ClosureTy {\n+                            sig: FnSig {output: ty::mk_nil(tcx),\n+                                        ..copy fty.sig},\n+                            ..copy *fty\n+                        })\n+                    }\n+                    result::Err(_) => {\n+                        fcx.type_error_message(\n+                            expr.span,\n+                            |actual| {\n+                                let did_you_mean = {\n+                                    if ty::type_is_nil(fty.sig.output) {\n+                                        \"\\nDid you mean to use \\\n+                                             `do` instead of `for`?\"\n+                                     } else {\n+                                         \"\"\n+                                     }\n+                                };\n+                                fmt!(\"A `for` loop iterator should expect a \\\n+                                      closure that returns `bool`. This \\\n+                                      iterator expects a closure that \\\n+                                      returns `%s`.%s\",\n+                                     actual, did_you_mean)\n+                            },\n+                            fty.sig.output,\n+                            None);\n+                        err_happened = true;\n+\n+                        // Kind of a hack: create a function type with\n+                        // the result replaced with ty_err, to\n+                        // suppress derived errors.\n+                        let t = ty::replace_closure_return_type(\n+                            tcx, ty::mk_closure(tcx, copy *fty),\n+                            ty::mk_err(tcx));\n+                        fcx.write_ty(expr.id, ty::mk_err(tcx));\n+                        t\n+                    }\n+                }\n+            }\n+            _ => {\n+                match expected {\n+                    Some(expected_t) => {\n+                        fcx.type_error_message(\n+                            expr.span,\n+                            |actual| {\n+                                fmt!(\"last argument in `for` call \\\n+                                      has non-closure type: %s\",\n+                                     actual)\n+                            },\n+                            expected_t, None);\n+                        let err_ty = ty::mk_err(tcx);\n+                        fcx.write_ty(expr.id, err_ty);\n+                        err_happened = true;\n+                        err_ty\n+                    }\n+                    None => fcx.tcx().sess.impossible_case(\n+                        expr.span,\n+                        ~\"loop body must have an expected type\")\n+                }\n+            }\n+        };\n+\n+        match loop_body.node {\n+            ast::expr_fn_block(ref decl, ref body) => {\n+                // If an error occurred, we pretend this isn't a for\n+                // loop, so as to assign types to all nodes while also\n+                // propagating ty_err throughout so as to suppress\n+                // derived errors. If we passed in ForLoop in the\n+                // error case, we'd potentially emit a spurious error\n+                // message because of the indirect_ret_ty.\n+                let fn_kind = if err_happened {Vanilla} else {ForLoop};\n+                check_expr_fn(fcx, loop_body, None,\n+                              decl, *body, fn_kind, Some(inner_ty));\n+                demand::suptype(fcx, loop_body.span,\n+                                inner_ty, fcx.expr_ty(loop_body));\n+            }\n+            ref n => {\n+                die!(fmt!(\n+                    \"check_loop_body expected expr_fn_block, not %?\", n))\n+            }\n+        }\n+\n+        let block_ty = structurally_resolved_type(\n+            fcx, expr.span, fcx.node_ty(loop_body.id));\n+        if err_happened {\n+            fcx.write_ty(expr.id, ty::mk_err(fcx.tcx()));\n+        } else {\n+            let loop_body_ty =\n+                ty::replace_closure_return_type(\n+                    tcx, block_ty, ty::mk_bool(tcx));\n+            fcx.write_ty(expr.id, loop_body_ty);\n+        }\n+    }\n+\n     let tcx = fcx.ccx.tcx;\n     let id = expr.id;\n     let mut bot = false;\n@@ -2153,121 +2262,38 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_match(discrim, ref arms) => {\n         bot = _match::check_match(fcx, expr, discrim, (/*bad*/copy *arms));\n       }\n-      ast::expr_fn(proto, ref decl, ref body, _) => {\n-        check_expr_fn(fcx, expr, Some(proto),\n+      ast::expr_fn(sigil, ref decl, ref body, _) => {\n+        check_expr_fn(fcx, expr, Some(sigil),\n                       decl, (*body), Vanilla, expected);\n       }\n       ast::expr_fn_block(ref decl, ref body) => {\n         check_expr_fn(fcx, expr, None,\n                       decl, (*body), Vanilla, expected);\n       }\n-      ast::expr_loop_body(b) => {\n-        // a loop body is the special argument to a `for` loop.  We know that\n-        // there will be an expected type in this context because it can only\n-        // appear in the context of a call, so we get the expected type of the\n-        // parameter. The catch here is that we need to validate two things:\n-        // 1. a closure that returns a bool is expected\n-        // 2. the closure that was given returns unit\n-        let mut err_happened = false;\n-        let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n-        let inner_ty = match expected_sty {\n-          Some(ty::ty_fn(ref fty)) => {\n-            match fcx.mk_subty(false, expr.span,\n-                               (*fty).sig.output, ty::mk_bool(tcx)) {\n-              result::Ok(_) =>\n-                  ty::mk_fn(tcx, FnTyBase {\n-                      meta: (*fty).meta,\n-                      sig: FnSig {output: ty::mk_nil(tcx),\n-                                  ../*bad*/copy (*fty).sig}\n-                  }),\n-              result::Err(_) => {\n-                   fcx.type_error_message(expr.span,\n-                      |actual| {\n-                          fmt!(\"A `for` loop iterator should expect a \\\n-                                closure that returns `bool`. This iterator \\\n-                                expects a closure that returns `%s`. %s\",\n-                               actual, if ty::type_is_nil((*fty).sig.output) {\n-                                   \"\\nDid you mean to use `do` instead of \\\n-                                        `for`?\" } else { \"\" } )\n-                      },\n-                      (*fty).sig.output, None);\n-                err_happened = true;\n-                // Kind of a hack: create a function type with the result\n-                // replaced with ty_err, to suppress derived errors.\n-                let t = ty::replace_fn_return_type(tcx, ty::mk_fn(tcx,\n-                                                                  copy *fty),\n-                                                   ty::mk_err(tcx));\n-                fcx.write_ty(id, ty::mk_err(tcx));\n-                t\n-              }\n-            }\n-          }\n-          _ =>\n-              match expected {\n-                  Some(expected_t) => {\n-                      fcx.type_error_message(expr.span, |actual| {\n-                          fmt!(\"a `loop` function's last \\\n-                                argument should be of function \\\n-                                type, not `%s`\",\n-                               actual)\n-                      },\n-                                             expected_t, None);\n-                      let err_ty = ty::mk_err(tcx);\n-                      fcx.write_ty(id, err_ty);\n-                      err_happened = true;\n-                      err_ty\n-                  }\n-                  None => fcx.tcx().sess.impossible_case(expr.span,\n-                            ~\"loop body must have an expected type\")\n-              }\n-        };\n-        match b.node {\n-                ast::expr_fn_block(ref decl, ref body) => {\n-                    // If an error occurred, we pretend this isn't a for\n-                    // loop, so as to assign types to all nodes while also\n-                    // propagating ty_err throughout so as to suppress\n-                    // derived errors. If we passed in ForLoop in the\n-                    // error case, we'd potentially emit a spurious error\n-                    // message because of the indirect_ret_ty.\n-                    let fn_kind = if err_happened { Vanilla }\n-                                  else { ForLoop };\n-                    check_expr_fn(fcx, b, None,\n-                                  decl, *body, fn_kind, Some(inner_ty));\n-                    demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n-                }\n-                // argh\n-                _ => die!(~\"expr_fn_block\")\n-        }\n-        let block_ty = structurally_resolved_type(\n-            fcx, expr.span, fcx.node_ty(b.id));\n-        if err_happened {\n-            fcx.write_ty(expr.id, ty::mk_err(fcx.tcx()));\n-        } else {\n-            let loop_body_ty = ty::replace_fn_return_type(tcx, block_ty,\n-                                                          ty::mk_bool(tcx));\n-            fcx.write_ty(expr.id, loop_body_ty);\n-        }\n+      ast::expr_loop_body(loop_body) => {\n+          check_loop_body(fcx, expr, expected, loop_body);\n       }\n       ast::expr_do_body(b) => {\n         let expected_sty = unpack_expected(fcx, expected, |x| Some(copy *x));\n         let inner_ty = match expected_sty {\n-          Some(ty::ty_fn(ref fty)) => {\n-              ty::mk_fn(tcx, (/*bad*/copy *fty))\n-          }\n-          _ => match expected {\n-                  Some(expected_t) => {\n-                      fcx.type_error_message(expr.span, |_actual| {\n-                          ~\"Non-function passed to a `do` \\\n-                            function as its last argument, or wrong number \\\n-                            of arguments passed to a `do` function\"\n-                      }, expected_t, None);\n-                      let err_ty = ty::mk_err(tcx);\n-                      fcx.write_ty(id, err_ty);\n-                      err_ty\n-                  }\n-                  None => fcx.tcx().sess.impossible_case(expr.span,\n-                              ~\"do body must have expected type\")\n-              }\n+            Some(ty::ty_closure(_)) => expected.get(),\n+            _ => match expected {\n+                Some(expected_t) => {\n+                    fcx.type_error_message(expr.span, |actual| {\n+                        fmt!(\"last argument in `do` call \\\n+                              has non-closure type: %s\",\n+                             actual)\n+                    }, expected_t, None);\n+                    let err_ty = ty::mk_err(tcx);\n+                    fcx.write_ty(id, err_ty);\n+                    err_ty\n+                }\n+                None => {\n+                    fcx.tcx().sess.impossible_case(\n+                        expr.span,\n+                        ~\"do body must have expected type\")\n+                }\n+            }\n         };\n         match b.node {\n           ast::expr_fn_block(ref decl, ref body) => {\n@@ -2290,11 +2316,11 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n             };\n         fcx.write_ty(id, typ);\n       }\n-      ast::expr_call(f, args, _) => {\n-        bot = check_call(fcx, expr.span, expr.id, f, args);\n+      ast::expr_call(f, args, sugar) => {\n+        bot = check_call(fcx, expr.span, expr.id, f, args, sugar);\n       }\n-      ast::expr_method_call(rcvr, ident, tps, args, _) => {\n-        bot = check_method_call(fcx, expr, rcvr, ident, args, tps);\n+      ast::expr_method_call(rcvr, ident, tps, args, sugar) => {\n+        bot = check_method_call(fcx, expr, rcvr, ident, args, tps, sugar);\n       }\n       ast::expr_cast(e, t) => {\n         bot = check_expr(fcx, e);\n@@ -2435,7 +2461,7 @@ pub fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_struct(path, ref fields, base_expr) => {\n         // Resolve the path.\n-        match tcx.def_map.find(id) {\n+        match tcx.def_map.find(&id) {\n             Some(ast::def_struct(type_def_id)) => {\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n                                          (/*bad*/copy *fields), base_expr);\n@@ -2532,7 +2558,7 @@ pub fn check_decl_local(fcx: @fn_ctxt, local: @ast::local) -> bool {\n     }\n \n     let region =\n-        ty::re_scope(tcx.region_map.get(local.node.id));\n+        ty::re_scope(tcx.region_map.get(&local.node.id));\n     let pcx = pat_ctxt {\n         fcx: fcx,\n         map: pat_id_map(tcx.def_map, local.node.pat),\n@@ -2633,7 +2659,7 @@ pub fn check_const(ccx: @crate_ctxt,\n                    id: ast::node_id) {\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, rty, e.id);\n-    let declty = fcx.ccx.tcx.tcache.get(local_def(id)).ty;\n+    let declty = fcx.ccx.tcx.tcache.get(&local_def(id)).ty;\n     check_const_with_ty(fcx, _sp, e, declty);\n }\n \n@@ -2984,7 +3010,7 @@ pub fn may_break(cx: ty::ctxt, id: ast::node_id, b: ast::blk) -> bool {\n     (block_query(b, |e| {\n         match e.node {\n             ast::expr_break(Some(_)) =>\n-                match cx.def_map.find(e.id) {\n+                match cx.def_map.find(&e.id) {\n                     Some(ast::def_label(loop_id)) if id == loop_id => true,\n                     _ => false,\n                 },\n@@ -3080,28 +3106,26 @@ pub fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n           let ty_visitor_name = tcx.sess.ident_of(~\"TyVisitor\");\n           assert tcx.intrinsic_defs.contains_key_ref(&tydesc_name);\n           assert ccx.tcx.intrinsic_defs.contains_key_ref(&ty_visitor_name);\n-          let (_, tydesc_ty) = tcx.intrinsic_defs.get(tydesc_name);\n-          let (_, visitor_trait) = tcx.intrinsic_defs.get(ty_visitor_name);\n+          let (_, tydesc_ty) = tcx.intrinsic_defs.get(&tydesc_name);\n+          let (_, visitor_trait) = tcx.intrinsic_defs.get(&ty_visitor_name);\n           let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {ty: tydesc_ty,\n                                                    mutbl: ast::m_imm});\n           (0u, ~[arg(ast::by_val, td_ptr),\n                  arg(ast::by_ref, visitor_trait)], ty::mk_nil(tcx))\n       }\n       ~\"frame_address\" => {\n-        let fty = ty::mk_fn(ccx.tcx, FnTyBase {\n-            meta: FnMeta {purity: ast::impure_fn,\n-                          proto: ast::ProtoBorrowed,\n-                          onceness: ast::Once,\n-                          region: ty::re_bound(ty::br_anon(0)),\n-                          bounds: @~[]},\n-            sig: FnSig {\n-                inputs: ~[arg {\n-                    mode: ast::expl(ast::by_val),\n-                    ty: ty::mk_imm_ptr(\n-                        ccx.tcx,\n-                        ty::mk_mach_uint(ccx.tcx, ast::ty_u8))\n-                }],\n-                output: ty::mk_nil(ccx.tcx)}\n+        let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n+            purity: ast::impure_fn,\n+            sigil: ast::BorrowedSigil,\n+            onceness: ast::Once,\n+            region: ty::re_bound(ty::br_anon(0)),\n+            sig: ty::FnSig {\n+                inputs: ~[arg {mode: ast::expl(ast::by_val),\n+                               ty: ty::mk_imm_ptr(\n+                                   ccx.tcx,\n+                                   ty::mk_mach_uint(ccx.tcx, ast::ty_u8))}],\n+                output: ty::mk_nil(ccx.tcx)\n+            }\n         });\n         (0u, ~[arg(ast::by_ref, fty)], ty::mk_nil(tcx))\n       }\n@@ -3324,12 +3348,9 @@ pub fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n         return;\n       }\n     };\n-    let fty = ty::mk_fn(tcx, FnTyBase {\n-        meta: FnMeta {purity: ast::unsafe_fn,\n-                      proto: ast::ProtoBare,\n-                      onceness: ast::Many,\n-                      region: ty::re_static,\n-                      bounds: @~[]},\n+    let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n+        purity: ast::unsafe_fn,\n+        abi: ast::RustAbi,\n         sig: FnSig {inputs: inputs,\n                     output: output}\n     });"}, {"sha": "9dfaaeebc8fd9f46677330d6aa70ebd06f846ba1", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -32,7 +32,7 @@ use core::prelude::*;\n use middle::freevars::get_freevars;\n use middle::pat_util::{pat_bindings, pat_is_binding};\n use middle::ty::{encl_region, re_scope};\n-use middle::ty::{ty_fn_proto, vstore_box, vstore_fixed, vstore_slice};\n+use middle::ty::{vstore_box, vstore_fixed, vstore_slice};\n use middle::ty::{vstore_uniq};\n use middle::ty;\n use middle::typeck::check::fn_ctxt;\n@@ -42,7 +42,7 @@ use middle::typeck::infer::{resolve_type};\n use util::ppaux::{note_and_explain_region, ty_to_str};\n \n use core::result;\n-use syntax::ast::{ProtoBare, ProtoBox, ProtoUniq, ProtoBorrowed};\n+use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n use syntax::ast::{def_arg, def_binding, def_local, def_self, def_upvar};\n use syntax::ast;\n use syntax::codemap::span;\n@@ -59,10 +59,9 @@ pub fn encl_region_of_def(fcx: @fn_ctxt, def: ast::def) -> ty::Region {\n         def_self(node_id, _) | def_binding(node_id, _) =>\n             return encl_region(tcx, node_id),\n         def_upvar(_, subdef, closure_id, body_id) => {\n-            match ty_fn_proto(fcx.node_ty(closure_id)) {\n-                ProtoBare => tcx.sess.bug(~\"ProtoBare with upvars?!\"),\n-                ProtoBorrowed => encl_region_of_def(fcx, *subdef),\n-                ProtoBox | ProtoUniq => re_scope(body_id)\n+            match ty::ty_closure_sigil(fcx.node_ty(closure_id)) {\n+                BorrowedSigil => encl_region_of_def(fcx, *subdef),\n+                ManagedSigil | OwnedSigil => re_scope(body_id)\n             }\n         }\n         _ => {\n@@ -181,7 +180,7 @@ pub fn visit_block(b: ast::blk, &&rcx: @rcx, v: rvt) {\n pub fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n     debug!(\"visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n \n-    for rcx.fcx.inh.adjustments.find(expr.id).each |adjustment| {\n+    for rcx.fcx.inh.adjustments.find(&expr.id).each |adjustment| {\n         for adjustment.autoref.each |autoref| {\n             guarantor::for_autoref(rcx, expr, *adjustment, autoref);\n         }\n@@ -278,11 +277,9 @@ pub fn visit_expr(expr: @ast::expr, &&rcx: @rcx, v: rvt) {\n         ast::expr_fn(*) | ast::expr_fn_block(*) => {\n             let function_type = rcx.resolve_node_type(expr.id);\n             match ty::get(function_type).sty {\n-                ty::ty_fn(ref fn_ty) => {\n-                    if fn_ty.meta.proto == ast::ProtoBorrowed {\n-                        constrain_free_variables(\n-                            rcx, fn_ty.meta.region, expr);\n-                    }\n+                ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n+                                              region: region, _}) => {\n+                    constrain_free_variables(rcx, region, expr);\n                 }\n                 _ => ()\n             }\n@@ -327,7 +324,7 @@ pub fn constrain_auto_ref(rcx: @rcx, expr: @ast::expr) {\n \n     debug!(\"constrain_auto_ref(expr=%s)\", rcx.fcx.expr_to_str(expr));\n \n-    let adjustment = rcx.fcx.inh.adjustments.find(expr.id);\n+    let adjustment = rcx.fcx.inh.adjustments.find(&expr.id);\n     let region = match adjustment {\n         Some(@ty::AutoAdjustment { autoref: Some(ref auto_ref), _ }) => {\n             auto_ref.region\n@@ -725,7 +722,7 @@ pub mod guarantor {\n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n         debug!(\"before adjustments, cat=%?\", expr_ct.cat);\n \n-        for rcx.fcx.inh.adjustments.find(expr.id).each |adjustment| {\n+        for rcx.fcx.inh.adjustments.find(&expr.id).each |adjustment| {\n             debug!(\"adjustment=%?\", adjustment);\n \n             expr_ct = apply_autoderefs("}, {"sha": "f0956df545c41bc806668f9551530beb49a1cece", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -12,7 +12,6 @@\n \n use core::prelude::*;\n \n-use middle::ty::{FnTyBase};\n use middle::ty;\n use middle::typeck::check::self_info;\n use middle::typeck::isr_alist;\n@@ -27,22 +26,6 @@ use syntax::print::pprust::{expr_to_str};\n \n // Helper functions related to manipulating region types.\n \n-pub fn replace_bound_regions_in_fn_ty(\n-    tcx: ty::ctxt,\n-    isr: isr_alist,\n-    self_info: Option<self_info>,\n-    fn_ty: &ty::FnTy,\n-    mapf: fn(ty::bound_region) -> ty::Region) ->\n-    {isr: isr_alist, self_info: Option<self_info>, fn_ty: ty::FnTy} {\n-    let {isr, self_info, fn_sig} =\n-        replace_bound_regions_in_fn_sig(\n-            tcx, isr, self_info, &fn_ty.sig, mapf);\n-    {isr: isr,\n-     self_info: self_info,\n-     fn_ty: FnTyBase {meta: fn_ty.meta,\n-                      sig: fn_sig}}\n-}\n-\n pub fn replace_bound_regions_in_fn_sig(\n     tcx: ty::ctxt,\n     isr: isr_alist,"}, {"sha": "abd4697eb31a83abfaccae2d060377b82498de63", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -194,7 +194,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n     match ty::get(ty).sty {\n         ty::ty_param(param_ty {idx: n, def_id: did}) => {\n             let mut n_bound = 0;\n-            let bounds = tcx.ty_param_bounds.get(did.node);\n+            let bounds = tcx.ty_param_bounds.get(&did.node);\n             for ty::iter_bound_traits_and_supertraits(\n                 tcx, bounds) |ity| {\n                 debug!(\"checking bounds trait %?\",\n@@ -233,7 +233,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n             relate_trait_tys(vcx, location_info, trait_ty, ty);\n             if !allow_unsafe && !is_early {\n                 for vec::each(*ty::trait_methods(tcx, did)) |m| {\n-                    if ty::type_has_self(ty::mk_fn(tcx, /*bad*/copy m.fty)) {\n+                    if ty::type_has_self(ty::mk_bare_fn(tcx, copy m.fty)) {\n                         tcx.sess.span_err(\n                             location_info.span,\n                             ~\"a boxed trait with self types may not be \\\n@@ -255,7 +255,7 @@ pub fn lookup_vtable(vcx: &VtableContext,\n \n             let mut impls_seen = HashMap();\n \n-            match vcx.ccx.coherence_info.extension_methods.find(trait_id) {\n+            match vcx.ccx.coherence_info.extension_methods.find(&trait_id) {\n                 None => {\n                     // Nothing found. Continue.\n                 }\n@@ -525,7 +525,7 @@ pub fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n       ast::expr_path(*) => {\n         match fcx.opt_node_ty_substs(ex.id) {\n           Some(ref substs) => {\n-              let def = cx.tcx.def_map.get(ex.id);\n+              let def = cx.tcx.def_map.get(&ex.id);\n             let did = ast_util::def_id_of_def(def);\n             let item_ty = ty::lookup_item_type(cx.tcx, did);\n             debug!(\"early resolve expr: def %? %?, %?, %?\", ex.id, did, def,"}, {"sha": "fab64c88b5344c2942895410a56ecbe452065d0a", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -55,7 +55,7 @@ fn resolve_type_vars_in_type(fcx: @fn_ctxt, sp: span, typ: ty::t)\n fn resolve_method_map_entry(fcx: @fn_ctxt, sp: span, id: ast::node_id)\n {\n     // Resolve any method map entry\n-    match fcx.ccx.method_map.find(id) {\n+    match fcx.ccx.method_map.find(&id) {\n         None => {}\n         Some(ref mme) => {\n             for resolve_type_vars_in_type(fcx, sp, mme.self_arg.ty).each |t| {\n@@ -77,7 +77,7 @@ fn resolve_type_vars_for_node(wbcx: wb_ctxt, sp: span, id: ast::node_id)\n     let fcx = wbcx.fcx, tcx = fcx.ccx.tcx;\n \n     // Resolve any borrowings for the node with id `id`\n-    match fcx.inh.adjustments.find(id) {\n+    match fcx.inh.adjustments.find(&id) {\n         None => (),\n         Some(adj) => {\n             let resolved_autoref = match adj.autoref {"}, {"sha": "8fc8c4f6cbb8df20f3d6ae594908252e9a8de176", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -26,10 +26,10 @@ use middle::resolve::{Impl, MethodInfo};\n use middle::ty::{ProvidedMethodSource, ProvidedMethodInfo, bound_copy, get};\n use middle::ty::{kind_can_be_copied, lookup_item_type, param_bounds, subst};\n use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n-use middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_infer, ty_int, ty_nil};\n+use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_opaque_box, ty_param, ty_param_bounds_and_ty, ty_ptr};\n use middle::ty::{ty_rec, ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n-use middle::ty::{ty_type, ty_uint, ty_uniq};\n+use middle::ty::{ty_type, ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_kind_ext};\n use middle::ty::{type_is_ty_var};\n use middle::ty;\n@@ -108,7 +108,7 @@ pub fn get_base_type(inference_context: @InferCtxt,\n \n         ty_nil | ty_bot | ty_bool | ty_int(*) | ty_uint(*) | ty_float(*) |\n         ty_estr(*) | ty_evec(*) | ty_rec(*) |\n-        ty_fn(*) | ty_tup(*) | ty_infer(*) |\n+        ty_bare_fn(*) | ty_closure(*) | ty_tup(*) | ty_infer(*) |\n         ty_param(*) | ty_self | ty_type | ty_opaque_box |\n         ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) | ty_err => {\n             debug!(\"(getting base type) no base type; found %?\",\n@@ -236,7 +236,8 @@ pub impl CoherenceChecker {\n     }\n \n     fn check_implementation(item: @item, associated_traits: ~[@trait_ref]) {\n-        let self_type = self.crate_context.tcx.tcache.get(local_def(item.id));\n+        let self_type = self.crate_context.tcx.tcache.get(\n+            &local_def(item.id));\n \n         // If there are no traits, then this implementation must have a\n         // base type.\n@@ -354,7 +355,7 @@ pub impl CoherenceChecker {\n                 };\n \n             let pmm = self.crate_context.tcx.provided_methods;\n-            match pmm.find(local_def(impl_id)) {\n+            match pmm.find(&local_def(impl_id)) {\n                 Some(mis) => {\n                     // If the trait already has an entry in the\n                     // provided_methods_map, we just need to add this\n@@ -382,7 +383,7 @@ pub impl CoherenceChecker {\n     fn add_inherent_method(base_def_id: def_id, implementation: @Impl) {\n         let implementation_list;\n         match self.crate_context.coherence_info.inherent_methods\n-                  .find(base_def_id) {\n+                  .find(&base_def_id) {\n             None => {\n                 implementation_list = @DVec();\n                 self.crate_context.coherence_info.inherent_methods\n@@ -399,7 +400,7 @@ pub impl CoherenceChecker {\n     fn add_trait_method(trait_id: def_id, implementation: @Impl) {\n         let implementation_list;\n         match self.crate_context.coherence_info.extension_methods\n-                  .find(trait_id) {\n+                  .find(&trait_id) {\n             None => {\n                 implementation_list = @DVec();\n                 self.crate_context.coherence_info.extension_methods\n@@ -462,7 +463,7 @@ pub impl CoherenceChecker {\n         debug!(\"Adding impl %? of %? for %s\",\n                the_impl.did, trait_t,\n                ty_to_str(self.crate_context.tcx, self_t));\n-        match self.crate_context.tcx.trait_impls.find(trait_t) {\n+        match self.crate_context.tcx.trait_impls.find(&trait_t) {\n             None => {\n                 let m = HashMap();\n                 m.insert(self_t, the_impl);\n@@ -480,7 +481,7 @@ pub impl CoherenceChecker {\n         let coherence_info = &self.crate_context.coherence_info;\n         let extension_methods = &coherence_info.extension_methods;\n \n-        match extension_methods.find(trait_def_id) {\n+        match extension_methods.find(&trait_def_id) {\n             Some(impls) => {\n                 for uint::range(0, impls.len()) |i| {\n                     f(impls[i]);\n@@ -612,7 +613,7 @@ pub impl CoherenceChecker {\n \n     fn get_self_type_for_implementation(implementation: @Impl)\n                                      -> ty_param_bounds_and_ty {\n-        return self.crate_context.tcx.tcache.get(implementation.did);\n+        return self.crate_context.tcx.tcache.get(&implementation.did);\n     }\n \n     // Privileged scope checking\n@@ -627,7 +628,7 @@ pub impl CoherenceChecker {\n                     item_impl(_, opt_trait, _, _) => {\n                         let mut ok = false;\n                         match self.base_type_def_ids.find(\n-                            local_def(item.id)) {\n+                            &local_def(item.id)) {\n \n                             None => {\n                                 // Nothing to do.\n@@ -701,7 +702,7 @@ pub impl CoherenceChecker {\n \n     fn trait_ref_to_trait_def_id(trait_ref: @trait_ref) -> def_id {\n         let def_map = self.crate_context.tcx.def_map;\n-        let trait_def = def_map.get(trait_ref.ref_id);\n+        let trait_def = def_map.get(&trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n         return trait_id;\n     }\n@@ -774,7 +775,7 @@ pub impl CoherenceChecker {\n \n                     match self.crate_context.tcx\n                               .provided_methods\n-                              .find(local_def(item.id)) {\n+                              .find(&local_def(item.id)) {\n                         None => {\n                             debug!(\"(creating impl) trait with node_id `%d` \\\n                                     has no provided methods\", trait_did.node);\n@@ -808,7 +809,7 @@ pub impl CoherenceChecker {\n \n     fn span_of_impl(implementation: @Impl) -> span {\n         assert implementation.did.crate == local_crate;\n-        match self.crate_context.tcx.items.find(implementation.did.node) {\n+        match self.crate_context.tcx.items.find(&implementation.did.node) {\n             Some(node_item(item, _)) => {\n                 return item.span;\n             }\n@@ -836,7 +837,7 @@ pub impl CoherenceChecker {\n \n             // Make sure we don't visit the same implementation\n             // multiple times.\n-            match impls_seen.find(implementation.did) {\n+            match impls_seen.find(&implementation.did) {\n                 None => {\n                     // Good. Continue.\n                     impls_seen.insert(implementation.did, ());\n@@ -988,7 +989,7 @@ pub impl CoherenceChecker {\n         let coherence_info = &self.crate_context.coherence_info;\n         let tcx = self.crate_context.tcx;\n         let drop_trait = tcx.lang_items.drop_trait();\n-        let impls_opt = coherence_info.extension_methods.find(drop_trait);\n+        let impls_opt = coherence_info.extension_methods.find(&drop_trait);\n \n         let impls;\n         match impls_opt {\n@@ -1013,7 +1014,7 @@ pub impl CoherenceChecker {\n                 _ => {\n                     // Destructors only work on nominal types.\n                     if impl_info.did.crate == ast::local_crate {\n-                        match tcx.items.find(impl_info.did.node) {\n+                        match tcx.items.find(&impl_info.did.node) {\n                             Some(ast_map::node_item(@ref item, _)) => {\n                                 tcx.sess.span_err((*item).span,\n                                                   ~\"the Drop trait may only \\"}, {"sha": "120fd89e5ebdf279656e894e3dd3109f65bf2a33", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 78, "deletions": 128, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -33,10 +33,10 @@ are represented as `ty_param()` instances.\n use core::prelude::*;\n \n use metadata::csearch;\n-use middle::ty::{FnMeta, FnSig, FnTyBase, InstantiatedTraitRef, arg};\n+use middle::ty::{InstantiatedTraitRef, arg};\n use middle::ty::{substs, ty_param_substs_and_ty};\n use middle::ty;\n-use middle::typeck::astconv::{ast_conv, ty_of_fn_decl, ty_of_arg};\n+use middle::typeck::astconv::{ast_conv, ty_of_arg};\n use middle::typeck::astconv::{ast_ty_to_ty};\n use middle::typeck::astconv;\n use middle::typeck::infer;\n@@ -130,7 +130,7 @@ pub impl @crate_ctxt: ast_conv {\n         if id.crate != ast::local_crate {\n             csearch::get_type(self.tcx, id)\n         } else {\n-            match self.tcx.items.find(id.node) {\n+            match self.tcx.items.find(&id.node) {\n               Some(ast_map::node_item(item, _)) => {\n                 ty_of_item(self, item)\n               }\n@@ -153,9 +153,10 @@ pub impl @crate_ctxt: ast_conv {\n \n pub fn get_enum_variant_types(ccx: @crate_ctxt,\n                               enum_ty: ty::t,\n-                              variants: ~[ast::variant],\n-                              ty_params: ~[ast::ty_param],\n-                              rp: Option<ty::region_variance>) {\n+                              variants: &[ast::variant],\n+                              ty_params: &[ast::ty_param],\n+                              rp: Option<ty::region_variance>)\n+{\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n@@ -166,70 +167,45 @@ pub fn get_enum_variant_types(ccx: @crate_ctxt,\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n                 let rs = type_rscope(rp);\n-                let args = args.map(|va| {\n-                    let arg_ty = ccx.to_ty(rs, va.ty);\n-                    arg { mode: ast::expl(ast::by_copy), ty: arg_ty }\n-                });\n-                result_ty = Some(ty::mk_fn(tcx, FnTyBase {\n-                    meta: FnMeta {purity: ast::pure_fn,\n-                                  proto: ast::ProtoBare,\n-                                  onceness: ast::Many,\n-                                  bounds: @~[],\n-                                  region: ty::re_static},\n-                    sig: FnSig {inputs: args,\n-                                output: enum_ty}\n-                }));\n+                let input_tys = args.map(|va| ccx.to_ty(rs, va.ty));\n+                result_ty = Some(ty::mk_ctor_fn(tcx, input_tys, enum_ty));\n             }\n+\n             ast::tuple_variant_kind(_) => {\n                 result_ty = Some(enum_ty);\n             }\n+\n             ast::struct_variant_kind(struct_def) => {\n-                // XXX: Merge with computation of the the same value below?\n-                let tpt = {\n-                    bounds: ty_param_bounds(ccx, /*bad*/copy ty_params),\n-                    region_param: rp,\n-                    ty: enum_ty\n-                };\n-                convert_struct(\n-                    ccx,\n-                    rp,\n-                    struct_def,\n-                    /*bad*/copy ty_params,\n-                    tpt,\n-                    variant.node.id);\n-                // Compute the ctor arg types from the struct fields\n-                let struct_fields = do struct_def.fields.map |struct_field| {\n-                    arg {\n-                        mode: ast::expl(ast::by_val),\n-                        ty: ty::node_id_to_type(ccx.tcx, struct_field.node.id)\n-                    }\n-                };\n-                result_ty = Some(ty::mk_fn(tcx, FnTyBase {\n-                    meta: FnMeta {purity: ast::pure_fn,\n-                                  proto: ast::ProtoBare,\n-                                  onceness: ast::Many,\n-                                  bounds: @~[],\n-                                  region: ty::re_static},\n-                    sig: FnSig {inputs: struct_fields, output: enum_ty }}));\n+                let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n+                           region_param: rp,\n+                           ty: enum_ty};\n+\n+                convert_struct(ccx,\n+                               rp,\n+                               struct_def,\n+                               ty_params.to_vec(),\n+                               tpt,\n+                               variant.node.id);\n+\n+                let input_tys = struct_def.fields.map(\n+                    |f| ty::node_id_to_type(ccx.tcx, f.node.id));\n+                result_ty = Some(ty::mk_ctor_fn(tcx, input_tys, enum_ty));\n             }\n+\n             ast::enum_variant_kind(ref enum_definition) => {\n-                get_enum_variant_types(ccx,\n-                                       enum_ty,\n-                                       /*bad*/copy enum_definition.variants,\n-                                       /*bad*/copy ty_params,\n-                                       rp);\n+                get_enum_variant_types(ccx, enum_ty,\n+                                       enum_definition.variants,\n+                                       ty_params, rp);\n                 result_ty = None;\n             }\n         };\n \n         match result_ty {\n             None => {}\n             Some(result_ty) => {\n-                let tpt = {\n-                    bounds: ty_param_bounds(ccx, /*bad*/copy ty_params),\n-                    region_param: rp,\n-                    ty: result_ty\n-                };\n+                let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n+                           region_param: rp,\n+                           ty: result_ty};\n                 tcx.tcache.insert(local_def(variant.node.id), tpt);\n                 write_ty_to_tcx(tcx, variant.node.id, result_ty);\n             }\n@@ -279,7 +255,7 @@ pub fn ensure_trait_methods(ccx: @crate_ctxt,\n         };\n         let ty = ty::subst(ccx.tcx,\n                            &substs,\n-                           ty::mk_fn(ccx.tcx, /*bad*/copy m.fty));\n+                           ty::mk_bare_fn(ccx.tcx, copy m.fty));\n         let bounds = @(*trait_bounds + ~[@~[ty::bound_trait(trait_ty)]]\n                        + *m.tps);\n         ccx.tcx.tcache.insert(local_def(am.id),\n@@ -290,8 +266,8 @@ pub fn ensure_trait_methods(ccx: @crate_ctxt,\n \n \n     let tcx = ccx.tcx;\n-    let region_paramd = tcx.region_paramd_items.find(id);\n-    match tcx.items.get(id) {\n+    let region_paramd = tcx.region_paramd_items.find(&id);\n+    match tcx.items.get(&id) {\n       ast_map::node_item(@ast::item {\n                 node: ast::item_trait(ref params, _, ref ms),\n                 _\n@@ -305,7 +281,7 @@ pub fn ensure_trait_methods(ccx: @crate_ctxt,\n                 ast::provided(method) => def_id = local_def(method.id)\n             }\n \n-            let trait_bounds = ty_param_bounds(ccx, copy *params);\n+            let trait_bounds = ty_param_bounds(ccx, *params);\n             let ty_m = trait_method_to_ty_method(*m);\n             let method_ty = ty_of_ty_method(ccx, ty_m, region_paramd, def_id);\n             if ty_m.self_ty.node == ast::sty_static {\n@@ -458,7 +434,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     //   that correspond to the parameters we will find on the impl\n     // - replace self region with a fresh, dummy region\n     let impl_fty = {\n-        let impl_fty = ty::mk_fn(tcx, /*bad*/copy impl_m.fty);\n+        let impl_fty = ty::mk_bare_fn(tcx, copy impl_m.fty);\n         debug!(\"impl_fty (pre-subst): %s\", ppaux::ty_to_str(tcx, impl_fty));\n         replace_bound_self(tcx, impl_fty, dummy_self_r)\n     };\n@@ -476,7 +452,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             self_ty: Some(self_ty),\n             tps: vec::append(trait_tps, dummy_tps)\n         };\n-        let trait_fty = ty::mk_fn(tcx, /*bad*/copy trait_m.fty);\n+        let trait_fty = ty::mk_bare_fn(tcx, copy trait_m.fty);\n         debug!(\"trait_fty (pre-subst): %s\", ppaux::ty_to_str(tcx, trait_fty));\n         ty::subst(tcx, &substs, trait_fty)\n     };\n@@ -521,7 +497,7 @@ pub fn check_methods_against_trait(ccx: @crate_ctxt,\n         // trait ref. Otherwise, we will potentially overwrite the types of\n         // the methods within the trait with bogus results. (See issue #3903.)\n \n-        match tcx.items.find(did.node) {\n+        match tcx.items.find(&did.node) {\n             Some(ast_map::node_item(item, _)) => {\n                 let tpt = ty_of_item(ccx, item);\n                 ensure_trait_methods(ccx, did.node, tpt.ty);\n@@ -583,9 +559,9 @@ pub fn convert_methods(ccx: @crate_ctxt,\n \n     let tcx = ccx.tcx;\n     do vec::map(ms) |m| {\n-        let bounds = ty_param_bounds(ccx, /*bad*/copy m.tps);\n+        let bounds = ty_param_bounds(ccx, m.tps);\n         let mty = ty_of_method(ccx, *m, rp);\n-        let fty = ty::mk_fn(tcx, /*bad*/copy mty.fty);\n+        let fty = ty::mk_bare_fn(tcx, copy mty.fty);\n         tcx.tcache.insert(\n             local_def(m.id),\n \n@@ -616,7 +592,7 @@ pub fn ensure_no_ty_param_bounds(ccx: @crate_ctxt,\n \n pub fn convert(ccx: @crate_ctxt, it: @ast::item) {\n     let tcx = ccx.tcx;\n-    let rp = tcx.region_paramd_items.find(it.id);\n+    let rp = tcx.region_paramd_items.find(&it.id);\n     debug!(\"convert: item %s with id %d rp %?\",\n            tcx.sess.str_of(it.ident), it.id, rp);\n     match /*bad*/copy it.node {\n@@ -626,13 +602,11 @@ pub fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         ensure_no_ty_param_bounds(ccx, it.span, *ty_params, \"enumeration\");\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n-        get_enum_variant_types(ccx,\n-                               tpt.ty,\n-                               /*bad*/copy (*enum_definition).variants,\n-                               /*bad*/copy *ty_params, rp);\n+        get_enum_variant_types(ccx, tpt.ty, enum_definition.variants,\n+                               *ty_params, rp);\n       }\n       ast::item_impl(ref tps, trait_ref, selfty, ref ms) => {\n-        let i_bounds = ty_param_bounds(ccx, /*bad*/copy *tps);\n+        let i_bounds = ty_param_bounds(ccx, *tps);\n         let selfty = ccx.to_ty(type_rscope(rp), selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n         tcx.tcache.insert(local_def(it.id),\n@@ -695,13 +669,12 @@ pub fn convert_struct(ccx: @crate_ctxt,\n \n     do option::iter(&struct_def.dtor) |dtor| {\n         // Write the dtor type\n-        let t_dtor = ty::mk_fn(\n+        let t_dtor = ty::mk_bare_fn(\n             tcx,\n-            ty_of_fn_decl(\n-                ccx, type_rscope(rp), ast::ProtoBare,\n-                ast::impure_fn, ast::Many,\n-                /*bounds:*/ @~[], /*opt_region:*/ None,\n-                ast_util::dtor_dec(), None, dtor.span));\n+            astconv::ty_of_bare_fn(\n+                ccx, type_rscope(rp),\n+                ast::impure_fn, ast::RustAbi,\n+                ast_util::dtor_dec()));\n         write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n         tcx.tcache.insert(local_def(dtor.node.id),\n                           {bounds: tpt.bounds,\n@@ -727,25 +700,11 @@ pub fn convert_struct(ccx: @crate_ctxt,\n                 tcx.tcache.insert(local_def(ctor_id), tpt);\n             } else if struct_def.fields[0].node.kind == ast::unnamed_field {\n                 // Tuple-like.\n-                let ctor_fn_ty = ty::mk_fn(tcx, FnTyBase {\n-                    meta: FnMeta {\n-                        purity: ast::pure_fn,\n-                        proto: ast::ProtoBare,\n-                        onceness: ast::Many,\n-                        bounds: @~[],\n-                        region: ty::re_static\n-                    },\n-                    sig: FnSig {\n-                        inputs: do struct_def.fields.map |field| {\n-                            arg {\n-                                mode: ast::expl(ast::by_copy),\n-                                ty: ccx.tcx.tcache.get\n-                                        (local_def(field.node.id)).ty\n-                            }\n-                        },\n-                        output: selfty\n-                    }\n-                });\n+                let inputs =\n+                    struct_def.fields.map(\n+                        |field| ccx.tcx.tcache.get(\n+                            &local_def(field.node.id)).ty);\n+                let ctor_fn_ty = ty::mk_ctor_fn(tcx, inputs, selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.insert(local_def(ctor_id), {\n                     bounds: tpt.bounds,\n@@ -770,11 +729,9 @@ pub fn ty_of_method(ccx: @crate_ctxt,\n                     m: @ast::method,\n                     rp: Option<ty::region_variance>) -> ty::method {\n     {ident: m.ident,\n-     tps: ty_param_bounds(ccx, /*bad*/copy m.tps),\n-     fty: ty_of_fn_decl(ccx, type_rscope(rp), ast::ProtoBare,\n-                        m.purity, ast::Many,\n-                        /*bounds:*/ @~[], /*opt_region:*/ None,\n-                        m.decl, None, m.span),\n+     tps: ty_param_bounds(ccx, m.tps),\n+     fty: astconv::ty_of_bare_fn(ccx, type_rscope(rp), m.purity,\n+                                 ast::RustAbi, m.decl),\n      self_ty: m.self_ty.node,\n      vis: m.vis,\n      def_id: local_def(m.id)}\n@@ -785,11 +742,9 @@ pub fn ty_of_ty_method(self: @crate_ctxt,\n                        rp: Option<ty::region_variance>,\n                        id: ast::def_id) -> ty::method {\n     {ident: m.ident,\n-     tps: ty_param_bounds(self, /*bad*/copy m.tps),\n-     fty: ty_of_fn_decl(self, type_rscope(rp), ast::ProtoBare,\n-                        m.purity, ast::Many,\n-                        /*bounds:*/ @~[], /*opt_region:*/ None,\n-                        m.decl, None, m.span),\n+     tps: ty_param_bounds(self, m.tps),\n+     fty: astconv::ty_of_bare_fn(self, type_rscope(rp), m.purity,\n+                                 ast::RustAbi, m.decl),\n      // assume public, because this is only invoked on trait methods\n      self_ty: m.self_ty.node,\n      vis: ast::public,\n@@ -830,11 +785,11 @@ pub fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n \n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n-    match tcx.tcache.find(def_id) {\n+    match tcx.tcache.find(&def_id) {\n       Some(tpt) => return tpt,\n       _ => {}\n     }\n-    let rp = tcx.region_paramd_items.find(it.id);\n+    let rp = tcx.region_paramd_items.find(&it.id);\n     match /*bad*/copy it.node {\n       ast::item_const(t, _) => {\n         let typ = ccx.to_ty(empty_rscope, t);\n@@ -844,13 +799,11 @@ pub fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n       }\n       ast::item_fn(decl, purity, tps, _) => {\n         let bounds = ty_param_bounds(ccx, tps);\n-        let tofd = ty_of_fn_decl(ccx, empty_rscope,\n-                                 ast::ProtoBare, purity, ast::Many,\n-                                 /*bounds:*/ @~[], /*opt_region:*/ None,\n-                                 decl, None, it.span);\n+        let tofd = astconv::ty_of_bare_fn(ccx, empty_rscope, purity,\n+                                          ast::RustAbi, decl);\n         let tpt = {bounds: bounds,\n                    region_param: None,\n-                   ty: ty::mk_fn(ccx.tcx, tofd)};\n+                   ty: ty::mk_bare_fn(ccx.tcx, tofd)};\n         debug!(\"type of %s (id %d) is %s\",\n                tcx.sess.str_of(it.ident),\n                it.id,\n@@ -859,12 +812,12 @@ pub fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         return tpt;\n       }\n       ast::item_ty(t, tps) => {\n-        match tcx.tcache.find(local_def(it.id)) {\n+        match tcx.tcache.find(&local_def(it.id)) {\n           Some(tpt) => return tpt,\n           None => { }\n         }\n \n-        let rp = tcx.region_paramd_items.find(it.id);\n+        let rp = tcx.region_paramd_items.find(&it.id);\n         let tpt = {\n             let ty = {\n                 let t0 = ccx.to_ty(type_rscope(rp), t);\n@@ -976,9 +929,9 @@ pub fn compute_bounds(ccx: @crate_ctxt,\n }\n \n pub fn ty_param_bounds(ccx: @crate_ctxt,\n-                       params: ~[ast::ty_param]) -> @~[ty::param_bounds] {\n+                       params: &[ast::ty_param]) -> @~[ty::param_bounds] {\n     @do params.map |param| {\n-        match ccx.tcx.ty_param_bounds.find(param.id) {\n+        match ccx.tcx.ty_param_bounds.find(&param.id) {\n           Some(bs) => bs,\n           None => {\n             let bounds = compute_bounds(ccx, param.bounds);\n@@ -999,15 +952,13 @@ pub fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, rb, *a, None) );\n     let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n \n-    let t_fn = ty::mk_fn(ccx.tcx, FnTyBase {\n-        meta: FnMeta {purity: ast::unsafe_fn,\n-                      onceness: ast::Many,\n-                      proto: ast::ProtoBare,\n-                      bounds: @~[],\n-                      region: ty::re_static},\n-        sig: FnSig {inputs: input_tys,\n-                    output: output_ty}\n-    });\n+    let t_fn = ty::mk_bare_fn(\n+        ccx.tcx,\n+        ty::BareFnTy {\n+            abi: ast::RustAbi,\n+            purity: ast::unsafe_fn,\n+            sig: ty::FnSig {inputs: input_tys, output: output_ty}\n+        });\n     let tpt = {bounds: bounds, region_param: None, ty: t_fn};\n     ccx.tcx.tcache.insert(def_id, tpt);\n     return tpt;\n@@ -1017,8 +968,7 @@ pub fn mk_ty_params(ccx: @crate_ctxt, atps: ~[ast::ty_param])\n     -> {bounds: @~[ty::param_bounds], params: ~[ty::t]} {\n \n     let mut i = 0u;\n-    // XXX: Bad copy.\n-    let bounds = ty_param_bounds(ccx, copy atps);\n+    let bounds = ty_param_bounds(ccx, atps);\n     {bounds: bounds,\n      params: vec::map(atps, |atp| {\n          let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));"}, {"sha": "5d291fdde77b386a43f2094c529adf32a8df9470", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -69,7 +69,7 @@ use core::prelude::*;\n use middle::ty::{TyVar, AutoPtr, AutoBorrowVec, AutoBorrowFn};\n use middle::ty::{AutoAdjustment, AutoRef};\n use middle::ty::{vstore_slice, vstore_box, vstore_uniq, vstore_fixed};\n-use middle::ty::{FnMeta, FnTyBase, mt};\n+use middle::ty::{mt};\n use middle::ty;\n use middle::typeck::infer::{CoerceResult, resolve_type};\n use middle::typeck::infer::combine::CombineFields;\n@@ -117,7 +117,7 @@ impl Coerce {\n                 };\n             }\n \n-            ty::ty_fn(ref b_f) if b_f.meta.proto == ast::ProtoBorrowed => {\n+            ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil, _}) => {\n                 return do self.unpack_actual_value(a) |sty_a| {\n                     self.coerce_borrowed_fn(a, sty_a, b)\n                 };\n@@ -134,7 +134,7 @@ impl Coerce {\n \n         do self.unpack_actual_value(a) |sty_a| {\n             match *sty_a {\n-                ty::ty_fn(ref a_f) if a_f.meta.proto == ast::ProtoBare => {\n+                ty::ty_bare_fn(ref a_f) => {\n                     // Bare functions are coercable to any closure type.\n                     //\n                     // FIXME(#3320) this should go away and be\n@@ -289,9 +289,9 @@ impl Coerce {\n                b.inf_str(self.infcx));\n \n         let fn_ty = match *sty_a {\n-            ty::ty_fn(ref f) if f.meta.proto == ast::ProtoBox => {f}\n-            ty::ty_fn(ref f) if f.meta.proto == ast::ProtoUniq => {f}\n-            ty::ty_fn(ref f) if f.meta.proto == ast::ProtoBare => {\n+            ty::ty_closure(ref f) if f.sigil == ast::ManagedSigil => copy *f,\n+            ty::ty_closure(ref f) if f.sigil == ast::OwnedSigil => copy *f,\n+            ty::ty_bare_fn(ref f) => {\n                 return self.coerce_from_bare_fn(a, f, b);\n             }\n             _ => {\n@@ -300,12 +300,13 @@ impl Coerce {\n         };\n \n         let r_borrow = self.infcx.next_region_var_nb(self.span);\n-        let meta = FnMeta {proto: ast::ProtoBorrowed,\n-                           region: r_borrow,\n-                           ..fn_ty.meta};\n-        let a_borrowed = ty::mk_fn(self.infcx.tcx,\n-                                   FnTyBase {meta: meta,\n-                                             sig: copy fn_ty.sig});\n+        let a_borrowed = ty::mk_closure(\n+            self.infcx.tcx,\n+            ty::ClosureTy {\n+                sigil: ast::BorrowedSigil,\n+                region: r_borrow,\n+                ..fn_ty\n+            });\n \n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(@AutoAdjustment {\n@@ -320,7 +321,7 @@ impl Coerce {\n \n     fn coerce_from_bare_fn(&self,\n                            a: ty::t,\n-                           fn_ty_a: &ty::FnTy,\n+                           fn_ty_a: &ty::BareFnTy,\n                            b: ty::t) -> CoerceResult\n     {\n         do self.unpack_actual_value(b) |sty_b| {\n@@ -330,26 +331,26 @@ impl Coerce {\n \n     fn coerce_from_bare_fn_post_unpack(&self,\n                                        a: ty::t,\n-                                       fn_ty_a: &ty::FnTy,\n+                                       fn_ty_a: &ty::BareFnTy,\n                                        b: ty::t,\n                                        sty_b: &ty::sty) -> CoerceResult\n     {\n         debug!(\"coerce_from_bare_fn(a=%s, b=%s)\",\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n \n         let fn_ty_b = match *sty_b {\n-            ty::ty_fn(ref f) if f.meta.proto != ast::ProtoBare => {f}\n+            ty::ty_closure(ref f) => {copy *f}\n             _ => {\n                 return self.subtype(a, b);\n             }\n         };\n \n-            // for now, bare fn and closures have the same\n-            // representation\n-        let a_adapted = ty::mk_fn(self.infcx.tcx,\n-                                  FnTyBase {meta: copy fn_ty_b.meta,\n-                                            sig: copy fn_ty_a.sig});\n-        self.subtype(a_adapted, b)\n+        // for now, bare fn and closures have the same\n+        // representation\n+        let a_closure = ty::mk_closure(\n+            self.infcx.tcx,\n+            ty::ClosureTy {sig: copy fn_ty_a.sig, ..fn_ty_b});\n+        self.subtype(a_closure, b)\n     }\n \n     fn coerce_unsafe_ptr(&self,"}, {"sha": "7737327bc0c52935f7f292b353aafab6dc9a6ad5", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 52, "deletions": 26, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -56,7 +56,7 @@\n \n use core::prelude::*;\n \n-use middle::ty::{FloatVar, FnTyBase, FnMeta, FnSig, IntVar, TyVar};\n+use middle::ty::{FloatVar, FnSig, IntVar, TyVar};\n use middle::ty::{IntType, UintType, arg, substs};\n use middle::ty;\n use middle::typeck::infer::glb::Glb;\n@@ -94,14 +94,17 @@ pub trait Combine {\n     fn self_tys(a: Option<ty::t>, b: Option<ty::t>) -> cres<Option<ty::t>>;\n     fn substs(did: ast::def_id, as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs>;\n-    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy>;\n+    fn bare_fn_tys(a: &ty::BareFnTy,\n+                   b: &ty::BareFnTy) -> cres<ty::BareFnTy>;\n+    fn closure_tys(a: &ty::ClosureTy,\n+                   b: &ty::ClosureTy) -> cres<ty::ClosureTy>;\n     fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n-    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta>;\n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field>;\n     fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode>;\n     fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg>;\n-    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto>;\n+    fn sigils(p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil>;\n     fn purities(a: purity, b: purity) -> cres<purity>;\n+    fn abis(a: ast::Abi, b: ast::Abi) -> cres<ast::Abi>;\n     fn oncenesses(a: Onceness, b: Onceness) -> cres<Onceness>;\n     fn contraregions(a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n     fn regions(a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n@@ -287,12 +290,12 @@ pub fn super_self_tys<C:Combine>(\n     }\n }\n \n-pub fn super_protos<C: Combine>(\n-    self: &C, p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n+pub fn super_sigils<C: Combine>(\n+    self: &C, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n     if p1 == p2 {\n         Ok(p1)\n     } else {\n-        Err(ty::terr_proto_mismatch(expected_found(self, p1, p2)))\n+        Err(ty::terr_sigil_mismatch(expected_found(self, p1, p2)))\n     }\n }\n \n@@ -350,21 +353,45 @@ pub fn super_vstores<C:Combine>(\n     }\n }\n \n-pub fn super_fn_metas<C:Combine>(\n-    self: &C, a_f: &ty::FnMeta, b_f: &ty::FnMeta) -> cres<ty::FnMeta> {\n-    let p = if_ok!(self.protos(a_f.proto, b_f.proto));\n+pub fn super_closure_tys<C:Combine>(\n+    self: &C, a_f: &ty::ClosureTy, b_f: &ty::ClosureTy) -> cres<ty::ClosureTy>\n+{\n+    let p = if_ok!(self.sigils(a_f.sigil, b_f.sigil));\n     let r = if_ok!(self.contraregions(a_f.region, b_f.region));\n     let purity = if_ok!(self.purities(a_f.purity, b_f.purity));\n     let onceness = if_ok!(self.oncenesses(a_f.onceness, b_f.onceness));\n-    Ok(FnMeta {purity: purity,\n-               proto: p,\n-               onceness: onceness,\n-               region: r,\n-               bounds: a_f.bounds}) // XXX: This is wrong!\n+    let sig = if_ok!(self.fn_sigs(&a_f.sig, &b_f.sig));\n+    Ok(ty::ClosureTy {purity: purity,\n+                      sigil: p,\n+                      onceness: onceness,\n+                      region: r,\n+                      sig: sig})\n+}\n+\n+pub fn super_abis<C:Combine>(\n+    self: &C, a: ast::Abi, b: ast::Abi) -> cres<ast::Abi>\n+{\n+    if a == b {\n+        Ok(a)\n+    } else {\n+        Err(ty::terr_abi_mismatch(expected_found(self, a, b)))\n+    }\n+}\n+\n+pub fn super_bare_fn_tys<C:Combine>(\n+    self: &C, a_f: &ty::BareFnTy, b_f: &ty::BareFnTy) -> cres<ty::BareFnTy>\n+{\n+    let purity = if_ok!(self.purities(a_f.purity, b_f.purity));\n+    let abi = if_ok!(self.abis(a_f.abi, b_f.abi));\n+    let sig = if_ok!(self.fn_sigs(&a_f.sig, &b_f.sig));\n+    Ok(ty::BareFnTy {purity: purity,\n+                     abi: abi,\n+                     sig: sig})\n }\n \n pub fn super_fn_sigs<C:Combine>(\n-    self: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig> {\n+    self: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig>\n+{\n     fn argvecs<C:Combine>(self: &C,\n                           +a_args: ~[ty::arg],\n                           +b_args: ~[ty::arg]) -> cres<~[ty::arg]>\n@@ -384,13 +411,6 @@ pub fn super_fn_sigs<C:Combine>(\n     }\n }\n \n-pub fn super_fns<C:Combine>(\n-    self: &C, a_f: &ty::FnTy, b_f: &ty::FnTy) -> cres<ty::FnTy> {\n-    let m = if_ok!(self.fn_metas(&a_f.meta, &b_f.meta));\n-    let s = if_ok!(self.fn_sigs(&a_f.sig, &b_f.sig));\n-    Ok(FnTyBase {meta: m, sig: s})\n-}\n-\n pub fn super_tys<C:Combine>(\n     self: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n     let tcx = self.infcx().tcx;\n@@ -551,9 +571,15 @@ pub fn super_tys<C:Combine>(\n         }\n       }\n \n-      (ty::ty_fn(ref a_fty), ty::ty_fn(ref b_fty)) => {\n-        do self.fns(a_fty, b_fty).chain |fty| {\n-            Ok(ty::mk_fn(tcx, fty))\n+      (ty::ty_bare_fn(ref a_fty), ty::ty_bare_fn(ref b_fty)) => {\n+        do self.bare_fn_tys(a_fty, b_fty).chain |fty| {\n+            Ok(ty::mk_bare_fn(tcx, fty))\n+        }\n+      }\n+\n+      (ty::ty_closure(ref a_fty), ty::ty_closure(ref b_fty)) => {\n+        do self.closure_tys(a_fty, b_fty).chain |fty| {\n+            Ok(ty::mk_closure(tcx, fty))\n         }\n       }\n "}, {"sha": "382d5f24cc74b6dd48f83a245eccaca5043bb357", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -267,16 +267,22 @@ pub impl Glb: Combine {\n         }\n     }\n \n-    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n-        super_protos(&self, p1, p2)\n+    fn sigils(p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n+        super_sigils(&self, p1, p2)\n     }\n \n-    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n-        super_fns(&self, a, b)\n+    fn abis(p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n+        super_abis(&self, p1, p2)\n     }\n \n-    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n-        super_fn_metas(&self, a, b)\n+    fn bare_fn_tys(a: &ty::BareFnTy,\n+                   b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n+        super_bare_fn_tys(&self, a, b)\n+    }\n+\n+    fn closure_tys(a: &ty::ClosureTy,\n+                   b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n+        super_closure_tys(&self, a, b)\n     }\n \n     fn substs(did: ast::def_id,"}, {"sha": "4bf8a0bae8623dd29af701251024aef4d89fc9e2", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -71,23 +71,6 @@ pub impl ty::t: LatticeValue {\n     }\n }\n \n-pub impl FnMeta: LatticeValue {\n-    static fn sub(cf: &CombineFields,\n-                  a: &FnMeta, b: &FnMeta) -> ures {\n-        Sub(*cf).fn_metas(a, b).to_ures()\n-    }\n-\n-    static fn lub(cf: &CombineFields,\n-                  a: &FnMeta, b: &FnMeta) -> cres<FnMeta> {\n-        Lub(*cf).fn_metas(a, b)\n-    }\n-\n-    static fn glb(cf: &CombineFields,\n-                  a: &FnMeta, b: &FnMeta) -> cres<FnMeta> {\n-        Glb(*cf).fn_metas(a, b)\n-    }\n-}\n-\n pub impl CombineFields {\n     fn var_sub_var<T:Copy InferStr LatticeValue,\n                    V:Copy Eq ToStr Vid UnifyVid<Bounds<T>>>("}, {"sha": "44ad367c9dcf9d5e79232e6373bcfdaa586ce227", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -191,18 +191,24 @@ pub impl Lub: Combine {\n         }\n     }\n \n-    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n-        super_fns(&self, a, b)\n+    fn bare_fn_tys(a: &ty::BareFnTy,\n+                   b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n+        super_bare_fn_tys(&self, a, b)\n     }\n \n-    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n-        super_fn_metas(&self, a, b)\n+    fn closure_tys(a: &ty::ClosureTy,\n+                   b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n+        super_closure_tys(&self, a, b)\n     }\n \n     // Traits please (FIXME: #2794):\n \n-    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n-        super_protos(&self, p1, p2)\n+    fn sigils(p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n+        super_sigils(&self, p1, p2)\n+    }\n+\n+    fn abis(p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n+        super_abis(&self, p1, p2)\n     }\n \n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {"}, {"sha": "d6ecf11ef26faf96556a5757ca4b252026e5f089", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -242,9 +242,6 @@ section on \"Type Combining\" below for details.\n \n */\n \n-#[warn(deprecated_mode)];\n-#[warn(deprecated_pattern)];\n-\n use core::prelude::*;\n \n pub use middle::ty::IntVarValue;\n@@ -257,7 +254,6 @@ pub use middle::typeck::infer::resolve::{resolve_nested_tvar};\n pub use middle::typeck::infer::resolve::{resolve_rvar};\n \n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n-use middle::ty::{mk_fn, type_is_bot};\n use middle::ty::{ty_int, ty_uint, get, terr_fn, TyVar, IntVar, FloatVar};\n use middle::ty;\n use middle::typeck::check::regionmanip::{replace_bound_regions_in_fn_sig};"}, {"sha": "afb18888cd90587b0d2586a9b3d17cedc3cd860d", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -536,9 +536,6 @@ more convincing in the future.\n \n */\n \n-#[warn(deprecated_mode)];\n-#[warn(deprecated_pattern)];\n-\n use core::prelude::*;\n \n use middle::region::is_subregion_of;\n@@ -912,7 +909,7 @@ pub impl RegionVarBindings {\n         -> cres<Region> {\n \n         let vars = TwoRegions { a: a, b: b };\n-        match combines.find(vars) {\n+        match combines.find(&vars) {\n           Some(c) => Ok(re_infer(ReVar(c))),\n           None => {\n             let c = self.new_region_var(span);"}, {"sha": "bc834ef0289964773ff6c561841f90794fb91fa9", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -212,20 +212,26 @@ pub impl Sub: Combine {\n \n     // Traits please (FIXME: #2794):\n \n-    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n-        super_protos(&self, p1, p2)\n+    fn sigils(p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n+        super_sigils(&self, p1, p2)\n+    }\n+\n+    fn abis(p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n+        super_abis(&self, p1, p2)\n     }\n \n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n         super_flds(&self, a, b)\n     }\n \n-    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n-        super_fns(&self, a, b)\n+    fn bare_fn_tys(a: &ty::BareFnTy,\n+                   b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n+        super_bare_fn_tys(&self, a, b)\n     }\n \n-    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n-        super_fn_metas(&self, a, b)\n+    fn closure_tys(a: &ty::ClosureTy,\n+                   b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n+        super_closure_tys(&self, a, b)\n     }\n \n     fn vstores(vk: ty::terr_vstore_kind,"}, {"sha": "bade7639e4baf60a2828c83138b24ed65ee54966", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,7 +10,7 @@\n \n use core::prelude::*;\n \n-use middle::ty::{FnMeta, FnTyBase, FnSig, Vid};\n+use middle::ty::{FnSig, Vid};\n use middle::ty::{IntVarValue, IntType, UintType};\n use middle::ty;\n use middle::typeck::infer::{Bound, Bounds};\n@@ -34,12 +34,6 @@ pub impl ty::t : InferStr {\n     }\n }\n \n-pub impl FnMeta : InferStr {\n-    fn inf_str(&self, _cx: &InferCtxt) -> ~str {\n-        fmt!(\"%?\", *self)\n-    }\n-}\n-\n pub impl FnSig : InferStr {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         fmt!(\"(%s) -> %s\",\n@@ -48,12 +42,6 @@ pub impl FnSig : InferStr {\n     }\n }\n \n-pub impl<M:InferStr> FnTyBase<M> : InferStr {\n-    fn inf_str(&self, cx: &InferCtxt) -> ~str {\n-        fmt!(\"%s%s\", self.meta.inf_str(cx), self.sig.inf_str(cx))\n-    }\n-}\n-\n pub impl ty::mt : InferStr {\n     fn inf_str(&self, cx: &InferCtxt) -> ~str {\n         mt_to_str(cx.tcx, *self)"}, {"sha": "3d9e2e7b86ab28b433a81064c9e68450b565fc75", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -225,7 +225,7 @@ pub fn write_substs_to_tcx(tcx: ty::ctxt,\n }\n \n pub fn lookup_def_tcx(tcx: ty::ctxt, sp: span, id: ast::node_id) -> ast::def {\n-    match tcx.def_map.find(id) {\n+    match tcx.def_map.find(&id) {\n       Some(x) => x,\n       _ => {\n         tcx.sess.span_fatal(sp, ~\"internal error looking up a definition\")\n@@ -324,8 +324,8 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     match ty::get(main_t).sty {\n-        ty::ty_fn(ref fn_ty) => {\n-            match tcx.items.find(main_id) {\n+        ty::ty_bare_fn(ref fn_ty) => {\n+            match tcx.items.find(&main_id) {\n                 Some(ast_map::node_item(it,_)) => {\n                     match it.node {\n                         ast::item_fn(_, _, ref ps, _)\n@@ -341,8 +341,8 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n                 }\n                 _ => ()\n             }\n-            let mut ok = ty::type_is_nil((*fn_ty).sig.output);\n-            let num_args = vec::len((*fn_ty).sig.inputs);\n+            let mut ok = ty::type_is_nil(fn_ty.sig.output);\n+            let num_args = vec::len(fn_ty.sig.inputs);\n             ok &= num_args == 0u;\n             if !ok {\n                 tcx.sess.span_err("}, {"sha": "43d12c95c4df6e348c3cff604854f9b5a90816f3", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 88, "deletions": 77, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -21,7 +21,8 @@ use middle::ty::{mt, t, param_bound, param_ty};\n use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region};\n use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{ty_bool, ty_bot, ty_box, ty_struct, ty_enum};\n-use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_fn, ty_trait, ty_int};\n+use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_bare_fn, ty_closure};\n+use middle::ty::{ty_trait, ty_int};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n use middle::ty::{ty_ptr, ty_rec, ty_rptr, ty_self, ty_tup};\n use middle::ty::{ty_type, ty_uniq, ty_uint, ty_infer};\n@@ -30,7 +31,7 @@ use metadata::encoder;\n use syntax::codemap;\n use syntax::codemap::span;\n use syntax::print::pprust;\n-use syntax::print::pprust::{path_to_str, proto_to_str, mode_to_str};\n+use syntax::print::pprust::{path_to_str, mode_to_str};\n use syntax::{ast, ast_util};\n use syntax::ast_map;\n \n@@ -67,7 +68,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                             -> (~str, Option<span>) {\n     return match region {\n       re_scope(node_id) => {\n-        match cx.items.find(node_id) {\n+        match cx.items.find(&node_id) {\n           Some(ast_map::node_block(ref blk)) => {\n             explain_span(cx, \"block\", (*blk).span)\n           }\n@@ -105,7 +106,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n                     bound_region_to_str(cx, br))\n         };\n \n-        match cx.items.find(id) {\n+        match cx.items.find(&id) {\n           Some(ast_map::node_block(ref blk)) => {\n             let (msg, opt_span) = explain_span(cx, \"block\", (*blk).span);\n             (fmt!(\"%s %s\", prefix, msg), opt_span)\n@@ -154,7 +155,7 @@ pub fn bound_region_to_str_adorned(cx: ctxt, prefix: &str,\n }\n \n pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n-    match cx.items.find(node_id) {\n+    match cx.items.find(&node_id) {\n       Some(ast_map::node_block(ref blk)) => {\n         fmt!(\"<block at %s>\",\n              cx.sess.codemap.span_to_str((*blk).span))\n@@ -252,17 +253,6 @@ pub fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n     }\n }\n \n-pub fn proto_ty_to_str(_cx: ctxt, proto: ast::Proto,\n-                       followed_by_word: bool) -> &static/str {\n-    match proto {\n-        ast::ProtoBare if followed_by_word => \"extern \",\n-        ast::ProtoBare => \"extern\",\n-        ast::ProtoBox => \"@\",\n-        ast::ProtoBorrowed => \"&\",\n-        ast::ProtoUniq => \"~\",\n-    }\n-}\n-\n pub fn expr_repr(cx: ctxt, expr: @ast::expr) -> ~str {\n     fmt!(\"expr(%d: %s)\",\n          expr.id,\n@@ -306,69 +296,95 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         };\n         fmt!(\"%s%s\", modestr, ty_to_str(cx, ty))\n     }\n-    fn fn_to_str(cx: ctxt,\n-                 proto: ast::Proto,\n-                 region: ty::Region,\n-                 purity: ast::purity,\n-                 onceness: ast::Onceness,\n-                 ident: Option<ast::ident>,\n-                 inputs: &[arg],\n-                 output: t) -> ~str {\n-        let mut s;\n-\n-        s = match purity {\n-            ast::impure_fn => ~\"\",\n-            _ => purity.to_str() + ~\" \"\n-        };\n+    fn bare_fn_to_str(cx: ctxt,\n+                      purity: ast::purity,\n+                      abi: ast::Abi,\n+                      ident: Option<ast::ident>,\n+                      sig: &ty::FnSig) -> ~str\n+    {\n+        let mut s = ~\"extern \";\n \n-        s += match onceness {\n-            ast::Many => ~\"\",\n-            ast::Once => onceness.to_str() + ~\" \"\n+        match abi {\n+            ast::RustAbi => {}\n+        }\n+\n+        match purity {\n+            ast::impure_fn => {}\n+            _ => {\n+                s.push_str(purity.to_str());\n+                s.push_char(' ');\n+            }\n         };\n \n-        s += proto_ty_to_str(cx, proto, true);\n+        s.push_str(\"fn\");\n \n-        match (proto, region) {\n-            (ast::ProtoBox, ty::re_static) |\n-            (ast::ProtoUniq, ty::re_static) |\n-            (ast::ProtoBare, ty::re_static) => {\n-            }\n+        match ident {\n+          Some(i) => {\n+              s.push_char(' ');\n+              s.push_str(cx.sess.str_of(i));\n+          }\n+          _ => { }\n+        }\n+\n+        push_sig_to_str(cx, &mut s, sig);\n+\n+        return s;\n+    }\n+    fn closure_to_str(cx: ctxt, cty: &ty::ClosureTy) -> ~str\n+    {\n+        let mut s = cty.sigil.to_str();\n+\n+        match (cty.sigil, cty.region) {\n+            (ast::ManagedSigil, ty::re_static) |\n+            (ast::OwnedSigil, ty::re_static) => {}\n \n             (_, region) => {\n-                s += region_to_str_adorned(cx, ~\"\", region, ~\"/\");\n+                s.push_str(region_to_str_adorned(cx, \"\", region, \"/\"));\n             }\n         }\n \n-        s += ~\"fn\";\n+        match cty.purity {\n+            ast::impure_fn => {}\n+            _ => {\n+                s.push_str(cty.purity.to_str());\n+                s.push_char(' ');\n+            }\n+        };\n \n-        match ident {\n-          Some(i) => { s += ~\" \"; s += cx.sess.str_of(i); }\n-          _ => { }\n-        }\n-        s += ~\"(\";\n-        let strs = inputs.map(|a| fn_input_to_str(cx, *a));\n-        s += str::connect(strs, ~\", \");\n-        s += ~\")\";\n-        if ty::get(output).sty != ty_nil {\n-            s += ~\" -> \";\n-            if ty::type_is_bot(output) {\n-                s += ~\"!\";\n+        match cty.onceness {\n+            ast::Many => {}\n+            ast::Once => {\n+                s.push_str(cty.onceness.to_str());\n+                s.push_char(' ');\n+            }\n+        };\n+\n+        s.push_str(\"fn\");\n+\n+        push_sig_to_str(cx, &mut s, &cty.sig);\n+\n+        return s;\n+    }\n+    fn push_sig_to_str(cx: ctxt, s: &mut ~str, sig: &ty::FnSig) {\n+        s.push_char('(');\n+        let strs = sig.inputs.map(|a| fn_input_to_str(cx, *a));\n+        s.push_str(str::connect(strs, \", \"));\n+        s.push_char(')');\n+        if ty::get(sig.output).sty != ty_nil {\n+            s.push_str(\" -> \");\n+            if ty::type_is_bot(sig.output) {\n+                s.push_char('!');\n             } else {\n-                s += ty_to_str(cx, output);\n+                s.push_str(ty_to_str(cx, sig.output));\n             }\n         }\n-        return s;\n     }\n     fn method_to_str(cx: ctxt, m: method) -> ~str {\n-        return fn_to_str(\n-            cx,\n-            m.fty.meta.proto,\n-            m.fty.meta.region,\n-            m.fty.meta.purity,\n-            m.fty.meta.onceness,\n-            Some(m.ident),\n-            m.fty.sig.inputs,\n-            m.fty.sig.output) + ~\";\";\n+        bare_fn_to_str(cx,\n+                       m.fty.purity,\n+                       m.fty.abi,\n+                       Some(m.ident),\n+                       &m.fty.sig) + ~\";\"\n     }\n     fn field_to_str(cx: ctxt, f: field) -> ~str {\n         return cx.sess.str_of(f.ident) + ~\": \" + mt_to_str(cx, f.mt);\n@@ -409,15 +425,11 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         let strs = elems.map(|elem| ty_to_str(cx, *elem));\n         ~\"(\" + str::connect(strs, ~\",\") + ~\")\"\n       }\n-      ty_fn(ref f) => {\n-        fn_to_str(cx,\n-                  f.meta.proto,\n-                  f.meta.region,\n-                  f.meta.purity,\n-                  f.meta.onceness,\n-                  None,\n-                  f.sig.inputs,\n-                  f.sig.output)\n+      ty_closure(ref f) => {\n+          closure_to_str(cx, f)\n+      }\n+      ty_bare_fn(ref f) => {\n+          bare_fn_to_str(cx, f.purity, f.abi, None, &f.sig)\n       }\n       ty_infer(infer_ty) => infer_ty.to_str(),\n       ty_err => ~\"[type error]\",\n@@ -448,10 +460,9 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       }\n       ty_estr(vs) => vstore_ty_to_str(cx, ~\"str\", vs),\n       ty_opaque_box => ~\"@?\",\n-      ty_opaque_closure_ptr(ast::ProtoBorrowed) => ~\"closure&\",\n-      ty_opaque_closure_ptr(ast::ProtoBox) => ~\"closure@\",\n-      ty_opaque_closure_ptr(ast::ProtoUniq) => ~\"closure~\",\n-      ty_opaque_closure_ptr(ast::ProtoBare) => ~\"closure\"\n+      ty_opaque_closure_ptr(ast::BorrowedSigil) => ~\"closure&\",\n+      ty_opaque_closure_ptr(ast::ManagedSigil) => ~\"closure@\",\n+      ty_opaque_closure_ptr(ast::OwnedSigil) => ~\"closure~\",\n     }\n }\n "}, {"sha": "1d629467a42e9ebd99e22d037832551b68405a31", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -21,6 +21,7 @@ use core::prelude::*;\n \n use parse;\n use util;\n+use std::cell::Cell;\n \n use core::pipes::{stream, Chan, SharedChan, Port};\n use core::vec;\n@@ -78,8 +79,10 @@ fn run<T>(owner: SrvOwner<T>, source: ~str, parse: Parser) -> T {\n \n     let (po, ch) = stream();\n \n+    let source = Cell(source);\n+    let parse = Cell(parse);\n     do task::spawn {\n-        act(&po, copy source, copy parse);\n+        act(&po, source.take(), parse.take());\n     }\n \n     let srv_ = Srv {"}, {"sha": "0beb651afc4ed1f3ab0768307c407283247adfff", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -96,7 +96,7 @@ fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n }\n \n pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n-    let doc_strs = do doc_metas(attrs).filter_map |meta| {\n+    let doc_strs = do doc_metas(attrs).filter_mapped |meta| {\n         attr::get_meta_item_value_str(*meta)\n     };\n     if doc_strs.is_empty() {"}, {"sha": "c595ebce65f1a5d2df31f8c6949abbdf61f8e738", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -116,7 +116,7 @@ fn parse_item_attrs<T:Owned>(\n     id: doc::AstId,\n     parse_attrs: fn~(a: ~[ast::attribute]) -> T) -> T {\n     do astsrv::exec(srv) |move parse_attrs, ctxt| {\n-        let attrs = match ctxt.ast_map.get(id) {\n+        let attrs = match ctxt.ast_map.get(&id) {\n           ast_map::node_item(item, _) => copy item.attrs,\n           ast_map::node_foreign_item(item, _, _) => copy item.attrs,\n           _ => die!(~\"parse_item_attrs: not an item\")\n@@ -170,7 +170,7 @@ fn fold_enum(\n             let desc = {\n                 let variant = copy variant;\n                 do astsrv::exec(srv.clone()) |ctxt| {\n-                    match ctxt.ast_map.get(doc_id) {\n+                    match ctxt.ast_map.get(&doc_id) {\n                         ast_map::node_item(@ast::item {\n                             node: ast::item_enum(ref enum_definition, _), _\n                         }, _) => {\n@@ -234,7 +234,7 @@ fn merge_method_attrs(\n \n     // Create an assoc list from method name to attributes\n     let attrs: ~[(~str, Option<~str>)] = do astsrv::exec(srv) |ctxt| {\n-        match ctxt.ast_map.get(item_id) {\n+        match ctxt.ast_map.get(&item_id) {\n           ast_map::node_item(@ast::item {\n             node: ast::item_trait(_, _, ref methods), _\n           }, _) => {"}, {"sha": "2d0969562a05cd61014d6b26b435613a7721739f", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -62,7 +62,7 @@ fn fold_trait(fold: &fold::Fold<()>, doc: doc::TraitDoc) -> doc::TraitDoc {\n     let doc =fold::default_seq_fold_trait(fold, doc);\n \n     doc::TraitDoc {\n-        methods: par::map(doc.methods, |doc| doc::MethodDoc {\n+        methods: doc.methods.map(|doc| doc::MethodDoc {\n             brief: extract(copy doc.desc),\n             .. copy *doc\n         }),\n@@ -74,7 +74,7 @@ fn fold_impl(fold: &fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n     let doc =fold::default_seq_fold_impl(fold, doc);\n \n     doc::ImplDoc {\n-        methods: par::map(doc.methods, |doc| doc::MethodDoc {\n+        methods: doc.methods.map(|doc| doc::MethodDoc {\n             brief: extract(copy doc.desc),\n             .. copy *doc\n         }),"}, {"sha": "2eb4ed97871323801149d2d1d9b4b1bcbb6485b0", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -192,7 +192,7 @@ impl Doc {\n /// Some helper methods on ModDoc, mostly for testing\n impl ModDoc {\n     fn mods(&self) -> ~[ModDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               ModTag(ModDoc) => Some(ModDoc),\n               _ => None\n@@ -201,7 +201,7 @@ impl ModDoc {\n     }\n \n     fn nmods(&self) -> ~[NmodDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               NmodTag(nModDoc) => Some(nModDoc),\n               _ => None\n@@ -210,7 +210,7 @@ impl ModDoc {\n     }\n \n     fn fns(&self) -> ~[FnDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               FnTag(FnDoc) => Some(FnDoc),\n               _ => None\n@@ -219,7 +219,7 @@ impl ModDoc {\n     }\n \n     fn consts(&self) -> ~[ConstDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               ConstTag(ConstDoc) => Some(ConstDoc),\n               _ => None\n@@ -228,7 +228,7 @@ impl ModDoc {\n     }\n \n     fn enums(&self) -> ~[EnumDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               EnumTag(EnumDoc) => Some(EnumDoc),\n               _ => None\n@@ -237,7 +237,7 @@ impl ModDoc {\n     }\n \n     fn traits(&self) -> ~[TraitDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               TraitTag(TraitDoc) => Some(TraitDoc),\n               _ => None\n@@ -246,7 +246,7 @@ impl ModDoc {\n     }\n \n     fn impls(&self) -> ~[ImplDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               ImplTag(ImplDoc) => Some(ImplDoc),\n               _ => None\n@@ -255,7 +255,7 @@ impl ModDoc {\n     }\n \n     fn types(&self) -> ~[TyDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n               TyTag(TyDoc) => Some(TyDoc),\n               _ => None\n@@ -264,7 +264,7 @@ impl ModDoc {\n     }\n \n     fn structs(&self) -> ~[StructDoc] {\n-        do vec::filter_map(self.items) |itemtag| {\n+        do vec::filter_mapped(self.items) |itemtag| {\n             match copy *itemtag {\n                 StructTag(StructDoc) => Some(StructDoc),\n                 _ => None\n@@ -287,7 +287,7 @@ pub trait PageUtils {\n impl ~[Page]: PageUtils {\n \n     fn mods(&self) -> ~[ModDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(ModTag(ModDoc)) => Some(ModDoc),\n               _ => None\n@@ -296,7 +296,7 @@ impl ~[Page]: PageUtils {\n     }\n \n     fn nmods(&self) -> ~[NmodDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(NmodTag(nModDoc)) => Some(nModDoc),\n               _ => None\n@@ -305,7 +305,7 @@ impl ~[Page]: PageUtils {\n     }\n \n     fn fns(&self) -> ~[FnDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(FnTag(FnDoc)) => Some(FnDoc),\n               _ => None\n@@ -314,7 +314,7 @@ impl ~[Page]: PageUtils {\n     }\n \n     fn consts(&self) -> ~[ConstDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(ConstTag(ConstDoc)) => Some(ConstDoc),\n               _ => None\n@@ -323,7 +323,7 @@ impl ~[Page]: PageUtils {\n     }\n \n     fn enums(&self) -> ~[EnumDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(EnumTag(EnumDoc)) => Some(EnumDoc),\n               _ => None\n@@ -332,7 +332,7 @@ impl ~[Page]: PageUtils {\n     }\n \n     fn traits(&self) -> ~[TraitDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(TraitTag(TraitDoc)) => Some(TraitDoc),\n               _ => None\n@@ -341,7 +341,7 @@ impl ~[Page]: PageUtils {\n     }\n \n     fn impls(&self) -> ~[ImplDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(ImplTag(ImplDoc)) => Some(ImplDoc),\n               _ => None\n@@ -350,7 +350,7 @@ impl ~[Page]: PageUtils {\n     }\n \n     fn types(&self) -> ~[TyDoc] {\n-        do vec::filter_map(*self) |page| {\n+        do vec::filter_mapped(*self) |page| {\n             match copy *page {\n               ItemPage(TyTag(TyDoc)) => Some(TyDoc),\n               _ => None"}, {"sha": "822a423eae40ca31929fde8f359585f06eb2f4da", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -92,7 +92,7 @@ fn moddoc_from_mod(\n ) -> doc::ModDoc {\n     doc::ModDoc {\n         item: itemdoc,\n-        items: do vec::filter_map(module_.items) |item| {\n+        items: do vec::filter_mapped(module_.items) |item| {\n             let ItemDoc = mk_itemdoc(item.id, to_str(item.ident));\n             match copy item.node {\n               ast::item_mod(m) => {"}, {"sha": "e9b25b07de15bdb5c25f65300411e9cbdcdb0a72", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -55,23 +55,23 @@ impl<T: Clone> Fold<T>: Clone {\n     }\n }\n \n-type FoldDoc<T> = fn~(fold: &Fold<T>, doc: doc::Doc) -> doc::Doc;\n-type FoldCrate<T> = fn~(fold: &Fold<T>, doc: doc::CrateDoc) -> doc::CrateDoc;\n-type FoldItem<T> = fn~(fold: &Fold<T>, doc: doc::ItemDoc) -> doc::ItemDoc;\n-type FoldMod<T> = fn~(fold: &Fold<T>, doc: doc::ModDoc) -> doc::ModDoc;\n-type FoldNmod<T> = fn~(fold: &Fold<T>, doc: doc::NmodDoc) -> doc::NmodDoc;\n-type FoldFn<T> = fn~(fold: &Fold<T>, doc: doc::FnDoc) -> doc::FnDoc;\n-type FoldConst<T> = fn~(fold: &Fold<T>, doc: doc::ConstDoc) -> doc::ConstDoc;\n-type FoldEnum<T> = fn~(fold: &Fold<T>, doc: doc::EnumDoc) -> doc::EnumDoc;\n-type FoldTrait<T> = fn~(fold: &Fold<T>, doc: doc::TraitDoc) -> doc::TraitDoc;\n-type FoldImpl<T> = fn~(fold: &Fold<T>, doc: doc::ImplDoc) -> doc::ImplDoc;\n-type FoldType<T> = fn~(fold: &Fold<T>, doc: doc::TyDoc) -> doc::TyDoc;\n-type FoldStruct<T> = fn~(fold: &Fold<T>,\n+type FoldDoc<T> = @fn(fold: &Fold<T>, doc: doc::Doc) -> doc::Doc;\n+type FoldCrate<T> = @fn(fold: &Fold<T>, doc: doc::CrateDoc) -> doc::CrateDoc;\n+type FoldItem<T> = @fn(fold: &Fold<T>, doc: doc::ItemDoc) -> doc::ItemDoc;\n+type FoldMod<T> = @fn(fold: &Fold<T>, doc: doc::ModDoc) -> doc::ModDoc;\n+type FoldNmod<T> = @fn(fold: &Fold<T>, doc: doc::NmodDoc) -> doc::NmodDoc;\n+type FoldFn<T> = @fn(fold: &Fold<T>, doc: doc::FnDoc) -> doc::FnDoc;\n+type FoldConst<T> = @fn(fold: &Fold<T>, doc: doc::ConstDoc) -> doc::ConstDoc;\n+type FoldEnum<T> = @fn(fold: &Fold<T>, doc: doc::EnumDoc) -> doc::EnumDoc;\n+type FoldTrait<T> = @fn(fold: &Fold<T>, doc: doc::TraitDoc) -> doc::TraitDoc;\n+type FoldImpl<T> = @fn(fold: &Fold<T>, doc: doc::ImplDoc) -> doc::ImplDoc;\n+type FoldType<T> = @fn(fold: &Fold<T>, doc: doc::TyDoc) -> doc::TyDoc;\n+type FoldStruct<T> = @fn(fold: &Fold<T>,\n                          doc: doc::StructDoc) -> doc::StructDoc;\n \n // This exists because fn types don't infer correctly as record\n // initializers, but they do as function arguments\n-fn mk_fold<T:Clone>(\n+fn mk_fold<T>(\n     ctxt: T,\n     fold_doc: FoldDoc<T>,\n     fold_crate: FoldCrate<T>,\n@@ -103,7 +103,7 @@ fn mk_fold<T:Clone>(\n     }\n }\n \n-pub fn default_any_fold<T:Owned Clone>(ctxt: T) -> Fold<T> {\n+pub fn default_any_fold<T: Clone>(ctxt: T) -> Fold<T> {\n     mk_fold(\n         move ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -121,7 +121,7 @@ pub fn default_any_fold<T:Owned Clone>(ctxt: T) -> Fold<T> {\n     )\n }\n \n-pub fn default_seq_fold<T:Clone>(ctxt: T) -> Fold<T> {\n+pub fn default_seq_fold<T: Clone>(ctxt: T) -> Fold<T> {\n     mk_fold(\n         move ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -139,7 +139,7 @@ pub fn default_seq_fold<T:Clone>(ctxt: T) -> Fold<T> {\n     )\n }\n \n-pub fn default_par_fold<T:Owned Clone>(ctxt: T) -> Fold<T> {\n+pub fn default_par_fold<T: Clone>(ctxt: T) -> Fold<T> {\n     mk_fold(\n         move ctxt,\n         |f, d| default_seq_fold_doc(f, d),\n@@ -189,7 +189,7 @@ pub fn default_seq_fold_item<T>(\n     doc\n }\n \n-pub fn default_any_fold_mod<T:Owned Clone>(\n+pub fn default_any_fold_mod<T:Clone>(\n     fold: &Fold<T>,\n     doc: doc::ModDoc\n ) -> doc::ModDoc {\n@@ -215,7 +215,7 @@ pub fn default_seq_fold_mod<T>(\n     }\n }\n \n-pub fn default_par_fold_mod<T:Owned Clone>(\n+pub fn default_par_fold_mod<T:Clone>(\n     fold: &Fold<T>,\n     doc: doc::ModDoc\n ) -> doc::ModDoc {\n@@ -228,7 +228,7 @@ pub fn default_par_fold_mod<T:Owned Clone>(\n     }\n }\n \n-pub fn default_any_fold_nmod<T:Owned Clone>(\n+pub fn default_any_fold_nmod<T:Clone>(\n     fold: &Fold<T>,\n     doc: doc::NmodDoc\n ) -> doc::NmodDoc {\n@@ -254,7 +254,7 @@ pub fn default_seq_fold_nmod<T>(\n     }\n }\n \n-pub fn default_par_fold_nmod<T:Owned Clone>(\n+pub fn default_par_fold_nmod<T:Clone>(\n     fold: &Fold<T>,\n     doc: doc::NmodDoc\n ) -> doc::NmodDoc {"}, {"sha": "42a7d0006db09f4ebcdd786e759a17ef4d63ee46", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -28,9 +28,7 @@ use std::par;\n pub fn mk_pass(config: config::Config) -> Pass {\n     Pass {\n         name: ~\"markdown_index\",\n-        f: fn~(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n-            run(srv, doc, copy config)\n-        }\n+        f: |srv, doc| run(srv, doc, copy config)\n     }\n }\n \n@@ -78,7 +76,7 @@ fn build_mod_index(\n     config: config::Config\n ) -> doc::Index {\n     doc::Index {\n-        entries: par::map(doc.items, |doc| {\n+        entries: doc.items.map(|doc| {\n             item_to_entry(copy *doc, copy config)\n         })\n     }\n@@ -89,7 +87,7 @@ fn build_nmod_index(\n     config: config::Config\n ) -> doc::Index {\n     doc::Index {\n-        entries: par::map(doc.fns, |doc| {\n+        entries: doc.fns.map(|doc| {\n             item_to_entry(doc::FnTag(copy *doc), copy config)\n         })\n     }"}, {"sha": "161642a2f3d974e4ba53b6247c27683e34c8da4b", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -43,14 +43,9 @@ use syntax;\n \n pub fn mk_pass(writer_factory: WriterFactory) -> Pass {\n     let writer_factory = Cell(writer_factory);\n-    let f = fn~(move writer_factory,\n-                srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n-        run(srv, doc, writer_factory.take())\n-    };\n-\n     Pass {\n         name: ~\"markdown\",\n-        f: move f\n+        f: |srv, doc| run(srv, doc, writer_factory.take())\n     }\n }\n "}, {"sha": "08abe4b351b6f1008beefaebce8f451efa4d6d73", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -36,9 +36,7 @@ use syntax::ast;\n pub fn mk_pass(output_style: config::OutputStyle) -> Pass {\n     Pass {\n         name: ~\"page\",\n-        f: fn~(srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n-            run(srv, doc, output_style)\n-        }\n+        f: |srv, doc| run(srv, doc, output_style)\n     }\n }\n "}, {"sha": "e78c7d54019fc5a1bce1c2c10530e0c46482901a", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -20,7 +20,7 @@ use core::vec;\n /// A single operation on the document model\n pub struct Pass {\n     name: ~str,\n-    f: fn~(srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc\n+    f: @fn(srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc\n }\n \n pub fn run_passes("}, {"sha": "97258d99ba493ecdeeb497932e8af4ad08292bc1", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -56,7 +56,7 @@ fn is_hidden(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n \n     let id = doc.id;\n     do astsrv::exec(srv) |ctxt| {\n-        let attrs = match ctxt.ast_map.get(id) {\n+        let attrs = match ctxt.ast_map.get(&id) {\n           ast_map::node_item(item, _) => copy item.attrs,\n           _ => ~[]\n         };"}, {"sha": "1acb6092e2c7c0288417c224704ff40e08efb3bf", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -59,7 +59,7 @@ fn is_visible(srv: astsrv::Srv, doc: doc::ItemDoc) -> bool {\n     let id = doc.id;\n \n     do astsrv::exec(srv) |ctxt| {\n-        match ctxt.ast_map.get(id) {\n+        match ctxt.ast_map.get(&id) {\n             ast_map::node_item(item, _) => {\n                 item.vis == ast::public\n             }"}, {"sha": "205fc0aa86decc599fe64d3fd8ae0b98c1182ed2", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -57,7 +57,7 @@ fn fold_trait(fold: &fold::Fold<()>, doc: doc::TraitDoc) -> doc::TraitDoc {\n     let doc = fold::default_seq_fold_trait(fold, doc);\n \n     doc::TraitDoc {\n-        methods: do par::map(doc.methods) |method| {\n+        methods: do doc.methods.map |method| {\n             let (desc, sections) = sectionalize(copy method.desc);\n \n             doc::MethodDoc {\n@@ -74,7 +74,7 @@ fn fold_impl(fold: &fold::Fold<()>, doc: doc::ImplDoc) -> doc::ImplDoc {\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n     doc::ImplDoc {\n-        methods: do par::map(doc.methods) |method| {\n+        methods: do doc.methods.map |method| {\n             let (desc, sections) = sectionalize(copy method.desc);\n \n             doc::MethodDoc {"}, {"sha": "b7614a785c74205c19aa3dd8218857e639b27787", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -23,16 +23,14 @@ use util::NominalOp;\n \n use std::sort;\n \n-pub type ItemLtEqOp = pure fn~(v1: &doc::ItemTag, v2:  &doc::ItemTag) -> bool;\n+pub type ItemLtEqOp = @pure fn(v1: &doc::ItemTag, v2:  &doc::ItemTag) -> bool;\n \n type ItemLtEq = NominalOp<ItemLtEqOp>;\n \n pub fn mk_pass(name: ~str, lteq: ItemLtEqOp) -> Pass {\n     Pass {\n         name: copy name,\n-        f: fn~(move lteq, srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n-            run(srv, doc, NominalOp { op: copy lteq })\n-        }\n+        f: |srv, doc| run(srv, doc, NominalOp { op: lteq })\n     }\n }\n "}, {"sha": "79ba8f0684a5852d476508af508a0fab89d66822", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -23,17 +23,17 @@ use util::NominalOp;\n use std::par;\n use std::cell::Cell;\n \n-pub fn mk_pass(name: ~str, op: fn~(&str) -> ~str) -> Pass {\n+pub fn mk_pass(name: ~str, op: @fn(&str) -> ~str) -> Pass {\n     let op = Cell(op);\n     Pass {\n         name: copy name,\n-        f: fn~(move op, srv: astsrv::Srv, doc: doc::Doc) -> doc::Doc {\n+        f: |srv: astsrv::Srv, doc: doc::Doc| -> doc::Doc {\n             run(srv, doc, op.take())\n         }\n     }\n }\n \n-type Op = fn~(&str) -> ~str;\n+type Op = @fn(&str) -> ~str;\n \n #[allow(non_implicitly_copyable_typarams)]\n fn run(\n@@ -76,7 +76,7 @@ fn apply_to_sections(\n     op: NominalOp<Op>,\n     sections: ~[doc::Section]\n ) -> ~[doc::Section] {\n-    par::map(sections, |section, copy op| doc::Section {\n+    sections.map(|section, copy op| doc::Section {\n         header: (op.op)(copy section.header),\n         body: (op.op)(copy section.body)\n     })\n@@ -89,7 +89,7 @@ fn fold_enum(\n     let fold_copy = copy *fold;\n \n     doc::EnumDoc {\n-        variants: do par::map(doc.variants) |variant, copy fold_copy| {\n+        variants: do doc.variants.map |variant, copy fold_copy| {\n             doc::VariantDoc {\n                 desc: maybe_apply_op(copy fold_copy.ctxt, &variant.desc),\n                 .. copy *variant\n@@ -116,7 +116,7 @@ fn apply_to_methods(\n     docs: ~[doc::MethodDoc]\n ) -> ~[doc::MethodDoc] {\n     let op = copy op;\n-    do par::map(docs) |doc| {\n+    do docs.map |doc| {\n         doc::MethodDoc {\n             brief: maybe_apply_op(copy op, &doc.brief),\n             desc: maybe_apply_op(copy op, &doc.desc),"}, {"sha": "58a2e0e13246e1d38af3851f537d959caf6d1d36", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -68,7 +68,7 @@ fn fold_fn(\n \n fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n     do astsrv::exec(srv) |ctxt| {\n-        match ctxt.ast_map.get(fn_id) {\n+        match ctxt.ast_map.get(&fn_id) {\n           ast_map::node_item(@ast::item {\n             ident: ident,\n             node: ast::item_fn(ref decl, _, ref tys, _), _\n@@ -107,7 +107,7 @@ fn fold_const(\n         sig: Some({\n             let doc = copy doc;\n             do astsrv::exec(srv) |ctxt| {\n-                match ctxt.ast_map.get(doc.id()) {\n+                match ctxt.ast_map.get(&doc.id()) {\n                     ast_map::node_item(@ast::item {\n                         node: ast::item_const(ty, _), _\n                     }, _) => {\n@@ -138,7 +138,7 @@ fn fold_enum(\n             let sig = {\n                 let variant = copy *variant;\n                 do astsrv::exec(srv.clone()) |copy variant, ctxt| {\n-                    match ctxt.ast_map.get(doc_id) {\n+                    match ctxt.ast_map.get(&doc_id) {\n                         ast_map::node_item(@ast::item {\n                             node: ast::item_enum(ref enum_definition, _), _\n                         }, _) => {\n@@ -199,7 +199,7 @@ fn get_method_sig(\n     method_name: ~str\n ) -> Option<~str> {\n     do astsrv::exec(srv) |copy method_name, ctxt| {\n-        match ctxt.ast_map.get(item_id) {\n+        match ctxt.ast_map.get(&item_id) {\n           ast_map::node_item(@ast::item {\n             node: ast::item_trait(_, _, ref methods), _\n           }, _) => {\n@@ -271,7 +271,7 @@ fn fold_impl(\n     let (trait_types, self_ty) = {\n         let doc = copy doc;\n         do astsrv::exec(srv) |ctxt| {\n-            match ctxt.ast_map.get(doc.id()) {\n+            match ctxt.ast_map.get(&doc.id()) {\n                 ast_map::node_item(@ast::item {\n                     node: ast::item_impl(_, opt_trait_type, self_ty, _), _\n                 }, _) => {\n@@ -331,7 +331,7 @@ fn fold_type(\n         sig: {\n             let doc = copy doc;\n             do astsrv::exec(srv) |ctxt| {\n-                match ctxt.ast_map.get(doc.id()) {\n+                match ctxt.ast_map.get(&doc.id()) {\n                     ast_map::node_item(@ast::item {\n                         ident: ident,\n                         node: ast::item_ty(ty, ref params), _\n@@ -369,7 +369,7 @@ fn fold_struct(\n         sig: {\n             let doc = copy doc;\n             do astsrv::exec(srv) |ctxt| {\n-                match ctxt.ast_map.get(doc.id()) {\n+                match ctxt.ast_map.get(&doc.id()) {\n                     ast_map::node_item(item, _) => {\n                         let item = strip_struct_extra_stuff(item);\n                         Some(pprust::item_to_str(item,"}, {"sha": "fa8c2dd93c0381b99a3fabe6fe9389202d273cbd", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -80,7 +80,7 @@ fn unindent(s: &str) -> ~str {\n \n     if !lines.is_empty() {\n         let unindented = ~[str::trim(vec::head(lines))]\n-            + do par::map(vec::tail(lines)) |line| {\n+            + do vec::tail(lines).map |line| {\n             if str::is_whitespace(*line) {\n                 copy *line\n             } else {"}, {"sha": "a1fd7a66f7ec81f6696cbea8dcd7dfa390fd8dff", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n /**\n  * Concurrency-enabled mechanisms for sharing mutable and/or immutable state\n  * between tasks."}, {"sha": "a2cbe27ea9045407d08b5b894f1375ab41aa66f4", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -32,8 +32,6 @@\n // overhead when initializing plain-old-data and means we don't need\n // to waste time running the destructors of POD.\n \n-#[forbid(deprecated_mode)];\n-\n use arena;\n use list;\n use list::{List, Cons, Nil};"}, {"sha": "d9e121798f183f37abda3b8b65f9b8d823af53b8", "filename": "src/libstd/base64.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbase64.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use core::io::Reader;\n use core::iter;\n use core::str;"}, {"sha": "a94c4f790641d093e3108ea9f9fdf7d1df8b5bbb", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use core::ops;\n use core::prelude::*;\n use core::uint;\n@@ -156,7 +154,7 @@ impl BigBitv {\n      fn each_storage(op: fn(v: &mut uint) -> bool) {\n         for uint::range(0, self.storage.len()) |i| {\n             let mut w = self.storage[i];\n-            let b = !op(&mut w);\n+            let b = op(&mut w);\n             self.storage[i] = w;\n             if !b { break; }\n         }\n@@ -981,6 +979,24 @@ mod tests {\n       assert !b1[40];\n       assert !b1[80];\n     }\n+\n+    #[test]\n+    pub fn test_small_clear() {\n+      let b = Bitv(14, true);\n+      b.clear();\n+      for b.ones |i| {\n+          die!(fmt!(\"found 1 at %?\", i));\n+      }\n+    }\n+\n+    #[test]\n+    pub fn test_big_clear() {\n+      let b = Bitv(140, true);\n+      b.clear();\n+      for b.ones |i| {\n+          die!(fmt!(\"found 1 at %?\", i));\n+      }\n+    }\n }\n \n //"}, {"sha": "5ea5418d9882e66c7c968ba6789b3b493191dd7d", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -35,7 +35,6 @@\n  * great care must be taken to ensure that a reference to the c_vec::t is\n  * still held if needed.\n  */\n-#[forbid(deprecated_mode)];\n \n use core::libc;\n use core::option;\n@@ -46,11 +45,11 @@ use core::task;\n /**\n  * The type representing a foreign chunk of memory\n  *\n- * Wrapped in a enum for opacity; FIXME #818 when it is possible to have\n- * truly opaque types, this should be revisited.\n  */\n-pub enum CVec<T> {\n-    CVecCtor({ base: *mut T, len: uint, rsrc: @DtorRes})\n+pub struct CVec<T> {\n+    priv base: *mut T,\n+    priv len: uint,\n+    priv rsrc: @DtorRes\n }\n \n struct DtorRes {\n@@ -85,11 +84,11 @@ fn DtorRes(dtor: Option<fn@()>) -> DtorRes {\n  * * len - The number of elements in the buffer\n  */\n pub unsafe fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n-    return CVecCtor({\n+    return CVec{\n         base: base,\n         len: len,\n         rsrc: @DtorRes(option::None)\n-    });\n+    };\n }\n \n /**\n@@ -105,11 +104,11 @@ pub unsafe fn CVec<T>(base: *mut T, len: uint) -> CVec<T> {\n  */\n pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: fn@())\n   -> CVec<T> {\n-    return CVecCtor({\n+    return CVec{\n         base: base,\n         len: len,\n         rsrc: @DtorRes(option::Some(dtor))\n-    });\n+    };\n }\n \n /*\n@@ -123,7 +122,7 @@ pub unsafe fn c_vec_with_dtor<T>(base: *mut T, len: uint, dtor: fn@())\n  */\n pub fn get<T: Copy>(t: CVec<T>, ofs: uint) -> T {\n     assert ofs < len(t);\n-    return unsafe { *ptr::mut_offset((*t).base, ofs) };\n+    return unsafe { *ptr::mut_offset(t.base, ofs) };\n }\n \n /**\n@@ -133,22 +132,18 @@ pub fn get<T: Copy>(t: CVec<T>, ofs: uint) -> T {\n  */\n pub fn set<T: Copy>(t: CVec<T>, ofs: uint, v: T) {\n     assert ofs < len(t);\n-    unsafe { *ptr::mut_offset((*t).base, ofs) = v };\n+    unsafe { *ptr::mut_offset(t.base, ofs) = v };\n }\n \n /*\n  Section: Elimination forms\n  */\n \n /// Returns the length of the vector\n-pub pure fn len<T>(t: CVec<T>) -> uint {\n-    return (*t).len;\n-}\n+pub pure fn len<T>(t: CVec<T>) -> uint { t.len }\n \n /// Returns a pointer to the first element of the vector\n-pub unsafe fn ptr<T>(t: CVec<T>) -> *mut T {\n-    return (*t).base;\n-}\n+pub unsafe fn ptr<T>(t: CVec<T>) -> *mut T { t.base }\n \n #[cfg(test)]\n mod tests {"}, {"sha": "10a896a40896f57d21e7be91370195c017783a45", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use core::option;\n use core::prelude::*;\n "}, {"sha": "110559ddcefe0fb4fe568aec74c4d7277b743260", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n //! Additional general-purpose comparison functionality.\n \n use core::f32;"}, {"sha": "71eb29e26eba750c466d52c645d21508867b14e3", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -14,22 +14,12 @@ Higher level communication abstractions.\n \n */\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n-\n use core::pipes::{GenericChan, GenericSmartChan, GenericPort};\n use core::pipes::{Chan, Port, Selectable, Peekable};\n use core::pipes;\n use core::prelude::*;\n \n /// An extension of `pipes::stream` that allows both sending and receiving.\n-#[cfg(stage0)]\n-pub struct DuplexStream<T:Owned, U:Owned> {\n-    priv chan: Chan<T>,\n-    priv port: Port<U>,\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n pub struct DuplexStream<T, U> {\n     priv chan: Chan<T>,\n     priv port: Port<U>,"}, {"sha": "7813357caf228d9ccb476ebaa9ce8cf4d9549436", "filename": "src/libstd/dbg.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdbg.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n //! Unsafe debugging functions for inspecting values.\n \n use core::cast::reinterpret_cast;"}, {"sha": "465c5d8f8feea36b9bb80e9f1fd3a358eb6bfc48", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! A deque. Untested as of yet. Likely buggy\n-#[forbid(deprecated_mode)];\n #[forbid(non_camel_case_types)];\n \n use core::cmp::Eq;"}, {"sha": "768d2dbf2d4ba640c2b6a01ff4d91d0281dc70b2", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use serialize;\n \n use core::io;\n@@ -84,22 +82,27 @@ pub mod reader {\n         }\n     }\n \n-    fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n+    struct Res {\n+        val: uint,\n+        next: uint\n+    }\n+\n+    fn vuint_at(data: &[u8], start: uint) -> Res {\n         let a = data[start];\n         if a & 0x80u8 != 0u8 {\n-            return {val: (a & 0x7fu8) as uint, next: start + 1u};\n+            return Res {val: (a & 0x7fu8) as uint, next: start + 1u};\n         }\n         if a & 0x40u8 != 0u8 {\n-            return {val: ((a & 0x3fu8) as uint) << 8u |\n+            return Res {val: ((a & 0x3fu8) as uint) << 8u |\n                         (data[start + 1u] as uint),\n                     next: start + 2u};\n         } else if a & 0x20u8 != 0u8 {\n-            return {val: ((a & 0x1fu8) as uint) << 16u |\n+            return Res {val: ((a & 0x1fu8) as uint) << 16u |\n                         (data[start + 1u] as uint) << 8u |\n                         (data[start + 2u] as uint),\n                     next: start + 3u};\n         } else if a & 0x10u8 != 0u8 {\n-            return {val: ((a & 0x0fu8) as uint) << 24u |\n+            return Res {val: ((a & 0x0fu8) as uint) << 24u |\n                         (data[start + 1u] as uint) << 16u |\n                         (data[start + 2u] as uint) << 8u |\n                         (data[start + 3u] as uint),"}, {"sha": "d6c2cf5a265eedadc3e69a8d91103c11e9290afc", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n /*!\n  * A functional key,value store that works on anything.\n  *"}, {"sha": "e34574a2e15b43549156f22aaf2c2ad6d32dd0c4", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -74,7 +74,6 @@\n  *        do_work(input, output);\n  *    }\n  */\n-#[forbid(deprecated_mode)];\n \n use core::cmp::Eq;\n use core::prelude::*;"}, {"sha": "99c6c2f008dd65c708fa6b3780c8b99a75957523", "filename": "src/libstd/json.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,7 +10,6 @@\n \n // Rust JSON serialization library\n // Copyright (c) 2011 Google Inc.\n-#[forbid(deprecated_mode)];\n #[forbid(non_camel_case_types)];\n \n //! json serialization\n@@ -856,9 +855,6 @@ pub impl Decoder: serialize::Decoder {\n         debug!(\"read_vec_elt(idx=%u)\", idx);\n         match *self.peek() {\n             List(ref list) => {\n-                // FIXME(#3148)---should be inferred\n-                let list: &self/~[Json] = list;\n-\n                 self.stack.push(&list[idx]);\n                 f()\n             }\n@@ -885,9 +881,6 @@ pub impl Decoder: serialize::Decoder {\n         let top = self.peek();\n         match *top {\n             Object(ref obj) => {\n-                // FIXME(#3148) This hint should not be necessary.\n-                let obj: &self/~Object = obj;\n-\n                 match obj.find(&name.to_owned()) {\n                     None => die!(fmt!(\"no such field: %s\", name)),\n                     Some(json) => {\n@@ -917,8 +910,6 @@ pub impl Decoder: serialize::Decoder {\n         debug!(\"read_tup_elt(idx=%u)\", idx);\n         match *self.peek() {\n             List(ref list) => {\n-                // FIXME(#3148)---should be inferred\n-                let list: &self/~[Json] = list;\n                 self.stack.push(&list[idx]);\n                 f()\n             }"}, {"sha": "140c2013738de6acecd26842035d8ccbf4c46d14", "filename": "src/libstd/list.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! A standard linked list\n-#[forbid(deprecated_mode)];\n \n use core::cmp::Eq;\n use core::option;"}, {"sha": "1d831af0e292aa9e727b70b21e108d4a8d8618c7", "filename": "src/libstd/md4.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmd4.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,13 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use core::str;\n use core::uint;\n use core::vec;\n \n-pub pure fn md4(msg: &[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n+struct Quad {\n+    a: u32,\n+    b: u32,\n+    c: u32,\n+    d: u32\n+}\n+\n+pub pure fn md4(msg: &[u8]) -> Quad {\n     // subtle: if orig_len is merely uint, then the code below\n     // which performs shifts by 32 bits or more has undefined\n     // results.\n@@ -95,11 +100,11 @@ pub pure fn md4(msg: &[u8]) -> {a: u32, b: u32, c: u32, d: u32} {\n         a += aa; b += bb; c += cc; d += dd;\n         i += 64u;\n     }\n-    return {a: a, b: b, c: c, d: d};\n+    return Quad {a: a, b: b, c: c, d: d};\n }\n \n pub pure fn md4_str(msg: &[u8]) -> ~str {\n-    let {a, b, c, d} = md4(msg);\n+    let Quad {a, b, c, d} = md4(msg);\n     pure fn app(a: u32, b: u32, c: u32, d: u32, f: fn(u32)) {\n         f(a); f(b); f(c); f(d);\n     }"}, {"sha": "511e80b0160f6823f357a1022f42162cb20c976d", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! Types/fns concerning Internet Protocol (IP), versions 4 & 6\n-#[forbid(deprecated_mode)];\n \n use core::libc;\n use core::prelude::*;"}, {"sha": "c90518f1692b1d8e130315db0cbe08cd98f10fcc", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,6 +10,7 @@\n \n //! High-level interface to libuv's TCP functionality\n // FIXME #4425: Need FFI fixes\n+\n #[allow(deprecated_mode)];\n \n use future;"}, {"sha": "9403438dde0ead2b308d2930292fac3d0b06a37a", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n //! Types/fns concerning URLs (see RFC 3986)\n-#[forbid(deprecated_mode)];\n+\n+#[allow(deprecated_mode)];\n \n use core::cmp::Eq;\n use core::dvec::DVec;"}, {"sha": "ad7e8e50e38f09ecc6086fb38e8ec0d16cefd4ff", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 52, "deletions": 54, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! A map type - **deprecated**, use `core::hashmap` instead\n-#[forbid(deprecated_mode)];\n \n use core::container::{Container, Mutable, Map};\n use core::cmp::Eq;\n@@ -226,9 +225,9 @@ pub mod chained {\n             }\n         }\n \n-        pure fn find(&self, k: K) -> Option<V> {\n+        pure fn find(&self, k: &K) -> Option<V> {\n             unsafe {\n-                match self.search_tbl(&k, k.hash_keyed(0,0) as uint) {\n+                match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n                   NotFound => None,\n                   FoundFirst(_, entry) => Some(entry.value),\n                   FoundAfter(_, entry) => Some(entry.value)\n@@ -291,7 +290,7 @@ pub mod chained {\n             return self.update_with_key(key, newval, |_k, v, v1| ff(v,v1));\n         }\n \n-        pure fn get(&self, k: K) -> V {\n+        pure fn get(&self, k: &K) -> V {\n             let opt_v = self.find(k);\n             if opt_v.is_none() {\n                 die!(fmt!(\"Key not found in table: %?\", k));\n@@ -364,7 +363,7 @@ pub mod chained {\n     impl<K:Eq IterBytes Hash Copy, V: Copy> T<K, V>: ops::Index<K, V> {\n         pure fn index(&self, k: K) -> V {\n             unsafe {\n-                self.get(k)\n+                self.get(&k)\n             }\n         }\n     }\n@@ -421,7 +420,6 @@ pub fn hash_from_vec<K: Eq IterBytes Hash Const Copy, V: Copy>(\n #[cfg(test)]\n mod tests {\n     use core::option::None;\n-    use core::option;\n     use core::uint;\n \n     use super::*;\n@@ -437,13 +435,13 @@ mod tests {\n         assert (hm_uu.insert(10u, 12u));\n         assert (hm_uu.insert(11u, 13u));\n         assert (hm_uu.insert(12u, 14u));\n-        assert (hm_uu.get(11u) == 13u);\n-        assert (hm_uu.get(12u) == 14u);\n-        assert (hm_uu.get(10u) == 12u);\n+        assert (hm_uu.get(&11) == 13u);\n+        assert (hm_uu.get(&12) == 14u);\n+        assert (hm_uu.get(&10) == 12u);\n         assert (!hm_uu.insert(12u, 14u));\n-        assert (hm_uu.get(12u) == 14u);\n+        assert (hm_uu.get(&12) == 14u);\n         assert (!hm_uu.insert(12u, 12u));\n-        assert (hm_uu.get(12u) == 12u);\n+        assert (hm_uu.get(&12) == 12u);\n         let ten: ~str = ~\"ten\";\n         let eleven: ~str = ~\"eleven\";\n         let twelve: ~str = ~\"twelve\";\n@@ -453,40 +451,40 @@ mod tests {\n         assert (hm_su.insert(~\"ten\", 12u));\n         assert (hm_su.insert(eleven, 13u));\n         assert (hm_su.insert(~\"twelve\", 14u));\n-        assert (hm_su.get(eleven) == 13u);\n-        assert (hm_su.get(~\"eleven\") == 13u);\n-        assert (hm_su.get(~\"twelve\") == 14u);\n-        assert (hm_su.get(~\"ten\") == 12u);\n+        assert (hm_su.get(&eleven) == 13u);\n+        assert (hm_su.get(&~\"eleven\") == 13u);\n+        assert (hm_su.get(&~\"twelve\") == 14u);\n+        assert (hm_su.get(&~\"ten\") == 12u);\n         assert (!hm_su.insert(~\"twelve\", 14u));\n-        assert (hm_su.get(~\"twelve\") == 14u);\n+        assert (hm_su.get(&~\"twelve\") == 14u);\n         assert (!hm_su.insert(~\"twelve\", 12u));\n-        assert (hm_su.get(~\"twelve\") == 12u);\n+        assert (hm_su.get(&~\"twelve\") == 12u);\n         debug!(\"uint -> str\");\n         let hm_us: HashMap<uint, ~str> =\n             HashMap::<uint, ~str>();\n         assert (hm_us.insert(10u, ~\"twelve\"));\n         assert (hm_us.insert(11u, ~\"thirteen\"));\n         assert (hm_us.insert(12u, ~\"fourteen\"));\n-        assert hm_us.get(11u) == ~\"thirteen\";\n-        assert hm_us.get(12u) == ~\"fourteen\";\n-        assert hm_us.get(10u) == ~\"twelve\";\n+        assert hm_us.get(&11) == ~\"thirteen\";\n+        assert hm_us.get(&12) == ~\"fourteen\";\n+        assert hm_us.get(&10) == ~\"twelve\";\n         assert (!hm_us.insert(12u, ~\"fourteen\"));\n-        assert hm_us.get(12u) == ~\"fourteen\";\n+        assert hm_us.get(&12) == ~\"fourteen\";\n         assert (!hm_us.insert(12u, ~\"twelve\"));\n-        assert hm_us.get(12u) == ~\"twelve\";\n+        assert hm_us.get(&12) == ~\"twelve\";\n         debug!(\"str -> str\");\n         let hm_ss: HashMap<~str, ~str> =\n             HashMap::<~str, ~str>();\n         assert (hm_ss.insert(ten, ~\"twelve\"));\n         assert (hm_ss.insert(eleven, ~\"thirteen\"));\n         assert (hm_ss.insert(twelve, ~\"fourteen\"));\n-        assert hm_ss.get(~\"eleven\") == ~\"thirteen\";\n-        assert hm_ss.get(~\"twelve\") == ~\"fourteen\";\n-        assert hm_ss.get(~\"ten\") == ~\"twelve\";\n+        assert hm_ss.get(&~\"eleven\") == ~\"thirteen\";\n+        assert hm_ss.get(&~\"twelve\") == ~\"fourteen\";\n+        assert hm_ss.get(&~\"ten\") == ~\"twelve\";\n         assert (!hm_ss.insert(~\"twelve\", ~\"fourteen\"));\n-        assert hm_ss.get(~\"twelve\") == ~\"fourteen\";\n+        assert hm_ss.get(&~\"twelve\") == ~\"fourteen\";\n         assert (!hm_ss.insert(~\"twelve\", ~\"twelve\"));\n-        assert hm_ss.get(~\"twelve\") == ~\"twelve\";\n+        assert hm_ss.get(&~\"twelve\") == ~\"twelve\";\n         debug!(\"*** finished test_simple\");\n     }\n \n@@ -512,17 +510,17 @@ mod tests {\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm_uu.get(i));\n-            assert (hm_uu.get(i) == i * i);\n+            debug!(\"get(%u) = %u\", i, hm_uu.get(&i));\n+            assert (hm_uu.get(&i) == i * i);\n             i += 1u;\n         }\n         assert (hm_uu.insert(num_to_insert, 17u));\n-        assert (hm_uu.get(num_to_insert) == 17u);\n+        assert (hm_uu.get(&num_to_insert) == 17u);\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm_uu.get(i));\n-            assert (hm_uu.get(i) == i * i);\n+            debug!(\"get(%u) = %u\", i, hm_uu.get(&i));\n+            assert (hm_uu.get(&i) == i * i);\n             i += 1u;\n         }\n         debug!(\"str -> str\");\n@@ -542,22 +540,22 @@ mod tests {\n         while i < num_to_insert {\n             debug!(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n                    uint::to_str_radix(i, 2u),\n-                   hm_ss.get(uint::to_str_radix(i, 2u)));\n-            assert hm_ss.get(uint::to_str_radix(i, 2u)) ==\n+                   hm_ss.get(&uint::to_str_radix(i, 2u)));\n+            assert hm_ss.get(&uint::to_str_radix(i, 2u)) ==\n                              uint::to_str_radix(i * i, 2u);\n             i += 1u;\n         }\n         assert (hm_ss.insert(uint::to_str_radix(num_to_insert, 2u),\n                              uint::to_str_radix(17u, 2u)));\n-        assert hm_ss.get(uint::to_str_radix(num_to_insert, 2u)) ==\n+        assert hm_ss.get(&uint::to_str_radix(num_to_insert, 2u)) ==\n             uint::to_str_radix(17u, 2u);\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n             debug!(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n                    uint::to_str_radix(i, 2u),\n-                   hm_ss.get(uint::to_str_radix(i, 2u)));\n-            assert hm_ss.get(uint::to_str_radix(i, 2u)) ==\n+                   hm_ss.get(&uint::to_str_radix(i, 2u)));\n+            assert hm_ss.get(&uint::to_str_radix(i, 2u)) ==\n                              uint::to_str_radix(i * i, 2u);\n             i += 1u;\n         }\n@@ -589,15 +587,15 @@ mod tests {\n         debug!(\"-----\");\n         i = 1u;\n         while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm.get(i));\n-            assert (hm.get(i) == i * i);\n+            debug!(\"get(%u) = %u\", i, hm.get(&i));\n+            assert (hm.get(&i) == i * i);\n             i += 2u;\n         }\n         debug!(\"-----\");\n         i = 1u;\n         while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm.get(i));\n-            assert (hm.get(i) == i * i);\n+            debug!(\"get(%u) = %u\", i, hm.get(&i));\n+            assert (hm.get(&i) == i * i);\n             i += 2u;\n         }\n         debug!(\"-----\");\n@@ -611,16 +609,16 @@ mod tests {\n         debug!(\"-----\");\n         i = 0u;\n         while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm.get(i));\n-            assert (hm.get(i) == i * i);\n+            debug!(\"get(%u) = %u\", i, hm.get(&i));\n+            assert (hm.get(&i) == i * i);\n             i += 1u;\n         }\n         debug!(\"-----\");\n         assert (hm.len() == num_to_insert);\n         i = 0u;\n         while i < num_to_insert {\n-            debug!(\"get(%u) = %u\", i, hm.get(i));\n-            assert (hm.get(i) == i * i);\n+            debug!(\"get(%u) = %u\", i, hm.get(&i));\n+            assert (hm.get(&i) == i * i);\n             i += 1u;\n         }\n         debug!(\"*** finished test_removal\");\n@@ -639,9 +637,9 @@ mod tests {\n     fn test_find() {\n         let key = ~\"k\";\n         let map = HashMap::<~str, ~str>();\n-        assert (option::is_none(&map.find(key)));\n+        assert map.find(&key).is_none();\n         map.insert(key, ~\"val\");\n-        assert (option::get(map.find(key)) == ~\"val\");\n+        assert map.find(&key).get() == ~\"val\";\n     }\n \n     #[test]\n@@ -664,9 +662,9 @@ mod tests {\n             (~\"c\", 3)\n         ]);\n         assert map.len() == 3u;\n-        assert map.get(~\"a\") == 1;\n-        assert map.get(~\"b\") == 2;\n-        assert map.get(~\"c\") == 3;\n+        assert map.get(&~\"a\") == 1;\n+        assert map.get(&~\"b\") == 2;\n+        assert map.get(&~\"c\") == 3;\n     }\n \n     #[test]\n@@ -692,11 +690,11 @@ mod tests {\n         map.update_with_key(~\"cat\",      2, addMoreToCount);\n \n         // check the total counts\n-        assert 10 == option::get(map.find(~\"cat\"));\n-        assert  3 == option::get(map.find(~\"ferret\"));\n-        assert  1 == option::get(map.find(~\"mongoose\"));\n+        assert map.find(&~\"cat\").get() == 10;\n+        assert map.find(&~\"ferret\").get() == 3;\n+        assert map.find(&~\"mongoose\").get() == 1;\n \n         // sadly, no mythical animals were counted!\n-        assert None == map.find(~\"unicorn\");\n+        assert map.find(&~\"unicorn\").is_none();\n     }\n }"}, {"sha": "8293ff1c2afdf09573d2db3dff05c1b8e53b1e1a", "filename": "src/libstd/par.rs", "status": "modified", "additions": 17, "deletions": 34, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use core::cast;\n use core::prelude::*;\n use core::ptr;\n@@ -38,7 +36,7 @@ const min_granularity : uint = 1024u;\n  */\n fn map_slices<A: Copy Owned, B: Copy Owned>(\n     xs: &[A],\n-    f: fn() -> fn~(uint, v: &[A]) -> B)\n+    f: &fn() -> ~fn(uint, v: &[A]) -> B)\n     -> ~[B] {\n \n     let len = xs.len();\n@@ -93,20 +91,22 @@ fn map_slices<A: Copy Owned, B: Copy Owned>(\n \n /// A parallel version of map.\n pub fn map<A: Copy Owned, B: Copy Owned>(\n-    xs: &[A], f: fn~(&A) -> B) -> ~[B] {\n+    xs: &[A], fn_factory: &fn() -> ~fn(&A) -> B) -> ~[B] {\n     vec::concat(map_slices(xs, || {\n-        let f = copy f;\n+        let f = fn_factory();\n         fn~(_base: uint, slice : &[A]) -> ~[B] {\n             vec::map(slice, |x| f(x))\n         }\n     }))\n }\n \n /// A parallel version of mapi.\n-pub fn mapi<A: Copy Owned, B: Copy Owned>(xs: &[A],\n-                                    f: fn~(uint, &A) -> B) -> ~[B] {\n+pub fn mapi<A: Copy Owned, B: Copy Owned>(\n+    xs: &[A],\n+    fn_factory: &fn() -> ~fn(uint, &A) -> B) -> ~[B]\n+{\n     let slices = map_slices(xs, || {\n-        let f = copy f;\n+        let f = fn_factory();\n         fn~(base: uint, slice : &[A], copy f) -> ~[B] {\n             vec::mapi(slice, |i, x| {\n                 f(i + base, x)\n@@ -119,32 +119,13 @@ pub fn mapi<A: Copy Owned, B: Copy Owned>(xs: &[A],\n     r\n }\n \n-/**\n- * A parallel version of mapi.\n- *\n- * In this case, f is a function that creates functions to run over the\n- * inner elements. This is to skirt the need for copy constructors.\n- */\n-pub fn mapi_factory<A: Copy Owned, B: Copy Owned>(\n-    xs: &[A], f: fn() -> fn~(uint, A) -> B) -> ~[B] {\n-    let slices = map_slices(xs, || {\n-        let f = f();\n-        fn~(base: uint, slice : &[A], move f) -> ~[B] {\n-            vec::mapi(slice, |i, x| {\n-                f(i + base, *x)\n-            })\n-        }\n-    });\n-    let r = vec::concat(slices);\n-    log(info, (r.len(), xs.len()));\n-    assert(r.len() == xs.len());\n-    r\n-}\n-\n /// Returns true if the function holds for all elements in the vector.\n-pub fn alli<A: Copy Owned>(xs: &[A], f: fn~(uint, &A) -> bool) -> bool {\n+pub fn alli<A: Copy Owned>(\n+    xs: &[A],\n+    fn_factory: &fn() -> ~fn(uint, &A) -> bool) -> bool\n+{\n     do vec::all(map_slices(xs, || {\n-        let f = copy f;\n+        let f = fn_factory();\n         fn~(base: uint, slice : &[A], copy f) -> bool {\n             vec::alli(slice, |i, x| {\n                 f(i + base, x)\n@@ -154,9 +135,11 @@ pub fn alli<A: Copy Owned>(xs: &[A], f: fn~(uint, &A) -> bool) -> bool {\n }\n \n /// Returns true if the function holds for any elements in the vector.\n-pub fn any<A: Copy Owned>(xs: &[A], f: fn~(&A) -> bool) -> bool {\n+pub fn any<A: Copy Owned>(\n+    xs: &[A],\n+    fn_factory: &fn() -> ~fn(&A) -> bool) -> bool {\n     do vec::any(map_slices(xs, || {\n-        let f = copy f;\n+        let f = fn_factory();\n         fn~(_base : uint, slice: &[A], copy f) -> bool {\n             vec::any(slice, |x| f(x))\n         }"}, {"sha": "dc2e3d3da2bd40e48736712ad95d85000e91a7ad", "filename": "src/libstd/prettyprint.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fprettyprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fprettyprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use serialize;\n \n use core::io::Writer;"}, {"sha": "30baa3cc5f15ad80d773b8ce391540c79eed8eb0", "filename": "src/libstd/rl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Frl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Frl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frl.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -64,7 +64,7 @@ pub unsafe fn read(prompt: ~str) -> Option<~str> {\n     }\n }\n \n-pub type CompletionCb = fn~(~str, fn(~str));\n+pub type CompletionCb = @fn(~str, fn(~str));\n \n fn complete_key(_v: @CompletionCb) {}\n \n@@ -75,7 +75,7 @@ pub unsafe fn complete(cb: CompletionCb) {\n \n         extern fn callback(line: *c_char, completions: *()) {\n             unsafe {\n-                let cb = copy *task::local_data::local_data_get(complete_key)\n+                let cb = *task::local_data::local_data_get(complete_key)\n                     .get();\n \n                 do cb(str::raw::from_c_str(line)) |suggestion| {"}, {"sha": "f8aef2c5f1e992d01db2f256039e5a97dee59f28", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -33,8 +33,6 @@\n  * * access to a character by index is logarithmic (linear in strings);\n  */\n \n-#[forbid(deprecated_mode)];\n-\n use core::cast;\n use core::char;\n use core::option;"}, {"sha": "972df73d2160949096e1b2d33de2393b3886a436", "filename": "src/libstd/serialize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialize.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -14,7 +14,6 @@\n Core encoding and decoding interfaces.\n */\n \n-#[forbid(deprecated_mode)];\n #[forbid(non_camel_case_types)];\n \n use core::at_vec;"}, {"sha": "6209170ac3d1fa7df396092aa8bbd3f8ba004361", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -22,8 +22,6 @@\n  * the `reset` method.\n  */\n \n-#[forbid(deprecated_mode)];\n-\n use core::str;\n use core::uint;\n use core::vec;\n@@ -66,7 +64,7 @@ const k3: u32 = 0xCA62C1D6u32;\n \n /// Construct a `sha` object\n pub fn sha1() -> Sha1 {\n-    type Sha1State =\n+    struct Sha1State\n         {h: ~[mut u32],\n          mut len_low: u32,\n          mut len_high: u32,\n@@ -258,7 +256,7 @@ pub fn sha1() -> Sha1 {\n             return s;\n         }\n     }\n-    let st = {\n+    let st = Sha1State {\n         h: vec::cast_to_mut(vec::from_elem(digest_buf_len, 0u32)),\n         mut len_low: 0u32,\n         mut len_high: 0u32,"}, {"sha": "9af596eb1f5f88103efca8d96a6722279603cde8", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -12,7 +12,6 @@\n  * A simple map based on a vector for small integer keys. Space requirements\n  * are O(highest integer key).\n  */\n-#[forbid(deprecated_mode)];\n \n use core::container::{Container, Mutable, Map, Set};\n use core::option::{Some, None};\n@@ -116,8 +115,6 @@ pub impl<V> SmallIntMap<V> {\n }\n \n pub impl<V: Copy> SmallIntMap<V> {\n-    // FIXME: #4733, remove after the next snapshot\n-    #[cfg(stage2)]\n     fn update_with_key(&mut self, key: uint, val: V,\n                        ff: fn(uint, V, V) -> V) -> bool {\n         match self.find(&key) {\n@@ -126,8 +123,6 @@ pub impl<V: Copy> SmallIntMap<V> {\n         }\n     }\n \n-    // FIXME: #4733, remove after the next snapshot\n-    #[cfg(stage2)]\n     fn update(&mut self, key: uint, newval: V, ff: fn(V, V) -> V) -> bool {\n         self.update_with_key(key, newval, |_k, v, v1| ff(v,v1))\n     }"}, {"sha": "680a2b99c4a2e10568aa7f89e5b98b047a207580", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! Sorting methods\n-#[forbid(deprecated_mode)];\n \n use core::cmp::{Eq, Ord};\n use core::dvec::DVec;\n@@ -64,14 +63,13 @@ pub pure fn merge_sort<T: Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n     }\n }\n \n-fn part<T: Copy>(arr: &mut [T], left: uint,\n-                right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n-    let pivot_value = arr[pivot];\n+fn part<T>(arr: &mut [T], left: uint,\n+           right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n     arr[pivot] <-> arr[right];\n     let mut storage_index: uint = left;\n     let mut i: uint = left;\n     while i < right {\n-        if compare_func(&arr[i], &pivot_value) {\n+        if compare_func(&arr[i], &arr[right]) {\n             arr[i] <-> arr[storage_index];\n             storage_index += 1;\n         }\n@@ -81,8 +79,8 @@ fn part<T: Copy>(arr: &mut [T], left: uint,\n     return storage_index;\n }\n \n-fn qsort<T: Copy>(arr: &mut [T], left: uint,\n-             right: uint, compare_func: Le<T>) {\n+fn qsort<T>(arr: &mut [T], left: uint,\n+            right: uint, compare_func: Le<T>) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n         let new_pivot = part::<T>(arr, left, right, pivot, compare_func);\n@@ -100,7 +98,7 @@ fn qsort<T: Copy>(arr: &mut [T], left: uint,\n  * Has worst case O(n^2) performance, average case O(n log n).\n  * This is an unstable sort.\n  */\n-pub fn quick_sort<T: Copy>(arr: &mut [T], compare_func: Le<T>) {\n+pub fn quick_sort<T>(arr: &mut [T], compare_func: Le<T>) {\n     if len::<T>(arr) == 0u { return; }\n     qsort::<T>(arr, 0u, len::<T>(arr) - 1u, compare_func);\n }"}, {"sha": "8c142908d106fa43e744aaa9ef56499e98b56a90", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -28,16 +28,8 @@ not required in or otherwise suitable for the core library.\n \n #[allow(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n-// XXX this is set to allow because there are two methods in encoding\n-// that can't be silenced otherwise. Most every module is set to forbid\n-#[allow(deprecated_mode)];\n-#[forbid(deprecated_pattern)];\n #[allow(deprecated_self)];\n \n-\n-// Transitional\n-#[legacy_records];\n-\n #[no_core];\n \n extern mod core(vers = \"0.6\");"}, {"sha": "b7e75897bf1e9e343db67a6664eb7c0ac2d40e7b", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// NB: transitionary, de-mode-ing.\n-#[forbid(deprecated_mode)];\n /**\n  * The concurrency primitives you know and love.\n  *"}, {"sha": "b786d913639cd52fd82f9f2876b0335333fcb223", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,8 +10,6 @@\n \n //! Temporary files and directories\n \n-#[forbid(deprecated_mode)];\n-\n use core::os;\n use core::prelude::*;\n use core::rand;"}, {"sha": "5616c7211c1da5dcdb505d0a3b765fb29a4d6a3c", "filename": "src/libstd/term.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //! Simple ANSI color library\n-#[forbid(deprecated_mode)];\n \n use core::i32;\n use core::io;"}, {"sha": "e83b759f90144f50927af17f4675ab65a361a547", "filename": "src/libstd/test.rs", "status": "modified", "additions": 148, "deletions": 124, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -15,8 +15,6 @@\n // simplest interface possible for representing and running tests\n // while providing a base that other test frameworks may build off of.\n \n-#[forbid(deprecated_mode)];\n-\n use getopts;\n use sort;\n use term;\n@@ -51,20 +49,24 @@ pub type TestName = ~str;\n // the test succeeds; if the function fails then the test fails. We\n // may need to come up with a more clever definition of test in order\n // to support isolation of tests into tasks.\n-pub type TestFn = fn~();\n+pub type TestFn = ~fn();\n \n // The definition of a single test. A test runner will run a list of\n // these.\n pub struct TestDesc {\n     name: TestName,\n-    testfn: TestFn,\n     ignore: bool,\n     should_fail: bool\n }\n \n+pub struct TestDescAndFn {\n+    desc: TestDesc,\n+    testfn: TestFn,\n+}\n+\n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs (generated at compile time).\n-pub fn test_main(args: &[~str], tests: &[TestDesc]) {\n+pub fn test_main(args: &[~str], tests: ~[TestDescAndFn]) {\n     let opts =\n         match parse_opts(args) {\n           either::Left(move o) => o,\n@@ -92,7 +94,7 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n         };\n \n     let filter =\n-        if vec::len(matches.free) > 0u {\n+        if vec::len(matches.free) > 0 {\n             option::Some(matches.free[0])\n         } else { option::None };\n \n@@ -111,26 +113,27 @@ pub fn parse_opts(args: &[~str]) -> OptRes {\n #[deriving_eq]\n pub enum TestResult { TrOk, TrFailed, TrIgnored, }\n \n-type ConsoleTestState =\n-    @{out: io::Writer,\n-      log_out: Option<io::Writer>,\n-      use_color: bool,\n-      mut total: uint,\n-      mut passed: uint,\n-      mut failed: uint,\n-      mut ignored: uint,\n-      mut failures: ~[TestDesc]};\n+struct ConsoleTestState {\n+    out: io::Writer,\n+    log_out: Option<io::Writer>,\n+    use_color: bool,\n+    mut total: uint,\n+    mut passed: uint,\n+    mut failed: uint,\n+    mut ignored: uint,\n+    mut failures: ~[TestDesc]\n+}\n \n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts,\n-                     tests: &[TestDesc]) -> bool {\n+                         tests: ~[TestDescAndFn]) -> bool {\n \n-    fn callback(event: &TestEvent, st: ConsoleTestState) {\n+    fn callback(event: &TestEvent, st: @ConsoleTestState) {\n         debug!(\"callback(event=%?)\", event);\n         match *event {\n           TeFiltered(ref filtered_tests) => {\n             st.total = filtered_tests.len();\n-            let noun = if st.total != 1u { ~\"tests\" } else { ~\"test\" };\n+            let noun = if st.total != 1 { ~\"tests\" } else { ~\"test\" };\n             st.out.write_line(fmt!(\"\\nrunning %u %s\", st.total, noun));\n           }\n           TeWait(ref test) => st.out.write_str(\n@@ -142,18 +145,18 @@ pub fn run_tests_console(opts: &TestOpts,\n             }\n             match result {\n               TrOk => {\n-                st.passed += 1u;\n+                st.passed += 1;\n                 write_ok(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n               }\n               TrFailed => {\n-                st.failed += 1u;\n+                st.failed += 1;\n                 write_failed(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n                 st.failures.push(move test);\n               }\n               TrIgnored => {\n-                st.ignored += 1u;\n+                st.ignored += 1;\n                 write_ignored(st.out, st.use_color);\n                 st.out.write_line(~\"\");\n               }\n@@ -174,19 +177,19 @@ pub fn run_tests_console(opts: &TestOpts,\n     };\n \n     let st =\n-        @{out: io::stdout(),\n+        @ConsoleTestState{out: io::stdout(),\n           log_out: log_out,\n           use_color: use_color(),\n-          mut total: 0u,\n-          mut passed: 0u,\n-          mut failed: 0u,\n-          mut ignored: 0u,\n+          mut total: 0,\n+          mut passed: 0,\n+          mut failed: 0,\n+          mut ignored: 0,\n           mut failures: ~[]};\n \n     run_tests(opts, tests, |x| callback(&x, st));\n \n     assert (st.passed + st.failed + st.ignored == st.total);\n-    let success = st.failed == 0u;\n+    let success = st.failed == 0;\n \n     if !success {\n         print_failures(st);\n@@ -234,7 +237,7 @@ pub fn run_tests_console(opts: &TestOpts,\n     }\n }\n \n-fn print_failures(st: ConsoleTestState) {\n+fn print_failures(st: @ConsoleTestState) {\n     st.out.write_line(~\"\\nfailures:\");\n     let failures = copy st.failures;\n     let failures = vec::map(failures, |test| test.name);\n@@ -246,29 +249,29 @@ fn print_failures(st: ConsoleTestState) {\n \n #[test]\n fn should_sort_failures_before_printing_them() {\n+    fn dummy() {}\n+\n     let s = do io::with_str_writer |wr| {\n         let test_a = TestDesc {\n             name: ~\"a\",\n-            testfn: fn~() { },\n             ignore: false,\n             should_fail: false\n         };\n \n         let test_b = TestDesc {\n             name: ~\"b\",\n-            testfn: fn~() { },\n             ignore: false,\n             should_fail: false\n         };\n \n         let st =\n-            @{out: wr,\n+            @ConsoleTestState{out: wr,\n               log_out: option::None,\n               use_color: false,\n-              mut total: 0u,\n-              mut passed: 0u,\n-              mut failed: 0u,\n-              mut ignored: 0u,\n+              mut total: 0,\n+              mut passed: 0,\n+              mut failed: 0,\n+              mut ignored: 0,\n               mut failures: ~[move test_b, move test_a]};\n \n         print_failures(st);\n@@ -279,7 +282,7 @@ fn should_sort_failures_before_printing_them() {\n     assert apos < bpos;\n }\n \n-fn use_color() -> bool { return get_concurrency() == 1u; }\n+fn use_color() -> bool { return get_concurrency() == 1; }\n \n enum TestEvent {\n     TeFiltered(~[TestDesc]),\n@@ -290,68 +293,68 @@ enum TestEvent {\n type MonitorMsg = (TestDesc, TestResult);\n \n fn run_tests(opts: &TestOpts,\n-             tests: &[TestDesc],\n+             tests: ~[TestDescAndFn],\n              callback: fn@(e: TestEvent)) {\n     let mut filtered_tests = filter_tests(opts, tests);\n-    callback(TeFiltered(copy filtered_tests));\n+\n+    let filtered_descs = filtered_tests.map(|t| t.desc);\n+    callback(TeFiltered(filtered_descs));\n \n     // It's tempting to just spawn all the tests at once, but since we have\n     // many tests that run in other processes we would be making a big mess.\n     let concurrency = get_concurrency();\n     debug!(\"using %u test tasks\", concurrency);\n \n-    let total = vec::len(filtered_tests);\n-    let mut run_idx = 0;\n-    let mut wait_idx = 0;\n-    let mut done_idx = 0;\n+    let mut remaining = filtered_tests;\n+    vec::reverse(remaining);\n+    let mut pending = 0;\n \n     let (p, ch) = stream();\n     let ch = SharedChan(ch);\n \n-    while done_idx < total {\n-        while wait_idx < concurrency && run_idx < total {\n-            let test = copy filtered_tests[run_idx];\n+    while pending > 0 || !remaining.is_empty() {\n+        while pending < concurrency && !remaining.is_empty() {\n+            let test = remaining.pop();\n             if concurrency == 1 {\n                 // We are doing one test at a time so we can print the name\n                 // of the test before we run it. Useful for debugging tests\n                 // that hang forever.\n-                callback(TeWait(copy test));\n+                callback(TeWait(test.desc));\n             }\n-            run_test(move test, ch.clone());\n-            wait_idx += 1;\n-            run_idx += 1;\n+            run_test(test, ch.clone());\n+            pending += 1;\n         }\n \n-        let (test, result) = p.recv();\n+        let (desc, result) = p.recv();\n         if concurrency != 1 {\n-            callback(TeWait(copy test));\n+            callback(TeWait(desc));\n         }\n-        callback(TeResult(move test, result));\n-        wait_idx -= 1;\n-        done_idx += 1;\n+        callback(TeResult(desc, result));\n+        pending -= 1;\n     }\n }\n \n // Windows tends to dislike being overloaded with threads.\n #[cfg(windows)]\n-const sched_overcommit : uint = 1u;\n+const sched_overcommit : uint = 1;\n \n #[cfg(unix)]\n const sched_overcommit : uint = 4u;\n \n fn get_concurrency() -> uint {\n     unsafe {\n         let threads = rustrt::rust_sched_threads() as uint;\n-        if threads == 1u { 1u }\n+        if threads == 1 { 1 }\n         else { threads * sched_overcommit }\n     }\n }\n \n #[allow(non_implicitly_copyable_typarams)]\n-pub fn filter_tests(opts: &TestOpts,\n-                    tests: &[TestDesc])\n-                 -> ~[TestDesc] {\n-    let mut filtered = vec::slice(tests, 0, tests.len());\n+pub fn filter_tests(\n+    opts: &TestOpts,\n+    tests: ~[TestDescAndFn]) -> ~[TestDescAndFn]\n+{\n+    let mut filtered = tests;\n \n     // Remove tests that don't match the test filter\n     filtered = if opts.filter.is_none() {\n@@ -363,10 +366,10 @@ pub fn filter_tests(opts: &TestOpts,\n           option::None => ~\"\"\n         };\n \n-        fn filter_fn(test: &TestDesc, filter_str: &str) ->\n-            Option<TestDesc> {\n-            if str::contains(test.name, filter_str) {\n-                return option::Some(copy *test);\n+        fn filter_fn(test: TestDescAndFn, filter_str: &str) ->\n+            Option<TestDescAndFn> {\n+            if str::contains(test.desc.name, filter_str) {\n+                return option::Some(test);\n             } else { return option::None; }\n         }\n \n@@ -377,26 +380,26 @@ pub fn filter_tests(opts: &TestOpts,\n     filtered = if !opts.run_ignored {\n         move filtered\n     } else {\n-        fn filter(test: &TestDesc) -> Option<TestDesc> {\n-            if test.ignore {\n-                return option::Some(TestDesc {\n-                    name: test.name,\n-                    testfn: copy test.testfn,\n-                    ignore: false,\n-                    should_fail: test.should_fail});\n-            } else { return option::None; }\n+        fn filter(test: TestDescAndFn) -> Option<TestDescAndFn> {\n+            if test.desc.ignore {\n+                let TestDescAndFn {desc, testfn} = test;\n+                Some(TestDescAndFn {\n+                    desc: TestDesc {ignore: false, ..desc},\n+                    testfn: testfn\n+                })\n+            } else {\n+                None\n+            }\n         };\n \n         vec::filter_map(filtered, |x| filter(x))\n     };\n \n     // Sort the tests alphabetically\n-    filtered = {\n-        pure fn lteq(t1: &TestDesc, t2: &TestDesc) -> bool {\n-            str::le(t1.name, t2.name)\n-        }\n-        sort::merge_sort(filtered, lteq)\n-    };\n+    pure fn lteq(t1: &TestDescAndFn, t2: &TestDescAndFn) -> bool {\n+        str::le(t1.desc.name, t2.desc.name)\n+    }\n+    sort::quick_sort(filtered, lteq);\n \n     move filtered\n }\n@@ -406,37 +409,40 @@ struct TestFuture {\n     wait: fn@() -> TestResult,\n }\n \n-pub fn run_test(test: TestDesc, monitor_ch: SharedChan<MonitorMsg>) {\n-    if test.ignore {\n-        monitor_ch.send((copy test, TrIgnored));\n+pub fn run_test(test: TestDescAndFn, monitor_ch: SharedChan<MonitorMsg>) {\n+    let TestDescAndFn {desc, testfn} = test;\n+\n+    if desc.ignore {\n+        monitor_ch.send((desc, TrIgnored));\n         return;\n     }\n \n-    do task::spawn |move test| {\n-        let testfn = copy test.testfn;\n+    let testfn_cell = ::cell::Cell(testfn);\n+    do task::spawn {\n         let mut result_future = None; // task::future_result(builder);\n         task::task().unlinked().future_result(|+r| {\n             result_future = Some(move r);\n-        }).spawn(move testfn);\n+        }).spawn(testfn_cell.take());\n         let task_result = option::unwrap(move result_future).recv();\n-        let test_result = calc_result(&test, task_result == task::Success);\n-        monitor_ch.send((copy test, test_result));\n+        let test_result = calc_result(&desc, task_result == task::Success);\n+        monitor_ch.send((desc, test_result));\n     };\n }\n \n-fn calc_result(test: &TestDesc, task_succeeded: bool) -> TestResult {\n+fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n     if task_succeeded {\n-        if test.should_fail { TrFailed }\n+        if desc.should_fail { TrFailed }\n         else { TrOk }\n     } else {\n-        if test.should_fail { TrOk }\n+        if desc.should_fail { TrOk }\n         else { TrFailed }\n     }\n }\n \n #[cfg(test)]\n mod tests {\n-    use test::{TrFailed, TrIgnored, TrOk, filter_tests, parse_opts, TestDesc};\n+    use test::{TrFailed, TrIgnored, TrOk, filter_tests, parse_opts,\n+               TestDesc, TestDescAndFn};\n     use test::{TestOpts, run_test};\n \n     use core::either;\n@@ -447,11 +453,13 @@ mod tests {\n     #[test]\n     pub fn do_not_run_ignored_tests() {\n         fn f() { die!(); }\n-        let desc = TestDesc {\n-            name: ~\"whatever\",\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: ~\"whatever\",\n+                ignore: true,\n+                should_fail: false\n+            },\n             testfn: f,\n-            ignore: true,\n-            should_fail: false\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan(ch);\n@@ -463,11 +471,13 @@ mod tests {\n     #[test]\n     pub fn ignored_tests_result_in_ignored() {\n         fn f() { }\n-        let desc = TestDesc {\n-            name: ~\"whatever\",\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: ~\"whatever\",\n+                ignore: true,\n+                should_fail: false\n+            },\n             testfn: f,\n-            ignore: true,\n-            should_fail: false\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan(ch);\n@@ -480,11 +490,13 @@ mod tests {\n     #[ignore(cfg(windows))]\n     pub fn test_should_fail() {\n         fn f() { die!(); }\n-        let desc = TestDesc {\n-            name: ~\"whatever\",\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: ~\"whatever\",\n+                ignore: false,\n+                should_fail: true\n+            },\n             testfn: f,\n-            ignore: false,\n-            should_fail: true\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan(ch);\n@@ -496,11 +508,13 @@ mod tests {\n     #[test]\n     pub fn test_should_fail_but_succeeds() {\n         fn f() { }\n-        let desc = TestDesc {\n-            name: ~\"whatever\",\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: ~\"whatever\",\n+                ignore: false,\n+                should_fail: true\n+            },\n             testfn: f,\n-            ignore: false,\n-            should_fail: true\n         };\n         let (p, ch) = stream();\n         let ch = SharedChan(ch);\n@@ -531,6 +545,8 @@ mod tests {\n \n     #[test]\n     pub fn filter_for_ignored_option() {\n+        fn dummy() {}\n+\n         // When we run ignored tests the test filter should filter out all the\n         // unignored tests and flip the ignore flag on the rest to false\n \n@@ -541,24 +557,28 @@ mod tests {\n         };\n \n         let tests = ~[\n-            TestDesc {\n-                name: ~\"1\",\n-                testfn: fn~() { },\n-                ignore: true,\n-                should_fail: false,\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: ~\"1\",\n+                    ignore: true,\n+                    should_fail: false,\n+                },\n+                testfn: dummy,\n             },\n-            TestDesc {\n-                name: ~\"2\",\n-                testfn: fn~() { },\n-                ignore: false,\n-                should_fail: false,\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: ~\"2\",\n+                    ignore: false,\n+                    should_fail: false\n+                },\n+                testfn: dummy,\n             },\n         ];\n         let filtered = filter_tests(&opts, tests);\n \n-        assert (vec::len(filtered) == 1u);\n-        assert (filtered[0].name == ~\"1\");\n-        assert (filtered[0].ignore == false);\n+        assert (vec::len(filtered) == 1);\n+        assert (filtered[0].desc.name == ~\"1\");\n+        assert (filtered[0].desc.ignore == false);\n     }\n \n     #[test]\n@@ -578,12 +598,16 @@ mod tests {\n              ~\"test::sort_tests\"];\n         let tests =\n         {\n-            let testfn = fn~() { };\n+            fn testfn() { }\n             let mut tests = ~[];\n             for vec::each(names) |name| {\n-                let test = TestDesc {\n-                    name: *name, testfn: copy testfn, ignore: false,\n-                    should_fail: false};\n+                let test = TestDescAndFn {\n+                    desc: TestDesc {\n+                        name: *name, ignore: false,\n+                        should_fail: false\n+                    },\n+                    testfn: testfn,\n+                };\n                 tests.push(move test);\n             }\n             move tests\n@@ -603,7 +627,7 @@ mod tests {\n \n         for vec::each(pairs) |p| {\n             match *p {\n-                (ref a, ref b) => { assert (*a == b.name); }\n+                (ref a, ref b) => { assert (*a == b.desc.name); }\n             }\n         }\n     }"}, {"sha": "f696d239d30df8b65b756499e532014339ea3aaf", "filename": "src/libstd/time.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[forbid(deprecated_mode)];\n-\n use core::cmp::{Eq, Ord};\n use core::int;\n use core::libc::{c_char, c_int, c_long, size_t, time_t};"}, {"sha": "1da1bc60314d2eb3ce29a84494558fb1b39e786b", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,8 +10,6 @@\n \n //! Utilities that leverage libuv's `uv_timer_*` API\n \n-#[forbid(deprecated_mode)];\n-\n use uv;\n use uv::iotask;\n use uv::iotask::IoTask;"}, {"sha": "1e90abcc03dc640f2b2f422d01afdf7368b140e5", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 70, "deletions": 75, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -12,8 +12,6 @@\n //! trees. The only requirement for the types is that the key implements\n //! `Ord`, and that the `lt` method provides a total ordering.\n \n-#[forbid(deprecated_mode)];\n-\n use core::container::{Container, Mutable, Map, Set};\n use core::cmp::{Eq, Ord};\n use core::option::{Option, Some, None};\n@@ -49,8 +47,8 @@ impl <K: Eq Ord, V: Eq> TreeMap<K, V>: Eq {\n             let mut y = other.iter();\n             for self.len().times {\n                 unsafe { // unsafe as a purity workaround\n-                    x = x.next();\n-                    y = y.next();\n+                    map_next(&mut x);\n+                    map_next(&mut y);\n                     // FIXME: #4492 (ICE), x.get() == y.get()\n                     let (x1, x2) = x.get().unwrap();\n                     let (y1, y2) = y.get().unwrap();\n@@ -74,8 +72,8 @@ pure fn lt<K: Ord, V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n     let (a_len, b_len) = (a.len(), b.len());\n     for uint::min(a_len, b_len).times {\n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            map_next(&mut x);\n+            map_next(&mut y);\n             let (key_a,_) = x.get().unwrap();\n             let (key_b,_) = y.get().unwrap();\n             if *key_a < *key_b { return true; }\n@@ -142,7 +140,6 @@ impl <K: Ord, V> TreeMap<K, V>: Map<K, V> {\n         loop {\n             match *current {\n               Some(ref r) => {\n-                let r: &self/~TreeNode<K, V> = r; // FIXME: #3148\n                 if *key < r.key {\n                     current = &r.left;\n                 } else if r.key < *key {\n@@ -211,32 +208,30 @@ impl <K: Ord, V> TreeMapIterator<K, V> {\n     // Returns the current node, or None if this iterator is at the end.\n     fn get(&const self) -> Option<(&self/K, &self/V)> {\n         match self.current {\n-            Some(res) => Some((&res.key, &res.value)),\n-            None => None\n+          Some(res) => Some((&res.key, &res.value)),\n+          None => None\n         }\n     }\n+}\n \n-    /// Advance the iterator to the next node (in order). If this iterator\n-    /// is finished, does nothing.\n-    fn next(self) -> TreeMapIterator/&self<K, V> {\n-        let mut this = self;\n-        while !this.stack.is_empty() || this.node.is_some() {\n-            match *this.node {\n-              Some(ref x) => {\n-                this.stack.push(x);\n-                this.node = &x.left;\n-              }\n-              None => {\n-                let res = this.stack.pop();\n-                this.node = &res.right;\n-                this.current = Some(res);\n-                return this;\n-              }\n-            }\n+/// Advance the iterator to the next node (in order). If this iterator\n+/// is finished, does nothing.\n+pub fn map_next<K: Ord, V>(iter: &mut TreeMapIterator/&a<K, V>) {\n+    while !iter.stack.is_empty() || iter.node.is_some() {\n+        match *iter.node {\n+          Some(ref x) => {\n+            iter.stack.push(x);\n+            iter.node = &x.left;\n+          }\n+          None => {\n+            let res = iter.stack.pop();\n+            iter.node = &res.right;\n+            iter.current = Some(res);\n+            return;\n+          }\n         }\n-        this.current = None;\n-        return this;\n     }\n+    iter.current = None;\n }\n \n pub struct TreeSet<T> {\n@@ -298,18 +293,18 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n                 if a1 < b1 {\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else if b1 < a1 {\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 } else {\n                     return false;\n@@ -329,8 +324,8 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut x = self.iter();\n         let mut y = other.iter();\n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n             while b.is_some() {\n@@ -346,10 +341,10 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n                 }\n \n                 if !(a1 < b1) {\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n-                x = x.next();\n+                set_next(&mut x);\n                 a = x.get();\n             }\n         }\n@@ -362,15 +357,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x = x.next(); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x); x.get() } else { None }\n                     }\n                 }\n \n@@ -379,11 +374,11 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else {\n-                    if !(b1 < a1) { x = x.next(); a = x.get() }\n-                    y = y.next();\n+                    if !(b1 < a1) { set_next(&mut x); a = x.get() }\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n             }\n@@ -397,15 +392,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x.next(); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x); x.get() } else { None }\n                     }\n                 }\n \n@@ -414,21 +409,21 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n \n                 if a1 < b1 {\n                     if !f(a1) { return }\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else {\n                     if b1 < a1 {\n                         if !f(b1) { return }\n                     } else {\n-                        x = x.next();\n+                        set_next(&mut x);\n                         a = x.get();\n                     }\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n             }\n             do b.while_some |b1| {\n-                if f(b1) { y = y.next(); y.get() } else { None }\n+                if f(b1) { set_next(&mut y); y.get() } else { None }\n             }\n         }\n     }\n@@ -439,22 +434,22 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n                 if a1 < b1 {\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 } else {\n                     if !(b1 < a1) {\n                         if !f(a1) { return }\n                     }\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 }\n             }\n@@ -467,15 +462,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n         let mut y = other.iter();\n \n         unsafe { // purity workaround\n-            x = x.next();\n-            y = y.next();\n+            set_next(&mut x);\n+            set_next(&mut y);\n             let mut a = x.get();\n             let mut b = y.get();\n \n             while a.is_some() {\n                 if b.is_none() {\n                     return do a.while_some() |a1| {\n-                        if f(a1) { x = x.next(); x.get() } else { None }\n+                        if f(a1) { set_next(&mut x); x.get() } else { None }\n                     }\n                 }\n \n@@ -484,15 +479,15 @@ impl <T: Ord> TreeSet<T>: Set<T> {\n \n                 if b1 < a1 {\n                     if !f(b1) { return }\n-                    y = y.next();\n+                    set_next(&mut y);\n                     b = y.get();\n                 } else {\n                     if !f(a1) { return }\n                     if !(a1 < b1) {\n-                        y = y.next();\n+                        set_next(&mut y);\n                         b = y.get()\n                     }\n-                    x = x.next();\n+                    set_next(&mut x);\n                     a = x.get();\n                 }\n             }\n@@ -525,16 +520,16 @@ impl <T: Ord> TreeSetIterator<T> {\n     /// Returns the current node, or None if this iterator is at the end.\n     fn get(&const self) -> Option<&self/T> {\n         match self.iter.get() {\n-            None => None,\n-            Some((k, _)) => Some(k)\n+          None => None,\n+          Some((k, _)) => Some(k)\n         }\n     }\n+}\n \n-    /// Advance the iterator to the next node (in order). If this iterator is\n-    /// finished, does nothing.\n-    fn next(self) -> TreeSetIterator/&self<T> {\n-        TreeSetIterator { iter: self.iter.next() }\n-    }\n+/// Advance the iterator to the next node (in order). If this iterator is\n+/// finished, does nothing.\n+pub fn set_next<T: Ord>(iter: &mut TreeSetIterator/&a<T>) {\n+    map_next(&mut iter.iter);\n }\n \n // Nodes keep track of their level in the tree, starting at 1 in the\n@@ -746,8 +741,8 @@ mod test_treemap {\n         let v1 = str::to_bytes(~\"baz\");\n         let v2 = str::to_bytes(~\"foobar\");\n \n-        m.insert(k1, v1);\n-        m.insert(k2, v2);\n+        m.insert(copy k1, copy v1);\n+        m.insert(copy k2, copy v2);\n \n         assert m.find(&k2) == Some(&v2);\n         assert m.find(&k1) == Some(&v1);\n@@ -966,20 +961,20 @@ mod test_treemap {\n         let m = m;\n         let mut iter = m.iter();\n \n-        // FIXME: #4492 (ICE): iter.next() == Some((&x1, &y1))\n+        // FIXME: #4492 (ICE): iter.get() == Some((&x1, &y1))\n \n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x1, &y1);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x2, &y2);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x3, &y3);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x4, &y4);\n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().unwrap() == (&x5, &y5);\n \n-        iter = iter.next();\n+        map_next(&mut iter);\n         assert iter.get().is_none();\n     }\n }"}, {"sha": "9763f655a6f4ed33f9504a2a1ba99a5ad0bf49c2", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,8 +10,6 @@\n \n //! A process-wide libuv event loop for library use.\n \n-#[forbid(deprecated_mode)];\n-\n use ll = uv_ll;\n use iotask = uv_iotask;\n use get_gl = get;"}, {"sha": "a44fef54b726a337fa4f1c53ffab412807474e52", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -14,7 +14,6 @@\n  * The I/O task runs in its own single-threaded scheduler.  By using the\n  * `interact` function you can execute code in a uv callback.\n  */\n-#[forbid(deprecated_mode)];\n \n use ll = uv_ll;\n \n@@ -27,19 +26,17 @@ use core::task::TaskBuilder;\n use core::task;\n \n /// Used to abstract-away direct interaction with a libuv loop.\n-pub enum IoTask {\n-    IoTask_({\n-        async_handle: *ll::uv_async_t,\n-        op_chan: SharedChan<IoTaskMsg>\n-    })\n+pub struct IoTask {\n+    async_handle: *ll::uv_async_t,\n+    op_chan: SharedChan<IoTaskMsg>\n }\n \n impl IoTask: Clone {\n     fn clone(&self) -> IoTask {\n-        IoTask_({\n+        IoTask{\n             async_handle: self.async_handle,\n             op_chan: self.op_chan.clone()\n-        })\n+        }\n     }\n }\n \n@@ -131,10 +128,10 @@ fn run_loop(iotask_ch: &Chan<IoTask>) {\n \n         // Send out a handle through which folks can talk to us\n         // while we dwell in the I/O loop\n-        let iotask = IoTask_({\n+        let iotask = IoTask{\n             async_handle: async_handle,\n             op_chan: SharedChan(msg_ch)\n-        });\n+        };\n         iotask_ch.send(iotask);\n \n         log(debug, ~\"about to run uv loop\");"}, {"sha": "ca5a821921a7de3819712c582ffb0bd09f244c04", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -1543,7 +1543,7 @@ pub mod test {\n             let continue_async_handle_ptr =\n                 ptr::addr_of(&continue_async_handle);\n             let async_data =\n-                { continue_chan: continue_chan };\n+                async_handle_data { continue_chan: continue_chan };\n             let async_data_ptr = ptr::addr_of(&async_data);\n \n             let server_data = tcp_server_data {"}, {"sha": "b828c4ef629f58c8d0849c163dec93c7fd452ed0", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(deprecated_mode)];\n+\n use json;\n use sha1;\n use serialize::{Encoder, Encodable, Decoder, Decodable};\n@@ -167,20 +169,6 @@ struct Database {\n }\n \n impl Database {\n-    #[cfg(stage0)]\n-    #[cfg(stage1)]\n-    fn prepare(&mut self, fn_name: &str,\n-               declared_inputs: &WorkMap) -> Option<(WorkMap, WorkMap, ~str)>\n-    {\n-        let k = json_encode(&(fn_name, declared_inputs));\n-        let db_cache = copy self.db_cache;\n-        match db_cache.find(&k) {\n-            None => None,\n-            Some(&v) => Some(json_decode(copy v))\n-        }\n-    }\n-\n-    #[cfg(stage2)]\n     fn prepare(&mut self, fn_name: &str,\n                declared_inputs: &WorkMap) -> Option<(WorkMap, WorkMap, ~str)>\n     {\n@@ -235,13 +223,6 @@ struct Exec {\n     discovered_outputs: WorkMap\n }\n \n-#[cfg(stage0)]\n-struct Work<T:Owned> {\n-    prep: @Mut<Prep>,\n-    res: Option<Either<T,PortOne<(Exec,T)>>>\n-}\n-#[cfg(stage1)]\n-#[cfg(stage2)]\n struct Work<T> {\n     prep: @Mut<Prep>,\n     res: Option<Either<T,PortOne<(Exec,T)>>>"}, {"sha": "574ce281e2827fe1fe3a224e33d3c5b5126e9c85", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 61, "deletions": 21, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -399,16 +399,46 @@ pub impl mutability : cmp::Eq {\n #[auto_encode]\n #[auto_decode]\n #[deriving_eq]\n-pub enum Proto {\n-    ProtoBare,     // bare functions (deprecated)\n-    ProtoUniq,     // ~fn\n-    ProtoBox,      // @fn\n-    ProtoBorrowed, // &fn\n+pub enum Abi {\n+    RustAbi\n }\n \n-pub impl Proto : to_bytes::IterBytes {\n+pub impl Abi : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        (*self as uint).iter_bytes(lsb0, f);\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+pub impl Abi : ToStr {\n+    pure fn to_str(&self) -> ~str {\n+        match *self {\n+            RustAbi => ~\"\\\"rust\\\"\"\n+        }\n+    }\n+}\n+\n+#[auto_encode]\n+#[auto_decode]\n+#[deriving_eq]\n+pub enum Sigil {\n+    BorrowedSigil,\n+    OwnedSigil,\n+    ManagedSigil\n+}\n+\n+pub impl Sigil : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (*self as uint).iter_bytes(lsb0, f)\n+    }\n+}\n+\n+pub impl Sigil : ToStr {\n+    pure fn to_str(&self) -> ~str {\n+        match *self {\n+            BorrowedSigil => ~\"&\",\n+            OwnedSigil => ~\"~\",\n+            ManagedSigil => ~\"@\"\n+         }\n     }\n }\n \n@@ -434,13 +464,6 @@ pub enum expr_vstore {\n     expr_vstore_mut_slice,             // &mut [1,2,3,4]\n }\n \n-pub pure fn is_blockish(p: Proto) -> bool {\n-    match p {\n-        ProtoBorrowed => true,\n-        ProtoBare | ProtoUniq | ProtoBox => false\n-    }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n pub enum binop {\n@@ -671,14 +694,23 @@ pub struct expr {\n pub enum log_level { error, debug, log_other }\n // 0 = error, 1 = debug, 2 = log_other\n \n+#[auto_encode]\n+#[auto_decode]\n+#[deriving_eq]\n+pub enum CallSugar {\n+    NoSugar,\n+    DoSugar,\n+    ForSugar\n+}\n+\n #[auto_encode]\n #[auto_decode]\n pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n     expr_rec(~[field], Option<@expr>),\n-    expr_call(@expr, ~[@expr], bool), // True iff last argument is a block\n-    expr_method_call(@expr, ident, ~[@Ty], ~[@expr], bool), // Ditto\n+    expr_call(@expr, ~[@expr], CallSugar),\n+    expr_method_call(@expr, ident, ~[@Ty], ~[@expr], CallSugar),\n     expr_tup(~[@expr]),\n     expr_binary(binop, @expr, @expr),\n     expr_unary(unop, @expr),\n@@ -693,7 +725,7 @@ pub enum expr_ {\n     expr_match(@expr, ~[arm]),\n \n     // FIXME(#4717) the @() is req'd on windows or else LLVM croaks\n-    expr_fn(Proto, fn_decl, blk, @()),\n+    expr_fn(Sigil, fn_decl, blk, @()),\n \n     expr_fn_block(fn_decl, blk),\n     // Inner expr is always an expr_fn_block. We need the wrapping node to\n@@ -1112,12 +1144,19 @@ pub impl Onceness : to_bytes::IterBytes {\n \n #[auto_encode]\n #[auto_decode]\n-pub struct TyFn {\n-    proto: Proto,\n+pub struct TyClosure {\n+    sigil: Sigil,\n     region: Option<@region>,\n     purity: purity,\n     onceness: Onceness,\n-    bounds: @~[ty_param_bound],\n+    decl: fn_decl\n+}\n+\n+#[auto_encode]\n+#[auto_decode]\n+pub struct TyBareFn {\n+    purity: purity,\n+    abi: Abi,\n     decl: fn_decl\n }\n \n@@ -1133,7 +1172,8 @@ pub enum ty_ {\n     ty_ptr(mt),\n     ty_rptr(@region, mt),\n     ty_rec(~[ty_field]),\n-    ty_fn(@TyFn),\n+    ty_closure(@TyClosure),\n+    ty_bare_fn(@TyBareFn),\n     ty_tup(~[@Ty]),\n     ty_path(@path, node_id),\n     ty_mac(mac),"}, {"sha": "fe41cee919f643de5bf8285d847defb961ad2c02", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -333,7 +333,7 @@ pub fn map_stmt(stmt: @stmt, cx: ctx, v: vt) {\n }\n \n pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n-    match map.find(id) {\n+    match map.find(&id) {\n       None => {\n         fmt!(\"unknown node (id=%d)\", id)\n       }\n@@ -398,7 +398,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n pub fn node_item_query<Result>(items: map, id: node_id,\n                            query: fn(@item) -> Result,\n                            error_msg: ~str) -> Result {\n-    match items.find(id) {\n+    match items.find(&id) {\n         Some(node_item(it, _)) => query(it),\n         _ => die!(error_msg)\n     }"}, {"sha": "c347c04641f10e5d7744dc7dff50939f364f2979", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -154,7 +154,7 @@ pub fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n             option::None\n         }\n     };\n-    return vec::filter_map(attrs, filter);\n+    return vec::filter_mapped(attrs, filter);\n }\n \n /// Search a list of meta items and return only those with a specific name\n@@ -277,9 +277,9 @@ pub fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->\n    ~[@ast::meta_item] {\n \n-    return vec::filter_map(items, |item| {\n+    return vec::filter_mapped(items, |item| {\n         if get_meta_item_name(*item) != name {\n-            option::Some(/* FIXME (#2543) */ copy *item)\n+            option::Some(*item)\n         } else {\n             option::None\n         }"}, {"sha": "a509325facecadea641de2bf782d18cb28cba381", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -76,7 +76,7 @@ pub impl BytePos: Sub<BytePos, BytePos> {\n }\n \n pub impl BytePos: to_bytes::IterBytes {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }\n@@ -99,7 +99,7 @@ pub impl CharPos: cmp::Ord {\n }\n \n pub impl CharPos: to_bytes::IterBytes {\n-    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+    pure fn iter_bytes(&self, +lsb0: bool, &&f: to_bytes::Cb) {\n         (**self).iter_bytes(lsb0, f)\n     }\n }"}, {"sha": "21154bff01e9a6f3a9179dfa9ee509490e142d6a", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -392,7 +392,7 @@ priv impl ext_ctxt {\n         expr: @ast::expr,\n         args: ~[@ast::expr]\n     ) -> @ast::expr {\n-        self.expr(span, ast::expr_call(expr, args, false))\n+        self.expr(span, ast::expr_call(expr, args, ast::NoSugar))\n     }\n \n     fn lambda_expr(expr: @ast::expr) -> @ast::expr {"}, {"sha": "a050b2316e873a41872cc1390033dc384a873885", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -103,7 +103,7 @@ pub fn mk_addr_of(cx: ext_ctxt, sp: span, e: @ast::expr) -> @ast::expr {\n }\n pub fn mk_call_(cx: ext_ctxt, sp: span, fn_expr: @ast::expr,\n                 args: ~[@ast::expr]) -> @ast::expr {\n-    mk_expr(cx, sp, ast::expr_call(fn_expr, args, false))\n+    mk_expr(cx, sp, ast::expr_call(fn_expr, args, ast::NoSugar))\n }\n pub fn mk_call(cx: ext_ctxt, sp: span, fn_path: ~[ast::ident],\n                args: ~[@ast::expr]) -> @ast::expr {"}, {"sha": "18256369c78af15c0a84a0e1101c35ec2dd4edc3", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -40,7 +40,7 @@ pub fn expand_expr(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n                 /* using idents and token::special_idents would make the\n                 the macro names be hygienic */\n                 let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-                match exts.find(*extname) {\n+                match exts.find(extname) {\n                   None => {\n                     cx.span_fatal(pth.span,\n                                   fmt!(\"macro undefined: '%s'\", *extname))\n@@ -104,7 +104,7 @@ pub fn expand_mod_items(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n               ast::meta_name_value(ref n, _) => (*n),\n               ast::meta_list(ref n, _) => (*n)\n             };\n-            match exts.find(mname) {\n+            match exts.find(&mname) {\n               None | Some(NormalTT(_)) | Some(ItemTT(*)) => items,\n               Some(ItemDecorator(dec_fn)) => {\n                   cx.bt_push(ExpandedFrom({call_site: attr.span,\n@@ -161,7 +161,7 @@ pub fn expand_item_mac(exts: HashMap<~str, SyntaxExtension>,\n     };\n \n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-    let expanded = match exts.find(*extname) {\n+    let expanded = match exts.find(extname) {\n         None => cx.span_fatal(pth.span,\n                               fmt!(\"macro undefined: '%s!'\", *extname)),\n \n@@ -224,7 +224,7 @@ pub fn expand_stmt(exts: HashMap<~str, SyntaxExtension>, cx: ext_ctxt,\n \n     assert(vec::len(pth.idents) == 1u);\n     let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-    let (fully_expanded, sp) = match exts.find(*extname) {\n+    let (fully_expanded, sp) = match exts.find(extname) {\n         None =>\n             cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", *extname)),\n "}, {"sha": "da0ac4e08ab06c0b3445173869dee577428a841d", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -367,7 +367,7 @@ pub impl protocol: gen_init {\n             ext_cx.block(\n                 self.states.map_to_vec(\n                     |s| ext_cx.parse_stmt(\n-                        fmt!(\"data.%s.set_buffer_(buffer)\",\n+                        fmt!(\"data.%s.set_buffer(buffer)\",\n                              s.name))),\n                 ext_cx.parse_expr(\n                     fmt!(\"::ptr::addr_of(&(data.%s))\","}, {"sha": "3e7a84240e40e60a255080509f2630f705396d0f", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -59,11 +59,11 @@ pub fn add_new_extension(cx: ext_ctxt, sp: span, name: ident,\n                                      arg_reader as reader, argument_gram);\n \n     // Extract the arguments:\n-    let lhses:~[@named_match] = match argument_map.get(lhs_nm) {\n+    let lhses:~[@named_match] = match argument_map.get(&lhs_nm) {\n       @matched_seq(s, _) => s,\n       _ => cx.span_bug(sp, ~\"wrong-structured lhs\")\n     };\n-    let rhses:~[@named_match] = match argument_map.get(rhs_nm) {\n+    let rhses:~[@named_match] = match argument_map.get(&rhs_nm) {\n       @matched_seq(s, _) => s,\n       _ => cx.span_bug(sp, ~\"wrong-structured rhs\")\n     };"}, {"sha": "6f57ca38f1f1a48d01cf67be7e25d55eaadd81a9", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -111,7 +111,7 @@ pure fn lookup_cur_matched_by_matched(r: tt_reader,\n }\n \n fn lookup_cur_matched(r: tt_reader, name: ident) -> @named_match {\n-    lookup_cur_matched_by_matched(r, r.interpolations.get(name))\n+    lookup_cur_matched_by_matched(r, r.interpolations.get(&name))\n }\n enum lis {\n     lis_unconstrained, lis_constraint(uint, ident), lis_contradiction(~str)"}, {"sha": "8cecbfb12101ec5acf16578ad319219ed50c4156", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -536,13 +536,18 @@ pub fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n       ty_rptr(region, mt) => ty_rptr(region, fold_mt(mt, fld)),\n       ty_rec(ref fields) =>\n         ty_rec(vec::map((*fields), |f| fold_field(*f, fld))),\n-      ty_fn(f) =>\n-        ty_fn(@TyFn {\n-            proto: f.proto,\n+      ty_closure(f) =>\n+        ty_closure(@TyClosure {\n+            sigil: f.sigil,\n             purity: f.purity,\n             region: f.region,\n             onceness: f.onceness,\n-            bounds: @vec::map(*f.bounds, |x| fold_ty_param_bound(*x, fld)),\n+            decl: fold_fn_decl(f.decl, fld)\n+        }),\n+      ty_bare_fn(f) =>\n+        ty_bare_fn(@TyBareFn {\n+            purity: f.purity,\n+            abi: f.abi,\n             decl: fold_fn_decl(f.decl, fld)\n         }),\n       ty_tup(tys) => ty_tup(vec::map(tys, |ty| fld.fold_ty(*ty))),\n@@ -557,7 +562,7 @@ pub fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n pub fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n     ast::_mod {\n         view_items: vec::map(m.view_items, |x| fld.fold_view_item(*x)),\n-        items: vec::filter_map(m.items, |x| fld.fold_item(*x)),\n+        items: vec::filter_mapped(m.items, |x| fld.fold_item(*x)),\n     }\n }\n "}, {"sha": "64c4cb3c508a1d487bdb2611e12c7834bd8d4a69", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -23,8 +23,10 @@ pub fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n       | ast::expr_block(_)\n       | ast::expr_while(*)\n       | ast::expr_loop(*)\n-      | ast::expr_call(_, _, true)\n-      | ast::expr_method_call(_, _, _, _, true) => false,\n+      | ast::expr_call(_, _, ast::DoSugar)\n+      | ast::expr_call(_, _, ast::ForSugar)\n+      | ast::expr_method_call(_, _, _, _, ast::DoSugar)\n+      | ast::expr_method_call(_, _, _, _, ast::ForSugar) => false,\n       _ => true\n     }\n }"}, {"sha": "0f672d1de81fdb9a4cc15bea86787f898fe06ad8", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -431,6 +431,13 @@ fn scan_number(c: char, rdr: string_reader) -> token::Token {\n         let dec_part = scan_digits(rdr, 10u);\n         num_str += ~\".\" + dec_part;\n     }\n+    if is_float {\n+        match base {\n+          16u => rdr.fatal(~\"hexadecimal float literal is not supported\"),\n+          2u => rdr.fatal(~\"binary float literal is not supported\"),\n+          _ => ()\n+        }\n+    }\n     match scan_exponent(rdr) {\n       Some(ref s) => {\n         is_float = true;"}, {"sha": "7fb3064c388f1f5bdac80b9191d41287c5721b3d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 96, "deletions": 74, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -10,7 +10,10 @@\n \n use core::prelude::*;\n \n-use ast::{ProtoBox, ProtoUniq, RegionTyParamBound, TraitTyParamBound};\n+use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil, RustAbi};\n+use ast::{CallSugar, NoSugar, DoSugar, ForSugar};\n+use ast::{TyBareFn, TyClosure};\n+use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{provided, public, pure_fn, purity, re_static};\n use ast::{_mod, add, arg, arm, attribute, bind_by_ref, bind_infer};\n use ast::{bind_by_copy, bitand, bitor, bitxor, blk};\n@@ -27,7 +30,7 @@ use ast::{expr_ret, expr_swap, expr_struct, expr_tup, expr_unary};\n use ast::{expr_vec, expr_vstore, expr_vstore_mut_box};\n use ast::{expr_vstore_fixed, expr_vstore_slice, expr_vstore_box};\n use ast::{expr_vstore_mut_slice, expr_while, extern_fn, field, fn_decl};\n-use ast::{expr_vstore_uniq, TyFn, Onceness, Once, Many};\n+use ast::{expr_vstore_uniq, TyClosure, TyBareFn, Onceness, Once, Many};\n use ast::{foreign_item, foreign_item_const, foreign_item_fn, foreign_mod};\n use ast::{ident, impure_fn, infer, inherited, item, item_, item_const};\n use ast::{item_const, item_enum, item_fn, item_foreign_mod, item_impl};\n@@ -38,15 +41,16 @@ use ast::{m_imm, m_mutbl, mac_, mac_invoc_tt, matcher, match_nonterminal};\n use ast::{match_seq, match_tok, method, mode, module_ns, mt, mul, mutability};\n use ast::{named_field, neg, node_id, noreturn, not, pat, pat_box, pat_enum};\n use ast::{pat_ident, pat_lit, pat_range, pat_rec, pat_region, pat_struct};\n-use ast::{pat_tup, pat_uniq, pat_wild, path, private, Proto, ProtoBare};\n-use ast::{ProtoBorrowed, re_self, re_anon, re_named, region, rem, required};\n+use ast::{pat_tup, pat_uniq, pat_wild, path, private};\n+use ast::{re_self, re_anon, re_named, region, rem, required};\n use ast::{ret_style, return_val, self_ty, shl, shr, stmt, stmt_decl};\n use ast::{stmt_expr, stmt_semi, stmt_mac, struct_def, struct_field};\n use ast::{struct_immutable, struct_mutable, struct_variant_kind, subtract};\n use ast::{sty_box, sty_by_ref, sty_region, sty_static, sty_uniq, sty_value};\n use ast::{token_tree, trait_method, trait_ref, tt_delim, tt_seq, tt_tok};\n use ast::{tt_nonterminal, tuple_variant_kind, Ty, ty_, ty_bot, ty_box};\n-use ast::{ty_field, ty_fixed_length_vec, ty_fn, ty_infer, ty_mac, ty_method};\n+use ast::{ty_field, ty_fixed_length_vec, ty_closure, ty_bare_fn};\n+use ast::{ty_infer, ty_mac, ty_method};\n use ast::{ty_nil, ty_param, ty_param_bound, ty_path, ty_ptr, ty_rec, ty_rptr};\n use ast::{ty_tup, ty_u32, ty_uniq, ty_vec, type_value_ns, uniq};\n use ast::{unnamed_field, unsafe_blk, unsafe_fn, variant, view_item};\n@@ -293,25 +297,49 @@ pub impl Parser {\n \n     pure fn id_to_str(id: ident) -> @~str { self.sess.interner.get(id) }\n \n-    fn token_is_fn_keyword(+tok: token::Token) -> bool {\n+    fn token_is_closure_keyword(+tok: token::Token) -> bool {\n         self.token_is_keyword(~\"pure\", tok) ||\n             self.token_is_keyword(~\"unsafe\", tok) ||\n             self.token_is_keyword(~\"once\", tok) ||\n-            self.token_is_keyword(~\"fn\", tok) ||\n-            self.token_is_keyword(~\"extern\", tok)\n+            self.token_is_keyword(~\"fn\", tok)\n     }\n \n-    fn parse_ty_fn(pre_proto: Option<ast::Proto>,\n-                       pre_region_name: Option<ident>) -> ty_\n+    fn parse_ty_bare_fn() -> ty_\n     {\n         /*\n \n-        (&|~|@) [r/] [pure|unsafe] [once] fn [:K] (S) -> T\n-        ^~~~~~^ ^~~^ ^~~~~~~~~~~~^ ^~~~~^    ^~~^ ^~^    ^\n-           |     |     |             |        |    |     |\n-           |     |     |             |        |    |   Return type\n-           |     |     |             |        |  Argument types\n-           |     |     |             |    Environment bounds\n+        extern \"ABI\" [pure|unsafe] fn (S) -> T\n+               ^~~~^ ^~~~~~~~~~~~^    ^~^    ^\n+                 |     |               |     |\n+                 |     |               |   Return type\n+                 |     |             Argument types\n+                 |     |\n+                 |     |\n+                 |   Purity\n+                ABI\n+\n+        */\n+\n+        let purity = self.parse_purity();\n+        self.expect_keyword(~\"fn\");\n+        return ty_bare_fn(@TyBareFn {\n+            abi: RustAbi,\n+            purity: purity,\n+            decl: self.parse_ty_fn_decl()\n+        });\n+    }\n+\n+    fn parse_ty_closure(pre_sigil: Option<ast::Sigil>,\n+                        pre_region_name: Option<ident>) -> ty_\n+    {\n+        /*\n+\n+        (&|~|@) [r/] [pure|unsafe] [once] fn (S) -> T\n+        ^~~~~~^ ^~~^ ^~~~~~~~~~~~^ ^~~~~^    ^~^    ^\n+           |     |     |             |        |     |\n+           |     |     |             |        |   Return type\n+           |     |     |             |      Argument types\n+           |     |     |             |\n            |     |     |          Once-ness (a.k.a., affine)\n            |     |   Purity\n            | Lifetime bound\n@@ -322,22 +350,13 @@ pub impl Parser {\n         // At this point, the allocation type and lifetime bound have been\n         // parsed.\n \n-        let purity = parse_purity(&self);\n+        let purity = self.parse_purity();\n         let onceness = parse_onceness(&self);\n+        self.expect_keyword(~\"fn\");\n+        let post_sigil = self.parse_fn_ty_sigil();\n \n-        let bounds, post_proto;\n-        if self.eat_keyword(~\"extern\") {\n-            self.expect_keyword(~\"fn\");\n-            post_proto = Some(ast::ProtoBare);\n-            bounds = @~[];\n-        } else {\n-            self.expect_keyword(~\"fn\");\n-            post_proto = self.parse_fn_ty_proto();\n-            bounds = self.parse_optional_ty_param_bounds();\n-        };\n-\n-        let proto = match (pre_proto, post_proto) {\n-            (None, None) => ast::ProtoBorrowed,\n+        let sigil = match (pre_sigil, post_sigil) {\n+            (None, None) => BorrowedSigil,\n             (Some(p), None) | (None, Some(p)) => p,\n             (Some(_), Some(_)) => {\n                 self.fatal(~\"cannot combine prefix and postfix \\\n@@ -352,30 +371,28 @@ pub impl Parser {\n             None\n         };\n \n-        return ty_fn(@TyFn {\n-            proto: proto,\n+        return ty_closure(@TyClosure {\n+            sigil: sigil,\n             region: region,\n             purity: purity,\n             onceness: onceness,\n-            bounds: bounds,\n             decl: self.parse_ty_fn_decl()\n         });\n \n-        fn parse_purity(self: &Parser) -> purity {\n-            if self.eat_keyword(~\"pure\") {\n-                return pure_fn;\n-            } else if self.eat_keyword(~\"unsafe\") {\n-                return unsafe_fn;\n-            } else {\n-                return impure_fn;\n-            }\n-        }\n-\n         fn parse_onceness(self: &Parser) -> Onceness {\n             if self.eat_keyword(~\"once\") {Once} else {Many}\n         }\n     }\n \n+    fn parse_purity() -> purity {\n+        if self.eat_keyword(~\"pure\") {\n+            return pure_fn;\n+        } else if self.eat_keyword(~\"unsafe\") {\n+            return unsafe_fn;\n+        } else {\n+            return impure_fn;\n+        }\n+    }\n \n     fn parse_ty_fn_decl() -> fn_decl {\n         let inputs = do self.parse_unspanned_seq(\n@@ -560,10 +577,10 @@ pub impl Parser {\n             }\n         } else if self.token == token::AT {\n             self.bump();\n-            self.parse_box_or_uniq_pointee(ast::ProtoBox, ty_box)\n+            self.parse_box_or_uniq_pointee(ManagedSigil, ty_box)\n         } else if self.token == token::TILDE {\n             self.bump();\n-            self.parse_box_or_uniq_pointee(ast::ProtoUniq, ty_uniq)\n+            self.parse_box_or_uniq_pointee(OwnedSigil, ty_uniq)\n         } else if self.token == token::BINOP(token::STAR) {\n             self.bump();\n             ty_ptr(self.parse_mt())\n@@ -590,8 +607,10 @@ pub impl Parser {\n         } else if self.token == token::BINOP(token::AND) {\n             self.bump();\n             self.parse_borrowed_pointee()\n-        } else if self.token_is_fn_keyword(self.token) {\n-            self.parse_ty_fn(None, None)\n+        } else if self.eat_keyword(~\"extern\") {\n+            self.parse_ty_bare_fn()\n+        } else if self.token_is_closure_keyword(self.token) {\n+            self.parse_ty_closure(None, None)\n         } else if self.token == token::MOD_SEP\n             || is_ident_or_path(self.token) {\n             let path = self.parse_path_with_tps(colons_before_params);\n@@ -603,19 +622,19 @@ pub impl Parser {\n     }\n \n     fn parse_box_or_uniq_pointee(\n-        proto: ast::Proto,\n+        sigil: ast::Sigil,\n         ctor: &fn(+v: mt) -> ty_) -> ty_\n     {\n         // @foo/fn() or @fn() are parsed directly as fn types:\n         match copy self.token {\n             token::IDENT(rname, _) => {\n                 if self.look_ahead(1u) == token::BINOP(token::SLASH) &&\n-                    self.token_is_fn_keyword(self.look_ahead(2u))\n+                    self.token_is_closure_keyword(self.look_ahead(2u))\n                 {\n                     self.bump(); self.bump();\n-                    return self.parse_ty_fn(Some(proto), Some(rname));\n-                } else if self.token_is_fn_keyword(self.token) {\n-                    return self.parse_ty_fn(Some(proto), None);\n+                    return self.parse_ty_closure(Some(sigil), Some(rname));\n+                } else if self.token_is_closure_keyword(self.token) {\n+                    return self.parse_ty_closure(Some(sigil), None);\n                 }\n             }\n             _ => {}\n@@ -643,8 +662,8 @@ pub impl Parser {\n             _ => { None }\n         };\n \n-        if self.token_is_fn_keyword(self.token) {\n-            return self.parse_ty_fn(Some(ProtoBorrowed), rname);\n+        if self.token_is_closure_keyword(self.token) {\n+            return self.parse_ty_closure(Some(BorrowedSigil), rname);\n         }\n \n         let r = self.region_from_name(rname);\n@@ -981,24 +1000,26 @@ pub impl Parser {\n         } else if self.eat_keyword(~\"if\") {\n             return self.parse_if_expr();\n         } else if self.eat_keyword(~\"for\") {\n-            return self.parse_sugary_call_expr(~\"for\", expr_loop_body);\n+            return self.parse_sugary_call_expr(~\"for\", ForSugar,\n+                                               expr_loop_body);\n         } else if self.eat_keyword(~\"do\") {\n-            return self.parse_sugary_call_expr(~\"do\", expr_do_body);\n+            return self.parse_sugary_call_expr(~\"do\", DoSugar,\n+                                               expr_do_body);\n         } else if self.eat_keyword(~\"while\") {\n             return self.parse_while_expr();\n         } else if self.eat_keyword(~\"loop\") {\n             return self.parse_loop_expr();\n         } else if self.eat_keyword(~\"match\") {\n             return self.parse_match_expr();\n         } else if self.eat_keyword(~\"fn\") {\n-            let opt_proto = self.parse_fn_ty_proto();\n-            let proto = match opt_proto {\n-                None | Some(ast::ProtoBare) => {\n+            let opt_sigil = self.parse_fn_ty_sigil();\n+            let sigil = match opt_sigil {\n+                None => {\n                     self.fatal(~\"fn expr are deprecated, use fn@\")\n                 }\n                 Some(p) => { p }\n             };\n-            return self.parse_fn_expr(proto);\n+            return self.parse_fn_expr(sigil);\n         } else if self.eat_keyword(~\"unsafe\") {\n             return self.parse_block_expr(lo, unsafe_blk);\n         } else if self.token == token::LBRACKET {\n@@ -1176,7 +1197,7 @@ pub impl Parser {\n                                 |p| p.parse_expr());\n                             hi = self.span.hi;\n \n-                            let nd = expr_method_call(e, i, tys, es, false);\n+                            let nd = expr_method_call(e, i, tys, es, NoSugar);\n                             e = self.mk_expr(lo, hi, move nd);\n                         }\n                         _ => {\n@@ -1198,7 +1219,7 @@ pub impl Parser {\n                     |p| p.parse_expr());\n                 hi = self.span.hi;\n \n-                let nd = expr_call(e, es, false);\n+                let nd = expr_call(e, es, NoSugar);\n                 e = self.mk_expr(lo, hi, nd);\n               }\n \n@@ -1566,7 +1587,7 @@ pub impl Parser {\n         self.mk_expr(q.lo, q.hi, expr_if(q.cond, q.then, q.els))\n     }\n \n-    fn parse_fn_expr(proto: Proto) -> @expr {\n+    fn parse_fn_expr(sigil: Sigil) -> @expr {\n         let lo = self.last_span.lo;\n \n         // if we want to allow fn expression argument types to be inferred in\n@@ -1576,7 +1597,7 @@ pub impl Parser {\n         let body = self.parse_block();\n \n         self.mk_expr(lo, body.span.hi,\n-                            expr_fn(proto, decl, body, @()))\n+                     expr_fn(sigil, decl, body, @()))\n     }\n \n     // `|args| { ... }` like in `do` expressions\n@@ -1641,6 +1662,7 @@ pub impl Parser {\n     }\n \n     fn parse_sugary_call_expr(keyword: ~str,\n+                              sugar: CallSugar,\n                               ctor: fn(+v: @expr) -> expr_) -> @expr {\n         let lo = self.last_span;\n         // Parse the callee `foo` in\n@@ -1654,35 +1676,35 @@ pub impl Parser {\n         // them as the lambda arguments\n         let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n         match e.node {\n-            expr_call(f, args, false) => {\n+            expr_call(f, args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append(args, ~[last_arg]);\n-                self.mk_expr(lo.lo, block.span.hi, expr_call(f, args, true))\n+                self.mk_expr(lo.lo, block.span.hi, expr_call(f, args, sugar))\n             }\n-            expr_method_call(f, i, tps, args, false) => {\n+            expr_method_call(f, i, tps, args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append(args, ~[last_arg]);\n                 self.mk_expr(lo.lo, block.span.hi,\n-                             expr_method_call(f, i, tps, args, true))\n+                             expr_method_call(f, i, tps, args, sugar))\n             }\n             expr_field(f, i, tps) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 self.mk_expr(lo.lo, block.span.hi,\n-                             expr_method_call(f, i, tps, ~[last_arg], true))\n+                             expr_method_call(f, i, tps, ~[last_arg], sugar))\n             }\n             expr_path(*) | expr_call(*) | expr_method_call(*) |\n                 expr_paren(*) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 self.mk_expr(lo.lo, last_arg.span.hi,\n-                             expr_call(e, ~[last_arg], true))\n+                             expr_call(e, ~[last_arg], sugar))\n             }\n             _ => {\n                 // There may be other types of expressions that can\n@@ -3592,19 +3614,19 @@ pub impl Parser {\n         (id, item_enum(enum_definition, ty_params), None)\n     }\n \n-    fn parse_fn_ty_proto() -> Option<Proto> {\n+    fn parse_fn_ty_sigil() -> Option<Sigil> {\n         match self.token {\n             token::AT => {\n                 self.bump();\n-                Some(ProtoBox)\n+                Some(ManagedSigil)\n             }\n             token::TILDE => {\n                 self.bump();\n-                Some(ProtoUniq)\n+                Some(OwnedSigil)\n             }\n             token::BINOP(token::AND) => {\n                 self.bump();\n-                Some(ProtoBorrowed)\n+                Some(BorrowedSigil)\n             }\n             _ => {\n                 None"}, {"sha": "bcbee7b2f244490ee6f00c5ac92bf9ca76e4bf88", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 56, "deletions": 54, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -404,9 +404,15 @@ pub fn print_type_ex(s: ps, &&ty: @ast::Ty, print_colons: bool) {\n         commasep(s, inconsistent, elts, print_type);\n         pclose(s);\n       }\n-      ast::ty_fn(f) => {\n-        print_ty_fn(s, Some(f.proto), f.region, f.purity,\n-                    f.onceness, f.bounds, f.decl, None, None, None);\n+      ast::ty_bare_fn(f) => {\n+          print_ty_fn(s, Some(f.abi), None, None,\n+                      f.purity, ast::Many, f.decl, None,\n+                      None, None);\n+      }\n+      ast::ty_closure(f) => {\n+          print_ty_fn(s, None, Some(f.sigil), f.region,\n+                      f.purity, f.onceness, f.decl, None,\n+                      None, None);\n       }\n       ast::ty_path(path, _) => print_path(s, path, print_colons),\n       ast::ty_fixed_length_vec(mt, v) => {\n@@ -806,8 +812,8 @@ pub fn print_ty_method(s: ps, m: ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n-    print_ty_fn(s, None, None, m.purity, ast::Many,\n-                @~[], m.decl, Some(m.ident), Some(m.tps),\n+    print_ty_fn(s, None, None, None, m.purity, ast::Many,\n+                m.decl, Some(m.ident), Some(m.tps),\n                 Some(m.self_ty.node));\n     word(s.s, ~\";\");\n }\n@@ -1046,32 +1052,32 @@ pub fn print_expr_vstore(s: ps, t: ast::expr_vstore) {\n }\n \n pub fn print_call_pre(s: ps,\n-                      has_block: bool,\n+                      sugar: ast::CallSugar,\n                       base_args: &mut ~[@ast::expr])\n                    -> Option<@ast::expr> {\n-    if has_block {\n-        let blk_arg = base_args.pop();\n-        match blk_arg.node {\n-          ast::expr_loop_body(_) => { head(s, ~\"for\"); }\n-          ast::expr_do_body(_) => { head(s, ~\"do\"); }\n-          _ => {}\n-        }\n-        Some(blk_arg)\n-    } else {\n-        None\n+    match sugar {\n+        ast::DoSugar => {\n+            head(s, ~\"do\");\n+            Some(base_args.pop())\n+        }\n+        ast::ForSugar => {\n+            head(s, ~\"for\");\n+            Some(base_args.pop())\n+        }\n+        ast::NoSugar => None\n     }\n }\n \n pub fn print_call_post(s: ps,\n-                       has_block: bool,\n+                       sugar: ast::CallSugar,\n                        blk: &Option<@ast::expr>,\n                        base_args: &mut ~[@ast::expr]) {\n-    if !has_block || !base_args.is_empty() {\n+    if sugar == ast::NoSugar || !base_args.is_empty() {\n         popen(s);\n         commasep_exprs(s, inconsistent, *base_args);\n         pclose(s);\n     }\n-    if has_block {\n+    if sugar != ast::NoSugar {\n         nbsp(s);\n         match blk.get().node {\n           // need to handle closures specifically\n@@ -1181,15 +1187,15 @@ pub fn print_expr(s: ps, &&expr: @ast::expr) {\n         commasep_exprs(s, inconsistent, exprs);\n         pclose(s);\n       }\n-      ast::expr_call(func, args, has_block) => {\n+      ast::expr_call(func, args, sugar) => {\n         let mut base_args = copy args;\n-        let blk = print_call_pre(s, has_block, &mut base_args);\n+        let blk = print_call_pre(s, sugar, &mut base_args);\n         print_expr(s, func);\n-        print_call_post(s, has_block, &blk, &mut base_args);\n+        print_call_post(s, sugar, &blk, &mut base_args);\n       }\n-      ast::expr_method_call(func, ident, tys, args, has_block) => {\n+      ast::expr_method_call(func, ident, tys, args, sugar) => {\n         let mut base_args = copy args;\n-        let blk = print_call_pre(s, has_block, &mut base_args);\n+        let blk = print_call_pre(s, sugar, &mut base_args);\n         print_expr(s, func);\n         word(s.s, ~\".\");\n         print_ident(s, ident);\n@@ -1198,7 +1204,7 @@ pub fn print_expr(s: ps, &&expr: @ast::expr) {\n             commasep(s, inconsistent, tys, print_type);\n             word(s.s, ~\">\");\n         }\n-        print_call_post(s, has_block, &blk, &mut base_args);\n+        print_call_post(s, sugar, &blk, &mut base_args);\n       }\n       ast::expr_binary(op, lhs, rhs) => {\n         print_expr(s, lhs);\n@@ -1305,13 +1311,13 @@ pub fn print_expr(s: ps, &&expr: @ast::expr) {\n         }\n         bclose_(s, expr.span, match_indent_unit);\n       }\n-      ast::expr_fn(proto, decl, ref body, _) => {\n+      ast::expr_fn(sigil, decl, ref body, _) => {\n         // containing cbox, will be closed by print-block at }\n         cbox(s, indent_unit);\n         // head-box, will be closed by print-block at start\n         ibox(s, 0u);\n         print_fn_header_info(s, None, None, ast::Many,\n-                             Some(proto), ast::inherited);\n+                             Some(sigil), ast::inherited);\n         print_fn_args_and_ret(s, decl, None);\n         space(s.s);\n         print_block(s, (*body));\n@@ -1900,33 +1906,32 @@ pub fn print_arg(s: ps, input: ast::arg) {\n }\n \n pub fn print_ty_fn(s: ps,\n-                   opt_proto: Option<ast::Proto>,\n+                   opt_abi: Option<ast::Abi>,\n+                   opt_sigil: Option<ast::Sigil>,\n                    opt_region: Option<@ast::region>,\n                    purity: ast::purity,\n                    onceness: ast::Onceness,\n-                   bounds: @~[ast::ty_param_bound],\n                    decl: ast::fn_decl, id: Option<ast::ident>,\n                    tps: Option<~[ast::ty_param]>,\n                    opt_self_ty: Option<ast::self_ty_>) {\n     ibox(s, indent_unit);\n \n     // Duplicates the logic in `print_fn_header_info()`.  This is because that\n-    // function prints the proto in the wrong place.  That should be fixed.\n+    // function prints the sigil in the wrong place.  That should be fixed.\n     print_self_ty_if_static(s, opt_self_ty);\n-    print_opt_proto(s, opt_proto);\n+    print_opt_abi(s, opt_abi);\n+    print_opt_sigil(s, opt_sigil);\n     for opt_region.each |r| { print_region(s, ~\"\", *r, ~\"/\"); }\n     print_purity(s, purity);\n     print_onceness(s, onceness);\n     word(s.s, ~\"fn\");\n-    print_bounds(s, bounds);\n     match id { Some(id) => { word(s.s, ~\" \"); print_ident(s, id); } _ => () }\n     match tps { Some(tps) => print_type_params(s, tps), _ => () }\n     zerobreak(s.s);\n \n     popen(s);\n-    // It is unfortunate to duplicate the commasep logic, but we\n-    // we want the self type, the args, and the capture clauses all\n-    // in the same box.\n+    // It is unfortunate to duplicate the commasep logic, but we we want the\n+    // self type and the args all in the same box.\n     box(s, 0u, inconsistent);\n     let mut first = true;\n     for opt_self_ty.each |self_ty| {\n@@ -2157,12 +2162,18 @@ pub fn print_opt_purity(s: ps, opt_purity: Option<ast::purity>) {\n     }\n }\n \n-pub fn print_opt_proto(s: ps, opt_proto: Option<ast::Proto>) {\n-    match opt_proto {\n-        Some(ast::ProtoBare) => { word(s.s, ~\"extern \"); }\n-        Some(ast::ProtoBorrowed) => { word(s.s, ~\"&\"); }\n-        Some(ast::ProtoUniq) => { word(s.s, ~\"~\"); }\n-        Some(ast::ProtoBox) => { word(s.s, ~\"@\"); }\n+pub fn print_opt_abi(s: ps, opt_abi: Option<ast::Abi>) {\n+    match opt_abi {\n+        Some(ast::RustAbi) => { word_nbsp(s, ~\"extern\"); }\n+        None => {}\n+    };\n+}\n+\n+pub fn print_opt_sigil(s: ps, opt_sigil: Option<ast::Sigil>) {\n+    match opt_sigil {\n+        Some(ast::BorrowedSigil) => { word(s.s, ~\"&\"); }\n+        Some(ast::OwnedSigil) => { word(s.s, ~\"~\"); }\n+        Some(ast::ManagedSigil) => { word(s.s, ~\"@\"); }\n         None => {}\n     };\n }\n@@ -2171,20 +2182,20 @@ pub fn print_fn_header_info(s: ps,\n                             opt_sty: Option<ast::self_ty_>,\n                             opt_purity: Option<ast::purity>,\n                             onceness: ast::Onceness,\n-                            opt_proto: Option<ast::Proto>,\n+                            opt_sigil: Option<ast::Sigil>,\n                             vis: ast::visibility) {\n     print_self_ty_if_static(s, opt_sty);\n     word(s.s, visibility_qualified(vis, ~\"\"));\n     print_opt_purity(s, opt_purity);\n     print_onceness(s, onceness);\n     word(s.s, ~\"fn\");\n-    print_opt_proto(s, opt_proto);\n+    print_opt_sigil(s, opt_sigil);\n }\n \n-pub fn opt_proto_to_str(opt_p: Option<ast::Proto>) -> ~str {\n+pub fn opt_sigil_to_str(opt_p: Option<ast::Sigil>) -> ~str {\n     match opt_p {\n       None => ~\"fn\",\n-      Some(p) => proto_to_str(p)\n+      Some(p) => fmt!(\"fn%s\", p.to_str())\n     }\n }\n \n@@ -2218,15 +2229,6 @@ pub fn print_onceness(s: ps, o: ast::Onceness) {\n     }\n }\n \n-pub fn proto_to_str(p: ast::Proto) -> ~str {\n-    return match p {\n-      ast::ProtoBare => ~\"extern fn\",\n-      ast::ProtoBorrowed => ~\"fn&\",\n-      ast::ProtoUniq => ~\"fn~\",\n-      ast::ProtoBox => ~\"fn@\"\n-    };\n-}\n-\n #[cfg(test)]\n pub mod test {\n     use ast;"}, {"sha": "877817af06c1807f2ba70639c6d5c18c1a4b4f0f", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -22,7 +22,6 @@\n #[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n #[allow(deprecated_mode)];\n-#[warn(deprecated_pattern)];\n #[allow(deprecated_self)];\n \n #[no_core];"}, {"sha": "905571d18172146f6bfcd21d001e4d562e06e057", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -44,7 +44,7 @@ pub trait Interner<T:Eq IterBytes Hash Const Copy> {\n \n pub impl <T:Eq IterBytes Hash Const Copy> hash_interner<T>: Interner<T> {\n     fn intern(val: T) -> uint {\n-        match self.map.find(val) {\n+        match self.map.find(&val) {\n           Some(idx) => return idx,\n           None => {\n             let new_idx = self.vect.len();"}, {"sha": "37b96e056537064160c863c434ffcd1a911cc08a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -30,10 +30,10 @@ use core::vec;\n pub enum vt<E> { mk_vt(visitor<E>), }\n \n pub enum fn_kind {\n-    fk_item_fn(ident, ~[ty_param], purity), //< an item declared with fn()\n-    fk_method(ident, ~[ty_param], @method),\n-    fk_anon(Proto),    //< an anonymous function like fn@(...)\n-    fk_fn_block,       //< a block {||...}\n+    fk_item_fn(ident, ~[ty_param], purity), // fn foo()\n+    fk_method(ident, ~[ty_param], @method), // fn foo(&self)\n+    fk_anon(ast::Sigil),                    // fn@(x, y) { ... }\n+    fk_fn_block,                            // |x, y| ...\n     fk_dtor(~[ty_param], ~[attribute], node_id /* self id */,\n             def_id /* parent class id */) // class destructor\n \n@@ -217,9 +217,12 @@ pub fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n       ty_tup(ts) => for ts.each |tt| {\n         (v.visit_ty)(*tt, e, v);\n       },\n-      ty_fn(f) => {\n+      ty_closure(f) => {\n+        for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n+        (v.visit_ty)(f.decl.output, e, v);\n+      }\n+      ty_bare_fn(f) => {\n         for f.decl.inputs.each |a| { (v.visit_ty)(a.ty, e, v); }\n-        visit_ty_param_bounds(f.bounds, e, v);\n         (v.visit_ty)(f.decl.output, e, v);\n       }\n       ty_path(p, _) => visit_path(p, e, v),"}, {"sha": "a6ec0e499c7f0ff5b2c4992b97efc22eafe5fc1d", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -1,3 +1,11 @@\n+S 2013-02-04 2f46b76\n+  freebsd-x86_64 d33b5ebbf3335f6a8a5cc23572f630ad66539830\n+  linux-i386 7537519ae3de82592d6150b9ca81cd4bf45d9457\n+  linux-x86_64 17472c4ffa6a59a6dbf45158827992c4404f7d92\n+  macos-i386 a8473c209a199822f9bf0132449a8c38374d4d42\n+  macos-x86_64 3213a4166ee59dfb1167b9a31c64b747ce65884c\n+  winnt-i386 74c718ee885193719afa2ae44f395399bf993dd3\n+\n S 2013-01-23 e8f4da7\n   macos-i386 6860345b8d05986ae1b20c7532fd9667dff31b2a\n   macos-x86_64 d0c6131e4afe93759af08d88e81cd7a8496595f0"}, {"sha": "8679d3a778607ee8b088b7cb8306ebb7e093cd52", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -20,5 +20,5 @@ pub type header_map = HashMap<~str, @DVec<@~str>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T: Copy>(req: header_map) {\n-  let _x = copy *(copy *req.get(~\"METHOD\"))[0u];\n+  let _x = copy *(copy *req.get(&~\"METHOD\"))[0u];\n }"}, {"sha": "68ba40749f2dd579ccad1dd1c96b807a351cbf37", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -42,7 +42,7 @@ fn old_int_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n             }\n \n             for uint::range(0, num_keys) |i| {\n-                assert map.get(i) == i+1;\n+                assert map.get(&i) == i+1;\n             }\n         }\n     }\n@@ -81,7 +81,7 @@ fn old_str_benchmarks(rng: @rand::Rng, num_keys: uint, results: &mut Results) {\n \n             for uint::range(0, num_keys) |i| {\n                 let s = uint::to_str(i);\n-                assert map.get(s) == i;\n+                assert map.get(&s) == i;\n             }\n         }\n     }"}, {"sha": "fafda39993ee2cc1cb276e8a91ca983be71dec19", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -83,7 +83,7 @@ fn str_set() {\n \n     let mut found = 0;\n     for int::range(0, 1000) |_i| {\n-        match s.find(r.gen_str(10)) {\n+        match s.find(&r.gen_str(10)) {\n           Some(_) => { found += 1; }\n           None => { }\n         }"}, {"sha": "222307bd240df4ecc7e050268031cb6a3dd6beca", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #[legacy_modes];\n+#[allow(deprecated_mode)];\n \n /*!\n \n@@ -247,8 +248,13 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n         }\n     }\n \n+    fn is_gray_factory() -> ~fn(c: &color) -> bool {\n+        let r: ~fn(c: &color) -> bool = is_gray;\n+        r\n+    }\n+\n     let mut i = 0;\n-    while par::any(colors, is_gray) {\n+    while par::any(colors, is_gray_factory) {\n         // Do the BFS.\n         log(info, fmt!(\"PBFS iteration %?\", i));\n         i += 1;\n@@ -257,14 +263,13 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n         let color = arc::ARC(move colors);\n \n         let color_vec = arc::get(&color); // FIXME #3387 requires this temp\n-        colors = do par::mapi_factory(*color_vec) {\n+        colors = do par::mapi(*color_vec) {\n             let colors = arc::clone(&color);\n             let graph = arc::clone(&graph);\n-            fn~(move graph, move colors, +i: uint, +c: color) -> color {\n-                let c : color = c;\n+            fn~(+i: uint, +c: &color) -> color {\n                 let colors = arc::get(&colors);\n                 let graph = arc::get(&graph);\n-                match c {\n+                match *c {\n                   white => {\n                     let i = i as node_id;\n \n@@ -290,11 +295,13 @@ fn pbfs(&&graph: arc::ARC<graph>, key: node_id) -> bfs_result {\n     }\n \n     // Convert the results.\n-    do par::map(colors) |c| {\n-        match *c {\n-          white => { -1i64 }\n-          black(parent) => { parent }\n-          _ => { die!(~\"Found remaining gray nodes in BFS\") }\n+    do par::map(colors) {\n+        fn~(c: &color) -> i64 {\n+            match *c {\n+                white => { -1i64 }\n+                black(parent) => { parent }\n+                _ => { die!(~\"Found remaining gray nodes in BFS\") }\n+            }\n         }\n     }\n }\n@@ -377,14 +384,15 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     log(info, ~\"Verifying tree and graph edges...\");\n \n-    let edges = copy edges;\n-    let status = do par::alli(tree) |u, v| {\n-        let u = u as node_id;\n-        if *v == -1i64 || u == root {\n-            true\n-        }\n-        else {\n-            edges.contains(&(u, *v)) || edges.contains(&(*v, u))\n+    let status = do par::alli(tree) {\n+        let edges = copy edges;\n+        fn~(+u: uint, v: &i64) -> bool {\n+            let u = u as node_id;\n+            if *v == -1i64 || u == root {\n+                true\n+            } else {\n+                edges.contains(&(u, *v)) || edges.contains(&(*v, u))\n+            }\n         }\n     };\n "}, {"sha": "811f39e4343db24b2fd538d98235fc8be5791a57", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -69,7 +69,7 @@ fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str {\n \n // given a map, search for the frequency of a pattern\n fn find(mm: HashMap<~[u8], uint>, key: ~str) -> uint {\n-   match mm.find(str::to_bytes(str::to_lower(key))) {\n+   match mm.find(&str::to_bytes(str::to_lower(key))) {\n       option::None      => { return 0u; }\n       option::Some(num) => { return num; }\n    }"}, {"sha": "5888dab3bb923840b56a3f1b1dbfd05408937d75", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -136,7 +136,7 @@ fn writer(path: ~str, pport: pipes::Port<Line>, size: uint)\n             while prev <= i {\n                 if lines.contains_key_ref(&prev) {\n                     debug!(\"WS %u\", prev);\n-                    cout.write(lines.get(prev));\n+                    cout.write(lines.get(&prev));\n                     done += 1_u;\n                     lines.remove(&prev);\n                     prev += 1_u;"}, {"sha": "8e5ab45bae8684591a86a86861b99c0f1f4c623d", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -15,6 +15,10 @@ extern mod std;\n use std::list::{List, Cons, Nil};\n use std::time::precise_time_s;\n \n+enum UniqueList {\n+    ULNil, ULCons(~UniqueList)\n+}\n+\n fn main() {\n     let (repeat, depth) = if os::getenv(~\"RUST_BENCH\").is_some() {\n         (50, 1000)\n@@ -43,7 +47,6 @@ struct State {\n     box: @nillist,\n     unique: ~nillist,\n     fn_box: fn@() -> @nillist,\n-    fn_unique: fn~() -> ~nillist,\n     tuple: (@nillist, ~nillist),\n     vec: ~[@nillist],\n     res: r\n@@ -76,22 +79,18 @@ fn recurse_or_fail(depth: int, st: Option<State>) {\n                 box: @Nil,\n                 unique: ~Nil,\n                 fn_box: fn@() -> @nillist { @Nil::<()> },\n-                fn_unique: fn~() -> ~nillist { ~Nil::<()> },\n                 tuple: (@Nil, ~Nil),\n                 vec: ~[@Nil],\n                 res: r(@Nil)\n             }\n           }\n           Some(st) => {\n             let fn_box = st.fn_box;\n-            let fn_unique = copy st.fn_unique;\n \n             State {\n                 box: @Cons((), st.box),\n                 unique: ~Cons((), @*st.unique),\n                 fn_box: fn@() -> @nillist { @Cons((), fn_box()) },\n-                fn_unique: fn~(move fn_unique) -> ~nillist\n-                    { ~Cons((), @*fn_unique()) },\n                 tuple: (@Cons((), st.tuple.first()),\n                         ~Cons((), @*st.tuple.second())),\n                 vec: st.vec + ~[@Cons((), st.vec.last())],"}, {"sha": "c0430a6a8bb7dd0abb4e60592efe8db0a63a79ab", "filename": "src/test/compile-fail/functional-struct-update.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/64fedfbc4ef37b56f7bb12e2864f4011e4031ac5/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fedfbc4ef37b56f7bb12e2864f4011e4031ac5/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffunctional-struct-update.rs?ref=64fedfbc4ef37b56f7bb12e2864f4011e4031ac5", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct Bar {\n-    x: int,\n-}\n-\n-impl Bar : Drop {\n-    fn finalize(&self) {\n-        io::println(\"Goodbye, cruel world\");\n-    }\n-}\n-\n-struct Foo {\n-    x: int,\n-    y: Bar\n-}\n-\n-fn main() {\n-    let a = Foo { x: 1, y: Bar { x: 5 } };\n-    let c = Foo { x: 4, .. a}; //~ ERROR cannot copy field `y` of base expression, which has a noncopyable type\n-    io::println(fmt!(\"%?\", c));\n-}\n-"}, {"sha": "46ad7f64589446816ca5dd09533a0dfaaab4fe5d", "filename": "src/test/compile-fail/issue-3044.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: Non-function passed to a `do` function as its last argument, or wrong number of arguments passed to a `do` function\n fn main() {\n     let needlesArr: ~[char] = ~['a', 'f'];\n     do vec::foldr(needlesArr) |x, y| {\n+        //~^ ERROR 2 parameters were supplied (including the closure passed by the `do` keyword)\n+        //~^^ ERROR Unconstrained region variable #2\n+        //\n+        // this last error is, um, non-ideal.\n     }\n-// for some reason if I use the new error syntax for the two error messages this generates,\n-// the test runner gets confused -- tjc\n }\n "}, {"sha": "e72b73f8fa4c6836efa40130f809d1fc83d5764d", "filename": "src/test/compile-fail/issue-4523.rs", "status": "renamed", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4523.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,13 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn to_lambda1(f: fn@(uint) -> uint) -> fn@(uint) -> uint {\n-    return f;\n-}\n+fn foopy() {}\n \n-fn to_lambda2(b: fn(uint) -> uint) -> fn@(uint) -> uint {\n-    return to_lambda1(|x| b(x)); //~ ERROR illegal move from argument `b`\n-}\n+const f: fn() = foopy; //~ ERROR mismatched types: expected `&static/fn()`\n \n-fn main() {\n-}\n+fn main () {\n+    f();\n+}\n\\ No newline at end of file", "previous_filename": "src/test/compile-fail/block-arg-used-as-lambda-with-illegal-cap.rs"}, {"sha": "bc6dd8f5dc959c72c7c1c75701d003aa70b2a1f7", "filename": "src/test/compile-fail/kindck-owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -24,6 +24,6 @@ fn main() {\n     copy2(@&x); //~ ERROR missing `&static`\n \n     copy2(fn@() {});\n-    copy2(fn~() {}); //~ WARNING instantiating copy type parameter with a not implicitly copyable type\n-    copy2(fn&() {}); //~ ERROR missing `copy &static`\n+    copy2(fn~() {}); //~ ERROR missing `copy`\n+    copy2(fn&() {}); //~ ERROR missing `&static`\n }"}, {"sha": "660e5596ca55202df70be69a40466ae0bcd963d0", "filename": "src/test/compile-fail/moves-sru-moved-field.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-sru-moved-field.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -0,0 +1,27 @@\n+type Noncopyable = ~fn();\n+\n+struct Foo {\n+    copied: int,\n+    moved: ~int,\n+    noncopyable: Noncopyable\n+}\n+\n+fn test0(f: Foo, g: Noncopyable, h: Noncopyable) {\n+    // just copy implicitly copyable fields from `f`, no moves:\n+    let _b = Foo {moved: ~1, noncopyable: g, ..f};\n+    let _c = Foo {moved: ~2, noncopyable: h, ..f};\n+}\n+\n+fn test1(f: Foo, g: Noncopyable, h: Noncopyable) {\n+    // copying move-by-default fields from `f`, so move:\n+    let _b = Foo {noncopyable: g, ..f};\n+    let _c = Foo {noncopyable: h, ..f}; //~ ERROR use of moved value: `f`\n+}\n+\n+fn test2(f: Foo, g: Noncopyable) {\n+    // move non-copyable field\n+    let _b = Foo {copied: 22, moved: ~23, ..f};\n+    let _c = Foo {noncopyable: g, ..f}; //~ ERROR use of moved value: `f`\n+}\n+\n+fn main() {}"}, {"sha": "0fa61b1af52ef404ddd68f9939c33c199b921e3b", "filename": "src/test/compile-fail/no-binary-float-literal.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fcompile-fail%2Fno-binary-float-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fcompile-fail%2Fno-binary-float-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-binary-float-literal.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn ignore<T>(_x: T) {}\n+// error-pattern:binary float literal is not supported\n \n-pub fn main() {\n-    let f: fn@:Owned() = ||();\n-    ignore(f);\n+fn main() {\n+    0b101010f;\n+    0b101.010;\n+    0b101p4f;\n }\n-", "previous_filename": "src/test/run-pass/bounded-fn-type.rs"}, {"sha": "4abb6093b2443a221fb691aeed8f9ada8a2c0250", "filename": "src/test/compile-fail/no-hex-float-literal.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fcompile-fail%2Fno-hex-float-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fcompile-fail%2Fno-hex-float-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-hex-float-literal.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// error-pattern:hexadecimal float literal is not supported\n+\n fn main() {\n-    let x = 3;\n-    fn blah(_a: extern fn()) {}\n-    blah(|| {\n-        log(debug, x); //~ ERROR attempted dynamic environment capture\n-    });\n-}\n\\ No newline at end of file\n+    0xABC.Df;\n+    0x567.89;\n+    0xDEAD.BEEFp-2f;\n+}", "previous_filename": "src/test/compile-fail/bad-var-env-capture-in-block-arg.rs"}, {"sha": "6f1f1aba459306b560cf231d084acd94f9376581", "filename": "src/test/compile-fail/unop-neg-bool.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fcompile-fail%2Funop-neg-bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Fcompile-fail%2Funop-neg-bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funop-neg-bool.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    -true; //~ ERROR cannot apply unary operator `-` to type `bool`\n+}"}, {"sha": "d7a285d58e66283232d9bb62eb7efbec1236e614", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -49,7 +49,7 @@ mod map_reduce {\n         fn emit(im: oldmap::HashMap<~str, int>, ctrl: SharedChan<ctrl_proto>, key: ~str,\n                 val: ~str) {\n             let mut c;\n-            match im.find(copy key) {\n+            match im.find(&key) {\n               Some(_c) => { c = _c }\n               None => {\n                   let (pp, cc) = stream();\n@@ -88,7 +88,7 @@ mod map_reduce {\n               mapper_done => { num_mappers -= 1; }\n               find_reducer(k, cc) => {\n                 let mut c;\n-                match reducers.find(str::from_bytes(k)) {\n+                match reducers.find(&str::from_bytes(k)) {\n                   Some(_c) => { c = _c; }\n                   None => { c = 0; }\n                 }"}, {"sha": "9b852cbc635aa213167f3a4748e9b3ce959e2d1c", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -29,11 +29,11 @@ fn calllink08() { unsafe { rustrt::get_task_id(); } }\n fn calllink09() { unsafe { rustrt::rust_sched_threads(); } }\n fn calllink10() { unsafe { rustrt::rust_get_task(); } }\n \n-fn runtest(f: fn~(), frame_backoff: u32) {\n+fn runtest(f: extern fn(), frame_backoff: u32) {\n     runtest2(f, frame_backoff, 0 as *u8);\n }\n \n-fn runtest2(f: fn~(), frame_backoff: u32, last_stk: *u8) -> u32 {\n+fn runtest2(f: extern fn(), frame_backoff: u32, last_stk: *u8) -> u32 {\n     unsafe {\n         let curr_stk = rustrt::debug_get_stk_seg();\n         if (last_stk != curr_stk && last_stk != 0 as *u8) {\n@@ -67,6 +67,6 @@ pub fn main() {\n         let f = *f;\n         let sz = rng.next() % 256u32 + 256u32;\n         let frame_backoff = rng.next() % 10u32 + 1u32;\n-        task::try(|move f| runtest(f, frame_backoff) );\n+        task::try(|| runtest(f, frame_backoff) );\n     }\n }"}, {"sha": "18c446fe3505401d82d7be07467ccefd2db633bb", "filename": "src/test/run-pass/newtype.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Frun-pass%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Frun-pass%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewtype.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -16,5 +16,6 @@ fn compute(i: mytype) -> int { return i.val + 20; }\n \n pub fn main() {\n     let myval = mytype(Mytype{compute: compute, val: 30});\n+    io::println(fmt!(\"%d\", compute(myval)));\n     assert ((myval.compute)(myval) == 50);\n }"}, {"sha": "a3b03daf02fbff33259e612e30287fd78c8914e4", "filename": "src/test/run-pass/pipe-pingpong-bounded.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -37,8 +37,8 @@ mod pingpong {\n             }\n         };\n         do pipes::entangle_buffer(move buffer) |buffer, data| {\n-            data.ping.set_buffer_(buffer);\n-            data.pong.set_buffer_(buffer);\n+            data.ping.set_buffer(buffer);\n+            data.pong.set_buffer(buffer);\n             ptr::addr_of(&(data.ping))\n         }\n     }"}, {"sha": "520ddf3f73a753f146e8858d02e74e236f5bd067", "filename": "src/test/run-pass/sendfn-deep-copy.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/64fedfbc4ef37b56f7bb12e2864f4011e4031ac5/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64fedfbc4ef37b56f7bb12e2864f4011e4031ac5/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendfn-deep-copy.rs?ref=64fedfbc4ef37b56f7bb12e2864f4011e4031ac5", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn main() { test05(); }\n-\n-fn mk_counter<A:Copy>() -> fn~(A) -> (A,uint) {\n-    // The only reason that the counter is generic is so that it closes\n-    // over both a type descriptor and some data.\n-    let v = ~[mut 0u];\n-    return fn~(a: A) -> (A,uint) {\n-        let n = v[0];\n-        v[0] = n + 1u;\n-        (a, n)\n-    };\n-}\n-\n-fn test05() {\n-    let fp0 = mk_counter::<float>();\n-\n-    assert (5.3f, 0u) == fp0(5.3f);\n-    assert (5.5f, 1u) == fp0(5.5f);\n-\n-    let fp1 = copy fp0;\n-\n-    assert (5.3f, 2u) == fp0(5.3f);\n-    assert (5.3f, 2u) == fp1(5.3f);\n-    assert (5.5f, 3u) == fp0(5.5f);\n-    assert (5.5f, 3u) == fp1(5.5f);\n-}"}, {"sha": "1f4df7be1f3522cc36090412d89ea9d69c8ff944", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=46df7985a5f3e1e1a50d0f5f81f32bb1e4be8967", "patch": "@@ -28,11 +28,11 @@ fn checktests() {\n     // Pull the tests out of the secreturn test module\n     let tests = __test::tests();\n \n-    let shouldignore = option::get(\n-        vec::find(tests, |t| t.name == ~\"shouldignore\" ));\n-    assert shouldignore.ignore == true;\n+    assert vec::any(\n+        tests,\n+        |t| t.desc.name == ~\"shouldignore\" && t.desc.ignore);\n \n-    let shouldnotignore = option::get(\n-        vec::find(tests, |t| t.name == ~\"shouldnotignore\" ));\n-    assert shouldnotignore.ignore == false;\n+    assert vec::any(\n+        tests,\n+        |t| t.desc.name == ~\"shouldnotignore\" && !t.desc.ignore);\n }\n\\ No newline at end of file"}]}