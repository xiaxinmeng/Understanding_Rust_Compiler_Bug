{"sha": "d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "node_id": "C_kwDOAAsO6NoAKGQ1ZTdmNDc4MmU0YjY5OTcyOGQwYTA4MjAwZWNkMWE1NGQ1NmE4NWQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-16T20:31:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-16T20:31:42Z"}, "message": "Auto merge of #99346 - matthiaskrgr:rollup-p4dl1qt, r=matthiaskrgr\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #98582 (Allow destructuring opaque types in their defining scopes)\n - #99213 (migrate some of `rustc_passes::check_attr`'s diagnostics and derive improvements)\n - #99258 (Provide structured suggestion for dropped temp value)\n - #99259 (interpret/visitor: support visiting with a PlaceTy)\n - #99287 ([rustdoc-json] JSON no longer inlines)\n - #99290 (Revert \"Highlight conflicting param-env candidates\")\n - #99316 (docs: add missing word)\n - #99317 (Borrow Vec<T, A> as [T])\n - #99323 (Fix flakyness of GUI tests)\n - #99342 (Avoid some `Symbol` to `String` conversions)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "2ecfa500407be289cf19a91c39d2ce7bdd511731", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ecfa500407be289cf19a91c39d2ce7bdd511731"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "html_url": "https://github.com/rust-lang/rust/commit/d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7210e46dc69a4b197a313d093fe145722c248b7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7210e46dc69a4b197a313d093fe145722c248b7d", "html_url": "https://github.com/rust-lang/rust/commit/7210e46dc69a4b197a313d093fe145722c248b7d"}, {"sha": "6277ac2fb8bf97cd910a0a841c6924b246d32c44", "url": "https://api.github.com/repos/rust-lang/rust/commits/6277ac2fb8bf97cd910a0a841c6924b246d32c44", "html_url": "https://github.com/rust-lang/rust/commit/6277ac2fb8bf97cd910a0a841c6924b246d32c44"}], "stats": {"total": 3485, "additions": 2270, "deletions": 1215}, "files": [{"sha": "9a8d9d40b6e45a3c2b2ebc82cd95b15b6aa7a0de", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -4239,6 +4239,7 @@ dependencies = [\n  \"rustc_hir\",\n  \"rustc_index\",\n  \"rustc_lexer\",\n+ \"rustc_macros\",\n  \"rustc_middle\",\n  \"rustc_serialize\",\n  \"rustc_session\","}, {"sha": "ee96dbc2f60b480228082662b1ed0ec160266d0e", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 71, "deletions": 7, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -7,7 +7,7 @@ use rustc_errors::{\n };\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::intravisit::{walk_expr, Visitor};\n+use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::ObligationCause;\n@@ -23,7 +23,7 @@ use rustc_middle::ty::{\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::symbol::sym;\n-use rustc_span::{BytePos, Span};\n+use rustc_span::{BytePos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::TraitEngineExt as _;\n \n@@ -1227,8 +1227,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     from_closure: false,\n                     region_name:\n                         RegionName {\n-                            source:\n-                                RegionNameSource::AnonRegionFromUpvar(upvar_span, ref upvar_name),\n+                            source: RegionNameSource::AnonRegionFromUpvar(upvar_span, upvar_name),\n                             ..\n                         },\n                     span,\n@@ -1500,7 +1499,70 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             | BorrowExplanation::UsedLaterInLoop(..)\n             | BorrowExplanation::UsedLaterWhenDropped { .. } => {\n                 // Only give this note and suggestion if it could be relevant.\n-                err.note(\"consider using a `let` binding to create a longer lived value\");\n+                let sm = self.infcx.tcx.sess.source_map();\n+                let mut suggested = false;\n+                let msg = \"consider using a `let` binding to create a longer lived value\";\n+\n+                /// We check that there's a single level of block nesting to ensure always correct\n+                /// suggestions. If we don't, then we only provide a free-form message to avoid\n+                /// misleading users in cases like `src/test/ui/nll/borrowed-temporary-error.rs`.\n+                /// We could expand the analysis to suggest hoising all of the relevant parts of\n+                /// the users' code to make the code compile, but that could be too much.\n+                struct NestedStatementVisitor {\n+                    span: Span,\n+                    current: usize,\n+                    found: usize,\n+                }\n+\n+                impl<'tcx> Visitor<'tcx> for NestedStatementVisitor {\n+                    fn visit_block(&mut self, block: &hir::Block<'tcx>) {\n+                        self.current += 1;\n+                        walk_block(self, block);\n+                        self.current -= 1;\n+                    }\n+                    fn visit_expr(&mut self, expr: &hir::Expr<'tcx>) {\n+                        if self.span == expr.span {\n+                            self.found = self.current;\n+                        }\n+                        walk_expr(self, expr);\n+                    }\n+                }\n+                let source_info = self.body.source_info(location);\n+                if let Some(scope) = self.body.source_scopes.get(source_info.scope)\n+                    && let ClearCrossCrate::Set(scope_data) = &scope.local_data\n+                    && let Some(node) = self.infcx.tcx.hir().find(scope_data.lint_root)\n+                    && let Some(id) = node.body_id()\n+                    && let hir::ExprKind::Block(block, _) = self.infcx.tcx.hir().body(id).value.kind\n+                {\n+                    for stmt in block.stmts {\n+                        let mut visitor = NestedStatementVisitor {\n+                            span: proper_span,\n+                            current: 0,\n+                            found: 0,\n+                        };\n+                        visitor.visit_stmt(stmt);\n+                        if visitor.found == 0\n+                            && stmt.span.contains(proper_span)\n+                            && let Some(p) = sm.span_to_margin(stmt.span)\n+                            && let Ok(s) = sm.span_to_snippet(proper_span)\n+                        {\n+                            let addition = format!(\"let binding = {};\\n{}\", s, \" \".repeat(p));\n+                            err.multipart_suggestion_verbose(\n+                                msg,\n+                                vec![\n+                                    (stmt.span.shrink_to_lo(), addition),\n+                                    (proper_span, \"binding\".to_string()),\n+                                ],\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                            suggested = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+                if !suggested {\n+                    err.note(msg);\n+                }\n             }\n             _ => {}\n         }\n@@ -1699,7 +1761,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         borrow_span: Span,\n         name: &Option<String>,\n         upvar_span: Span,\n-        upvar_name: &str,\n+        upvar_name: Symbol,\n         escape_span: Span,\n     ) -> DiagnosticBuilder<'cx, ErrorGuaranteed> {\n         let tcx = self.infcx.tcx;\n@@ -2093,7 +2155,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                             }\n                             StorageDeadOrDrop::Destructor(_) => kind,\n                         },\n-                        ProjectionElem::Field(..) | ProjectionElem::Downcast(..) => {\n+                        ProjectionElem::OpaqueCast { .. }\n+                        | ProjectionElem::Field(..)\n+                        | ProjectionElem::Downcast(..) => {\n                             match place_ty.ty.kind() {\n                                 ty::Adt(def, _) if def.has_dtor(tcx) => {\n                                     // Report the outermost adt with a destructor"}, {"sha": "72aee0267ac1e14f4bb125f53a96f34d664786cb", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::mir::{\n };\n use rustc_middle::ty::adjustment::PointerCast;\n use rustc_middle::ty::{self, RegionVid, TyCtxt};\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{sym, DesugaringKind, Span};\n \n use crate::region_infer::BlameConstraint;\n@@ -282,7 +282,7 @@ impl<'tcx> BorrowExplanation<'tcx> {\n     ) {\n         if let ConstraintCategory::OpaqueType = category {\n             let suggestable_name =\n-                if region_name.was_named() { region_name.to_string() } else { \"'_\".to_string() };\n+                if region_name.was_named() { region_name.name } else { kw::UnderscoreLifetime };\n \n             let msg = format!(\n                 \"you can add a bound to the {}to make it last less than `'static` and match `{}`\","}, {"sha": "fada3d45fbed856cb088632a1526a193f431c79b", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -226,6 +226,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 }\n                 ProjectionElem::Downcast(..) if including_downcast.0 => return None,\n                 ProjectionElem::Downcast(..) => (),\n+                ProjectionElem::OpaqueCast(..) => (),\n                 ProjectionElem::Field(field, _ty) => {\n                     // FIXME(project-rfc_2229#36): print capture precisely here.\n                     if let Some(field) = self.is_upvar_field_projection(PlaceRef {\n@@ -286,6 +287,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     PlaceRef { local, projection: proj_base }.ty(self.body, self.infcx.tcx)\n                 }\n                 ProjectionElem::Downcast(..) => place.ty(self.body, self.infcx.tcx),\n+                ProjectionElem::OpaqueCast(ty) => PlaceTy::from_ty(*ty),\n                 ProjectionElem::Field(_, field_type) => PlaceTy::from_ty(*field_type),\n             },\n         };"}, {"sha": "cb7077fe621715e0ecb7133b3ca70607a03ac913", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -169,6 +169,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         ..,\n                         ProjectionElem::Index(_)\n                         | ProjectionElem::ConstantIndex { .. }\n+                        | ProjectionElem::OpaqueCast { .. }\n                         | ProjectionElem::Subslice { .. }\n                         | ProjectionElem::Downcast(..),\n                     ],"}, {"sha": "0e6a05478a07ec2befcc82da3a0faac374e2f0d8", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -19,8 +19,7 @@ use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::Region;\n use rustc_middle::ty::TypeVisitor;\n use rustc_middle::ty::{self, RegionVid, Ty};\n-use rustc_span::symbol::sym;\n-use rustc_span::symbol::Ident;\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n \n use crate::borrowck_errors;\n@@ -758,7 +757,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 return;\n             };\n \n-            let lifetime = if f.has_name() { fr_name.to_string() } else { \"'_\".to_string() };\n+            let lifetime = if f.has_name() { fr_name.name } else { kw::UnderscoreLifetime };\n \n             let arg = match param.param.pat.simple_ident() {\n                 Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n@@ -770,7 +769,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 self.infcx.tcx,\n                 diag,\n                 fn_returns,\n-                lifetime,\n+                lifetime.to_string(),\n                 Some(arg),\n                 captures,\n                 Some((param.param_ty_span, param.param_ty.to_string())),"}, {"sha": "4cf1ac4d7abc0ca28cf3f9f327eac9d4eaac0746", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -34,13 +34,13 @@ pub(crate) enum RegionNameSource {\n     /// The `'static` region.\n     Static,\n     /// The free region corresponding to the environment of a closure.\n-    SynthesizedFreeEnvRegion(Span, String),\n+    SynthesizedFreeEnvRegion(Span, &'static str),\n     /// The region corresponding to an argument.\n     AnonRegionFromArgument(RegionNameHighlight),\n     /// The region corresponding to a closure upvar.\n-    AnonRegionFromUpvar(Span, String),\n+    AnonRegionFromUpvar(Span, Symbol),\n     /// The region corresponding to the return type of a closure.\n-    AnonRegionFromOutput(RegionNameHighlight, String),\n+    AnonRegionFromOutput(RegionNameHighlight, &'static str),\n     /// The region from a type yielded by a generator.\n     AnonRegionFromYieldTy(Span, String),\n     /// An anonymous region from an async fn.\n@@ -110,7 +110,7 @@ impl RegionName {\n             }\n             RegionNameSource::SynthesizedFreeEnvRegion(span, note) => {\n                 diag.span_label(*span, format!(\"lifetime `{self}` represents this closure's body\"));\n-                diag.note(note);\n+                diag.note(*note);\n             }\n             RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::CannotMatchHirTy(\n                 span,\n@@ -350,10 +350,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n                     Some(RegionName {\n                         name: region_name,\n-                        source: RegionNameSource::SynthesizedFreeEnvRegion(\n-                            fn_decl_span,\n-                            note.to_string(),\n-                        ),\n+                        source: RegionNameSource::SynthesizedFreeEnvRegion(fn_decl_span, note),\n                     })\n                 }\n \n@@ -678,7 +675,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         Some(RegionName {\n             name: region_name,\n-            source: RegionNameSource::AnonRegionFromUpvar(upvar_span, upvar_name.to_string()),\n+            source: RegionNameSource::AnonRegionFromUpvar(upvar_span, upvar_name),\n         })\n     }\n \n@@ -756,7 +753,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         Some(RegionName {\n             name: self.synthesize_region_name(),\n-            source: RegionNameSource::AnonRegionFromOutput(highlight, mir_description.to_string()),\n+            source: RegionNameSource::AnonRegionFromOutput(highlight, mir_description),\n         })\n     }\n "}, {"sha": "74321ddcd99191ea77e8822f8d96f90c5226ab19", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1788,6 +1788,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         for (place_base, elem) in place.iter_projections().rev() {\n             match elem {\n                 ProjectionElem::Index(_/*operand*/) |\n+                ProjectionElem::OpaqueCast(_) |\n                 ProjectionElem::ConstantIndex { .. } |\n                 // assigning to P[i] requires P to be valid.\n                 ProjectionElem::Downcast(_/*adt_def*/, _/*variant_idx*/) =>\n@@ -2179,6 +2180,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     | ProjectionElem::Index(..)\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. }\n+                    | ProjectionElem::OpaqueCast { .. }\n                     | ProjectionElem::Downcast(..) => {\n                         let upvar_field_projection = self.is_upvar_field_projection(place);\n                         if let Some(field) = upvar_field_projection {"}, {"sha": "5b67e6aa1cffa9c2e8339dd07c6ff1e25f877cca", "filename": "compiler/rustc_borrowck/src/places_conflict.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplaces_conflict.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -255,6 +255,7 @@ fn place_components_conflict<'tcx>(\n                 | (ProjectionElem::Index { .. }, _, _)\n                 | (ProjectionElem::ConstantIndex { .. }, _, _)\n                 | (ProjectionElem::Subslice { .. }, _, _)\n+                | (ProjectionElem::OpaqueCast { .. }, _, _)\n                 | (ProjectionElem::Downcast { .. }, _, _) => {\n                     // Recursive case. This can still be disjoint on a\n                     // further iteration if this a shallow access and\n@@ -322,6 +323,17 @@ fn place_projection_conflict<'tcx>(\n             debug!(\"place_element_conflict: DISJOINT-OR-EQ-DEREF\");\n             Overlap::EqualOrDisjoint\n         }\n+        (ProjectionElem::OpaqueCast(v1), ProjectionElem::OpaqueCast(v2)) => {\n+            if v1 == v2 {\n+                // same type - recur.\n+                debug!(\"place_element_conflict: DISJOINT-OR-EQ-OPAQUE\");\n+                Overlap::EqualOrDisjoint\n+            } else {\n+                // Different types. Disjoint!\n+                debug!(\"place_element_conflict: DISJOINT-OPAQUE\");\n+                Overlap::Disjoint\n+            }\n+        }\n         (ProjectionElem::Field(f1, _), ProjectionElem::Field(f2, _)) => {\n             if f1 == f2 {\n                 // same field (e.g., `a.y` vs. `a.y`) - recur.\n@@ -525,6 +537,7 @@ fn place_projection_conflict<'tcx>(\n             | ProjectionElem::Field(..)\n             | ProjectionElem::Index(..)\n             | ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::OpaqueCast { .. }\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Downcast(..),\n             _,"}, {"sha": "2b50cbac9a02da128786fa86e3ed5d80dcfa8b44", "filename": "compiler/rustc_borrowck/src/prefixes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fprefixes.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -81,6 +81,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         }\n                         ProjectionElem::Downcast(..)\n                         | ProjectionElem::Subslice { .. }\n+                        | ProjectionElem::OpaqueCast { .. }\n                         | ProjectionElem::ConstantIndex { .. }\n                         | ProjectionElem::Index(_) => {\n                             cursor = cursor_base;"}, {"sha": "8e763a02af33f11b13726a65a77a0b014d0440eb", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -790,6 +790,19 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n                 }\n                 PlaceTy::from_ty(fty)\n             }\n+            ProjectionElem::OpaqueCast(ty) => {\n+                let ty = self.sanitize_type(place, ty);\n+                let ty = self.cx.normalize(ty, location);\n+                self.cx\n+                    .eq_types(\n+                        base.ty,\n+                        ty,\n+                        location.to_locations(),\n+                        ConstraintCategory::TypeAnnotation,\n+                    )\n+                    .unwrap();\n+                PlaceTy::from_ty(ty)\n+            }\n         }\n     }\n \n@@ -1195,10 +1208,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 tcx,\n                 self.param_env,\n                 proj,\n-                |this, field, ()| {\n+                |this, field, _| {\n                     let ty = this.field_ty(tcx, field);\n                     self.normalize(ty, locations)\n                 },\n+                |_, _| unreachable!(),\n             );\n             curr_projected_ty = projected_ty;\n         }\n@@ -2493,6 +2507,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n                 ProjectionElem::Field(..)\n                 | ProjectionElem::Downcast(..)\n+                | ProjectionElem::OpaqueCast(..)\n                 | ProjectionElem::Index(..)\n                 | ProjectionElem::ConstantIndex { .. }\n                 | ProjectionElem::Subslice { .. } => {"}, {"sha": "54652623d940187536a7bea565b00615805e1ee2", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -825,6 +825,7 @@ pub(crate) fn codegen_place<'tcx>(\n                     cplace = cplace.place_deref(fx);\n                 }\n             }\n+            PlaceElem::OpaqueCast(ty) => cplace = cplace.place_opaque_cast(fx, ty),\n             PlaceElem::Field(field, _ty) => {\n                 cplace = cplace.place_field(fx, field);\n             }"}, {"sha": "8ff35d2f76dbfb62c4c79b5ff9f1dbc3234343a1", "filename": "compiler/rustc_codegen_cranelift/src/value_and_place.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvalue_and_place.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -615,6 +615,14 @@ impl<'tcx> CPlace<'tcx> {\n         }\n     }\n \n+    pub(crate) fn place_opaque_cast(\n+        self,\n+        fx: &mut FunctionCx<'_, '_, 'tcx>,\n+        ty: Ty<'tcx>,\n+    ) -> CPlace<'tcx> {\n+        CPlace { inner: self.inner, layout: fx.layout_of(ty) }\n+    }\n+\n     pub(crate) fn place_field(\n         self,\n         fx: &mut FunctionCx<'_, '_, 'tcx>,"}, {"sha": "421d6f807ae8e128f855a18a676da5a41dd24c02", "filename": "compiler/rustc_codegen_ssa/src/mir/place.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fplace.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -411,6 +411,21 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         downcast\n     }\n \n+    pub fn project_type<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        &self,\n+        bx: &mut Bx,\n+        ty: Ty<'tcx>,\n+    ) -> Self {\n+        let mut downcast = *self;\n+        downcast.layout = bx.cx().layout_of(ty);\n+\n+        // Cast to the appropriate type.\n+        let variant_ty = bx.cx().backend_type(downcast.layout);\n+        downcast.llval = bx.pointercast(downcast.llval, bx.cx().type_ptr_to(variant_ty));\n+\n+        downcast\n+    }\n+\n     pub fn storage_live<Bx: BuilderMethods<'a, 'tcx, Value = V>>(&self, bx: &mut Bx) {\n         bx.lifetime_start(self.llval, self.layout.size);\n     }\n@@ -459,6 +474,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 mir::ProjectionElem::Field(ref field, _) => {\n                     cg_base.project_field(bx, field.index())\n                 }\n+                mir::ProjectionElem::OpaqueCast(ty) => cg_base.project_type(bx, ty),\n                 mir::ProjectionElem::Index(index) => {\n                     let index = &mir::Operand::Copy(mir::Place::from(index));\n                     let index = self.codegen_operand(bx, index);"}, {"sha": "8fff4571d127c4ac263f7856e50b6a28051eb990", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -436,7 +436,7 @@ fn valtree_into_mplace<'tcx>(\n \n                         let offset = place_adjusted.layout.fields.offset(i);\n                         place\n-                            .offset(\n+                            .offset_with_meta(\n                                 offset,\n                                 MemPlaceMeta::Meta(Scalar::from_machine_usize(\n                                     num_elems as u64,"}, {"sha": "22dc1e80f13a825e6a057d685614c5e635180419", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -297,15 +297,15 @@ impl<'tcx, Tag: Provenance> OpTy<'tcx, Tag> {\n         }\n     }\n \n-    pub fn offset(\n+    pub fn offset_with_meta(\n         &self,\n         offset: Size,\n         meta: MemPlaceMeta<Tag>,\n         layout: TyAndLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n         match self.try_as_mplace() {\n-            Ok(mplace) => Ok(mplace.offset(offset, meta, layout, cx)?.into()),\n+            Ok(mplace) => Ok(mplace.offset_with_meta(offset, meta, layout, cx)?.into()),\n             Err(imm) => {\n                 assert!(\n                     matches!(*imm, Immediate::Uninit),\n@@ -317,6 +317,16 @@ impl<'tcx, Tag: Provenance> OpTy<'tcx, Tag> {\n             }\n         }\n     }\n+\n+    pub fn offset(\n+        &self,\n+        offset: Size,\n+        layout: TyAndLayout<'tcx>,\n+        cx: &impl HasDataLayout,\n+    ) -> InterpResult<'tcx, Self> {\n+        assert!(!layout.is_unsized());\n+        self.offset_with_meta(offset, MemPlaceMeta::None, layout, cx)\n+    }\n }\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {"}, {"sha": "a29a1492c8ef32c756ffeb8d04c2208fa07cf8e4", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -163,7 +163,7 @@ impl<Tag: Provenance> MemPlace<Tag> {\n     }\n \n     #[inline]\n-    pub fn offset<'tcx>(\n+    pub fn offset_with_meta<'tcx>(\n         self,\n         offset: Size,\n         meta: MemPlaceMeta<Tag>,\n@@ -199,20 +199,30 @@ impl<'tcx, Tag: Provenance> MPlaceTy<'tcx, Tag> {\n     }\n \n     #[inline]\n-    pub fn offset(\n+    pub fn offset_with_meta(\n         &self,\n         offset: Size,\n         meta: MemPlaceMeta<Tag>,\n         layout: TyAndLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n         Ok(MPlaceTy {\n-            mplace: self.mplace.offset(offset, meta, cx)?,\n+            mplace: self.mplace.offset_with_meta(offset, meta, cx)?,\n             align: self.align.restrict_for_offset(offset),\n             layout,\n         })\n     }\n \n+    pub fn offset(\n+        &self,\n+        offset: Size,\n+        layout: TyAndLayout<'tcx>,\n+        cx: &impl HasDataLayout,\n+    ) -> InterpResult<'tcx, Self> {\n+        assert!(!layout.is_unsized());\n+        self.offset_with_meta(offset, MemPlaceMeta::None, layout, cx)\n+    }\n+\n     #[inline]\n     pub fn from_aligned_ptr(ptr: Pointer<Option<Tag>>, layout: TyAndLayout<'tcx>) -> Self {\n         MPlaceTy { mplace: MemPlace::from_ptr(ptr), layout, align: layout.align.abi }"}, {"sha": "704dc6db060715d9b499e4c25a9d2a9b59783c49", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -63,7 +63,7 @@ where\n \n         // We do not look at `base.layout.align` nor `field_layout.align`, unlike\n         // codegen -- mostly to see if we can get away with that\n-        base.offset(offset, meta, field_layout, self)\n+        base.offset_with_meta(offset, meta, field_layout, self)\n     }\n \n     /// Gets the place of a field inside the place, and also the field's type.\n@@ -193,9 +193,7 @@ where\n                 let offset = stride * index; // `Size` multiplication\n                 // All fields have the same layout.\n                 let field_layout = base.layout.field(self, 0);\n-                assert!(!field_layout.is_unsized());\n-\n-                base.offset(offset, MemPlaceMeta::None, field_layout, self)\n+                base.offset(offset, field_layout, self)\n             }\n             _ => span_bug!(\n                 self.cur_span(),\n@@ -215,10 +213,10 @@ where\n         let abi::FieldsShape::Array { stride, .. } = base.layout.fields else {\n             span_bug!(self.cur_span(), \"operand_array_fields: expected an array layout\");\n         };\n-        let layout = base.layout.field(self, 0);\n+        let field_layout = base.layout.field(self, 0);\n         let dl = &self.tcx.data_layout;\n         // `Size` multiplication\n-        Ok((0..len).map(move |i| base.offset(stride * i, MemPlaceMeta::None, layout, dl)))\n+        Ok((0..len).map(move |i| base.offset(stride * i, field_layout, dl)))\n     }\n \n     /// Index into an array.\n@@ -326,7 +324,7 @@ where\n             }\n         };\n         let layout = self.layout_of(ty)?;\n-        base.offset(from_offset, meta, layout, self)\n+        base.offset_with_meta(from_offset, meta, layout, self)\n     }\n \n     pub fn place_subslice(\n@@ -351,6 +349,11 @@ where\n     ) -> InterpResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n+            OpaqueCast(ty) => {\n+                let mut place = *base;\n+                place.layout = self.layout_of(ty)?;\n+                place\n+            }\n             Field(field, _) => self.place_field(base, field.index())?,\n             Downcast(_, variant) => self.place_downcast(base, variant)?,\n             Deref => self.deref_operand(&self.place_to_op(base)?)?.into(),\n@@ -375,6 +378,11 @@ where\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc_middle::mir::ProjectionElem::*;\n         Ok(match proj_elem {\n+            OpaqueCast(ty) => {\n+                let mut op = *base;\n+                op.layout = self.layout_of(ty)?;\n+                op\n+            }\n             Field(field, _) => self.operand_field(base, field.index())?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),"}, {"sha": "2e5492ecf56019064edf48881e34bd3d6a97b9cc", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -853,7 +853,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 self.visit_scalar(scalar, scalar_layout)?;\n             }\n             Abi::ScalarPair(a_layout, b_layout) => {\n-                // We would validate these things as we descend into the fields,\n+                // There is no `rustc_layout_scalar_valid_range_start` for pairs, so\n+                // we would validate these things as we descend into the fields,\n                 // but that can miss bugs in layout computation. Layout computation\n                 // is subtle due to enums having ScalarPair layout, where one field\n                 // is the discriminant.\n@@ -867,7 +868,8 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             }\n             Abi::Vector { .. } => {\n                 // No checks here, we assume layout computation gets this right.\n-                // (This is harder to check since Miri does not represent these as `Immediate`.)\n+                // (This is harder to check since Miri does not represent these as `Immediate`. We\n+                // also cannot use field projections since this might be a newtype around a vector.)\n             }\n             Abi::Aggregate { .. } => {\n                 // Nothing to do."}, {"sha": "f6a0c19d2595332c2bff285802d5251374a5764b", "filename": "compiler/rustc_const_eval/src/interpret/visitor.rs", "status": "modified", "additions": 237, "deletions": 35, "changes": 272, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvisitor.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -8,23 +8,33 @@ use rustc_target::abi::{FieldsShape, VariantIdx, Variants};\n \n use std::num::NonZeroUsize;\n \n-use super::{InterpCx, MPlaceTy, Machine, OpTy};\n+use super::{InterpCx, MPlaceTy, Machine, OpTy, PlaceTy};\n \n-// A thing that we can project into, and that has a layout.\n-// This wouldn't have to depend on `Machine` but with the current type inference,\n-// that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n+/// A thing that we can project into, and that has a layout.\n+/// This wouldn't have to depend on `Machine` but with the current type inference,\n+/// that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     /// Gets this value's layout.\n     fn layout(&self) -> TyAndLayout<'tcx>;\n \n-    /// Makes this into an `OpTy`.\n-    fn to_op(&self, ecx: &InterpCx<'mir, 'tcx, M>)\n-    -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+    /// Makes this into an `OpTy`, in a cheap way that is good for reading.\n+    fn to_op_for_read(\n+        &self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+\n+    /// Makes this into an `OpTy`, in a potentially more expensive way that is good for projections.\n+    fn to_op_for_proj(\n+        &self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        self.to_op_for_read(ecx)\n+    }\n \n     /// Creates this from an `OpTy`.\n     ///\n-    /// If `to_op` only ever produces `Indirect` operands, then this one is definitely `Indirect`.\n-    fn from_op(mplace: OpTy<'tcx, M::PointerTag>) -> Self;\n+    /// If `to_op_for_proj` only ever produces `Indirect` operands, then this one is definitely `Indirect`.\n+    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self;\n \n     /// Projects to the given enum variant.\n     fn project_downcast(\n@@ -41,25 +51,67 @@ pub trait Value<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n     ) -> InterpResult<'tcx, Self>;\n }\n \n-// Operands and memory-places are both values.\n-// Places in general are not due to `place_field` having to do `force_allocation`.\n+/// A thing that we can project into given *mutable* access to `ecx`, and that has a layout.\n+/// This wouldn't have to depend on `Machine` but with the current type inference,\n+/// that's just more convenient to work with (avoids repeating all the `Machine` bounds).\n+pub trait ValueMut<'mir, 'tcx, M: Machine<'mir, 'tcx>>: Copy {\n+    /// Gets this value's layout.\n+    fn layout(&self) -> TyAndLayout<'tcx>;\n+\n+    /// Makes this into an `OpTy`, in a cheap way that is good for reading.\n+    fn to_op_for_read(\n+        &self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+\n+    /// Makes this into an `OpTy`, in a potentially more expensive way that is good for projections.\n+    fn to_op_for_proj(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n+\n+    /// Creates this from an `OpTy`.\n+    ///\n+    /// If `to_op_for_proj` only ever produces `Indirect` operands, then this one is definitely `Indirect`.\n+    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self;\n+\n+    /// Projects to the given enum variant.\n+    fn project_downcast(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        variant: VariantIdx,\n+    ) -> InterpResult<'tcx, Self>;\n+\n+    /// Projects to the n-th field.\n+    fn project_field(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self>;\n+}\n+\n+// We cannot have a general impl which shows that Value implies ValueMut. (When we do, it says we\n+// cannot `impl ValueMut for PlaceTy` because some downstream crate could `impl Value for PlaceTy`.)\n+// So we have some copy-paste here. (We could have a macro but since we only have 2 types with this\n+// double-impl, that would barely make the code shorter, if at all.)\n+\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tcx, M::PointerTag> {\n     #[inline(always)]\n     fn layout(&self) -> TyAndLayout<'tcx> {\n         self.layout\n     }\n \n     #[inline(always)]\n-    fn to_op(\n+    fn to_op_for_read(\n         &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(*self)\n     }\n \n     #[inline(always)]\n-    fn from_op(op: OpTy<'tcx, M::PointerTag>) -> Self {\n-        op\n+    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+        *op\n     }\n \n     #[inline(always)]\n@@ -81,6 +133,54 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M> for OpTy<'tc\n     }\n }\n \n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n+    for OpTy<'tcx, M::PointerTag>\n+{\n+    #[inline(always)]\n+    fn layout(&self) -> TyAndLayout<'tcx> {\n+        self.layout\n+    }\n+\n+    #[inline(always)]\n+    fn to_op_for_read(\n+        &self,\n+        _ecx: &InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        Ok(*self)\n+    }\n+\n+    #[inline(always)]\n+    fn to_op_for_proj(\n+        &self,\n+        _ecx: &mut InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        Ok(*self)\n+    }\n+\n+    #[inline(always)]\n+    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+        *op\n+    }\n+\n+    #[inline(always)]\n+    fn project_downcast(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        variant: VariantIdx,\n+    ) -> InterpResult<'tcx, Self> {\n+        ecx.operand_downcast(self, variant)\n+    }\n+\n+    #[inline(always)]\n+    fn project_field(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self> {\n+        ecx.operand_field(self, field)\n+    }\n+}\n+\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n     for MPlaceTy<'tcx, M::PointerTag>\n {\n@@ -90,16 +190,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n     }\n \n     #[inline(always)]\n-    fn to_op(\n+    fn to_op_for_read(\n         &self,\n         _ecx: &InterpCx<'mir, 'tcx, M>,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self.into())\n     }\n \n     #[inline(always)]\n-    fn from_op(op: OpTy<'tcx, M::PointerTag>) -> Self {\n-        // assert is justified because our `to_op` only ever produces `Indirect` operands.\n+    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+        // assert is justified because our `to_op_for_read` only ever produces `Indirect` operands.\n         op.assert_mem_place()\n     }\n \n@@ -122,11 +222,111 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> Value<'mir, 'tcx, M>\n     }\n }\n \n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n+    for MPlaceTy<'tcx, M::PointerTag>\n+{\n+    #[inline(always)]\n+    fn layout(&self) -> TyAndLayout<'tcx> {\n+        self.layout\n+    }\n+\n+    #[inline(always)]\n+    fn to_op_for_read(\n+        &self,\n+        _ecx: &InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        Ok(self.into())\n+    }\n+\n+    #[inline(always)]\n+    fn to_op_for_proj(\n+        &self,\n+        _ecx: &mut InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        Ok(self.into())\n+    }\n+\n+    #[inline(always)]\n+    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+        // assert is justified because our `to_op_for_proj` only ever produces `Indirect` operands.\n+        op.assert_mem_place()\n+    }\n+\n+    #[inline(always)]\n+    fn project_downcast(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        variant: VariantIdx,\n+    ) -> InterpResult<'tcx, Self> {\n+        ecx.mplace_downcast(self, variant)\n+    }\n+\n+    #[inline(always)]\n+    fn project_field(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self> {\n+        ecx.mplace_field(self, field)\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueMut<'mir, 'tcx, M>\n+    for PlaceTy<'tcx, M::PointerTag>\n+{\n+    #[inline(always)]\n+    fn layout(&self) -> TyAndLayout<'tcx> {\n+        self.layout\n+    }\n+\n+    #[inline(always)]\n+    fn to_op_for_read(\n+        &self,\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        // We `force_allocation` here so that `from_op` below can work.\n+        ecx.place_to_op(self)\n+    }\n+\n+    #[inline(always)]\n+    fn to_op_for_proj(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+    ) -> InterpResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n+        // We `force_allocation` here so that `from_op` below can work.\n+        Ok(ecx.force_allocation(self)?.into())\n+    }\n+\n+    #[inline(always)]\n+    fn from_op(op: &OpTy<'tcx, M::PointerTag>) -> Self {\n+        // assert is justified because our `to_op` only ever produces `Indirect` operands.\n+        op.assert_mem_place().into()\n+    }\n+\n+    #[inline(always)]\n+    fn project_downcast(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        variant: VariantIdx,\n+    ) -> InterpResult<'tcx, Self> {\n+        ecx.place_downcast(self, variant)\n+    }\n+\n+    #[inline(always)]\n+    fn project_field(\n+        &self,\n+        ecx: &mut InterpCx<'mir, 'tcx, M>,\n+        field: usize,\n+    ) -> InterpResult<'tcx, Self> {\n+        ecx.place_field(self, field)\n+    }\n+}\n+\n macro_rules! make_value_visitor {\n-    ($visitor_trait_name:ident, $($mutability:ident)?) => {\n+    ($visitor_trait:ident, $value_trait:ident, $($mutability:ident)?) => {\n         // How to traverse a value and what to do when we are at the leaves.\n-        pub trait $visitor_trait_name<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>: Sized {\n-            type V: Value<'mir, 'tcx, M>;\n+        pub trait $visitor_trait<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>: Sized {\n+            type V: $value_trait<'mir, 'tcx, M>;\n \n             /// The visitor must have an `InterpCx` in it.\n             fn ecx(&$($mutability)? self)\n@@ -215,19 +415,20 @@ macro_rules! make_value_visitor {\n             }\n             fn walk_value(&mut self, v: &Self::V) -> InterpResult<'tcx>\n             {\n-                trace!(\"walk_value: type: {}\", v.layout().ty);\n+                let ty = v.layout().ty;\n+                trace!(\"walk_value: type: {ty}\");\n \n                 // Special treatment for special types, where the (static) layout is not sufficient.\n-                match *v.layout().ty.kind() {\n+                match *ty.kind() {\n                     // If it is a trait object, switch to the real type that was used to create it.\n                     ty::Dynamic(..) => {\n                         // unsized values are never immediate, so we can assert_mem_place\n-                        let op = v.to_op(self.ecx())?;\n+                        let op = v.to_op_for_read(self.ecx())?;\n                         let dest = op.assert_mem_place();\n-                        let inner = self.ecx().unpack_dyn_trait(&dest)?.1;\n-                        trace!(\"walk_value: dyn object layout: {:#?}\", inner.layout);\n+                        let inner_mplace = self.ecx().unpack_dyn_trait(&dest)?.1;\n+                        trace!(\"walk_value: dyn object layout: {:#?}\", inner_mplace.layout);\n                         // recurse with the inner type\n-                        return self.visit_field(&v, 0, &Value::from_op(inner.into()));\n+                        return self.visit_field(&v, 0, &$value_trait::from_op(&inner_mplace.into()));\n                     },\n                     // Slices do not need special handling here: they have `Array` field\n                     // placement with length 0, so we enter the `Array` case below which\n@@ -278,10 +479,10 @@ macro_rules! make_value_visitor {\n \n                 // Visit the fields of this value.\n                 match v.layout().fields {\n-                    FieldsShape::Primitive => {},\n+                    FieldsShape::Primitive => {}\n                     FieldsShape::Union(fields) => {\n                         self.visit_union(v, fields)?;\n-                    },\n+                    }\n                     FieldsShape::Arbitrary { ref offsets, .. } => {\n                         // FIXME: We collect in a vec because otherwise there are lifetime\n                         // errors: Projecting to a field needs access to `ecx`.\n@@ -291,16 +492,17 @@ macro_rules! make_value_visitor {\n                             })\n                             .collect();\n                         self.visit_aggregate(v, fields.into_iter())?;\n-                    },\n+                    }\n                     FieldsShape::Array { .. } => {\n-                        // Let's get an mplace first.\n-                        let op = v.to_op(self.ecx())?;\n+                        // Let's get an mplace (or immediate) first.\n+                        // This might `force_allocate` if `v` is a `PlaceTy`, but `place_index` does that anyway.\n+                        let op = v.to_op_for_proj(self.ecx())?;\n                         // Now we can go over all the fields.\n                         // This uses the *run-time length*, i.e., if we are a slice,\n                         // the dynamic info from the metadata is used.\n                         let iter = self.ecx().operand_array_fields(&op)?\n                             .map(|f| f.and_then(|f| {\n-                                Ok(Value::from_op(f))\n+                                Ok($value_trait::from_op(&f))\n                             }));\n                         self.visit_aggregate(v, iter)?;\n                     }\n@@ -310,7 +512,7 @@ macro_rules! make_value_visitor {\n                     // If this is a multi-variant layout, find the right variant and proceed\n                     // with *its* fields.\n                     Variants::Multiple { .. } => {\n-                        let op = v.to_op(self.ecx())?;\n+                        let op = v.to_op_for_read(self.ecx())?;\n                         let idx = self.read_discriminant(&op)?;\n                         let inner = v.project_downcast(self.ecx(), idx)?;\n                         trace!(\"walk_value: variant layout: {:#?}\", inner.layout());\n@@ -325,5 +527,5 @@ macro_rules! make_value_visitor {\n     }\n }\n \n-make_value_visitor!(ValueVisitor,);\n-make_value_visitor!(MutValueVisitor, mut);\n+make_value_visitor!(ValueVisitor, Value,);\n+make_value_visitor!(MutValueVisitor, ValueMut, mut);"}, {"sha": "0581f4919782de87b05b7fa66071a8986b031eb9", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -652,6 +652,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n \n             ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Downcast(..)\n+            | ProjectionElem::OpaqueCast(..)\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Field(..)\n             | ProjectionElem::Index(_) => {}"}, {"sha": "c2b4f6eca5cedae20f51eccce1af89d3f04df078", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -316,6 +316,7 @@ where\n \n             ProjectionElem::Deref\n             | ProjectionElem::Field(_, _)\n+            | ProjectionElem::OpaqueCast(_)\n             | ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Downcast(_, _)"}, {"sha": "daa154576ae4b99acd3e0f88d89bb0aeefba05bb", "filename": "compiler/rustc_const_eval/src/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -361,7 +361,7 @@ impl<'tcx> Validator<'_, 'tcx> {\n                             return Err(Unpromotable);\n                         }\n                     }\n-                    ProjectionElem::Downcast(..) => {\n+                    ProjectionElem::OpaqueCast(..) | ProjectionElem::Downcast(..) => {\n                         return Err(Unpromotable);\n                     }\n "}, {"sha": "e4c9a4dad7b4815cf164781bcab0d7cc870d30b0", "filename": "compiler/rustc_error_messages/locales/en-US/passes.ftl", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fpasses.ftl?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,151 @@\n+-passes-previously-accepted =\n+    this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+\n+-passes-see-issue =\n+    see issue #{$issue} <https://github.com/rust-lang/rust/issues/{$issue}> for more information\n+\n+passes-outer-crate-level-attr =\n+    crate-level attribute should be an inner attribute: add an exclamation mark: `#![foo]`\n+\n+passes-inner-crate-level-attr =\n+    crate-level attribute should be in the root module\n+\n+passes-ignored-attr-with-macro = `#[{$sym}]` is ignored on struct fields, match arms and macro defs\n+    .warn = {-passes-previously-accepted}\n+    .note = {-passes-see-issue(issue: \"80564\")}\n+\n+passes-ignored-attr = `#[{$sym}]` is ignored on struct fields and match arms\n+    .warn = {-passes-previously-accepted}\n+    .note = {-passes-see-issue(issue: \"80564\")}\n+\n+passes-inline-ignored-function-prototype = `#[inline]` is ignored on function prototypes\n+\n+passes-inline-ignored-constants = `#[inline]` is ignored on constants\n+    .warn = {-passes-previously-accepted}\n+    .note = {-passes-see-issue(issue: \"65833\")}\n+\n+passes-inline-not-fn-or-closure = attribute should be applied to function or closure\n+    .label = not a function or closure\n+\n+passes-no-coverage-ignored-function-prototype = `#[no_coverage]` is ignored on function prototypes\n+\n+passes-no-coverage-propagate =\n+    `#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\n+\n+passes-no-coverage-fn-defn = `#[no_coverage]` may only be applied to function definitions\n+\n+passes-no-coverage-not-coverable = `#[no_coverage]` must be applied to coverable code\n+    .label = not coverable code\n+\n+passes-should-be-applied-to-fn = attribute should be applied to a function definition\n+    .label = not a function definition\n+\n+passes-naked-tracked-caller = cannot use `#[track_caller]` with `#[naked]`\n+\n+passes-should-be-applied-to-struct-enum = attribute should be applied to a struct or enum\n+    .label = not a struct or enum\n+\n+passes-should-be-applied-to-trait = attribute should be applied to a trait\n+    .label = not a trait\n+\n+passes-target-feature-on-statement = {passes-should-be-applied-to-fn}\n+    .warn = {-passes-previously-accepted}\n+    .label = {passes-should-be-applied-to-fn.label}\n+\n+passes-should-be-applied-to-static = attribute should be applied to a static\n+    .label = not a static\n+\n+passes-doc-expect-str = doc {$attr_name} attribute expects a string: #[doc({$attr_name} = \"a\")]\n+\n+passes-doc-alias-empty = {$attr_str} attribute cannot have empty value\n+\n+passes-doc-alias-bad-char = {$char_} character isn't allowed in {$attr_str}\n+\n+passes-doc-alias-start-end = {$attr_str} cannot start or end with ' '\n+\n+passes-doc-alias-bad-location = {$attr_str} isn't allowed on {$location}\n+\n+passes-doc-alias-not-an-alias = {$attr_str} is the same as the item's name\n+\n+passes-doc-alias-duplicated = doc alias is duplicated\n+    .label = first defined here\n+\n+passes-doc-alias-not-string-literal = `#[doc(alias(\"a\"))]` expects string literals\n+\n+passes-doc-alias-malformed =\n+    doc alias attribute expects a string `#[doc(alias = \"a\")]` or a list of strings `#[doc(alias(\"a\", \"b\"))]`\n+\n+passes-doc-keyword-empty-mod = `#[doc(keyword = \"...\")]` should be used on empty modules\n+\n+passes-doc-keyword-not-mod = `#[doc(keyword = \"...\")]` should be used on modules\n+\n+passes-doc-keyword-invalid-ident = `{$doc_keyword}` is not a valid identifier\n+\n+passes-doc-tuple-variadic-not-first =\n+    `#[doc(tuple_variadic)]` must be used on the first of a set of tuple trait impls with varying arity\n+\n+passes-doc-keyword-only-impl = `#[doc(keyword = \"...\")]` should be used on impl blocks\n+\n+passes-doc-inline-conflict-first = this attribute...\n+passes-doc-inline-conflict-second = ...conflicts with this attribute\n+passes-doc-inline-conflict = conflicting doc inlining attributes\n+    .help = remove one of the conflicting attributes\n+\n+passes-doc-inline-only-use = this attribute can only be applied to a `use` item\n+    .label = only applicable on `use` items\n+    .not-a-use-item-label = not a `use` item\n+    .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n+\n+passes-doc-attr-not-crate-level =\n+    `#![doc({$attr_name} = \"...\")]` isn't allowed as a crate-level attribute\n+\n+passes-attr-crate-level = this attribute can only be applied at the crate level\n+    .suggestion = to apply to the crate, use an inner attribute\n+    .help = to apply to the crate, use an inner attribute\n+    .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n+\n+passes-doc-test-unknown = unknown `doc(test)` attribute `{$path}`\n+\n+passes-doc-test-takes-list = `#[doc(test(...)]` takes a list of attributes\n+\n+passes-doc-primitive = `doc(primitive)` should never have been stable\n+\n+passes-doc-test-unknown-any = unknown `doc` attribute `{$path}`\n+\n+passes-doc-test-unknown-spotlight = unknown `doc` attribute `{$path}`\n+    .note = `doc(spotlight)` was renamed to `doc(notable_trait)`\n+    .suggestion = use `notable_trait` instead\n+    .no-op-note = `doc(spotlight)` is now a no-op\n+\n+passes-doc-test-unknown-include = unknown `doc` attribute `{$path}`\n+    .suggestion = use `doc = include_str!` instead\n+\n+passes-doc-invalid = invalid `doc` attribute\n+\n+passes-pass-by-value = `pass_by_value` attribute should be applied to a struct, enum or type alias\n+    .label = is not a struct, enum or type alias\n+\n+passes-allow-incoherent-impl =\n+    `rustc_allow_incoherent_impl` attribute should be applied to impl items.\n+    .label = the only currently supported targets are inherent methods\n+\n+passes-has-incoherent-inherent-impl =\n+    `rustc_has_incoherent_inherent_impls` attribute should be applied to types or traits.\n+    .label = only adts, extern types and traits are supported\n+\n+passes-must-use-async =\n+    `must_use` attribute on `async` functions applies to the anonymous `Future` returned by the function, not the value within\n+    .label = this attribute does nothing, the `Future`s returned by async functions are already `must_use`\n+\n+passes-must-use-no-effect = `#[must_use]` has no effect when applied to {$article} {$target}\n+\n+passes-must-not-suspend = `must_not_suspend` attribute should be applied to a struct, enum, or trait\n+    .label = is not a struct, enum, or trait\n+\n+passes-cold = {passes-should-be-applied-to-fn}\n+    .warn = {-passes-previously-accepted}\n+    .label = {passes-should-be-applied-to-fn.label}\n+\n+passes-link = attribute should be applied to an `extern` block with non-Rust ABI\n+    .warn = {-passes-previously-accepted}\n+    .label = not an `extern` block"}, {"sha": "f8a750da93f8d3442af9adb9b59b813d1cb4c9bb", "filename": "compiler/rustc_error_messages/locales/en-US/privacy.ftl", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -10,3 +10,12 @@ privacy-unnamed-item-is-private = {$kind} is private\n privacy-in-public-interface = {$vis_descr} {$kind} `{$descr}` in public interface\n     .label = can't leak {$vis_descr} {$kind}\n     .visibility-label = `{$descr}` declared as {$vis_descr}\n+\n+privacy-from-private-dep-in-public-interface =\n+    {$kind} `{$descr}` from private dependency '{$krate}' in public interface\n+\n+private-in-public-lint =\n+    {$vis_descr} {$kind} `{$descr}` in public interface (error {$kind ->\n+        [trait] E0445\n+        *[other] E0446\n+    })"}, {"sha": "a3040f83fdfc7d5ee57b8fe064f35061b462f579", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -37,6 +37,7 @@ fluent_messages! {\n     expand => \"../locales/en-US/expand.ftl\",\n     lint => \"../locales/en-US/lint.ftl\",\n     parser => \"../locales/en-US/parser.ftl\",\n+    passes => \"../locales/en-US/passes.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\",\n     typeck => \"../locales/en-US/typeck.ftl\",\n }"}, {"sha": "7d7f3e1833576c080318f6eba2ba6abed9290aa7", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 35, "deletions": 78, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -40,6 +40,35 @@ pub trait IntoDiagnosticArg {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static>;\n }\n \n+macro_rules! into_diagnostic_arg_using_display {\n+    ($( $ty:ty ),+ $(,)?) => {\n+        $(\n+            impl IntoDiagnosticArg for $ty {\n+                fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+                    self.to_string().into_diagnostic_arg()\n+                }\n+            }\n+        )+\n+    }\n+}\n+\n+into_diagnostic_arg_using_display!(\n+    i8,\n+    u8,\n+    i16,\n+    u16,\n+    i32,\n+    u32,\n+    i64,\n+    u64,\n+    i128,\n+    u128,\n+    std::num::NonZeroU32,\n+    hir::Target,\n+    Edition,\n+    Ident,\n+);\n+\n impl IntoDiagnosticArg for bool {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         if self {\n@@ -50,81 +79,9 @@ impl IntoDiagnosticArg for bool {\n     }\n }\n \n-impl IntoDiagnosticArg for i8 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for u8 {\n+impl IntoDiagnosticArg for char {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for i16 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for u16 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for i32 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for u32 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for i64 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for u64 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for i128 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for u128 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for String {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for std::num::NonZeroU32 {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n-    }\n-}\n-\n-impl IntoDiagnosticArg for Edition {\n-    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        DiagnosticArgValue::Str(Cow::Owned(self.to_string()))\n+        DiagnosticArgValue::Str(Cow::Owned(format!(\"{:?}\", self)))\n     }\n }\n \n@@ -134,15 +91,15 @@ impl IntoDiagnosticArg for Symbol {\n     }\n }\n \n-impl IntoDiagnosticArg for Ident {\n+impl<'a> IntoDiagnosticArg for &'a str {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         self.to_string().into_diagnostic_arg()\n     }\n }\n \n-impl<'a> IntoDiagnosticArg for &'a str {\n+impl IntoDiagnosticArg for String {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n-        self.to_string().into_diagnostic_arg()\n+        DiagnosticArgValue::Str(Cow::Owned(self))\n     }\n }\n \n@@ -496,7 +453,7 @@ impl Diagnostic {\n         self\n     }\n \n-    pub fn note_trait_signature(&mut self, name: String, signature: String) -> &mut Self {\n+    pub fn note_trait_signature(&mut self, name: Symbol, signature: String) -> &mut Self {\n         self.highlighted_note(vec![\n             (format!(\"`{}` from trait: `\", name), Style::NoStyle),\n             (signature, Style::Highlight),"}, {"sha": "9e68ee282e65235634506aab28e2d97c41e698da", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -595,6 +595,7 @@ macro_rules! error_code {\n pub struct LintDiagnosticBuilder<'a, G: EmissionGuarantee>(DiagnosticBuilder<'a, G>);\n \n impl<'a, G: EmissionGuarantee> LintDiagnosticBuilder<'a, G> {\n+    #[rustc_lint_diagnostics]\n     /// Return the inner `DiagnosticBuilder`, first setting the primary message to `msg`.\n     pub fn build(mut self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'a, G> {\n         self.0.set_primary_message(msg);"}, {"sha": "0315d11634c6b6b16afa213008c1c8e84ea4e30d", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -218,10 +218,9 @@ pub fn default_submod_path<'a>(\n         \"\"\n     };\n \n-    let mod_name = ident.name.to_string();\n-    let default_path_str = format!(\"{}{}.rs\", relative_prefix, mod_name);\n+    let default_path_str = format!(\"{}{}.rs\", relative_prefix, ident.name);\n     let secondary_path_str =\n-        format!(\"{}{}{}mod.rs\", relative_prefix, mod_name, path::MAIN_SEPARATOR);\n+        format!(\"{}{}{}mod.rs\", relative_prefix, ident.name, path::MAIN_SEPARATOR);\n     let default_path = dir_path.join(&default_path_str);\n     let secondary_path = dir_path.join(&secondary_path_str);\n     let default_exists = sess.source_map().file_exists(&default_path);"}, {"sha": "b267140daa971cea52f386bc38b3d382ad15f2ea", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -138,7 +138,7 @@ fn fmt_printer<'a, 'tcx>(infcx: &'a InferCtxt<'_, 'tcx>, ns: Namespace) -> FmtPr\n         if let TypeVariableOriginKind::TypeParameterDefinition(name, _) =\n             infcx.inner.borrow_mut().type_variables().var_origin(ty_vid).kind\n         {\n-            Some(name.to_string())\n+            Some(name)\n         } else {\n             None\n         }\n@@ -151,7 +151,7 @@ fn fmt_printer<'a, 'tcx>(infcx: &'a InferCtxt<'_, 'tcx>, ns: Namespace) -> FmtPr\n         if let ConstVariableOriginKind::ConstParameterDefinition(name, _) =\n             infcx.inner.borrow_mut().const_unification_table().probe_value(ct_vid).origin.kind\n         {\n-            return Some(name.to_string());\n+            return Some(name);\n         } else {\n             None\n         }"}, {"sha": "6b5b8b5932018abfb6e5d54b55dc38853885b0a5", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -59,7 +59,7 @@ impl<'a> SessionDiagnosticDerive<'a> {\n                         return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n                     }\n                     (Some(DiagnosticDeriveKind::Lint), _) => {\n-                        span_err(span, \"only `#[error(..)]` and `#[warn(..)]` are supported\")\n+                        span_err(span, \"only `#[error(..)]` and `#[warning(..)]` are supported\")\n                             .help(\"use the `#[error(...)]` attribute to create a error\")\n                             .emit();\n                         return DiagnosticDeriveError::ErrorHandled.to_compile_error();"}, {"sha": "5c5275b7cfb928256231d848423b019a2cdb2829", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 115, "deletions": 75, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -8,12 +8,13 @@ use crate::diagnostics::utils::{\n     report_error_if_not_applied_to_span, report_type_error, type_is_unit, type_matches_path,\n     Applicability, FieldInfo, FieldInnerTy, HasFieldMap, SetOnce,\n };\n-use proc_macro2::{Ident, TokenStream};\n+use proc_macro2::{Ident, Span, TokenStream};\n use quote::{format_ident, quote};\n use std::collections::HashMap;\n use std::str::FromStr;\n use syn::{\n-    parse_quote, spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path, Type,\n+    parse_quote, spanned::Spanned, Attribute, Field, Meta, MetaList, MetaNameValue, NestedMeta,\n+    Path, Type,\n };\n use synstructure::{BindingInfo, Structure};\n \n@@ -80,8 +81,8 @@ impl DiagnosticDeriveBuilder {\n     }\n \n     pub fn body<'s>(&mut self, structure: &mut Structure<'s>) -> (TokenStream, TokenStream) {\n-        // Keep track of which fields are subdiagnostics or have no attributes.\n-        let mut subdiagnostics_or_empty = std::collections::HashSet::new();\n+        // Keep track of which fields need to be handled with a by-move binding.\n+        let mut needs_moved = std::collections::HashSet::new();\n \n         // Generates calls to `span_label` and similar functions based on the attributes\n         // on fields. Code for suggestions uses formatting machinery and the value of\n@@ -92,16 +93,11 @@ impl DiagnosticDeriveBuilder {\n         let attrs = structure\n             .clone()\n             .filter(|field_binding| {\n-                let attrs = &field_binding.ast().attrs;\n-\n-                (!attrs.is_empty()\n-                    && attrs.iter().all(|attr| {\n-                        \"subdiagnostic\" != attr.path.segments.last().unwrap().ident.to_string()\n-                    }))\n-                    || {\n-                        subdiagnostics_or_empty.insert(field_binding.binding.clone());\n-                        false\n-                    }\n+                let ast = &field_binding.ast();\n+                !self.needs_move(ast) || {\n+                    needs_moved.insert(field_binding.binding.clone());\n+                    false\n+                }\n             })\n             .each(|field_binding| self.generate_field_attrs_code(field_binding));\n \n@@ -111,12 +107,41 @@ impl DiagnosticDeriveBuilder {\n         // attributes or a `#[subdiagnostic]` attribute then it must be passed as an\n         // argument to the diagnostic so that it can be referred to by Fluent messages.\n         let args = structure\n-            .filter(|field_binding| subdiagnostics_or_empty.contains(&field_binding.binding))\n+            .filter(|field_binding| needs_moved.contains(&field_binding.binding))\n             .each(|field_binding| self.generate_field_attrs_code(field_binding));\n \n         (attrs, args)\n     }\n \n+    /// Returns `true` if `field` should generate a `set_arg` call rather than any other diagnostic\n+    /// call (like `span_label`).\n+    fn should_generate_set_arg(&self, field: &Field) -> bool {\n+        field.attrs.is_empty()\n+    }\n+\n+    /// Returns `true` if `field` needs to have code generated in the by-move branch of the\n+    /// generated derive rather than the by-ref branch.\n+    fn needs_move(&self, field: &Field) -> bool {\n+        let generates_set_arg = self.should_generate_set_arg(field);\n+        let is_multispan = type_matches_path(&field.ty, &[\"rustc_errors\", \"MultiSpan\"]);\n+        // FIXME(davidtwco): better support for one field needing to be in the by-move and\n+        // by-ref branches.\n+        let is_subdiagnostic = field\n+            .attrs\n+            .iter()\n+            .map(|attr| attr.path.segments.last().unwrap().ident.to_string())\n+            .any(|attr| attr == \"subdiagnostic\");\n+\n+        // `set_arg` calls take their argument by-move..\n+        generates_set_arg\n+            // If this is a `MultiSpan` field then it needs to be moved to be used by any\n+            // attribute..\n+            || is_multispan\n+            // If this a `#[subdiagnostic]` then it needs to be moved as the other diagnostic is\n+            // unlikely to be `Copy`..\n+            || is_subdiagnostic\n+    }\n+\n     /// Establishes state in the `DiagnosticDeriveBuilder` resulting from the struct\n     /// attributes like `#[error(..)`, such as the diagnostic kind and slug. Generates\n     /// diagnostic builder calls for setting error code and creating note/help messages.\n@@ -131,16 +156,20 @@ impl DiagnosticDeriveBuilder {\n         let name = name.as_str();\n         let meta = attr.parse_meta()?;\n \n-        let is_help_or_note = matches!(name, \"help\" | \"note\");\n+        let is_help_note_or_warn = matches!(name, \"help\" | \"note\" | \"warn_\");\n \n         let nested = match meta {\n             // Most attributes are lists, like `#[error(..)]`/`#[warning(..)]` for most cases or\n             // `#[help(..)]`/`#[note(..)]` when the user is specifying a alternative slug.\n             Meta::List(MetaList { ref nested, .. }) => nested,\n             // Subdiagnostics without spans can be applied to the type too, and these are just\n             // paths: `#[help]` and `#[note]`\n-            Meta::Path(_) if is_help_or_note => {\n-                let fn_name = proc_macro2::Ident::new(name, attr.span());\n+            Meta::Path(_) if is_help_note_or_warn => {\n+                let fn_name = if name == \"warn_\" {\n+                    Ident::new(\"warn\", attr.span())\n+                } else {\n+                    Ident::new(name, attr.span())\n+                };\n                 return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::_subdiag::#fn_name); });\n             }\n             _ => throw_invalid_attr!(attr, &meta),\n@@ -152,9 +181,11 @@ impl DiagnosticDeriveBuilder {\n             \"error\" => self.kind.set_once((DiagnosticDeriveKind::Error, span)),\n             \"warning\" => self.kind.set_once((DiagnosticDeriveKind::Warn, span)),\n             \"lint\" => self.kind.set_once((DiagnosticDeriveKind::Lint, span)),\n-            \"help\" | \"note\" => (),\n+            \"help\" | \"note\" | \"warn_\" => (),\n             _ => throw_invalid_attr!(attr, &meta, |diag| {\n-                diag.help(\"only `error`, `warning`, `help` and `note` are valid attributes\")\n+                diag.help(\n+                    \"only `error`, `warning`, `help`, `note` and `warn_` are valid attributes\",\n+                )\n             }),\n         }\n \n@@ -163,22 +194,24 @@ impl DiagnosticDeriveBuilder {\n         let mut nested_iter = nested.into_iter();\n         if let Some(nested_attr) = nested_iter.next() {\n             // Report an error if there are any other list items after the path.\n-            if is_help_or_note && nested_iter.next().is_some() {\n+            if is_help_note_or_warn && nested_iter.next().is_some() {\n                 throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n-                    diag.help(\"`help` and `note` struct attributes can only have one argument\")\n+                    diag.help(\n+                        \"`help`, `note` and `warn_` struct attributes can only have one argument\",\n+                    )\n                 });\n             }\n \n             match nested_attr {\n-                NestedMeta::Meta(Meta::Path(path)) if is_help_or_note => {\n+                NestedMeta::Meta(Meta::Path(path)) if is_help_note_or_warn => {\n                     let fn_name = proc_macro2::Ident::new(name, attr.span());\n                     return Ok(quote! { #diag.#fn_name(rustc_errors::fluent::#path); });\n                 }\n                 NestedMeta::Meta(Meta::Path(path)) => {\n                     self.slug.set_once((path.clone(), span));\n                 }\n                 NestedMeta::Meta(meta @ Meta::NameValue(_))\n-                    if !is_help_or_note\n+                    if !is_help_note_or_warn\n                         && meta.path().segments.last().unwrap().ident.to_string() == \"code\" =>\n                 {\n                     // don't error for valid follow-up attributes\n@@ -227,57 +260,55 @@ impl DiagnosticDeriveBuilder {\n         let field = binding_info.ast();\n         let field_binding = &binding_info.binding;\n \n-        let inner_ty = FieldInnerTy::from_type(&field.ty);\n-\n-        // When generating `set_arg` or `add_subdiagnostic` calls, move data rather than\n-        // borrow it to avoid requiring clones - this must therefore be the last use of\n-        // each field (for example, any formatting machinery that might refer to a field\n-        // should be generated already).\n-        if field.attrs.is_empty() {\n+        if self.should_generate_set_arg(&field) {\n             let diag = &self.diag;\n             let ident = field.ident.as_ref().unwrap();\n-            quote! {\n+            return quote! {\n                 #diag.set_arg(\n                     stringify!(#ident),\n                     #field_binding\n                 );\n-            }\n-        } else {\n-            field\n-                .attrs\n-                .iter()\n-                .map(move |attr| {\n-                    let name = attr.path.segments.last().unwrap().ident.to_string();\n-                    let (binding, needs_destructure) = match (name.as_str(), &inner_ty) {\n-                        // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n-                        (\"primary_span\", FieldInnerTy::Vec(_)) => {\n-                            (quote! { #field_binding.clone() }, false)\n-                        }\n-                        // `subdiagnostics` are not derefed because they are bound by value.\n-                        (\"subdiagnostic\", _) => (quote! { #field_binding }, true),\n-                        _ => (quote! { *#field_binding }, true),\n-                    };\n-\n-                    let generated_code = self\n-                        .generate_inner_field_code(\n-                            attr,\n-                            FieldInfo {\n-                                binding: binding_info,\n-                                ty: inner_ty.inner_type().unwrap_or(&field.ty),\n-                                span: &field.span(),\n-                            },\n-                            binding,\n-                        )\n-                        .unwrap_or_else(|v| v.to_compile_error());\n-\n-                    if needs_destructure {\n-                        inner_ty.with(field_binding, generated_code)\n-                    } else {\n-                        generated_code\n-                    }\n-                })\n-                .collect()\n+            };\n         }\n+\n+        let needs_move = self.needs_move(&field);\n+        let inner_ty = FieldInnerTy::from_type(&field.ty);\n+\n+        field\n+            .attrs\n+            .iter()\n+            .map(move |attr| {\n+                let name = attr.path.segments.last().unwrap().ident.to_string();\n+                let needs_clone =\n+                    name == \"primary_span\" && matches!(inner_ty, FieldInnerTy::Vec(_));\n+                let (binding, needs_destructure) = if needs_clone {\n+                    // `primary_span` can accept a `Vec<Span>` so don't destructure that.\n+                    (quote! { #field_binding.clone() }, false)\n+                } else if needs_move {\n+                    (quote! { #field_binding }, true)\n+                } else {\n+                    (quote! { *#field_binding }, true)\n+                };\n+\n+                let generated_code = self\n+                    .generate_inner_field_code(\n+                        attr,\n+                        FieldInfo {\n+                            binding: binding_info,\n+                            ty: inner_ty.inner_type().unwrap_or(&field.ty),\n+                            span: &field.span(),\n+                        },\n+                        binding,\n+                    )\n+                    .unwrap_or_else(|v| v.to_compile_error());\n+\n+                if needs_destructure {\n+                    inner_ty.with(field_binding, generated_code)\n+                } else {\n+                    generated_code\n+                }\n+            })\n+            .collect()\n     }\n \n     fn generate_inner_field_code(\n@@ -324,10 +355,12 @@ impl DiagnosticDeriveBuilder {\n                 report_error_if_not_applied_to_span(attr, &info)?;\n                 Ok(self.add_spanned_subdiagnostic(binding, ident, parse_quote! { _subdiag::label }))\n             }\n-            \"note\" | \"help\" => {\n-                let path = match name {\n-                    \"note\" => parse_quote! { _subdiag::note },\n-                    \"help\" => parse_quote! { _subdiag::help },\n+            \"note\" | \"help\" | \"warn_\" => {\n+                let warn_ident = Ident::new(\"warn\", Span::call_site());\n+                let (ident, path) = match name {\n+                    \"note\" => (ident, parse_quote! { _subdiag::note }),\n+                    \"help\" => (ident, parse_quote! { _subdiag::help }),\n+                    \"warn_\" => (&warn_ident, parse_quote! { _subdiag::warn }),\n                     _ => unreachable!(),\n                 };\n                 if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n@@ -364,10 +397,10 @@ impl DiagnosticDeriveBuilder {\n             \"suggestion\" | \"suggestion_short\" | \"suggestion_hidden\" | \"suggestion_verbose\" => {\n                 return self.generate_inner_field_code_suggestion(attr, info);\n             }\n-            \"label\" | \"help\" | \"note\" => (),\n+            \"label\" | \"help\" | \"note\" | \"warn_\" => (),\n             _ => throw_invalid_attr!(attr, &meta, |diag| {\n                 diag.help(\n-                    \"only `label`, `note`, `help` or `suggestion{,_short,_hidden,_verbose}` are \\\n+                    \"only `label`, `help`, `note`, `warn` or `suggestion{,_short,_hidden,_verbose}` are \\\n                      valid field attributes\",\n                 )\n             }),\n@@ -396,7 +429,14 @@ impl DiagnosticDeriveBuilder {\n                 Ok(self.add_spanned_subdiagnostic(binding, ident, msg))\n             }\n             \"note\" | \"help\" if type_is_unit(&info.ty) => Ok(self.add_subdiagnostic(ident, msg)),\n-            \"note\" | \"help\" => report_type_error(attr, \"`Span` or `()`\")?,\n+            // `warn_` must be special-cased because the attribute `warn` already has meaning and\n+            // so isn't used, despite the diagnostic API being named `warn`.\n+            \"warn_\" if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) => Ok(self\n+                .add_spanned_subdiagnostic(binding, &Ident::new(\"warn\", Span::call_site()), msg)),\n+            \"warn_\" if type_is_unit(&info.ty) => {\n+                Ok(self.add_subdiagnostic(&Ident::new(\"warn\", Span::call_site()), msg))\n+            }\n+            \"note\" | \"help\" | \"warn_\" => report_type_error(attr, \"`Span` or `()`\")?,\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "1170d2b3c59a47749a10de6d4e15aedfdc6be18c", "filename": "compiler/rustc_macros/src/diagnostics/fluent.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Ffluent.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -260,10 +260,12 @@ pub(crate) fn fluent_messages(input: proc_macro::TokenStream) -> proc_macro::Tok\n             #generated\n \n             pub mod _subdiag {\n-                pub const note: crate::SubdiagnosticMessage =\n-                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"note\"));\n                 pub const help: crate::SubdiagnosticMessage =\n                     crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"help\"));\n+                pub const note: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"note\"));\n+                pub const warn: crate::SubdiagnosticMessage =\n+                    crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"warn\"));\n                 pub const label: crate::SubdiagnosticMessage =\n                     crate::SubdiagnosticMessage::FluentAttr(std::borrow::Cow::Borrowed(\"label\"));\n                 pub const suggestion: crate::SubdiagnosticMessage ="}, {"sha": "edf4dbed9853eeb8e2dbc8266ba3e92dc3012588", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -37,6 +37,8 @@ enum SubdiagnosticKind {\n     Note,\n     /// `#[help(...)]`\n     Help,\n+    /// `#[warn_(...)]`\n+    Warn,\n     /// `#[suggestion{,_short,_hidden,_verbose}]`\n     Suggestion(SubdiagnosticSuggestionKind),\n }\n@@ -49,6 +51,7 @@ impl FromStr for SubdiagnosticKind {\n             \"label\" => Ok(SubdiagnosticKind::Label),\n             \"note\" => Ok(SubdiagnosticKind::Note),\n             \"help\" => Ok(SubdiagnosticKind::Help),\n+            \"warn_\" => Ok(SubdiagnosticKind::Warn),\n             \"suggestion\" => Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal)),\n             \"suggestion_short\" => {\n                 Ok(SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Short))\n@@ -70,6 +73,7 @@ impl quote::IdentFragment for SubdiagnosticKind {\n             SubdiagnosticKind::Label => write!(f, \"label\"),\n             SubdiagnosticKind::Note => write!(f, \"note\"),\n             SubdiagnosticKind::Help => write!(f, \"help\"),\n+            SubdiagnosticKind::Warn => write!(f, \"warn\"),\n             SubdiagnosticKind::Suggestion(SubdiagnosticSuggestionKind::Normal) => {\n                 write!(f, \"suggestion\")\n             }"}, {"sha": "002abb152f7597a788fa4cbb954febfa6e94d00e", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -85,7 +85,13 @@ pub(crate) fn report_error_if_not_applied_to_span(\n     attr: &Attribute,\n     info: &FieldInfo<'_>,\n ) -> Result<(), DiagnosticDeriveError> {\n-    report_error_if_not_applied_to_ty(attr, info, &[\"rustc_span\", \"Span\"], \"`Span`\")\n+    if !type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"])\n+        && !type_matches_path(&info.ty, &[\"rustc_errors\", \"MultiSpan\"])\n+    {\n+        report_type_error(attr, \"`Span` or `MultiSpan`\")?;\n+    }\n+\n+    Ok(())\n }\n \n /// Inner type of a field and type of wrapper."}, {"sha": "ab509b26f1c55eeb4a1b6a5469f6cff33a1e5c0b", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -130,8 +130,9 @@ decl_derive!(\n         warning,\n         error,\n         lint,\n-        note,\n         help,\n+        note,\n+        warn_,\n         // field attributes\n         skip_arg,\n         primary_span,\n@@ -148,8 +149,9 @@ decl_derive!(\n         warning,\n         error,\n         lint,\n-        note,\n         help,\n+        note,\n+        warn_,\n         // field attributes\n         skip_arg,\n         primary_span,\n@@ -166,6 +168,7 @@ decl_derive!(\n         label,\n         help,\n         note,\n+        warn_,\n         suggestion,\n         suggestion_short,\n         suggestion_hidden,"}, {"sha": "0b5d23be58d85e2c44c499e2e75209729af441b9", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1397,6 +1397,7 @@ impl<V, T> ProjectionElem<V, T> {\n \n             Self::Field(_, _)\n             | Self::Index(_)\n+            | Self::OpaqueCast(_)\n             | Self::ConstantIndex { .. }\n             | Self::Subslice { .. }\n             | Self::Downcast(_, _) => false,\n@@ -1574,7 +1575,9 @@ impl Debug for Place<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         for elem in self.projection.iter().rev() {\n             match elem {\n-                ProjectionElem::Downcast(_, _) | ProjectionElem::Field(_, _) => {\n+                ProjectionElem::OpaqueCast(_)\n+                | ProjectionElem::Downcast(_, _)\n+                | ProjectionElem::Field(_, _) => {\n                     write!(fmt, \"(\").unwrap();\n                 }\n                 ProjectionElem::Deref => {\n@@ -1590,6 +1593,9 @@ impl Debug for Place<'_> {\n \n         for elem in self.projection.iter() {\n             match elem {\n+                ProjectionElem::OpaqueCast(ty) => {\n+                    write!(fmt, \" as {})\", ty)?;\n+                }\n                 ProjectionElem::Downcast(Some(name), _index) => {\n                     write!(fmt, \" as {})\", name)?;\n                 }"}, {"sha": "263c2ca3c700ec2a1d594d120f9faed459c78e79", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -754,6 +754,9 @@ pub type AssertMessage<'tcx> = AssertKind<Operand<'tcx>>;\n ///    generator has more than one variant, the parent place's variant index must be set, indicating\n ///    which variant is being used. If it has just one variant, the variant index may or may not be\n ///    included - the single possible variant is inferred if it is not included.\n+///  - [`OpaqueCast`](ProjectionElem::OpaqueCast): This projection changes the place's type to the\n+///    given one, and makes no other changes. A `OpaqueCast` projection on any type other than an\n+///    opaque type from the current crate is not well-formed.\n ///  - [`ConstantIndex`](ProjectionElem::ConstantIndex): Computes an offset in units of `T` into the\n ///    place as described in the documentation for the `ProjectionElem`. The resulting address is\n ///    the parent's address plus that offset, and the type is `T`. This is only legal if the parent\n@@ -856,6 +859,10 @@ pub enum ProjectionElem<V, T> {\n     ///\n     /// The included Symbol is the name of the variant, used for printing MIR.\n     Downcast(Option<Symbol>, VariantIdx),\n+\n+    /// Like an explicit cast from an opaque type to a concrete type, but without\n+    /// requiring an intermediate variable.\n+    OpaqueCast(T),\n }\n \n /// Alias for projections as they appear in places, where the base is a place"}, {"sha": "c6975df45efc2a8247012dba1f74deecb2b534da", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -57,7 +57,7 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// `PlaceElem`, where we can just use the `Ty` that is already\n     /// stored inline on field projection elems.\n     pub fn projection_ty(self, tcx: TyCtxt<'tcx>, elem: PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n-        self.projection_ty_core(tcx, ty::ParamEnv::empty(), &elem, |_, _, ty| ty)\n+        self.projection_ty_core(tcx, ty::ParamEnv::empty(), &elem, |_, _, ty| ty, |_, ty| ty)\n     }\n \n     /// `place_ty.projection_ty_core(tcx, elem, |...| { ... })`\n@@ -71,6 +71,7 @@ impl<'tcx> PlaceTy<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         elem: &ProjectionElem<V, T>,\n         mut handle_field: impl FnMut(&Self, Field, T) -> Ty<'tcx>,\n+        mut handle_opaque_cast: impl FnMut(&Self, T) -> Ty<'tcx>,\n     ) -> PlaceTy<'tcx>\n     where\n         V: ::std::fmt::Debug,\n@@ -109,6 +110,7 @@ impl<'tcx> PlaceTy<'tcx> {\n                 PlaceTy { ty: self.ty, variant_index: Some(index) }\n             }\n             ProjectionElem::Field(f, fty) => PlaceTy::from_ty(handle_field(&self, f, fty)),\n+            ProjectionElem::OpaqueCast(ty) => PlaceTy::from_ty(handle_opaque_cast(&self, ty)),\n         };\n         debug!(\"projection_ty self: {:?} elem: {:?} yields: {:?}\", self, elem, answer);\n         answer"}, {"sha": "a73ef23e28132db30842800b65d731571a14ad73", "filename": "compiler/rustc_middle/src/mir/type_foldable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftype_foldable.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -182,6 +182,7 @@ impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n         Ok(match self {\n             Deref => Deref,\n             Field(f, ty) => Field(f, ty.try_fold_with(folder)?),\n+            OpaqueCast(ty) => OpaqueCast(ty.try_fold_with(folder)?),\n             Index(v) => Index(v.try_fold_with(folder)?),\n             Downcast(symbol, variantidx) => Downcast(symbol, variantidx),\n             ConstantIndex { offset, min_length, from_end } => {"}, {"sha": "e5599fb15ad312ff3c60c8b6ba135b8a4c1e4807", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1064,6 +1064,11 @@ macro_rules! visit_place_fns {\n                     self.visit_ty(&mut new_ty, TyContext::Location(location));\n                     if ty != new_ty { Some(PlaceElem::Field(field, new_ty)) } else { None }\n                 }\n+                PlaceElem::OpaqueCast(ty) => {\n+                    let mut new_ty = ty;\n+                    self.visit_ty(&mut new_ty, TyContext::Location(location));\n+                    if ty != new_ty { Some(PlaceElem::OpaqueCast(new_ty)) } else { None }\n+                }\n                 PlaceElem::Deref\n                 | PlaceElem::ConstantIndex { .. }\n                 | PlaceElem::Subslice { .. }\n@@ -1133,7 +1138,7 @@ macro_rules! visit_place_fns {\n             location: Location,\n         ) {\n             match elem {\n-                ProjectionElem::Field(_field, ty) => {\n+                ProjectionElem::OpaqueCast(ty) | ProjectionElem::Field(_, ty) => {\n                     self.visit_ty(ty, TyContext::Location(location));\n                 }\n                 ProjectionElem::Index(local) => {"}, {"sha": "75559d4f8b843f153ac74c3bf85e12045ad7d601", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -542,17 +542,9 @@ pub enum SelectionError<'tcx> {\n     ErrorReporting,\n     /// Multiple applicable `impl`s where found. The `DefId`s correspond to\n     /// all the `impl`s' Items.\n-    Ambiguous(Vec<AmbiguousSelection>),\n+    Ambiguous(Vec<DefId>),\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub enum AmbiguousSelection {\n-    Impl(DefId),\n-    ParamEnv(Span),\n-}\n-\n-TrivialTypeTraversalAndLiftImpls! { AmbiguousSelection, }\n-\n /// When performing resolution, it is typically the case that there\n /// can be one of three outcomes:\n ///"}, {"sha": "c41a8318ec57f3c6867981e2f6fe1d2b86b45266", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1975,7 +1975,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         min_size = field_end;\n                     }\n                     FieldInfo {\n-                        name: name.to_string(),\n+                        name,\n                         offset: offset.bytes(),\n                         size: field_layout.size.bytes(),\n                         align: field_layout.align.abi.bytes(),\n@@ -1984,7 +1984,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 .collect();\n \n             VariantInfo {\n-                name: n.map(|n| n.to_string()),\n+                name: n,\n                 kind: if layout.is_unsized() { SizeKind::Min } else { SizeKind::Exact },\n                 align: layout.align.abi.bytes(),\n                 size: if min_size.bytes() == 0 { layout.size.bytes() } else { min_size.bytes() },"}, {"sha": "96e84bc8f0acfe3a3b34767926e073a269cd6746", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1030,11 +1030,11 @@ pub trait PrettyPrinter<'tcx>:\n         }\n     }\n \n-    fn ty_infer_name(&self, _: ty::TyVid) -> Option<String> {\n+    fn ty_infer_name(&self, _: ty::TyVid) -> Option<Symbol> {\n         None\n     }\n \n-    fn const_infer_name(&self, _: ty::ConstVid<'tcx>) -> Option<String> {\n+    fn const_infer_name(&self, _: ty::ConstVid<'tcx>) -> Option<Symbol> {\n         None\n     }\n \n@@ -1550,8 +1550,8 @@ pub struct FmtPrinterData<'a, 'tcx> {\n \n     pub region_highlight_mode: RegionHighlightMode<'tcx>,\n \n-    pub ty_infer_name_resolver: Option<Box<dyn Fn(ty::TyVid) -> Option<String> + 'a>>,\n-    pub const_infer_name_resolver: Option<Box<dyn Fn(ty::ConstVid<'tcx>) -> Option<String> + 'a>>,\n+    pub ty_infer_name_resolver: Option<Box<dyn Fn(ty::TyVid) -> Option<Symbol> + 'a>>,\n+    pub const_infer_name_resolver: Option<Box<dyn Fn(ty::ConstVid<'tcx>) -> Option<Symbol> + 'a>>,\n }\n \n impl<'a, 'tcx> Deref for FmtPrinter<'a, 'tcx> {\n@@ -1841,11 +1841,11 @@ impl<'tcx> Printer<'tcx> for FmtPrinter<'_, 'tcx> {\n }\n \n impl<'tcx> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx> {\n-    fn ty_infer_name(&self, id: ty::TyVid) -> Option<String> {\n+    fn ty_infer_name(&self, id: ty::TyVid) -> Option<Symbol> {\n         self.0.ty_infer_name_resolver.as_ref().and_then(|func| func(id))\n     }\n \n-    fn const_infer_name(&self, id: ty::ConstVid<'tcx>) -> Option<String> {\n+    fn const_infer_name(&self, id: ty::ConstVid<'tcx>) -> Option<Symbol> {\n         self.0.const_infer_name_resolver.as_ref().and_then(|func| func(id))\n     }\n "}, {"sha": "6abf419dd4991bfb8347499e00e3d96e350cca26", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 52, "deletions": 39, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -7,6 +7,7 @@ use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::hir::place::Projection as HirProjection;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::middle::region;\n+use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::AssertKind::BoundsCheck;\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n@@ -71,7 +72,7 @@ pub(crate) enum PlaceBase {\n /// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n #[derive(Clone, Debug, PartialEq)]\n-pub(crate) struct PlaceBuilder<'tcx> {\n+pub(in crate::build) struct PlaceBuilder<'tcx> {\n     base: PlaceBase,\n     projection: Vec<PlaceElem<'tcx>>,\n }\n@@ -104,6 +105,8 @@ fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n                 variant = Some(*idx);\n                 continue;\n             }\n+            // These do not affect anything, they just make sure we know the right type.\n+            ProjectionElem::OpaqueCast(_) => continue,\n             ProjectionElem::Index(..)\n             | ProjectionElem::ConstantIndex { .. }\n             | ProjectionElem::Subslice { .. } => {\n@@ -201,10 +204,10 @@ fn find_capture_matching_projections<'a, 'tcx>(\n /// `PlaceBuilder` now starts from `PlaceBase::Local`.\n ///\n /// Returns a Result with the error being the PlaceBuilder (`from_builder`) that was not found.\n-fn to_upvars_resolved_place_builder<'a, 'tcx>(\n+#[instrument(level = \"trace\", skip(cx))]\n+fn to_upvars_resolved_place_builder<'tcx>(\n     from_builder: PlaceBuilder<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    typeck_results: &'a ty::TypeckResults<'tcx>,\n+    cx: &Builder<'_, 'tcx>,\n ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n     match from_builder.base {\n         PlaceBase::Local(_) => Ok(from_builder),\n@@ -219,13 +222,13 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n \n             let Some((capture_index, capture)) =\n                 find_capture_matching_projections(\n-                    typeck_results,\n+                    cx.typeck_results,\n                     var_hir_id,\n                     closure_def_id,\n                     &from_builder.projection,\n                 ) else {\n-                let closure_span = tcx.def_span(closure_def_id);\n-                if !enable_precise_capture(tcx, closure_span) {\n+                let closure_span = cx.tcx.def_span(closure_def_id);\n+                if !enable_precise_capture(cx.tcx, closure_span) {\n                     bug!(\n                         \"No associated capture found for {:?}[{:#?}] even though \\\n                             capture_disjoint_fields isn't enabled\",\n@@ -242,8 +245,8 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n             };\n \n             // We won't be building MIR if the closure wasn't local\n-            let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n-            let closure_ty = typeck_results.node_type(closure_hir_id);\n+            let closure_hir_id = cx.tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n+            let closure_ty = cx.typeck_results.node_type(closure_hir_id);\n \n             let substs = match closure_ty.kind() {\n                 ty::Closure(_, substs) => ty::UpvarSubsts::Closure(substs),\n@@ -270,12 +273,14 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n \n             // We used some of the projections to build the capture itself,\n             // now we apply the remaining to the upvar resolved place.\n+            trace!(?capture.place, ?from_builder.projection);\n             let remaining_projections = strip_prefix(\n                 capture.place.base_ty,\n                 from_builder.projection,\n                 &capture.place.projections,\n             );\n             upvar_resolved_place_builder.projection.extend(remaining_projections);\n+            trace!(?upvar_resolved_place_builder);\n \n             Ok(upvar_resolved_place_builder)\n         }\n@@ -294,16 +299,21 @@ fn strip_prefix<'tcx>(\n     prefix_projections: &[HirProjection<'tcx>],\n ) -> impl Iterator<Item = PlaceElem<'tcx>> {\n     let mut iter = projections.into_iter();\n+    let mut next = || match iter.next()? {\n+        // Filter out opaque casts, they are unnecessary in the prefix.\n+        ProjectionElem::OpaqueCast(..) => iter.next(),\n+        other => Some(other),\n+    };\n     for projection in prefix_projections {\n         match projection.kind {\n             HirProjectionKind::Deref => {\n-                assert!(matches!(iter.next(), Some(ProjectionElem::Deref)));\n+                assert!(matches!(next(), Some(ProjectionElem::Deref)));\n             }\n             HirProjectionKind::Field(..) => {\n                 if base_ty.is_enum() {\n-                    assert!(matches!(iter.next(), Some(ProjectionElem::Downcast(..))));\n+                    assert!(matches!(next(), Some(ProjectionElem::Downcast(..))));\n                 }\n-                assert!(matches!(iter.next(), Some(ProjectionElem::Field(..))));\n+                assert!(matches!(next(), Some(ProjectionElem::Field(..))));\n             }\n             HirProjectionKind::Index | HirProjectionKind::Subslice => {\n                 bug!(\"unexpected projection kind: {:?}\", projection);\n@@ -315,24 +325,32 @@ fn strip_prefix<'tcx>(\n }\n \n impl<'tcx> PlaceBuilder<'tcx> {\n-    pub(crate) fn into_place<'a>(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        typeck_results: &'a ty::TypeckResults<'tcx>,\n-    ) -> Place<'tcx> {\n+    pub(crate) fn into_place(self, cx: &Builder<'_, 'tcx>) -> Place<'tcx> {\n         if let PlaceBase::Local(local) = self.base {\n-            Place { local, projection: tcx.intern_place_elems(&self.projection) }\n+            let mut projections = vec![];\n+            let mut ty = PlaceTy::from_ty(cx.local_decls[local].ty);\n+            for projection in self.projection {\n+                // Only preserve those opaque casts that actually go from an opaque type\n+                // to another type.\n+                if let ProjectionElem::OpaqueCast(t) = projection {\n+                    if let ty::Opaque(..) = ty.ty.kind() {\n+                        if t != ty.ty {\n+                            projections.push(ProjectionElem::OpaqueCast(t));\n+                        }\n+                    }\n+                } else {\n+                    projections.push(projection);\n+                }\n+                ty = ty.projection_ty(cx.tcx, projection);\n+            }\n+            Place { local, projection: cx.tcx.intern_place_elems(&projections) }\n         } else {\n-            self.expect_upvars_resolved(tcx, typeck_results).into_place(tcx, typeck_results)\n+            self.expect_upvars_resolved(cx).into_place(cx)\n         }\n     }\n \n-    fn expect_upvars_resolved<'a>(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        typeck_results: &'a ty::TypeckResults<'tcx>,\n-    ) -> PlaceBuilder<'tcx> {\n-        to_upvars_resolved_place_builder(self, tcx, typeck_results).unwrap()\n+    fn expect_upvars_resolved(self, cx: &Builder<'_, 'tcx>) -> PlaceBuilder<'tcx> {\n+        to_upvars_resolved_place_builder(self, cx).unwrap()\n     }\n \n     /// Attempts to resolve the `PlaceBuilder`.\n@@ -346,12 +364,11 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     /// not captured. This can happen because the final mir that will be\n     /// generated doesn't require a read for this place. Failures will only\n     /// happen inside closures.\n-    pub(crate) fn try_upvars_resolved<'a>(\n+    pub(crate) fn try_upvars_resolved(\n         self,\n-        tcx: TyCtxt<'tcx>,\n-        typeck_results: &'a ty::TypeckResults<'tcx>,\n+        cx: &Builder<'_, 'tcx>,\n     ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n-        to_upvars_resolved_place_builder(self, tcx, typeck_results)\n+        to_upvars_resolved_place_builder(self, cx)\n     }\n \n     pub(crate) fn base(&self) -> PlaceBase {\n@@ -411,7 +428,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.tcx, self.typeck_results))\n+        block.and(place_builder.into_place(self))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -435,7 +452,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<Place<'tcx>> {\n         let place_builder = unpack!(block = self.as_read_only_place_builder(block, expr));\n-        block.and(place_builder.into_place(self.tcx, self.typeck_results))\n+        block.and(place_builder.into_place(self))\n     }\n \n     /// This is used when constructing a compound `Place`, so that we can avoid creating\n@@ -530,7 +547,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             inferred_ty: expr.ty,\n                         });\n \n-                    let place = place_builder.clone().into_place(this.tcx, this.typeck_results);\n+                    let place = place_builder.clone().into_place(this);\n                     this.cfg.push(\n                         block,\n                         Statement {\n@@ -682,7 +699,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         if is_outermost_index {\n             self.read_fake_borrows(block, fake_borrow_temps, source_info)\n         } else {\n-            base_place = base_place.expect_upvars_resolved(self.tcx, self.typeck_results);\n+            base_place = base_place.expect_upvars_resolved(self);\n             self.add_fake_borrows_of_base(\n                 &base_place,\n                 block,\n@@ -710,12 +727,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let lt = self.temp(bool_ty, expr_span);\n \n         // len = len(slice)\n-        self.cfg.push_assign(\n-            block,\n-            source_info,\n-            len,\n-            Rvalue::Len(slice.into_place(self.tcx, self.typeck_results)),\n-        );\n+        self.cfg.push_assign(block, source_info, len, Rvalue::Len(slice.into_place(self)));\n         // lt = idx < len\n         self.cfg.push_assign(\n             block,\n@@ -795,6 +807,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     }\n                     ProjectionElem::Field(..)\n                     | ProjectionElem::Downcast(..)\n+                    | ProjectionElem::OpaqueCast(..)\n                     | ProjectionElem::ConstantIndex { .. }\n                     | ProjectionElem::Subslice { .. } => (),\n                 }"}, {"sha": "93f76333165a5c1bb3cc041fdaff6a36d974ce8c", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -321,11 +321,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     let place_builder =\n                         unpack!(block = this.as_place_builder(block, &this.thir[*thir_place]));\n \n-                    if let Ok(place_builder_resolved) =\n-                        place_builder.try_upvars_resolved(this.tcx, this.typeck_results)\n-                    {\n-                        let mir_place =\n-                            place_builder_resolved.into_place(this.tcx, this.typeck_results);\n+                    if let Ok(place_builder_resolved) = place_builder.try_upvars_resolved(this) {\n+                        let mir_place = place_builder_resolved.into_place(this);\n                         this.cfg.push_fake_read(\n                             block,\n                             this.source_info(this.tcx.hir().span(*hir_id)),\n@@ -616,8 +613,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             // by the parent itself. The mutability of the current capture\n             // is same as that of the capture in the parent closure.\n             PlaceBase::Upvar { .. } => {\n-                let enclosing_upvars_resolved =\n-                    arg_place_builder.clone().into_place(this.tcx, this.typeck_results);\n+                let enclosing_upvars_resolved = arg_place_builder.clone().into_place(this);\n \n                 match enclosing_upvars_resolved.as_ref() {\n                     PlaceRef {\n@@ -654,7 +650,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n         };\n \n-        let arg_place = arg_place_builder.into_place(this.tcx, this.typeck_results);\n+        let arg_place = arg_place_builder.into_place(this);\n \n         this.cfg.push_assign(\n             block,"}, {"sha": "dac8862647a85c7e303f0a7946fa122926bae9d5", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -23,17 +23,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         ensure_sufficient_stack(|| self.as_temp_inner(block, temp_lifetime, expr, mutability))\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn as_temp_inner(\n         &mut self,\n         mut block: BasicBlock,\n         temp_lifetime: Option<region::Scope>,\n         expr: &Expr<'tcx>,\n         mutability: Mutability,\n     ) -> BlockAnd<Local> {\n-        debug!(\n-            \"as_temp(block={:?}, temp_lifetime={:?}, expr={:?}, mutability={:?})\",\n-            block, temp_lifetime, expr, mutability\n-        );\n         let this = self;\n \n         let expr_span = expr.span;"}, {"sha": "d1ef515b3d29bda290a6f6f3a4684c24fa80a650", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -15,14 +15,13 @@ use std::iter;\n impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n     /// is assumed to be uninitialized.\n+    #[instrument(level = \"debug\", skip(self))]\n     pub(crate) fn expr_into_dest(\n         &mut self,\n         destination: Place<'tcx>,\n         mut block: BasicBlock,\n         expr: &Expr<'tcx>,\n     ) -> BlockAnd<()> {\n-        debug!(\"expr_into_dest(destination={:?}, block={:?}, expr={:?})\", destination, block, expr);\n-\n         // since we frequently have to reference `self` from within a\n         // closure, where `self` would be shadowed, it's easier to\n         // just use the name `this` uniformly\n@@ -366,9 +365,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                             None => {\n                                 let place_builder = place_builder.clone();\n                                 this.consume_by_copy_or_move(\n-                                    place_builder\n-                                        .field(n, *ty)\n-                                        .into_place(this.tcx, this.typeck_results),\n+                                    place_builder.field(n, *ty).into_place(this),\n                                 )\n                             }\n                         })"}, {"sha": "86ef666eac8d2c88c62d2b49e1b20a4e428a8bf9", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 36, "deletions": 44, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -220,10 +220,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let cause_matched_place = FakeReadCause::ForMatchedPlace(None);\n         let source_info = self.source_info(scrutinee_span);\n \n-        if let Ok(scrutinee_builder) =\n-            scrutinee_place_builder.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n-        {\n-            let scrutinee_place = scrutinee_builder.into_place(self.tcx, self.typeck_results);\n+        if let Ok(scrutinee_builder) = scrutinee_place_builder.clone().try_upvars_resolved(self) {\n+            let scrutinee_place = scrutinee_builder.into_place(self);\n             self.cfg.push_fake_read(block, source_info, cause_matched_place, scrutinee_place);\n         }\n \n@@ -348,12 +346,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // ```\n                     let mut opt_scrutinee_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n                     let scrutinee_place: Place<'tcx>;\n-                    if let Ok(scrutinee_builder) = scrutinee_place_builder\n-                        .clone()\n-                        .try_upvars_resolved(this.tcx, this.typeck_results)\n+                    if let Ok(scrutinee_builder) =\n+                        scrutinee_place_builder.clone().try_upvars_resolved(this)\n                     {\n-                        scrutinee_place =\n-                            scrutinee_builder.into_place(this.tcx, this.typeck_results);\n+                        scrutinee_place = scrutinee_builder.into_place(this);\n                         opt_scrutinee_place = Some((Some(&scrutinee_place), scrutinee_span));\n                     }\n                     let scope = this.declare_bindings(\n@@ -602,12 +598,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             while let Some(next) = {\n                 for binding in &candidate_ref.bindings {\n                     let local = self.var_local_id(binding.var_id, OutsideGuard);\n-\n-                    let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n-                        VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n-                    )))) = self.local_decls[local].local_info else {\n-                        bug!(\"Let binding to non-user variable.\")\n-                    };\n                     // `try_upvars_resolved` may fail if it is unable to resolve the given\n                     // `PlaceBuilder` inside a closure. In this case, we don't want to include\n                     // a scrutinee place. `scrutinee_place_builder` will fail for destructured\n@@ -622,10 +612,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     //    let (v1, v2) = foo;\n                     // };\n                     // ```\n-                    if let Ok(match_pair_resolved) =\n-                        initializer.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n-                    {\n-                        let place = match_pair_resolved.into_place(self.tcx, self.typeck_results);\n+                    if let Ok(match_pair_resolved) = initializer.clone().try_upvars_resolved(self) {\n+                        let place = match_pair_resolved.into_place(self);\n+\n+                        let Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::Var(\n+                            VarBindingForm { opt_match_place: Some((ref mut match_place, _)), .. },\n+                        )))) = self.local_decls[local].local_info else {\n+                            bug!(\"Let binding to non-user variable.\")\n+                        };\n+\n                         *match_place = Some(place);\n                     }\n                 }\n@@ -654,6 +649,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// scope for the bindings in these patterns, if such a scope had to be\n     /// created. NOTE: Declaring the bindings should always be done in their\n     /// drop scope.\n+    #[instrument(skip(self), level = \"debug\")]\n     pub(crate) fn declare_bindings(\n         &mut self,\n         mut visibility_scope: Option<SourceScope>,\n@@ -662,7 +658,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<&Place<'tcx>>, Span)>,\n     ) -> Option<SourceScope> {\n-        debug!(\"declare_bindings: pattern={:?}\", pattern);\n         self.visit_primary_bindings(\n             &pattern,\n             UserTypeProjections::none(),\n@@ -872,7 +867,7 @@ impl<'tcx, 'pat> Candidate<'pat, 'tcx> {\n         Candidate {\n             span: pattern.span,\n             has_guard,\n-            match_pairs: smallvec![MatchPair { place, pattern }],\n+            match_pairs: smallvec![MatchPair::new(place, pattern)],\n             bindings: Vec::new(),\n             ascriptions: Vec::new(),\n             subcandidates: Vec::new(),\n@@ -1048,6 +1043,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// if `x.0` matches `false` (for the third arm). In the (impossible at\n     /// runtime) case when `x.0` is now `true`, we branch to\n     /// `otherwise_block`.\n+    #[instrument(skip(self, fake_borrows), level = \"debug\")]\n     fn match_candidates<'pat>(\n         &mut self,\n         span: Span,\n@@ -1057,11 +1053,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         candidates: &mut [&mut Candidate<'pat, 'tcx>],\n         fake_borrows: &mut Option<FxIndexSet<Place<'tcx>>>,\n     ) {\n-        debug!(\n-            \"matched_candidate(span={:?}, candidates={:?}, start_block={:?}, otherwise_block={:?})\",\n-            span, candidates, start_block, otherwise_block,\n-        );\n-\n         // Start by simplifying candidates. Once this process is complete, all\n         // the match pairs which remain require some form of test, whether it\n         // be a switch or pattern comparison.\n@@ -1380,6 +1371,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         )\n     }\n \n+    #[instrument(\n+        skip(self, otherwise, or_span, place, fake_borrows, candidate, pats),\n+        level = \"debug\"\n+    )]\n     fn test_or_pattern<'pat>(\n         &mut self,\n         candidate: &mut Candidate<'pat, 'tcx>,\n@@ -1389,7 +1384,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         place: PlaceBuilder<'tcx>,\n         fake_borrows: &mut Option<FxIndexSet<Place<'tcx>>>,\n     ) {\n-        debug!(\"test_or_pattern:\\ncandidate={:#?}\\npats={:#?}\", candidate, pats);\n+        debug!(\"candidate={:#?}\\npats={:#?}\", candidate, pats);\n         let mut or_candidates: Vec<_> = pats\n             .iter()\n             .map(|pat| Candidate::new(place.clone(), pat, candidate.has_guard))\n@@ -1605,9 +1600,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         // Insert a Shallow borrow of any places that is switched on.\n         if let Some(fb) = fake_borrows && let Ok(match_place_resolved) =\n-            match_place.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n+            match_place.clone().try_upvars_resolved(self)\n         {\n-            let resolved_place = match_place_resolved.into_place(self.tcx, self.typeck_results);\n+            let resolved_place = match_place_resolved.into_place(self);\n             fb.insert(resolved_place);\n         }\n \n@@ -1634,9 +1629,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             candidates = rest;\n         }\n         // at least the first candidate ought to be tested\n-        assert!(total_candidate_count > candidates.len());\n-        debug!(\"test_candidates: tested_candidates: {}\", total_candidate_count - candidates.len());\n-        debug!(\"test_candidates: untested_candidates: {}\", candidates.len());\n+        assert!(\n+            total_candidate_count > candidates.len(),\n+            \"{}, {:#?}\",\n+            total_candidate_count,\n+            candidates\n+        );\n+        debug!(\"tested_candidates: {}\", total_candidate_count - candidates.len());\n+        debug!(\"untested_candidates: {}\", candidates.len());\n \n         // HACK(matthewjasper) This is a closure so that we can let the test\n         // create its blocks before the rest of the match. This currently\n@@ -1794,10 +1794,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         );\n         let mut opt_expr_place: Option<(Option<&Place<'tcx>>, Span)> = None;\n         let expr_place: Place<'tcx>;\n-        if let Ok(expr_builder) =\n-            expr_place_builder.try_upvars_resolved(self.tcx, self.typeck_results)\n-        {\n-            expr_place = expr_builder.into_place(self.tcx, self.typeck_results);\n+        if let Ok(expr_builder) = expr_place_builder.try_upvars_resolved(self) {\n+            expr_place = expr_builder.into_place(self);\n             opt_expr_place = Some((Some(&expr_place), expr_span));\n         }\n         let otherwise_post_guard_block = otherwise_candidate.pre_binding_block.unwrap();\n@@ -2195,6 +2193,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// first local is a binding for occurrences of `var` in the guard, which\n     /// will have type `&T`. The second local is a binding for occurrences of\n     /// `var` in the arm body, which will have type `T`.\n+    #[instrument(skip(self), level = \"debug\")]\n     fn declare_binding(\n         &mut self,\n         source_info: SourceInfo,\n@@ -2209,19 +2208,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n         pat_span: Span,\n     ) {\n-        debug!(\n-            \"declare_binding(var_id={:?}, name={:?}, mode={:?}, var_ty={:?}, \\\n-             visibility_scope={:?}, source_info={:?})\",\n-            var_id, name, mode, var_ty, visibility_scope, source_info\n-        );\n-\n         let tcx = self.tcx;\n         let debug_source_info = SourceInfo { span: source_info.span, scope: visibility_scope };\n         let binding_mode = match mode {\n             BindingMode::ByValue => ty::BindingMode::BindByValue(mutability),\n             BindingMode::ByRef(_) => ty::BindingMode::BindByReference(mutability),\n         };\n-        debug!(\"declare_binding: user_ty={:?}\", user_ty);\n         let local = LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty,\n@@ -2271,7 +2263,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         } else {\n             LocalsForNode::One(for_arm_body)\n         };\n-        debug!(\"declare_binding: vars={:?}\", locals);\n+        debug!(?locals);\n         self.var_indices.insert(var_id, locals);\n     }\n "}, {"sha": "6fa817da28a3c7578b6ee1b2b17bc2bf03750f07", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -37,12 +37,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     ///\n     /// only generates a single switch. If this happens this method returns\n     /// `true`.\n+    #[instrument(skip(self, candidate), level = \"debug\")]\n     pub(super) fn simplify_candidate<'pat>(\n         &mut self,\n         candidate: &mut Candidate<'pat, 'tcx>,\n     ) -> bool {\n         // repeatedly simplify match pairs until fixed point is reached\n-        debug!(?candidate, \"simplify_candidate\");\n+        debug!(\"{:#?}\", candidate);\n \n         // existing_bindings and new_bindings exists to keep the semantics in order.\n         // Reversing the binding order for bindings after `@` changes the binding order in places\n@@ -155,12 +156,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ascription: thir::Ascription { ref annotation, variance },\n             } => {\n                 // Apply the type ascription to the value at `match_pair.place`, which is the\n-                if let Ok(place_resolved) =\n-                    match_pair.place.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n-                {\n+                if let Ok(place_resolved) = match_pair.place.clone().try_upvars_resolved(self) {\n                     candidate.ascriptions.push(Ascription {\n                         annotation: annotation.clone(),\n-                        source: place_resolved.into_place(self.tcx, self.typeck_results),\n+                        source: place_resolved.into_place(self),\n                         variance,\n                     });\n                 }\n@@ -184,12 +183,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 ref subpattern,\n                 is_primary: _,\n             } => {\n-                if let Ok(place_resolved) =\n-                    match_pair.place.clone().try_upvars_resolved(self.tcx, self.typeck_results)\n-                {\n+                if let Ok(place_resolved) = match_pair.place.clone().try_upvars_resolved(self) {\n                     candidate.bindings.push(Binding {\n                         span: match_pair.pattern.span,\n-                        source: place_resolved.into_place(self.tcx, self.typeck_results),\n+                        source: place_resolved.into_place(self),\n                         var_id: var,\n                         binding_mode: mode,\n                     });"}, {"sha": "63acd731db7c9735c901d335dcf5d276db1f1d0c", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -144,6 +144,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self, make_target_blocks, place_builder), level = \"debug\")]\n     pub(super) fn perform_test(\n         &mut self,\n         match_start_span: Span,\n@@ -153,21 +154,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         test: &Test<'tcx>,\n         make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n     ) {\n-        let place: Place<'tcx>;\n-        if let Ok(test_place_builder) =\n-            place_builder.try_upvars_resolved(self.tcx, self.typeck_results)\n-        {\n-            place = test_place_builder.into_place(self.tcx, self.typeck_results);\n-        } else {\n-            return;\n-        }\n-        debug!(\n-            \"perform_test({:?}, {:?}: {:?}, {:?})\",\n-            block,\n-            place,\n-            place.ty(&self.local_decls, self.tcx),\n-            test\n-        );\n+        let place = place_builder.into_place(self);\n+        let place_ty = place.ty(&self.local_decls, self.tcx);\n+        debug!(?place, ?place_ty,);\n \n         let source_info = self.source_info(test.span);\n         match test.kind {\n@@ -735,9 +724,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // So, if we have a match-pattern like `x @ Enum::Variant(P1, P2)`,\n         // we want to create a set of derived match-patterns like\n         // `(x as Variant).0 @ P1` and `(x as Variant).1 @ P1`.\n-        let elem =\n-            ProjectionElem::Downcast(Some(adt_def.variant(variant_index).name), variant_index);\n-        let downcast_place = match_pair.place.project(elem); // `(x as Variant)`\n+        let downcast_place = match_pair.place.downcast(adt_def, variant_index); // `(x as Variant)`\n         let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n             // e.g., `(x as Variant).0`\n             let place = downcast_place.clone().field(subpattern.field, subpattern.pattern.ty);"}, {"sha": "4a7edc517f4e4436a73c8e16f16709acabd8e8c3", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -31,21 +31,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         suffix: &'pat [Pat<'tcx>],\n     ) {\n         let tcx = self.tcx;\n-        let (min_length, exact_size) = if let Ok(place_resolved) =\n-            place.clone().try_upvars_resolved(tcx, self.typeck_results)\n-        {\n-            match place_resolved\n-                .into_place(tcx, self.typeck_results)\n-                .ty(&self.local_decls, tcx)\n-                .ty\n-                .kind()\n-            {\n-                ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n-                _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n-            }\n-        } else {\n-            ((prefix.len() + suffix.len()).try_into().unwrap(), false)\n-        };\n+        let (min_length, exact_size) =\n+            if let Ok(place_resolved) = place.clone().try_upvars_resolved(self) {\n+                match place_resolved.into_place(self).ty(&self.local_decls, tcx).ty.kind() {\n+                    ty::Array(_, length) => (length.eval_usize(tcx, self.param_env), true),\n+                    _ => ((prefix.len() + suffix.len()).try_into().unwrap(), false),\n+                }\n+            } else {\n+                ((prefix.len() + suffix.len()).try_into().unwrap(), false)\n+            };\n \n         match_pairs.extend(prefix.iter().enumerate().map(|(idx, subpattern)| {\n             let elem =\n@@ -100,10 +94,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n }\n \n impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n-    pub(crate) fn new(\n+    pub(in crate::build) fn new(\n         place: PlaceBuilder<'tcx>,\n         pattern: &'pat Pat<'tcx>,\n     ) -> MatchPair<'pat, 'tcx> {\n+        // Force the place type to the pattern's type.\n+        // FIXME(oli-obk): only do this when we don't already know the place type.\n+        // FIXME(oli-obk): can we use this to simplify slice/array pattern hacks?\n+        let place = place.project(ProjectionElem::OpaqueCast(pattern.ty));\n         MatchPair { place, pattern }\n     }\n }"}, {"sha": "ab37c4802852a85e1015038723230591167e8d75", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -553,6 +553,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     /// Convenience wrapper that pushes a scope and then executes `f`\n     /// to build its contents, popping the scope afterwards.\n+    #[instrument(skip(self, f), level = \"debug\")]\n     pub(crate) fn in_scope<F, R>(\n         &mut self,\n         region_scope: (region::Scope, SourceInfo),\n@@ -562,7 +563,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     where\n         F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>,\n     {\n-        debug!(\"in_scope(region_scope={:?})\", region_scope);\n         let source_scope = self.source_scope;\n         let tcx = self.tcx;\n         if let LintLevel::Explicit(current_hir_id) = lint_level {\n@@ -589,7 +589,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let rv = unpack!(block = f(self));\n         unpack!(block = self.pop_scope(region_scope, block));\n         self.source_scope = source_scope;\n-        debug!(\"in_scope: exiting region_scope={:?} block={:?}\", region_scope, block);\n+        debug!(?block);\n         block.and(rv)\n     }\n "}, {"sha": "05da33caa91bdefe94a338c292d4e52a33cd4f16", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -48,6 +48,8 @@ impl<'tcx> Cx<'tcx> {\n             _ => None,\n         };\n \n+        trace!(?expr.ty);\n+\n         // Now apply adjustments, if any.\n         for adjustment in self.typeck_results.expr_adjustments(hir_expr) {\n             trace!(?expr, ?adjustment);\n@@ -56,6 +58,8 @@ impl<'tcx> Cx<'tcx> {\n                 self.apply_adjustment(hir_expr, expr, adjustment, adjustment_span.unwrap_or(span));\n         }\n \n+        trace!(?expr.ty, \"after adjustments\");\n+\n         // Next, wrap this up in the expr's scope.\n         expr = Expr {\n             temp_lifetime,"}, {"sha": "c0fd19cf71c3186ede0fb0d75895f1afde65b6a3", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1202,35 +1202,32 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n \n     /// Creates a new list of wildcard fields for a given constructor. The result must have a\n     /// length of `constructor.arity()`.\n-    pub(super) fn wildcards(\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        ty: Ty<'tcx>,\n-        constructor: &Constructor<'tcx>,\n-    ) -> Self {\n+    #[instrument(level = \"trace\")]\n+    pub(super) fn wildcards(pcx: PatCtxt<'_, 'p, 'tcx>, constructor: &Constructor<'tcx>) -> Self {\n         let ret = match constructor {\n-            Single | Variant(_) => match ty.kind() {\n-                ty::Tuple(fs) => Fields::wildcards_from_tys(cx, fs.iter()),\n-                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(cx, once(*rty)),\n+            Single | Variant(_) => match pcx.ty.kind() {\n+                ty::Tuple(fs) => Fields::wildcards_from_tys(pcx.cx, fs.iter()),\n+                ty::Ref(_, rty, _) => Fields::wildcards_from_tys(pcx.cx, once(*rty)),\n                 ty::Adt(adt, substs) => {\n                     if adt.is_box() {\n                         // The only legal patterns of type `Box` (outside `std`) are `_` and box\n                         // patterns. If we're here we can assume this is a box pattern.\n-                        Fields::wildcards_from_tys(cx, once(substs.type_at(0)))\n+                        Fields::wildcards_from_tys(pcx.cx, once(substs.type_at(0)))\n                     } else {\n                         let variant = &adt.variant(constructor.variant_index_for_adt(*adt));\n-                        let tys = Fields::list_variant_nonhidden_fields(cx, ty, variant)\n+                        let tys = Fields::list_variant_nonhidden_fields(pcx.cx, pcx.ty, variant)\n                             .map(|(_, ty)| ty);\n-                        Fields::wildcards_from_tys(cx, tys)\n+                        Fields::wildcards_from_tys(pcx.cx, tys)\n                     }\n                 }\n-                _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", ty),\n+                _ => bug!(\"Unexpected type for `Single` constructor: {:?}\", pcx),\n             },\n-            Slice(slice) => match *ty.kind() {\n+            Slice(slice) => match *pcx.ty.kind() {\n                 ty::Slice(ty) | ty::Array(ty, _) => {\n                     let arity = slice.arity();\n-                    Fields::wildcards_from_tys(cx, (0..arity).map(|_| ty))\n+                    Fields::wildcards_from_tys(pcx.cx, (0..arity).map(|_| ty))\n                 }\n-                _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, pcx),\n             },\n             Str(..)\n             | FloatRange(..)\n@@ -1243,7 +1240,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 bug!(\"called `Fields::wildcards` on an `Or` ctor\")\n             }\n         };\n-        debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n+        debug!(?ret);\n         ret\n     }\n \n@@ -1286,7 +1283,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n     /// For example, if `ctor` is a `Constructor::Variant` for `Option::Some`, we get the pattern\n     /// `Some(_)`.\n     pub(super) fn wild_from_ctor(pcx: PatCtxt<'_, 'p, 'tcx>, ctor: Constructor<'tcx>) -> Self {\n-        let fields = Fields::wildcards(pcx.cx, pcx.ty, &ctor);\n+        let fields = Fields::wildcards(pcx, &ctor);\n         DeconstructedPat::new(ctor, fields, pcx.ty, DUMMY_SP)\n     }\n \n@@ -1553,13 +1550,13 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n     /// `other_ctor` can be different from `self.ctor`, but must be covered by it.\n     pub(super) fn specialize<'a>(\n         &'a self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n         other_ctor: &Constructor<'tcx>,\n     ) -> SmallVec<[&'p DeconstructedPat<'p, 'tcx>; 2]> {\n         match (&self.ctor, other_ctor) {\n             (Wildcard, _) => {\n                 // We return a wildcard for each field of `other_ctor`.\n-                Fields::wildcards(cx, self.ty, other_ctor).iter_patterns().collect()\n+                Fields::wildcards(pcx, other_ctor).iter_patterns().collect()\n             }\n             (Slice(self_slice), Slice(other_slice))\n                 if self_slice.arity() != other_slice.arity() =>\n@@ -1578,7 +1575,7 @@ impl<'p, 'tcx> DeconstructedPat<'p, 'tcx> {\n                         let prefix = &self.fields.fields[..prefix];\n                         let suffix = &self.fields.fields[self_slice.arity() - suffix..];\n                         let wildcard: &_ =\n-                            cx.pattern_arena.alloc(DeconstructedPat::wildcard(inner_ty));\n+                            pcx.cx.pattern_arena.alloc(DeconstructedPat::wildcard(inner_ty));\n                         let extra_wildcards = other_slice.arity() - self_slice.arity();\n                         let extra_wildcards = (0..extra_wildcards).map(|_| wildcard);\n                         prefix.iter().chain(extra_wildcards).chain(suffix).collect()"}, {"sha": "7d22f7b69d862059da105dbe1dc55b71ab79cf15", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -196,6 +196,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n         }\n     }\n \n+    #[instrument(skip(self), level = \"debug\")]\n     fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat<'tcx>) -> Pat<'tcx> {\n         let mut ty = self.typeck_results.node_type(pat.hir_id);\n "}, {"sha": "f27ec22a8dee25a8a4e0cfe6669d26856761002b", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -411,12 +411,12 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     /// This is roughly the inverse of `Constructor::apply`.\n     fn pop_head_constructor(\n         &self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n     ) -> PatStack<'p, 'tcx> {\n         // We pop the head pattern and push the new fields extracted from the arguments of\n         // `self.head()`.\n-        let mut new_fields: SmallVec<[_; 2]> = self.head().specialize(cx, ctor);\n+        let mut new_fields: SmallVec<[_; 2]> = self.head().specialize(pcx, ctor);\n         new_fields.extend_from_slice(&self.pats[1..]);\n         PatStack::from_vec(new_fields)\n     }\n@@ -475,7 +475,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n         let mut matrix = Matrix::empty();\n         for row in &self.patterns {\n             if ctor.is_covered_by(pcx, row.head().ctor()) {\n-                let new_row = row.pop_head_constructor(pcx.cx, ctor);\n+                let new_row = row.pop_head_constructor(pcx, ctor);\n                 matrix.push(new_row);\n             }\n         }\n@@ -786,7 +786,7 @@ fn is_useful<'p, 'tcx>(\n     is_under_guard: bool,\n     is_top_level: bool,\n ) -> Usefulness<'p, 'tcx> {\n-    debug!(\"matrix,v={:?}{:?}\", matrix, v);\n+    debug!(?matrix, ?v);\n     let Matrix { patterns: rows, .. } = matrix;\n \n     // The base case. We are pattern-matching on () and the return value is\n@@ -806,11 +806,6 @@ fn is_useful<'p, 'tcx>(\n \n     debug_assert!(rows.iter().all(|r| r.len() == v.len()));\n \n-    let ty = v.head().ty();\n-    let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n-    debug!(\"v.head: {:?}, v.span: {:?}\", v.head(), v.head().span());\n-    let pcx = PatCtxt { cx, ty, span: v.head().span(), is_top_level, is_non_exhaustive };\n-\n     // If the first pattern is an or-pattern, expand it.\n     let mut ret = Usefulness::new_not_useful(witness_preference);\n     if v.head().is_or_pat() {\n@@ -832,6 +827,19 @@ fn is_useful<'p, 'tcx>(\n             }\n         }\n     } else {\n+        let mut ty = v.head().ty();\n+\n+        // Opaque types can't get destructured/split, but the patterns can\n+        // actually hint at hidden types, so we use the patterns' types instead.\n+        if let ty::Opaque(..) = v.head().ty().kind() {\n+            if let Some(row) = rows.first() {\n+                ty = row.head().ty();\n+            }\n+        }\n+        let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n+        debug!(\"v.head: {:?}, v.span: {:?}\", v.head(), v.head().span());\n+        let pcx = PatCtxt { cx, ty, span: v.head().span(), is_top_level, is_non_exhaustive };\n+\n         let v_ctor = v.head().ctor();\n         debug!(?v_ctor);\n         if let Constructor::IntRange(ctor_range) = &v_ctor {\n@@ -853,7 +861,7 @@ fn is_useful<'p, 'tcx>(\n             debug!(\"specialize({:?})\", ctor);\n             // We cache the result of `Fields::wildcards` because it is used a lot.\n             let spec_matrix = start_matrix.specialize_constructor(pcx, &ctor);\n-            let v = v.pop_head_constructor(cx, &ctor);\n+            let v = v.pop_head_constructor(pcx, &ctor);\n             let usefulness = ensure_sufficient_stack(|| {\n                 is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false)\n             });"}, {"sha": "7806e8f45d3ade55a4f6c907a90e0d515273e88a", "filename": "compiler/rustc_mir_dataflow/src/move_paths/abs_domain.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -48,6 +48,7 @@ impl<'tcx> Lift for PlaceElem<'tcx> {\n         match *self {\n             ProjectionElem::Deref => ProjectionElem::Deref,\n             ProjectionElem::Field(f, ty) => ProjectionElem::Field(f, ty.lift()),\n+            ProjectionElem::OpaqueCast(ty) => ProjectionElem::OpaqueCast(ty.lift()),\n             ProjectionElem::Index(ref i) => ProjectionElem::Index(i.lift()),\n             ProjectionElem::Subslice { from, to, from_end } => {\n                 ProjectionElem::Subslice { from, to, from_end }"}, {"sha": "86327ade94b8a2e6305def7f7eded40abfbdb56f", "filename": "compiler/rustc_mir_transform/src/add_retag.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -28,6 +28,7 @@ fn is_stable(place: PlaceRef<'_>) -> bool {\n             ProjectionElem::Field { .. } |\n             ProjectionElem::ConstantIndex { .. } |\n             ProjectionElem::Subslice { .. } |\n+            ProjectionElem::OpaqueCast { .. } |\n             ProjectionElem::Downcast { .. } => true,\n         }\n     })"}, {"sha": "faa9c493d88751b00196dd43ba6afa43a3058a58", "filename": "compiler/rustc_passes/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_passes%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_passes%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2FCargo.toml?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -15,6 +15,7 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_target = { path = \"../rustc_target\" }\n+rustc_macros = { path = \"../rustc_macros\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "d96e7d3efe83db095dc1e2180e8b60683d7cf5b9", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 246, "deletions": 444, "changes": 690, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -4,9 +4,10 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n+use crate::errors;\n use rustc_ast::{ast, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, MultiSpan};\n+use rustc_errors::{fluent, pluralize, struct_span_err, Applicability, MultiSpan};\n use rustc_expand::base::resolve_path;\n use rustc_feature::{AttributeDuplicates, AttributeType, BuiltinAttribute, BUILTIN_ATTRIBUTE_MAP};\n use rustc_hir as hir;\n@@ -175,16 +176,20 @@ impl CheckAttrVisitor<'_> {\n                 if let Some(BuiltinAttribute { type_: AttributeType::CrateLevel, .. }) =\n                     attr.ident().and_then(|ident| BUILTIN_ATTRIBUTE_MAP.get(&ident.name))\n                 {\n-                    self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                        let msg = match attr.style {\n-                            ast::AttrStyle::Outer => {\n-                                \"crate-level attribute should be an inner attribute: add an exclamation \\\n-                                 mark: `#![foo]`\"\n-                            }\n-                            ast::AttrStyle::Inner => \"crate-level attribute should be in the root module\",\n-                        };\n-                        lint.build(msg).emit();\n-                    });\n+                    match attr.style {\n+                        ast::AttrStyle::Outer => self.tcx.emit_spanned_lint(\n+                            UNUSED_ATTRIBUTES,\n+                            hir_id,\n+                            attr.span,\n+                            errors::OuterCrateLevelAttr,\n+                        ),\n+                        ast::AttrStyle::Inner => self.tcx.emit_spanned_lint(\n+                            UNUSED_ATTRIBUTES,\n+                            hir_id,\n+                            attr.span,\n+                            errors::InnerCrateLevelAttr,\n+                        ),\n+                    }\n                 }\n             }\n \n@@ -209,37 +214,21 @@ impl CheckAttrVisitor<'_> {\n     }\n \n     fn inline_attr_str_error_with_macro_def(&self, hir_id: HirId, attr: &Attribute, sym: &str) {\n-        self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-            lint.build(&format!(\n-                \"`#[{sym}]` is ignored on struct fields, match arms and macro defs\",\n-            ))\n-            .warn(\n-                \"this was previously accepted by the compiler but is \\\n-                 being phased out; it will become a hard error in \\\n-                 a future release!\",\n-            )\n-            .note(\n-                \"see issue #80564 <https://github.com/rust-lang/rust/issues/80564> \\\n-                 for more information\",\n-            )\n-            .emit();\n-        });\n+        self.tcx.emit_spanned_lint(\n+            UNUSED_ATTRIBUTES,\n+            hir_id,\n+            attr.span,\n+            errors::IgnoredAttrWithMacro { sym },\n+        );\n     }\n \n     fn inline_attr_str_error_without_macro_def(&self, hir_id: HirId, attr: &Attribute, sym: &str) {\n-        self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-            lint.build(&format!(\"`#[{sym}]` is ignored on struct fields and match arms\"))\n-                .warn(\n-                    \"this was previously accepted by the compiler but is \\\n-                 being phased out; it will become a hard error in \\\n-                 a future release!\",\n-                )\n-                .note(\n-                    \"see issue #80564 <https://github.com/rust-lang/rust/issues/80564> \\\n-                 for more information\",\n-                )\n-                .emit();\n-        });\n+        self.tcx.emit_spanned_lint(\n+            UNUSED_ATTRIBUTES,\n+            hir_id,\n+            attr.span,\n+            errors::IgnoredAttr { sym },\n+        );\n     }\n \n     /// Checks if an `#[inline]` is applied to a function or a closure. Returns `true` if valid.\n@@ -249,29 +238,25 @@ impl CheckAttrVisitor<'_> {\n             | Target::Closure\n             | Target::Method(MethodKind::Trait { body: true } | MethodKind::Inherent) => true,\n             Target::Method(MethodKind::Trait { body: false }) | Target::ForeignFn => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"`#[inline]` is ignored on function prototypes\").emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::IgnoredInlineAttrFnProto,\n+                );\n                 true\n             }\n             // FIXME(#65833): We permit associated consts to have an `#[inline]` attribute with\n             // just a lint, because we previously erroneously allowed it and some crates used it\n             // accidentally, to to be compatible with crates depending on them, we can't throw an\n             // error here.\n             Target::AssocConst => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"`#[inline]` is ignored on constants\")\n-                        .warn(\n-                            \"this was previously accepted by the compiler but is \\\n-                             being phased out; it will become a hard error in \\\n-                             a future release!\",\n-                        )\n-                        .note(\n-                            \"see issue #65833 <https://github.com/rust-lang/rust/issues/65833> \\\n-                             for more information\",\n-                        )\n-                        .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::IgnoredInlineAttrConstants,\n+                );\n                 true\n             }\n             // FIXME(#80564): Same for fields, arms, and macro defs\n@@ -280,14 +265,10 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    attr.span,\n-                    E0518,\n-                    \"attribute should be applied to function or closure\",\n-                )\n-                .span_label(span, \"not a function or closure\")\n-                .emit();\n+                self.tcx.sess.emit_err(errors::InlineNotFnOrClosure {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -309,36 +290,40 @@ impl CheckAttrVisitor<'_> {\n \n             // function prototypes can't be covered\n             Target::Method(MethodKind::Trait { body: false }) | Target::ForeignFn => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"`#[no_coverage]` is ignored on function prototypes\").emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::IgnoredNoCoverageFnProto,\n+                );\n                 true\n             }\n \n             Target::Mod | Target::ForeignMod | Target::Impl | Target::Trait => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"`#[no_coverage]` does not propagate into items and must be applied to the contained functions directly\").emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::IgnoredNoCoveragePropagate,\n+                );\n                 true\n             }\n \n             Target::Expression | Target::Statement | Target::Arm => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"`#[no_coverage]` may only be applied to function definitions\")\n-                        .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::IgnoredNoCoverageFnDefn,\n+                );\n                 true\n             }\n \n             _ => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    attr.span,\n-                    E0788,\n-                    \"`#[no_coverage]` must be applied to coverable code\",\n-                )\n-                .span_label(span, \"not coverable code\")\n-                .emit();\n+                self.tcx.sess.emit_err(errors::IgnoredNoCoverageNotCoverable {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -389,14 +374,10 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"attribute should be applied to a function definition\",\n-                    )\n-                    .span_label(span, \"not a function definition\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -408,14 +389,10 @@ impl CheckAttrVisitor<'_> {\n             Target::Fn\n             | Target::Method(MethodKind::Trait { body: true } | MethodKind::Inherent) => true,\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"attribute should be applied to a function definition\",\n-                    )\n-                    .span_label(span, \"not a function definition\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -432,13 +409,7 @@ impl CheckAttrVisitor<'_> {\n     ) -> bool {\n         match target {\n             _ if attrs.iter().any(|attr| attr.has_name(sym::naked)) => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    attr_span,\n-                    E0736,\n-                    \"cannot use `#[track_caller]` with `#[naked]`\",\n-                )\n-                .emit();\n+                self.tcx.sess.emit_err(errors::NakedTrackedCaller { attr_span });\n                 false\n             }\n             Target::Fn | Target::Method(..) | Target::ForeignFn | Target::Closure => true,\n@@ -453,14 +424,9 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    attr_span,\n-                    E0739,\n-                    \"attribute should be applied to function\"\n-                )\n-                .span_label(span, \"not a function\")\n-                .emit();\n+                self.tcx\n+                    .sess\n+                    .emit_err(errors::TrackedCallerWrongLocation { attr_span, defn_span: span });\n                 false\n             }\n         }\n@@ -485,14 +451,10 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    attr.span,\n-                    E0701,\n-                    \"attribute can only be applied to a struct or enum\"\n-                )\n-                .span_label(span, \"not a struct or enum\")\n-                .emit();\n+                self.tcx.sess.emit_err(errors::NonExhaustiveWrongLocation {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -511,11 +473,10 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute can only be applied to a trait\")\n-                    .span_label(span, \"not a trait\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToTrait {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -531,11 +492,10 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Trait => true,\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute can only be applied to a trait\")\n-                    .span_label(span, \"not a trait\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToTrait {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -555,16 +515,12 @@ impl CheckAttrVisitor<'_> {\n             // FIXME: #[target_feature] was previously erroneously allowed on statements and some\n             // crates used this, so only emit a warning.\n             Target::Statement => {\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"attribute should be applied to a function\")\n-                        .warn(\n-                            \"this was previously accepted by the compiler but is \\\n-                             being phased out; it will become a hard error in \\\n-                             a future release!\",\n-                        )\n-                        .span_label(span, \"not a function\")\n-                        .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::TargetFeatureOnStatement,\n+                );\n                 true\n             }\n             // FIXME(#80564): We permit struct fields, match arms and macro defs to have an\n@@ -576,11 +532,10 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied to a function\")\n-                    .span_label(span, \"not a function\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToFn {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n@@ -591,24 +546,17 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::ForeignStatic | Target::Static => true,\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"attribute should be applied to a static\")\n-                    .span_label(span, \"not a static\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::AttrShouldBeAppliedToStatic {\n+                    attr_span: attr.span,\n+                    defn_span: span,\n+                });\n                 false\n             }\n         }\n     }\n \n     fn doc_attr_str_error(&self, meta: &NestedMetaItem, attr_name: &str) {\n-        self.tcx\n-            .sess\n-            .struct_span_err(\n-                meta.span(),\n-                &format!(\"doc {0} attribute expects a string: #[doc({0} = \\\"a\\\")]\", attr_name),\n-            )\n-            .emit();\n+        self.tcx.sess.emit_err(errors::DocExpectStr { attr_span: meta.span(), attr_name });\n     }\n \n     fn check_doc_alias_value(\n@@ -621,46 +569,29 @@ impl CheckAttrVisitor<'_> {\n         aliases: &mut FxHashMap<String, Span>,\n     ) -> bool {\n         let tcx = self.tcx;\n-        let err_fn = move |span: Span, msg: &str| {\n-            tcx.sess.span_err(\n-                span,\n-                &format!(\n-                    \"`#[doc(alias{})]` {}\",\n-                    if is_list { \"(\\\"...\\\")\" } else { \" = \\\"...\\\"\" },\n-                    msg,\n-                ),\n-            );\n-            false\n-        };\n+        let span = meta.name_value_literal_span().unwrap_or_else(|| meta.span());\n+        let attr_str =\n+            &format!(\"`#[doc(alias{})]`\", if is_list { \"(\\\"...\\\")\" } else { \" = \\\"...\\\"\" });\n         if doc_alias == kw::Empty {\n-            return err_fn(\n-                meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n-                \"attribute cannot have empty value\",\n-            );\n+            tcx.sess.emit_err(errors::DocAliasEmpty { span, attr_str });\n+            return false;\n         }\n \n         let doc_alias_str = doc_alias.as_str();\n         if let Some(c) = doc_alias_str\n             .chars()\n             .find(|&c| c == '\"' || c == '\\'' || (c.is_whitespace() && c != ' '))\n         {\n-            self.tcx.sess.span_err(\n-                meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n-                &format!(\n-                    \"{:?} character isn't allowed in `#[doc(alias{})]`\",\n-                    c,\n-                    if is_list { \"(\\\"...\\\")\" } else { \" = \\\"...\\\"\" },\n-                ),\n-            );\n+            tcx.sess.emit_err(errors::DocAliasBadChar { span, attr_str, char_: c });\n             return false;\n         }\n         if doc_alias_str.starts_with(' ') || doc_alias_str.ends_with(' ') {\n-            return err_fn(\n-                meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n-                \"cannot start or end with ' '\",\n-            );\n+            tcx.sess.emit_err(errors::DocAliasStartEnd { span, attr_str });\n+            return false;\n         }\n-        if let Some(err) = match target {\n+\n+        let span = meta.span();\n+        if let Some(location) = match target {\n             Target::Impl => Some(\"implementation block\"),\n             Target::ForeignMod => Some(\"extern block\"),\n             Target::AssocTy => {\n@@ -686,19 +617,21 @@ impl CheckAttrVisitor<'_> {\n             Target::Param => return false,\n             _ => None,\n         } {\n-            return err_fn(meta.span(), &format!(\"isn't allowed on {}\", err));\n+            tcx.sess.emit_err(errors::DocAliasBadLocation { span, attr_str, location });\n+            return false;\n         }\n         let item_name = self.tcx.hir().name(hir_id);\n         if item_name == doc_alias {\n-            return err_fn(meta.span(), \"is the same as the item's name\");\n+            tcx.sess.emit_err(errors::DocAliasNotAnAlias { span, attr_str });\n+            return false;\n         }\n-        let span = meta.span();\n         if let Err(entry) = aliases.try_insert(doc_alias_str.to_owned(), span) {\n-            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, span, |lint| {\n-                lint.build(\"doc alias is duplicated\")\n-                    .span_label(*entry.entry.get(), \"first defined here\")\n-                    .emit();\n-            });\n+            self.tcx.emit_spanned_lint(\n+                UNUSED_ATTRIBUTES,\n+                hir_id,\n+                span,\n+                errors::DocAliasDuplicated { first_defn: *entry.entry.get() },\n+            );\n         }\n         true\n     }\n@@ -723,22 +656,12 @@ impl CheckAttrVisitor<'_> {\n                         _ => {\n                             self.tcx\n                                 .sess\n-                                .struct_span_err(\n-                                    v.span(),\n-                                    \"`#[doc(alias(\\\"a\\\"))]` expects string literals\",\n-                                )\n-                                .emit();\n+                                .emit_err(errors::DocAliasNotStringLiteral { span: v.span() });\n                             errors += 1;\n                         }\n                     },\n                     None => {\n-                        self.tcx\n-                            .sess\n-                            .struct_span_err(\n-                                v.span(),\n-                                \"`#[doc(alias(\\\"a\\\"))]` expects string literals\",\n-                            )\n-                            .emit();\n+                        self.tcx.sess.emit_err(errors::DocAliasNotStringLiteral { span: v.span() });\n                         errors += 1;\n                     }\n                 }\n@@ -747,14 +670,7 @@ impl CheckAttrVisitor<'_> {\n         } else if let Some(doc_alias) = meta.value_str() {\n             self.check_doc_alias_value(meta, doc_alias, hir_id, target, false, aliases)\n         } else {\n-            self.tcx\n-                .sess\n-                .struct_span_err(\n-                    meta.span(),\n-                    \"doc alias attribute expects a string `#[doc(alias = \\\"a\\\")]` or a list of \\\n-                     strings `#[doc(alias(\\\"a\\\", \\\"b\\\"))]`\",\n-                )\n-                .emit();\n+            self.tcx.sess.emit_err(errors::DocAliasMalformed { span: meta.span() });\n             false\n         }\n     }\n@@ -771,35 +687,20 @@ impl CheckAttrVisitor<'_> {\n         }) {\n             Some(ItemKind::Mod(ref module)) => {\n                 if !module.item_ids.is_empty() {\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(\n-                            meta.span(),\n-                            \"`#[doc(keyword = \\\"...\\\")]` can only be used on empty modules\",\n-                        )\n-                        .emit();\n+                    self.tcx.sess.emit_err(errors::DocKeywordEmptyMod { span: meta.span() });\n                     return false;\n                 }\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        meta.span(),\n-                        \"`#[doc(keyword = \\\"...\\\")]` can only be used on modules\",\n-                    )\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::DocKeywordNotMod { span: meta.span() });\n                 return false;\n             }\n         }\n         if !rustc_lexer::is_ident(doc_keyword.as_str()) {\n-            self.tcx\n-                .sess\n-                .struct_span_err(\n-                    meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n-                    &format!(\"`{doc_keyword}` is not a valid identifier\"),\n-                )\n-                .emit();\n+            self.tcx.sess.emit_err(errors::DocKeywordInvalidIdent {\n+                span: meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n+                doc_keyword,\n+            });\n             return false;\n         }\n         true\n@@ -812,24 +713,12 @@ impl CheckAttrVisitor<'_> {\n         }) {\n             Some(ItemKind::Impl(ref i)) => {\n                 if !matches!(&i.self_ty.kind, hir::TyKind::Tup([_])) {\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(\n-                            meta.span(),\n-                            \"`#[doc(tuple_variadic)]` must be used on the first of a set of tuple trait impls with varying arity\",\n-                        )\n-                        .emit();\n+                    self.tcx.sess.emit_err(errors::DocTupleVariadicNotFirst { span: meta.span() });\n                     return false;\n                 }\n             }\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        meta.span(),\n-                        \"`#[doc(keyword = \\\"...\\\")]` can only be used on impl blocks\",\n-                    )\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::DocKeywordOnlyImpl { span: meta.span() });\n                 return false;\n             }\n         }\n@@ -858,13 +747,9 @@ impl CheckAttrVisitor<'_> {\n             if let Some((prev_inline, prev_span)) = *specified_inline {\n                 if do_inline != prev_inline {\n                     let mut spans = MultiSpan::from_spans(vec![prev_span, meta.span()]);\n-                    spans.push_span_label(prev_span, \"this attribute...\");\n-                    spans.push_span_label(meta.span(), \"...conflicts with this attribute\");\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(spans, \"conflicting doc inlining attributes\")\n-                        .help(\"remove one of the conflicting attributes\")\n-                        .emit();\n+                    spans.push_span_label(prev_span, fluent::passes::doc_inline_conflict_first);\n+                    spans.push_span_label(meta.span(), fluent::passes::doc_inline_conflict_second);\n+                    self.tcx.sess.emit_err(errors::DocKeywordConflict { spans });\n                     return false;\n                 }\n                 true\n@@ -873,23 +758,14 @@ impl CheckAttrVisitor<'_> {\n                 true\n             }\n         } else {\n-            self.tcx.struct_span_lint_hir(\n+            self.tcx.emit_spanned_lint(\n                 INVALID_DOC_ATTRIBUTES,\n                 hir_id,\n                 meta.span(),\n-                |lint| {\n-                    let mut err = lint.build(\n-                        \"this attribute can only be applied to a `use` item\",\n-                    );\n-                    err.span_label(meta.span(), \"only applicable on `use` items\");\n-                    if attr.style == AttrStyle::Outer {\n-                        err.span_label(\n-                            self.tcx.hir().span(hir_id),\n-                            \"not a `use` item\",\n-                        );\n-                    }\n-                    err.note(\"read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline for more information\")\n-                        .emit();\n+                errors::DocInlineOnlyUse {\n+                    attr_span: meta.span(),\n+                    item_span: (attr.style == AttrStyle::Outer)\n+                        .then(|| self.tcx.hir().span(hir_id)),\n                 },\n             );\n             false\n@@ -904,15 +780,7 @@ impl CheckAttrVisitor<'_> {\n         attr_name: &str,\n     ) -> bool {\n         if CRATE_HIR_ID == hir_id {\n-            self.tcx\n-                .sess\n-                .struct_span_err(\n-                    meta.span(),\n-                    &format!(\n-                        \"`#![doc({attr_name} = \\\"...\\\")]` isn't allowed as a crate-level attribute\",\n-                    ),\n-                )\n-                .emit();\n+            self.tcx.sess.emit_err(errors::DocAttrNotCrateLevel { span: meta.span(), attr_name });\n             return false;\n         }\n         true\n@@ -926,36 +794,25 @@ impl CheckAttrVisitor<'_> {\n         hir_id: HirId,\n     ) -> bool {\n         if hir_id != CRATE_HIR_ID {\n-            self.tcx.struct_span_lint_hir(\n-                INVALID_DOC_ATTRIBUTES,\n-                hir_id,\n-                meta.span(),\n-                |lint| {\n-                    let mut err = lint.build(\n-                        \"this attribute can only be applied at the crate level\",\n-                    );\n-                    if attr.style == AttrStyle::Outer && self.tcx.hir().get_parent_item(hir_id) == CRATE_DEF_ID {\n-                        if let Ok(mut src) =\n-                            self.tcx.sess.source_map().span_to_snippet(attr.span)\n-                        {\n-                            src.insert(1, '!');\n-                            err.span_suggestion_verbose(\n-                                attr.span,\n-                                \"to apply to the crate, use an inner attribute\",\n-                                src,\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        } else {\n-                            err.span_help(\n-                                attr.span,\n-                                \"to apply to the crate, use an inner attribute\",\n-                            );\n-                        }\n+            self.tcx.struct_span_lint_hir(INVALID_DOC_ATTRIBUTES, hir_id, meta.span(), |lint| {\n+                let mut err = lint.build(fluent::passes::attr_crate_level);\n+                if attr.style == AttrStyle::Outer\n+                    && self.tcx.hir().get_parent_item(hir_id) == CRATE_DEF_ID\n+                {\n+                    if let Ok(mut src) = self.tcx.sess.source_map().span_to_snippet(attr.span) {\n+                        src.insert(1, '!');\n+                        err.span_suggestion_verbose(\n+                            attr.span,\n+                            fluent::passes::suggestion,\n+                            src,\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        err.span_help(attr.span, fluent::passes::help);\n                     }\n-                    err.note(\"read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\")\n-                        .emit();\n-                },\n-            );\n+                }\n+                err.note(fluent::passes::note).emit();\n+            });\n             return false;\n         }\n         true\n@@ -970,28 +827,27 @@ impl CheckAttrVisitor<'_> {\n                 match i_meta.name_or_empty() {\n                     sym::attr | sym::no_crate_inject => {}\n                     _ => {\n-                        self.tcx.struct_span_lint_hir(\n+                        self.tcx.emit_spanned_lint(\n                             INVALID_DOC_ATTRIBUTES,\n                             hir_id,\n                             i_meta.span(),\n-                            |lint| {\n-                                lint.build(&format!(\n-                                    \"unknown `doc(test)` attribute `{}`\",\n-                                    rustc_ast_pretty::pprust::path_to_string(\n-                                        &i_meta.meta_item().unwrap().path\n-                                    ),\n-                                ))\n-                                .emit();\n+                            errors::DocTestUnknown {\n+                                path: rustc_ast_pretty::pprust::path_to_string(\n+                                    &i_meta.meta_item().unwrap().path,\n+                                ),\n                             },\n                         );\n                         is_valid = false;\n                     }\n                 }\n             }\n         } else {\n-            self.tcx.struct_span_lint_hir(INVALID_DOC_ATTRIBUTES, hir_id, meta.span(), |lint| {\n-                lint.build(\"`#[doc(test(...)]` takes a list of attributes\").emit();\n-            });\n+            self.tcx.emit_spanned_lint(\n+                INVALID_DOC_ATTRIBUTES,\n+                hir_id,\n+                meta.span(),\n+                errors::DocTestTakesList,\n+            );\n             is_valid = false;\n         }\n         is_valid\n@@ -1093,79 +949,66 @@ impl CheckAttrVisitor<'_> {\n \n                         sym::primitive => {\n                             if !self.tcx.features().rustdoc_internals {\n-                                self.tcx.struct_span_lint_hir(\n+                                self.tcx.emit_spanned_lint(\n                                     INVALID_DOC_ATTRIBUTES,\n                                     hir_id,\n                                     i_meta.span,\n-                                    |lint| {\n-                                        let mut diag = lint.build(\n-                                            \"`doc(primitive)` should never have been stable\",\n-                                        );\n-                                        diag.emit();\n-                                    },\n+                                    errors::DocPrimitive,\n                                 );\n                             }\n                         }\n \n                         _ => {\n-                            self.tcx.struct_span_lint_hir(\n-                                INVALID_DOC_ATTRIBUTES,\n-                                hir_id,\n-                                i_meta.span,\n-                                |lint| {\n-                                    let mut diag = lint.build(&format!(\n-                                        \"unknown `doc` attribute `{}`\",\n-                                        rustc_ast_pretty::pprust::path_to_string(&i_meta.path),\n-                                    ));\n-                                    if i_meta.has_name(sym::spotlight) {\n-                                        diag.note(\n-                                            \"`doc(spotlight)` was renamed to `doc(notable_trait)`\",\n-                                        );\n-                                        diag.span_suggestion_short(\n-                                            i_meta.span,\n-                                            \"use `notable_trait` instead\",\n-                                            \"notable_trait\",\n-                                            Applicability::MachineApplicable,\n-                                        );\n-                                        diag.note(\"`doc(spotlight)` is now a no-op\");\n+                            let path = rustc_ast_pretty::pprust::path_to_string(&i_meta.path);\n+                            if i_meta.has_name(sym::spotlight) {\n+                                self.tcx.emit_spanned_lint(\n+                                    INVALID_DOC_ATTRIBUTES,\n+                                    hir_id,\n+                                    i_meta.span,\n+                                    errors::DocTestUnknownSpotlight {\n+                                        path,\n+                                        span: i_meta.span\n                                     }\n-                                    if i_meta.has_name(sym::include) {\n-                                        if let Some(value) = i_meta.value_str() {\n-                                            // if there are multiple attributes, the suggestion would suggest deleting all of them, which is incorrect\n-                                            let applicability = if list.len() == 1 {\n-                                                Applicability::MachineApplicable\n-                                            } else {\n-                                                Applicability::MaybeIncorrect\n-                                            };\n-                                            let inner = if attr.style == AttrStyle::Inner {\n-                                                \"!\"\n-                                            } else {\n-                                                \"\"\n-                                            };\n-                                            diag.span_suggestion(\n-                                                attr.meta().unwrap().span,\n-                                                \"use `doc = include_str!` instead\",\n-                                                format!(\n-                                                    \"#{inner}[doc = include_str!(\\\"{value}\\\")]\",\n-                                                ),\n-                                                applicability,\n-                                            );\n-                                        }\n+                                );\n+                            } else if i_meta.has_name(sym::include) &&\n+                                    let Some(value) = i_meta.value_str() {\n+                                let applicability = if list.len() == 1 {\n+                                    Applicability::MachineApplicable\n+                                } else {\n+                                    Applicability::MaybeIncorrect\n+                                };\n+                                // If there are multiple attributes, the suggestion would suggest\n+                                // deleting all of them, which is incorrect.\n+                                self.tcx.emit_spanned_lint(\n+                                    INVALID_DOC_ATTRIBUTES,\n+                                    hir_id,\n+                                    i_meta.span,\n+                                    errors::DocTestUnknownInclude {\n+                                        path,\n+                                        value: value.to_string(),\n+                                        inner: (attr.style == AttrStyle::Inner)\n+                                            .then_some(\"!\")\n+                                            .unwrap_or(\"\"),\n+                                        sugg: (attr.meta().unwrap().span, applicability),\n                                     }\n-                                    diag.emit();\n-                                },\n-                            );\n+                                );\n+                            } else {\n+                                self.tcx.emit_spanned_lint(\n+                                    INVALID_DOC_ATTRIBUTES,\n+                                    hir_id,\n+                                    i_meta.span,\n+                                    errors::DocTestUnknownAny { path }\n+                                );\n+                            }\n                             is_valid = false;\n                         }\n                     }\n                 } else {\n-                    self.tcx.struct_span_lint_hir(\n+                    self.tcx.emit_spanned_lint(\n                         INVALID_DOC_ATTRIBUTES,\n                         hir_id,\n                         meta.span(),\n-                        |lint| {\n-                            lint.build(\"invalid `doc` attribute\").emit();\n-                        },\n+                        errors::DocInvalid,\n                     );\n                     is_valid = false;\n                 }\n@@ -1180,14 +1023,7 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Struct | Target::Enum | Target::TyAlias => true,\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"`pass_by_value` attribute should be applied to a struct, enum or type alias.\",\n-                    )\n-                    .span_label(span, \"is not a struct, enum or type alias\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::PassByValue { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1197,14 +1033,7 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Method(MethodKind::Inherent) => true,\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"`rustc_allow_incoherent_impl` attribute should be applied to impl items.\",\n-                    )\n-                    .span_label(span, \"the only currently supported targets are inherent methods\")\n-                    .emit();\n+                self.tcx.sess.emit_err(errors::AllowIncoherentImpl { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1223,12 +1052,7 @@ impl CheckAttrVisitor<'_> {\n             _ => {\n                 self.tcx\n                     .sess\n-                    .struct_span_err(\n-                        attr.span,\n-                        \"`rustc_has_incoherent_inherent_impls` attribute should be applied to types or traits.\",\n-                    )\n-                    .span_label(span, \"only adts, extern types and traits are supported\")\n-                    .emit();\n+                    .emit_err(errors::HasIncoherentInherentImpl { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1238,19 +1062,12 @@ impl CheckAttrVisitor<'_> {\n     fn check_must_use(&self, hir_id: HirId, attr: &Attribute, span: Span, target: Target) -> bool {\n         let node = self.tcx.hir().get(hir_id);\n         if let Some(kind) = node.fn_kind() && let rustc_hir::IsAsync::Async = kind.asyncness() {\n-            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                lint.build(\n-                    \"`must_use` attribute on `async` functions \\\n-                    applies to the anonymous `Future` returned by the \\\n-                    function, not the value within\",\n-                )\n-                .span_label(\n-                    span,\n-                    \"this attribute does nothing, the `Future`s \\\n-                    returned by async functions are already `must_use`\",\n-                )\n-                .emit();\n-            });\n+            self.tcx.emit_spanned_lint(\n+                UNUSED_ATTRIBUTES,\n+                hir_id,\n+                attr.span,\n+                errors::MustUseAsync { span }\n+            );\n         }\n \n         if !matches!(\n@@ -1278,12 +1095,12 @@ impl CheckAttrVisitor<'_> {\n                 _ => \"a\",\n             };\n \n-            self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                lint.build(&format!(\n-                    \"`#[must_use]` has no effect when applied to {article} {target}\"\n-                ))\n-                .emit();\n-            });\n+            self.tcx.emit_spanned_lint(\n+                UNUSED_ATTRIBUTES,\n+                hir_id,\n+                attr.span,\n+                errors::MustUseNoEffect { article, target },\n+            );\n         }\n \n         // For now, its always valid\n@@ -1295,11 +1112,7 @@ impl CheckAttrVisitor<'_> {\n         match target {\n             Target::Struct | Target::Enum | Target::Union | Target::Trait => true,\n             _ => {\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(attr.span, \"`must_not_suspend` attribute should be applied to a struct, enum, or trait\")\n-                        .span_label(span, \"is not a struct, enum, or trait\")\n-                        .emit();\n+                self.tcx.sess.emit_err(errors::MustNotSuspend { attr_span: attr.span, span });\n                 false\n             }\n         }\n@@ -1319,16 +1132,12 @@ impl CheckAttrVisitor<'_> {\n             _ => {\n                 // FIXME: #[cold] was previously allowed on non-functions and some crates used\n                 // this, so only emit a warning.\n-                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-                    lint.build(\"attribute should be applied to a function\")\n-                        .warn(\n-                            \"this was previously accepted by the compiler but is \\\n-                             being phased out; it will become a hard error in \\\n-                             a future release!\",\n-                        )\n-                        .span_label(span, \"not a function\")\n-                        .emit();\n-                });\n+                self.tcx.emit_spanned_lint(\n+                    UNUSED_ATTRIBUTES,\n+                    hir_id,\n+                    attr.span,\n+                    errors::Cold { span },\n+                );\n             }\n         }\n     }\n@@ -1343,19 +1152,12 @@ impl CheckAttrVisitor<'_> {\n             return;\n         }\n \n-        self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n-            let mut diag =\n-                lint.build(\"attribute should be applied to an `extern` block with non-Rust ABI\");\n-            diag.warn(\n-                \"this was previously accepted by the compiler but is \\\n-                 being phased out; it will become a hard error in \\\n-                 a future release!\",\n-            );\n-            if target != Target::ForeignMod {\n-                diag.span_label(span, \"not an `extern` block\");\n-            }\n-            diag.emit();\n-        });\n+        self.tcx.emit_spanned_lint(\n+            UNUSED_ATTRIBUTES,\n+            hir_id,\n+            attr.span,\n+            errors::Link { span: (target != Target::ForeignMod).then_some(span) },\n+        );\n     }\n \n     /// Checks if `#[link_name]` is applied to an item other than a foreign function or static."}, {"sha": "f8e8720ab5474231a487f2c7fd2d251e611fc62b", "filename": "compiler/rustc_passes/src/errors.rs", "status": "added", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,362 @@\n+use rustc_errors::{Applicability, MultiSpan};\n+use rustc_macros::{LintDiagnostic, SessionDiagnostic};\n+use rustc_span::{Span, Symbol};\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::outer_crate_level_attr)]\n+pub struct OuterCrateLevelAttr;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::inner_crate_level_attr)]\n+pub struct InnerCrateLevelAttr;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::ignored_attr_with_macro)]\n+pub struct IgnoredAttrWithMacro<'a> {\n+    pub sym: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::ignored_attr)]\n+pub struct IgnoredAttr<'a> {\n+    pub sym: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::inline_ignored_function_prototype)]\n+pub struct IgnoredInlineAttrFnProto;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::inline_ignored_constants)]\n+#[warn_]\n+#[note]\n+pub struct IgnoredInlineAttrConstants;\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::inline_not_fn_or_closure, code = \"E0518\")]\n+pub struct InlineNotFnOrClosure {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub defn_span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::no_coverage_ignored_function_prototype)]\n+pub struct IgnoredNoCoverageFnProto;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::no_coverage_propagate)]\n+pub struct IgnoredNoCoveragePropagate;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::no_coverage_fn_defn)]\n+pub struct IgnoredNoCoverageFnDefn;\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::no_coverage_not_coverable, code = \"E0788\")]\n+pub struct IgnoredNoCoverageNotCoverable {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub defn_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::should_be_applied_to_fn)]\n+pub struct AttrShouldBeAppliedToFn {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub defn_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::naked_tracked_caller, code = \"E0736\")]\n+pub struct NakedTrackedCaller {\n+    #[primary_span]\n+    pub attr_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::should_be_applied_to_fn, code = \"E0739\")]\n+pub struct TrackedCallerWrongLocation {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub defn_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::should_be_applied_to_struct_enum, code = \"E0701\")]\n+pub struct NonExhaustiveWrongLocation {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub defn_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::should_be_applied_to_trait)]\n+pub struct AttrShouldBeAppliedToTrait {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub defn_span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::target_feature_on_statement)]\n+pub struct TargetFeatureOnStatement;\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::should_be_applied_to_static)]\n+pub struct AttrShouldBeAppliedToStatic {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub defn_span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_expect_str)]\n+pub struct DocExpectStr<'a> {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    pub attr_name: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_alias_empty)]\n+pub struct DocAliasEmpty<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr_str: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_alias_bad_char)]\n+pub struct DocAliasBadChar<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr_str: &'a str,\n+    pub char_: char,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_alias_start_end)]\n+pub struct DocAliasStartEnd<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr_str: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_alias_bad_location)]\n+pub struct DocAliasBadLocation<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr_str: &'a str,\n+    pub location: &'a str,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_alias_not_an_alias)]\n+pub struct DocAliasNotAnAlias<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr_str: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_alias_duplicated)]\n+pub struct DocAliasDuplicated {\n+    #[label]\n+    pub first_defn: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_alias_not_string_literal)]\n+pub struct DocAliasNotStringLiteral {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_alias_malformed)]\n+pub struct DocAliasMalformed {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_keyword_empty_mod)]\n+pub struct DocKeywordEmptyMod {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_keyword_not_mod)]\n+pub struct DocKeywordNotMod {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_keyword_invalid_ident)]\n+pub struct DocKeywordInvalidIdent {\n+    #[primary_span]\n+    pub span: Span,\n+    pub doc_keyword: Symbol,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_tuple_variadic_not_first)]\n+pub struct DocTupleVariadicNotFirst {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_keyword_only_impl)]\n+pub struct DocKeywordOnlyImpl {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_inline_conflict)]\n+#[help]\n+pub struct DocKeywordConflict {\n+    #[primary_span]\n+    pub spans: MultiSpan,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_inline_only_use)]\n+#[note]\n+pub struct DocInlineOnlyUse {\n+    #[label]\n+    pub attr_span: Span,\n+    #[label(passes::not_a_use_item_label)]\n+    pub item_span: Option<Span>,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::doc_attr_not_crate_level)]\n+pub struct DocAttrNotCrateLevel<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub attr_name: &'a str,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_test_unknown)]\n+pub struct DocTestUnknown {\n+    pub path: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_test_takes_list)]\n+pub struct DocTestTakesList;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_primitive)]\n+pub struct DocPrimitive;\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_test_unknown_any)]\n+pub struct DocTestUnknownAny {\n+    pub path: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_test_unknown_spotlight)]\n+#[note]\n+#[note(passes::no_op_note)]\n+pub struct DocTestUnknownSpotlight {\n+    pub path: String,\n+    #[suggestion_short(applicability = \"machine-applicable\", code = \"notable_trait\")]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_test_unknown_include)]\n+pub struct DocTestUnknownInclude {\n+    pub path: String,\n+    pub value: String,\n+    pub inner: &'static str,\n+    #[suggestion(code = \"#{inner}[doc = include_str!(\\\"{value}\\\")]\")]\n+    pub sugg: (Span, Applicability),\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::doc_invalid)]\n+pub struct DocInvalid;\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::pass_by_value)]\n+pub struct PassByValue {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::allow_incoherent_impl)]\n+pub struct AllowIncoherentImpl {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::has_incoherent_inherent_impl)]\n+pub struct HasIncoherentInherentImpl {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::must_use_async)]\n+pub struct MustUseAsync {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::must_use_no_effect)]\n+pub struct MustUseNoEffect {\n+    pub article: &'static str,\n+    pub target: rustc_hir::Target,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(passes::must_not_suspend)]\n+pub struct MustNotSuspend {\n+    #[primary_span]\n+    pub attr_span: Span,\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::cold)]\n+#[warn_]\n+pub struct Cold {\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(passes::link)]\n+#[warn_]\n+pub struct Link {\n+    #[label]\n+    pub span: Option<Span>,\n+}"}, {"sha": "7b2f83958af85cd31c4bf0f3ebd87a7c5e8aa87e", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -7,8 +7,8 @@\n #![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(iter_intersperse)]\n-#![feature(let_else)]\n #![feature(let_chains)]\n+#![feature(let_else)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n #![feature(try_blocks)]\n@@ -27,6 +27,7 @@ pub mod dead;\n mod debugger_visualizer;\n mod diagnostic_items;\n pub mod entry;\n+mod errors;\n pub mod hir_id_validator;\n pub mod hir_stats;\n mod lang_items;"}, {"sha": "b0fac91f6ebc35831e6790f8406bdf358272d041", "filename": "compiler/rustc_privacy/src/errors.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,4 +1,4 @@\n-use rustc_macros::{SessionDiagnostic, SessionSubdiagnostic};\n+use rustc_macros::{LintDiagnostic, SessionDiagnostic, SessionSubdiagnostic};\n use rustc_span::{Span, Symbol};\n \n #[derive(SessionDiagnostic)]\n@@ -73,3 +73,19 @@ pub struct InPublicInterface<'a> {\n     #[label(privacy::visibility_label)]\n     pub vis_span: Span,\n }\n+\n+#[derive(LintDiagnostic)]\n+#[lint(privacy::from_private_dep_in_public_interface)]\n+pub struct FromPrivateDependencyInPublicInterface<'a> {\n+    pub kind: &'a str,\n+    pub descr: String,\n+    pub krate: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[lint(privacy::private_in_public_lint)]\n+pub struct PrivateInPublicLint<'a> {\n+    pub vis_descr: &'static str,\n+    pub kind: &'a str,\n+    pub descr: String,\n+}"}, {"sha": "9a835808d4935518ea21e24dd95189aa85a477ab", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 12, "deletions": 23, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -38,8 +38,8 @@ use std::ops::ControlFlow;\n use std::{cmp, fmt, mem};\n \n use errors::{\n-    FieldIsPrivate, FieldIsPrivateLabel, InPublicInterface, InPublicInterfaceTraits, ItemIsPrivate,\n-    UnnamedItemIsPrivate,\n+    FieldIsPrivate, FieldIsPrivateLabel, FromPrivateDependencyInPublicInterface, InPublicInterface,\n+    InPublicInterfaceTraits, ItemIsPrivate, PrivateInPublicLint, UnnamedItemIsPrivate,\n };\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -1716,19 +1716,14 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n \n     fn check_def_id(&mut self, def_id: DefId, kind: &str, descr: &dyn fmt::Display) -> bool {\n         if self.leaks_private_dep(def_id) {\n-            self.tcx.struct_span_lint_hir(\n+            self.tcx.emit_spanned_lint(\n                 lint::builtin::EXPORTED_PRIVATE_DEPENDENCIES,\n                 self.tcx.hir().local_def_id_to_hir_id(self.item_def_id),\n                 self.tcx.def_span(self.item_def_id.to_def_id()),\n-                |lint| {\n-                    lint.build(&format!(\n-                        \"{} `{}` from private dependency '{}' in public \\\n-                                                interface\",\n-                        kind,\n-                        descr,\n-                        self.tcx.crate_name(def_id.krate)\n-                    ))\n-                    .emit();\n+                FromPrivateDependencyInPublicInterface {\n+                    kind,\n+                    descr: descr.to_string(),\n+                    krate: self.tcx.crate_name(def_id.krate),\n                 },\n             );\n         }\n@@ -1754,12 +1749,14 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n                 }\n             };\n             let span = self.tcx.def_span(self.item_def_id.to_def_id());\n+            let descr = descr.to_string();\n             if self.has_old_errors\n                 || self.in_assoc_ty\n                 || self.tcx.resolutions(()).has_pub_restricted\n             {\n                 let descr = descr.to_string();\n-                let vis_span = self.tcx.def_span(def_id);\n+                let vis_span =\n+                    self.tcx.sess.source_map().guess_head_span(self.tcx.def_span(def_id));\n                 if kind == \"trait\" {\n                     self.tcx.sess.emit_err(InPublicInterfaceTraits {\n                         span,\n@@ -1778,19 +1775,11 @@ impl SearchInterfaceForPrivateItemsVisitor<'_> {\n                     });\n                 }\n             } else {\n-                let err_code = if kind == \"trait\" { \"E0445\" } else { \"E0446\" };\n-                self.tcx.struct_span_lint_hir(\n+                self.tcx.emit_spanned_lint(\n                     lint::builtin::PRIVATE_IN_PUBLIC,\n                     hir_id,\n                     span,\n-                    |lint| {\n-                        lint.build(&format!(\n-                            \"{} (error {})\",\n-                            format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr),\n-                            err_code\n-                        ))\n-                        .emit();\n-                    },\n+                    PrivateInPublicLint { vis_descr, kind, descr },\n                 );\n             }\n         }"}, {"sha": "eede4d16ea378b268a91e6d8e8f50c09ac1026d8", "filename": "compiler/rustc_session/src/code_stats.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcode_stats.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,11 +1,12 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lock;\n+use rustc_span::Symbol;\n use rustc_target::abi::{Align, Size};\n use std::cmp::{self, Ordering};\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct VariantInfo {\n-    pub name: Option<String>,\n+    pub name: Option<Symbol>,\n     pub kind: SizeKind,\n     pub size: u64,\n     pub align: u64,\n@@ -20,7 +21,7 @@ pub enum SizeKind {\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub struct FieldInfo {\n-    pub name: String,\n+    pub name: Symbol,\n     pub offset: u64,\n     pub size: u64,\n     pub align: u64,\n@@ -119,7 +120,7 @@ impl CodeStats {\n                 let VariantInfo { ref name, kind: _, align: _, size, ref fields } = *variant_info;\n                 let indent = if !struct_like {\n                     let name = match name.as_ref() {\n-                        Some(name) => name.to_owned(),\n+                        Some(name) => name.to_string(),\n                         None => i.to_string(),\n                     };\n                     println!("}, {"sha": "8a679ca005f3d567740c89fdfbf98fc2e4a403ff", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 11, "deletions": 30, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -23,7 +23,7 @@ use rustc_hir::GenericParam;\n use rustc_hir::Item;\n use rustc_hir::Node;\n use rustc_infer::infer::error_reporting::same_type_modulo_infer;\n-use rustc_infer::traits::{AmbiguousSelection, TraitEngine};\n+use rustc_infer::traits::TraitEngine;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::ExpectedFound;\n@@ -1403,7 +1403,7 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n     fn annotate_source_of_ambiguity(\n         &self,\n         err: &mut Diagnostic,\n-        impls: &[AmbiguousSelection],\n+        impls: &[DefId],\n         predicate: ty::Predicate<'tcx>,\n     );\n \n@@ -2036,14 +2036,6 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                 );\n                 match selcx.select_from_obligation(&obligation) {\n                     Err(SelectionError::Ambiguous(impls)) if impls.len() > 1 => {\n-                        if self.is_tainted_by_errors() && subst.is_none() {\n-                            // If `subst.is_none()`, then this is probably two param-env\n-                            // candidates or impl candidates that are equal modulo lifetimes.\n-                            // Therefore, if we've already emitted an error, just skip this\n-                            // one, since it's not particularly actionable.\n-                            err.cancel();\n-                            return;\n-                        }\n                         self.annotate_source_of_ambiguity(&mut err, &impls, predicate);\n                     }\n                     _ => {\n@@ -2224,35 +2216,24 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n     fn annotate_source_of_ambiguity(\n         &self,\n         err: &mut Diagnostic,\n-        impls: &[AmbiguousSelection],\n+        impls: &[DefId],\n         predicate: ty::Predicate<'tcx>,\n     ) {\n         let mut spans = vec![];\n         let mut crates = vec![];\n         let mut post = vec![];\n-        let mut or_where_clause = false;\n-        for ambig in impls {\n-            match ambig {\n-                AmbiguousSelection::Impl(def_id) => match self.tcx.span_of_impl(*def_id) {\n-                    Ok(span) => spans.push(span),\n-                    Err(name) => {\n-                        crates.push(name);\n-                        if let Some(header) = to_pretty_impl_header(self.tcx, *def_id) {\n-                            post.push(header);\n-                        }\n+        for def_id in impls {\n+            match self.tcx.span_of_impl(*def_id) {\n+                Ok(span) => spans.push(span),\n+                Err(name) => {\n+                    crates.push(name);\n+                    if let Some(header) = to_pretty_impl_header(self.tcx, *def_id) {\n+                        post.push(header);\n                     }\n-                },\n-                AmbiguousSelection::ParamEnv(span) => {\n-                    or_where_clause = true;\n-                    spans.push(*span);\n                 }\n             }\n         }\n-        let msg = format!(\n-            \"multiple `impl`s{} satisfying `{}` found\",\n-            if or_where_clause { \" or `where` clauses\" } else { \"\" },\n-            predicate\n-        );\n+        let msg = format!(\"multiple `impl`s satisfying `{}` found\", predicate);\n         let mut crate_names: Vec<_> = crates.iter().map(|n| format!(\"`{}`\", n)).collect();\n         crate_names.sort();\n         crate_names.dedup();"}, {"sha": "6e8581128dd8ea2a822c49a806e0238a5dfc9665", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 2, "deletions": 41, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -6,11 +6,9 @@\n //!\n //! [rustc dev guide]:https://rustc-dev-guide.rust-lang.org/traits/resolution.html#candidate-assembly\n use hir::LangItem;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_infer::traits::util::elaborate_predicates_with_span;\n-use rustc_infer::traits::{AmbiguousSelection, TraitEngine};\n+use rustc_infer::traits::TraitEngine;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n use rustc_lint_defs::builtin::DEREF_INTO_DYN_SUPERTRAIT;\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -201,48 +199,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // and report ambiguity.\n                     if i > 1 {\n                         debug!(\"multiple matches, ambig\");\n-\n-                        // Collect a list of (probable) spans that point to a param-env candidate\n-                        let tcx = self.infcx.tcx;\n-                        let owner = stack.obligation.cause.body_id.owner.to_def_id();\n-                        let predicates = tcx.predicates_of(owner).instantiate_identity(tcx);\n-                        let param_env_spans: FxHashMap<_, _> = elaborate_predicates_with_span(\n-                            tcx,\n-                            std::iter::zip(predicates.predicates, predicates.spans),\n-                        )\n-                        .filter_map(|obligation| {\n-                            let kind = obligation.predicate.kind();\n-                            if let ty::PredicateKind::Trait(trait_pred) = kind.skip_binder() {\n-                                if trait_pred.trait_ref\n-                                    == ty::TraitRef::identity(tcx, trait_pred.def_id())\n-                                        .skip_binder()\n-                                {\n-                                    // HACK: Remap the `Self: Trait` predicate that every trait has to a more useful span\n-                                    Some((\n-                                        kind.rebind(trait_pred),\n-                                        tcx.def_span(trait_pred.def_id()),\n-                                    ))\n-                                } else {\n-                                    Some((kind.rebind(trait_pred), obligation.cause.span))\n-                                }\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                        .collect();\n-\n                         return Err(Ambiguous(\n                             candidates\n                                 .into_iter()\n                                 .filter_map(|c| match c.candidate {\n-                                    SelectionCandidate::ImplCandidate(def_id) => {\n-                                        Some(AmbiguousSelection::Impl(def_id))\n-                                    }\n-                                    SelectionCandidate::ParamCandidate(predicate) => {\n-                                        Some(AmbiguousSelection::ParamEnv(\n-                                            *param_env_spans.get(&predicate)?,\n-                                        ))\n-                                    }\n+                                    SelectionCandidate::ImplCandidate(def_id) => Some(def_id),\n                                     _ => None,\n                                 })\n                                 .collect(),"}, {"sha": "9e4da0580522b54fd21940f109c3fd1fd8e0329a", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -2486,7 +2486,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                         concrete type's name `{type_name}` instead if you want to \\\n                                         specify its type parameters\"\n                                     ),\n-                                    type_name.to_string(),\n+                                    type_name,\n                                     Applicability::MaybeIncorrect,\n                                 );\n                             }"}, {"sha": "a53217ef81882825b4744d8eaf2a34bc02bb589f", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -544,7 +544,7 @@ fn compare_self_type<'tcx>(\n             if let Some(span) = tcx.hir().span_if_local(trait_m.def_id) {\n                 err.span_label(span, format!(\"trait method declared without `{self_descr}`\"));\n             } else {\n-                err.note_trait_signature(trait_m.name.to_string(), trait_m.signature(tcx));\n+                err.note_trait_signature(trait_m.name, trait_m.signature(tcx));\n             }\n             let reported = err.emit();\n             return Err(reported);\n@@ -564,7 +564,7 @@ fn compare_self_type<'tcx>(\n             if let Some(span) = tcx.hir().span_if_local(trait_m.def_id) {\n                 err.span_label(span, format!(\"`{self_descr}` used in trait\"));\n             } else {\n-                err.note_trait_signature(trait_m.name.to_string(), trait_m.signature(tcx));\n+                err.note_trait_signature(trait_m.name, trait_m.signature(tcx));\n             }\n             let reported = err.emit();\n             return Err(reported);\n@@ -803,7 +803,7 @@ fn compare_number_of_method_arguments<'tcx>(\n                 ),\n             );\n         } else {\n-            err.note_trait_signature(trait_m.name.to_string(), trait_m.signature(tcx));\n+            err.note_trait_signature(trait_m.name, trait_m.signature(tcx));\n         }\n         err.span_label(\n             impl_span,"}, {"sha": "02e493f7258649d8b5f1a71b4f92b16483966f31", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1856,7 +1856,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             let remaining_private_fields_len = remaining_private_fields.len();\n             let names = match &remaining_private_fields\n                 .iter()\n-                .map(|(name, _, _)| name.to_string())\n+                .map(|(name, _, _)| name)\n                 .collect::<Vec<_>>()[..]\n             {\n                 _ if remaining_private_fields_len > 6 => String::new(),"}, {"sha": "7f96e421a9ae366cbec4ebdbb0ec11c7c029a173", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -19,6 +19,7 @@ use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::ToPolyTraitRef;\n use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeVisitable};\n use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::Symbol;\n use rustc_span::{lev_distance, source_map, ExpnKind, FileName, MacroKind, Span};\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -1548,7 +1549,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Option<ObligationCause<'tcx>>,\n         )],\n     ) {\n-        let mut derives = Vec::<(String, Span, String)>::new();\n+        let mut derives = Vec::<(String, Span, Symbol)>::new();\n         let mut traits = Vec::<Span>::new();\n         for (pred, _, _) in unsatisfied_predicates {\n             let ty::PredicateKind::Trait(trait_pred) = pred.kind().skip_binder() else { continue };\n@@ -1581,12 +1582,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 derives.push((\n                                     self_name.clone(),\n                                     self_span,\n-                                    parent_diagnostic_name.to_string(),\n+                                    parent_diagnostic_name,\n                                 ));\n                             }\n                         }\n                     }\n-                    derives.push((self_name, self_span, diagnostic_name.to_string()));\n+                    derives.push((self_name, self_span, diagnostic_name));\n                 } else {\n                     traits.push(self.tcx.def_span(trait_pred.def_id()));\n                 }\n@@ -1609,7 +1610,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     continue;\n                 }\n             }\n-            derives_grouped.push((self_name, self_span, trait_name));\n+            derives_grouped.push((self_name, self_span, trait_name.to_string()));\n         }\n \n         let len = traits.len();"}, {"sha": "849e96445d3eaae7bbd4f84c247c53792c756553", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -25,7 +25,7 @@ can be broken down into several distinct phases:\n \n - regionck: after main is complete, the regionck pass goes over all\n   types looking for regions and making sure that they did not escape\n-  into places they are not in scope.  This may also influence the\n+  into places where they are not in scope.  This may also influence the\n   final assignments of the various region variables if there is some\n   flexibility.\n "}, {"sha": "8c26c96816d9bbab16dec6c22ad260a88bacb360", "filename": "compiler/rustc_typeck/src/impl_wf_check.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -17,7 +17,7 @@ use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n \n@@ -123,12 +123,7 @@ fn enforce_impl_params_are_constrained(tcx: TyCtxt<'_>, impl_def_id: LocalDefId)\n             ty::GenericParamDefKind::Type { .. } => {\n                 let param_ty = ty::ParamTy::for_def(param);\n                 if !input_parameters.contains(&cgp::Parameter::from(param_ty)) {\n-                    report_unused_parameter(\n-                        tcx,\n-                        tcx.def_span(param.def_id),\n-                        \"type\",\n-                        &param_ty.to_string(),\n-                    );\n+                    report_unused_parameter(tcx, tcx.def_span(param.def_id), \"type\", param_ty.name);\n                 }\n             }\n             ty::GenericParamDefKind::Lifetime => {\n@@ -140,7 +135,7 @@ fn enforce_impl_params_are_constrained(tcx: TyCtxt<'_>, impl_def_id: LocalDefId)\n                         tcx,\n                         tcx.def_span(param.def_id),\n                         \"lifetime\",\n-                        &param.name.to_string(),\n+                        param.name,\n                     );\n                 }\n             }\n@@ -151,7 +146,7 @@ fn enforce_impl_params_are_constrained(tcx: TyCtxt<'_>, impl_def_id: LocalDefId)\n                         tcx,\n                         tcx.def_span(param.def_id),\n                         \"const\",\n-                        &param_ct.to_string(),\n+                        param_ct.name,\n                     );\n                 }\n             }\n@@ -178,7 +173,7 @@ fn enforce_impl_params_are_constrained(tcx: TyCtxt<'_>, impl_def_id: LocalDefId)\n     // used elsewhere are not projected back out.\n }\n \n-fn report_unused_parameter(tcx: TyCtxt<'_>, span: Span, kind: &str, name: &str) {\n+fn report_unused_parameter(tcx: TyCtxt<'_>, span: Span, kind: &str, name: Symbol) {\n     let mut err = struct_span_err!(\n         tcx.sess,\n         span,"}, {"sha": "63d4d94529008dbf8fca0c1fe305cc060d9f1069", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -836,14 +836,14 @@ impl<T: Clone, V: Borrow<[T]>> Join<&[T]> for [V] {\n ////////////////////////////////////////////////////////////////////////////////\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Borrow<[T]> for Vec<T> {\n+impl<T, A: Allocator> Borrow<[T]> for Vec<T, A> {\n     fn borrow(&self) -> &[T] {\n         &self[..]\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> BorrowMut<[T]> for Vec<T> {\n+impl<T, A: Allocator> BorrowMut<[T]> for Vec<T, A> {\n     fn borrow_mut(&mut self) -> &mut [T] {\n         &mut self[..]\n     }"}, {"sha": "d6260b8ca06e48f0082982a905b40b4a43c2a3e2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -2120,8 +2120,9 @@ fn clean_use_statement<'tcx>(\n     // forcefully don't inline if this is not public or if the\n     // #[doc(no_inline)] attribute is present.\n     // Don't inline doc(hidden) imports so they can be stripped at a later stage.\n-    let mut denied = !(visibility.is_public()\n-        || (cx.render_options.document_private && is_visible_from_parent_mod))\n+    let mut denied = cx.output_format.is_json()\n+        || !(visibility.is_public()\n+            || (cx.render_options.document_private && is_visible_from_parent_mod))\n         || pub_underscore\n         || attrs.iter().any(|a| {\n             a.has_name(sym::doc)"}, {"sha": "0e9a9e0e506464bd2fd2bb585374942c840bc8ff", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -81,6 +81,8 @@ pub(crate) struct DocContext<'tcx> {\n     pub(crate) inlined: FxHashSet<ItemId>,\n     /// Used by `calculate_doc_coverage`.\n     pub(crate) output_format: OutputFormat,\n+    /// Used by `strip_private`.\n+    pub(crate) show_coverage: bool,\n }\n \n impl<'tcx> DocContext<'tcx> {\n@@ -381,6 +383,7 @@ pub(crate) fn run_global_ctxt(\n         inlined: FxHashSet::default(),\n         output_format,\n         render_options,\n+        show_coverage,\n     };\n \n     // Small hack to force the Sized trait to be present."}, {"sha": "2598b9b0b28c20e982287ac7ee0eca48d972d056", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -43,7 +43,16 @@ impl JsonRenderer<'_> {\n         let span = item.span(self.tcx);\n         let clean::Item { name, attrs: _, kind: _, visibility, item_id, cfg: _ } = item;\n         let inner = match *item.kind {\n-            clean::StrippedItem(_) | clean::KeywordItem(_) => return None,\n+            clean::KeywordItem(_) => return None,\n+            clean::StrippedItem(ref inner) => {\n+                match &**inner {\n+                    // We document non-empty stripped modules as with `Module::is_stripped` set to\n+                    // `true`, to prevent contained items from being orphaned for downstream users,\n+                    // as JSON does no inlining.\n+                    clean::ModuleItem(m) if !m.items.is_empty() => from_clean_item(item, self.tcx),\n+                    _ => return None,\n+                }\n+            }\n             _ => from_clean_item(item, self.tcx),\n         };\n         Some(Item {\n@@ -220,7 +229,9 @@ fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n     let header = item.fn_header(tcx);\n \n     match *item.kind {\n-        ModuleItem(m) => ItemEnum::Module(Module { is_crate, items: ids(m.items, tcx) }),\n+        ModuleItem(m) => {\n+            ItemEnum::Module(Module { is_crate, items: ids(m.items, tcx), is_stripped: false })\n+        }\n         ImportItem(i) => ItemEnum::Import(i.into_tcx(tcx)),\n         StructItem(s) => ItemEnum::Struct(s.into_tcx(tcx)),\n         UnionItem(u) => ItemEnum::Union(u.into_tcx(tcx)),\n@@ -257,8 +268,19 @@ fn from_clean_item(item: clean::Item, tcx: TyCtxt<'_>) -> ItemEnum {\n             bounds: b.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n             default: Some(t.item_type.unwrap_or(t.type_).into_tcx(tcx)),\n         },\n-        // `convert_item` early returns `None` for striped items and keywords.\n-        StrippedItem(_) | KeywordItem(_) => unreachable!(),\n+        // `convert_item` early returns `None` for stripped items and keywords.\n+        KeywordItem(_) => unreachable!(),\n+        StrippedItem(inner) => {\n+            match *inner {\n+                ModuleItem(m) => ItemEnum::Module(Module {\n+                    is_crate,\n+                    items: ids(m.items, tcx),\n+                    is_stripped: true,\n+                }),\n+                // `convert_item` early returns `None` for stripped items we're not including\n+                _ => unreachable!(),\n+            }\n+        }\n         ExternCrateItem { ref src } => ItemEnum::ExternCrate {\n             name: name.as_ref().unwrap().to_string(),\n             rename: src.map(|x| x.to_string()),"}, {"sha": "6364d00d0624e5a938eaca00b7167253a2bec21c", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -21,6 +21,7 @@ use rustc_span::def_id::LOCAL_CRATE;\n use rustdoc_json_types as types;\n \n use crate::clean::types::{ExternalCrate, ExternalLocation};\n+use crate::clean::ItemKind;\n use crate::config::RenderOptions;\n use crate::docfs::PathError;\n use crate::error::Error;\n@@ -175,6 +176,14 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n     /// the hashmap because certain items (traits and types) need to have their mappings for trait\n     /// implementations filled out before they're inserted.\n     fn item(&mut self, item: clean::Item) -> Result<(), Error> {\n+        trace!(\"rendering {} {:?}\", item.type_(), item.name);\n+\n+        // Flatten items that recursively store other items. We include orphaned items from\n+        // stripped modules and etc that are otherwise reachable.\n+        if let ItemKind::StrippedItem(inner) = &*item.kind {\n+            inner.inner_items().for_each(|i| self.item(i.clone()).unwrap());\n+        }\n+\n         // Flatten items that recursively store other items\n         item.kind.inner_items().for_each(|i| self.item(i.clone()).unwrap());\n "}, {"sha": "9ba841a31cf9545b71a207ffb4cd7958dae6e72c", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -24,6 +24,7 @@ pub(crate) fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) ->\n             retained: &mut retained,\n             access_levels: &cx.cache.access_levels,\n             update_retained: true,\n+            is_json_output: cx.output_format.is_json() && !cx.show_coverage,\n         };\n         krate = ImportStripper.fold_crate(stripper.fold_crate(krate));\n     }"}, {"sha": "5f2f50e712b532f9f822608de8bb928aebd9ab52", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -3,14 +3,29 @@ use rustc_hir::def_id::DefId;\n use rustc_middle::middle::privacy::AccessLevels;\n use std::mem;\n \n-use crate::clean::{self, Item, ItemIdSet};\n+use crate::clean::{self, Item, ItemId, ItemIdSet};\n use crate::fold::{strip_item, DocFolder};\n use crate::formats::cache::Cache;\n \n pub(crate) struct Stripper<'a> {\n     pub(crate) retained: &'a mut ItemIdSet,\n     pub(crate) access_levels: &'a AccessLevels<DefId>,\n     pub(crate) update_retained: bool,\n+    pub(crate) is_json_output: bool,\n+}\n+\n+impl<'a> Stripper<'a> {\n+    // We need to handle this differently for the JSON output because some non exported items could\n+    // be used in public API. And so, we need these items as well. `is_exported` only checks if they\n+    // are in the public API, which is not enough.\n+    #[inline]\n+    fn is_item_reachable(&self, item_id: ItemId) -> bool {\n+        if self.is_json_output {\n+            self.access_levels.is_reachable(item_id.expect_def_id())\n+        } else {\n+            self.access_levels.is_exported(item_id.expect_def_id())\n+        }\n+    }\n }\n \n impl<'a> DocFolder for Stripper<'a> {\n@@ -45,9 +60,8 @@ impl<'a> DocFolder for Stripper<'a> {\n             | clean::TraitAliasItem(..)\n             | clean::MacroItem(..)\n             | clean::ForeignTypeItem => {\n-                if i.item_id.is_local()\n-                    && !self.access_levels.is_exported(i.item_id.expect_def_id())\n-                {\n+                let item_id = i.item_id;\n+                if item_id.is_local() && !self.is_item_reachable(item_id) {\n                     debug!(\"Stripper: stripping {:?} {:?}\", i.type_(), i.name);\n                     return None;\n                 }"}, {"sha": "ca7a20bf3688a934fd2a36a937c253e8f40f0b5f", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -190,6 +190,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     ) -> bool {\n         debug!(\"maybe_inline_local res: {:?}\", res);\n \n+        if self.cx.output_format.is_json() {\n+            return false;\n+        }\n+\n         let tcx = self.cx.tcx;\n         let Some(res_did) = res.opt_def_id() else {\n             return false;"}, {"sha": "761e94c7ebbc44d66df46c8dab17b9c3b1c9cffe", "filename": "src/rustdoc-json-types/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Frustdoc-json-types%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Frustdoc-json-types%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc-json-types%2Flib.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -9,7 +9,7 @@ use std::path::PathBuf;\n use serde::{Deserialize, Serialize};\n \n /// rustdoc format-version.\n-pub const FORMAT_VERSION: u32 = 15;\n+pub const FORMAT_VERSION: u32 = 16;\n \n /// A `Crate` is the root of the emitted JSON blob. It contains all type/documentation information\n /// about the language items in the local crate, as well as info about external items to allow\n@@ -245,6 +245,9 @@ pub enum ItemEnum {\n pub struct Module {\n     pub is_crate: bool,\n     pub items: Vec<Id>,\n+    /// If `true`, this module is not part of the public API, but it contains\n+    /// items that are re-exported as public API.\n+    pub is_stripped: bool,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]"}, {"sha": "a5afb037d0fd5987879350827cf35aa698fe59b2", "filename": "src/test/rustdoc-gui/escape-key.goml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fescape-key.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fescape-key.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fescape-key.goml?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -3,6 +3,8 @@\n goto: file://|DOC_PATH|/test_docs/index.html\n // First, we check that the search results are hidden when the Escape key is pressed.\n write: (\".search-input\", \"test\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n wait-for: \"#search h1\" // The search element is empty before the first search \n // Check that the currently displayed element is search.\n wait-for: \"#alternative-display #search\""}, {"sha": "d645e2370616144c4acc4f5680e1b08be3f3575d", "filename": "src/test/rustdoc-gui/search-filter.goml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fsearch-filter.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fsearch-filter.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-filter.goml?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -2,6 +2,8 @@\n goto: file://|DOC_PATH|/test_docs/index.html\n show-text: true\n write: (\".search-input\", \"test\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n // Waiting for the search results to appear...\n wait-for: \"#titles\"\n assert-text: (\"#results .externcrate\", \"test_docs\")"}, {"sha": "5ef890d472b90804fbc8bf507d235b764670f60d", "filename": "src/test/rustdoc-gui/search-reexport.goml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fsearch-reexport.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fsearch-reexport.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-reexport.goml?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -7,6 +7,8 @@ reload:\n assert-text: (\"//*[@id='reexport.TheStdReexport']\", \"pub use ::std as TheStdReexport;\")\n assert-css: (\"//*[@id='reexport.TheStdReexport']\", {\"background-color\": \"rgba(0, 0, 0, 0)\"})\n write: (\".search-input\", \"TheStdReexport\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n wait-for: \"//a[@class='result-import']\"\n assert-attribute: (\n     \"//a[@class='result-import']\",\n@@ -18,6 +20,8 @@ click: \"//a[@class='result-import']\"\n wait-for-css: (\"//*[@id='reexport.TheStdReexport']\", {\"background-color\": \"rgb(73, 74, 61)\"})\n \n // We now check that the alias is working as well on the reexport.\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n write: (\".search-input\", \"AliasForTheStdReexport\")\n wait-for: \"//a[@class='result-import']\"\n assert-text: ("}, {"sha": "9a49ae2c6b853661f83c5007943dabda13d9ccb4", "filename": "src/test/rustdoc-gui/search-result-color.goml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -89,6 +89,8 @@ show-text: true\n // We reload the page so the local storage settings are being used.\n reload:\n write: (\".search-input\", \"thisisanalias\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n // Waiting for the search results to appear...\n wait-for: \"#titles\"\n // Checking that the colors for the alias element are the ones expected."}, {"sha": "6295d7fae89070aaaef59aed1681bedd86f1c755", "filename": "src/test/rustdoc-gui/search-result-display.goml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fsearch-result-display.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fsearch-result-display.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-result-display.goml?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -2,6 +2,8 @@\n goto: file://|DOC_PATH|/test_docs/index.html\n size: (900, 1000)\n write: (\".search-input\", \"test\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n wait-for: \"#search-settings\"\n // The width is returned by \"getComputedStyle\" which returns the exact number instead of the\n // CSS rule which is \"50%\"..."}, {"sha": "16ae10431acf2dbf86d433f7ff5e29a851be43e2", "filename": "src/test/rustdoc-gui/search-result-keyword.goml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fsearch-result-keyword.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fsearch-result-keyword.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-result-keyword.goml?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,6 +1,8 @@\n // Checks that the \"keyword\" results have the expected text alongside them.\n goto: file://|DOC_PATH|/test_docs/index.html\n write: (\".search-input\", \"CookieMonster\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n // Waiting for the search results to appear...\n wait-for: \"#titles\"\n // Note: The two next assert commands could be merged as one but readability would be"}, {"sha": "9d506c1519e6b5c2f5ac875045003649102b11c9", "filename": "src/test/rustdoc-gui/search-tab-change-title-fn-sig.goml", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fsearch-tab-change-title-fn-sig.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fsearch-tab-change-title-fn-sig.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-tab-change-title-fn-sig.goml?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -2,6 +2,8 @@\n // First, try a search-by-name\n goto: file://|DOC_PATH|/test_docs/index.html\n write: (\".search-input\", \"Foo\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n // Waiting for the search results to appear...\n wait-for: \"#titles\"\n assert-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n@@ -22,6 +24,8 @@ wait-for-attribute: (\"#titles > button:nth-of-type(3)\", {\"class\": \"selected\"})\n // Now try search-by-return\n goto: file://|DOC_PATH|/test_docs/index.html\n write: (\".search-input\", \"-> String\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n // Waiting for the search results to appear...\n wait-for: \"#titles\"\n assert-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n@@ -42,6 +46,8 @@ wait-for-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n // Try with a search-by-return with no results\n goto: file://|DOC_PATH|/test_docs/index.html\n write: (\".search-input\", \"-> Something\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n // Waiting for the search results to appear...\n wait-for: \"#titles\"\n assert-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n@@ -50,6 +56,8 @@ assert-text: (\"#titles > button:nth-of-type(1)\", \"In Function Return Types\", STA\n // Try with a search-by-parameter\n goto: file://|DOC_PATH|/test_docs/index.html\n write: (\".search-input\", \"usize pattern\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n // Waiting for the search results to appear...\n wait-for: \"#titles\"\n assert-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})\n@@ -58,6 +66,8 @@ assert-text: (\"#titles > button:nth-of-type(1)\", \"In Function Parameters\", START\n // Try with a search-by-parameter-and-return\n goto: file://|DOC_PATH|/test_docs/index.html\n write: (\".search-input\", \"pattern -> str\")\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n // Waiting for the search results to appear...\n wait-for: \"#titles\"\n assert-attribute: (\"#titles > button:nth-of-type(1)\", {\"class\": \"selected\"})"}, {"sha": "8a3365d3cc25e2c90becdb28d450c275e343ebd1", "filename": "src/test/rustdoc-gui/settings.goml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fsettings.goml", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-gui%2Fsettings.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsettings.goml?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -20,6 +20,8 @@ wait-for-css: (\"#settings\", {\"display\": \"none\"})\n // Let's click on it when the search results are displayed.\n focus: \".search-input\"\n write: \"test\"\n+// To be SURE that the search will be run.\n+press-key: 'Enter'\n wait-for: \"#alternative-display #search\"\n click: \"#settings-menu\"\n wait-for-css: (\"#settings\", {\"display\": \"block\"})"}, {"sha": "5c4ccf996a54f6e7fc726031254aea8ec8391aad", "filename": "src/test/rustdoc-json/doc_hidden_failure.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Fdoc_hidden_failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Fdoc_hidden_failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fdoc_hidden_failure.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,22 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/98007>.\n+\n+#![feature(no_core)]\n+#![no_core]\n+\n+mod auto {\n+    mod action_row {\n+        pub struct ActionRowBuilder;\n+    }\n+\n+    #[doc(hidden)]\n+    pub mod builders {\n+        pub use super::action_row::ActionRowBuilder;\n+    }\n+}\n+\n+// @count doc_hidden_failure.json \"$.index[*][?(@.name=='builders')]\" 2\n+pub use auto::*;\n+\n+pub mod builders {\n+    pub use crate::auto::builders::*;\n+}"}, {"sha": "4a835673a596bcd05404f43d34082bf2785f2a9d", "filename": "src/test/rustdoc-json/reexport/auxiliary/pub-struct.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fauxiliary%2Fpub-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fauxiliary%2Fpub-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fauxiliary%2Fpub-struct.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1 @@\n+pub struct Foo;"}, {"sha": "ba1cfd8a0b5775ba6dab6a52e887ea6d47ab8a1d", "filename": "src/test/rustdoc-json/reexport/glob_extern.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fglob_extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fglob_extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fglob_extern.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -3,15 +3,16 @@\n #![no_core]\n #![feature(no_core)]\n \n-// @!has glob_extern.json \"$.index[*][?(@.name=='mod1')]\"\n+// @is glob_extern.json \"$.index[*][?(@.name=='mod1')].kind\" \\\"module\\\"\n+// @is glob_extern.json \"$.index[*][?(@.name=='mod1')].inner.is_stripped\" \"true\"\n mod mod1 {\n     extern \"C\" {\n-        // @set public_fn_id = - \"$.index[*][?(@.name=='public_fn')].id\"\n+        // @has - \"$.index[*][?(@.name=='public_fn')].id\"\n         pub fn public_fn();\n         // @!has - \"$.index[*][?(@.name=='private_fn')]\"\n         fn private_fn();\n     }\n }\n \n-// @has - \"$.index[*][?(@.name=='glob_extern')].inner.items[*]\" $public_fn_id\n+// @is - \"$.index[*][?(@.kind=='import')].inner.glob\" true\n pub use mod1::*;"}, {"sha": "e6a44748c25fbd3b162f5e89096fb036f1cf3031", "filename": "src/test/rustdoc-json/reexport/glob_private.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fglob_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fglob_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fglob_private.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -3,25 +3,30 @@\n #![no_core]\n #![feature(no_core)]\n \n-// @!has glob_private.json \"$.index[*][?(@.name=='mod1')]\"\n+// @is glob_private.json \"$.index[*][?(@.name=='mod1')].kind\" \\\"module\\\"\n+// @is glob_private.json \"$.index[*][?(@.name=='mod1')].inner.is_stripped\" \"true\"\n mod mod1 {\n-    // @!has - \"$.index[*][?(@.name=='mod2')]\"\n+    // @is - \"$.index[*][?(@.name=='mod2')].kind\" \\\"module\\\"\n+    // @is - \"$.index[*][?(@.name=='mod2')].inner.is_stripped\" \"true\"\n     mod mod2 {\n         // @set m2pub_id = - \"$.index[*][?(@.name=='Mod2Public')].id\"\n         pub struct Mod2Public;\n \n         // @!has - \"$.index[*][?(@.name=='Mod2Private')]\"\n         struct Mod2Private;\n     }\n+\n+    // @has - \"$.index[*][?(@.kind=='import' && @.inner.name=='mod2')]\"\n     pub use self::mod2::*;\n \n     // @set m1pub_id = - \"$.index[*][?(@.name=='Mod1Public')].id\"\n     pub struct Mod1Public;\n-\n     // @!has - \"$.index[*][?(@.name=='Mod1Private')]\"\n     struct Mod1Private;\n }\n+\n+// @has - \"$.index[*][?(@.kind=='import' && @.inner.name=='mod1')]\"\n pub use mod1::*;\n \n-// @has - \"$.index[*][?(@.name=='glob_private')].inner.items[*]\" $m2pub_id\n-// @has - \"$.index[*][?(@.name=='glob_private')].inner.items[*]\" $m1pub_id\n+// @has - \"$.index[*][?(@.name=='mod2')].inner.items[*]\" $m2pub_id\n+// @has - \"$.index[*][?(@.name=='mod1')].inner.items[*]\" $m1pub_id"}, {"sha": "7bf10a986861658005557d7ed770e7f071d61d07", "filename": "src/test/rustdoc-json/reexport/in_root_and_mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fin_root_and_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fin_root_and_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fin_root_and_mod.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,15 +1,17 @@\n #![feature(no_core)]\n #![no_core]\n \n+// @is in_root_and_mod.json \"$.index[*][?(@.name=='foo')].kind\" \\\"module\\\"\n+// @is in_root_and_mod.json \"$.index[*][?(@.name=='foo')].inner.is_stripped\" \"true\"\n mod foo {\n-    // @set foo_id = in_root_and_mod.json \"$.index[*][?(@.name=='Foo')].id\"\n+    // @has - \"$.index[*][?(@.name=='Foo')]\"\n     pub struct Foo;\n }\n \n-// @has - \"$.index[*][?(@.name=='in_root_and_mod')].inner.items[*]\" $foo_id\n+// @has - \"$.index[*][?(@.kind=='import' && @.inner.source=='foo::Foo')]\"\n pub use foo::Foo;\n \n pub mod bar {\n-    // @has - \"$.index[*][?(@.name=='bar')].inner.items[*]\" $foo_id\n+    // @has - \"$.index[*][?(@.kind=='import' && @.inner.source=='crate::foo::Foo')]\"\n     pub use crate::foo::Foo;\n }"}, {"sha": "327b0f45fdd54d6af4f01cb9628381c88d0ff9ac", "filename": "src/test/rustdoc-json/reexport/private_twice_one_inline.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fprivate_twice_one_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fprivate_twice_one_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fprivate_twice_one_inline.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,18 @@\n+// aux-build:pub-struct.rs\n+\n+// Test for the ICE in rust/83057\n+// Am external type re-exported with different attributes shouldn't cause an error\n+\n+#![no_core]\n+#![feature(no_core)]\n+\n+extern crate pub_struct as foo;\n+\n+#[doc(inline)]\n+pub use foo::Foo;\n+\n+pub mod bar {\n+    pub use foo::Foo;\n+}\n+\n+// @count private_twice_one_inline.json \"$.index[*][?(@.kind=='import')]\" 2"}, {"sha": "36d6a50d385a21ecee5cceb7f6f4025cf4b05fee", "filename": "src/test/rustdoc-json/reexport/private_two_names.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fprivate_two_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fprivate_two_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fprivate_two_names.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,17 @@\n+// Test for the ICE in rust/83720\n+// A pub-in-private type re-exported under two different names shouldn't cause an error\n+\n+#![no_core]\n+#![feature(no_core)]\n+\n+// @is private_two_names.json \"$.index[*][?(@.name=='style')].kind\" \\\"module\\\"\n+// @is private_two_names.json \"$.index[*][?(@.name=='style')].inner.is_stripped\" \"true\"\n+mod style {\n+    // @has - \"$.index[*](?(@.name=='Color'))\"\n+    pub struct Color;\n+}\n+\n+// @has - \"$.index[*][?(@.kind=='import' && @.inner.name=='Color')]\"\n+pub use style::Color;\n+// @has - \"$.index[*][?(@.kind=='import' && @.inner.name=='Colour')]\"\n+pub use style::Color as Colour;"}, {"sha": "2476399bd561cdfcf3bfed9656ac7848302bbc6b", "filename": "src/test/rustdoc-json/reexport/rename_private.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Frename_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Frename_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Frename_private.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -2,13 +2,13 @@\n \n #![no_core]\n #![feature(no_core)]\n-// @!has rename_private.json \"$.index[*][?(@.name=='inner')]\"\n+\n+// @is rename_private.json \"$.index[*][?(@.name=='inner')].kind\" \\\"module\\\"\n+// @is rename_private.json \"$.index[*][?(@.name=='inner')].inner.is_stripped\" \"true\"\n mod inner {\n-    // @!has - \"$.index[*][?(@.name=='Public')]\"\n+    // @has - \"$.index[*][?(@.name=='Public')]\"\n     pub struct Public;\n }\n \n-// @set newname_id = - \"$.index[*][?(@.name=='NewName')].id\"\n-// @is - \"$.index[*][?(@.name=='NewName')].kind\" \\\"struct\\\"\n-// @has - \"$.index[*][?(@.name=='rename_private')].inner.items[*]\" $newname_id\n+// @is - \"$.index[*][?(@.kind=='import')].inner.name\" \\\"NewName\\\"\n pub use inner::Public as NewName;"}, {"sha": "eedddd6a7bb48182f86b5aea8d58c0f7035a480c", "filename": "src/test/rustdoc-json/reexport/same_type_reexported_more_than_once.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fsame_type_reexported_more_than_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fsame_type_reexported_more_than_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fsame_type_reexported_more_than_once.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,15 +1,13 @@\n-// Regression test for https://github.com/rust-lang/rust/issues/97432.\n+// Regression test for <https://github.com/rust-lang/rust/issues/97432>.\n \n #![feature(no_core)]\n #![no_std]\n #![no_core]\n \n // @has same_type_reexported_more_than_once.json\n-// @set trait_id = - \"$.index[*][?(@.name=='Trait')].id\"\n-// @has - \"$.index[*][?(@.name=='same_type_reexported_more_than_once')].inner.items[*]\" $trait_id\n+// @has - \"$.index[*][?(@.name=='Trait')]\"\n pub use inner::Trait;\n-// @set reexport_id = - \"$.index[*][?(@.name=='Reexport')].id\"\n-// @has - \"$.index[*][?(@.name=='same_type_reexported_more_than_once')].inner.items[*]\" $reexport_id\n+// @has - \"$.index[*].inner[?(@.name=='Reexport')].id\"\n pub use inner::Trait as Reexport;\n \n mod inner {"}, {"sha": "5ec13e403aef694a01cb05be115926afab93b8d9", "filename": "src/test/rustdoc-json/reexport/simple_private.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fsimple_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freexport%2Fsimple_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Fsimple_private.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,13 +1,15 @@\n // edition:2018\n-\n #![no_core]\n #![feature(no_core)]\n \n-// @!has simple_private.json \"$.index[*][?(@.name=='inner')]\"\n+// @is simple_private.json \"$.index[*][?(@.name=='inner')].kind\" \\\"module\\\"\n+// @is simple_private.json \"$.index[*][?(@.name=='inner')].inner.is_stripped\" \"true\"\n mod inner {\n     // @set pub_id = - \"$.index[*][?(@.name=='Public')].id\"\n     pub struct Public;\n }\n \n-// @has - \"$.index[*][?(@.name=='simple_private')].inner.items[*]\" $pub_id\n+// @is - \"$.index[*][?(@.kind=='import')].inner.name\" \\\"Public\\\"\n pub use inner::Public;\n+\n+// @has - \"$.index[*][?(@.name=='inner')].inner.items[*]\" $pub_id"}, {"sha": "6b324d0090a154ef3954e50a60abbb960e3bad86", "filename": "src/test/rustdoc-json/return_private.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freturn_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Freturn_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freturn_private.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,15 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/96161>.\n+// ignore-tidy-linelength\n+\n+#![feature(no_core)]\n+#![no_core]\n+\n+mod secret {\n+    pub struct Secret;\n+}\n+\n+// @is return_private.json \"$.index[*][?(@.name=='get_secret')].kind\" \\\"function\\\"\n+// @is return_private.json \"$.index[*][?(@.name=='get_secret')].inner.decl.output.inner.name\" \\\"secret::Secret\\\"\n+pub fn get_secret() -> secret::Secret {\n+    secret::Secret\n+}"}, {"sha": "91f9f02ad7b47342aae502b827ba7ca0b5bf2686", "filename": "src/test/rustdoc-json/stripped_modules.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Fstripped_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-json%2Fstripped_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Fstripped_modules.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,21 @@\n+#![no_core]\n+#![feature(no_core)]\n+\n+// @!has stripped_modules.json \"$.index[*][?(@.name=='no_pub_inner')]\"\n+mod no_pub_inner {\n+    fn priv_inner() {}\n+}\n+\n+// @!has - \"$.index[*][?(@.name=='pub_inner_unreachable')]\"\n+mod pub_inner_unreachable {\n+    // @!has - \"$.index[*][?(@.name=='pub_inner_1')]\"\n+    pub fn pub_inner_1() {}\n+}\n+\n+// @has - \"$.index[*][?(@.name=='pub_inner_reachable')]\"\n+mod pub_inner_reachable {\n+    // @has - \"$.index[*][?(@.name=='pub_inner_2')]\"\n+    pub fn pub_inner_2() {}\n+}\n+\n+pub use pub_inner_reachable::pub_inner_2;"}, {"sha": "a4fa3817905c7dbc428514fd99fa9321b10f10b9", "filename": "src/test/rustdoc-ui/invalid-doc-attr.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-ui%2Finvalid-doc-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Frustdoc-ui%2Finvalid-doc-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Finvalid-doc-attr.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -12,7 +12,7 @@ LL | #![deny(warnings)]\n    = note: `#[deny(invalid_doc_attributes)]` implied by `#[deny(warnings)]`\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n help: to apply to the crate, use an inner attribute\n    |\n LL | #![doc(test(no_crate_inject))]\n@@ -29,7 +29,7 @@ LL | pub fn foo() {}\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n \n error: this attribute can only be applied at the crate level\n   --> $DIR/invalid-doc-attr.rs:15:12\n@@ -39,7 +39,7 @@ LL |     #![doc(test(no_crate_inject))]\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n error: conflicting doc inlining attributes\n   --> $DIR/invalid-doc-attr.rs:28:7\n@@ -59,7 +59,7 @@ LL |     #[doc(test(no_crate_inject))]\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n error: this attribute can only be applied to a `use` item\n   --> $DIR/invalid-doc-attr.rs:22:11\n@@ -72,7 +72,7 @@ LL |     pub fn baz() {}\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n \n error: aborting due to 6 previous errors\n "}, {"sha": "0a210cbdc94307677afd1428e626190bb68503eb", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -23,7 +23,7 @@ extern crate rustc_middle;\n use rustc_middle::ty::Ty;\n \n extern crate rustc_errors;\n-use rustc_errors::Applicability;\n+use rustc_errors::{Applicability, MultiSpan};\n \n extern crate rustc_session;\n \n@@ -140,7 +140,7 @@ struct CodeNotProvided {}\n #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct MessageWrongType {\n     #[primary_span]\n-    //~^ ERROR `#[primary_span]` attribute can only be applied to fields of type `Span`\n+    //~^ ERROR `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     foo: String,\n }\n \n@@ -165,7 +165,7 @@ struct ErrorWithField {\n #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct ErrorWithMessageAppliedToField {\n     #[label(typeck::label)]\n-    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     name: String,\n }\n \n@@ -208,7 +208,7 @@ struct LabelOnSpan {\n #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n struct LabelOnNonSpan {\n     #[label(typeck::label)]\n-    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+    //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     id: u32,\n }\n \n@@ -538,7 +538,7 @@ struct LabelWithTrailingList {\n \n #[derive(SessionDiagnostic)]\n #[lint(typeck::ambiguous_lifetime_bound)]\n-//~^ ERROR only `#[error(..)]` and `#[warn(..)]` are supported\n+//~^ ERROR only `#[error(..)]` and `#[warning(..)]` are supported\n struct LintsBad {\n }\n \n@@ -552,3 +552,17 @@ struct LintsGood {\n //~^ ERROR only `#[lint(..)]` is supported\n struct ErrorsBad {\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+struct ErrorWithMultiSpan {\n+    #[primary_span]\n+    span: MultiSpan,\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[warn_]\n+struct ErrorWithWarn {\n+    val: String,\n+}"}, {"sha": "c1080aa24521f7735bac376335686928b7c5dc76", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -21,7 +21,7 @@ error: `#[nonsense(...)]` is not a valid attribute\n LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: only `error`, `warning`, `help` and `note` are valid attributes\n+   = help: only `error`, `warning`, `help`, `note` and `warn_` are valid attributes\n \n error: diagnostic kind not specified\n   --> $DIR/diagnostic-derive.rs:53:1\n@@ -233,7 +233,7 @@ LL | | struct SlugNotProvided {}\n    |\n    = help: specify the slug as the first argument to the attribute, such as `#[error(typeck::example_error)]`\n \n-error: the `#[primary_span]` attribute can only be applied to fields of type `Span`\n+error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:142:5\n    |\n LL |     #[primary_span]\n@@ -247,7 +247,7 @@ LL |     #[nonsense]\n    |\n    = help: only `skip_arg`, `primary_span`, `label`, `note`, `help` and `subdiagnostic` are valid field attributes\n \n-error: the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:167:5\n    |\n LL |     #[label(typeck::label)]\n@@ -279,7 +279,7 @@ LL | #[derive(SessionDiagnostic)]\n    = note: if you intended to print `}`, you can escape it using `}}`\n    = note: this error originates in the derive macro `SessionDiagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: the `#[label(...)]` attribute can only be applied to fields of type `Span`\n+error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:210:5\n    |\n LL |     #[label(typeck::label)]\n@@ -363,7 +363,7 @@ error: `#[label(...)]` is not a valid attribute\n LL |     #[label(typeck::label, foo(\"...\"))]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: only `#[error(..)]` and `#[warn(..)]` are supported\n+error: only `#[error(..)]` and `#[warning(..)]` are supported\n   --> $DIR/diagnostic-derive.rs:540:1\n    |\n LL | / #[lint(typeck::ambiguous_lifetime_bound)]"}, {"sha": "16da25c402b570eac91383ed760b915a6d9ffc2b", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -244,7 +244,7 @@ enum V {\n //~^ ERROR label without `#[primary_span]` field\n struct W {\n     #[primary_span]\n-    //~^ ERROR the `#[primary_span]` attribute can only be applied to fields of type `Span`\n+    //~^ ERROR the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     span: String,\n }\n \n@@ -508,3 +508,15 @@ enum AX {\n         span: Span,\n     }\n }\n+\n+#[derive(SessionSubdiagnostic)]\n+#[warn_(parser::add_paren)]\n+struct AY {\n+}\n+\n+#[derive(SessionSubdiagnostic)]\n+#[warn_(parser::add_paren)]\n+struct AZ {\n+    #[primary_span]\n+    span: Span,\n+}"}, {"sha": "a289c4fffd9365e6882e9bd0a60fff2d420c6988", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -120,7 +120,7 @@ error: subdiagnostic kind not specified\n LL |     B {\n    |     ^\n \n-error: the `#[primary_span]` attribute can only be applied to fields of type `Span`\n+error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/subdiagnostic-derive.rs:246:5\n    |\n LL |     #[primary_span]"}, {"sha": "a4fa3817905c7dbc428514fd99fa9321b10f10b9", "filename": "src/test/ui/attributes/invalid-doc-attr.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fattributes%2Finvalid-doc-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fattributes%2Finvalid-doc-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Finvalid-doc-attr.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -12,7 +12,7 @@ LL | #![deny(warnings)]\n    = note: `#[deny(invalid_doc_attributes)]` implied by `#[deny(warnings)]`\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n help: to apply to the crate, use an inner attribute\n    |\n LL | #![doc(test(no_crate_inject))]\n@@ -29,7 +29,7 @@ LL | pub fn foo() {}\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n \n error: this attribute can only be applied at the crate level\n   --> $DIR/invalid-doc-attr.rs:15:12\n@@ -39,7 +39,7 @@ LL |     #![doc(test(no_crate_inject))]\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n error: conflicting doc inlining attributes\n   --> $DIR/invalid-doc-attr.rs:28:7\n@@ -59,7 +59,7 @@ LL |     #[doc(test(no_crate_inject))]\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n error: this attribute can only be applied to a `use` item\n   --> $DIR/invalid-doc-attr.rs:22:11\n@@ -72,7 +72,7 @@ LL |     pub fn baz() {}\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#inline-and-no_inline> for more information\n \n error: aborting due to 6 previous errors\n "}, {"sha": "a8dba0ba37d3ad817ee27f151ddae7ad3e6b9ac0", "filename": "src/test/ui/attributes/multiple-invalid.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fattributes%2Fmultiple-invalid.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -7,14 +7,14 @@ LL | #[inline]\n LL | const FOO: u8 = 0;\n    | ------------------ not a function or closure\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/multiple-invalid.rs:6:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | const FOO: u8 = 0;\n-   | ------------------ not a function\n+   | ------------------ not a function definition\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8bf6a2f6db3966c2410c637bed09dc3da4319396", "filename": "src/test/ui/borrowck/borrowck-borrowed-uniq-rvalue.fixed", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.fixed?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+\n+use std::collections::HashMap;\n+\n+fn main() {\n+    let tmp: Box<_>;\n+    let mut buggy_map: HashMap<usize, &usize> = HashMap::new();\n+    let binding = Box::new(1);\n+    buggy_map.insert(42, &*binding); //~ ERROR temporary value dropped while borrowed\n+\n+    // but it is ok if we use a temporary\n+    tmp = Box::new(2);\n+    buggy_map.insert(43, &*tmp);\n+}"}, {"sha": "85481336a305f5dbadadc7ce9f72fd0ff86dd774", "filename": "src/test/ui/borrowck/borrowck-borrowed-uniq-rvalue.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,8 +1,6 @@\n-use std::collections::HashMap;\n-\n-\n-\n+// run-rustfix\n \n+use std::collections::HashMap;\n \n fn main() {\n     let tmp: Box<_>;"}, {"sha": "dea8ac90bec2ebe5033acfa2657020c6b574aadd", "filename": "src/test/ui/borrowck/borrowck-borrowed-uniq-rvalue.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-borrowed-uniq-rvalue.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,5 +1,5 @@\n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/borrowck-borrowed-uniq-rvalue.rs:10:28\n+  --> $DIR/borrowck-borrowed-uniq-rvalue.rs:8:28\n    |\n LL |     buggy_map.insert(42, &*Box::new(1));\n    |                            ^^^^^^^^^^^ - temporary value is freed at the end of this statement\n@@ -9,7 +9,11 @@ LL |     buggy_map.insert(42, &*Box::new(1));\n LL |     buggy_map.insert(43, &*tmp);\n    |     --------------------------- borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~     let binding = Box::new(1);\n+LL ~     buggy_map.insert(42, &*binding);\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "139bd9a073973fdcc30117ea11c2be0f202fbb43", "filename": "src/test/ui/borrowck/issue-11493.fixed", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fissue-11493.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fissue-11493.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-11493.fixed?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,9 @@\n+// run-rustfix\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    let x = Some(3);\n+    let binding = id(5);\n+    let y = x.as_ref().unwrap_or(&binding);  //~ ERROR\n+    let _ = &y;\n+}"}, {"sha": "cb77f89fb2b1ec5efe544d5f45db1fc7c12b6da8", "filename": "src/test/ui/borrowck/issue-11493.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fissue-11493.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fissue-11493.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-11493.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,7 +1,8 @@\n+// run-rustfix\n fn id<T>(x: T) -> T { x }\n \n fn main() {\n     let x = Some(3);\n     let y = x.as_ref().unwrap_or(&id(5));  //~ ERROR\n-    &y;\n+    let _ = &y;\n }", "previous_filename": "src/test/ui/issues/issue-11493.rs"}, {"sha": "a5d1f2816f1ca707dbf04b1130d8cf07b82e5c7b", "filename": "src/test/ui/borrowck/issue-11493.stderr", "status": "renamed", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fissue-11493.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fissue-11493.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-11493.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,14 +1,18 @@\n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/issue-11493.rs:5:35\n+  --> $DIR/issue-11493.rs:6:35\n    |\n LL |     let y = x.as_ref().unwrap_or(&id(5));\n    |                                   ^^^^^ - temporary value is freed at the end of this statement\n    |                                   |\n    |                                   creates a temporary which is freed while still in use\n-LL |     &y;\n-   |     -- borrow later used here\n+LL |     let _ = &y;\n+   |             -- borrow later used here\n+   |\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~     let binding = id(5);\n+LL ~     let y = x.as_ref().unwrap_or(&binding);\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/issues/issue-11493.stderr"}, {"sha": "8640ca7a509648142c49cde2430c5bc010398588", "filename": "src/test/ui/borrowck/issue-36082.fixed", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fissue-36082.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fissue-36082.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-36082.fixed?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,17 @@\n+// run-rustfix\n+use std::cell::RefCell;\n+\n+fn main() {\n+    let mut r = 0;\n+    let s = 0;\n+    let x = RefCell::new((&mut r,s));\n+\n+    let binding = x.borrow();\n+    let val: &_ = binding.0;\n+    //~^ ERROR temporary value dropped while borrowed [E0716]\n+    //~| NOTE temporary value is freed at the end of this statement\n+    //~| NOTE creates a temporary which is freed while still in use\n+    //~| HELP consider using a `let` binding to create a longer lived value\n+    println!(\"{}\", val);\n+    //~^ borrow later used here\n+}"}, {"sha": "877d372fb8484985fb880bc6b5bbe165122ad974", "filename": "src/test/ui/borrowck/issue-36082.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fissue-36082.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fissue-36082.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-36082.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n use std::cell::RefCell;\n \n fn main() {\n@@ -9,7 +10,7 @@ fn main() {\n     //~^ ERROR temporary value dropped while borrowed [E0716]\n     //~| NOTE temporary value is freed at the end of this statement\n     //~| NOTE creates a temporary which is freed while still in use\n-    //~| NOTE consider using a `let` binding to create a longer lived value\n+    //~| HELP consider using a `let` binding to create a longer lived value\n     println!(\"{}\", val);\n     //~^ borrow later used here\n }", "previous_filename": "src/test/ui/issues/issue-36082.rs"}, {"sha": "4bd586db1cdcea283e86407ae370811641a27f99", "filename": "src/test/ui/borrowck/issue-36082.stderr", "status": "renamed", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fissue-36082.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fborrowck%2Fissue-36082.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-36082.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,5 +1,5 @@\n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/issue-36082.rs:8:19\n+  --> $DIR/issue-36082.rs:9:19\n    |\n LL |     let val: &_ = x.borrow().0;\n    |                   ^^^^^^^^^^  - temporary value is freed at the end of this statement\n@@ -9,7 +9,11 @@ LL |     let val: &_ = x.borrow().0;\n LL |     println!(\"{}\", val);\n    |                    --- borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~     let binding = x.borrow();\n+LL ~     let val: &_ = binding.0;\n+   |\n \n error: aborting due to previous error\n ", "previous_filename": "src/test/ui/issues/issue-36082.stderr"}, {"sha": "40f14c389842e6e93331b2d162c5490dfe6e2a47", "filename": "src/test/ui/cleanup-rvalue-scopes-cf.stderr", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fcleanup-rvalue-scopes-cf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fcleanup-rvalue-scopes-cf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcleanup-rvalue-scopes-cf.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -9,7 +9,11 @@ LL |     let x1 = arg(&AddFlags(1));\n LL |     (x1, x2, x3, x4, x5, x6, x7);\n    |      -- borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~     let binding = AddFlags(1);\n+LL ~     let x1 = arg(&binding);\n+   |\n \n error[E0716]: temporary value dropped while borrowed\n   --> $DIR/cleanup-rvalue-scopes-cf.rs:27:14\n@@ -22,7 +26,11 @@ LL |     let x2 = AddFlags(1).get();\n LL |     (x1, x2, x3, x4, x5, x6, x7);\n    |          -- borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~     let binding = AddFlags(1);\n+LL ~     let x2 = binding.get();\n+   |\n \n error[E0716]: temporary value dropped while borrowed\n   --> $DIR/cleanup-rvalue-scopes-cf.rs:28:21\n@@ -35,7 +43,11 @@ LL |     let x3 = &*arg(&AddFlags(1));\n LL |     (x1, x2, x3, x4, x5, x6, x7);\n    |              -- borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~     let binding = AddFlags(1);\n+LL ~     let x3 = &*arg(&binding);\n+   |\n \n error[E0716]: temporary value dropped while borrowed\n   --> $DIR/cleanup-rvalue-scopes-cf.rs:29:24\n@@ -48,7 +60,11 @@ LL |     let ref x4 = *arg(&AddFlags(1));\n LL |     (x1, x2, x3, x4, x5, x6, x7);\n    |                  -- borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~     let binding = AddFlags(1);\n+LL ~     let ref x4 = *arg(&binding);\n+   |\n \n error[E0716]: temporary value dropped while borrowed\n   --> $DIR/cleanup-rvalue-scopes-cf.rs:30:24\n@@ -61,7 +77,11 @@ LL |     let &ref x5 = arg(&AddFlags(1));\n LL |     (x1, x2, x3, x4, x5, x6, x7);\n    |                      -- borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~     let binding = AddFlags(1);\n+LL ~     let &ref x5 = arg(&binding);\n+   |\n \n error[E0716]: temporary value dropped while borrowed\n   --> $DIR/cleanup-rvalue-scopes-cf.rs:31:14\n@@ -74,7 +94,11 @@ LL |     let x6 = AddFlags(1).get();\n LL |     (x1, x2, x3, x4, x5, x6, x7);\n    |                          -- borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~     let binding = AddFlags(1);\n+LL ~     let x6 = binding.get();\n+   |\n \n error[E0716]: temporary value dropped while borrowed\n   --> $DIR/cleanup-rvalue-scopes-cf.rs:32:44\n@@ -87,7 +111,11 @@ LL |\n LL |     (x1, x2, x3, x4, x5, x6, x7);\n    |                              -- borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~     let binding = AddFlags(1);\n+LL ~     let StackBox { f: x7 } = StackBox { f: binding.get() };\n+   |\n \n error: aborting due to 7 previous errors\n "}, {"sha": "5d6796b49448a5dc50b3cea07535c524aef5d98c", "filename": "src/test/ui/feature-gates/issue-43106-gating-of-builtin-attrs.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Fissue-43106-gating-of-builtin-attrs.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -259,7 +259,7 @@ warning: crate-level attribute should be an inner attribute: add an exclamation\n LL | #[no_std]\n    | ^^^^^^^^^\n \n-warning: attribute should be applied to a function\n+warning: attribute should be applied to a function definition\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:453:1\n    |\n LL |   #[cold]\n@@ -272,7 +272,7 @@ LL | |     mod inner { #![cold] }\n ...  |\n LL | |\n LL | | }\n-   | |_- not a function\n+   | |_- not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n@@ -399,7 +399,7 @@ warning: `#[proc_macro_derive]` only has an effect on functions\n LL | #![proc_macro_derive()]\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: attribute should be applied to a function\n+warning: attribute should be applied to a function definition\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:62:1\n    |\n LL | #![cold]\n@@ -743,35 +743,35 @@ warning: crate-level attribute should be an inner attribute: add an exclamation\n LL |     #[no_std] impl S { }\n    |     ^^^^^^^^^\n \n-warning: attribute should be applied to a function\n+warning: attribute should be applied to a function definition\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:459:17\n    |\n LL |     mod inner { #![cold] }\n-   |     ------------^^^^^^^^-- not a function\n+   |     ------------^^^^^^^^-- not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n-warning: attribute should be applied to a function\n+warning: attribute should be applied to a function definition\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:466:5\n    |\n LL |     #[cold] struct S;\n-   |     ^^^^^^^ --------- not a function\n+   |     ^^^^^^^ --------- not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n-warning: attribute should be applied to a function\n+warning: attribute should be applied to a function definition\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:471:5\n    |\n LL |     #[cold] type T = S;\n-   |     ^^^^^^^ ----------- not a function\n+   |     ^^^^^^^ ----------- not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n-warning: attribute should be applied to a function\n+warning: attribute should be applied to a function definition\n   --> $DIR/issue-43106-gating-of-builtin-attrs.rs:476:5\n    |\n LL |     #[cold] impl S { }\n-   |     ^^^^^^^ ---------- not a function\n+   |     ^^^^^^^ ---------- not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n "}, {"sha": "8f6dde665e6284242a8fe8da2a669977fee72856", "filename": "src/test/ui/future-incompatible-lint-group.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ffuture-incompatible-lint-group.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ffuture-incompatible-lint-group.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffuture-incompatible-lint-group.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -22,7 +22,7 @@ LL | #![deny(future_incompatible)]\n    = note: `#[deny(invalid_doc_attributes)]` implied by `#[deny(future_incompatible)]`\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #82730 <https://github.com/rust-lang/rust/issues/82730>\n-   = note: read https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level for more information\n+   = note: read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n error: aborting due to previous error; 1 warning emitted\n "}, {"sha": "4e010a13653e7796c0723c35125c33bdb5ce60b1", "filename": "src/test/ui/issues/issue-21974.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fissues%2Fissue-21974.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fissues%2Fissue-21974.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21974.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -4,13 +4,7 @@ error[E0283]: type annotations needed: cannot satisfy `&'a T: Foo`\n LL |     where &'a T : Foo,\n    |                   ^^^\n    |\n-note: multiple `impl`s or `where` clauses satisfying `&'a T: Foo` found\n-  --> $DIR/issue-21974.rs:11:19\n-   |\n-LL |     where &'a T : Foo,\n-   |                   ^^^\n-LL |           &'b T : Foo\n-   |                   ^^^\n+   = note: cannot satisfy `&'a T: Foo`\n \n error: aborting due to previous error\n "}, {"sha": "8f3b2ac73199ccec1afced236ae6f1c0f0452522", "filename": "src/test/ui/issues/issue-24424.stderr", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fissues%2Fissue-24424.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fissues%2Fissue-24424.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24424.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -4,11 +4,7 @@ error[E0283]: type annotations needed: cannot satisfy `T0: Trait0<'l0>`\n LL | impl <'l0, 'l1, T0> Trait1<'l0, T0> for bool where T0 : Trait0<'l0>, T0 : Trait0<'l1> {}\n    |                                                         ^^^^^^^^^^^\n    |\n-note: multiple `impl`s or `where` clauses satisfying `T0: Trait0<'l0>` found\n-  --> $DIR/issue-24424.rs:4:57\n-   |\n-LL | impl <'l0, 'l1, T0> Trait1<'l0, T0> for bool where T0 : Trait0<'l0>, T0 : Trait0<'l1> {}\n-   |                                                         ^^^^^^^^^^^       ^^^^^^^^^^^\n+   = note: cannot satisfy `T0: Trait0<'l0>`\n \n error: aborting due to previous error\n "}, {"sha": "100965de1aa8496d2a5b5940621fead045e58a70", "filename": "src/test/ui/issues/issue-54044.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fissues%2Fissue-54044.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fissues%2Fissue-54044.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54044.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,11 +1,11 @@\n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/issue-54044.rs:3:1\n    |\n LL | #[cold]\n    | ^^^^^^^\n ...\n LL | struct Foo;\n-   | ----------- not a function\n+   | ----------- not a function definition\n    |\n note: the lint level is defined here\n   --> $DIR/issue-54044.rs:1:9\n@@ -14,14 +14,14 @@ LL | #![deny(unused_attributes)]\n    |         ^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/issue-54044.rs:9:5\n    |\n LL |     #[cold]\n    |     ^^^^^^^\n ...\n LL |     5;\n-   |     - not a function\n+   |     - not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n "}, {"sha": "45fa69d6fd7087eebd63be3c9b87cbe54bece7c1", "filename": "src/test/ui/issues/issue-78957.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fissues%2Fissue-78957.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fissues%2Fissue-78957.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-78957.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -4,11 +4,11 @@ error[E0518]: attribute should be applied to function or closure\n LL | pub struct Foo<#[inline] const N: usize>;\n    |                ^^^^^^^^^ -------------- not a function or closure\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/issue-78957.rs:7:16\n    |\n LL | pub struct Bar<#[cold] const N: usize>;\n-   |                ^^^^^^^ -------------- not a function\n+   |                ^^^^^^^ -------------- not a function definition\n    |\n note: the lint level is defined here\n   --> $DIR/issue-78957.rs:1:9\n@@ -29,11 +29,11 @@ error[E0518]: attribute should be applied to function or closure\n LL | pub struct Foo2<#[inline] 'a>(PhantomData<&'a ()>);\n    |                 ^^^^^^^^^ -- not a function or closure\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/issue-78957.rs:15:17\n    |\n LL | pub struct Bar2<#[cold] 'a>(PhantomData<&'a ()>);\n-   |                 ^^^^^^^ -- not a function\n+   |                 ^^^^^^^ -- not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n \n@@ -49,11 +49,11 @@ error[E0518]: attribute should be applied to function or closure\n LL | pub struct Foo3<#[inline] T>(PhantomData<T>);\n    |                 ^^^^^^^^^ - not a function or closure\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/issue-78957.rs:23:17\n    |\n LL | pub struct Bar3<#[cold] T>(PhantomData<T>);\n-   |                 ^^^^^^^ - not a function\n+   |                 ^^^^^^^ - not a function definition\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n "}, {"sha": "5832c4d173c10245c4574f5c47a058be2ad345eb", "filename": "src/test/ui/lifetimes/issue-34979.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Flifetimes%2Fissue-34979.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Flifetimes%2Fissue-34979.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Fissue-34979.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -4,13 +4,7 @@ error[E0283]: type annotations needed: cannot satisfy `&'a (): Foo`\n LL |     &'a (): Foo,\n    |             ^^^\n    |\n-note: multiple `impl`s or `where` clauses satisfying `&'a (): Foo` found\n-  --> $DIR/issue-34979.rs:6:13\n-   |\n-LL |     &'a (): Foo,\n-   |             ^^^\n-LL |     &'static (): Foo;\n-   |                  ^^^\n+   = note: cannot satisfy `&'a (): Foo`\n \n error: aborting due to previous error\n "}, {"sha": "b13e418e664a6a7fd3e598214e67a4906227e3d0", "filename": "src/test/ui/macros/issue-68060.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fissue-68060.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,11 +1,11 @@\n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/issue-68060.rs:4:13\n    |\n LL |             #[target_feature(enable = \"\")]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n ...\n LL |             |_| (),\n-   |             ------ not a function\n+   |             ------ not a function definition\n \n error: aborting due to previous error\n "}, {"sha": "0bf620934ec7b30e9c8cfee8ee6770fffc79a789", "filename": "src/test/ui/marker_trait_attr/marker-attribute-on-non-trait.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fmarker-attribute-on-non-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fmarker-attribute-on-non-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fmarker-attribute-on-non-trait.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,23 +1,23 @@\n #![feature(marker_trait_attr)]\n \n-#[marker] //~ ERROR attribute can only be applied to a trait\n+#[marker] //~ ERROR attribute should be applied to a trait\n struct Struct {}\n \n-#[marker] //~ ERROR attribute can only be applied to a trait\n+#[marker] //~ ERROR attribute should be applied to a trait\n impl Struct {}\n \n-#[marker] //~ ERROR attribute can only be applied to a trait\n+#[marker] //~ ERROR attribute should be applied to a trait\n union Union {\n     x: i32,\n }\n \n-#[marker] //~ ERROR attribute can only be applied to a trait\n+#[marker] //~ ERROR attribute should be applied to a trait\n const CONST: usize = 10;\n \n-#[marker] //~ ERROR attribute can only be applied to a trait\n+#[marker] //~ ERROR attribute should be applied to a trait\n fn function() {}\n \n-#[marker] //~ ERROR attribute can only be applied to a trait\n+#[marker] //~ ERROR attribute should be applied to a trait\n type Type = ();\n \n fn main() {}"}, {"sha": "19a5290dd7eb640409dc55829c159cfd52cf55bb", "filename": "src/test/ui/marker_trait_attr/marker-attribute-on-non-trait.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fmarker-attribute-on-non-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fmarker-attribute-on-non-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmarker_trait_attr%2Fmarker-attribute-on-non-trait.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,20 +1,20 @@\n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/marker-attribute-on-non-trait.rs:3:1\n    |\n LL | #[marker]\n    | ^^^^^^^^^\n LL | struct Struct {}\n    | ---------------- not a trait\n \n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/marker-attribute-on-non-trait.rs:6:1\n    |\n LL | #[marker]\n    | ^^^^^^^^^\n LL | impl Struct {}\n    | -------------- not a trait\n \n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/marker-attribute-on-non-trait.rs:9:1\n    |\n LL |   #[marker]\n@@ -24,23 +24,23 @@ LL | |     x: i32,\n LL | | }\n    | |_- not a trait\n \n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/marker-attribute-on-non-trait.rs:14:1\n    |\n LL | #[marker]\n    | ^^^^^^^^^\n LL | const CONST: usize = 10;\n    | ------------------------ not a trait\n \n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/marker-attribute-on-non-trait.rs:17:1\n    |\n LL | #[marker]\n    | ^^^^^^^^^\n LL | fn function() {}\n    | ---------------- not a trait\n \n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/marker-attribute-on-non-trait.rs:20:1\n    |\n LL | #[marker]"}, {"sha": "143f9a3009b6171846dcd3e1715c9e694deaafc1", "filename": "src/test/ui/rfc-2008-non-exhaustive/invalid-attribute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -3,11 +3,11 @@\n struct Foo;\n \n #[non_exhaustive]\n-//~^ ERROR attribute can only be applied to a struct or enum [E0701]\n+//~^ ERROR attribute should be applied to a struct or enum [E0701]\n trait Bar { }\n \n #[non_exhaustive]\n-//~^ ERROR attribute can only be applied to a struct or enum [E0701]\n+//~^ ERROR attribute should be applied to a struct or enum [E0701]\n union Baz {\n     f1: u16,\n     f2: u16"}, {"sha": "136cd763b05c17865c12c4dddfa96e67503d714c", "filename": "src/test/ui/rfc-2008-non-exhaustive/invalid-attribute.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Finvalid-attribute.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -4,7 +4,7 @@ error: malformed `non_exhaustive` attribute input\n LL | #[non_exhaustive(anything)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[non_exhaustive]`\n \n-error[E0701]: attribute can only be applied to a struct or enum\n+error[E0701]: attribute should be applied to a struct or enum\n   --> $DIR/invalid-attribute.rs:5:1\n    |\n LL | #[non_exhaustive]\n@@ -13,7 +13,7 @@ LL |\n LL | trait Bar { }\n    | ------------- not a struct or enum\n \n-error[E0701]: attribute can only be applied to a struct or enum\n+error[E0701]: attribute should be applied to a struct or enum\n   --> $DIR/invalid-attribute.rs:9:1\n    |\n LL |   #[non_exhaustive]"}, {"sha": "2d2b01b6f947aea42b4b864f3d453ea9aed78ef0", "filename": "src/test/ui/rfc-2091-track-caller/only-for-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,5 +1,5 @@\n #[track_caller]\n struct S;\n-//~^^ ERROR attribute should be applied to function\n+//~^^ ERROR attribute should be applied to a function definition\n \n fn main() {}"}, {"sha": "b36597bded9414c2fc828953a3b0114492903802", "filename": "src/test/ui/rfc-2091-track-caller/only-for-fns.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fonly-for-fns.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,10 +1,10 @@\n-error[E0739]: attribute should be applied to function\n+error[E0739]: attribute should be applied to a function definition\n   --> $DIR/only-for-fns.rs:1:1\n    |\n LL | #[track_caller]\n    | ^^^^^^^^^^^^^^^\n LL | struct S;\n-   | --------- not a function\n+   | --------- not a function definition\n \n error: aborting due to previous error\n "}, {"sha": "68a8802b2f6455fdb9b445fae0368323b5679ac7", "filename": "src/test/ui/rustdoc/doc_keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -15,6 +15,6 @@ fn foo() {}\n // Regression test for the ICE described in #83512.\n trait Foo {\n     #[doc(keyword = \"match\")]\n-    //~^ ERROR: `#[doc(keyword = \"...\")]` can only be used on modules\n+    //~^ ERROR: `#[doc(keyword = \"...\")]` should be used on modules\n     fn quux() {}\n }"}, {"sha": "a1d0e4ffc09387680100ec8a79e798edde4c7249", "filename": "src/test/ui/rustdoc/doc_keyword.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frustdoc%2Fdoc_keyword.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,16 +1,16 @@\n-error: `#[doc(keyword = \"...\")]` can only be used on empty modules\n+error: `#[doc(keyword = \"...\")]` should be used on empty modules\n   --> $DIR/doc_keyword.rs:6:7\n    |\n LL | #[doc(keyword = \"hell\")]\n    |       ^^^^^^^^^^^^^^^^\n \n-error: `#[doc(keyword = \"...\")]` can only be used on modules\n+error: `#[doc(keyword = \"...\")]` should be used on modules\n   --> $DIR/doc_keyword.rs:11:7\n    |\n LL | #[doc(keyword = \"hall\")]\n    |       ^^^^^^^^^^^^^^^^\n \n-error: `#[doc(keyword = \"...\")]` can only be used on modules\n+error: `#[doc(keyword = \"...\")]` should be used on modules\n   --> $DIR/doc_keyword.rs:17:11\n    |\n LL |     #[doc(keyword = \"match\")]"}, {"sha": "6240f103c99b062a9b60bce70c161ef94efe65a8", "filename": "src/test/ui/span/borrowck-let-suggestion-suffixes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fborrowck-let-suggestion-suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fborrowck-let-suggestion-suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-let-suggestion-suffixes.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -20,7 +20,7 @@ fn f() {\n     //~^ ERROR temporary value dropped while borrowed\n     //~| NOTE creates a temporary which is freed while still in use\n     //~| NOTE temporary value is freed at the end of this statement\n-    //~| NOTE consider using a `let` binding to create a longer lived value\n+    //~| HELP consider using a `let` binding to create a longer lived value\n \n     {\n \n@@ -41,7 +41,7 @@ fn f() {\n     //~^ ERROR temporary value dropped while borrowed\n     //~| NOTE creates a temporary which is freed while still in use\n     //~| NOTE temporary value is freed at the end of this statement\n-    //~| NOTE consider using a `let` binding to create a longer lived value\n+    //~| HELP consider using a `let` binding to create a longer lived value\n \n     v1.push(&old[0]);\n "}, {"sha": "a236dab3ae562ef96a19c2c7423c0a9169835dbb", "filename": "src/test/ui/span/borrowck-let-suggestion-suffixes.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fborrowck-let-suggestion-suffixes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fborrowck-let-suggestion-suffixes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-let-suggestion-suffixes.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -21,7 +21,11 @@ LL |     v3.push(&id('x'));           // statement 6\n LL |     (v1, v2, v3, /* v4 is above. */ v5).use_ref();\n    |              -- borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~     let binding = id('x');\n+LL ~     v3.push(&binding);           // statement 6\n+   |\n \n error[E0716]: temporary value dropped while borrowed\n   --> $DIR/borrowck-let-suggestion-suffixes.rs:29:18\n@@ -47,7 +51,11 @@ LL |     v5.push(&id('z'));\n LL |     (v1, v2, v3, /* v4 is above. */ v5).use_ref();\n    |                                     -- borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~     let binding = id('z');\n+LL ~     v5.push(&binding);\n+   |\n \n error: aborting due to 4 previous errors\n "}, {"sha": "51f65e5345d2a0f2ad3b75b0621b4ecf83c55226", "filename": "src/test/ui/span/borrowck-ref-into-rvalue.fixed", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.fixed?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+fn main() {\n+    let msg;\n+    let binding = Some(\"Hello\".to_string());\n+    match binding {\n+        //~^ ERROR temporary value dropped while borrowed\n+        Some(ref m) => {\n+            msg = m;\n+        },\n+        None => { panic!() }\n+    }\n+    println!(\"{}\", *msg);\n+}"}, {"sha": "7b09fad927fdf75040fea2d118cea45a6db1da7f", "filename": "src/test/ui/span/borrowck-ref-into-rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n fn main() {\n     let msg;\n     match Some(\"Hello\".to_string()) {"}, {"sha": "cb5289d24b4fc4ee5ee9a3c272ba48860c43e791", "filename": "src/test/ui/span/borrowck-ref-into-rvalue.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-ref-into-rvalue.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,5 +1,5 @@\n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/borrowck-ref-into-rvalue.rs:3:11\n+  --> $DIR/borrowck-ref-into-rvalue.rs:4:11\n    |\n LL |     match Some(\"Hello\".to_string()) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^ creates a temporary which is freed while still in use\n@@ -9,7 +9,11 @@ LL |     }\n LL |     println!(\"{}\", *msg);\n    |                    ---- borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~     let binding = Some(\"Hello\".to_string());\n+LL ~     match binding {\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "e6d1a4dd32806e4c75ff4dd4a7a5ffeedf2f02d8", "filename": "src/test/ui/span/issue-15480.fixed", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fissue-15480.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fissue-15480.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-15480.fixed?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+fn id<T>(x: T) -> T { x }\n+\n+fn main() {\n+    let binding = id(3);\n+    let v = vec![\n+        &binding\n+    ];\n+    //~^^ ERROR temporary value dropped while borrowed\n+\n+    for &&x in &v {\n+        println!(\"{}\", x + 3);\n+    }\n+}"}, {"sha": "916ce4b1edb266330b8972fc2fa127acc321ed6b", "filename": "src/test/ui/span/issue-15480.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fissue-15480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fissue-15480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-15480.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n fn id<T>(x: T) -> T { x }\n \n fn main() {"}, {"sha": "460ad9ac7444502da198362c2f3273b317035134", "filename": "src/test/ui/span/issue-15480.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fissue-15480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Fspan%2Fissue-15480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-15480.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,5 +1,5 @@\n error[E0716]: temporary value dropped while borrowed\n-  --> $DIR/issue-15480.rs:5:10\n+  --> $DIR/issue-15480.rs:6:10\n    |\n LL |         &id(3)\n    |          ^^^^^ creates a temporary which is freed while still in use\n@@ -9,7 +9,12 @@ LL |     ];\n LL |     for &&x in &v {\n    |                -- borrow later used here\n    |\n-   = note: consider using a `let` binding to create a longer lived value\n+help: consider using a `let` binding to create a longer lived value\n+   |\n+LL ~     let binding = id(3);\n+LL ~     let v = vec![\n+LL ~         &binding\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "889ced9752bd4520b3460ac8cc78ec679a28c157", "filename": "src/test/ui/target-feature/invalid-attribute.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftarget-feature%2Finvalid-attribute.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -34,43 +34,43 @@ LL | fn bar() {}\n    = note: see issue #69098 <https://github.com/rust-lang/rust/issues/69098> for more information\n    = help: add `#![feature(target_feature_11)]` to the crate attributes to enable\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:34:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | mod another {}\n-   | -------------- not a function\n+   | -------------- not a function definition\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:39:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | const FOO: usize = 7;\n-   | --------------------- not a function\n+   | --------------------- not a function definition\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:44:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | struct Foo;\n-   | ----------- not a function\n+   | ----------- not a function definition\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:49:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | enum Bar {}\n-   | ----------- not a function\n+   | ----------- not a function definition\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:54:1\n    |\n LL |   #[target_feature(enable = \"sse2\")]\n@@ -81,24 +81,24 @@ LL | |\n LL | |     f1: u16,\n LL | |     f2: u16,\n LL | | }\n-   | |_- not a function\n+   | |_- not a function definition\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:62:1\n    |\n LL | #[target_feature(enable = \"sse2\")]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL | trait Baz {}\n-   | ------------ not a function\n+   | ------------ not a function definition\n \n error: cannot use `#[inline(always)]` with `#[target_feature]`\n   --> $DIR/invalid-attribute.rs:67:1\n    |\n LL | #[inline(always)]\n    | ^^^^^^^^^^^^^^^^^\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:85:5\n    |\n LL |       #[target_feature(enable = \"sse2\")]\n@@ -108,16 +108,16 @@ LL | /     unsafe {\n LL | |         foo();\n LL | |         bar();\n LL | |     }\n-   | |_____- not a function\n+   | |_____- not a function definition\n \n-error: attribute should be applied to a function\n+error: attribute should be applied to a function definition\n   --> $DIR/invalid-attribute.rs:93:5\n    |\n LL |     #[target_feature(enable = \"sse2\")]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |\n LL |     || {};\n-   |     ----- not a function\n+   |     ----- not a function definition\n \n error[E0658]: `#[target_feature(..)]` can only be applied to `unsafe` functions\n   --> $DIR/invalid-attribute.rs:77:5"}, {"sha": "1f896da94db57c279aefcae77bcef77009587a66", "filename": "src/test/ui/traits/default-method/rustc_must_implement_one_of_misuse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -36,11 +36,11 @@ trait Tr5 {\n }\n \n #[rustc_must_implement_one_of(abc, xyz)]\n-//~^ attribute can only be applied to a trait\n+//~^ attribute should be applied to a trait\n fn function() {}\n \n #[rustc_must_implement_one_of(abc, xyz)]\n-//~^ attribute can only be applied to a trait\n+//~^ attribute should be applied to a trait\n struct Struct {}\n \n fn main() {}"}, {"sha": "869184f0d1a69fc3f28f5ccd186116077158f634", "filename": "src/test/ui/traits/default-method/rustc_must_implement_one_of_misuse.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fdefault-method%2Frustc_must_implement_one_of_misuse.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -4,7 +4,7 @@ error: malformed `rustc_must_implement_one_of` attribute input\n LL | #[rustc_must_implement_one_of]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[rustc_must_implement_one_of(function1, function2, ...)]`\n \n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/rustc_must_implement_one_of_misuse.rs:38:1\n    |\n LL | #[rustc_must_implement_one_of(abc, xyz)]\n@@ -13,7 +13,7 @@ LL |\n LL | fn function() {}\n    | ---------------- not a trait\n \n-error: attribute can only be applied to a trait\n+error: attribute should be applied to a trait\n   --> $DIR/rustc_must_implement_one_of_misuse.rs:42:1\n    |\n LL | #[rustc_must_implement_one_of(abc, xyz)]"}, {"sha": "fa280135beb2d98a99f1605dc79ea8c33b57b7fa", "filename": "src/test/ui/traits/issue-85735.stderr", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftraits%2Fissue-85735.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftraits%2Fissue-85735.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fissue-85735.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -4,14 +4,7 @@ error[E0283]: type annotations needed: cannot satisfy `T: FnMut<(&'a (),)>`\n LL |     T: FnMut(&'a ()),\n    |        ^^^^^^^^^^^^^\n    |\n-note: multiple `impl`s or `where` clauses satisfying `T: FnMut<(&'a (),)>` found\n-  --> $DIR/issue-85735.rs:7:8\n-   |\n-LL |     T: FnMut(&'a ()),\n-   |        ^^^^^^^^^^^^^\n-LL |\n-LL |     T: FnMut(&'b ()),\n-   |        ^^^^^^^^^^^^^\n+   = note: cannot satisfy `T: FnMut<(&'a (),)>`\n \n error: aborting due to previous error\n "}, {"sha": "9a50c0f988a568ac431906331fd54f9c624b2b32", "filename": "src/test/ui/type-alias-impl-trait/cross_inference_pattern_bug.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,8 +1,9 @@\n // compile-flags: --edition=2021\n+// check-pass\n #![feature(type_alias_impl_trait)]\n \n fn main() {\n-    type T = impl Copy; //~ ERROR unconstrained opaque type\n+    type T = impl Copy;\n     let foo: T = (1u32, 2u32);\n     let (a, b): (u32, u32) = foo;\n }"}, {"sha": "03b172e6de5706f8dcf6e1c38e289bed1df6f022", "filename": "src/test/ui/type-alias-impl-trait/cross_inference_pattern_bug.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7210e46dc69a4b197a313d093fe145722c248b7d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7210e46dc69a4b197a313d093fe145722c248b7d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug.stderr?ref=7210e46dc69a4b197a313d093fe145722c248b7d", "patch": "@@ -1,10 +0,0 @@\n-error: unconstrained opaque type\n-  --> $DIR/cross_inference_pattern_bug.rs:5:14\n-   |\n-LL |     type T = impl Copy;\n-   |              ^^^^^^^^^\n-   |\n-   = note: `T` must be used in combination with a concrete type within the same module\n-\n-error: aborting due to previous error\n-"}, {"sha": "b929122a6c23fccee8f2d15ea70ee4459b7885bf", "filename": "src/test/ui/type-alias-impl-trait/cross_inference_pattern_bug_no_type.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -1,13 +1,13 @@\n-// known-bug: #96572\n // compile-flags: --edition=2021 --crate-type=lib\n // rustc-env:RUST_BACKTRACE=0\n+// check-pass\n \n // tracked in https://github.com/rust-lang/rust/issues/96572\n \n #![feature(type_alias_impl_trait)]\n \n fn main() {\n-    type T = impl Copy;  // error: unconstrained opaque type\n+    type T = impl Copy;\n     let foo: T = (1u32, 2u32);\n-    let (a, b) = foo; // removing this line makes the code compile\n+    let (a, b) = foo; // this line used to make the code fail\n }"}, {"sha": "8aa1f495639951ff05e51d906d728a69dd8fd9bf", "filename": "src/test/ui/type-alias-impl-trait/cross_inference_pattern_bug_no_type.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7210e46dc69a4b197a313d093fe145722c248b7d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7210e46dc69a4b197a313d093fe145722c248b7d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fcross_inference_pattern_bug_no_type.stderr?ref=7210e46dc69a4b197a313d093fe145722c248b7d", "patch": "@@ -1,10 +0,0 @@\n-error: unconstrained opaque type\n-  --> $DIR/cross_inference_pattern_bug_no_type.rs:10:14\n-   |\n-LL |     type T = impl Copy;  // error: unconstrained opaque type\n-   |              ^^^^^^^^^\n-   |\n-   = note: `T` must be used in combination with a concrete type within the same module\n-\n-error: aborting due to previous error\n-"}, {"sha": "825710851b01f0dcab6c8bdb7cdd1f6fd9f916da", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-mismatch.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,10 @@\n+#![feature(type_alias_impl_trait)]\n+\n+fn main() {\n+    type T = impl Copy;\n+    let foo: T = Some((1u32, 2u32));\n+    match foo {\n+        None => (),\n+        Some((a, b, c)) => (), //~ ERROR mismatched types\n+    }\n+}"}, {"sha": "728244a1844dbe8eccb6b8143e1966218814d372", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-mismatch.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-mismatch.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,15 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-96572-unconstrained-mismatch.rs:8:14\n+   |\n+LL |     match foo {\n+   |           --- this expression has type `T`\n+LL |         None => (),\n+LL |         Some((a, b, c)) => (),\n+   |              ^^^^^^^^^ expected a tuple with 2 elements, found one with 3 elements\n+   |\n+   = note: expected tuple `(u32, u32)`\n+              found tuple `(_, _, _)`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "c0a371eca1c6feaa6945cbf5ce8cc01a97a00cde", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-only-pattern-rpit.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern-rpit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern-rpit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern-rpit.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,29 @@\n+// check-pass\n+\n+#[allow(unconditional_recursion)]\n+fn foo(b: bool) -> impl Copy {\n+    let (mut x, mut y) = foo(false);\n+    x = 42;\n+    y = \"foo\";\n+    if b {\n+        panic!()\n+    } else {\n+        foo(true)\n+    }\n+}\n+\n+fn bar(b: bool) -> Option<impl Copy> {\n+    if b {\n+        return None;\n+    }\n+    match bar(!b) {\n+        Some((mut x, mut y)) => {\n+            x = 42;\n+            y = \"foo\";\n+        }\n+        None => {}\n+    }\n+    None\n+}\n+\n+fn main() {}"}, {"sha": "ec249958590f1ce12549e07194c661fe15d6e8ff", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-only-pattern.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-only-pattern.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,24 @@\n+#![feature(type_alias_impl_trait)]\n+// check-pass\n+\n+type T = impl Copy;\n+\n+fn foo(foo: T) {\n+    let (mut x, mut y) = foo;\n+    x = 42;\n+    y = \"foo\";\n+}\n+\n+type U = impl Copy;\n+\n+fn bar(bar: Option<U>) {\n+    match bar {\n+        Some((mut x, mut y)) => {\n+            x = 42;\n+            y = \"foo\";\n+        }\n+        None => {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "3351d9bcff1f88db8113b98edae332981fb41fff", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-struct.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-struct.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,11 @@\n+#![feature(type_alias_impl_trait)]\n+// check-pass\n+\n+#[derive(Copy, Clone)]\n+struct Foo((u32, u32));\n+\n+fn main() {\n+    type U = impl Copy;\n+    let foo: U = Foo((1u32, 2u32));\n+    let Foo((a, b)) = foo;\n+}"}, {"sha": "ef3279a98d199f1cd2ca4115f2e06d7e362f1b05", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-upvar-enum.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-upvar-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-upvar-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-upvar-enum.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,13 @@\n+#![feature(type_alias_impl_trait)]\n+// check-pass\n+\n+fn main() {\n+    type T = impl Copy;\n+    let foo: T = Some((1u32, 2u32));\n+    let x = move || {\n+        match foo {\n+            None => (),\n+            Some((a, b)) => (),\n+        }\n+    };\n+}"}, {"sha": "bb0fc7c7534f5cec459993187a9f338378f99962", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained-upvar.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained-upvar.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,13 @@\n+#![feature(type_alias_impl_trait)]\n+// check-pass\n+\n+#[derive(Copy, Clone)]\n+struct Foo((u32, u32));\n+\n+fn main() {\n+    type T = impl Copy;\n+    let foo: T = Foo((1u32, 2u32));\n+    let x = move || {\n+        let Foo((a, b)) = foo;\n+    };\n+}"}, {"sha": "4b9ed7f28eb3f3ca621f63dd1e98b54f48eaa8ee", "filename": "src/test/ui/type-alias-impl-trait/issue-96572-unconstrained.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-96572-unconstrained.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -0,0 +1,11 @@\n+#![feature(type_alias_impl_trait)]\n+// check-pass\n+\n+fn main() {\n+    type T = impl Copy;\n+    let foo: T = Some((1u32, 2u32));\n+    match foo {\n+        None => (),\n+        Some((a, b)) => (),\n+    }\n+}"}, {"sha": "75feb5698eb630ea2e868cfb5cf4ea6d0e0b1eb5", "filename": "src/test/ui/type/type-check/issue-40294.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-40294.stderr?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -4,13 +4,7 @@ error[E0283]: type annotations needed: cannot satisfy `&'a T: Foo`\n LL |     where &'a T : Foo,\n    |                   ^^^\n    |\n-note: multiple `impl`s or `where` clauses satisfying `&'a T: Foo` found\n-  --> $DIR/issue-40294.rs:6:19\n-   |\n-LL |     where &'a T : Foo,\n-   |                   ^^^\n-LL |           &'b T : Foo\n-   |                   ^^^\n+   = note: cannot satisfy `&'a T: Foo`\n \n error: aborting due to previous error\n "}, {"sha": "0aa085fc71bfe4b03c8faafd97f049e87274e640", "filename": "src/tools/clippy/clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformat.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -82,7 +82,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessFormat {\n                 then {\n                     let is_new_string = match value.kind {\n                         ExprKind::Binary(..) => true,\n-                        ExprKind::MethodCall(path, ..) => path.ident.name.as_str() == \"to_string\",\n+                        ExprKind::MethodCall(path, ..) => path.ident.name == sym::to_string,\n                         _ => false,\n                     };\n                     let sugg = if format_args.format_string_span.contains(value.span) {"}, {"sha": "17d867aacb533b3d483e25d16cf31d74b224684f", "filename": "src/tools/clippy/clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -98,7 +98,7 @@ impl<'tcx> LateLintPass<'tcx> for InherentToString {\n         if_chain! {\n             // Check if item is a method, called to_string and has a parameter 'self'\n             if let ImplItemKind::Fn(ref signature, _) = impl_item.kind;\n-            if impl_item.ident.name.as_str() == \"to_string\";\n+            if impl_item.ident.name == sym::to_string;\n             let decl = &signature.decl;\n             if decl.implicit_self.has_implicit_self();\n             if decl.inputs.len() == 1;"}, {"sha": "b3276f1394ed2f7bcb0f4bcd3ad5bea8322717ce", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -427,5 +427,5 @@ fn is_cow_into_owned(cx: &LateContext<'_>, method_name: Symbol, method_def_id: D\n \n /// Returns true if the named method is `ToString::to_string`.\n fn is_to_string(cx: &LateContext<'_>, method_name: Symbol, method_def_id: DefId) -> bool {\n-    method_name.as_str() == \"to_string\" && is_diag_trait_item(cx, method_def_id, sym::ToString)\n+    method_name == sym::to_string && is_diag_trait_item(cx, method_def_id, sym::ToString)\n }"}, {"sha": "9690ad2777177c8e66477f457044e44693a8a398", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d5e7f4782e4b699728d0a08200ecd1a54d56a85d/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=d5e7f4782e4b699728d0a08200ecd1a54d56a85d", "patch": "@@ -252,6 +252,7 @@ fn check_place<'tcx>(tcx: TyCtxt<'tcx>, place: Place<'tcx>, span: Span, body: &B\n                 }\n             },\n             ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::OpaqueCast(..)\n             | ProjectionElem::Downcast(..)\n             | ProjectionElem::Subslice { .. }\n             | ProjectionElem::Deref"}]}