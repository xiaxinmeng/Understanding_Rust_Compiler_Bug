{"sha": "2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlY2IxMjZmNWNhZWIyNDhlMzMzZjg1NTllYjFiN2RmZDM0Y2M3NDQ=", "commit": {"author": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-26T17:59:38Z"}, "committer": {"name": "uHOOCCOOHu", "email": "hooccooh1896@gmail.com", "date": "2019-09-26T18:05:06Z"}, "message": "Support `$crate` in item and expr place.", "tree": {"sha": "02ca4f902520e3d2ec98fe8ce71be8a319bcdc66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02ca4f902520e3d2ec98fe8ce71be8a319bcdc66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAl2M/dIACgkQztOS3gxI\nPQCGvg/9Gvi11SDTSCA3Bok3R3plHinHurDNC9r2pyOd9ZabrYYYaDPJOImmtHel\npbBQyvCvaAG4j/KOuFhcwldHK8iD5vvqj3V/Iv9oX9HNf1K+uINo292+eX/EkZhD\nZ7Y0S2Z0XT4p2jHSysoJE1nGbj6AEh2n3TQSyCPji8f4FIOBYltImnYEwx9Dbqgb\nM0jhvA79G6W8rP0itICi6Ackrac/NsmYMIpE0TgCokMgR6kVJ6gS/WBTdcyXXUpQ\n2LUhZfp7qrxL+X/VxOonLJbIE605SuU/qSlV1nxVvWyc4XHvr70Dqo+hbhlB0iHc\nCTN5oedSZBANW0mgIWdF7084PyRRDjgc4m6QrwKp3wjT2rWA4HTdm0Hm2HchjwcL\n5LhxO8eAjkD+7GB60G/zsW5IbN+vOA4RSW3hMEd9dthIMAiGjnllKjqP2bx0QQmm\nkbdvoAJorstmllHU3pB1+2CP8h1/IPt5hu/PEb6xgVjTbii+stEycNZQU52rthWu\nXJjh7SkHZ4KYdnzHf/QhaIktOUYHvDs1FJZTkXYbOhVAvveSYwtRUcnLM1D2fOVM\nI3YSvowtKZ8+dBFNq+EaNNPqQgxA03fvSINA+nlTV3X1XaexoRFHsHfVpQZLDVE2\nmpRkm+1RQdO/YSomiVc01NMxMMvv/swnP5LJ+bj/VMa2wh8bxnI=\n=Pb0v\n-----END PGP SIGNATURE-----", "payload": "tree 02ca4f902520e3d2ec98fe8ce71be8a319bcdc66\nparent 8cd23a4fb8c6a1012ba3e40dd3329a5abaed06b7\nauthor uHOOCCOOHu <hooccooh1896@gmail.com> 1569520778 +0800\ncommitter uHOOCCOOHu <hooccooh1896@gmail.com> 1569521106 +0800\n\nSupport `$crate` in item and expr place.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "html_url": "https://github.com/rust-lang/rust/commit/2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/comments", "author": null, "committer": null, "parents": [{"sha": "8cd23a4fb8c6a1012ba3e40dd3329a5abaed06b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cd23a4fb8c6a1012ba3e40dd3329a5abaed06b7", "html_url": "https://github.com/rust-lang/rust/commit/8cd23a4fb8c6a1012ba3e40dd3329a5abaed06b7"}], "stats": {"total": 305, "additions": 268, "deletions": 37}, "files": [{"sha": "43c14ad238d0a2091627f312058aa4f8af9234f0", "filename": "crates/ra_assists/src/assists/auto_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fauto_import.rs?ref=2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "patch": "@@ -512,7 +512,7 @@ pub fn collect_hir_path_segments(path: &hir::Path) -> Option<Vec<SmolStr>> {\n         hir::PathKind::Plain => {}\n         hir::PathKind::Self_ => ps.push(\"self\".into()),\n         hir::PathKind::Super => ps.push(\"super\".into()),\n-        hir::PathKind::Type(_) => return None,\n+        hir::PathKind::Type(_) | hir::PathKind::DollarCrate(_) => return None,\n     }\n     for s in path.segments.iter() {\n         ps.push(s.name.to_string().into());"}, {"sha": "6d6f6050656dce763c2d92cded035374ebd24c6c", "filename": "crates/ra_hir/src/expr/lower.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Flower.rs?ref=2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "patch": "@@ -272,8 +272,11 @@ where\n                 self.alloc_expr(Expr::Match { expr, arms }, syntax_ptr)\n             }\n             ast::Expr::PathExpr(e) => {\n-                let path =\n-                    e.path().and_then(Path::from_ast).map(Expr::Path).unwrap_or(Expr::Missing);\n+                let path = e\n+                    .path()\n+                    .and_then(|path| self.parse_path(path))\n+                    .map(Expr::Path)\n+                    .unwrap_or(Expr::Missing);\n                 self.alloc_expr(path, syntax_ptr)\n             }\n             ast::Expr::ContinueExpr(_e) => {\n@@ -295,7 +298,7 @@ where\n                 self.alloc_expr(Expr::Return { expr }, syntax_ptr)\n             }\n             ast::Expr::RecordLit(e) => {\n-                let path = e.path().and_then(Path::from_ast);\n+                let path = e.path().and_then(|path| self.parse_path(path));\n                 let mut field_ptrs = Vec::new();\n                 let record_lit = if let Some(nfl) = e.record_field_list() {\n                     let fields = nfl\n@@ -459,7 +462,7 @@ where\n                     .ast_id(&e)\n                     .with_file_id(self.current_file_id);\n \n-                if let Some(path) = e.path().and_then(Path::from_ast) {\n+                if let Some(path) = e.path().and_then(|path| self.parse_path(path)) {\n                     if let Some(def) = self.resolver.resolve_path_as_macro(self.db, &path) {\n                         let call_id = MacroCallLoc { def: def.id, ast_id }.id(self.db);\n                         let file_id = call_id.as_file(MacroFileKind::Expr);\n@@ -529,7 +532,7 @@ where\n                 Pat::Bind { name, mode: annotation, subpat }\n             }\n             ast::Pat::TupleStructPat(p) => {\n-                let path = p.path().and_then(Path::from_ast);\n+                let path = p.path().and_then(|path| self.parse_path(path));\n                 let args = p.args().map(|p| self.collect_pat(p)).collect();\n                 Pat::TupleStruct { path, args }\n             }\n@@ -539,7 +542,7 @@ where\n                 Pat::Ref { pat, mutability }\n             }\n             ast::Pat::PathPat(p) => {\n-                let path = p.path().and_then(Path::from_ast);\n+                let path = p.path().and_then(|path| self.parse_path(path));\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n             ast::Pat::TuplePat(p) => {\n@@ -548,7 +551,7 @@ where\n             }\n             ast::Pat::PlaceholderPat(_) => Pat::Wild,\n             ast::Pat::RecordPat(p) => {\n-                let path = p.path().and_then(Path::from_ast);\n+                let path = p.path().and_then(|path| self.parse_path(path));\n                 let record_field_pat_list =\n                     p.record_field_pat_list().expect(\"every struct should have a field list\");\n                 let mut fields: Vec<_> = record_field_pat_list\n@@ -589,6 +592,10 @@ where\n             self.missing_pat()\n         }\n     }\n+\n+    fn parse_path(&mut self, path: ast::Path) -> Option<Path> {\n+        Path::from_src(Source { ast: path, file_id: self.current_file_id }, self.db)\n+    }\n }\n \n impl From<ast::BinOp> for BinaryOp {"}, {"sha": "4ce7551c3354735afdd3fbca17ab74cfb7f45c5b", "filename": "crates/ra_hir/src/generics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fgenerics.rs?ref=2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "patch": "@@ -132,6 +132,7 @@ impl GenericParams {\n     fn fill_params(&mut self, params: ast::TypeParamList, start: u32) {\n         for (idx, type_param) in params.type_params().enumerate() {\n             let name = type_param.name().map_or_else(Name::missing, |it| it.as_name());\n+            // FIXME: Use `Path::from_src`\n             let default = type_param.default_type().and_then(|t| t.path()).and_then(Path::from_ast);\n \n             let param = GenericParam { idx: idx as u32 + start, name: name.clone(), default };"}, {"sha": "bcbcd3dd7747d42b1034730ba059b26aa3f27fa6", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "patch": "@@ -58,6 +58,17 @@ impl HirFileId {\n         }\n     }\n \n+    /// Get the crate which the macro lives in, if it is a macro file.\n+    pub(crate) fn macro_crate(self, db: &impl AstDatabase) -> Option<Crate> {\n+        match self.0 {\n+            HirFileIdRepr::File(_) => None,\n+            HirFileIdRepr::Macro(macro_file) => {\n+                let loc = macro_file.macro_call_id.loc(db);\n+                Some(loc.def.krate)\n+            }\n+        }\n+    }\n+\n     pub(crate) fn parse_or_expand_query(\n         db: &impl AstDatabase,\n         file_id: HirFileId,"}, {"sha": "c66a1c6a6dbb664fdc03a0af2cb09300c54053a8", "filename": "crates/ra_hir/src/impl_block.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fimpl_block.rs?ref=2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "patch": "@@ -218,7 +218,10 @@ impl ModuleImplBlocks {\n                 ast::ItemOrMacro::Macro(macro_call) => {\n                     //FIXME: we should really cut down on the boilerplate required to process a macro\n                     let ast_id = db.ast_id_map(file_id).ast_id(&macro_call).with_file_id(file_id);\n-                    if let Some(path) = macro_call.path().and_then(Path::from_ast) {\n+                    if let Some(path) = macro_call\n+                        .path()\n+                        .and_then(|path| Path::from_src(Source { ast: path, file_id }, db))\n+                    {\n                         if let Some(def) = self.module.resolver(db).resolve_path_as_macro(db, &path)\n                         {\n                             let call_id = MacroCallLoc { def: def.id, ast_id }.id(db);"}, {"sha": "72f76bb797b3adfc63ae7b9ffa22b0f30aebc658", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "patch": "@@ -14,4 +14,6 @@ test_utils::marks!(\n     macro_rules_from_other_crates_are_visible_with_macro_use\n     prelude_is_macro_use\n     coerce_merge_fail_fallback\n+    macro_dollar_crate_self\n+    macro_dollar_crate_other\n );"}, {"sha": "15b5b4ee678e1008b48cec0fa6871bcaf34c5ef5", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "patch": "@@ -332,6 +332,20 @@ impl CrateDefMap {\n     ) -> ResolvePathResult {\n         let mut segments = path.segments.iter().enumerate();\n         let mut curr_per_ns: PerNs = match path.kind {\n+            PathKind::DollarCrate(krate) => {\n+                if krate == self.krate {\n+                    tested_by!(macro_dollar_crate_self);\n+                    PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n+                } else {\n+                    match krate.root_module(db) {\n+                        Some(module) => {\n+                            tested_by!(macro_dollar_crate_other);\n+                            PerNs::types(module.into())\n+                        }\n+                        None => return ResolvePathResult::empty(ReachedFixedPoint::No),\n+                    }\n+                }\n+            }\n             PathKind::Crate => {\n                 PerNs::types(Module { krate: self.krate, module_id: self.root }.into())\n             }"}, {"sha": "c607b8a11969a60ffeb8eb773d8ad55118b181bc", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "patch": "@@ -9,7 +9,7 @@ use test_utils::tested_by;\n \n use crate::{\n     db::{AstDatabase, DefDatabase},\n-    AsName, AstIdMap, Either, FileAstId, HirFileId, ModuleSource, Name, Path,\n+    AsName, AstIdMap, Either, FileAstId, HirFileId, ModuleSource, Name, Path, Source,\n };\n \n /// `RawItems` is a set of top-level items in a file (except for impls).\n@@ -71,6 +71,8 @@ impl RawItems {\n             raw_items: RawItems::default(),\n             source_ast_id_map: db.ast_id_map(file_id),\n             source_map: ImportSourceMap::default(),\n+            file_id,\n+            db,\n         };\n         if let Some(node) = db.parse_or_expand(file_id) {\n             if let Some(source_file) = ast::SourceFile::cast(node.clone()) {\n@@ -192,13 +194,15 @@ pub(super) struct MacroData {\n     pub(super) export: bool,\n }\n \n-struct RawItemsCollector {\n+struct RawItemsCollector<DB> {\n     raw_items: RawItems,\n     source_ast_id_map: Arc<AstIdMap>,\n     source_map: ImportSourceMap,\n+    file_id: HirFileId,\n+    db: DB,\n }\n \n-impl RawItemsCollector {\n+impl<DB: AstDatabase> RawItemsCollector<&'_ DB> {\n     fn process_module(&mut self, current_module: Option<Module>, body: impl ast::ModuleItemOwner) {\n         for item_or_macro in body.items_with_macros() {\n             match item_or_macro {\n@@ -300,17 +304,21 @@ impl RawItemsCollector {\n     fn add_use_item(&mut self, current_module: Option<Module>, use_item: ast::UseItem) {\n         let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n \n-        Path::expand_use_item(&use_item, |path, use_tree, is_glob, alias| {\n-            let import_data = ImportData {\n-                path,\n-                alias,\n-                is_glob,\n-                is_prelude,\n-                is_extern_crate: false,\n-                is_macro_use: false,\n-            };\n-            self.push_import(current_module, import_data, Either::A(AstPtr::new(use_tree)));\n-        })\n+        Path::expand_use_item(\n+            Source { ast: use_item, file_id: self.file_id },\n+            self.db,\n+            |path, use_tree, is_glob, alias| {\n+                let import_data = ImportData {\n+                    path,\n+                    alias,\n+                    is_glob,\n+                    is_prelude,\n+                    is_extern_crate: false,\n+                    is_macro_use: false,\n+                };\n+                self.push_import(current_module, import_data, Either::A(AstPtr::new(use_tree)));\n+            },\n+        )\n     }\n \n     fn add_extern_crate_item(\n@@ -335,7 +343,10 @@ impl RawItemsCollector {\n     }\n \n     fn add_macro(&mut self, current_module: Option<Module>, m: ast::MacroCall) {\n-        let path = match m.path().and_then(Path::from_ast) {\n+        let path = match m\n+            .path()\n+            .and_then(|path| Path::from_src(Source { ast: path, file_id: self.file_id }, self.db))\n+        {\n             Some(it) => it,\n             _ => return,\n         };"}, {"sha": "e4b4083948a6dfdb92860d89ccf288098ff47121", "filename": "crates/ra_hir/src/nameres/tests/macros.rs", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "patch": "@@ -515,3 +515,108 @@ fn path_qualified_macros() {\n         \u22eenot_found: _\n     \"###);\n }\n+\n+#[test]\n+fn macro_dollar_crate_is_correct_in_item() {\n+    covers!(macro_dollar_crate_self);\n+    covers!(macro_dollar_crate_other);\n+    let map = def_map_with_crate_graph(\n+        \"\n+        //- /main.rs\n+        #[macro_use]\n+        extern crate foo;\n+\n+        #[macro_use]\n+        mod m {\n+            macro_rules! current {\n+                () => {\n+                    use $crate::Foo as FooSelf;\n+                }\n+            }\n+        }\n+\n+        struct Foo;\n+\n+        current!();\n+        not_current1!();\n+        foo::not_current2!();\n+\n+        //- /lib.rs\n+        mod m {\n+            #[macro_export]\n+            macro_rules! not_current1 {\n+                () => {\n+                    use $crate::Bar;\n+                }\n+            }\n+        }\n+\n+        #[macro_export]\n+        macro_rules! not_current2 {\n+            () => {\n+                use $crate::Baz;\n+            }\n+        }\n+\n+        struct Bar;\n+        struct Baz;\n+        \",\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"foo\"]),\n+            \"foo\": (\"/lib.rs\", []),\n+        },\n+    );\n+    assert_snapshot!(map, @r###\"\n+        \u22eecrate\n+        \u22eeBar: t v\n+        \u22eeBaz: t v\n+        \u22eeFoo: t v\n+        \u22eeFooSelf: t v\n+        \u22eefoo: t\n+        \u22eem: t\n+        \u22ee\n+        \u22eecrate::m\n+    \"###);\n+}\n+\n+#[test]\n+fn macro_dollar_crate_is_correct_in_indirect_deps() {\n+    covers!(macro_dollar_crate_other);\n+    // From std\n+    let map = def_map_with_crate_graph(\n+        r#\"\n+        //- /main.rs\n+        foo!();\n+\n+        //- /std.rs\n+        #[prelude_import]\n+        use self::prelude::*;\n+\n+        pub use core::foo;\n+\n+        mod prelude {}\n+\n+        #[macro_use]\n+        mod std_macros;\n+\n+        //- /core.rs\n+        #[macro_export]\n+        macro_rules! foo {\n+            () => {\n+                use $crate::bar;\n+            }\n+        }\n+\n+        pub struct bar;\n+        \"#,\n+        crate_graph! {\n+            \"main\": (\"/main.rs\", [\"std\"]),\n+            \"std\": (\"/std.rs\", [\"core\"]),\n+            \"core\": (\"/core.rs\", []),\n+        },\n+    );\n+    assert_snapshot!(map, @r###\"\n+        \u22eecrate\n+        \u22eebar: t v\n+    \"###);\n+}"}, {"sha": "158c853d42d100daf7961bfdf0de773f99e4dc0e", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 52, "deletions": 12, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "patch": "@@ -5,7 +5,7 @@ use ra_syntax::{\n     AstNode,\n };\n \n-use crate::{name, type_ref::TypeRef, AsName, Name};\n+use crate::{db::AstDatabase, name, type_ref::TypeRef, AsName, Crate, Name, Source};\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n@@ -52,16 +52,19 @@ pub enum PathKind {\n     Abs,\n     // Type based path like `<T>::foo`\n     Type(Box<TypeRef>),\n+    // `$crate` from macro expansion\n+    DollarCrate(Crate),\n }\n \n impl Path {\n     /// Calls `cb` with all paths, represented by this use item.\n     pub fn expand_use_item(\n-        item: &ast::UseItem,\n+        item_src: Source<ast::UseItem>,\n+        db: &impl AstDatabase,\n         mut cb: impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n     ) {\n-        if let Some(tree) = item.use_tree() {\n-            expand_use_tree(None, tree, &mut cb);\n+        if let Some(tree) = item_src.ast.use_tree() {\n+            expand_use_tree(None, tree, &|| item_src.file_id.macro_crate(db), &mut cb);\n         }\n     }\n \n@@ -76,7 +79,19 @@ impl Path {\n     }\n \n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n-    pub fn from_ast(mut path: ast::Path) -> Option<Path> {\n+    /// DEPRECATED: It does not handle `$crate` from macro call.\n+    pub fn from_ast(path: ast::Path) -> Option<Path> {\n+        Path::parse(path, &|| None)\n+    }\n+\n+    /// Converts an `ast::Path` to `Path`. Works with use trees.\n+    /// It correctly handles `$crate` based path from macro call.\n+    pub fn from_src(source: Source<ast::Path>, db: &impl AstDatabase) -> Option<Path> {\n+        let file_id = source.file_id;\n+        Path::parse(source.ast, &|| file_id.macro_crate(db))\n+    }\n+\n+    fn parse(mut path: ast::Path, macro_crate: &impl Fn() -> Option<Crate>) -> Option<Path> {\n         let mut kind = PathKind::Plain;\n         let mut segments = Vec::new();\n         loop {\n@@ -88,6 +103,13 @@ impl Path {\n \n             match segment.kind()? {\n                 ast::PathSegmentKind::Name(name) => {\n+                    if name.text() == \"$crate\" {\n+                        if let Some(macro_crate) = macro_crate() {\n+                            kind = PathKind::DollarCrate(macro_crate);\n+                            break;\n+                        }\n+                    }\n+\n                     let args = segment\n                         .type_arg_list()\n                         .and_then(GenericArgs::from_ast)\n@@ -113,7 +135,7 @@ impl Path {\n                         }\n                         // <T as Trait<A>>::Foo desugars to Trait<Self=T, A>::Foo\n                         Some(trait_ref) => {\n-                            let path = Path::from_ast(trait_ref.path()?)?;\n+                            let path = Path::parse(trait_ref.path()?, macro_crate)?;\n                             kind = path.kind;\n                             let mut prefix_segments = path.segments;\n                             prefix_segments.reverse();\n@@ -264,6 +286,7 @@ impl From<Name> for Path {\n fn expand_use_tree(\n     prefix: Option<Path>,\n     tree: ast::UseTree,\n+    macro_crate: &impl Fn() -> Option<Crate>,\n     cb: &mut impl FnMut(Path, &ast::UseTree, bool, Option<Name>),\n ) {\n     if let Some(use_tree_list) = tree.use_tree_list() {\n@@ -272,13 +295,13 @@ fn expand_use_tree(\n             None => prefix,\n             // E.g. `use something::{inner}` (prefix is `None`, path is `something`)\n             // or `use something::{path::{inner::{innerer}}}` (prefix is `something::path`, path is `inner`)\n-            Some(path) => match convert_path(prefix, path) {\n+            Some(path) => match convert_path(prefix, path, macro_crate) {\n                 Some(it) => Some(it),\n                 None => return, // FIXME: report errors somewhere\n             },\n         };\n         for child_tree in use_tree_list.use_trees() {\n-            expand_use_tree(prefix.clone(), child_tree, cb);\n+            expand_use_tree(prefix.clone(), child_tree, macro_crate, cb);\n         }\n     } else {\n         let alias = tree.alias().and_then(|a| a.name()).map(|a| a.as_name());\n@@ -295,7 +318,7 @@ fn expand_use_tree(\n                     }\n                 }\n             }\n-            if let Some(path) = convert_path(prefix, ast_path) {\n+            if let Some(path) = convert_path(prefix, ast_path, macro_crate) {\n                 let is_glob = tree.has_star();\n                 cb(path, &tree, is_glob, alias)\n             }\n@@ -305,12 +328,29 @@ fn expand_use_tree(\n     }\n }\n \n-fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n-    let prefix =\n-        if let Some(qual) = path.qualifier() { Some(convert_path(prefix, qual)?) } else { prefix };\n+fn convert_path(\n+    prefix: Option<Path>,\n+    path: ast::Path,\n+    macro_crate: &impl Fn() -> Option<Crate>,\n+) -> Option<Path> {\n+    let prefix = if let Some(qual) = path.qualifier() {\n+        Some(convert_path(prefix, qual, macro_crate)?)\n+    } else {\n+        prefix\n+    };\n+\n     let segment = path.segment()?;\n     let res = match segment.kind()? {\n         ast::PathSegmentKind::Name(name) => {\n+            if name.text() == \"$crate\" {\n+                if let Some(krate) = macro_crate() {\n+                    return Some(Path::from_simple_segments(\n+                        PathKind::DollarCrate(krate),\n+                        iter::empty(),\n+                    ));\n+                }\n+            }\n+\n             // no type args in use\n             let mut res = prefix\n                 .unwrap_or_else(|| Path { kind: PathKind::Plain, segments: Vec::with_capacity(1) });"}, {"sha": "6e89bfc76581cdfaa21021c83235b6e36b463a48", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "patch": "@@ -203,6 +203,7 @@ impl SourceAnalyzer {\n         db: &impl HirDatabase,\n         macro_call: &ast::MacroCall,\n     ) -> Option<MacroDef> {\n+        // This must be a normal source file rather than macro file.\n         let path = macro_call.path().and_then(Path::from_ast)?;\n         self.resolver.resolve_path_as_macro(db, &path)\n     }\n@@ -261,6 +262,7 @@ impl SourceAnalyzer {\n                 return Some(PathResolution::AssocItem(assoc));\n             }\n         }\n+        // This must be a normal source file rather than macro file.\n         let hir_path = crate::Path::from_ast(path.clone())?;\n         self.resolve_hir_path(db, &hir_path)\n     }"}, {"sha": "bd2b07755c4b387db7b7fa9ee52b33fb0354d985", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "patch": "@@ -3130,6 +3130,39 @@ fn test() { S.foo()<|>; }\n     assert_eq!(t, \"u128\");\n }\n \n+#[test]\n+fn infer_macro_with_dollar_crate_is_correct_in_expr() {\n+    covers!(macro_dollar_crate_other);\n+    let (mut db, pos) = MockDatabase::with_position(\n+        r#\"\n+//- /main.rs\n+fn test() {\n+    let x = (foo::foo!(1), foo::foo!(2));\n+    x<|>;\n+}\n+\n+//- /lib.rs\n+#[macro_export]\n+macro_rules! foo {\n+    (1) => { $crate::bar!() };\n+    (2) => { 1 + $crate::baz() };\n+}\n+\n+#[macro_export]\n+macro_rules! bar {\n+    () => { 42 }\n+}\n+\n+pub fn baz() -> usize { 31usize }\n+\"#,\n+    );\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", [\"foo\"]),\n+        \"foo\": (\"/lib.rs\", []),\n+    });\n+    assert_eq!(\"(i32, usize)\", type_at_pos(&db, pos));\n+}\n+\n #[ignore]\n #[test]\n fn method_resolution_trait_before_autoref() {"}, {"sha": "2cf06b25044483f5e17979818cb5b38c742e3998", "filename": "crates/ra_hir/src/type_ref.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ftype_ref.rs?ref=2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "patch": "@@ -72,6 +72,7 @@ impl TypeRef {\n             }\n             ast::TypeRef::NeverType(..) => TypeRef::Never,\n             ast::TypeRef::PathType(inner) => {\n+                // FIXME: Use `Path::from_src`\n                 inner.path().and_then(Path::from_ast).map(TypeRef::Path).unwrap_or(TypeRef::Error)\n             }\n             ast::TypeRef::PointerType(inner) => {\n@@ -141,6 +142,7 @@ impl TypeBound {\n                     Some(p) => p,\n                     None => return TypeBound::Error,\n                 };\n+                // FIXME: Use `Path::from_src`\n                 let path = match Path::from_ast(path) {\n                     Some(p) => p,\n                     None => return TypeBound::Error,"}, {"sha": "ed094d5bb49c4b65024741325f4b9ff17e95b66f", "filename": "crates/ra_mbe/src/mbe_expander/transcriber.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ecb126f5caeb248e333f8559eb1b7dfd34cc744/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander%2Ftranscriber.rs?ref=2ecb126f5caeb248e333f8559eb1b7dfd34cc744", "patch": "@@ -86,7 +86,7 @@ fn expand_subtree(ctx: &mut ExpandCtx, template: &tt::Subtree) -> Result<tt::Sub\n \n fn expand_var(ctx: &mut ExpandCtx, v: &SmolStr) -> Result<Fragment, ExpandError> {\n     let res = if v == \"crate\" {\n-        // FIXME: Properly handle $crate token\n+        // We simply produce identifier `$crate` here. And it will be resolved when lowering ast to Path.\n         let tt =\n             tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: tt::TokenId::unspecified() })\n                 .into();"}]}