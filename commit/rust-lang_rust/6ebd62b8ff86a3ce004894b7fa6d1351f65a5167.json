{"sha": "6ebd62b8ff86a3ce004894b7fa6d1351f65a5167", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlYmQ2MmI4ZmY4NmEzY2UwMDQ4OTRiN2ZhNmQxMzUxZjY1YTUxNjc=", "commit": {"author": {"name": "Pazzaz", "email": "pazzaz.sundqvist@gmail.com", "date": "2018-07-22T20:18:05Z"}, "committer": {"name": "Pazzaz", "email": "pazzaz.sundqvist@gmail.com", "date": "2018-07-22T20:18:05Z"}, "message": "Make VecDeque append safer and easier to understand", "tree": {"sha": "02ef52a9d4ae29ed70d1e87c666fa2b9daf33f68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02ef52a9d4ae29ed70d1e87c666fa2b9daf33f68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ebd62b8ff86a3ce004894b7fa6d1351f65a5167", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ebd62b8ff86a3ce004894b7fa6d1351f65a5167", "html_url": "https://github.com/rust-lang/rust/commit/6ebd62b8ff86a3ce004894b7fa6d1351f65a5167", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ebd62b8ff86a3ce004894b7fa6d1351f65a5167/comments", "author": {"login": "Pazzaz", "id": 16006944, "node_id": "MDQ6VXNlcjE2MDA2OTQ0", "avatar_url": "https://avatars.githubusercontent.com/u/16006944?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Pazzaz", "html_url": "https://github.com/Pazzaz", "followers_url": "https://api.github.com/users/Pazzaz/followers", "following_url": "https://api.github.com/users/Pazzaz/following{/other_user}", "gists_url": "https://api.github.com/users/Pazzaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Pazzaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Pazzaz/subscriptions", "organizations_url": "https://api.github.com/users/Pazzaz/orgs", "repos_url": "https://api.github.com/users/Pazzaz/repos", "events_url": "https://api.github.com/users/Pazzaz/events{/privacy}", "received_events_url": "https://api.github.com/users/Pazzaz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Pazzaz", "id": 16006944, "node_id": "MDQ6VXNlcjE2MDA2OTQ0", "avatar_url": "https://avatars.githubusercontent.com/u/16006944?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Pazzaz", "html_url": "https://github.com/Pazzaz", "followers_url": "https://api.github.com/users/Pazzaz/followers", "following_url": "https://api.github.com/users/Pazzaz/following{/other_user}", "gists_url": "https://api.github.com/users/Pazzaz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Pazzaz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Pazzaz/subscriptions", "organizations_url": "https://api.github.com/users/Pazzaz/orgs", "repos_url": "https://api.github.com/users/Pazzaz/repos", "events_url": "https://api.github.com/users/Pazzaz/events{/privacy}", "received_events_url": "https://api.github.com/users/Pazzaz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f1fdecb3c152b9ca0713f7c85589f9447f28961", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f1fdecb3c152b9ca0713f7c85589f9447f28961", "html_url": "https://github.com/rust-lang/rust/commit/9f1fdecb3c152b9ca0713f7c85589f9447f28961"}], "stats": {"total": 240, "additions": 131, "deletions": 109}, "files": [{"sha": "7f4fbb99c22d6347c63a314a52ba312ebbc457e6", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 131, "deletions": 109, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/6ebd62b8ff86a3ce004894b7fa6d1351f65a5167/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ebd62b8ff86a3ce004894b7fa6d1351f65a5167/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=6ebd62b8ff86a3ce004894b7fa6d1351f65a5167", "patch": "@@ -202,6 +202,20 @@ impl<T> VecDeque<T> {\n                                  len);\n     }\n \n+    /// Returns a pair of slices which contain the contents of the buffer not used by the VecDeque.\n+    #[inline]\n+    unsafe fn unused_as_mut_slices<'a>(&'a mut self) -> (&'a mut [T], &'a mut [T]) {\n+        let head = self.head;\n+        let tail = self.tail;\n+        let buf = self.buffer_as_mut_slice();\n+        if head == tail {\n+            let (before, after) = buf.split_at_mut(head);\n+            (after, before)\n+        } else {\n+            RingSlices::ring_slices(buf, tail, head)\n+        }\n+    }\n+\n     /// Copies a potentially wrapping block of memory len long from src to dest.\n     /// (abs(dst - src) + len) must be no larger than cap() (There must be at\n     /// most one continuous overlapping region between src and dest).\n@@ -1834,144 +1848,152 @@ impl<T> VecDeque<T> {\n     #[inline]\n     #[stable(feature = \"append\", since = \"1.4.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n-        // Copy from src[i1..i1 + len] to dst[i2..i2 + len].\n-        // Does not check if the ranges are valid.\n-        unsafe fn copy_part<T>(i1: usize, i2: usize, len: usize, src: &[T], dst: &mut [T]) {\n-            debug_assert!(src.get(i1..i1 + len).is_some() && dst.get(i2..i2 + len).is_some());\n-            ptr::copy_nonoverlapping(src.as_ptr().add(i1), dst.as_mut_ptr().add(i2), len);\n+        // Copies all values from `src_slice` to the start of `dst_slice`.\n+        unsafe fn copy_whole_slice<T>(src_slice: &[T], dst_slice: &mut [T]) {\n+            let len = src_slice.len();\n+            ptr::copy_nonoverlapping(src_slice.as_ptr(), dst_slice[..len].as_mut_ptr(), len);\n         }\n \n         let src_total = other.len();\n \n         // Guarantees there is space in `self` for `other`.\n         self.reserve(src_total);\n \n-        self.head = {\n-            let dst_start_1 = self.head;\n-            let src_start_1 = other.tail;\n-            let dst_wrap_point = self.cap();\n-            let src_wrap_point = other.cap();\n-\n-            let dst = unsafe { self.buffer_as_mut_slice() };\n-            let src = unsafe { other.buffer_as_slice() };\n+        let new_head = {\n+            let original_head = self.head;\n \n-            let src_wraps = other.tail > other.head;\n-            let dst_wraps = dst_start_1 + src_total > dst_wrap_point;\n+            // The goal is to copy all values from `other` into `self`. To avoid any\n+            // mismatch, all valid values in `other` are retrieved...\n+            let (src_high, src_low) = other.as_slices();\n+            // and unoccupied parts of self are retrieved.\n+            let (dst_high, dst_low) = unsafe { self.unused_as_mut_slices() };\n \n-            // When minimizing the amount of calls to `copy_part`, there are\n-            // 6 different cases to handle. Whether src and/or dst wrap are 4\n-            // combinations and there are 3 distinct cases when they both wrap.\n-            // 6 = 3 + 1 + 1 + 1\n-            match (src_wraps, dst_wraps) {\n+            // Then all that is needed is to copy all values from\n+            // src (src_high and src_low) to dst (dst_high and dst_low).\n+            //\n+            // other [o o o . . . . . o o o o]\n+            //       [5 6 7]         [1 2 3 4]\n+            //       src_low         src_high\n+            //\n+            // self  [. . . . . . o o o o . .]\n+            //       [3 4 5 6 7 .]       [1 2]\n+            //       dst_low             dst_high\n+            //\n+            // Values are not copied one by one but as slices in `copy_whole_slice`.\n+            // What slices are used depends on various properties of src and dst.\n+            // There are 6 cases in total:\n+            //     1. `src` and `dst` are contiguous\n+            //     2. `src` is contiguous and `dst` is discontiguous\n+            //     3. `src` is discontiguous and `dst` is contiguous\n+            //     4. `src` and `dst` are discontiguous\n+            //        + src_high is smaller than dst_high\n+            //     5. `src` and `dst` are discontiguous\n+            //        + dst_high is smaller than src_high\n+            //     6. `src` and `dst` are discontiguous\n+            //        + dst_high is the same size as src_high\n+            let src_contiguous = src_low.is_empty();\n+            let dst_contiguous = dst_high.len() >= src_total;\n+            match (src_contiguous, dst_contiguous) {\n                 (true, true) => {\n-                    let dst_before_wrap = dst_wrap_point - dst_start_1;\n-                    let src_before_wrap = src_wrap_point - src_start_1;\n-\n-                    if src_before_wrap < dst_before_wrap {\n-                        //            src\n-                        // [o o o . . . . . . o o o]\n-                        //  2 3 3             1 1 1\n-                        //\n-                        //            dst\n-                        // [. . . . . . o o . . . .]\n-                        //  3 3 H           1 1 1 2\n-                        let src_2 = dst_before_wrap - src_before_wrap;\n-                        let dst_start_2 = dst_start_1 + src_before_wrap;\n-                        let src_3 = src_total - dst_before_wrap;\n-\n-                        unsafe {\n-                            copy_part(src_start_1, dst_start_1, src_before_wrap, src, dst);\n-                            copy_part(0, dst_start_2, src_2, src, dst);\n-                            copy_part(src_2, 0, src_3, src, dst);\n-                        }\n-                        src_3\n-                    } else if src_before_wrap > dst_before_wrap {\n-                        //            src\n-                        // [o o o . . . . . o o o o]\n-                        //  3 3 3           1 1 2 2\n-                        //\n-                        //            dst\n-                        // [. . . . . . o o o o . .]\n-                        //  2 2 3 3 3 H         1 1\n-                        let src_2 = src_before_wrap - dst_before_wrap;\n-                        let src_start_2 = src_start_1 + dst_before_wrap;\n-                        let src_3 = src_total - src_before_wrap;\n-\n-                        unsafe {\n-                            copy_part(src_start_1, dst_start_1, dst_before_wrap, src, dst);\n-                            copy_part(src_start_2, 0, src_2, src, dst);\n-                            copy_part(0, src_2, src_3, src, dst);\n-                        }\n-                        src_2 + src_3\n-                    } else {\n-                        //            src\n-                        // [o o . . . . . . . o o o]\n-                        //  2 2               1 1 1\n-                        //\n-                        //            dst\n-                        // [. . . . . . . o o . . .]\n-                        //  2 2 H             1 1 1\n-                        let src_2 = src_total - src_before_wrap;\n+                    // 1.\n+                    // other [. . . o o o . . . . . .]\n+                    //       []    [1 1 1]\n+                    //\n+                    // self  [. o o o o o . . . . . .]\n+                    //       [.]         [1 1 1 . . .]\n \n-                        unsafe {\n-                            copy_part(src_start_1, dst_start_1, src_before_wrap, src, dst);\n-                            copy_part(0, 0, src_2, src, dst);\n-                        }\n-                        src_2\n+                    unsafe {\n+                        copy_whole_slice(src_high, dst_high);\n                     }\n+                    original_head + src_total\n                 }\n-                (false, true) => {\n-                    //            src\n-                    // [. . . o o o o o . . . .]\n-                    //        1 1 2 2 2\n+                (true, false) => {\n+                    // 2.\n+                    // other [. . . o o o o o . . . .]\n+                    //       []    [1 1 2 2 2]\n                     //\n-                    //            dst\n-                    // [. . . . . . . o o o . .]\n-                    //  2 2 2 H             1 1\n-                    let dst_1 = dst_wrap_point - dst_start_1;\n-                    let src_start_2 = src_start_1 + dst_1;\n-                    let dst_2 = src_total - dst_1;\n+                    // self  [. . . . . . . o o o . .]\n+                    //       [2 2 2 . . . .]     [1 1]\n \n+                    let (src_1, src_2) = src_high.split_at(dst_high.len());\n                     unsafe {\n-                        copy_part(src_start_1, dst_start_1, dst_1, src, dst);\n-                        copy_part(src_start_2, 0, dst_2, src, dst);\n+                        copy_whole_slice(src_1, dst_high);\n+                        copy_whole_slice(src_2, dst_low);\n                     }\n-                    dst_2\n+                    src_total - dst_high.len()\n                 }\n-                (true, false) => {\n-                    //            src\n-                    // [o o . . . . . . . o o o]\n-                    //  2 2               1 1 1\n+                (false, true) => {\n+                    // 3.\n+                    // other [o o . . . . . . . o o o]\n+                    //       [2 2]             [1 1 1]\n                     //\n-                    //            dst\n-                    // [. o o . . . . . . . . .]\n-                    //        1 1 1 2 2 H\n-                    let src_1 = src_wrap_point - src_start_1;\n-                    let dst_start_2 = dst_start_1 + src_1;\n-                    let src_2 = src_total - src_1;\n+                    // self  [. o o . . . . . . . . .]\n+                    //       [.]   [1 1 1 2 2 . . . .]\n \n+                    let (dst_1, dst_2) = dst_high.split_at_mut(src_high.len());\n                     unsafe {\n-                        copy_part(src_start_1, dst_start_1, src_1, src, dst);\n-                        copy_part(0, dst_start_2, src_2, src, dst);\n+                        copy_whole_slice(src_high, dst_1);\n+                        copy_whole_slice(src_low, dst_2);\n                     }\n-                    dst_start_1 + src_1 + src_2\n+                    original_head + src_total\n                 }\n                 (false, false) => {\n-                    //            src\n-                    // [. . . o o o . . . . . .]\n-                    //        1 1 1\n-                    //\n-                    //            dst\n-                    // [. o o o o o . . . . . .]\n-                    //              1 1 1 H\n-                    unsafe {\n-                        copy_part(src_start_1, dst_start_1, src_total, src, dst);\n+                    if src_high.len() < dst_high.len() {\n+                        // 4.\n+                        // other [o o o . . . . . . o o o]\n+                        //       [2 3 3]           [1 1 1]\n+                        //\n+                        // self  [. . . . . . o o . . . .]\n+                        //       [3 3 . . . .]   [1 1 1 2]\n+\n+                        let (dst_1, dst_2) = dst_high.split_at_mut(src_high.len());\n+                        let (src_2, src_3) = src_low.split_at(dst_2.len());\n+                        unsafe {\n+                            copy_whole_slice(src_high, dst_1);\n+                            copy_whole_slice(src_2, dst_2);\n+                            copy_whole_slice(src_3, dst_low);\n+                        }\n+                        src_3.len()\n+                    } else if src_high.len() > dst_high.len() {\n+                        // 5.\n+                        // other [o o o . . . . . o o o o]\n+                        //       [3 3 3]         [1 1 2 2]\n+                        //\n+                        // self  [. . . . . . o o o o . .]\n+                        //       [2 2 3 3 3 .]       [1 1]\n+\n+                        let (src_1, src_2) = src_high.split_at(dst_high.len());\n+                        let (dst_2, dst_3) = dst_low.split_at_mut(src_2.len());\n+                        unsafe {\n+                            copy_whole_slice(src_1, dst_high);\n+                            copy_whole_slice(src_2, dst_2);\n+                            copy_whole_slice(src_low, dst_3);\n+                        }\n+                        dst_2.len() + src_low.len()\n+                    } else {\n+                        // 6.\n+                        // other [o o . . . . . . . o o o]\n+                        //       [2 2]             [1 1 1]\n+                        //\n+                        // self  [. . . . . . . o o . . .]\n+                        //       [2 2 . . . . .]   [1 1 1]\n+\n+                        unsafe {\n+                            copy_whole_slice(src_high, dst_high);\n+                            copy_whole_slice(src_low, dst_low);\n+                        }\n+                        src_low.len()\n                     }\n-                    dst_start_1 + src_total\n                 }\n             }\n         };\n+\n+        // Up until this point we are in a bad state as some values\n+        // exist in both `self` and `other`. To preserve panic safety\n+        // it is important we clear the old values from `other`...\n         other.clear();\n+        // and that we update `head` as the last step, making the values accessible in `self`.\n+        self.head = new_head;\n     }\n \n     /// Retains only the elements specified by the predicate."}]}