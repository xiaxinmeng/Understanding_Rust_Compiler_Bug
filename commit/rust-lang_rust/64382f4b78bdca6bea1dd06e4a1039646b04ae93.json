{"sha": "64382f4b78bdca6bea1dd06e4a1039646b04ae93", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MzgyZjRiNzhiZGNhNmJlYTFkZDA2ZTRhMTAzOTY0NmIwNGFlOTM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-03-07T01:44:28Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2019-03-21T21:49:42Z"}, "message": "Greatly improve generics handling in rustdoc search", "tree": {"sha": "a68023418fbcdfefffa2629b7111f0e86695f2fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a68023418fbcdfefffa2629b7111f0e86695f2fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64382f4b78bdca6bea1dd06e4a1039646b04ae93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64382f4b78bdca6bea1dd06e4a1039646b04ae93", "html_url": "https://github.com/rust-lang/rust/commit/64382f4b78bdca6bea1dd06e4a1039646b04ae93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64382f4b78bdca6bea1dd06e4a1039646b04ae93/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89573b3c8b629507130b1ec8beeaf550fdc0e046", "url": "https://api.github.com/repos/rust-lang/rust/commits/89573b3c8b629507130b1ec8beeaf550fdc0e046", "html_url": "https://github.com/rust-lang/rust/commit/89573b3c8b629507130b1ec8beeaf550fdc0e046"}], "stats": {"total": 295, "additions": 273, "deletions": 22}, "files": [{"sha": "e723ee1d10adc39f34d653794866214f43a32f91", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 53, "deletions": 7, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/64382f4b78bdca6bea1dd06e4a1039646b04ae93/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64382f4b78bdca6bea1dd06e4a1039646b04ae93/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=64382f4b78bdca6bea1dd06e4a1039646b04ae93", "patch": "@@ -1130,20 +1130,39 @@ fn report_assoc_ty_on_inherent_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span:\n }\n \n fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n+    checked_type_of(tcx, def_id, true).unwrap()\n+}\n+\n+pub fn checked_type_of<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    def_id: DefId,\n+    fail: bool,\n+) -> Option<Ty<'tcx>> {\n     use rustc::hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let hir_id = match tcx.hir().as_local_hir_id(def_id) {\n+        Some(hir_id) => hir_id,\n+        None => {\n+            if !fail {\n+                return None;\n+            }\n+            bug!(\"invalid node\");\n+        }\n+    };\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    match tcx.hir().get_by_hir_id(hir_id) {\n+    Some(match tcx.hir().get_by_hir_id(hir_id) {\n         Node::TraitItem(item) => match item.node {\n             TraitItemKind::Method(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n             }\n             TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n             TraitItemKind::Type(_, None) => {\n+                if !fail {\n+                    return None;\n+                }\n                 span_bug!(item.span, \"associated type missing default\");\n             }\n         },\n@@ -1225,6 +1244,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n                 | ItemKind::GlobalAsm(..)\n                 | ItemKind::ExternCrate(..)\n                 | ItemKind::Use(..) => {\n+                    if !fail {\n+                        return None;\n+                    }\n                     span_bug!(\n                         item.span,\n                         \"compute_type_of_item: unexpected item type: {:?}\",\n@@ -1264,7 +1286,7 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             ..\n         }) => {\n             if gen.is_some() {\n-                return tcx.typeck_tables_of(def_id).node_type(hir_id);\n+                return Some(tcx.typeck_tables_of(def_id).node_type(hir_id));\n             }\n \n             let substs = ty::ClosureSubsts {\n@@ -1342,6 +1364,9 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n                             }\n                             // Sanity check to make sure everything is as expected.\n                             if !found_const {\n+                                if !fail {\n+                                    return None;\n+                                }\n                                 bug!(\"no arg matching AnonConst in path\")\n                             }\n                             match path.def {\n@@ -1367,14 +1392,27 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n                                     return tcx.types.err;\n                                 }\n                                 Def::Err => tcx.types.err,\n-                                x => bug!(\"unexpected const parent path def {:?}\", x),\n+                                x => {\n+                                    if !fail {\n+                                        return None;\n+                                    }\n+                                    bug!(\"unexpected const parent path def {:?}\", x);\n+                                }\n+                            }\n+                        }\n+                        x => {\n+                            if !fail {\n+                                return None;\n                             }\n+                            bug!(\"unexpected const parent path {:?}\", x);\n                         }\n-                        x => bug!(\"unexpected const parent path {:?}\", x),\n                     }\n                 }\n \n                 x => {\n+                    if !fail {\n+                        return None;\n+                    }\n                     bug!(\"unexpected const parent in type_of_def_id(): {:?}\", x);\n                 }\n             }\n@@ -1385,13 +1423,21 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Ty<'tcx> {\n             hir::GenericParamKind::Const { ref ty, .. } => {\n                 icx.to_ty(ty)\n             }\n-            x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n+            x => {\n+                if !fail {\n+                    return None;\n+                }\n+                bug!(\"unexpected non-type Node::GenericParam: {:?}\", x)\n+            },\n         },\n \n         x => {\n+            if !fail {\n+                return None;\n+            }\n             bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n         }\n-    }\n+    })\n }\n \n fn find_existential_constraints<'a, 'tcx>("}, {"sha": "7bb381d92d836989141f998850aa1ce7ec749ffb", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64382f4b78bdca6bea1dd06e4a1039646b04ae93/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64382f4b78bdca6bea1dd06e4a1039646b04ae93/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=64382f4b78bdca6bea1dd06e4a1039646b04ae93", "patch": "@@ -115,6 +115,8 @@ use util::common::time;\n \n use std::iter;\n \n+pub use collect::checked_type_of;\n+\n pub struct TypeAndSubsts<'tcx> {\n     substs: SubstsRef<'tcx>,\n     ty: Ty<'tcx>,"}, {"sha": "2b45831f224fb2e1999053adcbadf315791822fd", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64382f4b78bdca6bea1dd06e4a1039646b04ae93/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64382f4b78bdca6bea1dd06e4a1039646b04ae93/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=64382f4b78bdca6bea1dd06e4a1039646b04ae93", "patch": "@@ -212,15 +212,19 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n     };\n \n     let predicates = cx.tcx.predicates_of(did);\n+    let generics = (cx.tcx.generics_of(did), &predicates).clean(cx);\n+    let decl = (did, sig).clean(cx);\n+    let all_types = clean::get_all_types(&generics, &decl, cx);\n     clean::Function {\n-        decl: (did, sig).clean(cx),\n-        generics: (cx.tcx.generics_of(did), &predicates).clean(cx),\n+        decl,\n+        generics,\n         header: hir::FnHeader {\n             unsafety: sig.unsafety(),\n             abi: sig.abi(),\n             constness,\n             asyncness: hir::IsAsync::NotAsync,\n-        }\n+        },\n+        all_types,\n     }\n }\n "}, {"sha": "5d691b1873b703b905a42ba87a7d363fd6974228", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 203, "deletions": 7, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/64382f4b78bdca6bea1dd06e4a1039646b04ae93/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64382f4b78bdca6bea1dd06e4a1039646b04ae93/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=64382f4b78bdca6bea1dd06e4a1039646b04ae93", "patch": "@@ -1084,9 +1084,10 @@ impl GenericBound {\n \n     fn get_trait_type(&self) -> Option<Type> {\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, _) = *self {\n-            return Some(trait_.clone());\n+            Some(trait_.clone())\n+        } else {\n+            None\n         }\n-        None\n     }\n }\n \n@@ -1319,6 +1320,16 @@ pub enum WherePredicate {\n     EqPredicate { lhs: Type, rhs: Type },\n }\n \n+impl WherePredicate {\n+    pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n+        match *self {\n+            WherePredicate::BoundPredicate { ref bounds, .. } => Some(bounds),\n+            WherePredicate::RegionPredicate { ref bounds, .. } => Some(bounds),\n+            _ => None,\n+        }\n+    }\n+}\n+\n impl Clean<WherePredicate> for hir::WherePredicate {\n     fn clean(&self, cx: &DocContext<'_>) -> WherePredicate {\n         match *self {\n@@ -1455,6 +1466,25 @@ pub enum GenericParamDefKind {\n     },\n }\n \n+impl GenericParamDefKind {\n+    pub fn is_type(&self) -> bool {\n+        match *self {\n+            GenericParamDefKind::Type { .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn get_type(&self, cx: &DocContext<'_, '_, '_>) -> Option<Type> {\n+        match *self {\n+            GenericParamDefKind::Type { did, .. } => {\n+                rustc_typeck::checked_type_of(cx.tcx, did, false).map(|t| t.clean(cx))\n+            }\n+            GenericParamDefKind::Const { ref ty, .. } => Some(ty.clone()),\n+            GenericParamDefKind::Lifetime => None,\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Debug, Hash)]\n pub struct GenericParamDef {\n     pub name: String,\n@@ -1466,12 +1496,25 @@ impl GenericParamDef {\n     pub fn is_synthetic_type_param(&self) -> bool {\n         match self.kind {\n             GenericParamDefKind::Lifetime |\n-            GenericParamDefKind::Const { .. } => {\n-                false\n-            }\n+            GenericParamDefKind::Const { .. } => false,\n             GenericParamDefKind::Type { ref synthetic, .. } => synthetic.is_some(),\n         }\n     }\n+\n+    pub fn is_type(&self) -> bool {\n+        self.kind.is_type()\n+    }\n+\n+    pub fn get_type(&self, cx: &DocContext<'_, '_, '_>) -> Option<Type> {\n+        self.kind.get_type(cx)\n+    }\n+\n+    pub fn get_bounds(&self) -> Option<&[GenericBound]> {\n+        match self.kind {\n+            GenericParamDefKind::Type { ref bounds, .. } => Some(bounds),\n+            _ => None,\n+        }\n+    }\n }\n \n impl<'tcx> Clean<GenericParamDef> for ty::GenericParamDef {\n@@ -1707,12 +1750,145 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics,\n     }\n }\n \n+// The point is to replace bounds with types.\n+pub fn get_real_types(\n+    generics: &Generics,\n+    arg: &Type,\n+    cx: &DocContext<'_, '_, '_>,\n+    debug: bool,\n+) -> Option<Vec<Type>> {\n+    let mut res = Vec::new();\n+    if arg.to_string() == \"W\" || arg.to_string() == \"Z\" || debug {\n+        println!(\"0. {:?}\", arg);\n+    }\n+    if let Some(where_pred) = generics.where_predicates.iter().find(|g| {\n+        match g {\n+            &WherePredicate::BoundPredicate { ref ty, .. } => ty.def_id() == arg.def_id(),\n+            _ => false,\n+        }\n+    }) {\n+        if arg.to_string() == \"W\" || arg.to_string() == \"Z\" || debug {\n+            println!(\"1. {:?} => {:?}\", arg, where_pred);\n+        }\n+        let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n+        for bound in bounds.iter() {\n+            match *bound {\n+                GenericBound::TraitBound(ref poly_trait, _) => {\n+                    if arg.to_string() == \"W\" || arg.to_string() == \"Z\" || debug {\n+                        println!(\"    {:?}\", poly_trait.trait_);\n+                    }\n+                    for x in poly_trait.generic_params.iter() {\n+                        if !x.is_type() {\n+                            continue\n+                        }\n+                        if let Some(ty) = x.get_type(cx) {\n+                            if let Some(mut adds) = get_real_types(generics, &ty, cx,\n+                                arg.to_string() == \"W\" || arg.to_string() == \"Z\" || debug) {\n+                                res.append(&mut adds);\n+                            } else if !ty.is_full_generic() {\n+                                res.push(ty);\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+    } else {\n+        let arg_s = arg.to_string();\n+        if let Some(bound) = generics.params.iter().find(|g| {\n+            g.is_type() && g.name == arg_s\n+        }) {\n+            if arg.to_string() == \"W\" || arg.to_string() == \"Z\" || debug {\n+                println!(\"2. {:?} => {:?}\", arg, bound);\n+            }\n+            for bound in bound.get_bounds().unwrap_or_else(|| &[]) {\n+                if let Some(ty) = bound.get_trait_type() {\n+                    if let Some(mut adds) = get_real_types(generics, &ty, cx,\n+                        arg.to_string() == \"W\" || arg.to_string() == \"Z\" || debug) {\n+                        if arg.to_string() == \"W\" || arg.to_string() == \"Z\" || debug {\n+                            println!(\"3. {:?}\", adds);\n+                        }\n+                        res.append(&mut adds);\n+                    } else {\n+                        if arg.to_string() == \"W\" || arg.to_string() == \"Z\" || debug {\n+                            println!(\"4. {:?}\", ty);\n+                        }\n+                        if !ty.is_full_generic() {\n+                            res.push(ty.clone());\n+                        }\n+                    }\n+                }\n+            }\n+            /*if let Some(ty) = bound.get_type(cx) {\n+                if let Some(mut adds) = get_real_types(generics, &ty, cx, level + 1) {\n+                    res.append(&mut adds);\n+                } else {\n+                    res.push(ty);\n+                }\n+            } else {\n+                res.push(arg.clone());\n+            }*/\n+        } else if let Some(gens) = arg.generics() {\n+            res.push(arg.clone());\n+            for gen in gens.iter() {\n+                if gen.is_full_generic() {\n+                    if let Some(mut adds) = get_real_types(generics, gen, cx,\n+                        arg.to_string() == \"W\" || arg.to_string() == \"Z\" || debug) {\n+                        if arg.to_string() == \"W\" || arg.to_string() == \"Z\" || debug {\n+                            println!(\"5. {:?}\", adds);\n+                        }\n+                        res.append(&mut adds);\n+                    }\n+                } else {\n+                    if arg.to_string() == \"W\" || arg.to_string() == \"Z\" || debug {\n+                        println!(\"6. {:?}\", gen);\n+                    }\n+                    res.push(gen.clone());\n+                }\n+            }\n+        }\n+    }\n+    if res.is_empty() && !arg.is_full_generic() {\n+        res.push(arg.clone());\n+    }\n+    if arg.to_string() == \"W\" || arg.to_string() == \"Z\" || debug {\n+        println!(\"7. /!\\\\ {:?}\", res);\n+    }\n+    Some(res)\n+}\n+\n+pub fn get_all_types(\n+    generics: &Generics,\n+    decl: &FnDecl,\n+    cx: &DocContext<'_, '_, '_>,\n+) -> Vec<Type> {\n+    let mut all_types = Vec::new();\n+    for arg in decl.inputs.values.iter() {\n+        if arg.type_.is_self_type() {\n+            continue;\n+        }\n+        if let Some(mut args) = get_real_types(generics, &arg.type_, cx, false) {\n+            all_types.append(&mut args);\n+        } else {\n+            all_types.push(arg.type_.clone());\n+        }\n+    }\n+    all_types.sort_unstable_by(|a, b| a.to_string().partial_cmp(&b.to_string()).expect(\"a\") );\n+    all_types.dedup();\n+    if decl.inputs.values.iter().any(|s| s.type_.to_string() == \"W\" || s.type_.to_string() == \"Z\") {\n+        println!(\"||||> {:?}\", all_types);\n+    }\n+    all_types\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Method {\n     pub generics: Generics,\n     pub decl: FnDecl,\n     pub header: hir::FnHeader,\n     pub defaultness: Option<hir::Defaultness>,\n+    pub all_types: Vec<Type>,\n }\n \n impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId,\n@@ -1721,11 +1897,13 @@ impl<'a> Clean<Method> for (&'a hir::MethodSig, &'a hir::Generics, hir::BodyId,\n         let (generics, decl) = enter_impl_trait(cx, || {\n             (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx))\n         });\n+        let all_types = get_all_types(&generics, &decl, cx);\n         Method {\n             decl,\n             generics,\n             header: self.0.header,\n             defaultness: self.3,\n+            all_types,\n         }\n     }\n }\n@@ -1735,13 +1913,15 @@ pub struct TyMethod {\n     pub header: hir::FnHeader,\n     pub decl: FnDecl,\n     pub generics: Generics,\n+    pub all_types: Vec<Type>,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Function {\n     pub decl: FnDecl,\n     pub generics: Generics,\n     pub header: hir::FnHeader,\n+    pub all_types: Vec<Type>,\n }\n \n impl Clean<Item> for doctree::Function {\n@@ -1756,6 +1936,7 @@ impl Clean<Item> for doctree::Function {\n         } else {\n             hir::Constness::NotConst\n         };\n+        let all_types = get_all_types(&generics, &decl, cx);\n         Item {\n             name: Some(self.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n@@ -1768,6 +1949,7 @@ impl Clean<Item> for doctree::Function {\n                 decl,\n                 generics,\n                 header: hir::FnHeader { constness, ..self.header },\n+                all_types,\n             }),\n         }\n     }\n@@ -1855,7 +2037,7 @@ impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl, A)\n         FnDecl {\n             inputs: (&self.0.inputs[..], self.1).clean(cx),\n             output: self.0.output.clean(cx),\n-            attrs: Attributes::default()\n+            attrs: Attributes::default(),\n         }\n     }\n }\n@@ -2037,10 +2219,12 @@ impl Clean<Item> for hir::TraitItem {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n                     (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n                 });\n+                let all_types = get_all_types(&generics, &decl, cx);\n                 TyMethodItem(TyMethod {\n                     header: sig.header,\n                     decl,\n                     generics,\n+                    all_types,\n                 })\n             }\n             hir::TraitItemKind::Type(ref bounds, ref default) => {\n@@ -2138,6 +2322,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     ty::ImplContainer(_) => true,\n                     ty::TraitContainer(_) => self.defaultness.has_value()\n                 };\n+                let all_types = get_all_types(&generics, &decl, cx);\n                 if provided {\n                     let constness = if cx.tcx.is_min_const_fn(self.def_id) {\n                         hir::Constness::Const\n@@ -2154,6 +2339,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                             asyncness: hir::IsAsync::NotAsync,\n                         },\n                         defaultness: Some(self.defaultness),\n+                        all_types,\n                     })\n                 } else {\n                     TyMethodItem(TyMethod {\n@@ -2164,7 +2350,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                             abi: sig.abi(),\n                             constness: hir::Constness::NotConst,\n                             asyncness: hir::IsAsync::NotAsync,\n-                        }\n+                        },\n+                        all_types,\n                     })\n                 }\n             }\n@@ -2410,6 +2597,13 @@ impl Type {\n             _ => None\n         }\n     }\n+\n+    pub fn is_full_generic(&self) -> bool {\n+        match *self {\n+            Type::Generic(_) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n impl GetDefId for Type {\n@@ -3824,6 +4018,7 @@ impl Clean<Item> for hir::ForeignItem {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n                     (generics.clean(cx), (&**decl, &names[..]).clean(cx))\n                 });\n+                let all_types = get_all_types(&generics, &decl, cx);\n                 ForeignFunctionItem(Function {\n                     decl,\n                     generics,\n@@ -3833,6 +4028,7 @@ impl Clean<Item> for hir::ForeignItem {\n                         constness: hir::Constness::NotConst,\n                         asyncness: hir::IsAsync::NotAsync,\n                     },\n+                    all_types,\n                 })\n             }\n             hir::ForeignItemKind::Static(ref ty, mutbl) => {"}, {"sha": "402eb1800829c3d24090420912e2fc5b4ed79595", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/64382f4b78bdca6bea1dd06e4a1039646b04ae93/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64382f4b78bdca6bea1dd06e4a1039646b04ae93/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=64382f4b78bdca6bea1dd06e4a1039646b04ae93", "patch": "@@ -5025,14 +5025,17 @@ fn make_item_keywords(it: &clean::Item) -> String {\n }\n \n fn get_index_search_type(item: &clean::Item) -> Option<IndexItemFunctionType> {\n-    let decl = match item.inner {\n-        clean::FunctionItem(ref f) => &f.decl,\n-        clean::MethodItem(ref m) => &m.decl,\n-        clean::TyMethodItem(ref m) => &m.decl,\n+    let (decl, all_types) = match item.inner {\n+        clean::FunctionItem(ref f) => (&f.decl, &f.all_types),\n+        clean::MethodItem(ref m) => (&m.decl, &m.all_types),\n+        clean::TyMethodItem(ref m) => (&m.decl, &m.all_types),\n         _ => return None\n     };\n \n-    let inputs = decl.inputs.values.iter().map(|arg| get_index_type(&arg.type_)).collect();\n+    println!(\"====> {:?}\", all_types);\n+    let inputs = all_types.iter().map(|arg| {\n+        get_index_type(&arg)\n+    }).collect();\n     let output = match decl.output {\n         clean::FunctionRetTy::Return(ref return_type) => Some(get_index_type(return_type)),\n         _ => None"}]}