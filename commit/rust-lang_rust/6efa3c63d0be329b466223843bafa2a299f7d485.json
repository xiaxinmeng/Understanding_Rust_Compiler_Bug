{"sha": "6efa3c63d0be329b466223843bafa2a299f7d485", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlZmEzYzYzZDBiZTMyOWI0NjYyMjM4NDNiYWZhMmEyOTlmN2Q0ODU=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-02-22T19:41:38Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-02-25T08:52:51Z"}, "message": "Remove std::bool::{Bool, all_values}\n\nThese were never used outside of the tests", "tree": {"sha": "b40b2aba36127a8bd85bc54b4a6ce7bbca4cf6a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b40b2aba36127a8bd85bc54b4a6ce7bbca4cf6a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6efa3c63d0be329b466223843bafa2a299f7d485", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6efa3c63d0be329b466223843bafa2a299f7d485", "html_url": "https://github.com/rust-lang/rust/commit/6efa3c63d0be329b466223843bafa2a299f7d485", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6efa3c63d0be329b466223843bafa2a299f7d485/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4243cad56bbd266872770218873900da22fed5ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/4243cad56bbd266872770218873900da22fed5ea", "html_url": "https://github.com/rust-lang/rust/commit/4243cad56bbd266872770218873900da22fed5ea"}], "stats": {"total": 205, "additions": 43, "deletions": 162}, "files": [{"sha": "f0835fe11024149845aeb396fae42c4f54f05e25", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 43, "deletions": 161, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/6efa3c63d0be329b466223843bafa2a299f7d485/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efa3c63d0be329b466223843bafa2a299f7d485/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=6efa3c63d0be329b466223843bafa2a299f7d485", "patch": "@@ -12,8 +12,6 @@\n //!\n //! A quick summary:\n //!\n-//! ## Trait implementations for `bool`\n-//!\n //! Implementations of the following traits:\n //!\n //! * `FromStr`\n@@ -24,16 +22,11 @@\n //! * `Default`\n //! * `Zero`\n //!\n-//! ## Various functions to compare `bool`s\n-//!\n-//! All of the standard comparison functions one would expect: `and`, `eq`, `or`,\n-//! and more.\n-//!\n-//! Also, a few conversion functions: `to_bit` and `to_str`.\n+//! A `to_bit` conversion function.\n \n-use option::{None, Option, Some};\n use from_str::FromStr;\n-use num::FromPrimitive;\n+use num::{Int, one, zero};\n+use option::{None, Option, Some};\n \n #[cfg(not(test))] use cmp::{Eq, Ord, TotalOrd, Ordering};\n #[cfg(not(test))] use ops::{Not, BitAnd, BitOr, BitXor};\n@@ -43,112 +36,19 @@ use num::FromPrimitive;\n // Freestanding functions\n /////////////////////////////////////////////////////////////////////////////\n \n-/// Iterates over all truth values, passing them to the given block.\n-///\n-/// There are no guarantees about the order values will be given.\n+/// Convert a `bool` to an integer.\n ///\n /// # Examples\n ///\n-/// ```\n-/// std::bool::all_values(|x: bool| {\n-///     println!(\"{}\", x);\n-/// })\n+/// ```rust\n+/// use std::bool;\n+///\n+/// assert_eq!(bool::to_bit::<u8>(true), 1u8);\n+/// assert_eq!(bool::to_bit::<u8>(false), 0u8);\n /// ```\n #[inline]\n-pub fn all_values(blk: |v: bool|) {\n-    blk(true);\n-    blk(false);\n-}\n-\n-/////////////////////////////////////////////////////////////////////////////\n-// Methods on `bool`\n-/////////////////////////////////////////////////////////////////////////////\n-\n-/// Extension methods on a `bool`\n-pub trait Bool {\n-    /// Conjunction of two boolean values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(true.and(true), true);\n-    /// assert_eq!(true.and(false), false);\n-    /// assert_eq!(false.and(true), false);\n-    /// assert_eq!(false.and(false), false);\n-    /// ```\n-    fn and(self, b: bool) -> bool;\n-\n-    /// Disjunction of two boolean values.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(true.or(true), true);\n-    /// assert_eq!(true.or(false), true);\n-    /// assert_eq!(false.or(true), true);\n-    /// assert_eq!(false.or(false), false);\n-    /// ```\n-    fn or(self, b: bool) -> bool;\n-\n-    /// An 'exclusive or' of two boolean values.\n-    ///\n-    /// 'exclusive or' is identical to `or(and(a, not(b)), and(not(a), b))`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(true.xor(true), false);\n-    /// assert_eq!(true.xor(false), true);\n-    /// assert_eq!(false.xor(true), true);\n-    /// assert_eq!(false.xor(false), false);\n-    /// ```\n-    fn xor(self, b: bool) -> bool;\n-\n-    /// Implication between two boolean values.\n-    ///\n-    /// Implication is often phrased as 'if a then b.'\n-    ///\n-    /// 'if a then b' is equivalent to `!a || b`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(true.implies(true), true);\n-    /// assert_eq!(true.implies(false), false);\n-    /// assert_eq!(false.implies(true), true);\n-    /// assert_eq!(false.implies(false), true);\n-    /// ```\n-    fn implies(self, b: bool) -> bool;\n-\n-    /// Convert a `bool` to a `u8`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```rust\n-    /// assert_eq!(true.to_bit::<u8>(), 1u8);\n-    /// assert_eq!(false.to_bit::<u8>(), 0u8);\n-    /// ```\n-    fn to_bit<N: FromPrimitive>(self) -> N;\n-}\n-\n-impl Bool for bool {\n-    #[inline]\n-    fn and(self, b: bool) -> bool { self && b }\n-\n-    #[inline]\n-    fn or(self, b: bool) -> bool { self || b }\n-\n-    #[inline]\n-    fn xor(self, b: bool) -> bool { self ^ b }\n-\n-    #[inline]\n-    fn implies(self, b: bool) -> bool { !self || b }\n-\n-    #[inline]\n-    fn to_bit<N: FromPrimitive>(self) -> N {\n-        if self { FromPrimitive::from_u8(1).unwrap() }\n-        else    { FromPrimitive::from_u8(0).unwrap() }\n-    }\n+pub fn to_bit<N: Int>(p: bool) -> N {\n+    if p { one() } else { zero() }\n }\n \n /////////////////////////////////////////////////////////////////////////////\n@@ -259,13 +159,17 @@ impl BitXor<bool, bool> for bool {\n #[cfg(not(test))]\n impl Ord for bool {\n     #[inline]\n-    fn lt(&self, other: &bool) -> bool { self.to_bit::<u8>() < other.to_bit() }\n+    fn lt(&self, other: &bool) -> bool {\n+        to_bit::<u8>(*self) < to_bit(*other)\n+    }\n }\n \n #[cfg(not(test))]\n impl TotalOrd for bool {\n     #[inline]\n-    fn cmp(&self, other: &bool) -> Ordering { self.to_bit::<u8>().cmp(&other.to_bit()) }\n+    fn cmp(&self, other: &bool) -> Ordering {\n+        to_bit::<u8>(*self).cmp(&to_bit(*other))\n+    }\n }\n \n /// Equality between two boolean values.\n@@ -294,16 +198,24 @@ impl Default for bool {\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n-    use super::all_values;\n-    use from_str::FromStr;\n+    use super::to_bit;\n \n     #[test]\n-    fn test_bool() {\n+    fn test_to_bit() {\n+        assert_eq!(to_bit::<u8>(true), 1u8);\n+        assert_eq!(to_bit::<u8>(false), 0u8);\n+    }\n+\n+    #[test]\n+    fn test_eq() {\n         assert_eq!(false.eq(&true), false);\n         assert_eq!(false == false, true);\n         assert_eq!(false != true, true);\n         assert_eq!(false.ne(&false), false);\n+    }\n \n+    #[test]\n+    fn test_bitand() {\n         assert_eq!(false.bitand(&false), false);\n         assert_eq!(true.bitand(&false), false);\n         assert_eq!(false.bitand(&true), false);\n@@ -313,7 +225,10 @@ mod tests {\n         assert_eq!(true & false, false);\n         assert_eq!(false & true, false);\n         assert_eq!(true & true, true);\n+    }\n \n+    #[test]\n+    fn test_bitor() {\n         assert_eq!(false.bitor(&false), false);\n         assert_eq!(true.bitor(&false), true);\n         assert_eq!(false.bitor(&true), true);\n@@ -323,7 +238,10 @@ mod tests {\n         assert_eq!(true | false, true);\n         assert_eq!(false | true, true);\n         assert_eq!(true | true, true);\n+    }\n \n+    #[test]\n+    fn test_bitxor() {\n         assert_eq!(false.bitxor(&false), false);\n         assert_eq!(true.bitxor(&false), true);\n         assert_eq!(false.bitxor(&true), true);\n@@ -333,65 +251,29 @@ mod tests {\n         assert_eq!(true ^ false, true);\n         assert_eq!(false ^ true, true);\n         assert_eq!(true ^ true, false);\n+    }\n \n+    #[test]\n+    fn test_not() {\n         assert_eq!(!true, false);\n         assert_eq!(!false, true);\n+    }\n \n-        assert_eq!(true.to_str(), ~\"true\");\n-        assert_eq!(false.to_str(), ~\"false\");\n-\n+    #[test]\n+    fn test_from_str() {\n         assert_eq!(from_str::<bool>(\"true\"), Some(true));\n         assert_eq!(from_str::<bool>(\"false\"), Some(false));\n         assert_eq!(from_str::<bool>(\"not even a boolean\"), None);\n-\n-        assert_eq!(true.and(true), true);\n-        assert_eq!(true.and(false), false);\n-        assert_eq!(false.and(true), false);\n-        assert_eq!(false.and(false), false);\n-\n-        assert_eq!(true.or(true), true);\n-        assert_eq!(true.or(false), true);\n-        assert_eq!(false.or(true), true);\n-        assert_eq!(false.or(false), false);\n-\n-        assert_eq!(true.xor(true), false);\n-        assert_eq!(true.xor(false), true);\n-        assert_eq!(false.xor(true), true);\n-        assert_eq!(false.xor(false), false);\n-\n-        assert_eq!(true.implies(true), true);\n-        assert_eq!(true.implies(false), false);\n-        assert_eq!(false.implies(true), true);\n-        assert_eq!(false.implies(false), true);\n-\n-        assert_eq!(true.to_bit::<u8>(), 1u8);\n-        assert_eq!(false.to_bit::<u8>(), 0u8);\n     }\n \n     #[test]\n-    fn test_bool_from_str() {\n-        all_values(|v| {\n-            assert!(Some(v) == FromStr::from_str(v.to_str()))\n-        });\n-    }\n-\n-    #[test]\n-    fn test_bool_to_str() {\n+    fn test_to_str() {\n         assert_eq!(false.to_str(), ~\"false\");\n         assert_eq!(true.to_str(), ~\"true\");\n     }\n \n     #[test]\n-    fn test_bool_to_bit() {\n-        all_values(|v| {\n-            assert_eq!(v.to_bit::<u8>(), if v { 1u8 } else { 0u8 });\n-            assert_eq!(v.to_bit::<uint>(), if v { 1u } else { 0u });\n-            assert_eq!(v.to_bit::<int>(), if v { 1i } else { 0i });\n-        });\n-    }\n-\n-    #[test]\n-    fn test_bool_ord() {\n+    fn test_ord() {\n         assert!(true > false);\n         assert!(!(false > true));\n \n@@ -410,7 +292,7 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_bool_totalord() {\n+    fn test_totalord() {\n         assert_eq!(true.cmp(&true), Equal);\n         assert_eq!(false.cmp(&false), Equal);\n         assert_eq!(true.cmp(&false), Greater);"}, {"sha": "5ea00c2f67d64df73f8623949d07c5a4425e0dfc", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6efa3c63d0be329b466223843bafa2a299f7d485/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6efa3c63d0be329b466223843bafa2a299f7d485/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=6efa3c63d0be329b466223843bafa2a299f7d485", "patch": "@@ -37,7 +37,6 @@ pub use mem::drop;\n \n pub use any::{Any, AnyOwnExt, AnyRefExt, AnyMutRefExt};\n pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, IntoBytes};\n-pub use bool::Bool;\n pub use c_str::ToCStr;\n pub use char::Char;\n pub use clone::{Clone, DeepClone};"}]}