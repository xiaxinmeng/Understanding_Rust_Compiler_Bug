{"sha": "2b17da60db5e604288c26ed2b89ef72e45a3f596", "node_id": "C_kwDOAAsO6NoAKDJiMTdkYTYwZGI1ZTYwNDI4OGMyNmVkMmI4OWVmNzJlNDVhM2Y1OTY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-04T20:45:47Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-10-04T20:53:02Z"}, "message": "Resolve macros in snippet require items", "tree": {"sha": "acb9c198c909a85784fb25746f949f61b0f8681b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/acb9c198c909a85784fb25746f949f61b0f8681b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b17da60db5e604288c26ed2b89ef72e45a3f596", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b17da60db5e604288c26ed2b89ef72e45a3f596", "html_url": "https://github.com/rust-lang/rust/commit/2b17da60db5e604288c26ed2b89ef72e45a3f596", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b17da60db5e604288c26ed2b89ef72e45a3f596/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca1fdd75f15b2c47962d123aebbe0e235cf1b43b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca1fdd75f15b2c47962d123aebbe0e235cf1b43b", "html_url": "https://github.com/rust-lang/rust/commit/ca1fdd75f15b2c47962d123aebbe0e235cf1b43b"}], "stats": {"total": 103, "additions": 49, "deletions": 54}, "files": [{"sha": "a640b7d0738f1dcb80c268d48e0d2399085f1198", "filename": "crates/ide_completion/src/completions/postfix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b17da60db5e604288c26ed2b89ef72e45a3f596/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b17da60db5e604288c26ed2b89ef72e45a3f596/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=2b17da60db5e604288c26ed2b89ef72e45a3f596", "patch": "@@ -232,8 +232,8 @@ fn add_custom_postfix_completions(\n         ImportScope::find_insert_use_container_with_macros(&ctx.token.parent()?, &ctx.sema)?;\n     ctx.config.postfix_snippets.iter().for_each(|snippet| {\n         let imports = match snippet.imports(ctx, &import_scope) {\n-            Ok(imports) => imports,\n-            Err(_) => return,\n+            Some(imports) => imports,\n+            None => return,\n         };\n         let mut builder = postfix_snippet(\n             &snippet.label,"}, {"sha": "3824bf8a9a0345241fea6040679b5f018c406e1d", "filename": "crates/ide_completion/src/completions/snippet.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b17da60db5e604288c26ed2b89ef72e45a3f596/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b17da60db5e604288c26ed2b89ef72e45a3f596/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=2b17da60db5e604288c26ed2b89ef72e45a3f596", "patch": "@@ -105,8 +105,8 @@ fn add_custom_completions(\n         ImportScope::find_insert_use_container_with_macros(&ctx.token.parent()?, &ctx.sema)?;\n     ctx.config.snippets.iter().filter(|snip| snip.scope == scope).for_each(|snip| {\n         let imports = match snip.imports(ctx, &import_scope) {\n-            Ok(imports) => imports,\n-            Err(_) => return,\n+            Some(imports) => imports,\n+            None => return,\n         };\n         let mut builder = snippet(ctx, cap, &snip.label, &snip.snippet);\n         for import in imports.into_iter() {"}, {"sha": "b7dd1b3297e39225bc34beb0dbfc43470c5a6865", "filename": "crates/ide_completion/src/snippet.rs", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/2b17da60db5e604288c26ed2b89ef72e45a3f596/crates%2Fide_completion%2Fsrc%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b17da60db5e604288c26ed2b89ef72e45a3f596/crates%2Fide_completion%2Fsrc%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fsnippet.rs?ref=2b17da60db5e604288c26ed2b89ef72e45a3f596", "patch": "@@ -37,7 +37,6 @@ pub struct Snippet {\n     pub description: Option<String>,\n     pub requires: Box<[String]>,\n }\n-\n impl Snippet {\n     pub fn new(\n         label: String,\n@@ -46,19 +45,7 @@ impl Snippet {\n         requires: &[String],\n         scope: SnippetScope,\n     ) -> Option<Self> {\n-        // validate that these are indeed simple paths\n-        if requires.iter().any(|path| match ast::Path::parse(path) {\n-            Ok(path) => path.segments().any(|seg| {\n-                !matches!(seg.kind(), Some(ast::PathSegmentKind::Name(_)))\n-                    || seg.generic_arg_list().is_some()\n-            }),\n-            Err(_) => true,\n-        }) {\n-            return None;\n-        }\n-        let snippet = snippet.iter().join(\"\\n\");\n-        let description = description.iter().join(\"\\n\");\n-        let description = if description.is_empty() { None } else { Some(description) };\n+        let (snippet, description) = validate_snippet(snippet, description, requires)?;\n         Some(Snippet {\n             scope,\n             label,\n@@ -68,12 +55,12 @@ impl Snippet {\n         })\n     }\n \n-    // FIXME: This shouldn't be fallible\n+    /// Returns None if the required items do not resolve.\n     pub(crate) fn imports(\n         &self,\n         ctx: &CompletionContext,\n         import_scope: &ImportScope,\n-    ) -> Result<Vec<ImportEdit>, ()> {\n+    ) -> Option<Vec<ImportEdit>> {\n         import_edits(ctx, import_scope, &self.requires)\n     }\n \n@@ -94,19 +81,7 @@ impl PostfixSnippet {\n         requires: &[String],\n         scope: PostfixSnippetScope,\n     ) -> Option<Self> {\n-        // validate that these are indeed simple paths\n-        if requires.iter().any(|path| match ast::Path::parse(path) {\n-            Ok(path) => path.segments().any(|seg| {\n-                !matches!(seg.kind(), Some(ast::PathSegmentKind::Name(_)))\n-                    || seg.generic_arg_list().is_some()\n-            }),\n-            Err(_) => true,\n-        }) {\n-            return None;\n-        }\n-        let snippet = snippet.iter().join(\"\\n\");\n-        let description = description.iter().join(\"\\n\");\n-        let description = if description.is_empty() { None } else { Some(description) };\n+        let (snippet, description) = validate_snippet(snippet, description, requires)?;\n         Some(PostfixSnippet {\n             scope,\n             label,\n@@ -116,12 +91,12 @@ impl PostfixSnippet {\n         })\n     }\n \n-    // FIXME: This shouldn't be fallible\n+    /// Returns None if the required items do not resolve.\n     pub(crate) fn imports(\n         &self,\n         ctx: &CompletionContext,\n         import_scope: &ImportScope,\n-    ) -> Result<Vec<ImportEdit>, ()> {\n+    ) -> Option<Vec<ImportEdit>> {\n         import_edits(ctx, import_scope, &self.requires)\n     }\n \n@@ -142,32 +117,52 @@ fn import_edits(\n     ctx: &CompletionContext,\n     import_scope: &ImportScope,\n     requires: &[String],\n-) -> Result<Vec<ImportEdit>, ()> {\n+) -> Option<Vec<ImportEdit>> {\n     let resolve = |import| {\n         let path = ast::Path::parse(import).ok()?;\n-        match ctx.scope.speculative_resolve(&path)? {\n-            hir::PathResolution::Macro(_) => None,\n-            hir::PathResolution::Def(def) => {\n-                let item = def.into();\n-                let path = ctx.scope.module()?.find_use_path_prefixed(\n-                    ctx.db,\n-                    item,\n-                    ctx.config.insert_use.prefix_kind,\n-                )?;\n-                Some((path.len() > 1).then(|| ImportEdit {\n-                    import: LocatedImport::new(path.clone(), item, item, None),\n-                    scope: import_scope.clone(),\n-                }))\n-            }\n-            _ => None,\n-        }\n+        let item = match ctx.scope.speculative_resolve(&path)? {\n+            hir::PathResolution::Macro(mac) => mac.into(),\n+            hir::PathResolution::Def(def) => def.into(),\n+            _ => return None,\n+        };\n+        let path = ctx.scope.module()?.find_use_path_prefixed(\n+            ctx.db,\n+            item,\n+            ctx.config.insert_use.prefix_kind,\n+        )?;\n+        Some((path.len() > 1).then(|| ImportEdit {\n+            import: LocatedImport::new(path.clone(), item, item, None),\n+            scope: import_scope.clone(),\n+        }))\n     };\n     let mut res = Vec::with_capacity(requires.len());\n     for import in requires {\n         match resolve(import) {\n             Some(first) => res.extend(first),\n-            None => return Err(()),\n+            None => return None,\n         }\n     }\n-    Ok(res)\n+    Some(res)\n+}\n+\n+fn validate_snippet(\n+    snippet: &[String],\n+    description: &[String],\n+    requires: &[String],\n+) -> Option<(String, Option<String>)> {\n+    // validate that these are indeed simple paths\n+    // we can't save the paths unfortunately due to them not being Send+Sync\n+    if requires.iter().any(|path| match ast::Path::parse(path) {\n+        Ok(path) => path.segments().any(|seg| {\n+            !matches!(seg.kind(), Some(ast::PathSegmentKind::Name(_)))\n+                || seg.generic_arg_list().is_some()\n+        }),\n+        Err(_) => true,\n+    }) {\n+        return None;\n+    }\n+    let snippet = snippet.iter().join(\"\\n\");\n+    let description = description.iter().join(\"\\n\");\n+    let description = if description.is_empty() { None } else { Some(description) };\n+    Some((snippet, description))\n }"}]}