{"sha": "4d79d391b0aa1175f493e3544d8f66e6600fbfc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkNzlkMzkxYjBhYTExNzVmNDkzZTM1NDRkOGY2NmU2NjAwZmJmYzY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-08T11:28:51Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-08T11:40:43Z"}, "message": "avoid reading from ZST locals", "tree": {"sha": "07d52865523f6a5db20c44e8213e352376ac769e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07d52865523f6a5db20c44e8213e352376ac769e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d79d391b0aa1175f493e3544d8f66e6600fbfc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d79d391b0aa1175f493e3544d8f66e6600fbfc6", "html_url": "https://github.com/rust-lang/rust/commit/4d79d391b0aa1175f493e3544d8f66e6600fbfc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d79d391b0aa1175f493e3544d8f66e6600fbfc6/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5731945187785e87352cf112380fad685db89636", "url": "https://api.github.com/repos/rust-lang/rust/commits/5731945187785e87352cf112380fad685db89636", "html_url": "https://github.com/rust-lang/rust/commit/5731945187785e87352cf112380fad685db89636"}], "stats": {"total": 85, "additions": 29, "deletions": 56}, "files": [{"sha": "32f7ecd97b2ef13caa44d56d680c400233d4f2ce", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 19, "deletions": 51, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4d79d391b0aa1175f493e3544d8f66e6600fbfc6/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d79d391b0aa1175f493e3544d8f66e6600fbfc6/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4d79d391b0aa1175f493e3544d8f66e6600fbfc6", "patch": "@@ -108,13 +108,13 @@ pub enum StackPopCleanup {\n /// State of a local variable including a memoized layout\n #[derive(Clone, PartialEq, Eq)]\n pub struct LocalState<'tcx, Tag=(), Id=AllocId> {\n-    pub state: LocalValue<Tag, Id>,\n+    pub value: LocalValue<Tag, Id>,\n     /// Don't modify if `Some`, this is only used to prevent computing the layout twice\n     pub layout: Cell<Option<TyLayout<'tcx>>>,\n }\n \n-/// State of a local variable\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+/// Current value of a local variable\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum LocalValue<Tag=(), Id=AllocId> {\n     /// This local is not currently alive, and cannot be used at all.\n     Dead,\n@@ -131,27 +131,13 @@ pub enum LocalValue<Tag=(), Id=AllocId> {\n     Live(Operand<Tag, Id>),\n }\n \n-impl<Tag: Copy> LocalValue<Tag> {\n-    /// The initial value of a local: ZST get \"initialized\" because they can be read from without\n-    /// ever having been written to.\n-    fn uninit_local(\n-        layout: TyLayout<'_>\n-    ) -> LocalValue<Tag> {\n-        // FIXME: Can we avoid this ZST special case? That would likely require MIR\n-        // generation changes.\n-        if layout.is_zst() {\n-            LocalValue::Live(Operand::Immediate(Immediate::Scalar(Scalar::zst().into())))\n-        } else {\n-            LocalValue::Uninitialized\n-        }\n-    }\n-}\n-\n-impl<'tcx, Tag: Copy> LocalState<'tcx, Tag> {\n-    pub fn access(&self) -> EvalResult<'tcx, &Operand<Tag>> {\n-        match self.state {\n-            LocalValue::Dead | LocalValue::Uninitialized => err!(DeadLocal),\n-            LocalValue::Live(ref val) => Ok(val),\n+impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n+    pub fn access(&self) -> EvalResult<'tcx, Operand<Tag>> {\n+        match self.value {\n+            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Uninitialized =>\n+                bug!(\"The type checker should prevent reading from a never-written local\"),\n+            LocalValue::Live(val) => Ok(val),\n         }\n     }\n \n@@ -160,7 +146,7 @@ impl<'tcx, Tag: Copy> LocalState<'tcx, Tag> {\n     pub fn access_mut(\n         &mut self,\n     ) -> EvalResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n-        match self.state {\n+        match self.value {\n             LocalValue::Dead => err!(DeadLocal),\n             LocalValue::Live(Operand::Indirect(mplace)) => Ok(Err(mplace)),\n             ref mut local @ LocalValue::Live(Operand::Immediate(_)) |\n@@ -507,13 +493,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         if mir.local_decls.len() > 1 {\n             // Locals are initially uninitialized.\n             let dummy = LocalState {\n-                state: LocalValue::Uninitialized,\n+                value: LocalValue::Uninitialized,\n                 layout: Cell::new(None),\n             };\n             let mut locals = IndexVec::from_elem(dummy, &mir.local_decls);\n             // Return place is handled specially by the `eval_place` functions, and the\n             // entry in `locals` should never be used. Make it dead, to be sure.\n-            locals[mir::RETURN_PLACE].state = LocalValue::Dead;\n+            locals[mir::RETURN_PLACE].value = LocalValue::Dead;\n             // Now mark those locals as dead that we do not want to initialize\n             match self.tcx.describe_def(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n@@ -526,31 +512,14 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n                             match stmt.kind {\n                                 StorageLive(local) |\n                                 StorageDead(local) => {\n-                                    locals[local].state = LocalValue::Dead;\n+                                    locals[local].value = LocalValue::Dead;\n                                 }\n                                 _ => {}\n                             }\n                         }\n                     }\n                 },\n             }\n-            // The remaining locals are uninitialized, fill them with `uninit_local`.\n-            // (For ZST this is not a NOP.)\n-            for (idx, local) in locals.iter_enumerated_mut() {\n-                match local.state {\n-                    LocalValue::Uninitialized => {\n-                        // This needs to be properly initialized.\n-                        let ty = self.monomorphize(mir.local_decls[idx].ty)?;\n-                        let layout = self.layout_of(ty)?;\n-                        local.state = LocalValue::uninit_local(layout);\n-                        local.layout = Cell::new(Some(layout));\n-                    }\n-                    LocalValue::Dead => {\n-                        // Nothing to do\n-                    }\n-                    LocalValue::Live(_) => bug!(\"Locals cannot be live yet\"),\n-                }\n-            }\n             // done\n             self.frame_mut().locals = locals;\n         }\n@@ -585,7 +554,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         }\n         // Deallocate all locals that are backed by an allocation.\n         for local in frame.locals {\n-            self.deallocate_local(local.state)?;\n+            self.deallocate_local(local.value)?;\n         }\n         // Validate the return value. Do this after deallocating so that we catch dangling\n         // references.\n@@ -633,10 +602,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place live\");\n         trace!(\"{:?} is now live\", local);\n \n-        let layout = self.layout_of_local(self.frame(), local, None)?;\n-        let local_val = LocalValue::uninit_local(layout);\n+        let local_val = LocalValue::Uninitialized;\n         // StorageLive *always* kills the value that's currently stored\n-        Ok(mem::replace(&mut self.frame_mut().locals[local].state, local_val))\n+        Ok(mem::replace(&mut self.frame_mut().locals[local].value, local_val))\n     }\n \n     /// Returns the old value of the local.\n@@ -645,7 +613,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n         assert!(local != mir::RETURN_PLACE, \"Cannot make return place dead\");\n         trace!(\"{:?} is now dead\", local);\n \n-        mem::replace(&mut self.frame_mut().locals[local].state, LocalValue::Dead)\n+        mem::replace(&mut self.frame_mut().locals[local].value, LocalValue::Dead)\n     }\n \n     pub(super) fn deallocate_local(\n@@ -698,7 +666,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n                 }\n                 write!(msg, \":\").unwrap();\n \n-                match self.stack[frame].locals[local].state {\n+                match self.stack[frame].locals[local].value {\n                     LocalValue::Dead => write!(msg, \" is dead\").unwrap(),\n                     LocalValue::Uninitialized => write!(msg, \" is uninitialized\").unwrap(),\n                     LocalValue::Live(Operand::Indirect(mplace)) => {"}, {"sha": "65cd7be8fd4b28cf753205347da7a115a1680bd0", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4d79d391b0aa1175f493e3544d8f66e6600fbfc6/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d79d391b0aa1175f493e3544d8f66e6600fbfc6/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=4d79d391b0aa1175f493e3544d8f66e6600fbfc6", "patch": "@@ -459,8 +459,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         assert_ne!(local, mir::RETURN_PLACE);\n-        let op = *frame.locals[local].access()?;\n         let layout = self.layout_of_local(frame, local, layout)?;\n+        let op = if layout.is_zst() {\n+            // Do not read from ZST, they might not be initialized\n+            Operand::Immediate(Immediate::Scalar(Scalar::zst().into()))\n+        } else {\n+            frame.locals[local].access()?\n+        };\n         Ok(OpTy { op, layout })\n     }\n \n@@ -475,7 +480,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 Operand::Indirect(mplace)\n             }\n             Place::Local { frame, local } =>\n-                *self.stack[frame].locals[local].access()?\n+                *self.access_local(&self.stack[frame], local, None)?\n         };\n         Ok(OpTy { op, layout: place.layout })\n     }"}, {"sha": "0bb8b1d9d02ca343c62ae817f28d8ebe808e8faa", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4d79d391b0aa1175f493e3544d8f66e6600fbfc6/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d79d391b0aa1175f493e3544d8f66e6600fbfc6/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=4d79d391b0aa1175f493e3544d8f66e6600fbfc6", "patch": "@@ -363,13 +363,13 @@ impl<'a, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a LocalState<'tcx>\n     type Item = LocalValue<(), AllocIdSnapshot<'a>>;\n \n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let LocalState { state, layout: _ } = self;\n-        state.snapshot(ctx)\n+        let LocalState { value, layout: _ } = self;\n+        value.snapshot(ctx)\n     }\n }\n \n impl_stable_hash_for!(struct LocalState<'tcx> {\n-    state,\n+    value,\n     layout -> _,\n });\n "}]}