{"sha": "8d98877112d4deb3786de521457418757e010c69", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkOTg4NzcxMTJkNGRlYjM3ODZkZTUyMTQ1NzQxODc1N2UwMTBjNjk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-07T13:39:54Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-12T21:57:58Z"}, "message": "Implement a new wfcheck to replace the old wf; this new code only issues\nwarnings. It also checks more conditions than the old code.  Keep the\nold wf code around unchanged so that we can continue to issue errors for\nthe cases where we used to report errors.\n\nAs part of this, remove the where-clauses-must-reference-parameter rule,\nwhich is easily circumvented.", "tree": {"sha": "b07b5298d86c77c216df2c8c7bde3b8ebe4bb32d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b07b5298d86c77c216df2c8c7bde3b8ebe4bb32d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d98877112d4deb3786de521457418757e010c69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d98877112d4deb3786de521457418757e010c69", "html_url": "https://github.com/rust-lang/rust/commit/8d98877112d4deb3786de521457418757e010c69", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d98877112d4deb3786de521457418757e010c69/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad47bd8a0f6f5284a8f937f5cd8a0a7e3df96991", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad47bd8a0f6f5284a8f937f5cd8a0a7e3df96991", "html_url": "https://github.com/rust-lang/rust/commit/ad47bd8a0f6f5284a8f937f5cd8a0a7e3df96991"}], "stats": {"total": 999, "additions": 854, "deletions": 145}, "files": [{"sha": "d84cbe1f879e6a0ebdc8be36d4b3e7ed932ffee7", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=8d98877112d4deb3786de521457418757e010c69", "patch": "@@ -432,7 +432,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             traits::ObligationCause::misc(self.span, self.fcx.body_id),\n             method_predicates);\n \n-        self.fcx.add_default_region_param_bounds(\n+        // this is a projection from a trait reference, so we have to\n+        // make sure that the trait reference inputs are well-formed.\n+        self.fcx.add_wf_bounds(\n             all_substs,\n             self.call_expr);\n     }"}, {"sha": "f8235ace3dd6a9ada51c8c685f4f950339e12087", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=8d98877112d4deb3786de521457418757e010c69", "patch": "@@ -480,6 +480,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     ty::Predicate::Equate(..) |\n                     ty::Predicate::Projection(..) |\n                     ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::WellFormed(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n                     ty::Predicate::TypeOutlives(..) => {\n                         None\n                     }"}, {"sha": "df8a80792a342ae7cb5ba823c85784cf38460a19", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 84, "deletions": 26, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8d98877112d4deb3786de521457418757e010c69", "patch": "@@ -90,7 +90,7 @@ use middle::infer;\n use middle::infer::type_variable;\n use middle::pat_util::{self, pat_id_map};\n use middle::privacy::{AllPublic, LastMod};\n-use middle::region::{self, CodeExtent};\n+use middle::region::{self};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits::{self, report_fulfillment_errors};\n use middle::ty::{FnSig, GenericPredicates, TypeScheme};\n@@ -133,7 +133,8 @@ pub mod coercion;\n pub mod demand;\n pub mod method;\n mod upvar;\n-pub mod wf;\n+mod wf;\n+mod wfcheck;\n mod cast;\n mod closure;\n mod callee;\n@@ -382,25 +383,47 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemBodiesVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_item_types(ccx: &CrateCtxt) {\n+pub fn check_wf_old(ccx: &CrateCtxt) {\n+    // FIXME(#25759). The new code below is much more reliable but (for now)\n+    // only generates warnings. So as to ensure that we continue\n+    // getting errors where we used to get errors, we run the old wf\n+    // code first and abort if it encounters any errors. If no abort\n+    // comes, we run the new code and issue warnings.\n     let krate = ccx.tcx.map.krate();\n     let mut visit = wf::CheckTypeWellFormedVisitor::new(ccx);\n     visit::walk_crate(&mut visit, krate);\n \n     // If types are not well-formed, it leads to all manner of errors\n     // downstream, so stop reporting errors at this point.\n     ccx.tcx.sess.abort_if_errors();\n+}\n \n-    let mut visit = CheckItemTypesVisitor { ccx: ccx };\n+pub fn check_wf_new(ccx: &CrateCtxt) {\n+    let krate = ccx.tcx.map.krate();\n+    let mut visit = wfcheck::CheckTypeWellFormedVisitor::new(ccx);\n     visit::walk_crate(&mut visit, krate);\n \n+    // If types are not well-formed, it leads to all manner of errors\n+    // downstream, so stop reporting errors at this point.\n     ccx.tcx.sess.abort_if_errors();\n+}\n \n+pub fn check_item_types(ccx: &CrateCtxt) {\n+    let krate = ccx.tcx.map.krate();\n+    let mut visit = CheckItemTypesVisitor { ccx: ccx };\n+    visit::walk_crate(&mut visit, krate);\n+    ccx.tcx.sess.abort_if_errors();\n+}\n+\n+pub fn check_item_bodies(ccx: &CrateCtxt) {\n+    let krate = ccx.tcx.map.krate();\n     let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n     visit::walk_crate(&mut visit, krate);\n \n     ccx.tcx.sess.abort_if_errors();\n+}\n \n+pub fn check_drop_impls(ccx: &CrateCtxt) {\n     for drop_method_did in ccx.tcx.destructors.borrow().iter() {\n         if drop_method_did.krate == ast::LOCAL_CRATE {\n             let drop_impl_did = ccx.tcx.map.get_parent_did(drop_method_did.node);\n@@ -586,7 +609,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n \n     if let ty::FnConverging(ret_ty) = ret_ty {\n         fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::ReturnType);\n-        fn_sig_tys.push(ret_ty);\n+        fn_sig_tys.push(ret_ty); // FIXME(#25759) just take implied bounds from the arguments\n     }\n \n     debug!(\"fn-sig-map: fn_id={} fn_sig_tys={:?}\",\n@@ -600,6 +623,14 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n \n         // Add formal parameters.\n         for (arg_ty, input) in arg_tys.iter().zip(&decl.inputs) {\n+            // The type of the argument must be well-formed.\n+            //\n+            // NB -- this is now checked in wfcheck, but that\n+            // currently only results in warnings, so we issue an\n+            // old-style WF obligation here so that we still get the\n+            // errors that we used to get.\n+            fcx.register_old_wf_obligation(arg_ty, input.ty.span, traits::MiscObligation);\n+\n             // Create type variables for each argument.\n             pat_util::pat_bindings(\n                 &tcx.def_map,\n@@ -1507,10 +1538,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn to_ty(&self, ast_t: &ast::Ty) -> Ty<'tcx> {\n         let t = ast_ty_to_ty(self, self, ast_t);\n \n-        let mut bounds_checker = wf::BoundsChecker::new(self,\n-                                                        self.body_id,\n-                                                        None);\n-        bounds_checker.check_ty(t, ast_t.span);\n+        // Generally speaking, we must check that types entered by the\n+        // user are well-formed. This is not true for `_`, since those\n+        // types are generated by inference. Now, you might think that\n+        // we could as well generate a WF obligation -- but\n+        // unfortunately that breaks code like `foo as *const _`,\n+        // because those type variables wind up being unconstrained\n+        // until very late. Nasty. Probably it'd be best to refactor\n+        // that code path, but that's tricky because of\n+        // defaults. Argh!\n+        match ast_t.node {\n+            ast::TyInfer => { }\n+            _ => { self.register_wf_obligation(t, ast_t.span, traits::MiscObligation); }\n+        }\n \n         t\n     }\n@@ -1629,15 +1669,38 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fulfillment_cx.register_region_obligation(ty, region, cause);\n     }\n \n-    pub fn add_default_region_param_bounds(&self,\n-                                           substs: &Substs<'tcx>,\n-                                           expr: &ast::Expr)\n+    /// Registers an obligation for checking later, during regionck, that the type `ty` must\n+    /// outlive the region `r`.\n+    pub fn register_wf_obligation(&self,\n+                                  ty: Ty<'tcx>,\n+                                  span: Span,\n+                                  code: traits::ObligationCauseCode<'tcx>)\n+    {\n+        // WF obligations never themselves fail, so no real need to give a detailed cause:\n+        let cause = traits::ObligationCause::new(span, self.body_id, code);\n+        self.register_predicate(traits::Obligation::new(cause, ty::Predicate::WellFormed(ty)));\n+    }\n+\n+    pub fn register_old_wf_obligation(&self,\n+                                      ty: Ty<'tcx>,\n+                                      span: Span,\n+                                      code: traits::ObligationCauseCode<'tcx>)\n+    {\n+        // Registers an \"old-style\" WF obligation that uses the\n+        // implicator code.  This is basically a buggy version of\n+        // `register_wf_obligation` that is being kept around\n+        // temporarily just to help with phasing in the newer rules.\n+        //\n+        // FIXME(#27579) all uses of this should be migrated to register_wf_obligation eventually\n+        let cause = traits::ObligationCause::new(span, self.body_id, code);\n+        self.register_region_obligation(ty, ty::ReEmpty, cause);\n+    }\n+\n+    /// Registers obligations that all types appearing in `substs` are well-formed.\n+    pub fn add_wf_bounds(&self, substs: &Substs<'tcx>, expr: &ast::Expr)\n     {\n         for &ty in &substs.types {\n-            let default_bound = ty::ReScope(CodeExtent::from_node_id(expr.id));\n-            let cause = traits::ObligationCause::new(expr.span, self.body_id,\n-                                                     traits::MiscObligation);\n-            self.register_region_obligation(ty, default_bound, cause);\n+            self.register_wf_obligation(ty, expr.span, traits::MiscObligation);\n         }\n     }\n \n@@ -2477,7 +2540,8 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     Expectation::rvalue_hint(fcx.tcx(), ty)\n                 });\n \n-                check_expr_with_unifier(fcx, &**arg,\n+                check_expr_with_unifier(fcx,\n+                                        &**arg,\n                                         expected.unwrap_or(ExpectHasType(formal_ty)),\n                                         NoPreference, || {\n                     // 2. Coerce to the most detailed type that could be coerced\n@@ -3362,7 +3426,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n           // We always require that the type provided as the value for\n           // a type parameter outlives the moment of instantiation.\n-          constrain_path_type_parameters(fcx, expr);\n+          fcx.opt_node_ty_substs(expr.id, |item_substs| {\n+              fcx.add_wf_bounds(&item_substs.substs, expr);\n+          });\n       }\n       ast::ExprInlineAsm(ref ia) => {\n           for &(_, ref input) in &ia.inputs {\n@@ -3903,14 +3969,6 @@ pub fn resolve_ty_and_def_ufcs<'a, 'b, 'tcx>(fcx: &FnCtxt<'b, 'tcx>,\n     }\n }\n \n-fn constrain_path_type_parameters(fcx: &FnCtxt,\n-                                  expr: &ast::Expr)\n-{\n-    fcx.opt_node_ty_substs(expr.id, |item_substs| {\n-        fcx.add_default_region_param_bounds(&item_substs.substs, expr);\n-    });\n-}\n-\n impl<'tcx> Expectation<'tcx> {\n     /// Provide an expectation for an rvalue expression given an *optional*\n     /// hint, which is not required for type safety (the resulting type might"}, {"sha": "925ea11690125a36390f1d5b7b950be7626e3e68", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 101, "deletions": 47, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=8d98877112d4deb3786de521457418757e010c69", "patch": "@@ -86,15 +86,19 @@ use astconv::AstConv;\n use check::dropck;\n use check::FnCtxt;\n use middle::free_region::FreeRegionMap;\n-use middle::implicator;\n+use middle::implicator::{self, Implication};\n use middle::mem_categorization as mc;\n+use middle::outlives;\n use middle::region::CodeExtent;\n+use middle::subst::Substs;\n use middle::traits;\n-use middle::ty::{self, ReScope, Ty, MethodCall, HasTypeFlags};\n-use middle::infer::{self, GenericKind};\n+use middle::ty::{self, RegionEscape, ReScope, Ty, MethodCall, HasTypeFlags};\n+use middle::infer::{self, GenericKind, InferCtxt, SubregionOrigin, VerifyBound};\n use middle::pat_util;\n+use middle::wf::{self, ImpliedBound};\n \n use std::mem;\n+use std::rc::Rc;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n use syntax::visit;\n@@ -120,12 +124,19 @@ pub fn regionck_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     rcx.resolve_regions_and_report_errors();\n }\n \n-pub fn regionck_item(fcx: &FnCtxt, item: &ast::Item) {\n-    let mut rcx = Rcx::new(fcx, RepeatingScope(item.id), item.id, Subject(item.id));\n+/// Region checking during the WF phase for items. `wf_tys` are the\n+/// types from which we should derive implied bounds, if any.\n+pub fn regionck_item<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                              item_id: ast::NodeId,\n+                              span: Span,\n+                              wf_tys: &[Ty<'tcx>]) {\n+    debug!(\"regionck_item(item.id={:?}, wf_tys={:?}\", item_id, wf_tys);\n+    let mut rcx = Rcx::new(fcx, RepeatingScope(item_id), item_id, Subject(item_id));\n     let tcx = fcx.tcx();\n     rcx.free_region_map\n        .relate_free_regions_from_predicates(tcx, &fcx.infcx().parameter_environment.caller_bounds);\n-    rcx.visit_region_obligations(item.id);\n+    rcx.relate_free_regions(wf_tys, item_id, span);\n+    rcx.visit_region_obligations(item_id);\n     rcx.resolve_regions_and_report_errors();\n }\n \n@@ -154,22 +165,6 @@ pub fn regionck_fn(fcx: &FnCtxt,\n     fcx.tcx().store_free_region_map(fn_id, rcx.free_region_map);\n }\n \n-/// Checks that the types in `component_tys` are well-formed. This will add constraints into the\n-/// region graph. Does *not* run `resolve_regions_and_report_errors` and so forth.\n-pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                  span: Span,\n-                                                  component_tys: &[Ty<'tcx>]) {\n-    let mut rcx = Rcx::new(fcx, RepeatingScope(0), 0, SubjectNode::None);\n-    for &component_ty in component_tys {\n-        // Check that each type outlives the empty region. Since the\n-        // empty region is a subregion of all others, this can't fail\n-        // unless the type does not meet the well-formedness\n-        // requirements.\n-        type_must_outlive(&mut rcx, infer::RelateParamBound(span, component_ty),\n-                          component_ty, ty::ReEmpty);\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // INTERNALS\n \n@@ -213,6 +208,10 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         self.fcx.ccx.tcx\n     }\n \n+    pub fn infcx(&self) -> &InferCtxt<'a,'tcx> {\n+        self.fcx.infcx()\n+    }\n+\n     fn set_body_id(&mut self, body_id: ast::NodeId) -> ast::NodeId {\n         mem::replace(&mut self.body_id, body_id)\n     }\n@@ -325,18 +324,79 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                 .to_vec();\n \n         for r_o in &region_obligations {\n-            debug!(\"visit_region_obligations: r_o={:?}\",\n-                   r_o);\n+            debug!(\"visit_region_obligations: r_o={:?} cause={:?}\",\n+                   r_o, r_o.cause);\n             let sup_type = self.resolve_type(r_o.sup_type);\n-            let origin = infer::RelateParamBound(r_o.cause.span, sup_type);\n-            type_must_outlive(self, origin, sup_type, r_o.sub_region);\n+            let origin = self.code_to_origin(r_o.cause.span, sup_type, &r_o.cause.code);\n+\n+            if r_o.sub_region != ty::ReEmpty {\n+                type_must_outlive(self, origin, sup_type, r_o.sub_region);\n+            } else {\n+                self.visit_old_school_wf(node_id, sup_type, origin);\n+            }\n         }\n \n         // Processing the region obligations should not cause the list to grow further:\n         assert_eq!(region_obligations.len(),\n                    self.fcx.inh.infcx.fulfillment_cx.borrow().region_obligations(node_id).len());\n     }\n \n+    fn visit_old_school_wf(&mut self,\n+                           body_id: ast::NodeId,\n+                           ty: Ty<'tcx>,\n+                           origin: infer::SubregionOrigin<'tcx>) {\n+        // As a weird kind of hack, we use a region of empty as a signal\n+        // to mean \"old-school WF rules\". The only reason the old-school\n+        // WF rules are not encoded using WF is that this leads to errors,\n+        // and we want to phase those in gradually.\n+\n+        // FIXME(#27579) remove this weird special case once we phase in new WF rules completely\n+        let implications = implicator::implications(self.infcx(),\n+                                                    body_id,\n+                                                    ty,\n+                                                    ty::ReEmpty,\n+                                                    origin.span());\n+        let origin_for_ty = |ty: Option<Ty<'tcx>>| match ty {\n+            None => origin.clone(),\n+            Some(ty) => infer::ReferenceOutlivesReferent(ty, origin.span()),\n+        };\n+        for implication in implications {\n+            match implication {\n+                Implication::RegionSubRegion(ty, r1, r2) => {\n+                    self.fcx.mk_subr(origin_for_ty(ty), r1, r2);\n+                }\n+                Implication::RegionSubGeneric(ty, r1, GenericKind::Param(param_ty)) => {\n+                    param_ty_must_outlive(self, origin_for_ty(ty), r1, param_ty);\n+                }\n+                Implication::RegionSubGeneric(ty, r1, GenericKind::Projection(proj_ty)) => {\n+                    projection_must_outlive(self, origin_for_ty(ty), r1, proj_ty);\n+                }\n+                Implication::Predicate(def_id, predicate) => {\n+                    let cause = traits::ObligationCause::new(origin.span(),\n+                                                             body_id,\n+                                                             traits::ItemObligation(def_id));\n+                    let obligation = traits::Obligation::new(cause, predicate);\n+                    self.fcx.register_predicate(obligation);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn code_to_origin(&self,\n+                      span: Span,\n+                      sup_type: Ty<'tcx>,\n+                      code: &traits::ObligationCauseCode<'tcx>)\n+                      -> SubregionOrigin<'tcx> {\n+        match *code {\n+            traits::ObligationCauseCode::RFC1214(ref code) =>\n+                infer::RFC1214Subregion(Rc::new(self.code_to_origin(span, sup_type, code))),\n+            traits::ObligationCauseCode::ReferenceOutlivesReferent(ref_type) =>\n+                infer::ReferenceOutlivesReferent(ref_type, span),\n+            _ =>\n+                infer::RelateParamBound(span, sup_type),\n+        }\n+    }\n+\n     /// This method populates the region map's `free_region_map`. It walks over the transformed\n     /// argument and return types for each function just before we check the body of that function,\n     /// looking for types where you have a borrowed pointer to other borrowed data (e.g., `&'a &'b\n@@ -356,33 +416,28 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         for &ty in fn_sig_tys {\n             let ty = self.resolve_type(ty);\n             debug!(\"relate_free_regions(t={:?})\", ty);\n-            let body_scope = CodeExtent::from_node_id(body_id);\n-            let body_scope = ty::ReScope(body_scope);\n-            let implications = implicator::implications(self.fcx.infcx(), body_id,\n-                                                        ty, body_scope, span);\n+            let implied_bounds = wf::implied_bounds(self.fcx.infcx(), body_id, ty, span);\n \n             // Record any relations between free regions that we observe into the free-region-map.\n-            self.free_region_map.relate_free_regions_from_implications(&implications);\n+            self.free_region_map.relate_free_regions_from_implied_bounds(&implied_bounds);\n \n             // But also record other relationships, such as `T:'x`,\n             // that don't go into the free-region-map but which we use\n             // here.\n-            for implication in implications {\n+            for implication in implied_bounds {\n                 debug!(\"implication: {:?}\", implication);\n                 match implication {\n-                    implicator::Implication::RegionSubRegion(_,\n-                                                             ty::ReFree(free_a),\n-                                                             ty::ReInfer(ty::ReVar(vid_b))) => {\n+                    ImpliedBound::RegionSubRegion(ty::ReFree(free_a),\n+                                                  ty::ReInfer(ty::ReVar(vid_b))) => {\n                         self.fcx.inh.infcx.add_given(free_a, vid_b);\n                     }\n-                    implicator::Implication::RegionSubGeneric(_, r_a, ref generic_b) => {\n-                        debug!(\"RegionSubGeneric: {:?} <= {:?}\",\n-                               r_a, generic_b);\n-\n-                        self.region_bound_pairs.push((r_a, generic_b.clone()));\n+                    ImpliedBound::RegionSubParam(r_a, param_b) => {\n+                        self.region_bound_pairs.push((r_a, GenericKind::Param(param_b)));\n                     }\n-                    implicator::Implication::RegionSubRegion(..) |\n-                    implicator::Implication::Predicate(..) => {\n+                    ImpliedBound::RegionSubProjection(r_a, projection_b) => {\n+                        self.region_bound_pairs.push((r_a, GenericKind::Projection(projection_b)));\n+                    }\n+                    ImpliedBound::RegionSubRegion(..) => {\n                         // In principle, we could record (and take\n                         // advantage of) every relationship here, but\n                         // we are also free not to -- it simply means\n@@ -492,12 +547,11 @@ fn constrain_bindings_in_pat(pat: &ast::Pat, rcx: &mut Rcx) {\n         // that the lifetime of any regions that appear in a\n         // variable's type enclose at least the variable's scope.\n \n-        let var_region = tcx.region_maps.var_region(id);\n-        type_of_node_must_outlive(\n-            rcx, infer::BindingTypeIsNotValidAtDecl(span),\n-            id, var_region);\n-\n         let var_scope = tcx.region_maps.var_scope(id);\n+\n+        let origin = infer::BindingTypeIsNotValidAtDecl(span);\n+        type_of_node_must_outlive(rcx, origin, id, ty::ReScope(var_scope));\n+\n         let typ = rcx.resolve_node_type(id);\n         dropck::check_safety_of_destructor_if_necessary(rcx, typ, span, var_scope);\n     })"}, {"sha": "21f48d37799e76fbb74b0acc9f75086773f54533", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=8d98877112d4deb3786de521457418757e010c69", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use astconv::AstConv;\n-use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck};\n+use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck, wfcheck};\n use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n use middle::region;\n@@ -23,7 +23,7 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::ast_util::local_def;\n use syntax::codemap::{DUMMY_SP, Span};\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token::{special_idents};\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -86,9 +86,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n                     Some(_) | None => {\n                         if !ccx.tcx.trait_has_default_impl(trait_ref.def_id) {\n-                            span_err!(ccx.tcx.sess, item.span, E0192,\n-                                      \"negative impls are only allowed for traits with \\\n-                                       default impls (e.g., `Send` and `Sync`)\")\n+                            wfcheck::error_192(ccx, item.span);\n                         }\n                     }\n                 }\n@@ -122,9 +120,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 reject_non_type_param_bounds(ccx.tcx, item.span, &trait_predicates);\n                 if ccx.tcx.trait_has_default_impl(local_def(item.id)) {\n                     if !items.is_empty() {\n-                        span_err!(ccx.tcx.sess, item.span, E0380,\n-                                  \"traits with default impls (`e.g. unsafe impl \\\n-                                  Trait for ..`) must have no methods or associated items\")\n+                        wfcheck::error_380(ccx, item.span);\n                     }\n                 }\n             }\n@@ -149,7 +145,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(type_scheme.ty), item.id);\n         f(self, &fcx);\n         fcx.select_all_obligations_or_error();\n-        regionck::regionck_item(&fcx, item);\n+        regionck::regionck_item(&fcx, item.id, item.span, &[]);\n     }\n \n     /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n@@ -185,8 +181,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let field_tys: Vec<Ty> =\n                 variants.iter().flat_map(|v| v.fields.iter().map(|f| f.ty)).collect();\n \n-            regionck::regionck_ensure_component_tys_wf(\n-                fcx, item.span, &field_tys);\n+            for &field_ty in &field_tys {\n+                fcx.register_wf_obligation(field_ty, item.span, traits::MiscObligation);\n+            }\n         });\n     }\n \n@@ -355,8 +352,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                          span: Span,\n                          param_name: ast::Name)\n     {\n-        span_err!(self.tcx().sess, span, E0392,\n-            \"parameter `{}` is never used\", param_name);\n+        wfcheck::error_392(self.tcx(), span, param_name);\n \n         let suggested_marker_id = self.tcx().lang_items.phantom_data();\n         match suggested_marker_id {\n@@ -420,9 +416,7 @@ fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     for method_param in generics.types.get_slice(subst::FnSpace) {\n         if impl_params.contains(&method_param.name) {\n-            span_err!(tcx.sess, span, E0194,\n-                \"type parameter `{}` shadows another type parameter of the same name\",\n-                          method_param.name);\n+            wfcheck::error_194(tcx, span, method_param.name);\n         }\n     }\n }\n@@ -521,11 +515,6 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n         }\n     }\n \n-    pub fn check_ty(&mut self, ty: Ty<'tcx>, span: Span) {\n-        self.span = span;\n-        ty.fold_with(self);\n-    }\n-\n     fn check_traits_in_ty(&mut self, ty: Ty<'tcx>, span: Span) {\n         self.span = span;\n         // When checking types outside of a type def'n, we ignore\n@@ -709,6 +698,8 @@ fn filter_to_trait_obligations<'tcx>(bounds: ty::InstantiatedPredicates<'tcx>)\n             ty::Predicate::Projection(..) => {\n                 result.predicates.push(space, predicate.clone())\n             }\n+            ty::Predicate::WellFormed(..) |\n+            ty::Predicate::ObjectSafe(..) |\n             ty::Predicate::Equate(..) |\n             ty::Predicate::TypeOutlives(..) |\n             ty::Predicate::RegionOutlives(..) => {"}, {"sha": "03e6ae2dd15456b2d29ea7d31d090bcdc37dd5b3", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "added", "additions": 630, "deletions": 0, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=8d98877112d4deb3786de521457418757e010c69", "patch": "@@ -0,0 +1,630 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use astconv::AstConv;\n+use check::{FnCtxt, Inherited, blank_fn_ctxt, regionck};\n+use constrained_type_params::{identify_constrained_type_params, Parameter};\n+use CrateCtxt;\n+use middle::region::DestructionScopeData;\n+use middle::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n+use middle::traits;\n+use middle::ty::{self, Ty};\n+use middle::ty_fold::{TypeFolder};\n+use middle::wf;\n+\n+use std::cell::RefCell;\n+use std::collections::HashSet;\n+use std::rc::Rc;\n+use syntax::ast;\n+use syntax::ast_util::local_def;\n+use syntax::codemap::{Span};\n+use syntax::parse::token::{special_idents};\n+use syntax::ptr::P;\n+use syntax::visit;\n+use syntax::visit::Visitor;\n+\n+pub struct CheckTypeWellFormedVisitor<'ccx, 'tcx:'ccx> {\n+    ccx: &'ccx CrateCtxt<'ccx, 'tcx>,\n+    code: traits::ObligationCauseCode<'tcx>,\n+}\n+\n+impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+    pub fn new(ccx: &'ccx CrateCtxt<'ccx, 'tcx>)\n+               -> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+        CheckTypeWellFormedVisitor {\n+            ccx: ccx,\n+            code: traits::ObligationCauseCode::RFC1214(\n+                Rc::new(traits::ObligationCauseCode::MiscObligation))\n+        }\n+    }\n+\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.ccx.tcx\n+    }\n+\n+    /// Checks that the field types (in a struct def'n) or argument types (in an enum def'n) are\n+    /// well-formed, meaning that they do not require any constraints not declared in the struct\n+    /// definition itself. For example, this definition would be illegal:\n+    ///\n+    ///     struct Ref<'a, T> { x: &'a T }\n+    ///\n+    /// because the type did not declare that `T:'a`.\n+    ///\n+    /// We do this check as a pre-pass before checking fn bodies because if these constraints are\n+    /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n+    /// the types first.\n+    fn check_item_well_formed(&mut self, item: &ast::Item) {\n+        let ccx = self.ccx;\n+        debug!(\"check_item_well_formed(it.id={}, it.ident={})\",\n+               item.id,\n+               ccx.tcx.item_path_str(local_def(item.id)));\n+\n+        match item.node {\n+            /// Right now we check that every default trait implementation\n+            /// has an implementation of itself. Basically, a case like:\n+            ///\n+            /// `impl Trait for T {}`\n+            ///\n+            /// has a requirement of `T: Trait` which was required for default\n+            /// method implementations. Although this could be improved now that\n+            /// there's a better infrastructure in place for this, it's being left\n+            /// for a follow-up work.\n+            ///\n+            /// Since there's such a requirement, we need to check *just* positive\n+            /// implementations, otherwise things like:\n+            ///\n+            /// impl !Send for T {}\n+            ///\n+            /// won't be allowed unless there's an *explicit* implementation of `Send`\n+            /// for `T`\n+            ast::ItemImpl(_, ast::ImplPolarity::Positive, _,\n+                          ref trait_ref, ref self_ty, _) => {\n+                self.check_impl(item, self_ty, trait_ref);\n+            }\n+            ast::ItemImpl(_, ast::ImplPolarity::Negative, _, Some(_), _, _) => {\n+                // FIXME(#27579) what amount of WF checking do we need for neg impls?\n+\n+                let trait_ref = ccx.tcx.impl_trait_ref(local_def(item.id)).unwrap();\n+                ccx.tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id);\n+                match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n+                    Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n+                    Some(_) | None => {\n+                        if !ccx.tcx.trait_has_default_impl(trait_ref.def_id) {\n+                            error_192(ccx, item.span);\n+                        }\n+                    }\n+                }\n+            }\n+            ast::ItemFn(_, _, _, _, _, ref body) => {\n+                self.check_item_fn(item, body);\n+            }\n+            ast::ItemStatic(..) => {\n+                self.check_item_type(item);\n+            }\n+            ast::ItemConst(..) => {\n+                self.check_item_type(item);\n+            }\n+            ast::ItemStruct(ref struct_def, ref ast_generics) => {\n+                self.check_type_defn(item, |fcx| {\n+                    vec![struct_variant(fcx, &**struct_def)]\n+                });\n+\n+                self.check_variances_for_type_defn(item, ast_generics);\n+            }\n+            ast::ItemEnum(ref enum_def, ref ast_generics) => {\n+                self.check_type_defn(item, |fcx| {\n+                    enum_variants(fcx, enum_def)\n+                });\n+\n+                self.check_variances_for_type_defn(item, ast_generics);\n+            }\n+            ast::ItemTrait(_, _, _, ref items) => {\n+                self.check_trait(item, items);\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_trait_or_impl_item(&mut self, item_id: ast::NodeId, span: Span) {\n+        let code = self.code.clone();\n+        self.with_fcx(item_id, span, |fcx, this| {\n+            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+            let free_id = fcx.inh.infcx.parameter_environment.free_id;\n+\n+            let item = fcx.tcx().impl_or_trait_item(local_def(item_id));\n+\n+            let mut implied_bounds = match item.container() {\n+                ty::TraitContainer(_) => vec![],\n+                ty::ImplContainer(def_id) => impl_implied_bounds(fcx, def_id, span)\n+            };\n+\n+            match item {\n+                ty::ConstTraitItem(assoc_const) => {\n+                    let ty = fcx.instantiate_type_scheme(span, free_substs, &assoc_const.ty);\n+                    fcx.register_wf_obligation(ty, span, code.clone());\n+                }\n+                ty::MethodTraitItem(method) => {\n+                    reject_shadowing_type_parameters(fcx.tcx(), span, &method.generics);\n+                    let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method.fty);\n+                    let predicates = fcx.instantiate_bounds(span, free_substs, &method.predicates);\n+                    this.check_fn_or_method(fcx, span, &method_ty, &predicates,\n+                                            free_id, &mut implied_bounds);\n+                }\n+                ty::TypeTraitItem(assoc_type) => {\n+                    if let Some(ref ty) = assoc_type.ty {\n+                        let ty = fcx.instantiate_type_scheme(span, free_substs, ty);\n+                        fcx.register_wf_obligation(ty, span, code.clone());\n+                    }\n+                }\n+            }\n+\n+            implied_bounds\n+        })\n+    }\n+\n+    fn with_item_fcx<F>(&mut self, item: &ast::Item, f: F) where\n+        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx>,\n+                           &mut CheckTypeWellFormedVisitor<'ccx,'tcx>) -> Vec<Ty<'tcx>>,\n+    {\n+        self.with_fcx(item.id, item.span, f)\n+    }\n+\n+    fn with_fcx<F>(&mut self, id: ast::NodeId, span: Span, mut f: F) where\n+        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx>,\n+                           &mut CheckTypeWellFormedVisitor<'ccx,'tcx>) -> Vec<Ty<'tcx>>,\n+    {\n+        let ccx = self.ccx;\n+        let param_env = ty::ParameterEnvironment::for_item(ccx.tcx, id);\n+        let tables = RefCell::new(ty::Tables::empty());\n+        let inh = Inherited::new(ccx.tcx, &tables, param_env);\n+        let fcx = blank_fn_ctxt(ccx, &inh, ty::FnDiverging, id);\n+        let wf_tys = f(&fcx, self);\n+        fcx.select_all_obligations_or_error();\n+        regionck::regionck_item(&fcx, id, span, &wf_tys);\n+    }\n+\n+    /// In a type definition, we check that to ensure that the types of the fields are well-formed.\n+    fn check_type_defn<F>(&mut self, item: &ast::Item, mut lookup_fields: F) where\n+        F: for<'fcx> FnMut(&FnCtxt<'fcx, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n+    {\n+        self.with_item_fcx(item, |fcx, this| {\n+            let variants = lookup_fields(fcx);\n+\n+            for variant in &variants {\n+                // For DST, all intermediate types must be sized.\n+                if let Some((_, fields)) = variant.fields.split_last() {\n+                    for field in fields {\n+                        fcx.register_builtin_bound(\n+                            field.ty,\n+                            ty::BoundSized,\n+                            traits::ObligationCause::new(field.span,\n+                                                         fcx.body_id,\n+                                                         traits::FieldSized));\n+                    }\n+                }\n+\n+                // All field types must be well-formed.\n+                for field in &variant.fields {\n+                    fcx.register_wf_obligation(field.ty, field.span, this.code.clone())\n+                }\n+            }\n+\n+            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+            let predicates = fcx.tcx().lookup_predicates(local_def(item.id));\n+            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+            this.check_where_clauses(fcx, item.span, &predicates);\n+\n+            vec![] // no implied bounds in a struct def'n\n+        });\n+    }\n+\n+    fn check_trait(&mut self,\n+                   item: &ast::Item,\n+                   items: &[P<ast::TraitItem>])\n+    {\n+        let trait_def_id = local_def(item.id);\n+\n+        if self.ccx.tcx.trait_has_default_impl(trait_def_id) {\n+            if !items.is_empty() {\n+                error_380(self.ccx, item.span);\n+            }\n+        }\n+\n+        self.with_item_fcx(item, |fcx, this| {\n+            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+            let predicates = fcx.tcx().lookup_predicates(trait_def_id);\n+            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+            this.check_where_clauses(fcx, item.span, &predicates);\n+            vec![]\n+        });\n+    }\n+\n+    fn check_item_fn(&mut self,\n+                     item: &ast::Item,\n+                     body: &ast::Block)\n+    {\n+        self.with_item_fcx(item, |fcx, this| {\n+            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+            let type_scheme = fcx.tcx().lookup_item_type(local_def(item.id));\n+            let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &type_scheme.ty);\n+            let bare_fn_ty = match item_ty.sty {\n+                ty::TyBareFn(_, ref bare_fn_ty) => bare_fn_ty,\n+                _ => {\n+                    this.tcx().sess.span_bug(item.span, \"Fn item without bare fn type\");\n+                }\n+            };\n+\n+            let predicates = fcx.tcx().lookup_predicates(local_def(item.id));\n+            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+\n+            let mut implied_bounds = vec![];\n+            this.check_fn_or_method(fcx, item.span, bare_fn_ty, &predicates,\n+                                    body.id, &mut implied_bounds);\n+            implied_bounds\n+        })\n+    }\n+\n+    fn check_item_type(&mut self,\n+                       item: &ast::Item)\n+    {\n+        debug!(\"check_item_type: {:?}\", item);\n+\n+        self.with_item_fcx(item, |fcx, this| {\n+            let type_scheme = fcx.tcx().lookup_item_type(local_def(item.id));\n+            let item_ty = fcx.instantiate_type_scheme(item.span,\n+                                                      &fcx.inh\n+                                                          .infcx\n+                                                          .parameter_environment\n+                                                          .free_substs,\n+                                                      &type_scheme.ty);\n+\n+            fcx.register_wf_obligation(item_ty, item.span, this.code.clone());\n+\n+            vec![] // no implied bounds in a const etc\n+        });\n+    }\n+\n+    fn check_impl(&mut self,\n+                  item: &ast::Item,\n+                  ast_self_ty: &ast::Ty,\n+                  ast_trait_ref: &Option<ast::TraitRef>)\n+    {\n+        debug!(\"check_impl: {:?}\", item);\n+\n+        self.with_item_fcx(item, |fcx, this| {\n+            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+            let item_def_id = local_def(item.id);\n+\n+            match *ast_trait_ref {\n+                Some(ref ast_trait_ref) => {\n+                    let trait_ref = fcx.tcx().impl_trait_ref(item_def_id).unwrap();\n+                    let trait_ref =\n+                        fcx.instantiate_type_scheme(\n+                            ast_trait_ref.path.span, free_substs, &trait_ref);\n+                    let obligations =\n+                        wf::trait_obligations(fcx.infcx(),\n+                                              fcx.body_id,\n+                                              &trait_ref,\n+                                              ast_trait_ref.path.span,\n+                                              true);\n+                    for obligation in obligations {\n+                        fcx.register_predicate(obligation);\n+                    }\n+                }\n+                None => {\n+                    let self_ty = fcx.tcx().node_id_to_type(item.id);\n+                    let self_ty = fcx.instantiate_type_scheme(item.span, free_substs, &self_ty);\n+                    fcx.register_wf_obligation(self_ty, ast_self_ty.span, this.code.clone());\n+                }\n+            }\n+\n+            let predicates = fcx.tcx().lookup_predicates(item_def_id);\n+            let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n+            this.check_where_clauses(fcx, item.span, &predicates);\n+\n+            impl_implied_bounds(fcx, local_def(item.id), item.span)\n+        });\n+    }\n+\n+    fn check_where_clauses<'fcx>(&mut self,\n+                                 fcx: &FnCtxt<'fcx,'tcx>,\n+                                 span: Span,\n+                                 predicates: &ty::InstantiatedPredicates<'tcx>)\n+    {\n+        let obligations =\n+            predicates.predicates\n+                      .iter()\n+                      .flat_map(|p| wf::predicate_obligations(fcx.infcx(),\n+                                                              fcx.body_id,\n+                                                              p,\n+                                                              span,\n+                                                              true));\n+\n+        for obligation in obligations {\n+            fcx.register_predicate(obligation);\n+        }\n+    }\n+\n+    fn check_fn_or_method<'fcx>(&mut self,\n+                                fcx: &FnCtxt<'fcx,'tcx>,\n+                                span: Span,\n+                                fty: &ty::BareFnTy<'tcx>,\n+                                predicates: &ty::InstantiatedPredicates<'tcx>,\n+                                free_id: ast::NodeId,\n+                                implied_bounds: &mut Vec<Ty<'tcx>>)\n+    {\n+        let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+        let fty = fcx.instantiate_type_scheme(span, free_substs, fty);\n+        let free_id_outlive = DestructionScopeData::new(free_id);\n+        let sig = fcx.tcx().liberate_late_bound_regions(free_id_outlive, &fty.sig);\n+\n+        for &input_ty in &sig.inputs {\n+            fcx.register_wf_obligation(input_ty, span, self.code.clone());\n+        }\n+        implied_bounds.extend(sig.inputs);\n+\n+        match sig.output {\n+            ty::FnConverging(output) => {\n+                fcx.register_wf_obligation(output, span, self.code.clone());\n+\n+                // FIXME(#25759) return types should not be implied bounds\n+                implied_bounds.push(output);\n+            }\n+            ty::FnDiverging => { }\n+        }\n+\n+        self.check_where_clauses(fcx, span, predicates);\n+    }\n+\n+    fn check_variances_for_type_defn(&self,\n+                                     item: &ast::Item,\n+                                     ast_generics: &ast::Generics)\n+    {\n+        let item_def_id = local_def(item.id);\n+        let ty_predicates = self.tcx().lookup_predicates(item_def_id);\n+        let variances = self.tcx().item_variances(item_def_id);\n+\n+        let mut constrained_parameters: HashSet<_> =\n+            variances.types\n+                     .iter_enumerated()\n+                     .filter(|&(_, _, &variance)| variance != ty::Bivariant)\n+                     .map(|(space, index, _)| self.param_ty(ast_generics, space, index))\n+                     .map(|p| Parameter::Type(p))\n+                     .collect();\n+\n+        identify_constrained_type_params(self.tcx(),\n+                                         ty_predicates.predicates.as_slice(),\n+                                         None,\n+                                         &mut constrained_parameters);\n+\n+        for (space, index, _) in variances.types.iter_enumerated() {\n+            let param_ty = self.param_ty(ast_generics, space, index);\n+            if constrained_parameters.contains(&Parameter::Type(param_ty)) {\n+                continue;\n+            }\n+            let span = self.ty_param_span(ast_generics, item, space, index);\n+            self.report_bivariance(span, param_ty.name);\n+        }\n+\n+        for (space, index, &variance) in variances.regions.iter_enumerated() {\n+            if variance != ty::Bivariant {\n+                continue;\n+            }\n+\n+            assert_eq!(space, TypeSpace);\n+            let span = ast_generics.lifetimes[index].lifetime.span;\n+            let name = ast_generics.lifetimes[index].lifetime.name;\n+            self.report_bivariance(span, name);\n+        }\n+    }\n+\n+    fn param_ty(&self,\n+                ast_generics: &ast::Generics,\n+                space: ParamSpace,\n+                index: usize)\n+                -> ty::ParamTy\n+    {\n+        let name = match space {\n+            TypeSpace => ast_generics.ty_params[index].ident.name,\n+            SelfSpace => special_idents::type_self.name,\n+            FnSpace => self.tcx().sess.bug(\"Fn space occupied?\"),\n+        };\n+\n+        ty::ParamTy { space: space, idx: index as u32, name: name }\n+    }\n+\n+    fn ty_param_span(&self,\n+                     ast_generics: &ast::Generics,\n+                     item: &ast::Item,\n+                     space: ParamSpace,\n+                     index: usize)\n+                     -> Span\n+    {\n+        match space {\n+            TypeSpace => ast_generics.ty_params[index].span,\n+            SelfSpace => item.span,\n+            FnSpace => self.tcx().sess.span_bug(item.span, \"Fn space occupied?\"),\n+        }\n+    }\n+\n+    fn report_bivariance(&self,\n+                         span: Span,\n+                         param_name: ast::Name)\n+    {\n+        error_392(self.tcx(), span, param_name);\n+\n+        let suggested_marker_id = self.tcx().lang_items.phantom_data();\n+        match suggested_marker_id {\n+            Some(def_id) => {\n+                self.tcx().sess.fileline_help(\n+                    span,\n+                    &format!(\"consider removing `{}` or using a marker such as `{}`\",\n+                             param_name,\n+                             self.tcx().item_path_str(def_id)));\n+            }\n+            None => {\n+                // no lang items, no help!\n+            }\n+        }\n+    }\n+}\n+\n+fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                          span: Span,\n+                                          generics: &ty::Generics<'tcx>) {\n+    let impl_params = generics.types.get_slice(subst::TypeSpace).iter()\n+        .map(|tp| tp.name).collect::<HashSet<_>>();\n+\n+    for method_param in generics.types.get_slice(subst::FnSpace) {\n+        if impl_params.contains(&method_param.name) {\n+            error_194(tcx, span, method_param.name);\n+        }\n+    }\n+}\n+\n+impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n+    fn visit_item(&mut self, i: &ast::Item) {\n+        debug!(\"visit_item: {:?}\", i);\n+        self.check_item_well_formed(i);\n+        visit::walk_item(self, i);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'v ast::TraitItem) {\n+        debug!(\"visit_trait_item: {:?}\", trait_item);\n+        self.check_trait_or_impl_item(trait_item.id, trait_item.span);\n+        visit::walk_trait_item(self, trait_item)\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'v ast::ImplItem) {\n+        debug!(\"visit_impl_item: {:?}\", impl_item);\n+        self.check_trait_or_impl_item(impl_item.id, impl_item.span);\n+        visit::walk_impl_item(self, impl_item)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// ADT\n+\n+struct AdtVariant<'tcx> {\n+    fields: Vec<AdtField<'tcx>>,\n+}\n+\n+struct AdtField<'tcx> {\n+    ty: Ty<'tcx>,\n+    span: Span,\n+}\n+\n+fn struct_variant<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                            struct_def: &ast::StructDef)\n+                            -> AdtVariant<'tcx> {\n+    let fields =\n+        struct_def.fields\n+        .iter()\n+        .map(|field| {\n+            let field_ty = fcx.tcx().node_id_to_type(field.node.id);\n+            let field_ty = fcx.instantiate_type_scheme(field.span,\n+                                                       &fcx.inh\n+                                                           .infcx\n+                                                           .parameter_environment\n+                                                           .free_substs,\n+                                                       &field_ty);\n+            AdtField { ty: field_ty, span: field.span }\n+        })\n+        .collect();\n+    AdtVariant { fields: fields }\n+}\n+\n+fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                           enum_def: &ast::EnumDef)\n+                           -> Vec<AdtVariant<'tcx>> {\n+    enum_def.variants.iter()\n+        .map(|variant| {\n+            match variant.node.kind {\n+                ast::TupleVariantKind(ref args) if !args.is_empty() => {\n+                    let ctor_ty = fcx.tcx().node_id_to_type(variant.node.id);\n+\n+                    // the regions in the argument types come from the\n+                    // enum def'n, and hence will all be early bound\n+                    let arg_tys = fcx.tcx().no_late_bound_regions(&ctor_ty.fn_args()).unwrap();\n+                    AdtVariant {\n+                        fields: args.iter().enumerate().map(|(index, arg)| {\n+                            let arg_ty = arg_tys[index];\n+                            let arg_ty =\n+                                fcx.instantiate_type_scheme(variant.span,\n+                                                            &fcx.inh\n+                                                                .infcx\n+                                                                .parameter_environment\n+                                                                .free_substs,\n+                                                            &arg_ty);\n+                            AdtField {\n+                                ty: arg_ty,\n+                                span: arg.ty.span\n+                            }\n+                        }).collect()\n+                    }\n+                }\n+                ast::TupleVariantKind(_) => {\n+                    AdtVariant {\n+                        fields: Vec::new()\n+                    }\n+                }\n+                ast::StructVariantKind(ref struct_def) => {\n+                    struct_variant(fcx, &**struct_def)\n+                }\n+            }\n+        })\n+        .collect()\n+}\n+\n+fn impl_implied_bounds<'fcx,'tcx>(fcx: &FnCtxt<'fcx, 'tcx>,\n+                                  impl_def_id: ast::DefId,\n+                                  span: Span)\n+                                  -> Vec<Ty<'tcx>>\n+{\n+    let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+    match fcx.tcx().impl_trait_ref(impl_def_id) {\n+        Some(ref trait_ref) => {\n+            // Trait impl: take implied bounds from all types that\n+            // appear in the trait reference.\n+            let trait_ref = fcx.instantiate_type_scheme(span, free_substs, trait_ref);\n+            trait_ref.substs.types.as_slice().to_vec()\n+        }\n+\n+        None => {\n+            // Inherent impl: take implied bounds from the self type.\n+            let self_ty = fcx.tcx().lookup_item_type(impl_def_id).ty;\n+            let self_ty = fcx.instantiate_type_scheme(span, free_substs, &self_ty);\n+            vec![self_ty]\n+        }\n+    }\n+}\n+\n+pub fn error_192<'ccx,'tcx>(ccx: &'ccx CrateCtxt<'ccx, 'tcx>, span: Span) {\n+    span_err!(ccx.tcx.sess, span, E0192,\n+              \"negative impls are only allowed for traits with \\\n+               default impls (e.g., `Send` and `Sync`)\")\n+}\n+\n+pub fn error_380<'ccx,'tcx>(ccx: &'ccx CrateCtxt<'ccx, 'tcx>, span: Span) {\n+    span_err!(ccx.tcx.sess, span, E0380,\n+              \"traits with default impls (`e.g. unsafe impl \\\n+               Trait for ..`) must have no methods or associated items\")\n+}\n+\n+pub fn error_392<'tcx>(tcx: &ty::ctxt<'tcx>, span: Span, param_name: ast::Name)  {\n+    span_err!(tcx.sess, span, E0392,\n+              \"parameter `{}` is never used\", param_name);\n+}\n+\n+pub fn error_194<'tcx>(tcx: &ty::ctxt<'tcx>, span: Span, name: ast::Name) {\n+    span_err!(tcx.sess, span, E0194,\n+              \"type parameter `{}` shadows another type parameter of the same name\",\n+              name);\n+}"}, {"sha": "1652c67c531d3cb169f92567cc24d3c42d941c0b", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=8d98877112d4deb3786de521457418757e010c69", "patch": "@@ -200,10 +200,13 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n \n                         if !traits::is_object_safe(self.tcx, data.principal_def_id()) {\n-                            // this just means the self-ty is illegal,\n-                            // and probably this error should have\n-                            // been reported elsewhere, but I'm trying to avoid\n-                            // giving a misleading message below.\n+                            // FIXME(#27579). This just means the\n+                            // self-ty is illegal; WF will report this\n+                            // error. But it will do so as a warning\n+                            // for a release or two.  For backwards\n+                            // compat reasons, then, we continue to\n+                            // report it here so that things which\n+                            // were errors remain errors.\n                             span_err!(self.tcx.sess, self_ty.span, E0372,\n                                       \"the trait `{}` cannot be made into an object\",\n                                       self.tcx.item_path_str(data.principal_def_id()));"}, {"sha": "e6824c811c58e598f47a9688bc7e735ae4ccf229", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d98877112d4deb3786de521457418757e010c69/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=8d98877112d4deb3786de521457418757e010c69", "patch": "@@ -345,9 +345,23 @@ pub fn check_crate(tcx: &ty::ctxt, trait_map: ty::TraitMap) {\n     time(time_passes, \"coherence checking\", (), |_|\n         coherence::check_coherence(&ccx));\n \n-    time(time_passes, \"type checking\", (), |_|\n+    time(time_passes, \"wf checking (old)\", (), |_|\n+        check::check_wf_old(&ccx));\n+\n+    time(time_passes, \"item-types checking\", (), |_|\n         check::check_item_types(&ccx));\n \n+    time(time_passes, \"item-bodies checking\", (), |_|\n+        check::check_item_bodies(&ccx));\n+\n+    time(time_passes, \"drop-impl checking\", (), |_|\n+        check::check_drop_impls(&ccx));\n+\n+    // Do this last so that if there are errors in the old code, they\n+    // get reported, and we don't get extra warnings.\n+    time(time_passes, \"wf checking (new)\", (), |_|\n+        check::check_wf_new(&ccx));\n+\n     check_for_entry_fn(&ccx);\n     tcx.sess.abort_if_errors();\n }"}, {"sha": "7968cc37090acffe1d09cc411bdd1c2fe813c5af", "filename": "src/test/compile-fail/where-clauses-not-parameter.rs", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ad47bd8a0f6f5284a8f937f5cd8a0a7e3df96991/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad47bd8a0f6f5284a8f937f5cd8a0a7e3df96991/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhere-clauses-not-parameter.rs?ref=ad47bd8a0f6f5284a8f937f5cd8a0a7e3df96991", "patch": "@@ -1,45 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn equal<T>(_: &T, _: &T) -> bool where isize : Eq {\n-    true //~^ ERROR cannot bound type `isize`, where clause bounds may only be attached\n-}\n-\n-// This should be fine involves a type parameter.\n-fn test<T: Eq>() -> bool where Option<T> : Eq {}\n-\n-// This should be rejected as well.\n-fn test2() -> bool where Option<isize> : Eq {}\n-//~^ ERROR cannot bound type `core::option::Option<isize>`, where clause bounds may\n-\n-#[derive(PartialEq)]\n-//~^ ERROR cannot bound type `isize`, where clause bounds\n-enum Foo<T> where isize : Eq { MkFoo(T) }\n-//~^ ERROR cannot bound type `isize`, where clause bounds\n-\n-fn test3<T: Eq>() -> bool where Option<Foo<T>> : Eq {}\n-\n-fn test4() -> bool where Option<Foo<isize>> : Eq {}\n-//~^ ERROR cannot bound type `core::option::Option<Foo<isize>>`, where clause bounds\n-\n-trait Baz<T> where isize : Eq {\n-    //~^ ERROR cannot bound type `isize`, where clause bounds may only\n-    fn baz(&self, t: T) where String : Eq; //~ ERROR cannot bound type `collections::string::String`\n-    //~^ ERROR cannot bound type `isize`, where clause\n-}\n-\n-impl Baz<isize> for isize where isize : Eq {\n-    //~^ ERROR cannot bound type `isize`, where clause bounds\n-    fn baz() where String : Eq {}\n-}\n-\n-fn main() {\n-    equal(&0, &0);\n-}"}]}