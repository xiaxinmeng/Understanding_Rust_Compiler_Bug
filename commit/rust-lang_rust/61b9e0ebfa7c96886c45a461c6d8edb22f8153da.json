{"sha": "61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxYjllMGViZmE3Yzk2ODg2YzQ1YTQ2MWM2ZDhlZGIyMmY4MTUzZGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-10T20:11:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-11T00:32:03Z"}, "message": "core: changes in response to #5656", "tree": {"sha": "f392a8f4119df4569328a228c994be2c4392d10a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f392a8f4119df4569328a228c994be2c4392d10a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "html_url": "https://github.com/rust-lang/rust/commit/61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49de82cdca2064a909d3104f4e5eccacb0425fd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/49de82cdca2064a909d3104f4e5eccacb0425fd0", "html_url": "https://github.com/rust-lang/rust/commit/49de82cdca2064a909d3104f4e5eccacb0425fd0"}], "stats": {"total": 705, "additions": 700, "deletions": 5}, "files": [{"sha": "dc6c80228dd74e7ee36248bd5c3c63ae3aef1c99", "filename": "src/libcore/condition.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcondition.rs?ref=61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "patch": "@@ -28,7 +28,7 @@ pub struct Condition<'self, T, U> {\n }\n \n pub impl<'self, T, U> Condition<'self, T, U> {\n-    fn trap(&self, h: &'self fn(T) -> U) -> Trap<'self, T, U> {\n+    fn trap(&'self self, h: &'self fn(T) -> U) -> Trap<'self, T, U> {\n         unsafe {\n             let p : *RustClosure = ::cast::transmute(&h);\n             let prev = task::local_data::local_data_get(self.key);"}, {"sha": "88c78aebfc5c7dbabb7a7196aa9903760c4d8119", "filename": "src/libcore/container.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "patch": "@@ -25,6 +25,7 @@ pub trait Mutable: Container {\n     fn clear(&mut self);\n }\n \n+#[cfg(stage0)]\n pub trait Map<K, V>: Mutable {\n     /// Return true if the map contains a value for the specified key\n     fn contains_key(&self, key: &K) -> bool;\n@@ -57,6 +58,41 @@ pub trait Map<K, V>: Mutable {\n     fn remove(&mut self, key: &K) -> bool;\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub trait Map<K, V>: Mutable {\n+    /// Return true if the map contains a value for the specified key\n+    fn contains_key(&self, key: &K) -> bool;\n+\n+    // Visits all keys and values\n+    fn each<'a>(&'a self, f: &fn(&K, &'a V) -> bool);\n+\n+    /// Visit all keys\n+    fn each_key(&self, f: &fn(&K) -> bool);\n+\n+    /// Visit all values\n+    fn each_value<'a>(&'a self, f: &fn(&'a V) -> bool);\n+\n+    /// Iterate over the map and mutate the contained values\n+    fn mutate_values(&mut self, f: &fn(&K, &mut V) -> bool);\n+\n+    /// Return a reference to the value corresponding to the key\n+    fn find<'a>(&'a self, key: &K) -> Option<&'a V>;\n+\n+    /// Return a mutable reference to the value corresponding to the key\n+    fn find_mut<'a>(&'a mut self, key: &K) -> Option<&'a mut V>;\n+\n+    /// Insert a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Return true if the key did\n+    /// not already exist in the map.\n+    fn insert(&mut self, key: K, value: V) -> bool;\n+\n+    /// Remove a key-value pair from the map. Return true if the key\n+    /// was present in the map, otherwise false.\n+    fn remove(&mut self, key: &K) -> bool;\n+}\n+\n pub trait Set<T>: Mutable {\n     /// Return true if the set contains a value\n     fn contains(&self, value: &T) -> bool;"}, {"sha": "2869c198ca2fc7882da5ee5edb946c07c5c400a7", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 171, "deletions": 2, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "patch": "@@ -186,6 +186,7 @@ priv impl<K:Hash + IterBytes + Eq,V> HashMap<K, V> {\n         }\n     }\n \n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn value_for_bucket(&self, idx: uint) -> &'self V {\n         match self.buckets[idx] {\n@@ -194,6 +195,18 @@ priv impl<K:Hash + IterBytes + Eq,V> HashMap<K, V> {\n         }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn value_for_bucket<'a>(&'a self, idx: uint) -> &'a V {\n+        match self.buckets[idx] {\n+            Some(ref bkt) => &bkt.value,\n+            None => fail!(~\"HashMap::find: internal logic error\"),\n+        }\n+    }\n+\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn mut_value_for_bucket(&mut self, idx: uint) -> &'self mut V {\n         match self.buckets[idx] {\n@@ -202,6 +215,17 @@ priv impl<K:Hash + IterBytes + Eq,V> HashMap<K, V> {\n         }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn mut_value_for_bucket<'a>(&'a mut self, idx: uint) -> &'a mut V {\n+        match self.buckets[idx] {\n+            Some(ref mut bkt) => &mut bkt.value,\n+            None => unreachable()\n+        }\n+    }\n+\n     /// Inserts the key value pair into the buckets.\n     /// Assumes that there will be a bucket.\n     /// True if there was no previous entry with that key\n@@ -307,6 +331,7 @@ impl<K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Visit all key-value pairs\n+    #[cfg(stage0)]\n     fn each(&self, blk: &fn(&'self K, &'self V) -> bool) {\n         for uint::range(0, self.buckets.len()) |i| {\n             for self.buckets[i].each |bucket| {\n@@ -317,19 +342,41 @@ impl<K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n         }\n     }\n \n+    /// Visit all key-value pairs\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each<'a>(&'a self, blk: &fn(&'a K, &'a V) -> bool) {\n+        for uint::range(0, self.buckets.len()) |i| {\n+            for self.buckets[i].each |bucket| {\n+                if !blk(&bucket.key, &bucket.value) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n     /// Visit all keys\n     fn each_key(&self, blk: &fn(k: &K) -> bool) {\n         self.each(|k, _| blk(k))\n     }\n \n     /// Visit all values\n+    #[cfg(stage0)]\n     fn each_value(&self, blk: &fn(v: &V) -> bool) {\n         self.each(|_, v| blk(v))\n     }\n \n+    /// Visit all values\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_value<'a>(&'a self, blk: &fn(v: &'a V) -> bool) {\n+        self.each(|_, v| blk(v))\n+    }\n+\n     /// Iterate over the map and mutate the contained values\n-    fn mutate_values(&mut self, blk: &fn(&'self K,\n-                          &'self mut V) -> bool) {\n+    fn mutate_values(&mut self, blk: &fn(&K, &mut V) -> bool) {\n         for uint::range(0, self.buckets.len()) |i| {\n             match self.buckets[i] {\n               Some(Bucket{key: ref key, value: ref mut value, _}) => {\n@@ -341,14 +388,27 @@ impl<K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n     }\n \n     /// Return a reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     fn find(&self, k: &K) -> Option<&'self V> {\n         match self.bucket_for_key(k) {\n             FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n             TableFull | FoundHole(_) => None,\n         }\n     }\n \n+    /// Return a reference to the value corresponding to the key\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find<'a>(&'a self, k: &K) -> Option<&'a V> {\n+        match self.bucket_for_key(k) {\n+            FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n+            TableFull | FoundHole(_) => None,\n+        }\n+    }\n+\n     /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     fn find_mut(&mut self, k: &K) -> Option<&'self mut V> {\n         let idx = match self.bucket_for_key(k) {\n             FoundEntry(idx) => idx,\n@@ -359,6 +419,20 @@ impl<K:Hash + IterBytes + Eq,V> Map<K, V> for HashMap<K, V> {\n         }\n     }\n \n+    /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find_mut<'a>(&'a mut self, k: &K) -> Option<&'a mut V> {\n+        let idx = match self.bucket_for_key(k) {\n+            FoundEntry(idx) => idx,\n+            TableFull | FoundHole(_) => return None\n+        };\n+        unsafe {  // FIXME(#4903)---requires flow-sensitive borrow checker\n+            Some(::cast::transmute_mut_region(self.mut_value_for_bucket(idx)))\n+        }\n+    }\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -431,6 +505,7 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, or insert\n     /// and return the value if it doesn't exist.\n+    #[cfg(stage0)]\n     fn find_or_insert(&mut self, k: K, v: V) -> &'self V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n@@ -459,8 +534,42 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n         }\n     }\n \n+    /// Return the value corresponding to the key in the map, or insert\n+    /// and return the value if it doesn't exist.\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find_or_insert<'a>(&'a mut self, k: K, v: V) -> &'a V {\n+        if self.size >= self.resize_at {\n+            // n.b.: We could also do this after searching, so\n+            // that we do not resize if this call to insert is\n+            // simply going to update a key in place.  My sense\n+            // though is that it's worse to have to search through\n+            // buckets to find the right spot twice than to just\n+            // resize in this corner case.\n+            self.expand();\n+        }\n+\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n+            TableFull => fail!(~\"Internal logic error\"),\n+            FoundEntry(idx) => idx,\n+            FoundHole(idx) => {\n+                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n+                                     value: v});\n+                self.size += 1;\n+                idx\n+            },\n+        };\n+\n+        unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+            ::cast::transmute_region(self.value_for_bucket(idx))\n+        }\n+    }\n+\n     /// Return the value corresponding to the key in the map, or create,\n     /// insert, and return a new value if it doesn't exist.\n+    #[cfg(stage0)]\n     fn find_or_insert_with(&mut self, k: K, f: &fn(&K) -> V) -> &'self V {\n         if self.size >= self.resize_at {\n             // n.b.: We could also do this after searching, so\n@@ -490,6 +599,40 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n         }\n     }\n \n+    /// Return the value corresponding to the key in the map, or create,\n+    /// insert, and return a new value if it doesn't exist.\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find_or_insert_with<'a>(&'a mut self, k: K, f: &fn(&K) -> V) -> &'a V {\n+        if self.size >= self.resize_at {\n+            // n.b.: We could also do this after searching, so\n+            // that we do not resize if this call to insert is\n+            // simply going to update a key in place.  My sense\n+            // though is that it's worse to have to search through\n+            // buckets to find the right spot twice than to just\n+            // resize in this corner case.\n+            self.expand();\n+        }\n+\n+        let hash = k.hash_keyed(self.k0, self.k1) as uint;\n+        let idx = match self.bucket_for_key_with_hash(hash, &k) {\n+            TableFull => fail!(~\"Internal logic error\"),\n+            FoundEntry(idx) => idx,\n+            FoundHole(idx) => {\n+                let v = f(&k);\n+                self.buckets[idx] = Some(Bucket{hash: hash, key: k,\n+                                     value: v});\n+                self.size += 1;\n+                idx\n+            },\n+        };\n+\n+        unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+            ::cast::transmute_region(self.value_for_bucket(idx))\n+        }\n+    }\n+\n     fn consume(&mut self, f: &fn(K, V)) {\n         let mut buckets = ~[];\n         self.buckets <-> buckets;\n@@ -506,13 +649,24 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn get(&self, k: &K) -> &'self V {\n         match self.find(k) {\n             Some(v) => v,\n             None => fail!(fmt!(\"No entry found for key: %?\", k)),\n         }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get<'a>(&'a self, k: &K) -> &'a V {\n+        match self.find(k) {\n+            Some(v) => v,\n+            None => fail!(fmt!(\"No entry found for key: %?\", k)),\n+        }\n+    }\n+\n     /// Return true if the map contains a value for the specified key,\n     /// using equivalence\n     fn contains_key_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, key: &Q)\n@@ -525,13 +679,28 @@ pub impl<K: Hash + IterBytes + Eq, V> HashMap<K, V> {\n \n     /// Return the value corresponding to the key in the map, using\n     /// equivalence\n+    #[cfg(stage0)]\n     fn find_equiv<Q:Hash + IterBytes + Equiv<K>>(&self, k: &Q)\n                                               -> Option<&'self V> {\n         match self.bucket_for_key_equiv(k) {\n             FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n             TableFull | FoundHole(_) => None,\n         }\n     }\n+\n+    /// Return the value corresponding to the key in the map, using\n+    /// equivalence\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn find_equiv<'a, Q:Hash + IterBytes + Equiv<K>>(\n+        &'a self, k: &Q) -> Option<&'a V>\n+    {\n+        match self.bucket_for_key_equiv(k) {\n+            FoundEntry(idx) => Some(self.value_for_bucket(idx)),\n+            TableFull | FoundHole(_) => None,\n+        }\n+    }\n }\n \n impl<K:Hash + IterBytes + Eq,V:Eq> Eq for HashMap<K, V> {"}, {"sha": "9b7276879c1232f09622894a4e37e46052ea6b39", "filename": "src/libcore/option.rs", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "patch": "@@ -101,22 +101,41 @@ impl<T: Copy + Add<T,T>> Add<Option<T>, Option<T>> for Option<T> {\n \n impl<T> BaseIter<T> for Option<T> {\n     /// Performs an operation on the contained value by reference\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn each(&self, f: &fn(x: &'self T) -> bool) {\n         match *self { None => (), Some(ref t) => { f(t); } }\n     }\n \n+    /// Performs an operation on the contained value by reference\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn each<'a>(&'a self, f: &fn(x: &'a T) -> bool) {\n+        match *self { None => (), Some(ref t) => { f(t); } }\n+    }\n+\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> {\n         if self.is_some() { Some(1) } else { Some(0) }\n     }\n }\n \n impl<T> MutableIter<T> for Option<T> {\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn each_mut(&mut self, f: &fn(&'self mut T) -> bool) {\n         match *self { None => (), Some(ref mut t) => { f(t); } }\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn each_mut<'a>(&'a mut self, f: &fn(&'a mut T) -> bool) {\n+        match *self { None => (), Some(ref mut t) => { f(t); } }\n+    }\n }\n \n impl<A> ExtendedIter<A> for Option<A> {\n@@ -182,17 +201,40 @@ pub impl<T> Option<T> {\n      * Update an optional value by optionally running its content by reference\n      * through a function that returns an option.\n      */\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn chain_ref<U>(&self, f: &fn(x: &'self T) -> Option<U>) -> Option<U> {\n         match *self { Some(ref x) => f(x), None => None }\n     }\n \n+    /**\n+     * Update an optional value by optionally running its content by reference\n+     * through a function that returns an option.\n+     */\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn chain_ref<'a, U>(&'a self, f: &fn(x: &'a T) -> Option<U>) -> Option<U> {\n+        match *self { Some(ref x) => f(x), None => None }\n+    }\n+\n     /// Maps a `some` value from one type to another by reference\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn map<U>(&self, f: &fn(&'self T) -> U) -> Option<U> {\n         match *self { Some(ref x) => Some(f(x)), None => None }\n     }\n \n+    /// Maps a `some` value from one type to another by reference\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn map<'a, U>(&self, f: &fn(&'a T) -> U) -> Option<U> {\n+        match *self { Some(ref x) => Some(f(x)), None => None }\n+    }\n+\n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n     #[inline(always)]\n@@ -201,11 +243,21 @@ pub impl<T> Option<T> {\n     }\n \n     /// Applies a function to the contained value or returns a default\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn map_default<U>(&self, def: U, f: &fn(&'self T) -> U) -> U {\n         match *self { None => def, Some(ref t) => f(t) }\n     }\n \n+    /// Applies a function to the contained value or returns a default\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn map_default<'a, U>(&'a self, def: U, f: &fn(&'a T) -> U) -> U {\n+        match *self { None => def, Some(ref t) => f(t) }\n+    }\n+\n     /// As `map_default`, but consumes the option and gives `f`\n     /// ownership to avoid copying.\n     #[inline(always)]\n@@ -244,13 +296,39 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn get_ref(&self) -> &'self T {\n         match *self {\n           Some(ref x) => x,\n           None => fail!(~\"option::get_ref none\")\n         }\n     }\n \n+    /**\n+    Gets an immutable reference to the value inside an option.\n+\n+    # Failure\n+\n+    Fails if the value equals `None`\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged\n+    (calling `get` on `None` is akin to dereferencing a null pointer).\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n+     */\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get_ref<'a>(&'a self) -> &'a T {\n+        match *self {\n+          Some(ref x) => x,\n+          None => fail!(~\"option::get_ref none\")\n+        }\n+    }\n+\n     /**\n     Gets a mutable reference to the value inside an option.\n \n@@ -266,13 +344,39 @@ pub impl<T> Option<T> {\n     case explicitly.\n      */\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn get_mut_ref(&mut self) -> &'self mut T {\n         match *self {\n           Some(ref mut x) => x,\n           None => fail!(~\"option::get_mut_ref none\")\n         }\n     }\n \n+    /**\n+    Gets a mutable reference to the value inside an option.\n+\n+    # Failure\n+\n+    Fails if the value equals `None`\n+\n+    # Safety note\n+\n+    In general, because this function may fail, its use is discouraged\n+    (calling `get` on `None` is akin to dereferencing a null pointer).\n+    Instead, prefer to use pattern matching and handle the `None`\n+    case explicitly.\n+     */\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get_mut_ref<'a>(&'a mut self) -> &'a mut T {\n+        match *self {\n+          Some(ref mut x) => x,\n+          None => fail!(~\"option::get_mut_ref none\")\n+        }\n+    }\n+\n     #[inline(always)]\n     fn unwrap(self) -> T {\n         /*!"}, {"sha": "58e281c29c60565f2e5d640ed2106dae8ca34fbe", "filename": "src/libcore/result.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "patch": "@@ -226,9 +226,16 @@ pub fn map_err<T:Copy,E,F:Copy>(res: &Result<T, E>, op: &fn(&E) -> F)\n }\n \n pub impl<T, E> Result<T, E> {\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn get_ref(&self) -> &'self T { get_ref(self) }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn get_ref<'a>(&'a self) -> &'a T { get_ref(self) }\n+\n     #[inline(always)]\n     fn is_ok(&self) -> bool { is_ok(self) }\n "}, {"sha": "6a7c3970c0091341c001ef1b36362c3ec8c3d266", "filename": "src/libcore/rt/rtio.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frtio.rs?ref=61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "patch": "@@ -22,7 +22,12 @@ pub trait EventLoop {\n     fn run(&mut self);\n     fn callback(&mut self, ~fn());\n     /// The asynchronous I/O services. Not all event loops may provide one\n+    #[cfg(stage0)]\n     fn io(&mut self) -> Option<&'self mut IoFactoryObject>;\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject>;\n }\n \n pub trait IoFactory {"}, {"sha": "25f446fb86d19169e8b099791f82370c63e65eaf", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "patch": "@@ -272,6 +272,7 @@ pub impl Scheduler {\n \n     // XXX: Hack. This should return &'self mut but I don't know how to\n     // make the borrowcheck happy\n+    #[cfg(stage0)]\n     fn task_from_last_cleanup_job(&mut self) -> &mut Task {\n         assert!(!self.cleanup_jobs.is_empty());\n         let last_job: &'self mut CleanupJob = &mut self.cleanup_jobs[0];\n@@ -285,6 +286,25 @@ pub impl Scheduler {\n         // borrows\n         return unsafe { transmute::<&Task, &mut Task>(last_task) };\n     }\n+\n+    // XXX: Hack. This should return &'self mut but I don't know how to\n+    // make the borrowcheck happy\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn task_from_last_cleanup_job<'a>(&'a mut self) -> &mut Task {\n+        assert!(!self.cleanup_jobs.is_empty());\n+        let last_job: &'a mut CleanupJob = &mut self.cleanup_jobs[0];\n+        let last_task: &'a Task = match last_job {\n+            &RescheduleTask(~ref task) => task,\n+            &RecycleTask(~ref task) => task,\n+            &GiveTask(~ref task, _) => task,\n+        };\n+        // XXX: Pattern matching mutable pointers above doesn't work\n+        // because borrowck thinks the three patterns are conflicting\n+        // borrows\n+        return unsafe { transmute::<&Task, &mut Task>(last_task) };\n+    }\n }\n \n static TASK_MIN_STACK_SIZE: uint = 10000000; // XXX: Too much stack\n@@ -354,6 +374,7 @@ impl ThreadLocalScheduler {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn get_scheduler(&mut self) -> &'self mut Scheduler {\n         unsafe {\n             let key = match self { &ThreadLocalScheduler(key) => key };\n@@ -370,6 +391,25 @@ impl ThreadLocalScheduler {\n         }\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn get_scheduler<'a>(&'a mut self) -> &'a mut Scheduler {\n+        unsafe {\n+            let key = match self { &ThreadLocalScheduler(key) => key };\n+            let mut value: *mut c_void = tls::get(key);\n+            assert!(value.is_not_null());\n+            {\n+                let value_ptr = &mut value;\n+                let sched: &mut ~Scheduler = {\n+                    transmute::<&mut *mut c_void, &mut ~Scheduler>(value_ptr)\n+                };\n+                let sched: &mut Scheduler = &mut **sched;\n+                return sched;\n+            }\n+        }\n+    }\n+\n     fn take_scheduler(&mut self) -> ~Scheduler {\n         unsafe {\n             let key = match self { &ThreadLocalScheduler(key) => key };"}, {"sha": "7162ed27a9d77df82dcbf9062abb8c99db1b7e5a", "filename": "src/libcore/rt/uvio.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Frt%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Frt%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuvio.rs?ref=61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "patch": "@@ -67,9 +67,17 @@ impl EventLoop for UvEventLoop {\n         }\n     }\n \n+    #[cfg(stage0)]\n     fn io(&mut self) -> Option<&'self mut IoFactoryObject> {\n         Some(&mut self.uvio)\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn io<'a>(&'a mut self) -> Option<&'a mut IoFactoryObject> {\n+        Some(&mut self.uvio)\n+    }\n }\n \n #[test]\n@@ -89,9 +97,17 @@ fn test_callback_run_once() {\n pub struct UvIoFactory(Loop);\n \n pub impl UvIoFactory {\n+    #[cfg(stage0)]\n     fn uv_loop(&mut self) -> &'self mut Loop {\n         match self { &UvIoFactory(ref mut ptr) => ptr }\n     }\n+\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn uv_loop<'a>(&'a mut self) -> &'a mut Loop {\n+        match self { &UvIoFactory(ref mut ptr) => ptr }\n+    }\n }\n \n impl IoFactory for UvIoFactory {"}, {"sha": "e4ee430cdda64dc2d4f2f23b4512ab6b0455a667", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "patch": "@@ -39,7 +39,7 @@ use result::Result;\n use comm::{stream, Chan, GenericChan, GenericPort, Port};\n use prelude::*;\n use result;\n-use task::rt::{task_id, sched_id, rust_task};\n+use task::rt::{task_id, sched_id};\n use util;\n use util::replace;\n use unstable::finally::Finally;"}, {"sha": "f4e9ddbdd90a11bc67bb0a1190353af13eb823f8", "filename": "src/libcore/trie.rs", "status": "modified", "additions": 96, "deletions": 1, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "patch": "@@ -56,10 +56,20 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Visit all key-value pairs in order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&uint, &'self T) -> bool) {\n         self.root.each(f);\n     }\n \n+    /// Visit all key-value pairs in order\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) {\n+        self.root.each(f);\n+    }\n+\n     /// Visit all keys in order\n     #[inline(always)]\n     fn each_key(&self, f: &fn(&uint) -> bool) {\n@@ -68,17 +78,28 @@ impl<T> Map<uint, T> for TrieMap<T> {\n \n     /// Visit all values in order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_value(&self, f: &fn(&T) -> bool) {\n         self.each(|_, v| f(v))\n     }\n \n+    /// Visit all values in order\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_value<'a>(&'a self, f: &fn(&'a T) -> bool) {\n+        self.each(|_, v| f(v))\n+    }\n+\n     /// Iterate over the map and mutate the contained values\n     #[inline(always)]\n     fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) {\n         self.root.mutate_values(f);\n     }\n \n     /// Return a reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     #[inline(hint)]\n     fn find(&self, key: &uint) -> Option<&'self T> {\n         let mut node: &'self TrieNode<T> = &self.root;\n@@ -99,12 +120,46 @@ impl<T> Map<uint, T> for TrieMap<T> {\n         }\n     }\n \n+    /// Return a reference to the value corresponding to the key\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(hint)]\n+    fn find<'a>(&'a self, key: &uint) -> Option<&'a T> {\n+        let mut node: &'a TrieNode<T> = &self.root;\n+        let mut idx = 0;\n+        loop {\n+            match node.children[chunk(*key, idx)] {\n+              Internal(ref x) => node = &**x,\n+              External(stored, ref value) => {\n+                if stored == *key {\n+                    return Some(value)\n+                } else {\n+                    return None\n+                }\n+              }\n+              Nothing => return None\n+            }\n+            idx += 1;\n+        }\n+    }\n+\n     /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(stage0)]\n     #[inline(always)]\n     fn find_mut(&mut self, key: &uint) -> Option<&'self mut T> {\n         find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n     }\n \n+    /// Return a mutable reference to the value corresponding to the key\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    #[inline(always)]\n+    fn find_mut<'a>(&'a mut self, key: &uint) -> Option<&'a mut T> {\n+        find_mut(&mut self.root.children[chunk(*key, 0)], *key, 1)\n+    }\n+\n     /// Insert a key-value pair into the map. An existing value for a\n     /// key is replaced by the new value. Return true if the key did\n     /// not already exist in the map.\n@@ -138,10 +193,20 @@ pub impl<T> TrieMap<T> {\n \n     /// Visit all key-value pairs in reverse order\n     #[inline(always)]\n+    #[cfg(stage0)]\n     fn each_reverse(&self, f: &fn(&uint, &'self T) -> bool) {\n         self.root.each_reverse(f);\n     }\n \n+    /// Visit all key-value pairs in reverse order\n+    #[inline(always)]\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) {\n+        self.root.each_reverse(f);\n+    }\n+\n     /// Visit all keys in reverse order\n     #[inline(always)]\n     fn each_key_reverse(&self, f: &fn(&uint) -> bool) {\n@@ -233,6 +298,7 @@ impl<T> TrieNode<T> {\n }\n \n impl<T> TrieNode<T> {\n+    #[cfg(stage0)]\n     fn each(&self, f: &fn(&uint, &'self T) -> bool) -> bool {\n         for uint::range(0, self.children.len()) |idx| {\n             match self.children[idx] {\n@@ -244,6 +310,21 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+        for uint::range(0, self.children.len()) |idx| {\n+            match self.children[idx] {\n+                Internal(ref x) => if !x.each(f) { return false },\n+                External(k, ref v) => if !f(&k, v) { return false },\n+                Nothing => ()\n+            }\n+        }\n+        true\n+    }\n+\n+    #[cfg(stage0)]\n     fn each_reverse(&self, f: &fn(&uint, &'self T) -> bool) -> bool {\n         for uint::range_rev(self.children.len(), 0) |idx| {\n             match self.children[idx - 1] {\n@@ -255,7 +336,21 @@ impl<T> TrieNode<T> {\n         true\n     }\n \n-    fn mutate_values(&mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n+    #[cfg(stage1)]\n+    #[cfg(stage2)]\n+    #[cfg(stage3)]\n+    fn each_reverse<'a>(&'a self, f: &fn(&uint, &'a T) -> bool) -> bool {\n+        for uint::range_rev(self.children.len(), 0) |idx| {\n+            match self.children[idx - 1] {\n+                Internal(ref x) => if !x.each_reverse(f) { return false },\n+                External(k, ref v) => if !f(&k, v) { return false },\n+                Nothing => ()\n+            }\n+        }\n+        true\n+    }\n+\n+    fn mutate_values<'a>(&'a mut self, f: &fn(&uint, &mut T) -> bool) -> bool {\n         for vec::each_mut(self.children) |child| {\n             match *child {\n                 Internal(ref mut x) => if !x.mutate_values(f) {"}, {"sha": "8e908435f3543fff15fea09f69d6d762f9ee5b5d", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "patch": "@@ -56,11 +56,13 @@ impl<T:Clone,U:Clone> Clone for (T, U) {\n     }\n }\n \n+#[cfg(stage0)]\n pub trait ImmutableTuple<T, U> {\n     fn first_ref(&self) -> &'self T;\n     fn second_ref(&self) -> &'self U;\n }\n \n+#[cfg(stage0)]\n impl<T, U> ImmutableTuple<T, U> for (T, U) {\n     #[inline(always)]\n     fn first_ref(&self) -> &'self T {\n@@ -76,6 +78,32 @@ impl<T, U> ImmutableTuple<T, U> for (T, U) {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub trait ImmutableTuple<T, U> {\n+    fn first_ref<'a>(&'a self) -> &'a T;\n+    fn second_ref<'a>(&'a self) -> &'a U;\n+}\n+\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<T, U> ImmutableTuple<T, U> for (T, U) {\n+    #[inline(always)]\n+    fn first_ref<'a>(&'a self) -> &'a T {\n+        match *self {\n+            (ref t, _) => t,\n+        }\n+    }\n+    #[inline(always)]\n+    fn second_ref<'a>(&'a self) -> &'a U {\n+        match *self {\n+            (_, ref u) => u,\n+        }\n+    }\n+}\n+\n pub trait ExtendedTupleOps<A,B> {\n     fn zip(&self) -> ~[(A, B)];\n     fn map<C>(&self, f: &fn(a: &A, b: &B) -> C) -> ~[C];"}, {"sha": "7940502d27e48bd28653d1cfe5dbf9756870ca12", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61b9e0ebfa7c96886c45a461c6d8edb22f8153da/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=61b9e0ebfa7c96886c45a461c6d8edb22f8153da", "patch": "@@ -1763,6 +1763,7 @@ impl<'self,T:Copy> CopyableVector<T> for &'self const [T] {\n     }\n }\n \n+#[cfg(stage0)]\n pub trait ImmutableVector<T> {\n     fn slice(&self, start: uint, end: uint) -> &'self [T];\n     fn head(&self) -> &'self T;\n@@ -1785,6 +1786,7 @@ pub trait ImmutableVector<T> {\n }\n \n /// Extension methods for vectors\n+#[cfg(stage0)]\n impl<'self,T> ImmutableVector<T> for &'self [T] {\n     /// Return a slice that points into another slice.\n     #[inline]\n@@ -1893,6 +1895,142 @@ impl<'self,T> ImmutableVector<T> for &'self [T] {\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+pub trait ImmutableVector<'self, T> {\n+    fn slice(&self, start: uint, end: uint) -> &'self [T];\n+    fn head(&self) -> &'self T;\n+    fn head_opt(&self) -> Option<&'self T>;\n+    fn tail(&self) -> &'self [T];\n+    fn tailn(&self, n: uint) -> &'self [T];\n+    fn init(&self) -> &'self [T];\n+    fn initn(&self, n: uint) -> &'self [T];\n+    fn last(&self) -> &'self T;\n+    fn last_opt(&self) -> Option<&'self T>;\n+    fn each_reverse(&self, blk: &fn(&T) -> bool);\n+    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool);\n+    fn foldr<U: Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U;\n+    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n+    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n+    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U];\n+    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n+    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n+    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n+}\n+\n+/// Extension methods for vectors\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n+    /// Return a slice that points into another slice.\n+    #[inline]\n+    fn slice(&self, start: uint, end: uint) -> &'self [T] {\n+        slice(*self, start, end)\n+    }\n+\n+    /// Returns the first element of a vector, failing if the vector is empty.\n+    #[inline]\n+    fn head(&self) -> &'self T { head(*self) }\n+\n+    /// Returns the first element of a vector\n+    #[inline]\n+    fn head_opt(&self) -> Option<&'self T> { head_opt(*self) }\n+\n+    /// Returns all but the first element of a vector\n+    #[inline]\n+    fn tail(&self) -> &'self [T] { tail(*self) }\n+\n+    /// Returns all but the first `n' elements of a vector\n+    #[inline]\n+    fn tailn(&self, n: uint) -> &'self [T] { tailn(*self, n) }\n+\n+    /// Returns all but the last elemnt of a vector\n+    #[inline]\n+    fn init(&self) -> &'self [T] { init(*self) }\n+\n+    /// Returns all but the last `n' elemnts of a vector\n+    #[inline]\n+    fn initn(&self, n: uint) -> &'self [T] { initn(*self, n) }\n+\n+    /// Returns the last element of a `v`, failing if the vector is empty.\n+    #[inline]\n+    fn last(&self) -> &'self T { last(*self) }\n+\n+    /// Returns the last element of a `v`, failing if the vector is empty.\n+    #[inline]\n+    fn last_opt(&self) -> Option<&'self T> { last_opt(*self) }\n+\n+    /// Iterates over a vector's elements in reverse.\n+    #[inline]\n+    fn each_reverse(&self, blk: &fn(&T) -> bool) {\n+        each_reverse(*self, blk)\n+    }\n+\n+    /// Iterates over a vector's elements and indices in reverse.\n+    #[inline]\n+    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) {\n+        eachi_reverse(*self, blk)\n+    }\n+\n+    /// Reduce a vector from right to left\n+    #[inline]\n+    fn foldr<U:Copy>(&self, z: U, p: &fn(t: &T, u: U) -> U) -> U {\n+        foldr(*self, z, p)\n+    }\n+\n+    /// Apply a function to each element of a vector and return the results\n+    #[inline]\n+    fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n+\n+    /**\n+     * Apply a function to the index and value of each element in the vector\n+     * and return the results\n+     */\n+    fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U] {\n+        mapi(*self, f)\n+    }\n+\n+    #[inline]\n+    fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U] {\n+        let mut r = ~[];\n+        let mut i = 0;\n+        while i < self.len() {\n+            r.push(f(&self[i]));\n+            i += 1;\n+        }\n+        r\n+    }\n+\n+    /**\n+     * Returns true if the function returns true for all elements.\n+     *\n+     *     If the vector is empty, true is returned.\n+     */\n+    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool {\n+        alli(*self, f)\n+    }\n+    /**\n+     * Apply a function to each element of a vector and return a concatenation\n+     * of each result vector\n+     */\n+    #[inline]\n+    fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U] {\n+        flat_map(*self, f)\n+    }\n+    /**\n+     * Apply a function to each element of a vector and return the results\n+     *\n+     * If function `f` returns `none` then that element is excluded from\n+     * the resulting vector.\n+     */\n+    #[inline]\n+    fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U] {\n+        filter_mapped(*self, f)\n+    }\n+}\n+\n pub trait ImmutableEqVector<T:Eq> {\n     fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     fn position_elem(&self, t: &T) -> Option<uint>;\n@@ -2353,14 +2491,26 @@ pub mod bytes {\n // ___________________________________________________________________________\n // ITERATION TRAIT METHODS\n \n+#[cfg(stage0)]\n impl<'self,A> iter::BaseIter<A> for &'self [A] {\n     #[inline(always)]\n     fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<'self,A> iter::BaseIter<A> for &'self [A] {\n+    #[inline(always)]\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n+    #[inline(always)]\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n // FIXME(#4148): This should be redundant\n+#[cfg(stage0)]\n impl<A> iter::BaseIter<A> for ~[A] {\n     #[inline(always)]\n     fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n@@ -2369,28 +2519,73 @@ impl<A> iter::BaseIter<A> for ~[A] {\n }\n \n // FIXME(#4148): This should be redundant\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<A> iter::BaseIter<A> for ~[A] {\n+    #[inline(always)]\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n+    #[inline(always)]\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n+// FIXME(#4148): This should be redundant\n+#[cfg(stage0)]\n impl<A> iter::BaseIter<A> for @[A] {\n     #[inline(always)]\n     fn each(&self, blk: &fn(v: &'self A) -> bool) { each(*self, blk) }\n     #[inline(always)]\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n+// FIXME(#4148): This should be redundant\n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<A> iter::BaseIter<A> for @[A] {\n+    #[inline(always)]\n+    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) { each(*self, blk) }\n+    #[inline(always)]\n+    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n+#[cfg(stage0)]\n impl<'self,A> iter::MutableIter<A> for &'self mut [A] {\n     #[inline(always)]\n     fn each_mut(&mut self, blk: &fn(v: &'self mut A) -> bool) {\n         each_mut(*self, blk)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<'self,A> iter::MutableIter<A> for &'self mut [A] {\n+    #[inline(always)]\n+    fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n+        each_mut(*self, blk)\n+    }\n+}\n+\n // FIXME(#4148): This should be redundant\n+#[cfg(stage0)]\n impl<A> iter::MutableIter<A> for ~[A] {\n     #[inline(always)]\n     fn each_mut(&mut self, blk: &fn(v: &'self mut A) -> bool) {\n         each_mut(*self, blk)\n     }\n }\n \n+#[cfg(stage1)]\n+#[cfg(stage2)]\n+#[cfg(stage3)]\n+impl<A> iter::MutableIter<A> for ~[A] {\n+    #[inline(always)]\n+    fn each_mut<'a>(&'a mut self, blk: &fn(v: &'a mut A) -> bool) {\n+        each_mut(*self, blk)\n+    }\n+}\n+\n // FIXME(#4148): This should be redundant\n impl<A> iter::MutableIter<A> for @mut [A] {\n     #[inline(always)]"}]}