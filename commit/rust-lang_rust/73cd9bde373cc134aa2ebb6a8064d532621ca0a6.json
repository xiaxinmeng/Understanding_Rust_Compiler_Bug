{"sha": "73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczY2Q5YmRlMzczY2MxMzRhYTJlYmI2YTgwNjRkNTMyNjIxY2EwYTY=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertaylorj@gmail.com", "date": "2017-04-10T07:00:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-04-30T21:03:30Z"}, "message": "introduce per-fn RegionMaps\n\nInstead of requesting the region maps for the entire crate, request for\na given item etc. Several bits of code were modified to take\n`&RegionMaps` as input (e.g., the `resolve_regions_and_report_errors()`\nfunction). I am not totally happy with this setup -- I *think* I'd\nrather have the region maps be part of typeck tables -- but at least the\n`RegionMaps` works in a \"parallel\" way to `FreeRegionMap`, so it's not\ntoo bad. Given that I expect a lot of this code to go away with NLL, I\ndidn't want to invest *too* much energy tweaking it.", "tree": {"sha": "c27699bff217136b907b85b1cd76d6eba7089f18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c27699bff217136b907b85b1cd76d6eba7089f18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "html_url": "https://github.com/rust-lang/rust/commit/73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7dc39dbf095f04839b57a1e34afc6ab29d905d3", "html_url": "https://github.com/rust-lang/rust/commit/c7dc39dbf095f04839b57a1e34afc6ab29d905d3"}], "stats": {"total": 725, "additions": 422, "deletions": 303}, "files": [{"sha": "a8ad49c6582d4f14cc56311bcec6c57716a53d87", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -15,9 +15,11 @@ use syntax::ast;\n use syntax::ptr::P;\n \n use hir::{self, PatKind};\n+use hir::def_id::DefId;\n \n struct CFGBuilder<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    owner_def_id: DefId,\n     tables: &'a ty::TypeckTables<'tcx>,\n     graph: CFGGraph,\n     fn_exit: CFGIndex,\n@@ -56,6 +58,7 @@ pub fn construct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let mut cfg_builder = CFGBuilder {\n         tcx: tcx,\n+        owner_def_id,\n         tables: tables,\n         graph: graph,\n         fn_exit: fn_exit,\n@@ -585,9 +588,10 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n         let mut data = CFGEdgeData { exiting_scopes: vec![] };\n         let mut scope = self.tcx.node_extent(from_expr.id);\n         let target_scope = self.tcx.node_extent(scope_id);\n+        let region_maps = self.tcx.region_maps(self.owner_def_id);\n         while scope != target_scope {\n             data.exiting_scopes.push(scope.node_id());\n-            scope = self.tcx.region_maps().encl_scope(scope);\n+            scope = region_maps.encl_scope(scope);\n         }\n         self.graph.add_edge(from_index, to_index, data);\n     }"}, {"sha": "63a4e6196a2e9d8be4c14bc282c71f2631d9c37c", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -56,7 +56,7 @@ pub enum DepNode<D: Clone + Debug> {\n     WorkProduct(Arc<WorkProductId>),\n \n     // Represents different phases in the compiler.\n-    RegionResolveCrate,\n+    RegionMaps(D),\n     Coherence,\n     Resolve,\n     CoherenceCheckTrait(D),\n@@ -197,7 +197,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             BorrowCheckKrate => Some(BorrowCheckKrate),\n             MirKrate => Some(MirKrate),\n             TypeckBodiesKrate => Some(TypeckBodiesKrate),\n-            RegionResolveCrate => Some(RegionResolveCrate),\n             Coherence => Some(Coherence),\n             Resolve => Some(Resolve),\n             Variance => Some(Variance),\n@@ -223,6 +222,7 @@ impl<D: Clone + Debug> DepNode<D> {\n                 def_ids.map(MirShim)\n             }\n             BorrowCheck(ref d) => op(d).map(BorrowCheck),\n+            RegionMaps(ref d) => op(d).map(RegionMaps),\n             RvalueCheck(ref d) => op(d).map(RvalueCheck),\n             TransCrateItem(ref d) => op(d).map(TransCrateItem),\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),"}, {"sha": "3e610dd3c0d87a74eda2f237177080f37a1b9b24", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -39,7 +39,7 @@ use syntax::codemap::Spanned;\n use syntax_pos::Span;\n use hir::*;\n use hir::def::Def;\n-use hir::map::Map;\n+use hir::map::{self, Map};\n use super::itemlikevisit::DeepVisitor;\n \n use std::cmp;\n@@ -140,6 +140,23 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n pub trait Visitor<'v> : Sized {\n+    /// Invokes the suitable visitor method for the given `Node`\n+    /// extracted from the hir map.\n+    fn visit_hir_map_node(&mut self, node: map::Node<'v>) {\n+        match node {\n+            map::NodeItem(a) => self.visit_item(a),\n+            map::NodeForeignItem(a) => self.visit_foreign_item(a),\n+            map::NodeTraitItem(a) => self.visit_trait_item(a),\n+            map::NodeImplItem(a) => self.visit_impl_item(a),\n+            map::NodeExpr(a) => self.visit_expr(a),\n+            map::NodeStmt(a) => self.visit_stmt(a),\n+            map::NodeTy(a) => self.visit_ty(a),\n+            map::NodePat(a) => self.visit_pat(a),\n+            map::NodeBlock(a) => self.visit_block(a),\n+            _ => bug!(\"Visitor::visit_hir_map_node() not yet impl for node `{:?}`\", node)\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // Nested items.\n "}, {"sha": "cae5c5011ce7e64a9851d4d75aa11252479e490a", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -572,6 +572,18 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    /// Check if the node is a non-closure function item\n+    pub fn is_fn(&self, id: NodeId) -> bool {\n+        let entry = if let Some(id) = self.find_entry(id) { id } else { return false };\n+\n+        match entry {\n+            EntryItem(_, &Item { node: ItemFn(..), .. }) |\n+            EntryTraitItem(_, &TraitItem { node: TraitItemKind::Method(..), .. }) |\n+            EntryImplItem(_, &ImplItem { node: ImplItemKind::Method(..), .. }) => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// If there is some error when walking the parents (e.g., a node does not\n     /// have a parent in the map or a node can't be found), then we return the\n     /// last good node id we found. Note that reaching the crate root (id == 0),"}, {"sha": "e91af21c6db2c3d7acc6085b0aff8c13afb61a2b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -20,7 +20,8 @@ pub use self::region_inference::{GenericKind, VerifyBound};\n \n use hir::def_id::DefId;\n use hir;\n-use middle::free_region::FreeRegionMap;\n+use middle::free_region::{FreeRegionMap, RegionRelations};\n+use middle::region::RegionMaps;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::lang_items;\n@@ -1322,9 +1323,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn resolve_regions_and_report_errors(&self,\n-                                             free_regions: &FreeRegionMap<'tcx>,\n-                                             subject_node_id: ast::NodeId) {\n-        let errors = self.region_vars.resolve_regions(free_regions, subject_node_id);\n+                                             region_context: DefId,\n+                                             region_map: &RegionMaps<'tcx>,\n+                                             free_regions: &FreeRegionMap<'tcx>) {\n+        let region_rels = RegionRelations::new(self.tcx,\n+                                               region_context,\n+                                               region_map,\n+                                               free_regions);\n+        let errors = self.region_vars.resolve_regions(&region_rels);\n         if !self.is_tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors\n             // altogether if other errors have been reported while"}, {"sha": "c48b8f610a2b735eea07a629d42b5d9e38d926d0", "filename": "src/librustc/infer/region_inference/graphviz.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -18,7 +18,9 @@\n /// For clarity, rename the graphviz crate locally to dot.\n use graphviz as dot;\n \n-use ty::{self, TyCtxt};\n+use hir::def_id::DefIndex;\n+use ty;\n+use middle::free_region::RegionRelations;\n use middle::region::CodeExtent;\n use super::Constraint;\n use infer::SubregionOrigin;\n@@ -32,7 +34,6 @@ use std::fs::File;\n use std::io;\n use std::io::prelude::*;\n use std::sync::atomic::{AtomicBool, Ordering};\n-use syntax::ast;\n \n fn print_help_message() {\n     println!(\"\\\n@@ -55,18 +56,18 @@ graphs will be printed.                                                     \\n\\\n \n pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n     region_vars: &RegionVarBindings<'a, 'gcx, 'tcx>,\n-    subject_node: ast::NodeId)\n+    region_rels: &RegionRelations<'a, 'gcx, 'tcx>)\n {\n-    let tcx = region_vars.tcx;\n+    let context = region_rels.context;\n \n     if !region_vars.tcx.sess.opts.debugging_opts.print_region_graph {\n         return;\n     }\n \n     let requested_node = env::var(\"RUST_REGION_GRAPH_NODE\")\n-        .ok().and_then(|s| s.parse().map(ast::NodeId::new).ok());\n+        .ok().and_then(|s| s.parse().map(DefIndex::new).ok());\n \n-    if requested_node.is_some() && requested_node != Some(subject_node) {\n+    if requested_node.is_some() && requested_node != Some(context.index) {\n         return;\n     }\n \n@@ -98,7 +99,7 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n             let mut new_str = String::new();\n             for c in output_template.chars() {\n                 if c == '%' {\n-                    new_str.push_str(&subject_node.to_string());\n+                    new_str.push_str(&context.index.as_usize().to_string());\n                 } else {\n                     new_str.push(c);\n                 }\n@@ -110,7 +111,7 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n     };\n \n     let constraints = &*region_vars.constraints.borrow();\n-    match dump_region_constraints_to(tcx, constraints, &output_path) {\n+    match dump_region_constraints_to(region_rels, constraints, &output_path) {\n         Ok(()) => {}\n         Err(e) => {\n             let msg = format!(\"io error dumping region constraints: {}\", e);\n@@ -120,8 +121,8 @@ pub fn maybe_print_constraints_for<'a, 'gcx, 'tcx>(\n }\n \n struct ConstraintGraph<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     graph_name: String,\n+    region_rels: &'a RegionRelations<'a, 'gcx, 'tcx>,\n     map: &'a FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>,\n     node_ids: FxHashMap<Node<'tcx>, usize>,\n }\n@@ -140,8 +141,8 @@ enum Edge<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-           name: String,\n+    fn new(name: String,\n+           region_rels: &'a RegionRelations<'a, 'gcx, 'tcx>,\n            map: &'a ConstraintMap<'tcx>)\n            -> ConstraintGraph<'a, 'gcx, 'tcx> {\n         let mut i = 0;\n@@ -159,17 +160,17 @@ impl<'a, 'gcx, 'tcx> ConstraintGraph<'a, 'gcx, 'tcx> {\n                 add_node(n2);\n             }\n \n-            tcx.region_maps().each_encl_scope(|sub, sup| {\n+            region_rels.region_maps.each_encl_scope(|sub, sup| {\n                 add_node(Node::Region(ty::ReScope(sub)));\n                 add_node(Node::Region(ty::ReScope(sup)));\n             });\n         }\n \n         ConstraintGraph {\n-            tcx: tcx,\n+            map,\n+            node_ids,\n+            region_rels,\n             graph_name: name,\n-            map: map,\n-            node_ids: node_ids,\n         }\n     }\n }\n@@ -245,7 +246,7 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n     fn edges(&self) -> dot::Edges<Edge<'tcx>> {\n         debug!(\"constraint graph has {} edges\", self.map.len());\n         let mut v: Vec<_> = self.map.keys().map(|e| Edge::Constraint(*e)).collect();\n-        self.tcx.region_maps().each_encl_scope(|sub, sup| v.push(Edge::EnclScope(sub, sup)));\n+        self.region_rels.region_maps.each_encl_scope(|sub, sup| v.push(Edge::EnclScope(sub, sup)));\n         debug!(\"region graph has {} edges\", v.len());\n         Cow::Owned(v)\n     }\n@@ -263,14 +264,14 @@ impl<'a, 'gcx, 'tcx> dot::GraphWalk<'a> for ConstraintGraph<'a, 'gcx, 'tcx> {\n \n pub type ConstraintMap<'tcx> = FxHashMap<Constraint<'tcx>, SubregionOrigin<'tcx>>;\n \n-fn dump_region_constraints_to<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+fn dump_region_constraints_to<'a, 'gcx, 'tcx>(region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n                                               map: &ConstraintMap<'tcx>,\n                                               path: &str)\n                                               -> io::Result<()> {\n     debug!(\"dump_region_constraints map (len: {}) path: {}\",\n            map.len(),\n            path);\n-    let g = ConstraintGraph::new(tcx, format!(\"region_constraints\"), map);\n+    let g = ConstraintGraph::new(format!(\"region_constraints\"), region_rels, map);\n     debug!(\"dump_region_constraints calling render\");\n     let mut v = Vec::new();\n     dot::render(&g, &mut v).unwrap();"}, {"sha": "fb699bbd2d25f90d194d7e48401e67911777798f", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -22,7 +22,7 @@ use super::unify_key;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use rustc_data_structures::unify::{self, UnificationTable};\n-use middle::free_region::FreeRegionMap;\n+use middle::free_region::RegionRelations;\n use ty::{self, Ty, TyCtxt};\n use ty::{Region, RegionVid};\n use ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound, ReErased};\n@@ -33,7 +33,6 @@ use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::fmt;\n use std::mem;\n use std::u32;\n-use syntax::ast;\n \n mod graphviz;\n \n@@ -892,18 +891,17 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// constraints, assuming such values can be found; if they cannot,\n     /// errors are reported.\n     pub fn resolve_regions(&self,\n-                           free_regions: &FreeRegionMap<'tcx>,\n-                           subject_node: ast::NodeId)\n+                           region_rels: &RegionRelations<'a, 'gcx, 'tcx>)\n                            -> Vec<RegionResolutionError<'tcx>> {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n         let mut errors = vec![];\n-        let v = self.infer_variable_values(free_regions, &mut errors, subject_node);\n+        let v = self.infer_variable_values(region_rels, &mut errors);\n         *self.values.borrow_mut() = Some(v);\n         errors\n     }\n \n     fn lub_concrete_regions(&self,\n-                            free_regions: &FreeRegionMap<'tcx>,\n+                            region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n                             a: Region<'tcx>,\n                             b: Region<'tcx>)\n                             -> Region<'tcx> {\n@@ -939,7 +937,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 // at least as big as the block fr.scope_id\".  So, we can\n                 // reasonably compare free regions and scopes:\n                 if let Some(fr_scope) = fr.scope {\n-                    let r_id = self.tcx.region_maps().nearest_common_ancestor(fr_scope, s_id);\n+                    let r_id = region_rels.region_maps.nearest_common_ancestor(fr_scope, s_id);\n                     if r_id == fr_scope {\n                         // if the free region's scope `fr.scope_id` is bigger than\n                         // the scope region `s_id`, then the LUB is the free\n@@ -957,12 +955,12 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 // The region corresponding to an outer block is a\n                 // subtype of the region corresponding to an inner\n                 // block.\n-                self.tcx.mk_region(ReScope(\n-                    self.tcx.region_maps().nearest_common_ancestor(a_id, b_id)))\n+                let lub = region_rels.region_maps.nearest_common_ancestor(a_id, b_id);\n+                self.tcx.mk_region(ReScope(lub))\n             }\n \n             (&ReFree(_), &ReFree(_)) => {\n-                free_regions.lub_free_regions(self.tcx, a, b)\n+                region_rels.lub_free_regions(a, b)\n             }\n \n             // For these types, we cannot define any additional\n@@ -996,24 +994,23 @@ type RegionGraph<'tcx> = graph::Graph<(), Constraint<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     fn infer_variable_values(&self,\n-                             free_regions: &FreeRegionMap<'tcx>,\n-                             errors: &mut Vec<RegionResolutionError<'tcx>>,\n-                             subject: ast::NodeId)\n+                             region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n+                             errors: &mut Vec<RegionResolutionError<'tcx>>)\n                              -> Vec<VarValue<'tcx>> {\n         let mut var_data = self.construct_var_data();\n \n         // Dorky hack to cause `dump_constraints` to only get called\n         // if debug mode is enabled:\n-        debug!(\"----() End constraint listing (subject={}) {:?}---\",\n-               subject,\n-               self.dump_constraints(subject));\n-        graphviz::maybe_print_constraints_for(self, subject);\n+        debug!(\"----() End constraint listing (context={:?}) {:?}---\",\n+               region_rels.context,\n+               self.dump_constraints(region_rels));\n+        graphviz::maybe_print_constraints_for(self, region_rels);\n \n         let graph = self.construct_graph();\n         self.expand_givens(&graph);\n-        self.expansion(free_regions, &mut var_data);\n-        self.collect_errors(free_regions, &mut var_data, errors);\n-        self.collect_var_errors(free_regions, &var_data, &graph, errors);\n+        self.expansion(region_rels, &mut var_data);\n+        self.collect_errors(region_rels, &mut var_data, errors);\n+        self.collect_var_errors(region_rels, &var_data, &graph, errors);\n         var_data\n     }\n \n@@ -1023,9 +1020,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             .collect()\n     }\n \n-    fn dump_constraints(&self, subject: ast::NodeId) {\n-        debug!(\"----() Start constraint listing (subject={}) ()----\",\n-               subject);\n+    fn dump_constraints(&self, free_regions: &RegionRelations<'a, 'gcx, 'tcx>) {\n+        debug!(\"----() Start constraint listing (context={:?}) ()----\",\n+               free_regions.context);\n         for (idx, (constraint, _)) in self.constraints.borrow().iter().enumerate() {\n             debug!(\"Constraint {} => {:?}\", idx, constraint);\n         }\n@@ -1056,21 +1053,21 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn expansion(&self, free_regions: &FreeRegionMap<'tcx>, var_values: &mut [VarValue<'tcx>]) {\n+    fn expansion(&self, region_rels: &RegionRelations<'a, 'gcx, 'tcx>, var_values: &mut [VarValue<'tcx>]) {\n         self.iterate_until_fixed_point(\"Expansion\", |constraint, origin| {\n             debug!(\"expansion: constraint={:?} origin={:?}\",\n                    constraint, origin);\n             match *constraint {\n                 ConstrainRegSubVar(a_region, b_vid) => {\n                     let b_data = &mut var_values[b_vid.index as usize];\n-                    self.expand_node(free_regions, a_region, b_vid, b_data)\n+                    self.expand_node(region_rels, a_region, b_vid, b_data)\n                 }\n                 ConstrainVarSubVar(a_vid, b_vid) => {\n                     match var_values[a_vid.index as usize] {\n                         ErrorValue => false,\n                         Value(a_region) => {\n                             let b_node = &mut var_values[b_vid.index as usize];\n-                            self.expand_node(free_regions, a_region, b_vid, b_node)\n+                            self.expand_node(region_rels, a_region, b_vid, b_node)\n                         }\n                     }\n                 }\n@@ -1085,7 +1082,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     }\n \n     fn expand_node(&self,\n-                   free_regions: &FreeRegionMap<'tcx>,\n+                   region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n                    a_region: Region<'tcx>,\n                    b_vid: RegionVid,\n                    b_data: &mut VarValue<'tcx>)\n@@ -1108,7 +1105,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         match *b_data {\n             Value(cur_region) => {\n-                let lub = self.lub_concrete_regions(free_regions, a_region, cur_region);\n+                let lub = self.lub_concrete_regions(region_rels, a_region, cur_region);\n                 if lub == cur_region {\n                     return false;\n                 }\n@@ -1132,7 +1129,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// cases where the region cannot grow larger than a fixed point)\n     /// and check that they are satisfied.\n     fn collect_errors(&self,\n-                      free_regions: &FreeRegionMap<'tcx>,\n+                      region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n                       var_data: &mut Vec<VarValue<'tcx>>,\n                       errors: &mut Vec<RegionResolutionError<'tcx>>) {\n         let constraints = self.constraints.borrow();\n@@ -1146,7 +1143,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 }\n \n                 ConstrainRegSubReg(sub, sup) => {\n-                    if free_regions.is_subregion_of(self.tcx, sub, sup) {\n+                    if region_rels.is_subregion_of(sub, sup) {\n                         continue;\n                     }\n \n@@ -1174,7 +1171,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                     // Do not report these errors immediately:\n                     // instead, set the variable value to error and\n                     // collect them later.\n-                    if !free_regions.is_subregion_of(self.tcx, a_region, b_region) {\n+                    if !region_rels.is_subregion_of(a_region, b_region) {\n                         debug!(\"collect_errors: region error at {:?}: \\\n                                 cannot verify that {:?}={:?} <= {:?}\",\n                                origin,\n@@ -1190,7 +1187,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         for verify in self.verifys.borrow().iter() {\n             debug!(\"collect_errors: verify={:?}\", verify);\n             let sub = normalize(self.tcx, var_data, verify.region);\n-            if verify.bound.is_met(self.tcx, free_regions, var_data, sub) {\n+            if verify.bound.is_met(region_rels, var_data, sub) {\n                 continue;\n             }\n \n@@ -1209,7 +1206,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// Go over the variables that were declared to be error variables\n     /// and create a `RegionResolutionError` for each of them.\n     fn collect_var_errors(&self,\n-                          free_regions: &FreeRegionMap<'tcx>,\n+                          region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n                           var_data: &[VarValue<'tcx>],\n                           graph: &RegionGraph<'tcx>,\n                           errors: &mut Vec<RegionResolutionError<'tcx>>) {\n@@ -1258,7 +1255,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                        this portion of the code and think hard about it. =) */\n \n                     let node_vid = RegionVid { index: idx as u32 };\n-                    self.collect_error_for_expanding_node(free_regions,\n+                    self.collect_error_for_expanding_node(region_rels,\n                                                           graph,\n                                                           &mut dup_vec,\n                                                           node_vid,\n@@ -1311,7 +1308,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     }\n \n     fn collect_error_for_expanding_node(&self,\n-                                        free_regions: &FreeRegionMap<'tcx>,\n+                                        region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n                                         graph: &RegionGraph<'tcx>,\n                                         dup_vec: &mut [u32],\n                                         node_idx: RegionVid,\n@@ -1347,7 +1344,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         for lower_bound in &lower_bounds {\n             for upper_bound in &upper_bounds {\n-                if !free_regions.is_subregion_of(self.tcx, lower_bound.region, upper_bound.region) {\n+                if !region_rels.is_subregion_of(lower_bound.region, upper_bound.region) {\n                     let origin = (*self.var_origins.borrow())[node_idx.index as usize].clone();\n                     debug!(\"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n                             sup: {:?}\",\n@@ -1591,29 +1588,30 @@ impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n         }\n     }\n \n-    fn is_met(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-              free_regions: &FreeRegionMap<'tcx>,\n+    fn is_met(&self,\n+              region_rels: &RegionRelations<'a, 'gcx, 'tcx>,\n               var_values: &Vec<VarValue<'tcx>>,\n               min: ty::Region<'tcx>)\n               -> bool {\n+        let tcx = region_rels.tcx;\n         match self {\n             &VerifyBound::AnyRegion(ref rs) =>\n                 rs.iter()\n                   .map(|&r| normalize(tcx, var_values, r))\n-                  .any(|r| free_regions.is_subregion_of(tcx, min, r)),\n+                  .any(|r| region_rels.is_subregion_of(min, r)),\n \n             &VerifyBound::AllRegions(ref rs) =>\n                 rs.iter()\n                   .map(|&r| normalize(tcx, var_values, r))\n-                  .all(|r| free_regions.is_subregion_of(tcx, min, r)),\n+                  .all(|r| region_rels.is_subregion_of(min, r)),\n \n             &VerifyBound::AnyBound(ref bs) =>\n                 bs.iter()\n-                  .any(|b| b.is_met(tcx, free_regions, var_values, min)),\n+                  .any(|b| b.is_met(region_rels, var_values, min)),\n \n             &VerifyBound::AllBounds(ref bs) =>\n                 bs.iter()\n-                  .all(|b| b.is_met(tcx, free_regions, var_values, min)),\n+                  .all(|b| b.is_met(region_rels, var_values, min)),\n         }\n     }\n }"}, {"sha": "a49f3d3b7a7fa6c1e110a6d167f24dde173cc61d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -270,19 +270,24 @@ enum PassArgs {\n \n impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n     pub fn new(delegate: &'a mut (Delegate<'tcx>+'a),\n+               context: DefId,\n                infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n                -> Self\n     {\n-        ExprUseVisitor::with_options(delegate, infcx, mc::MemCategorizationOptions::default())\n+        ExprUseVisitor::with_options(delegate,\n+                                     infcx,\n+                                     context,\n+                                     mc::MemCategorizationOptions::default())\n     }\n \n     pub fn with_options(delegate: &'a mut (Delegate<'tcx>+'a),\n                         infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                        context: DefId,\n                         options: mc::MemCategorizationOptions)\n                -> Self\n     {\n         ExprUseVisitor {\n-            mc: mc::MemCategorizationContext::with_options(infcx, options),\n+            mc: mc::MemCategorizationContext::with_options(infcx, context, options),\n             delegate: delegate\n         }\n     }"}, {"sha": "2dc7aac04aede4bc53413f5fefd0d65cb9b6ec13", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 98, "deletions": 55, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -15,10 +15,108 @@\n //! `TransitiveRelation` type and use that to decide when one free\n //! region outlives another and so forth.\n \n+use hir::def_id::DefId;\n+use middle::region::RegionMaps;\n use ty::{self, Lift, TyCtxt, Region};\n use ty::wf::ImpliedBound;\n use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n+/// Combines a `RegionMaps` (which governs relationships between\n+/// scopes) and a `FreeRegionMap` (which governs relationships between\n+/// free regions) to yield a complete relation between concrete\n+/// regions.\n+///\n+/// This stuff is a bit convoluted and should be refactored, but as we\n+/// move to NLL it'll all go away anyhow.\n+pub struct RegionRelations<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+\n+    /// context used to fetch the region maps\n+    pub context: DefId,\n+\n+    /// region maps for the given context\n+    pub region_maps: &'a RegionMaps<'tcx>,\n+\n+    /// free-region relationships\n+    pub free_regions: &'a FreeRegionMap<'tcx>,\n+}\n+\n+impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n+    pub fn new(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        context: DefId,\n+        region_maps: &'a RegionMaps<'tcx>,\n+        free_regions: &'a FreeRegionMap<'tcx>,\n+    ) -> Self {\n+        Self {\n+            tcx,\n+            context,\n+            region_maps,\n+            free_regions,\n+        }\n+    }\n+\n+    /// Determines whether one region is a subregion of another.  This is intended to run *after\n+    /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n+    pub fn is_subregion_of(&self,\n+                           sub_region: ty::Region<'tcx>,\n+                           super_region: ty::Region<'tcx>)\n+                           -> bool {\n+        let result = sub_region == super_region || {\n+            match (sub_region, super_region) {\n+                (&ty::ReEmpty, _) |\n+                (_, &ty::ReStatic) =>\n+                    true,\n+\n+                (&ty::ReScope(sub_scope), &ty::ReScope(super_scope)) =>\n+                    self.region_maps.is_subscope_of(sub_scope, super_scope),\n+\n+                (&ty::ReScope(sub_scope), &ty::ReFree(fr)) => {\n+                    // 1. It is safe to unwrap `fr.scope` because we\n+                    // should only ever wind up comparing against\n+                    // `ReScope` in the context of a method or\n+                    // body, where `fr.scope` should be `Some`.\n+                    self.region_maps.is_subscope_of(sub_scope, fr.scope.unwrap() /*1*/) ||\n+                        self.is_static(super_region)\n+                }\n+\n+                (&ty::ReFree(_), &ty::ReFree(_)) =>\n+                    self.free_regions.relation.contains(&sub_region, &super_region) ||\n+                        self.is_static(super_region),\n+\n+                (&ty::ReStatic, &ty::ReFree(_)) =>\n+                    self.is_static(super_region),\n+\n+                _ =>\n+                    false,\n+            }\n+        };\n+        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?}) = {:?}\",\n+               sub_region, super_region, result);\n+        result\n+    }\n+\n+    /// Determines whether this free-region is required to be 'static\n+    fn is_static(&self, super_region: ty::Region<'tcx>) -> bool {\n+        debug!(\"is_static(super_region={:?})\", super_region);\n+        match *super_region {\n+            ty::ReStatic => true,\n+            ty::ReFree(_) => {\n+                let re_static = self.tcx.mk_region(ty::ReStatic);\n+                self.free_regions.relation.contains(&re_static, &super_region)\n+            }\n+            _ => bug!(\"only free regions should be given to `is_static`\")\n+        }\n+    }\n+\n+    pub fn lub_free_regions(&self,\n+                            r_a: Region<'tcx>,\n+                            r_b: Region<'tcx>)\n+                            -> Region<'tcx> {\n+        self.free_regions.lub_free_regions(self.tcx, r_a, r_b)\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct FreeRegionMap<'tcx> {\n     // Stores the relation `a < b`, where `a` and `b` are regions.\n@@ -116,61 +214,6 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         debug!(\"lub_free_regions(r_a={:?}, r_b={:?}) = {:?}\", r_a, r_b, result);\n         result\n     }\n-\n-    /// Determines whether one region is a subregion of another.  This is intended to run *after\n-    /// inference* and sadly the logic is somewhat duplicated with the code in infer.rs.\n-    pub fn is_subregion_of<'a, 'gcx>(&self,\n-                                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                     sub_region: ty::Region<'tcx>,\n-                                     super_region: ty::Region<'tcx>)\n-                                     -> bool {\n-        let result = sub_region == super_region || {\n-            match (sub_region, super_region) {\n-                (&ty::ReEmpty, _) |\n-                (_, &ty::ReStatic) =>\n-                    true,\n-\n-                (&ty::ReScope(sub_scope), &ty::ReScope(super_scope)) =>\n-                    tcx.region_maps().is_subscope_of(sub_scope, super_scope),\n-\n-                (&ty::ReScope(sub_scope), &ty::ReFree(fr)) => {\n-                    // 1. It is safe to unwrap `fr.scope` because we\n-                    // should only ever wind up comparing against\n-                    // `ReScope` in the context of a method or\n-                    // body, where `fr.scope` should be `Some`.\n-                    tcx.region_maps().is_subscope_of(sub_scope, fr.scope.unwrap() /*1*/) ||\n-                        self.is_static(tcx, super_region)\n-                }\n-\n-                (&ty::ReFree(_), &ty::ReFree(_)) =>\n-                    self.relation.contains(&sub_region, &super_region) ||\n-                        self.is_static(tcx, super_region),\n-\n-                (&ty::ReStatic, &ty::ReFree(_)) =>\n-                    self.is_static(tcx, super_region),\n-\n-                _ =>\n-                    false,\n-            }\n-        };\n-        debug!(\"is_subregion_of(sub_region={:?}, super_region={:?}) = {:?}\",\n-               sub_region, super_region, result);\n-        result\n-    }\n-\n-    /// Determines whether this free-region is required to be 'static\n-    fn is_static<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, super_region: ty::Region<'tcx>)\n-                           -> bool {\n-        debug!(\"is_static(super_region={:?})\", super_region);\n-        match *super_region {\n-            ty::ReStatic => true,\n-            ty::ReFree(_) => {\n-                let re_static = tcx.mk_region(ty::ReStatic);\n-                self.relation.contains(&re_static, &super_region)\n-            }\n-            _ => bug!(\"only free regions should be given to `is_static`\")\n-        }\n-    }\n }\n \n impl_stable_hash_for!(struct FreeRegionMap<'tcx> {"}, {"sha": "0e2db746e45e4bc747d0db30776f8f572191cb2f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -70,6 +70,7 @@ pub use self::Note::*;\n \n use self::Aliasability::*;\n \n+use middle::region::RegionMaps;\n use hir::def_id::DefId;\n use hir::map as hir_map;\n use infer::InferCtxt;\n@@ -286,9 +287,10 @@ impl ast_node for hir::Pat {\n     fn span(&self) -> Span { self.span }\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Clone)]\n pub struct MemCategorizationContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    pub region_maps: Rc<RegionMaps<'tcx>>,\n     options: MemCategorizationOptions,\n }\n \n@@ -402,16 +404,21 @@ impl MutabilityCategory {\n }\n \n impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>)\n+    /// Context should be the `DefId` we use to fetch region-maps.\n+    pub fn new(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+               context: DefId)\n                -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n-        MemCategorizationContext::with_options(infcx, MemCategorizationOptions::default())\n+        MemCategorizationContext::with_options(infcx, context, MemCategorizationOptions::default())\n     }\n \n     pub fn with_options(infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+                        context: DefId,\n                         options: MemCategorizationOptions)\n                         -> MemCategorizationContext<'a, 'gcx, 'tcx> {\n+        let region_maps = infcx.tcx.region_maps(context);\n         MemCategorizationContext {\n             infcx: infcx,\n+            region_maps: region_maps,\n             options: options,\n         }\n     }\n@@ -786,7 +793,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             };\n \n             match fn_expr.node {\n-                hir::ExprClosure(.., body_id, _) => body_id.node_id,\n+                hir::ExprClosure(.., body_id, _) => body_id,\n                 _ => bug!()\n             }\n         };\n@@ -796,7 +803,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n-            scope: Some(self.tcx().item_extent(fn_body_id)),\n+            scope: Some(self.tcx().item_extent(fn_body_id.node_id)),\n             bound_region: ty::BrEnv\n         }));\n \n@@ -845,7 +852,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     pub fn temporary_scope(&self, id: ast::NodeId) -> (ty::Region<'tcx>, ty::Region<'tcx>)\n     {\n         let (scope, old_scope) =\n-            self.tcx().region_maps().old_and_new_temporary_scope(self.tcx(), id);\n+            self.region_maps.old_and_new_temporary_scope(self.tcx(), id);\n         (self.tcx().mk_region(match scope {\n             Some(scope) => ty::ReScope(scope),\n             None => ty::ReStatic"}, {"sha": "fb0c3a29deffc5931931a34ed08258babfd6767a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 50, "deletions": 30, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -29,8 +29,7 @@ use syntax_pos::Span;\n use ty::TyCtxt;\n use ty::maps::Providers;\n \n-use hir;\n-use hir::def_id::{CrateNum, LOCAL_CRATE};\n+use hir; use hir::def_id::DefId;\n use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n use hir::{Block, Item, FnDecl, Arm, Pat, PatKind, Stmt, Expr, Local};\n \n@@ -226,6 +225,9 @@ pub struct RegionMaps<'tcx> {\n     /// which that variable is declared.\n     var_map: NodeMap<CodeExtent<'tcx>>,\n \n+    /// maps from a node-id to the associated destruction scope (if any)\n+    destruction_scopes: NodeMap<CodeExtent<'tcx>>,\n+\n     /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n     /// larger than the default. The map goes from the expression id\n     /// to the cleanup scope id. For rvalues not present in this\n@@ -301,11 +303,22 @@ struct RegionResolutionVisitor<'a, 'tcx: 'a> {\n     /// arbitrary amounts of stack space. Terminating scopes end\n     /// up being contained in a DestructionScope that contains the\n     /// destructor's execution.\n-    terminating_scopes: NodeSet\n+    terminating_scopes: NodeSet,\n }\n \n \n impl<'tcx> RegionMaps<'tcx> {\n+    pub fn new() -> Self {\n+        RegionMaps {\n+            scope_map: FxHashMap(),\n+            destruction_scopes: FxHashMap(),\n+            var_map: NodeMap(),\n+            rvalue_scopes: NodeMap(),\n+            shrunk_rvalue_scopes: NodeMap(),\n+            fn_tree: NodeMap(),\n+        }\n+    }\n+\n     pub fn each_encl_scope<E>(&self, mut e:E) where E: FnMut(CodeExtent<'tcx>, CodeExtent<'tcx>) {\n         for (&child, &parent) in &self.scope_map {\n             e(child, parent)\n@@ -317,6 +330,10 @@ impl<'tcx> RegionMaps<'tcx> {\n         }\n     }\n \n+    pub fn opt_destruction_extent(&self, n: ast::NodeId) -> Option<CodeExtent<'tcx>> {\n+        self.destruction_scopes.get(&n).cloned()\n+    }\n+\n     /// Records that `sub_fn` is defined within `sup_fn`. These ids\n     /// should be the id of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n@@ -1029,18 +1046,18 @@ fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                         body_id: hir::BodyId,\n                         sp: Span,\n                         id: ast::NodeId) {\n+    visitor.cx.parent = Some(visitor.new_code_extent(\n+        CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id }));\n+\n     debug!(\"region::resolve_fn(id={:?}, \\\n-                               span={:?}, \\\n-                               body.id={:?}, \\\n-                               cx.parent={:?})\",\n+            span={:?}, \\\n+            body.id={:?}, \\\n+            cx.parent={:?})\",\n            id,\n            visitor.tcx.sess.codemap().span_to_string(sp),\n            body_id,\n            visitor.cx.parent);\n \n-    visitor.cx.parent = Some(visitor.new_code_extent(\n-        CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id }));\n-\n     let fn_decl_scope = visitor.new_code_extent(\n         CodeExtentData::ParameterScope { fn_id: id, body_id: body_id.node_id });\n \n@@ -1086,6 +1103,12 @@ impl<'a, 'tcx> RegionResolutionVisitor<'a, 'tcx> {\n             let prev = self.region_maps.scope_map.insert(code_extent, p);\n             assert!(prev.is_none());\n         }\n+\n+        // record the destruction scopes for later so we can query them\n+        if let &CodeExtentData::DestructionScope(n) = code_extent {\n+            self.region_maps.destruction_scopes.insert(n, code_extent);\n+        }\n+\n         code_extent\n     }\n \n@@ -1162,47 +1185,44 @@ impl<'a, 'tcx> Visitor<'tcx> for RegionResolutionVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn resolve_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Rc<RegionMaps<'tcx>> {\n-    tcx.region_resolve_crate(LOCAL_CRATE)\n-}\n-\n-fn region_resolve_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n+fn region_maps<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, fn_id: DefId)\n     -> Rc<RegionMaps<'tcx>>\n {\n-    debug_assert!(crate_num == LOCAL_CRATE);\n-\n-    let hir_map = &tcx.hir;\n+    let fn_node_id = tcx.hir.as_local_node_id(fn_id)\n+                            .expect(\"fn DefId should be for LOCAL_CRATE\");\n+    let node = tcx.hir.get(fn_node_id);\n+    match node {\n+        hir_map::NodeItem(_) | hir_map::NodeTraitItem(_) | hir_map::NodeImplItem(_) => { }\n+        _ => {\n+            let parent_id = tcx.hir.get_parent(fn_node_id);\n+            let parent_def_id = tcx.hir.local_def_id(parent_id);\n+            return tcx.region_maps(parent_def_id);\n+        }\n+    }\n \n-    let krate = hir_map.krate();\n-\n-    let mut maps = RegionMaps {\n-        scope_map: FxHashMap(),\n-        var_map: NodeMap(),\n-        rvalue_scopes: NodeMap(),\n-        shrunk_rvalue_scopes: NodeMap(),\n-        fn_tree: NodeMap(),\n-    };\n+    let mut maps = RegionMaps::new();\n \n     {\n         let mut visitor = RegionResolutionVisitor {\n             tcx: tcx,\n             region_maps: &mut maps,\n-            map: hir_map,\n+            map: &tcx.hir,\n             cx: Context {\n                 root_id: None,\n                 parent: None,\n                 var_parent: None,\n             },\n-            terminating_scopes: NodeSet()\n+            terminating_scopes: NodeSet(),\n         };\n-        krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n+        visitor.visit_hir_map_node(node);\n     }\n+\n     Rc::new(maps)\n }\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n-        region_resolve_crate,\n+        region_maps,\n         ..*providers\n     };\n }"}, {"sha": "4f7cb2b12a7caa505060bb9a1882114391155cc3", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -17,6 +17,7 @@ pub use self::ObligationCauseCode::*;\n \n use hir;\n use hir::def_id::DefId;\n+use middle::region::RegionMaps;\n use middle::free_region::FreeRegionMap;\n use ty::subst::Substs;\n use ty::{self, Ty, TyCtxt, TypeFoldable, ToPredicate};\n@@ -435,9 +436,10 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n // FIXME: this is gonna need to be removed ...\n /// Normalizes the parameter environment, reporting errors if they occur.\n pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    unnormalized_env: ty::ParameterEnvironment<'tcx>,\n-    cause: ObligationCause<'tcx>)\n-    -> ty::ParameterEnvironment<'tcx>\n+                                              region_context: DefId,\n+                                              unnormalized_env: ty::ParameterEnvironment<'tcx>,\n+                                              cause: ObligationCause<'tcx>)\n+                                              -> ty::ParameterEnvironment<'tcx>\n {\n     // I'm not wild about reporting errors here; I'd prefer to\n     // have the errors get reported at a defined place (e.g.,\n@@ -455,7 +457,6 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // can be sure that no errors should occur.\n \n     let span = cause.span;\n-    let body_id = cause.body_id;\n \n     debug!(\"normalize_param_env_or_error(unnormalized_env={:?})\",\n            unnormalized_env);\n@@ -492,8 +493,9 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"normalize_param_env_or_error: normalized predicates={:?}\",\n             predicates);\n \n+        let region_maps = RegionMaps::new();\n         let free_regions = FreeRegionMap::new();\n-        infcx.resolve_regions_and_report_errors(&free_regions, body_id);\n+        infcx.resolve_regions_and_report_errors(region_context, &region_maps, &free_regions);\n         let predicates = match infcx.fully_resolve(&predicates) {\n             Ok(predicates) => predicates,\n             Err(fixup_err) => {"}, {"sha": "73b76736b2470f6b4af9ad43914e7f47e3f3e168", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -21,7 +21,7 @@ use hir::map as hir_map;\n use hir::map::DisambiguatedDefPathData;\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n-use middle::region::{CodeExtent, CodeExtentData, RegionMaps};\n+use middle::region::{CodeExtent, CodeExtentData};\n use middle::resolve_lifetime;\n use middle::stability;\n use mir::Mir;\n@@ -52,7 +52,6 @@ use std::mem;\n use std::ops::Deref;\n use std::iter;\n use std::cmp::Ordering;\n-use std::rc::Rc;\n use syntax::abi;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n@@ -656,12 +655,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.intern_code_extent(CodeExtentData::Misc(n))\n     }\n \n-    // TODO this is revealing side-effects of query, bad\n-    pub fn opt_destruction_extent(self, n: ast::NodeId) -> Option<CodeExtent<'gcx>> {\n-        let s = CodeExtentData::DestructionScope(n);\n-        self.code_extent_interner.borrow().get(&s).cloned()\n-    }\n-\n     // Returns the code extent for an item - the destruction scope.\n     pub fn item_extent(self, n: ast::NodeId) -> CodeExtent<'gcx> {\n         self.intern_code_extent(CodeExtentData::DestructionScope(n))\n@@ -712,10 +705,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         local as usize == global as usize\n     }\n \n-    pub fn region_maps(self) -> Rc<RegionMaps<'tcx>> {\n-        self.region_resolve_crate(LOCAL_CRATE)\n-    }\n-\n     /// Create a type context and call the closure with a `TyCtxt` reference\n     /// to the context. The closure enforces that the type context and any interned\n     /// value (types, substs, etc.) can only be used while `ty::tls` has a valid"}, {"sha": "b8edfbf60f245a8caa6f0b7fca81eb2ccf3f5043", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -292,12 +292,6 @@ impl<'tcx> QueryDescription for queries::def_span<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::region_resolve_crate<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n-        format!(\"resolve crate\")\n-    }\n-}\n-\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -578,7 +572,10 @@ define_maps! { <'tcx>\n \n     [] reachable_set: reachability_dep_node(CrateNum) -> Rc<NodeSet>,\n \n-    [] region_resolve_crate: region_resolve_crate_dep_node(CrateNum) -> Rc<RegionMaps<'tcx>>,\n+    /// Per-function `RegionMaps`. The `DefId` should be the owner-def-id for the fn body;\n+    /// in the case of closures or \"inline\" expressions, this will be redirected to the enclosing\n+    /// fn item.\n+    [] region_maps: RegionMaps(DefId) -> Rc<RegionMaps<'tcx>>,\n \n     [] mir_shims: mir_shim_dep_node(ty::InstanceDef<'tcx>) -> &'tcx RefCell<mir::Mir<'tcx>>,\n \n@@ -601,10 +598,6 @@ fn reachability_dep_node(_: CrateNum) -> DepNode<DefId> {\n     DepNode::Reachability\n }\n \n-fn region_resolve_crate_dep_node(_: CrateNum) -> DepNode<DefId> {\n-    DepNode::RegionResolveCrate\n-}\n-\n fn mir_shim_dep_node(instance: ty::InstanceDef) -> DepNode<DefId> {\n     instance.dep_node()\n }"}, {"sha": "07aa627e59674aaf7ee596dcee087eb15a35ac86", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -2526,7 +2526,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let body_id = free_id_outlive.map(|f| f.node_id())\n                                      .unwrap_or(DUMMY_NODE_ID);\n         let cause = traits::ObligationCause::misc(span, body_id);\n-        traits::normalize_param_env_or_error(tcx, unnormalized_env, cause)\n+        traits::normalize_param_env_or_error(tcx, def_id, unnormalized_env, cause)\n     }\n \n     pub fn node_scope_region(self, id: NodeId) -> Region<'tcx> {"}, {"sha": "6e43943bc1747059c7ffcfbd1c969b5f01586f03", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -199,7 +199,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         all_loans: all_loans,\n         param_env: &infcx.parameter_environment\n     };\n-    euv::ExprUseVisitor::new(&mut clcx, &infcx).consume_body(body);\n+    euv::ExprUseVisitor::new(&mut clcx, bccx.owner_def_id, &infcx).consume_body(body);\n }\n \n #[derive(PartialEq)]\n@@ -238,9 +238,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         //! Like `each_issued_loan()`, but only considers loans that are\n         //! currently in scope.\n \n-        let tcx = self.tcx();\n         self.each_issued_loan(scope.node_id(), |loan| {\n-            if tcx.region_maps().is_subscope_of(scope, loan.kill_scope) {\n+            if self.bccx.region_maps.is_subscope_of(scope, loan.kill_scope) {\n                 op(loan)\n             } else {\n                 true\n@@ -379,8 +378,8 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                new_loan);\n \n         // Should only be called for loans that are in scope at the same time.\n-        assert!(self.tcx().region_maps().scopes_intersect(old_loan.kill_scope,\n-                                                        new_loan.kill_scope));\n+        assert!(self.bccx.region_maps.scopes_intersect(old_loan.kill_scope,\n+                                                       new_loan.kill_scope));\n \n         self.report_error_if_loan_conflicts_with_restriction(\n             old_loan, new_loan, old_loan, new_loan) &&"}, {"sha": "12854d3c9792251d54f4a3ff040c2a64c827285b", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -116,7 +116,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n             }\n             Categorization::Local(local_id) => {\n                 self.bccx.tcx.mk_region(ty::ReScope(\n-                    self.bccx.tcx.region_maps().var_scope(local_id)))\n+                    self.bccx.region_maps.var_scope(local_id)))\n             }\n             Categorization::StaticItem |\n             Categorization::Deref(.., mc::UnsafePtr(..)) => {"}, {"sha": "9a5d1008c408ed885e986f5b36188460182e358c", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -51,7 +51,7 @@ pub fn gather_loans_in_fn<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     };\n \n     let body = glcx.bccx.tcx.hir.body(body);\n-    euv::ExprUseVisitor::new(&mut glcx, &infcx).consume_body(body);\n+    euv::ExprUseVisitor::new(&mut glcx, bccx.owner_def_id, &infcx).consume_body(body);\n \n     glcx.report_potential_errors();\n     let GatherLoanCtxt { all_loans, move_data, .. } = glcx;\n@@ -458,7 +458,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         //! notably method arguments, the loan may be introduced only\n         //! later, once it comes into scope.\n \n-        if self.bccx.tcx.region_maps().is_subscope_of(borrow_scope, loan_scope) {\n+        if self.bccx.region_maps.is_subscope_of(borrow_scope, loan_scope) {\n             borrow_scope\n         } else {\n             loan_scope\n@@ -488,12 +488,11 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n         //! with immutable `&` pointers, because borrows of such pointers\n         //! do not require restrictions and hence do not cause a loan.\n \n-        let lexical_scope = lp.kill_scope(self.bccx.tcx);\n-        let rm = &self.bccx.tcx.region_maps();\n-        if rm.is_subscope_of(lexical_scope, loan_scope) {\n+        let lexical_scope = lp.kill_scope(self.bccx);\n+        if self.bccx.region_maps.is_subscope_of(lexical_scope, loan_scope) {\n             lexical_scope\n         } else {\n-            assert!(self.bccx.tcx.region_maps().is_subscope_of(loan_scope, lexical_scope));\n+            assert!(self.bccx.region_maps.is_subscope_of(loan_scope, lexical_scope));\n             loan_scope\n         }\n     }"}, {"sha": "e5e5045bc29f9a228c8db961f8232100f693f8b8", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -34,7 +34,8 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::middle::mem_categorization::ImmutabilityBlame;\n-use rustc::middle::region;\n+use rustc::middle::region::{self, RegionMaps};\n+use rustc::middle::free_region::RegionRelations;\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::maps::Providers;\n \n@@ -88,11 +89,8 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n     let body_id = tcx.hir.body_owned_by(owner_id);\n     let attributes = tcx.get_attrs(owner_def_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n-\n-    let mut bccx = &mut BorrowckCtxt {\n-        tcx: tcx,\n-        tables: tables,\n-    };\n+    let region_maps = tcx.region_maps(owner_def_id);\n+    let mut bccx = &mut BorrowckCtxt { tcx, tables, region_maps, owner_def_id };\n \n     let body = bccx.tcx.hir.body(body_id);\n \n@@ -149,7 +147,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n     loan_dfcx.propagate(cfg, body);\n \n     let flowed_moves = move_data::FlowedMoveData::new(move_data,\n-                                                      this.tcx,\n+                                                      this,\n                                                       cfg,\n                                                       id_range,\n                                                       body);\n@@ -170,11 +168,8 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     let owner_id = tcx.hir.body_owner(body_id);\n     let owner_def_id = tcx.hir.local_def_id(owner_id);\n     let tables = tcx.typeck_tables_of(owner_def_id);\n-\n-    let mut bccx = BorrowckCtxt {\n-        tcx: tcx,\n-        tables: tables,\n-    };\n+    let region_maps = tcx.region_maps(owner_def_id);\n+    let mut bccx = BorrowckCtxt { tcx, tables, region_maps, owner_def_id };\n \n     let dataflow_data = build_borrowck_dataflow_data(&mut bccx, cfg, body_id);\n     (bccx, dataflow_data)\n@@ -189,6 +184,10 @@ pub struct BorrowckCtxt<'a, 'tcx: 'a> {\n     // tables for the current thing we are checking; set to\n     // Some in `borrowck_fn` and cleared later\n     tables: &'a ty::TypeckTables<'tcx>,\n+\n+    region_maps: Rc<RegionMaps<'tcx>>,\n+\n+    owner_def_id: DefId,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -312,15 +311,15 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n }\n \n impl<'a, 'tcx> LoanPath<'tcx> {\n-    pub fn kill_scope(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> region::CodeExtent<'tcx> {\n+    pub fn kill_scope(&self, bccx: &BorrowckCtxt<'a, 'tcx>) -> region::CodeExtent<'tcx> {\n         match self.kind {\n-            LpVar(local_id) => tcx.region_maps().var_scope(local_id),\n+            LpVar(local_id) => bccx.region_maps.var_scope(local_id),\n             LpUpvar(upvar_id) => {\n-                let block_id = closure_to_block(upvar_id.closure_expr_id, tcx);\n-                tcx.node_extent(block_id)\n+                let block_id = closure_to_block(upvar_id.closure_expr_id, bccx.tcx);\n+                bccx.tcx.node_extent(block_id)\n             }\n             LpDowncast(ref base, _) |\n-            LpExtend(ref base, ..) => base.kill_scope(tcx),\n+            LpExtend(ref base, ..) => base.kill_scope(bccx),\n         }\n     }\n \n@@ -479,7 +478,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                            r_sup: ty::Region<'tcx>)\n                            -> bool\n     {\n-        self.tables.free_region_map.is_subregion_of(self.tcx, r_sub, r_sup)\n+        let region_rels = RegionRelations::new(self.tcx,\n+                                               self.owner_def_id,\n+                                               &self.region_maps,\n+                                               &self.tables.free_region_map);\n+        region_rels.is_subregion_of(r_sub, r_sup)\n     }\n \n     pub fn report(&self, err: BckError<'tcx>) {"}, {"sha": "3e23086ec7bddc5f03591064f084347fd6df151f", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -523,7 +523,8 @@ impl<'a, 'tcx> MoveData<'tcx> {\n     /// Moves are generated by moves and killed by assignments and\n     /// scoping. Assignments are generated by assignment to variables and\n     /// killed by scoping. See `README.md` for more details.\n-    fn add_gen_kills(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn add_gen_kills(&self,\n+                     bccx: &BorrowckCtxt<'a, 'tcx>,\n                      dfcx_moves: &mut MoveDataFlow,\n                      dfcx_assign: &mut AssignDataFlow) {\n         for (i, the_move) in self.moves.borrow().iter().enumerate() {\n@@ -546,7 +547,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         for path in self.paths.borrow().iter() {\n             match path.loan_path.kind {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n-                    let kill_scope = path.loan_path.kill_scope(tcx);\n+                    let kill_scope = path.loan_path.kill_scope(bccx);\n                     let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n                     self.kill_moves(path, kill_scope.node_id(),\n                                     KillFrom::ScopeEnd, dfcx_moves);\n@@ -561,7 +562,7 @@ impl<'a, 'tcx> MoveData<'tcx> {\n             let lp = self.path_loan_path(assignment.path);\n             match lp.kind {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n-                    let kill_scope = lp.kill_scope(tcx);\n+                    let kill_scope = lp.kill_scope(bccx);\n                     dfcx_assign.add_kill(KillFrom::ScopeEnd,\n                                          kill_scope.node_id(),\n                                          assignment_index);\n@@ -652,11 +653,13 @@ impl<'a, 'tcx> MoveData<'tcx> {\n \n impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n     pub fn new(move_data: MoveData<'tcx>,\n-               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+               bccx: &BorrowckCtxt<'a, 'tcx>,\n                cfg: &cfg::CFG,\n                id_range: IdRange,\n                body: &hir::Body)\n                -> FlowedMoveData<'a, 'tcx> {\n+        let tcx = bccx.tcx;\n+\n         let mut dfcx_moves =\n             DataFlowContext::new(tcx,\n                                  \"flowed_move_data_moves\",\n@@ -676,7 +679,7 @@ impl<'a, 'tcx> FlowedMoveData<'a, 'tcx> {\n \n         move_data.fixup_fragment_sets(tcx);\n \n-        move_data.add_gen_kills(tcx,\n+        move_data.add_gen_kills(bccx,\n                                 &mut dfcx_moves,\n                                 &mut dfcx_assign);\n "}, {"sha": "106b5a26d9564243c40e4d799d24178a53ff0e36", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -14,6 +14,7 @@ use _match::WitnessPreference::*;\n \n use pattern::{Pattern, PatternContext, PatternError, PatternKind};\n \n+use rustc::hir::def_id::DefId;\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n@@ -45,9 +46,12 @@ impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n                 b: hir::BodyId, s: Span, id: ast::NodeId) {\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n \n+        let region_context = self.tcx.hir.local_def_id(id);\n+\n         MatchVisitor {\n             tcx: self.tcx,\n             tables: self.tcx.body_tables(b),\n+            region_context: region_context,\n             param_env: &ty::ParameterEnvironment::for_item(self.tcx, id)\n         }.visit_body(self.tcx.hir.body(b));\n     }\n@@ -64,6 +68,7 @@ fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> Diagn\n \n struct MatchVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    region_context: DefId,\n     tables: &'a ty::TypeckTables<'tcx>,\n     param_env: &'a ty::ParameterEnvironment<'tcx>\n }\n@@ -517,7 +522,7 @@ fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n         let mut checker = MutationChecker {\n             cx: cx,\n         };\n-        ExprUseVisitor::new(&mut checker, &infcx).walk_expr(guard);\n+        ExprUseVisitor::new(&mut checker, cx.region_context, &infcx).walk_expr(guard);\n     });\n }\n "}, {"sha": "aa33d4b55399818240221378260859c068dfdc1f", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -924,10 +924,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"load_dep_graph\",\n              || rustc_incremental::load_dep_graph(tcx, &incremental_hashes_map));\n \n-        time(time_passes,\n-             \"region resolution\",\n-             || middle::region::resolve_crate(tcx));\n-\n         time(time_passes, \"stability index\", || {\n             tcx.stability.borrow_mut().build(tcx)\n         });"}, {"sha": "1036b96d7f5270d21081af5e690f61e0c2b58c2d", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -155,7 +155,8 @@ fn test_env<F>(source_string: &str,\n \n             body(Env { infcx: &infcx });\n             let free_regions = FreeRegionMap::new();\n-            infcx.resolve_regions_and_report_errors(&free_regions, ast::CRATE_NODE_ID);\n+            let def_id = tcx.hir.map.local_def_id(ast::CRATE_NODE_ID);\n+            infcx.resolve_regions_and_report_errors(def_id, &region_map, &free_regions);\n             assert_eq!(tcx.sess.err_count(), expected_err_count);\n         });\n     });"}, {"sha": "2505e2f8211b0c612a77a3664616aa4472e42a75", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn schedule_drop_for_binding(&mut self, var: NodeId, span: Span) {\n         let local_id = self.var_indices[&var];\n         let var_ty = self.local_decls[local_id].ty;\n-        let extent = self.hir.tcx().region_maps().var_scope(var);\n+        let extent = self.hir.region_maps.var_scope(var);\n         self.schedule_drop(span, extent, &Lvalue::Local(local_id), var_ty);\n     }\n "}, {"sha": "b8f1b754b48e82c51377f89c093dc29f092ed4d7", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -134,7 +134,7 @@ pub fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n \n     let tcx = hir.tcx();\n     let span = tcx.hir.span(fn_id);\n-    let mut builder = Builder::new(hir, span, arguments.len(), return_ty);\n+    let mut builder = Builder::new(hir.clone(), span, arguments.len(), return_ty);\n \n     let call_site_extent =\n         tcx.intern_code_extent(\n@@ -202,11 +202,10 @@ pub fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let ty = hir.tables().expr_ty_adjusted(ast_expr);\n     let owner_id = tcx.hir.body_owner(body_id);\n     let span = tcx.hir.span(owner_id);\n-    let mut builder = Builder::new(hir, span, 0, ty);\n+    let mut builder = Builder::new(hir.clone(), span, 0, ty);\n \n-    let region_maps = tcx.region_maps();\n-    let extent = region_maps.temporary_scope(tcx, ast_expr.id)\n-                            .unwrap_or(tcx.item_extent(owner_id));\n+    let extent = hir.region_maps.temporary_scope(tcx, ast_expr.id)\n+                                .unwrap_or(tcx.item_extent(owner_id));\n     let mut block = START_BLOCK;\n     let _ = builder.in_scope(extent, block, |builder| {\n         let expr = builder.hir.mirror(ast_expr);"}, {"sha": "2ec4a8a07df71640d0538d5effdd867a66bb2e92", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -84,7 +84,7 @@ pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n     let block_ty = cx.tables().node_id_to_type(block.id);\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(cx.tcx, block.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, block.id);\n     let expr = Expr {\n         ty: block_ty,\n         temp_lifetime: temp_lifetime,"}, {"sha": "6a1817aba09835348459479f38e11b15ff15fc44", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -26,7 +26,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n     fn make_mirror<'a, 'gcx>(self, cx: &mut Cx<'a, 'gcx, 'tcx>) -> Expr<'tcx> {\n-        let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(cx.tcx, self.id);\n+        let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, self.id);\n         let expr_extent = cx.tcx.node_extent(self.id);\n \n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n@@ -216,7 +216,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n         };\n \n         // Finally, create a destruction scope, if any.\n-        if let Some(extent) = cx.tcx.opt_destruction_extent(self.id) {\n+        if let Some(extent) = cx.region_maps.opt_destruction_extent(self.id) {\n             expr = Expr {\n                 temp_lifetime: temp_lifetime,\n                 temp_lifetime_was_shrunk: was_shrunk,\n@@ -238,7 +238,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                           expr: &'tcx hir::Expr)\n                                           -> Expr<'tcx> {\n     let expr_ty = cx.tables().expr_ty(expr);\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(cx.tcx, expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n \n     let kind = match expr.node {\n         // Here comes the interesting stuff:\n@@ -707,7 +707,7 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  method_call: ty::MethodCall)\n                                  -> Expr<'tcx> {\n     let callee = cx.tables().method_map[&method_call];\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(cx.tcx, expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n     Expr {\n         temp_lifetime: temp_lifetime,\n         temp_lifetime_was_shrunk: was_shrunk,\n@@ -791,7 +791,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                expr: &'tcx hir::Expr,\n                                def: Def)\n                                -> ExprKind<'tcx> {\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(cx.tcx, expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n \n     match def {\n         Def::Local(def_id) => {\n@@ -979,7 +979,7 @@ fn overloaded_operator<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         PassArgs::ByRef => {\n             let region = cx.tcx.node_scope_region(expr.id);\n             let (temp_lifetime, was_shrunk) =\n-                cx.tcx.region_maps().temporary_scope2(cx.tcx, expr.id);\n+                cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n             argrefs.extend(args.iter()\n                 .map(|arg| {\n                     let arg_ty = cx.tables().expr_ty_adjusted(arg);\n@@ -1031,7 +1031,7 @@ fn overloaded_lvalue<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n     // construct the complete expression `foo()` for the overloaded call,\n     // which will yield the &T type\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(cx.tcx, expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, expr.id);\n     let ref_kind = overloaded_operator(cx, expr, method_call, pass_args, receiver, args);\n     let ref_expr = Expr {\n         temp_lifetime: temp_lifetime,\n@@ -1056,7 +1056,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         closure_expr_id: closure_expr.id,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id).unwrap();\n-    let (temp_lifetime, was_shrunk) = cx.tcx.region_maps().temporary_scope2(cx.tcx, closure_expr.id);\n+    let (temp_lifetime, was_shrunk) = cx.region_maps.temporary_scope2(cx.tcx, closure_expr.id);\n     let var_ty = cx.tables().node_id_to_type(id_var);\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,"}, {"sha": "3e9bcb3e18627939b3652bc62e493c8442c40a7f", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -22,17 +22,20 @@ use rustc_const_eval::ConstContext;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::blocks::FnLikeNode;\n+use rustc::middle::region::RegionMaps;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, Ty, TyCtxt};\n use syntax::symbol::{Symbol, InternedString};\n use rustc::hir;\n use rustc_const_math::{ConstInt, ConstUsize};\n+use std::rc::Rc;\n \n-#[derive(Copy, Clone)]\n+#[derive(Clone)]\n pub struct Cx<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+    pub region_maps: Rc<RegionMaps<'tcx>>,\n     constness: hir::Constness,\n \n     /// True if this constant/function needs overflow checks.\n@@ -51,7 +54,13 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             MirSource::Promoted(..) => bug!(),\n         };\n \n-        let attrs = infcx.tcx.hir.attrs(src.item_id());\n+        let tcx = infcx.tcx;\n+        let src_id = src.item_id();\n+        let src_def_id = tcx.hir.local_def_id(src_id);\n+\n+        let region_maps = tcx.region_maps(src_def_id);\n+\n+        let attrs = tcx.hir.attrs(src_id);\n \n         // Some functions always have overflow checks enabled,\n         // however, they may not get codegen'd, depending on\n@@ -60,17 +69,12 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             .any(|item| item.check_name(\"rustc_inherit_overflow_checks\"));\n \n         // Respect -C overflow-checks.\n-        check_overflow |= infcx.tcx.sess.overflow_checks();\n+        check_overflow |= tcx.sess.overflow_checks();\n \n         // Constants and const fn's always need overflow checks.\n         check_overflow |= constness == hir::Constness::Const;\n \n-        Cx {\n-            tcx: infcx.tcx,\n-            infcx: infcx,\n-            constness: constness,\n-            check_overflow: check_overflow,\n-        }\n+        Cx { tcx, infcx, region_maps, constness, check_overflow }\n     }\n }\n "}, {"sha": "cd2d9165c6a53d3ae79af27e5beca0871e1988c6", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -130,7 +130,8 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         };\n \n         let outer_tables = self.tables;\n-        self.tables = self.tcx.typeck_tables_of(self.tcx.hir.local_def_id(item_id));\n+        let item_def_id = self.tcx.hir.local_def_id(item_id);\n+        self.tables = self.tcx.typeck_tables_of(item_def_id);\n \n         let body = self.tcx.hir.body(body_id);\n         if !self.in_fn {\n@@ -140,7 +141,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         let outer_penv = self.tcx.infer_ctxt(body_id, Reveal::UserFacing).enter(|infcx| {\n             let param_env = infcx.parameter_environment.clone();\n             let outer_penv = mem::replace(&mut self.param_env, param_env);\n-            euv::ExprUseVisitor::new(self, &infcx).consume_body(body);\n+            euv::ExprUseVisitor::new(self, item_def_id, &infcx).consume_body(body);\n             outer_penv\n         });\n "}, {"sha": "80330afaad841b0b1736641b18a3092508650948", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -11,13 +11,13 @@\n use rustc::hir::{self, ImplItemKind, TraitItemKind};\n use rustc::infer::{self, InferOk};\n use rustc::middle::free_region::FreeRegionMap;\n+use rustc::middle::region::RegionMaps;\n use rustc::ty::{self, TyCtxt};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::util::common::ErrorReported;\n \n-use syntax::ast;\n use syntax_pos::Span;\n \n use super::{Inherited, FnCtxt};\n@@ -30,14 +30,12 @@ use astconv::ExplicitSelf;\n ///\n /// - impl_m: type of the method we are checking\n /// - impl_m_span: span to use for reporting errors\n-/// - impl_m_body_id: id of the method body\n /// - trait_m: the method in the trait\n /// - impl_trait_ref: the TraitRef corresponding to the trait implementation\n \n pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                      impl_m: &ty::AssociatedItem,\n                                      impl_m_span: Span,\n-                                     impl_m_body_id: ast::NodeId,\n                                      trait_m: &ty::AssociatedItem,\n                                      impl_trait_ref: ty::TraitRef<'tcx>,\n                                      trait_item_span: Option<Span>,\n@@ -72,7 +70,6 @@ pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if let Err(ErrorReported) = compare_predicate_entailment(tcx,\n                                                              impl_m,\n                                                              impl_m_span,\n-                                                             impl_m_body_id,\n                                                              trait_m,\n                                                              impl_trait_ref,\n                                                              old_broken_mode) {\n@@ -83,21 +80,25 @@ pub fn compare_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                           impl_m: &ty::AssociatedItem,\n                                           impl_m_span: Span,\n-                                          impl_m_body_id: ast::NodeId,\n                                           trait_m: &ty::AssociatedItem,\n                                           impl_trait_ref: ty::TraitRef<'tcx>,\n                                           old_broken_mode: bool)\n                                           -> Result<(), ErrorReported> {\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n+    // This node-id should be used for the `body_id` field on each\n+    // `ObligationCause` (and the `FnCtxt`). This is what\n+    // `regionck_item` expects.\n+    let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n+\n     let cause = ObligationCause {\n         span: impl_m_span,\n-        body_id: impl_m_body_id,\n+        body_id: impl_m_node_id,\n         code: ObligationCauseCode::CompareImplMethodObligation {\n             item_name: impl_m.name,\n             impl_item_def_id: impl_m.def_id,\n             trait_item_def_id: trait_m.def_id,\n-            lint_id: if !old_broken_mode { Some(impl_m_body_id) } else { None },\n+            lint_id: if !old_broken_mode { Some(impl_m_node_id) } else { None },\n         },\n     };\n \n@@ -166,7 +167,6 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Create a parameter environment that represents the implementation's\n     // method.\n-    let impl_m_node_id = tcx.hir.as_local_node_id(impl_m.def_id).unwrap();\n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, impl_m_node_id);\n \n     // Create mapping from impl to skolemized.\n@@ -217,9 +217,10 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n     // The key step here is to update the caller_bounds's predicates to be\n     // the new hybrid bounds we computed.\n-    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n+    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_node_id);\n     let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.predicates);\n     let trait_param_env = traits::normalize_param_env_or_error(tcx,\n+                                                               impl_m.def_id,\n                                                                trait_param_env,\n                                                                normalize_cause.clone());\n \n@@ -275,7 +276,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             impl_sig.subst(tcx, impl_to_skol_substs);\n         let impl_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n-                                              impl_m_body_id,\n+                                              impl_m_node_id,\n                                               &impl_sig);\n         let impl_fty = tcx.mk_fn_ptr(ty::Binder(impl_sig));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n@@ -287,7 +288,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             trait_sig.subst(tcx, trait_to_skol_substs);\n         let trait_sig =\n             inh.normalize_associated_types_in(impl_m_span,\n-                                              impl_m_body_id,\n+                                              impl_m_node_id,\n                                               &trait_sig);\n         let trait_fty = tcx.mk_fn_ptr(ty::Binder(trait_sig));\n \n@@ -349,13 +350,14 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // region obligations that get overlooked.  The right\n             // thing to do is the code below. But we keep this old\n             // pass around temporarily.\n+            let region_maps = RegionMaps::new();\n             let mut free_regions = FreeRegionMap::new();\n             free_regions.relate_free_regions_from_predicates(\n                 &infcx.parameter_environment.caller_bounds);\n-            infcx.resolve_regions_and_report_errors(&free_regions, impl_m_body_id);\n+            infcx.resolve_regions_and_report_errors(impl_m.def_id, &region_maps, &free_regions);\n         } else {\n-            let fcx = FnCtxt::new(&inh, impl_m_body_id);\n-            fcx.regionck_item(impl_m_body_id, impl_m_span, &[]);\n+            let fcx = FnCtxt::new(&inh, impl_m_node_id);\n+            fcx.regionck_item(impl_m_node_id, impl_m_span, &[]);\n         }\n \n         Ok(())"}, {"sha": "c20777a403aac7a2b36f97e54b88da7826ede900", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -13,7 +13,7 @@ use check::regionck::RegionCtxt;\n use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferOk};\n-use middle::region;\n+use rustc::middle::region::{self, RegionMaps};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::{self, ObligationCause, Reveal};\n@@ -116,8 +116,9 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n             return Err(ErrorReported);\n         }\n \n+        let region_maps = RegionMaps::new();\n         let free_regions = FreeRegionMap::new();\n-        infcx.resolve_regions_and_report_errors(&free_regions, drop_impl_node_id);\n+        infcx.resolve_regions_and_report_errors(drop_impl_did, &region_maps, &free_regions);\n         Ok(())\n     })\n }\n@@ -278,7 +279,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'gcx, 'tcx>(\n            ty, scope);\n \n \n-    let parent_scope = match rcx.tcx.region_maps().opt_encl_scope(scope) {\n+    let parent_scope = match rcx.region_maps.opt_encl_scope(scope) {\n         Some(parent_scope) => parent_scope,\n         // If no enclosing scope, then it must be the root scope\n         // which cannot be outlived."}, {"sha": "7705041fc92d2f527616c3e6a8dddf616b353126", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -1237,14 +1237,13 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          err.emit()\n                     }\n                 }\n-                hir::ImplItemKind::Method(_, body_id) => {\n+                hir::ImplItemKind::Method(..) => {\n                     let trait_span = tcx.hir.span_if_local(ty_trait_item.def_id);\n                     if ty_trait_item.kind == ty::AssociatedKind::Method {\n                         let err_count = tcx.sess.err_count();\n                         compare_impl_method(tcx,\n                                             &ty_impl_item,\n                                             impl_item.span,\n-                                            body_id.node_id,\n                                             &ty_trait_item,\n                                             impl_trait_ref,\n                                             trait_span,\n@@ -1254,7 +1253,6 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             compare_impl_method(tcx,\n                                                 &ty_impl_item,\n                                                 impl_item.span,\n-                                                body_id.node_id,\n                                                 &ty_trait_item,\n                                                 impl_trait_ref,\n                                                 trait_span,"}, {"sha": "b241f52f62e9b0dd082bd6f20d988927f5933fad", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -87,7 +87,8 @@ use check::FnCtxt;\n use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n-use middle::region::{self, CodeExtent};\n+use middle::region::{self, CodeExtent, RegionMaps};\n+use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n use rustc::ty::{self, Ty, MethodCall, TypeFoldable};\n@@ -97,6 +98,7 @@ use rustc::ty::wf::ImpliedBound;\n \n use std::mem;\n use std::ops::Deref;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -112,8 +114,9 @@ macro_rules! ignore_err {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn regionck_expr(&self, body: &'gcx hir::Body) {\n+        let subject = self.tcx.hir.body_owner_def_id(body.id());\n         let id = body.value.id;\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(id), id, Subject(id));\n+        let mut rcx = RegionCtxt::new(self, RepeatingScope(id), id, Subject(subject));\n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n             rcx.visit_body(body);\n@@ -132,7 +135,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          span: Span,\n                          wf_tys: &[Ty<'tcx>]) {\n         debug!(\"regionck_item(item.id={:?}, wf_tys={:?}\", item_id, wf_tys);\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(item_id), item_id, Subject(item_id));\n+        let subject = self.tcx.hir.local_def_id(item_id);\n+        let mut rcx = RegionCtxt::new(self, RepeatingScope(item_id), item_id, Subject(subject));\n         rcx.free_region_map.relate_free_regions_from_predicates(\n             &self.parameter_environment.caller_bounds);\n         rcx.relate_free_regions(wf_tys, item_id, span);\n@@ -144,8 +148,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        fn_id: ast::NodeId,\n                        body: &'gcx hir::Body) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n+        let subject = self.tcx.hir.body_owner_def_id(body.id());\n         let node_id = body.value.id;\n-        let mut rcx = RegionCtxt::new(self, RepeatingScope(node_id), node_id, Subject(fn_id));\n+        let mut rcx = RegionCtxt::new(self, RepeatingScope(node_id), node_id, Subject(subject));\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n@@ -173,6 +178,8 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n \n+    pub region_maps: Rc<RegionMaps<'tcx>>,\n+\n     free_region_map: FreeRegionMap<'tcx>,\n \n     // id of innermost fn body id\n@@ -185,7 +192,7 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     repeating_scope: ast::NodeId,\n \n     // id of AST node being analyzed (the subject of the analysis).\n-    subject: ast::NodeId,\n+    subject_def_id: DefId,\n \n }\n \n@@ -197,19 +204,21 @@ impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n }\n \n pub struct RepeatingScope(ast::NodeId);\n-pub struct Subject(ast::NodeId);\n+pub struct Subject(DefId);\n \n impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     pub fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n                RepeatingScope(initial_repeating_scope): RepeatingScope,\n                initial_body_id: ast::NodeId,\n                Subject(subject): Subject) -> RegionCtxt<'a, 'gcx, 'tcx> {\n+        let region_maps = fcx.tcx.region_maps(subject);\n         RegionCtxt {\n             fcx: fcx,\n+            region_maps: region_maps,\n             repeating_scope: initial_repeating_scope,\n             body_id: initial_body_id,\n             call_site_scope: None,\n-            subject: subject,\n+            subject_def_id: subject,\n             region_bound_pairs: Vec::new(),\n             free_region_map: FreeRegionMap::new(),\n         }\n@@ -418,14 +427,12 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn resolve_regions_and_report_errors(&self) {\n-        let subject_node_id = self.subject;\n-\n-        self.fcx.resolve_regions_and_report_errors(&self.free_region_map,\n-                                                   subject_node_id);\n+        self.fcx.resolve_regions_and_report_errors(self.subject_def_id,\n+                                                   &self.region_maps,\n+                                                   &self.free_region_map);\n     }\n \n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n-        let tcx = self.tcx;\n         debug!(\"regionck::visit_pat(pat={:?})\", pat);\n         pat.each_binding(|_, id, span, _| {\n             // If we have a variable that contains region'd data, that\n@@ -451,7 +458,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             // that the lifetime of any regions that appear in a\n             // variable's type enclose at least the variable's scope.\n \n-            let var_scope = tcx.region_maps().var_scope(id);\n+            let var_scope = self.region_maps.var_scope(id);\n             let var_region = self.tcx.mk_region(ty::ReScope(var_scope));\n \n             let origin = infer::BindingTypeIsNotValidAtDecl(span);\n@@ -570,7 +577,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n             // If necessary, constrain destructors in the unadjusted form of this\n             // expression.\n             let cmt_result = {\n-                let mc = mc::MemCategorizationContext::new(self);\n+                let mc = mc::MemCategorizationContext::new(self, self.subject_def_id);\n                 mc.cat_expr_unadjusted(expr)\n             };\n             match cmt_result {\n@@ -587,7 +594,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n         // If necessary, constrain destructors in this expression. This will be\n         // the adjusted form if there is an adjustment.\n         let cmt_result = {\n-            let mc = mc::MemCategorizationContext::new(self);\n+            let mc = mc::MemCategorizationContext::new(self, self.subject_def_id);\n             mc.cat_expr(expr)\n         };\n         match cmt_result {\n@@ -949,7 +956,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                            r, m);\n \n                     {\n-                        let mc = mc::MemCategorizationContext::new(self);\n+                        let mc = mc::MemCategorizationContext::new(self, self.subject_def_id);\n                         let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                         debug!(\"constrain_autoderefs: self_cmt={:?}\",\n                                self_cmt);\n@@ -1061,7 +1068,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n         let cmt = {\n-            let mc = mc::MemCategorizationContext::new(self);\n+            let mc = mc::MemCategorizationContext::new(self, self.subject_def_id);\n             ignore_err!(mc.cat_expr(base))\n         };\n \n@@ -1079,7 +1086,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             None => { return; }\n             Some(ref expr) => &**expr,\n         };\n-        let mc = mc::MemCategorizationContext::new(self);\n+        let mc = &mc::MemCategorizationContext::new(self, self.subject_def_id);\n         let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n         self.link_pattern(mc, discr_cmt, &local.pat);\n     }\n@@ -1089,7 +1096,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// linked to the lifetime of its guarantor (if any).\n     fn link_match(&self, discr: &hir::Expr, arms: &[hir::Arm]) {\n         debug!(\"regionck::for_match()\");\n-        let mc = mc::MemCategorizationContext::new(self);\n+        let mc = &mc::MemCategorizationContext::new(self, self.subject_def_id);\n         let discr_cmt = ignore_err!(mc.cat_expr(discr));\n         debug!(\"discr_cmt={:?}\", discr_cmt);\n         for arm in arms {\n@@ -1104,7 +1111,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// linked to the lifetime of its guarantor (if any).\n     fn link_fn_args(&self, body_scope: CodeExtent<'tcx>, args: &[hir::Arg]) {\n         debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n-        let mc = mc::MemCategorizationContext::new(self);\n+        let mc = &mc::MemCategorizationContext::new(self, self.subject_def_id);\n         for arg in args {\n             let arg_ty = self.node_ty(arg.id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n@@ -1121,13 +1128,13 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// Link lifetimes of any ref bindings in `root_pat` to the pointers found\n     /// in the discriminant, if needed.\n     fn link_pattern<'t>(&self,\n-                        mc: mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n+                        mc: &mc::MemCategorizationContext<'a, 'gcx, 'tcx>,\n                         discr_cmt: mc::cmt<'tcx>,\n                         root_pat: &hir::Pat) {\n         debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n                discr_cmt,\n                root_pat);\n-    let _ = mc.cat_pattern(discr_cmt, root_pat, |_, sub_cmt, sub_pat| {\n+        let _ = mc.cat_pattern(discr_cmt, root_pat, |_, sub_cmt, sub_pat| {\n                 match sub_pat.node {\n                     // `ref x` pattern\n                     PatKind::Binding(hir::BindByRef(mutbl), ..) => {\n@@ -1147,7 +1154,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     autoref: &adjustment::AutoBorrow<'tcx>)\n     {\n         debug!(\"link_autoref(autoderefs={}, autoref={:?})\", autoderefs, autoref);\n-        let mc = mc::MemCategorizationContext::new(self);\n+        let mc = mc::MemCategorizationContext::new(self, self.subject_def_id);\n         let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n         debug!(\"expr_cmt={:?}\", expr_cmt);\n \n@@ -1171,7 +1178,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                    callee_scope: CodeExtent<'tcx>) {\n         debug!(\"link_by_ref(expr={:?}, callee_scope={:?})\",\n                expr, callee_scope);\n-        let mc = mc::MemCategorizationContext::new(self);\n+        let mc = mc::MemCategorizationContext::new(self, self.subject_def_id);\n         let expr_cmt = ignore_err!(mc.cat_expr(expr));\n         let borrow_region = self.tcx.mk_region(ty::ReScope(callee_scope));\n         self.link_region(expr.span, borrow_region, ty::ImmBorrow, expr_cmt);"}, {"sha": "227f06436ee1751ef92cfb64f19df261e25f602f", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -164,9 +164,11 @@ impl<'a, 'gcx, 'tcx> AdjustBorrowKind<'a, 'gcx, 'tcx> {\n         debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id());\n \n         {\n+            let body_owner_def_id = self.fcx.tcx.hir.body_owner_def_id(body.id());\n             let mut euv =\n                 euv::ExprUseVisitor::with_options(self,\n                                                   self.fcx,\n+                                                  body_owner_def_id,\n                                                   mc::MemCategorizationOptions {\n                                                       during_closure_kind_inference: true\n                                                   });"}, {"sha": "49785d8850f4de72595df5d4eb08904edef7e1d9", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -12,6 +12,7 @@\n //! up data structures required by type-checking/translation.\n \n use rustc::middle::free_region::FreeRegionMap;\n+use rustc::middle::region::RegionMaps;\n use rustc::middle::lang_items::UnsizeTraitLangItem;\n \n use rustc::traits::{self, ObligationCause, Reveal};\n@@ -342,10 +343,11 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         // Finally, resolve all regions.\n+        let region_maps = RegionMaps::new();\n         let mut free_regions = FreeRegionMap::new();\n         free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n             .caller_bounds);\n-        infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n+        infcx.resolve_regions_and_report_errors(impl_did, &region_maps, &free_regions);\n \n         CoerceUnsizedInfo {\n             custom_kind: kind"}, {"sha": "a81c0846a279489534080fc789c3cb7ef5509040", "filename": "src/test/run-pass/kindck-implicit-close-over-mut-var.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73cd9bde373cc134aa2ebb6a8064d532621ca0a6/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs?ref=73cd9bde373cc134aa2ebb6a8064d532621ca0a6", "patch": "@@ -1,4 +1,4 @@\n-s// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //"}]}