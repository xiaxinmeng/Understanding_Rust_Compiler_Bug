{"sha": "f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyZjhmYjJjMjBlMWEwMzcxZjQzMzc5YWMxM2ViMzIzZjk1YjRmNGI=", "commit": {"author": {"name": "Christian Poveda", "email": "git@christianpoveda.xyz", "date": "2020-02-06T00:46:50Z"}, "committer": {"name": "Christian Poveda", "email": "git@christianpoveda.xyz", "date": "2020-02-14T21:37:30Z"}, "message": "migrate more functions", "tree": {"sha": "8c322c152216513bbd4e7330d7d40eeb6485187a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c322c152216513bbd4e7330d7d40eeb6485187a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYIAB0WIQRsB8A/3NrzTlMMjT0nUl7150IKUAUCXkcTGgAKCRAnUl7150IK\nUHe8AQDSnzhPA2L1cuZZtMSa8Z/FQMPq7xWE5WAq+vuqz3S8XQEA9CZ49F6HT7XL\nzVgClA3Edmau0Eq7LH9Ge3iKxJgk/wM=\n=MdcT\n-----END PGP SIGNATURE-----", "payload": "tree 8c322c152216513bbd4e7330d7d40eeb6485187a\nparent e7d6e718b91d4122ee5ba8fa2ac67fb49af93f89\nauthor Christian Poveda <git@christianpoveda.xyz> 1580950010 -0500\ncommitter Christian Poveda <git@christianpoveda.xyz> 1581716250 -0500\n\nmigrate more functions\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b", "html_url": "https://github.com/rust-lang/rust/commit/f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b/comments", "author": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pvdrz", "id": 31802960, "node_id": "MDQ6VXNlcjMxODAyOTYw", "avatar_url": "https://avatars.githubusercontent.com/u/31802960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pvdrz", "html_url": "https://github.com/pvdrz", "followers_url": "https://api.github.com/users/pvdrz/followers", "following_url": "https://api.github.com/users/pvdrz/following{/other_user}", "gists_url": "https://api.github.com/users/pvdrz/gists{/gist_id}", "starred_url": "https://api.github.com/users/pvdrz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pvdrz/subscriptions", "organizations_url": "https://api.github.com/users/pvdrz/orgs", "repos_url": "https://api.github.com/users/pvdrz/repos", "events_url": "https://api.github.com/users/pvdrz/events{/privacy}", "received_events_url": "https://api.github.com/users/pvdrz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7d6e718b91d4122ee5ba8fa2ac67fb49af93f89", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7d6e718b91d4122ee5ba8fa2ac67fb49af93f89", "html_url": "https://github.com/rust-lang/rust/commit/e7d6e718b91d4122ee5ba8fa2ac67fb49af93f89"}], "stats": {"total": 317, "additions": 160, "deletions": 157}, "files": [{"sha": "f8a61a7c5a12a44e88092b686f0502c595dcc51b", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 0, "deletions": 157, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b", "patch": "@@ -702,163 +702,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_null(dest)?;\n             }\n \n-            // macOS API stubs.\n-            | \"pthread_attr_get_np\"\n-            | \"pthread_getattr_np\"\n-            => {\n-                this.write_null(dest)?;\n-            }\n-            \"pthread_get_stackaddr_np\" => {\n-                let stack_addr = Scalar::from_uint(STACK_ADDR, dest.layout.size);\n-                this.write_scalar(stack_addr, dest)?;\n-            }\n-            \"pthread_get_stacksize_np\" => {\n-                let stack_size = Scalar::from_uint(STACK_SIZE, dest.layout.size);\n-                this.write_scalar(stack_size, dest)?;\n-            }\n-            \"_tlv_atexit\" => {\n-                // FIXME: register the destructor.\n-            }\n-            \"_NSGetArgc\" => {\n-                this.write_scalar(this.machine.argc.expect(\"machine must be initialized\"), dest)?;\n-            }\n-            \"_NSGetArgv\" => {\n-                this.write_scalar(this.machine.argv.expect(\"machine must be initialized\"), dest)?;\n-            }\n-            \"SecRandomCopyBytes\" => {\n-                let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n-                let ptr = this.read_scalar(args[2])?.not_undef()?;\n-                this.gen_random(ptr, len as usize)?;\n-                this.write_null(dest)?;\n-            }\n-\n-            // Windows API stubs.\n-            // HANDLE = isize\n-            // DWORD = ULONG = u32\n-            // BOOL = i32\n-            \"GetProcessHeap\" => {\n-                // Just fake a HANDLE\n-                this.write_scalar(Scalar::from_int(1, this.pointer_size()), dest)?;\n-            }\n-            \"HeapAlloc\" => {\n-                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n-                let flags = this.read_scalar(args[1])?.to_u32()?;\n-                let size = this.read_scalar(args[2])?.to_machine_usize(this)?;\n-                let zero_init = (flags & 0x00000008) != 0; // HEAP_ZERO_MEMORY\n-                let res = this.malloc(size, zero_init, MiriMemoryKind::WinHeap);\n-                this.write_scalar(res, dest)?;\n-            }\n-            \"HeapFree\" => {\n-                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n-                let _flags = this.read_scalar(args[1])?.to_u32()?;\n-                let ptr = this.read_scalar(args[2])?.not_undef()?;\n-                this.free(ptr, MiriMemoryKind::WinHeap)?;\n-                this.write_scalar(Scalar::from_int(1, Size::from_bytes(4)), dest)?;\n-            }\n-            \"HeapReAlloc\" => {\n-                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n-                let _flags = this.read_scalar(args[1])?.to_u32()?;\n-                let ptr = this.read_scalar(args[2])?.not_undef()?;\n-                let size = this.read_scalar(args[3])?.to_machine_usize(this)?;\n-                let res = this.realloc(ptr, size, MiriMemoryKind::WinHeap)?;\n-                this.write_scalar(res, dest)?;\n-            }\n-\n-            \"SetLastError\" => {\n-                this.set_last_error(this.read_scalar(args[0])?.not_undef()?)?;\n-            }\n-            \"GetLastError\" => {\n-                let last_error = this.get_last_error()?;\n-                this.write_scalar(last_error, dest)?;\n-            }\n-\n-            \"AddVectoredExceptionHandler\" => {\n-                // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n-                this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n-            }\n-\n-            | \"InitializeCriticalSection\"\n-            | \"EnterCriticalSection\"\n-            | \"LeaveCriticalSection\"\n-            | \"DeleteCriticalSection\"\n-            => {\n-                // Nothing to do, not even a return value.\n-            }\n-\n-            | \"GetModuleHandleW\"\n-            | \"GetProcAddress\"\n-            | \"TryEnterCriticalSection\"\n-            | \"GetConsoleScreenBufferInfo\"\n-            | \"SetConsoleTextAttribute\"\n-            => {\n-                // Pretend these do not exist / nothing happened, by returning zero.\n-                this.write_null(dest)?;\n-            }\n-\n-            \"GetSystemInfo\" => {\n-                let system_info = this.deref_operand(args[0])?;\n-                // Initialize with `0`.\n-                this.memory.write_bytes(\n-                    system_info.ptr,\n-                    iter::repeat(0u8).take(system_info.layout.size.bytes() as usize),\n-                )?;\n-                // Set number of processors.\n-                let dword_size = Size::from_bytes(4);\n-                let num_cpus = this.mplace_field(system_info, 6)?;\n-                this.write_scalar(Scalar::from_int(NUM_CPUS, dword_size), num_cpus.into())?;\n-            }\n-\n-            \"TlsAlloc\" => {\n-                // This just creates a key; Windows does not natively support TLS destructors.\n-\n-                // Create key and return it.\n-                let key = this.machine.tls.create_tls_key(None) as u128;\n-\n-                // Figure out how large a TLS key actually is. This is `c::DWORD`.\n-                if dest.layout.size.bits() < 128\n-                    && key >= (1u128 << dest.layout.size.bits() as u128)\n-                {\n-                    throw_unsup!(OutOfTls);\n-                }\n-                this.write_scalar(Scalar::from_uint(key, dest.layout.size), dest)?;\n-            }\n-            \"TlsGetValue\" => {\n-                let key = this.read_scalar(args[0])?.to_u32()? as u128;\n-                let ptr = this.machine.tls.load_tls(key, tcx)?;\n-                this.write_scalar(ptr, dest)?;\n-            }\n-            \"TlsSetValue\" => {\n-                let key = this.read_scalar(args[0])?.to_u32()? as u128;\n-                let new_ptr = this.read_scalar(args[1])?.not_undef()?;\n-                this.machine.tls.store_tls(key, this.test_null(new_ptr)?)?;\n-\n-                // Return success (`1`).\n-                this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n-            }\n-            \"GetStdHandle\" => {\n-                let which = this.read_scalar(args[0])?.to_i32()?;\n-                // We just make this the identity function, so we know later in `WriteFile`\n-                // which one it is.\n-                this.write_scalar(Scalar::from_int(which, this.pointer_size()), dest)?;\n-            }\n-            \"GetConsoleMode\" => {\n-                // Everything is a pipe.\n-                this.write_null(dest)?;\n-            }\n-            \"GetCommandLineW\" => {\n-                this.write_scalar(\n-                    this.machine.cmd_line.expect(\"machine must be initialized\"),\n-                    dest,\n-                )?;\n-            }\n-            // The actual name of 'RtlGenRandom'\n-            \"SystemFunction036\" => {\n-                let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                let len = this.read_scalar(args[1])?.to_u32()?;\n-                this.gen_random(ptr, len as usize)?;\n-                this.write_scalar(Scalar::from_bool(true), dest)?;\n-            }\n-\n             _ => match this.tcx.sess.target.target.target_os.to_lowercase().as_str() {\n                 \"linux\" | \"macos\" => posix::EvalContextExt::emulate_foreign_item_by_name(this, link_name, args, dest)?,\n                 \"windows\" => windows::EvalContextExt::emulate_foreign_item_by_name(this, link_name, args, dest)?,"}, {"sha": "31a0a815891eca39cc58c8ab84088147280e51e9", "filename": "src/shims/foreign_items/posix/linux.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Flinux.rs?ref=f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b", "patch": "@@ -38,6 +38,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n+            \"pthread_getattr_np\" => {\n+                this.write_null(dest)?;\n+            }\n             _ => throw_unsup_format!(\"can't call foreign function: {}\", link_name),\n         };\n "}, {"sha": "8ed793b6c03c1fe394e03797d08c74218f8874f9", "filename": "src/shims/foreign_items/posix/macos.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix%2Fmacos.rs?ref=f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b", "patch": "@@ -53,6 +53,35 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n+            // macOS API stubs.\n+            \"pthread_attr_get_np\" => {\n+                this.write_null(dest)?;\n+            }\n+            \"pthread_get_stackaddr_np\" => {\n+                let stack_addr = Scalar::from_uint(STACK_ADDR, dest.layout.size);\n+                this.write_scalar(stack_addr, dest)?;\n+            }\n+            \"pthread_get_stacksize_np\" => {\n+                let stack_size = Scalar::from_uint(STACK_SIZE, dest.layout.size);\n+                this.write_scalar(stack_size, dest)?;\n+            }\n+            \"_tlv_atexit\" => {\n+                // FIXME: register the destructor.\n+            }\n+            \"_NSGetArgc\" => {\n+                this.write_scalar(this.machine.argc.expect(\"machine must be initialized\"), dest)?;\n+            }\n+            \"_NSGetArgv\" => {\n+                this.write_scalar(this.machine.argv.expect(\"machine must be initialized\"), dest)?;\n+            }\n+            \"SecRandomCopyBytes\" => {\n+                let len = this.read_scalar(args[1])?.to_machine_usize(this)?;\n+                let ptr = this.read_scalar(args[2])?.not_undef()?;\n+                this.gen_random(ptr, len as usize)?;\n+                this.write_null(dest)?;\n+            }\n+\n+\n             _ => throw_unsup_format!(\"can't call foreign function: {}\", link_name),\n         };\n "}, {"sha": "e16a89a126fd1d5d269f2084a59d296e8ae5c83f", "filename": "src/shims/foreign_items/windows.rs", "status": "modified", "additions": 128, "deletions": 0, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b/src%2Fshims%2Fforeign_items%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b/src%2Fshims%2Fforeign_items%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fwindows.rs?ref=f2f8fb2c20e1a0371f43379ac13eb323f95b4f4b", "patch": "@@ -1,5 +1,6 @@\n use crate::*;\n use rustc::ty::layout::Size;\n+use std::iter;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -10,6 +11,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         dest: PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n+        let tcx = &{ this.tcx.tcx };\n \n         match link_name {\n             // Environment related shims\n@@ -66,6 +68,132 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     dest,\n                 )?;\n             }\n+            // Windows API stubs.\n+            // HANDLE = isize\n+            // DWORD = ULONG = u32\n+            // BOOL = i32\n+            \"GetProcessHeap\" => {\n+                // Just fake a HANDLE\n+                this.write_scalar(Scalar::from_int(1, this.pointer_size()), dest)?;\n+            }\n+            \"HeapAlloc\" => {\n+                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n+                let flags = this.read_scalar(args[1])?.to_u32()?;\n+                let size = this.read_scalar(args[2])?.to_machine_usize(this)?;\n+                let zero_init = (flags & 0x00000008) != 0; // HEAP_ZERO_MEMORY\n+                let res = this.malloc(size, zero_init, MiriMemoryKind::WinHeap);\n+                this.write_scalar(res, dest)?;\n+            }\n+            \"HeapFree\" => {\n+                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n+                let _flags = this.read_scalar(args[1])?.to_u32()?;\n+                let ptr = this.read_scalar(args[2])?.not_undef()?;\n+                this.free(ptr, MiriMemoryKind::WinHeap)?;\n+                this.write_scalar(Scalar::from_int(1, Size::from_bytes(4)), dest)?;\n+            }\n+            \"HeapReAlloc\" => {\n+                let _handle = this.read_scalar(args[0])?.to_machine_isize(this)?;\n+                let _flags = this.read_scalar(args[1])?.to_u32()?;\n+                let ptr = this.read_scalar(args[2])?.not_undef()?;\n+                let size = this.read_scalar(args[3])?.to_machine_usize(this)?;\n+                let res = this.realloc(ptr, size, MiriMemoryKind::WinHeap)?;\n+                this.write_scalar(res, dest)?;\n+            }\n+\n+            \"SetLastError\" => {\n+                this.set_last_error(this.read_scalar(args[0])?.not_undef()?)?;\n+            }\n+            \"GetLastError\" => {\n+                let last_error = this.get_last_error()?;\n+                this.write_scalar(last_error, dest)?;\n+            }\n+\n+            \"AddVectoredExceptionHandler\" => {\n+                // Any non zero value works for the stdlib. This is just used for stack overflows anyway.\n+                this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n+            }\n+\n+            | \"InitializeCriticalSection\"\n+            | \"EnterCriticalSection\"\n+            | \"LeaveCriticalSection\"\n+            | \"DeleteCriticalSection\"\n+            => {\n+                // Nothing to do, not even a return value.\n+            }\n+\n+            | \"GetModuleHandleW\"\n+            | \"GetProcAddress\"\n+            | \"TryEnterCriticalSection\"\n+            | \"GetConsoleScreenBufferInfo\"\n+            | \"SetConsoleTextAttribute\"\n+            => {\n+                // Pretend these do not exist / nothing happened, by returning zero.\n+                this.write_null(dest)?;\n+            }\n+\n+            \"GetSystemInfo\" => {\n+                let system_info = this.deref_operand(args[0])?;\n+                // Initialize with `0`.\n+                this.memory.write_bytes(\n+                    system_info.ptr,\n+                    iter::repeat(0u8).take(system_info.layout.size.bytes() as usize),\n+                )?;\n+                // Set number of processors.\n+                let dword_size = Size::from_bytes(4);\n+                let num_cpus = this.mplace_field(system_info, 6)?;\n+                this.write_scalar(Scalar::from_int(NUM_CPUS, dword_size), num_cpus.into())?;\n+            }\n+\n+            \"TlsAlloc\" => {\n+                // This just creates a key; Windows does not natively support TLS destructors.\n+\n+                // Create key and return it.\n+                let key = this.machine.tls.create_tls_key(None) as u128;\n+\n+                // Figure out how large a TLS key actually is. This is `c::DWORD`.\n+                if dest.layout.size.bits() < 128\n+                    && key >= (1u128 << dest.layout.size.bits() as u128)\n+                {\n+                    throw_unsup!(OutOfTls);\n+                }\n+                this.write_scalar(Scalar::from_uint(key, dest.layout.size), dest)?;\n+            }\n+            \"TlsGetValue\" => {\n+                let key = this.read_scalar(args[0])?.to_u32()? as u128;\n+                let ptr = this.machine.tls.load_tls(key, tcx)?;\n+                this.write_scalar(ptr, dest)?;\n+            }\n+            \"TlsSetValue\" => {\n+                let key = this.read_scalar(args[0])?.to_u32()? as u128;\n+                let new_ptr = this.read_scalar(args[1])?.not_undef()?;\n+                this.machine.tls.store_tls(key, this.test_null(new_ptr)?)?;\n+\n+                // Return success (`1`).\n+                this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n+            }\n+            \"GetStdHandle\" => {\n+                let which = this.read_scalar(args[0])?.to_i32()?;\n+                // We just make this the identity function, so we know later in `WriteFile`\n+                // which one it is.\n+                this.write_scalar(Scalar::from_int(which, this.pointer_size()), dest)?;\n+            }\n+            \"GetConsoleMode\" => {\n+                // Everything is a pipe.\n+                this.write_null(dest)?;\n+            }\n+            \"GetCommandLineW\" => {\n+                this.write_scalar(\n+                    this.machine.cmd_line.expect(\"machine must be initialized\"),\n+                    dest,\n+                )?;\n+            }\n+            // The actual name of 'RtlGenRandom'\n+            \"SystemFunction036\" => {\n+                let ptr = this.read_scalar(args[0])?.not_undef()?;\n+                let len = this.read_scalar(args[1])?.to_u32()?;\n+                this.gen_random(ptr, len as usize)?;\n+                this.write_scalar(Scalar::from_bool(true), dest)?;\n+            }\n             _ => throw_unsup_format!(\"can't call foreign function: {}\", link_name),\n         }\n "}]}