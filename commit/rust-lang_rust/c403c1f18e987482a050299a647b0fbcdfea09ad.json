{"sha": "c403c1f18e987482a050299a647b0fbcdfea09ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0MDNjMWYxOGU5ODc0ODJhMDUwMjk5YTY0N2IwZmJjZGZlYTA5YWQ=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-11-26T04:02:15Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@palantir.com", "date": "2013-11-26T21:56:02Z"}, "message": "Clean up SmallVector use a bit", "tree": {"sha": "122251a53e17ae499c2af9f4cf190197c2a075a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/122251a53e17ae499c2af9f4cf190197c2a075a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c403c1f18e987482a050299a647b0fbcdfea09ad", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c403c1f18e987482a050299a647b0fbcdfea09ad", "html_url": "https://github.com/rust-lang/rust/commit/c403c1f18e987482a050299a647b0fbcdfea09ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c403c1f18e987482a050299a647b0fbcdfea09ad/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "url": "https://api.github.com/repos/rust-lang/rust/commits/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58", "html_url": "https://github.com/rust-lang/rust/commit/c144752a2de4ffe3a2a22da9a8309ca2ecd85c58"}], "stats": {"total": 146, "additions": 38, "deletions": 108}, "files": [{"sha": "64ce1e7b4e7de7d039198f3c3ba15106ee37f0f8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c403c1f18e987482a050299a647b0fbcdfea09ad/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c403c1f18e987482a050299a647b0fbcdfea09ad/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c403c1f18e987482a050299a647b0fbcdfea09ad", "patch": "@@ -33,7 +33,6 @@ use syntax::codemap;\n use syntax::fold::*;\n use syntax::fold;\n use syntax::parse::token;\n-use syntax::util::small_vector::SmallVector;\n use syntax;\n \n use std::at_vec;\n@@ -348,20 +347,14 @@ fn simplify_ast(ii: &ast::inlined_item) -> ast::inlined_item {\n \n     match *ii {\n         //hack: we're not dropping items\n-        ast::ii_item(i) => ast::ii_item(get_only_one(fld.fold_item(i))),\n+        ast::ii_item(i) => ast::ii_item(fld.fold_item(i)\n+                                        .expect_one(\"expected one item\")),\n         ast::ii_method(d, is_provided, m) =>\n           ast::ii_method(d, is_provided, fld.fold_method(m)),\n         ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i))\n     }\n }\n \n-fn get_only_one<T>(mut v: SmallVector<T>) -> T {\n-    if v.len() != 1 {\n-        fail!(\"Attempting to extract unique member but there isn't one\");\n-    }\n-    v.pop()\n-}\n-\n fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder(chi_doc);\n@@ -387,7 +380,8 @@ fn renumber_ast(xcx: @ExtendedDecodeContext, ii: ast::inlined_item)\n         xcx: xcx,\n     };\n     match ii {\n-        ast::ii_item(i) => ast::ii_item(get_only_one(fld.fold_item(i))),\n+        ast::ii_item(i) => ast::ii_item(fld.fold_item(i)\n+                                        .expect_one(\"expected one item\")),\n         ast::ii_method(d, is_provided, m) =>\n           ast::ii_method(xcx.tr_def_id(d), is_provided, fld.fold_method(m)),\n         ast::ii_foreign(i) => ast::ii_foreign(fld.fold_foreign_item(i)),"}, {"sha": "45f82d9b3a9359cb08d63aa260b0fd62c56c9675", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c403c1f18e987482a050299a647b0fbcdfea09ad/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c403c1f18e987482a050299a647b0fbcdfea09ad/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c403c1f18e987482a050299a647b0fbcdfea09ad", "patch": "@@ -678,7 +678,9 @@ pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n     let rename_fld = renames_to_fold(pending_renames);\n     let new_view_items = b.view_items.map(|x| fld.fold_view_item(x));\n     let new_stmts = b.stmts.iter()\n-            .flat_map(|x| fld.fold_stmt(mustbeone(rename_fld.fold_stmt(*x))).move_iter())\n+            .map(|x| rename_fld.fold_stmt(*x)\n+                 .expect_one(\"rename_fold didn't return one value\"))\n+            .flat_map(|x| fld.fold_stmt(x).move_iter())\n             .collect();\n     let new_expr = b.expr.map(|x| fld.fold_expr(rename_fld.fold_expr(x)));\n     Block{\n@@ -691,14 +693,6 @@ pub fn expand_block_elts(exts: SyntaxEnv, b: &Block, fld: &MacroExpander)\n     }\n }\n \n-// rename_fold should never return anything other than one thing\n-fn mustbeone<T>(mut val : SmallVector<T>) -> T {\n-    if val.len() != 1 {\n-        fail!(\"rename_fold didn't return one value\");\n-    }\n-    val.pop()\n-}\n-\n // get the (innermost) BlockInfo from an exts stack\n fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n     match exts.find_in_topmost_frame(&intern(special_block_name)) {\n@@ -734,11 +728,8 @@ pub fn renames_to_fold(renames: @mut ~[(ast::Ident,ast::Name)]) -> @ast_fold {\n \n // perform a bunch of renames\n fn apply_pending_renames(folder : @ast_fold, stmt : ast::Stmt) -> @ast::Stmt {\n-    let mut stmts = folder.fold_stmt(&stmt);\n-    if stmts.len() != 1 {\n-        fail!(\"renaming of stmt did not produce one stmt\");\n-    }\n-    stmts.pop()\n+    folder.fold_stmt(&stmt)\n+            .expect_one(\"renaming of stmt did not produce one stmt\")\n }\n \n \n@@ -1185,11 +1176,8 @@ fn mark_expr(expr : @ast::Expr, m : Mrk) -> @ast::Expr {\n \n // apply a given mark to the given stmt. Used following the expansion of a macro.\n fn mark_stmt(expr : &ast::Stmt, m : Mrk) -> @ast::Stmt {\n-    let mut stmts = new_mark_folder(m).fold_stmt(expr);\n-    if stmts.len() != 1 {\n-        fail!(\"marking a stmt didn't return a stmt\");\n-    }\n-    stmts.pop()\n+    new_mark_folder(m).fold_stmt(expr)\n+            .expect_one(\"marking a stmt didn't return a stmt\")\n }\n \n // apply a given mark to the given item. Used following the expansion of a macro."}, {"sha": "71eee8b7ccca0516eeafedb6740822b777b6b0ce", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 27, "deletions": 79, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/c403c1f18e987482a050299a647b0fbcdfea09ad/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c403c1f18e987482a050299a647b0fbcdfea09ad/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=c403c1f18e987482a050299a647b0fbcdfea09ad", "patch": "@@ -54,53 +54,29 @@ impl<T> SmallVector<T> {\n         match *self {\n             Zero => *self = One(v),\n             One(*) => {\n-                let mut tmp = Many(~[]);\n-                util::swap(self, &mut tmp);\n-                match *self {\n-                    Many(ref mut vs) => {\n-                        match tmp {\n-                            One(v1) => {\n-                                vs.push(v1);\n-                                vs.push(v);\n-                            }\n-                            _ => unreachable!()\n-                        }\n-                    }\n+                let one = util::replace(self, Zero);\n+                match one {\n+                    One(v1) => util::replace(self, Many(~[v1, v])),\n                     _ => unreachable!()\n-                }\n+                };\n             }\n             Many(ref mut vs) => vs.push(v)\n         }\n     }\n \n-    pub fn pop(&mut self) -> T {\n-        match *self {\n-            Zero => fail!(\"attempted to pop from an empty SmallVector\"),\n-            One(*) => {\n-                let mut tmp = Zero;\n-                util::swap(self, &mut tmp);\n-                match tmp {\n-                    One(v) => v,\n-                    _ => unreachable!()\n-                }\n-            }\n-            // Should this reduce to a One if possible?\n-            Many(ref mut vs) => vs.pop()\n-        }\n-    }\n-\n-    pub fn get<'a>(&'a self, idx: uint) -> &'a T {\n+    fn get<'a>(&'a self, idx: uint) -> &'a T {\n         match *self {\n             One(ref v) if idx == 0 => v,\n             Many(ref vs) => &vs[idx],\n             _ => fail!(\"Out of bounds access\")\n         }\n     }\n \n-    pub fn iter<'a>(&'a self) -> SmallVectorIterator<'a, T> {\n-        SmallVectorIterator {\n-            vec: self,\n-            idx: 0\n+    pub fn expect_one(self, err: &'static str) -> T {\n+        match self {\n+            One(v) => v,\n+            Many([v]) => v,\n+            _ => fail!(err)\n         }\n     }\n \n@@ -113,27 +89,6 @@ impl<T> SmallVector<T> {\n     }\n }\n \n-pub struct SmallVectorIterator<'vec, T> {\n-    priv vec: &'vec SmallVector<T>,\n-    priv idx: uint\n-}\n-\n-impl<'vec, T> Iterator<&'vec T> for SmallVectorIterator<'vec, T> {\n-    fn next(&mut self) -> Option<&'vec T> {\n-        if self.idx == self.vec.len() {\n-            return None;\n-        }\n-\n-        self.idx += 1;\n-        Some(self.vec.get(self.idx - 1))\n-    }\n-\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        let rem = self.vec.len() - self.idx;\n-        (rem, Some(rem))\n-    }\n-}\n-\n pub enum SmallVectorMoveIterator<T> {\n     priv ZeroIterator,\n     priv OneIterator(T),\n@@ -192,18 +147,6 @@ mod test {\n         assert_eq!(&3, v.get(2));\n     }\n \n-    #[test]\n-    fn test_pop() {\n-        let mut v = SmallVector::one(1);\n-        assert_eq!(1, v.pop());\n-        assert_eq!(0, v.len());\n-\n-        let mut v= SmallVector::many(~[1, 2]);\n-        assert_eq!(2, v.pop());\n-        assert_eq!(1, v.pop());\n-        assert_eq!(0, v.len());\n-    }\n-\n     #[test]\n     fn test_from_iterator() {\n         let v: SmallVector<int> = (~[1, 2, 3]).move_iter().collect();\n@@ -214,28 +157,33 @@ mod test {\n     }\n \n     #[test]\n-    fn test_iter() {\n+    fn test_move_iter() {\n         let v = SmallVector::zero();\n-        let v: ~[&int] = v.iter().collect();\n+        let v: ~[int] = v.move_iter().collect();\n         assert_eq!(~[], v);\n \n         let v = SmallVector::one(1);\n-        assert_eq!(~[&1], v.iter().collect());\n+        assert_eq!(~[1], v.move_iter().collect());\n \n         let v = SmallVector::many(~[1, 2, 3]);\n-        assert_eq!(~[&1, &2, &3], v.iter().collect());\n+        assert_eq!(~[1, 2, 3], v.move_iter().collect());\n     }\n \n     #[test]\n-    fn test_move_iter() {\n-        let v = SmallVector::zero();\n-        let v: ~[int] = v.move_iter().collect();\n-        assert_eq!(~[], v);\n+    #[should_fail]\n+    fn test_expect_one_zero() {\n+        let _: int = SmallVector::zero().expect_one(\"\");\n+    }\n \n-        let v = SmallVector::one(1);\n-        assert_eq!(~[1], v.move_iter().collect());\n+    #[test]\n+    #[should_fail]\n+    fn test_expect_one_many() {\n+        SmallVector::many(~[1, 2]).expect_one(\"\");\n+    }\n \n-        let v = SmallVector::many(~[1, 2, 3]);\n-        assert_eq!(~[1, 2, 3], v.move_iter().collect());\n+    #[test]\n+    fn test_expect_one_one() {\n+        assert_eq!(1, SmallVector::one(1).expect_one(\"\"));\n+        assert_eq!(1, SmallVector::many(~[1]).expect_one(\"\"));\n     }\n }"}]}