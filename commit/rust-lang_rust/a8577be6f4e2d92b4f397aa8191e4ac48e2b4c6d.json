{"sha": "a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NTc3YmU2ZjRlMmQ5MmI0ZjM5N2FhODE5MWU0YWM0OGUyYjRjNmQ=", "commit": {"author": {"name": "P1start", "email": "rewi-github@whanau.org", "date": "2014-09-13T02:01:17Z"}, "committer": {"name": "P1start", "email": "rewi-github@whanau.org", "date": "2014-10-01T22:09:29Z"}, "message": "Output a note when lifetimes cannot be elided from functions", "tree": {"sha": "5f84143453fb6e5c040648326ca6a7a4d093ae32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f84143453fb6e5c040648326ca6a7a4d093ae32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d", "html_url": "https://github.com/rust-lang/rust/commit/a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d/comments", "author": {"login": "ftxqxd", "id": 2055302, "node_id": "MDQ6VXNlcjIwNTUzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftxqxd", "html_url": "https://github.com/ftxqxd", "followers_url": "https://api.github.com/users/ftxqxd/followers", "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}", "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions", "organizations_url": "https://api.github.com/users/ftxqxd/orgs", "repos_url": "https://api.github.com/users/ftxqxd/repos", "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}", "received_events_url": "https://api.github.com/users/ftxqxd/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ftxqxd", "id": 2055302, "node_id": "MDQ6VXNlcjIwNTUzMDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2055302?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ftxqxd", "html_url": "https://github.com/ftxqxd", "followers_url": "https://api.github.com/users/ftxqxd/followers", "following_url": "https://api.github.com/users/ftxqxd/following{/other_user}", "gists_url": "https://api.github.com/users/ftxqxd/gists{/gist_id}", "starred_url": "https://api.github.com/users/ftxqxd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ftxqxd/subscriptions", "organizations_url": "https://api.github.com/users/ftxqxd/orgs", "repos_url": "https://api.github.com/users/ftxqxd/repos", "events_url": "https://api.github.com/users/ftxqxd/events{/privacy}", "received_events_url": "https://api.github.com/users/ftxqxd/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60e7317345f246a8169bbfe721473f693d54cade", "url": "https://api.github.com/repos/rust-lang/rust/commits/60e7317345f246a8169bbfe721473f693d54cade", "html_url": "https://github.com/rust-lang/rust/commit/60e7317345f246a8169bbfe721473f693d54cade"}], "stats": {"total": 125, "additions": 103, "deletions": 22}, "files": [{"sha": "fa68814ea16fce997370a66af50fa7bd47e438cd", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 69, "deletions": 14, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d", "patch": "@@ -59,18 +59,19 @@ use middle::subst::{VecPerParamSpace};\n use middle::ty;\n use middle::typeck::lookup_def_tcx;\n use middle::typeck::infer;\n-use middle::typeck::rscope::{ExplicitRscope, RegionScope, SpecificRscope};\n+use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope};\n use middle::typeck::rscope;\n use middle::typeck::TypeAndSubsts;\n use middle::typeck;\n use util::ppaux::{Repr, UserString};\n \n use std::collections::HashMap;\n use std::rc::Rc;\n-use syntax::abi;\n-use syntax::{ast, ast_util};\n+use std::iter::AdditiveIterator;\n+use syntax::{abi, ast, ast_util};\n use syntax::codemap::Span;\n use syntax::parse::token;\n+use syntax::print::pprust;\n \n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n@@ -147,10 +148,49 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n         None => {\n             match rscope.anon_regions(default_span, 1) {\n-                Err(()) => {\n+                Err(v) => {\n                     debug!(\"optional region in illegal location\");\n                     span_err!(this.tcx().sess, default_span, E0106,\n                         \"missing lifetime specifier\");\n+                    match v {\n+                        Some(v) => {\n+                            let mut m = String::new();\n+                            let len = v.len();\n+                            for (i, (name, n)) in v.move_iter().enumerate() {\n+                                m.push_str(if n == 1 {\n+                                    format!(\"`{}`\", name)\n+                                } else {\n+                                    format!(\"one of `{}`'s {} elided lifetimes\", name, n)\n+                                }.as_slice());\n+\n+                                if len == 2 && i == 0 {\n+                                    m.push_str(\" or \");\n+                                } else if i == len - 2 {\n+                                    m.push_str(\", or \");\n+                                } else if i != len - 1 {\n+                                    m.push_str(\", \");\n+                                }\n+                            }\n+                            if len == 1 {\n+                                span_note!(this.tcx().sess, default_span,\n+                                    \"this function's return type contains a borrowed value, but \\\n+                                     the signature does not say which {} it is borrowed from\",\n+                                    m);\n+                            } else if len == 0 {\n+                                span_note!(this.tcx().sess, default_span,\n+                                    \"this function's return type contains a borrowed value, but \\\n+                                     there is no value for it to be borrowed from\");\n+                                span_note!(this.tcx().sess, default_span,\n+                                    \"consider giving it a 'static lifetime\");\n+                            } else {\n+                                span_note!(this.tcx().sess, default_span,\n+                                    \"this function's return type contains a borrowed value, but \\\n+                                     the signature does not say whether it is borrowed from {}\",\n+                                    m);\n+                            }\n+                        }\n+                        None => {},\n+                    }\n                     ty::ReStatic\n                 }\n \n@@ -217,7 +257,7 @@ fn ast_path_substs<'tcx,AC,RS>(\n \n         match anon_regions {\n             Ok(v) => v.into_iter().collect(),\n-            Err(()) => Vec::from_fn(expected_num_region_params,\n+            Err(_) => Vec::from_fn(expected_num_region_params,\n                                     |_| ty::ReStatic) // hokey\n         }\n     };\n@@ -1153,15 +1193,20 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n     };\n \n     // HACK(eddyb) replace the fake self type in the AST with the actual type.\n-    let input_tys = if self_ty.is_some() {\n+    let input_params = if self_ty.is_some() {\n         decl.inputs.slice_from(1)\n     } else {\n         decl.inputs.as_slice()\n     };\n-    let input_tys = input_tys.iter().map(|a| ty_of_arg(this, &rb, a, None));\n-    let self_and_input_tys: Vec<_> =\n+    let input_tys = input_params.iter().map(|a| ty_of_arg(this, &rb, a, None));\n+    let input_pats: Vec<String> = input_params.iter()\n+                                              .map(|a| pprust::pat_to_string(&*a.pat))\n+                                              .collect();\n+    let self_and_input_tys: Vec<ty::t> =\n         self_ty.into_iter().chain(input_tys).collect();\n \n+    let mut lifetimes_for_params: Vec<(String, Vec<ty::Region>)> = Vec::new();\n+\n     // Second, if there was exactly one lifetime (either a substitution or a\n     // reference) in the arguments, then any anonymous regions in the output\n     // have that lifetime.\n@@ -1172,15 +1217,25 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n             drop(self_and_input_tys_iter.next())\n         }\n \n-        let mut accumulator = Vec::new();\n-        for input_type in self_and_input_tys_iter {\n-            ty::accumulate_lifetimes_in_type(&mut accumulator, *input_type)\n+        for (input_type, input_pat) in self_and_input_tys_iter.zip(input_pats.into_iter()) {\n+            let mut accumulator = Vec::new();\n+            ty::accumulate_lifetimes_in_type(&mut accumulator, *input_type);\n+            lifetimes_for_params.push((input_pat, accumulator));\n         }\n-        if accumulator.len() == 1 {\n-            implied_output_region = Some(*accumulator.get(0));\n+\n+        if lifetimes_for_params.iter().map(|&(_, ref x)| x.len()).sum() == 1 {\n+            implied_output_region =\n+                Some(lifetimes_for_params.iter()\n+                                         .filter_map(|&(_, ref x)|\n+                                            if x.len() == 1 { Some(x[0]) } else { None })\n+                                         .next().unwrap());\n         }\n     }\n \n+    let param_lifetimes: Vec<(String, uint)> = lifetimes_for_params.into_iter()\n+                                                                   .map(|(n, v)| (n, v.len()))\n+                                                                   .collect();\n+\n     let output_ty = match decl.output.node {\n         ast::TyInfer => this.ty_infer(decl.output.span),\n         _ => {\n@@ -1193,7 +1248,7 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n                     // All regions must be explicitly specified in the output\n                     // if the lifetime elision rules do not apply. This saves\n                     // the user from potentially-confusing errors.\n-                    let rb = ExplicitRscope;\n+                    let rb = UnelidableRscope::new(param_lifetimes);\n                     ast_ty_to_ty(this, &rb, &*decl.output)\n                 }\n             }"}, {"sha": "9b3bf46b94cf667ac057d267281734a72a34de88", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d", "patch": "@@ -1601,7 +1601,7 @@ impl<'a, 'tcx> RegionScope for infer::InferCtxt<'a, 'tcx> {\n     }\n \n     fn anon_regions(&self, span: Span, count: uint)\n-                    -> Result<Vec<ty::Region> , ()> {\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n         Ok(Vec::from_fn(count, |_| {\n             self.next_region_var(infer::MiscVariable(span))\n         }))"}, {"sha": "2845e3954b5c6c6f2fb514cb212bf7c8b9b4acdb", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d", "patch": "@@ -29,7 +29,7 @@ pub trait RegionScope {\n     fn anon_regions(&self,\n                     span: Span,\n                     count: uint)\n-                    -> Result<Vec<ty::Region> , ()>;\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>;\n \n     fn default_region_bound(&self, span: Span) -> Option<ty::Region>;\n }\n@@ -46,8 +46,31 @@ impl RegionScope for ExplicitRscope {\n     fn anon_regions(&self,\n                     _span: Span,\n                     _count: uint)\n-                    -> Result<Vec<ty::Region> , ()> {\n-        Err(())\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n+        Err(None)\n+    }\n+}\n+\n+// Same as `ExplicitRscope`, but provides some extra information for diagnostics\n+pub struct UnelidableRscope(Vec<(String, uint)>);\n+\n+impl UnelidableRscope {\n+    pub fn new(v: Vec<(String, uint)>) -> UnelidableRscope {\n+        UnelidableRscope(v)\n+    }\n+}\n+\n+impl RegionScope for UnelidableRscope {\n+    fn default_region_bound(&self, _span: Span) -> Option<ty::Region> {\n+        None\n+    }\n+\n+    fn anon_regions(&self,\n+                    _span: Span,\n+                    _count: uint)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>> {\n+        let UnelidableRscope(ref v) = *self;\n+        Err(Some(v.clone()))\n     }\n }\n \n@@ -72,7 +95,7 @@ impl RegionScope for SpecificRscope {\n     fn anon_regions(&self,\n                     _span: Span,\n                     count: uint)\n-                    -> Result<Vec<ty::Region> , ()>\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n     {\n         Ok(Vec::from_elem(count, self.default))\n     }\n@@ -109,7 +132,7 @@ impl RegionScope for BindingRscope {\n     fn anon_regions(&self,\n                     _: Span,\n                     count: uint)\n-                    -> Result<Vec<ty::Region> , ()>\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n     {\n         Ok(Vec::from_fn(count, |_| self.next_region()))\n     }"}, {"sha": "5fa8c5db5b01c95a9dd9f73c17ad3e6cbae96c82", "filename": "src/test/compile-fail/lifetime-elision-return-type-requires-explicit-lifetime.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-elision-return-type-requires-explicit-lifetime.rs?ref=a8577be6f4e2d92b4f397aa8191e4ac48e2b4c6d", "patch": "@@ -10,11 +10,13 @@\n \n // Lifetime annotation needed because we have no arguments.\n fn f() -> &int {    //~ ERROR missing lifetime specifier\n+//~^ NOTE there is no value for it to be borrowed from\n     fail!()\n }\n \n // Lifetime annotation needed because we have two by-reference parameters.\n-fn g(_: &int, _: &int) -> &int {    //~ ERROR missing lifetime specifier\n+fn g(_x: &int, _y: &int) -> &int {    //~ ERROR missing lifetime specifier\n+//~^ NOTE the signature does not say whether it is borrowed from `_x` or `_y`\n     fail!()\n }\n \n@@ -24,7 +26,8 @@ struct Foo<'a> {\n \n // Lifetime annotation needed because we have two lifetimes: one as a parameter\n // and one on the reference.\n-fn h(_: &Foo) -> &int { //~ ERROR missing lifetime specifier\n+fn h(_x: &Foo) -> &int { //~ ERROR missing lifetime specifier\n+//~^ NOTE the signature does not say which one of `_x`'s 2 elided lifetimes it is borrowed from\n     fail!()\n }\n "}]}