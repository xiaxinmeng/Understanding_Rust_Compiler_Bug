{"sha": "d641bccb0ffec543fa444ba523e8d4b63078fa53", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NDFiY2NiMGZmZWM1NDNmYTQ0NGJhNTIzZThkNGI2MzA3OGZhNTM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-12-17T11:00:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-12-17T11:00:39Z"}, "message": "Merge #6907\n\n6907: Lifetime reference search  r=matklad a=Veykril\n\nPR #6787 but rewritten to make use of the HIR now. This only applies to Lifetimes, not labels. Also Higher-Ranked Trait Bounds aren't supported yet, but I feel like this PR is big enough as is which is why I left them out after noticing I forgot about them.\r\n\r\nSupporting renaming required slight changes in the renaming module as lifetime names aren't allowed for anything but lifetimes(and labels) and vice versa for normal names.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "6695e5ebfeb9563bf5358a0cb89abe8456ac9172", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6695e5ebfeb9563bf5358a0cb89abe8456ac9172"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d641bccb0ffec543fa444ba523e8d4b63078fa53", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf2zpXCRBK7hj4Ov3rIwAAdHIIAEtTl7xBQj4kqKGBktzGHoy0\nyxQ4y9u4E3h3mP6pIS7s+YbLFtBhfJMF/CmHY8sIiSVGscWaVaTIDIAO1wnBA79E\nB/QnDwqO9Pq20pLzK95Jl/NQPhAjiogvT19LpfuyexDw71cgiivUHj4DlTeocuFv\nIa4i4OLOyYpO2R++2RQxzvXummS9NeCsV9vcltbJ9kvrdoFQF2125OFvQwrEHgKE\nzhCLM9lsBPeNmC1vzJW0ptwH2/nlxva1uQxOG6CO7mlGSlMT2fHMcLZ3DfMfo83W\n4a79Vn4hlriCgFjewQzbMz214GRYRtoTZw2Eq0lYdxMq1CN+sLRzxkrPunOkzdE=\n=moHY\n-----END PGP SIGNATURE-----\n", "payload": "tree 6695e5ebfeb9563bf5358a0cb89abe8456ac9172\nparent d21f5f7d6e13b93d64235f13ac18e447af8d59e4\nparent 55faa2daa3fc8bd213038a012b1c5e9ad5fd3736\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1608202839 +0000\ncommitter GitHub <noreply@github.com> 1608202839 +0000\n\nMerge #6907\n\n6907: Lifetime reference search  r=matklad a=Veykril\n\nPR #6787 but rewritten to make use of the HIR now. This only applies to Lifetimes, not labels. Also Higher-Ranked Trait Bounds aren't supported yet, but I feel like this PR is big enough as is which is why I left them out after noticing I forgot about them.\r\n\r\nSupporting renaming required slight changes in the renaming module as lifetime names aren't allowed for anything but lifetimes(and labels) and vice versa for normal names.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d641bccb0ffec543fa444ba523e8d4b63078fa53", "html_url": "https://github.com/rust-lang/rust/commit/d641bccb0ffec543fa444ba523e8d4b63078fa53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d641bccb0ffec543fa444ba523e8d4b63078fa53/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d21f5f7d6e13b93d64235f13ac18e447af8d59e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d21f5f7d6e13b93d64235f13ac18e447af8d59e4", "html_url": "https://github.com/rust-lang/rust/commit/d21f5f7d6e13b93d64235f13ac18e447af8d59e4"}, {"sha": "55faa2daa3fc8bd213038a012b1c5e9ad5fd3736", "url": "https://api.github.com/repos/rust-lang/rust/commits/55faa2daa3fc8bd213038a012b1c5e9ad5fd3736", "html_url": "https://github.com/rust-lang/rust/commit/55faa2daa3fc8bd213038a012b1c5e9ad5fd3736"}], "stats": {"total": 414, "additions": 373, "deletions": 41}, "files": [{"sha": "ce0f4214c6ed424730f019cfc88dbc287a0863e7", "filename": "crates/ide/src/display/navigation_target.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdisplay%2Fnavigation_target.rs?ref=d641bccb0ffec543fa444ba523e8d4b63078fa53", "patch": "@@ -9,7 +9,7 @@ use ide_db::{defs::Definition, RootDatabase};\n use syntax::{\n     ast::{self, NameOwner},\n     match_ast, AstNode, SmolStr,\n-    SyntaxKind::{self, IDENT_PAT, TYPE_PARAM},\n+    SyntaxKind::{self, IDENT_PAT, LIFETIME_PARAM, TYPE_PARAM},\n     TextRange,\n };\n \n@@ -182,6 +182,7 @@ impl TryToNav for Definition {\n             Definition::SelfType(it) => Some(it.to_nav(db)),\n             Definition::Local(it) => Some(it.to_nav(db)),\n             Definition::TypeParam(it) => Some(it.to_nav(db)),\n+            Definition::LifetimeParam(it) => Some(it.to_nav(db)),\n         }\n     }\n }\n@@ -376,6 +377,23 @@ impl ToNav for hir::TypeParam {\n     }\n }\n \n+impl ToNav for hir::LifetimeParam {\n+    fn to_nav(&self, db: &RootDatabase) -> NavigationTarget {\n+        let src = self.source(db);\n+        let full_range = src.value.syntax().text_range();\n+        NavigationTarget {\n+            file_id: src.file_id.original_file(db),\n+            name: self.name(db).to_string().into(),\n+            kind: LIFETIME_PARAM,\n+            full_range,\n+            focus_range: Some(full_range),\n+            container_name: None,\n+            description: None,\n+            docs: None,\n+        }\n+    }\n+}\n+\n pub(crate) fn docs_from_symbol(db: &RootDatabase, symbol: &FileSymbol) -> Option<Documentation> {\n     let parse = db.parse(symbol.file_id);\n     let node = symbol.ptr.to_node(parse.tree().syntax());"}, {"sha": "2b5794a315276948180be74f876c1399e4cb86e6", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=d641bccb0ffec543fa444ba523e8d4b63078fa53", "patch": "@@ -190,7 +190,10 @@ fn rewrite_intra_doc_link(\n         },\n         Definition::Macro(it) => it.resolve_doc_path(db, link, ns),\n         Definition::Field(it) => it.resolve_doc_path(db, link, ns),\n-        Definition::SelfType(_) | Definition::Local(_) | Definition::TypeParam(_) => return None,\n+        Definition::SelfType(_)\n+        | Definition::Local(_)\n+        | Definition::TypeParam(_)\n+        | Definition::LifetimeParam(_) => return None,\n     }?;\n     let krate = resolved.module(db)?.krate();\n     let canonical_path = resolved.canonical_path(db)?;"}, {"sha": "173509b08bd5c55ca79cf59c6dd1964eb27dab14", "filename": "crates/ide/src/goto_definition.rs", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_definition.rs?ref=d641bccb0ffec543fa444ba523e8d4b63078fa53", "patch": "@@ -1,3 +1,4 @@\n+use either::Either;\n use hir::Semantics;\n use ide_db::{\n     base_db::FileId,\n@@ -33,7 +34,7 @@ pub(crate) fn goto_definition(\n     let nav_targets = match_ast! {\n         match parent {\n             ast::NameRef(name_ref) => {\n-                reference_definition(&sema, &name_ref).to_vec()\n+                reference_definition(&sema, Either::Right(&name_ref)).to_vec()\n             },\n             ast::Name(name) => {\n                 let def = NameClass::classify(&sema, &name)?.referenced_or_defined(sema.db);\n@@ -53,6 +54,13 @@ pub(crate) fn goto_definition(\n                 let self_param = func.param_list()?.self_param()?;\n                 vec![self_to_nav_target(self_param, position.file_id)?]\n             },\n+            ast::Lifetime(lt) => if let Some(name_class) = NameClass::classify_lifetime(&sema, &lt) {\n+                let def = name_class.referenced_or_defined(sema.db);\n+                let nav = def.try_to_nav(sema.db)?;\n+                vec![nav]\n+            } else {\n+                reference_definition(&sema, Either::Left(&lt)).to_vec()\n+            },\n             _ => return None,\n         }\n     };\n@@ -64,7 +72,7 @@ fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n     return tokens.max_by_key(priority);\n     fn priority(n: &SyntaxToken) -> usize {\n         match n.kind() {\n-            IDENT | INT_NUMBER | T![self] => 2,\n+            IDENT | INT_NUMBER | LIFETIME_IDENT | T![self] => 2,\n             kind if kind.is_trivia() => 0,\n             _ => 1,\n         }\n@@ -102,9 +110,12 @@ impl ReferenceResult {\n \n pub(crate) fn reference_definition(\n     sema: &Semantics<RootDatabase>,\n-    name_ref: &ast::NameRef,\n+    name_ref: Either<&ast::Lifetime, &ast::NameRef>,\n ) -> ReferenceResult {\n-    let name_kind = NameRefClass::classify(sema, name_ref);\n+    let name_kind = name_ref.either(\n+        |lifetime| NameRefClass::classify_lifetime(sema, lifetime),\n+        |name_ref| NameRefClass::classify(sema, name_ref),\n+    );\n     if let Some(def) = name_kind {\n         let def = def.referenced(sema.db);\n         return match def.try_to_nav(sema.db) {\n@@ -114,10 +125,9 @@ pub(crate) fn reference_definition(\n     }\n \n     // Fallback index based approach:\n-    let navs = symbol_index::index_resolve(sema.db, name_ref)\n-        .into_iter()\n-        .map(|s| s.to_nav(sema.db))\n-        .collect();\n+    let name = name_ref.either(ast::Lifetime::text, ast::NameRef::text);\n+    let navs =\n+        symbol_index::index_resolve(sema.db, name).into_iter().map(|s| s.to_nav(sema.db)).collect();\n     ReferenceResult::Approximate(navs)\n }\n \n@@ -1033,6 +1043,37 @@ impl Foo {\n     fn bar(&self<|>) {\n           //^^^^\n     }\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn goto_lifetime_param_on_decl() {\n+        check(\n+            r#\"\n+fn foo<'foobar<|>>(_: &'foobar ()) {\n+     //^^^^^^^\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn goto_lifetime_param_decl() {\n+        check(\n+            r#\"\n+fn foo<'foobar>(_: &'foobar<|> ()) {\n+     //^^^^^^^\n+}\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn goto_lifetime_param_decl_nested() {\n+        check(\n+            r#\"\n+fn foo<'foobar>(_: &'foobar ()) {\n+    fn foo<'foobar>(_: &'foobar<|> ()) {}\n+         //^^^^^^^\n }\"#,\n         )\n     }"}, {"sha": "a01b0c8944f8c330023f6ac70497c2bef03c0ebe", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=d641bccb0ffec543fa444ba523e8d4b63078fa53", "patch": "@@ -364,7 +364,7 @@ fn hover_for_definition(db: &RootDatabase, def: Definition) -> Option<Markup> {\n                 Adt::Enum(it) => from_def_source(db, it, mod_path),\n             })\n         }\n-        Definition::TypeParam(_) => {\n+        Definition::TypeParam(_) | Definition::LifetimeParam(_) => {\n             // FIXME: Hover for generic param\n             None\n         }"}, {"sha": "c5c652cda49e52f50f6df5f50641c47f151baa3e", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=d641bccb0ffec543fa444ba523e8d4b63078fa53", "patch": "@@ -528,6 +528,13 @@ impl Analysis {\n         self.with_db(|db| references::rename::rename(db, position, new_name))\n     }\n \n+    pub fn prepare_rename(\n+        &self,\n+        position: FilePosition,\n+    ) -> Cancelable<Result<RangeInfo<()>, RenameError>> {\n+        self.with_db(|db| references::rename::prepare_rename(db, position))\n+    }\n+\n     pub fn structural_search_replace(\n         &self,\n         query: &str,"}, {"sha": "98190a86b254fe713edcc74a1a453506e0964fd5", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 86, "deletions": 5, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=d641bccb0ffec543fa444ba523e8d4b63078fa53", "patch": "@@ -130,6 +130,8 @@ pub(crate) fn find_all_refs(\n                 kind = ReferenceKind::FieldShorthandForLocal;\n             }\n         }\n+    } else if let Definition::LifetimeParam(_) = def {\n+        kind = ReferenceKind::Lifetime;\n     };\n \n     let declaration = Declaration { nav, kind, access: decl_access(&def, &syntax, decl_range) };\n@@ -148,11 +150,29 @@ fn find_name(\n         let range = name.syntax().text_range();\n         return Some(RangeInfo::new(range, def));\n     }\n-    let name_ref =\n-        sema.find_node_at_offset_with_descend::<ast::NameRef>(&syntax, position.offset)?;\n-    let def = NameRefClass::classify(sema, &name_ref)?.referenced(sema.db);\n-    let range = name_ref.syntax().text_range();\n-    Some(RangeInfo::new(range, def))\n+\n+    let (text_range, def) = if let Some(lifetime) =\n+        sema.find_node_at_offset_with_descend::<ast::Lifetime>(&syntax, position.offset)\n+    {\n+        if let Some(def) = NameRefClass::classify_lifetime(sema, &lifetime)\n+            .map(|class| NameRefClass::referenced(class, sema.db))\n+        {\n+            (lifetime.syntax().text_range(), def)\n+        } else {\n+            (\n+                lifetime.syntax().text_range(),\n+                NameClass::classify_lifetime(sema, &lifetime)?.referenced_or_defined(sema.db),\n+            )\n+        }\n+    } else {\n+        let name_ref =\n+            sema.find_node_at_offset_with_descend::<ast::NameRef>(&syntax, position.offset)?;\n+        (\n+            name_ref.syntax().text_range(),\n+            NameRefClass::classify(sema, &name_ref)?.referenced(sema.db),\n+        )\n+    };\n+    Some(RangeInfo::new(text_range, def))\n }\n \n fn decl_access(def: &Definition, syntax: &SyntaxNode, range: TextRange) -> Option<ReferenceAccess> {\n@@ -1005,4 +1025,65 @@ impl Foo {\n         }\n         expect.assert_eq(&actual)\n     }\n+\n+    #[test]\n+    fn test_find_lifetimes_function() {\n+        check(\n+            r#\"\n+trait Foo<'a> {}\n+impl<'a> Foo<'a> for &'a () {}\n+fn foo<'a, 'b: 'a>(x: &'a<|> ()) -> &'a () where &'a (): Foo<'a> {\n+    fn bar<'a>(_: &'a ()) {}\n+    x\n+}\n+\"#,\n+            expect![[r#\"\n+                'a LIFETIME_PARAM FileId(0) 55..57 55..57 Lifetime\n+\n+                FileId(0) 63..65 Lifetime\n+                FileId(0) 71..73 Lifetime\n+                FileId(0) 82..84 Lifetime\n+                FileId(0) 95..97 Lifetime\n+                FileId(0) 106..108 Lifetime\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_find_lifetimes_type_alias() {\n+        check(\n+            r#\"\n+type Foo<'a, T> where T: 'a<|> = &'a T;\n+\"#,\n+            expect![[r#\"\n+                'a LIFETIME_PARAM FileId(0) 9..11 9..11 Lifetime\n+\n+                FileId(0) 25..27 Lifetime\n+                FileId(0) 31..33 Lifetime\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_find_lifetimes_trait_impl() {\n+        check(\n+            r#\"\n+trait Foo<'a> {\n+    fn foo() -> &'a ();\n+}\n+impl<'a> Foo<'a> for &'a () {\n+    fn foo() -> &'a<|> () {\n+        unimplemented!()\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                'a LIFETIME_PARAM FileId(0) 47..49 47..49 Lifetime\n+\n+                FileId(0) 55..57 Lifetime\n+                FileId(0) 64..66 Lifetime\n+                FileId(0) 89..91 Lifetime\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "56e9238414d2babbce4c57d9ee65ca50c1bf980a", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 98, "deletions": 6, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=d641bccb0ffec543fa444ba523e8d4b63078fa53", "patch": "@@ -35,6 +35,29 @@ impl fmt::Display for RenameError {\n \n impl Error for RenameError {}\n \n+pub(crate) fn prepare_rename(\n+    db: &RootDatabase,\n+    position: FilePosition,\n+) -> Result<RangeInfo<()>, RenameError> {\n+    let sema = Semantics::new(db);\n+    let source_file = sema.parse(position.file_id);\n+    let syntax = source_file.syntax();\n+    if let Some(module) = find_module_at_offset(&sema, position, syntax) {\n+        rename_mod(&sema, position, module, \"dummy\")\n+    } else if let Some(self_token) =\n+        syntax.token_at_offset(position.offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n+    {\n+        rename_self_to_param(&sema, position, self_token, \"dummy\")\n+    } else {\n+        let range = match find_all_refs(&sema, position, None) {\n+            Some(RangeInfo { range, .. }) => range,\n+            None => return Err(RenameError(\"No references found at position\".to_string())),\n+        };\n+        Ok(RangeInfo::new(range, SourceChange::from(vec![])))\n+    }\n+    .map(|info| RangeInfo::new(info.range, ()))\n+}\n+\n pub(crate) fn rename(\n     db: &RootDatabase,\n     position: FilePosition,\n@@ -49,11 +72,18 @@ pub(crate) fn rename_with_semantics(\n     position: FilePosition,\n     new_name: &str,\n ) -> Result<RangeInfo<SourceChange>, RenameError> {\n-    match lex_single_syntax_kind(new_name) {\n+    let is_lifetime_name = match lex_single_syntax_kind(new_name) {\n         Some(res) => match res {\n-            (SyntaxKind::IDENT, _) => (),\n-            (SyntaxKind::UNDERSCORE, _) => (),\n+            (SyntaxKind::IDENT, _) => false,\n+            (SyntaxKind::UNDERSCORE, _) => false,\n             (SyntaxKind::SELF_KW, _) => return rename_to_self(&sema, position),\n+            (SyntaxKind::LIFETIME_IDENT, _) if new_name != \"'static\" && new_name != \"'_\" => true,\n+            (SyntaxKind::LIFETIME_IDENT, _) => {\n+                return Err(RenameError(format!(\n+                    \"Invalid name `{0}`: Cannot rename lifetime to {0}\",\n+                    new_name\n+                )))\n+            }\n             (_, Some(syntax_error)) => {\n                 return Err(RenameError(format!(\"Invalid name `{}`: {}\", new_name, syntax_error)))\n             }\n@@ -62,18 +92,21 @@ pub(crate) fn rename_with_semantics(\n             }\n         },\n         None => return Err(RenameError(format!(\"Invalid name `{}`: not an identifier\", new_name))),\n-    }\n+    };\n \n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax();\n-    if let Some(module) = find_module_at_offset(&sema, position, syntax) {\n+    // this is here to prevent lifetime renames from happening on modules and self\n+    if is_lifetime_name {\n+        rename_reference(&sema, position, new_name, is_lifetime_name)\n+    } else if let Some(module) = find_module_at_offset(&sema, position, syntax) {\n         rename_mod(&sema, position, module, new_name)\n     } else if let Some(self_token) =\n         syntax.token_at_offset(position.offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n     {\n         rename_self_to_param(&sema, position, self_token, new_name)\n     } else {\n-        rename_reference(&sema, position, new_name)\n+        rename_reference(&sema, position, new_name, is_lifetime_name)\n     }\n }\n \n@@ -355,12 +388,26 @@ fn rename_reference(\n     sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n     new_name: &str,\n+    is_lifetime_name: bool,\n ) -> Result<RangeInfo<SourceChange>, RenameError> {\n     let RangeInfo { range, info: refs } = match find_all_refs(sema, position, None) {\n         Some(range_info) => range_info,\n         None => return Err(RenameError(\"No references found at position\".to_string())),\n     };\n \n+    match (refs.declaration.kind == ReferenceKind::Lifetime, is_lifetime_name) {\n+        (true, false) => {\n+            return Err(RenameError(format!(\n+                \"Invalid name `{}`: not a lifetime identifier\",\n+                new_name\n+            )))\n+        }\n+        (false, true) => {\n+            return Err(RenameError(format!(\"Invalid name `{}`: not an identifier\", new_name)))\n+        }\n+        _ => (),\n+    }\n+\n     let edit = refs\n         .into_iter()\n         .map(|reference| source_edit_from_reference(sema, reference, new_name))\n@@ -464,6 +511,24 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_rename_to_invalid_identifier_lifetime() {\n+        check(\n+            \"'foo\",\n+            r#\"fn main() { let i<|> = 1; }\"#,\n+            \"error: Invalid name `'foo`: not an identifier\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_rename_to_invalid_identifier_lifetime2() {\n+        check(\n+            \"foo\",\n+            r#\"fn main<'a>(_: &'a<|> ()) {}\"#,\n+            \"error: Invalid name `foo`: not a lifetime identifier\",\n+        );\n+    }\n+\n     #[test]\n     fn test_rename_for_local() {\n         check(\n@@ -1393,6 +1458,33 @@ struct Foo {\n fn foo(Foo { i: bar }: foo) -> i32 {\n     bar\n }\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_rename_lifetimes() {\n+        check(\n+            \"'yeeee\",\n+            r#\"\n+trait Foo<'a> {\n+    fn foo() -> &'a ();\n+}\n+impl<'a> Foo<'a> for &'a () {\n+    fn foo() -> &'a<|> () {\n+        unimplemented!()\n+    }\n+}\n+\"#,\n+            r#\"\n+trait Foo<'a> {\n+    fn foo() -> &'a ();\n+}\n+impl<'yeeee> Foo<'yeeee> for &'yeeee () {\n+    fn foo() -> &'yeeee () {\n+        unimplemented!()\n+    }\n+}\n \"#,\n         )\n     }"}, {"sha": "488969f1a15c4b1a9d3bad597daee7be974b0def", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=d641bccb0ffec543fa444ba523e8d4b63078fa53", "patch": "@@ -806,6 +806,7 @@ fn highlight_def(db: &RootDatabase, def: Definition) -> Highlight {\n             }\n             return h;\n         }\n+        Definition::LifetimeParam(_) => HighlightTag::Lifetime,\n     }\n     .into()\n }"}, {"sha": "f2d1e4c392167eece42f3dd67bab7f8096529501", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=d641bccb0ffec543fa444ba523e8d4b63078fa53", "patch": "@@ -6,12 +6,12 @@\n // FIXME: this badly needs rename/rewrite (matklad, 2020-02-06).\n \n use hir::{\n-    db::HirDatabase, Crate, Field, HasVisibility, ImplDef, Local, MacroDef, Module, ModuleDef,\n-    Name, PathResolution, Semantics, TypeParam, Visibility,\n+    db::HirDatabase, Crate, Field, HasVisibility, ImplDef, LifetimeParam, Local, MacroDef, Module,\n+    ModuleDef, Name, PathResolution, Semantics, TypeParam, Visibility,\n };\n use syntax::{\n     ast::{self, AstNode},\n-    match_ast, SyntaxNode,\n+    match_ast, SyntaxKind, SyntaxNode,\n };\n \n use crate::RootDatabase;\n@@ -25,6 +25,8 @@ pub enum Definition {\n     SelfType(ImplDef),\n     Local(Local),\n     TypeParam(TypeParam),\n+    LifetimeParam(LifetimeParam),\n+    // FIXME: Label\n }\n \n impl Definition {\n@@ -36,6 +38,7 @@ impl Definition {\n             Definition::SelfType(it) => Some(it.module(db)),\n             Definition::Local(it) => Some(it.module(db)),\n             Definition::TypeParam(it) => Some(it.module(db)),\n+            Definition::LifetimeParam(it) => Some(it.module(db)),\n         }\n     }\n \n@@ -47,6 +50,7 @@ impl Definition {\n             Definition::SelfType(_) => None,\n             Definition::Local(_) => None,\n             Definition::TypeParam(_) => None,\n+            Definition::LifetimeParam(_) => None,\n         }\n     }\n \n@@ -72,6 +76,7 @@ impl Definition {\n             Definition::SelfType(_) => return None,\n             Definition::Local(it) => it.name(db)?,\n             Definition::TypeParam(it) => it.name(db),\n+            Definition::LifetimeParam(it) => it.name(db),\n         };\n         Some(name)\n     }\n@@ -229,6 +234,25 @@ impl NameClass {\n             }\n         }\n     }\n+\n+    pub fn classify_lifetime(\n+        sema: &Semantics<RootDatabase>,\n+        lifetime: &ast::Lifetime,\n+    ) -> Option<NameClass> {\n+        let _p = profile::span(\"classify_lifetime\").detail(|| lifetime.to_string());\n+        let parent = lifetime.syntax().parent()?;\n+\n+        match_ast! {\n+            match parent {\n+                ast::LifetimeParam(it) => {\n+                    let def = sema.to_def(&it)?;\n+                    Some(NameClass::Definition(Definition::LifetimeParam(def)))\n+                },\n+                ast::Label(_it) => None,\n+                _ => None,\n+            }\n+        }\n+    }\n }\n \n #[derive(Debug)]\n@@ -338,6 +362,35 @@ impl NameRefClass {\n         let resolved = sema.resolve_extern_crate(&extern_crate)?;\n         Some(NameRefClass::ExternCrate(resolved))\n     }\n+\n+    pub fn classify_lifetime(\n+        sema: &Semantics<RootDatabase>,\n+        lifetime: &ast::Lifetime,\n+    ) -> Option<NameRefClass> {\n+        let _p = profile::span(\"classify_lifetime_ref\").detail(|| lifetime.to_string());\n+        let parent = lifetime.syntax().parent()?;\n+        match parent.kind() {\n+            SyntaxKind::LIFETIME_ARG\n+            | SyntaxKind::SELF_PARAM\n+            | SyntaxKind::TYPE_BOUND\n+            | SyntaxKind::WHERE_PRED\n+            | SyntaxKind::REF_TYPE => sema\n+                .resolve_lifetime_param(lifetime)\n+                .map(Definition::LifetimeParam)\n+                .map(NameRefClass::Definition),\n+            // lifetime bounds, as in the 'b in 'a: 'b aren't wrapped in TypeBound nodes so we gotta check\n+            // if our lifetime is in a LifetimeParam without being the constrained lifetime\n+            _ if ast::LifetimeParam::cast(parent).and_then(|param| param.lifetime()).as_ref()\n+                != Some(lifetime) =>\n+            {\n+                sema.resolve_lifetime_param(lifetime)\n+                    .map(Definition::LifetimeParam)\n+                    .map(NameRefClass::Definition)\n+            }\n+            SyntaxKind::BREAK_EXPR | SyntaxKind::CONTINUE_EXPR => None,\n+            _ => None,\n+        }\n+    }\n }\n \n impl From<PathResolution> for Definition {"}, {"sha": "5b3997bcf8d461ea42759bf8e69da34187906d84", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=d641bccb0ffec543fa444ba523e8d4b63078fa53", "patch": "@@ -33,6 +33,7 @@ pub enum ReferenceKind {\n     RecordFieldExprOrPat,\n     SelfKw,\n     EnumLiteral,\n+    Lifetime,\n     Other,\n }\n \n@@ -129,6 +130,25 @@ impl Definition {\n             return SearchScope::new(res);\n         }\n \n+        if let Definition::LifetimeParam(param) = self {\n+            let range = match param.parent(db) {\n+                hir::GenericDef::Function(it) => it.source(db).value.syntax().text_range(),\n+                hir::GenericDef::Adt(it) => match it {\n+                    hir::Adt::Struct(it) => it.source(db).value.syntax().text_range(),\n+                    hir::Adt::Union(it) => it.source(db).value.syntax().text_range(),\n+                    hir::Adt::Enum(it) => it.source(db).value.syntax().text_range(),\n+                },\n+                hir::GenericDef::Trait(it) => it.source(db).value.syntax().text_range(),\n+                hir::GenericDef::TypeAlias(it) => it.source(db).value.syntax().text_range(),\n+                hir::GenericDef::ImplDef(it) => it.source(db).value.syntax().text_range(),\n+                hir::GenericDef::EnumVariant(it) => it.source(db).value.syntax().text_range(),\n+                hir::GenericDef::Const(it) => it.source(db).value.syntax().text_range(),\n+            };\n+            let mut res = FxHashMap::default();\n+            res.insert(file_id, Some(range));\n+            return SearchScope::new(res);\n+        }\n+\n         let vis = self.visibility(db);\n \n         if let Some(Visibility::Module(module)) = vis.and_then(|it| it.into()) {\n@@ -255,25 +275,42 @@ impl<'a> FindUsages<'a> {\n                     continue;\n                 }\n \n-                match sema.find_node_at_offset_with_descend(&tree, offset) {\n-                    Some(name_ref) => {\n-                        if self.found_name_ref(&name_ref, sink) {\n-                            return;\n-                        }\n+                if let Some(name_ref) = sema.find_node_at_offset_with_descend(&tree, offset) {\n+                    if self.found_name_ref(&name_ref, sink) {\n+                        return;\n+                    }\n+                } else if let Some(name) = sema.find_node_at_offset_with_descend(&tree, offset) {\n+                    if self.found_name(&name, sink) {\n+                        return;\n+                    }\n+                } else if let Some(lifetime) = sema.find_node_at_offset_with_descend(&tree, offset)\n+                {\n+                    if self.found_lifetime(&lifetime, sink) {\n+                        return;\n                     }\n-                    None => match sema.find_node_at_offset_with_descend(&tree, offset) {\n-                        Some(name) => {\n-                            if self.found_name(&name, sink) {\n-                                return;\n-                            }\n-                        }\n-                        None => {}\n-                    },\n                 }\n             }\n         }\n     }\n \n+    fn found_lifetime(\n+        &self,\n+        lifetime: &ast::Lifetime,\n+        sink: &mut dyn FnMut(Reference) -> bool,\n+    ) -> bool {\n+        match NameRefClass::classify_lifetime(self.sema, lifetime) {\n+            Some(NameRefClass::Definition(def)) if &def == self.def => {\n+                let reference = Reference {\n+                    file_range: self.sema.original_range(lifetime.syntax()),\n+                    kind: ReferenceKind::Lifetime,\n+                    access: None,\n+                };\n+                sink(reference)\n+            }\n+            _ => false, // not a usage\n+        }\n+    }\n+\n     fn found_name_ref(\n         &self,\n         name_ref: &ast::NameRef,"}, {"sha": "ca455fa03e32b850f7000c9fdcb81807d40f6340", "filename": "crates/ide_db/src/symbol_index.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs?ref=d641bccb0ffec543fa444ba523e8d4b63078fa53", "patch": "@@ -209,8 +209,7 @@ pub fn crate_symbols(db: &RootDatabase, krate: CrateId, query: Query) -> Vec<Fil\n     query.search(&buf)\n }\n \n-pub fn index_resolve(db: &RootDatabase, name_ref: &ast::NameRef) -> Vec<FileSymbol> {\n-    let name = name_ref.text();\n+pub fn index_resolve(db: &RootDatabase, name: &SmolStr) -> Vec<FileSymbol> {\n     let mut query = Query::new(name.to_string());\n     query.exact();\n     query.limit(4);"}, {"sha": "af226c10900ec0ad66994441a9e34a0b8794d05c", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d641bccb0ffec543fa444ba523e8d4b63078fa53/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=d641bccb0ffec543fa444ba523e8d4b63078fa53", "patch": "@@ -733,7 +733,7 @@ pub(crate) fn handle_prepare_rename(\n     let _p = profile::span(\"handle_prepare_rename\");\n     let position = from_proto::file_position(&snap, params)?;\n \n-    let change = snap.analysis.rename(position, \"dummy\")??;\n+    let change = snap.analysis.prepare_rename(position)??;\n     let line_index = snap.analysis.file_line_index(position.file_id)?;\n     let range = to_proto::range(&line_index, change.range);\n     Ok(Some(PrepareRenameResponse::Range(range)))"}]}