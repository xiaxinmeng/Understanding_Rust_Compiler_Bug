{"sha": "c9c5ee252a8523778377f2832765442e611e85a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5YzVlZTI1MmE4NTIzNzc4Mzc3ZjI4MzI3NjU0NDJlNjExZTg1YTQ=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-25T08:18:02Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-29T07:07:53Z"}, "message": "Implement non-internal ivecs\n\nVectors are now similar to our old, pre-internal vectors, except that\nthey are uniquely owned, not refcounted.\n\nTheir name should probably change too, then. I've renamed them to vec\nin the runtime, will do so throughout the compiler later.", "tree": {"sha": "85c0837af34b2431fc17da0a166254144aaa99c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85c0837af34b2431fc17da0a166254144aaa99c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9c5ee252a8523778377f2832765442e611e85a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9c5ee252a8523778377f2832765442e611e85a4", "html_url": "https://github.com/rust-lang/rust/commit/c9c5ee252a8523778377f2832765442e611e85a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9c5ee252a8523778377f2832765442e611e85a4/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "855e0a471365c7c61a139e2437215028bd231af5", "url": "https://api.github.com/repos/rust-lang/rust/commits/855e0a471365c7c61a139e2437215028bd231af5", "html_url": "https://github.com/rust-lang/rust/commit/855e0a471365c7c61a139e2437215028bd231af5"}], "stats": {"total": 2035, "additions": 487, "deletions": 1548}, "files": [{"sha": "f2b1bb1329fc8d01be766be81a30c1dd1f4f24b7", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -62,7 +62,7 @@ endif\n # runtime used directly by the compiler -- the binaries built by the\n # snapshot won't know about the changes yet. Don't leave this on. Turn\n # it on, shapshot, and turn it off again.\n-# CFG_USE_SNAP_LIBS_FOR_STAGE1 = 1\n+CFG_USE_SNAP_LIBS_FOR_STAGE1 = 1\n \n # version-string calculation\n CFG_GIT_DIR := $(CFG_SRC_DIR).git"}, {"sha": "22e49436440fe372f5bb15c87cd575276cb46f7b", "filename": "src/comp/back/abi.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fback%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fback%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fabi.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -92,24 +92,12 @@ const closure_elt_bindings: int = 1;\n \n const closure_elt_ty_params: int = 2;\n \n-const ivec_default_length: uint = 4u;\n+const ivec_elt_fill: uint = 0u;\n \n-const ivec_elt_len: uint = 0u;\n-\n-const ivec_elt_alen: uint = 1u;\n+const ivec_elt_alloc: uint = 1u;\n \n const ivec_elt_elems: uint = 2u;\n \n-const ivec_heap_stub_elt_zero: uint = 0u;\n-\n-const ivec_heap_stub_elt_alen: uint = 1u;\n-\n-const ivec_heap_stub_elt_ptr: uint = 2u;\n-\n-const ivec_heap_elt_len: uint = 0u;\n-\n-const ivec_heap_elt_elems: uint = 1u;\n-\n const worst_case_glue_call_args: int = 7;\n \n const abi_version: uint = 1u;"}, {"sha": "8f0cb959b3d308ac0599f1743ffd1a814da9843c", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -40,10 +40,7 @@ type upcalls =\n      new_str: ValueRef,\n      evec_append: ValueRef,\n      get_type_desc: ValueRef,\n-     ivec_resize: ValueRef,\n-     ivec_spill: ValueRef,\n-     ivec_resize_shared: ValueRef,\n-     ivec_spill_shared: ValueRef,\n+     ivec_grow: ValueRef,\n      ivec_push: ValueRef,\n      cmp_type: ValueRef,\n      log_type: ValueRef,\n@@ -95,19 +92,13 @@ fn declare_upcalls(_tn: type_names, tydesc_type: TypeRef,\n               d(~\"get_type_desc\",\n                 [T_ptr(T_nil()), T_size_t(), T_size_t(), T_size_t(),\n                  T_ptr(T_ptr(tydesc_type)), T_int()], T_ptr(tydesc_type)),\n-          ivec_resize:\n-              d(~\"ivec_resize\", [T_ptr(T_opaque_ivec()), T_int()], T_void()),\n-          ivec_spill:\n-              d(~\"ivec_spill\", [T_ptr(T_opaque_ivec()), T_int()], T_void()),\n-          ivec_resize_shared:\n-              d(~\"ivec_resize_shared\", [T_ptr(T_opaque_ivec()), T_int()],\n-                T_void()),\n-          ivec_spill_shared:\n-              d(~\"ivec_spill_shared\", [T_ptr(T_opaque_ivec()), T_int()],\n+          ivec_grow:\n+              d(~\"vec_grow\", [T_ptr(T_ptr(T_opaque_ivec())), T_int()],\n                 T_void()),\n           ivec_push:\n-              d(~\"ivec_push\", [T_ptr(T_opaque_ivec()), T_ptr(tydesc_type),\n-                              T_ptr(T_i8())], T_void()),\n+              d(~\"vec_push\",\n+                [T_ptr(T_ptr(T_opaque_ivec())), T_ptr(tydesc_type),\n+                 T_ptr(T_i8())], T_void()),\n           cmp_type:\n               dr(~\"cmp_type\",\n                  [T_ptr(T_i1()), taskptr_type, T_ptr(tydesc_type),"}, {"sha": "3c74e829e9da4ca9cb843b40fa9e24d16a47be03", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -313,7 +313,6 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t) -> [u8] {\n         s += [shape_ivec];\n         add_bool(s, true); // type is POD\n         let unit_ty = ty::mk_mach(ccx.tcx, ast::ty_u8);\n-        add_size_hint(ccx, s, unit_ty);\n         add_substr(s, shape_of(ccx, unit_ty));\n       }\n \n@@ -365,7 +364,6 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t) -> [u8] {\n       ty::ty_vec(mt) {\n         s += [shape_ivec];\n         add_bool(s, ty::type_is_pod(ccx.tcx, mt.ty));\n-        add_size_hint(ccx, s, mt.ty);\n         add_substr(s, shape_of(ccx, mt.ty));\n       }\n       ty::ty_rec(fields) {\n@@ -416,14 +414,6 @@ fn shape_of(ccx: &@crate_ctxt, t: ty::t) -> [u8] {\n     ret s;\n }\n \n-fn add_size_hint(ccx: &@crate_ctxt, s: &mutable [u8], typ: ty::t) {\n-    if ty::type_has_dynamic_size(ccx.tcx, typ) { s += [0u8, 0u8, 0u8]; ret; }\n-\n-    let llty = trans::type_of(ccx, dummy_sp(), typ);\n-    add_u16(s, trans::llsize_of_real(ccx, llty) as u16);\n-    s += [trans::llalign_of_real(ccx, llty) as u8];\n-}\n-\n // FIXME: We might discover other variants as we traverse these. Handle this.\n fn shape_of_variant(ccx: &@crate_ctxt, v: &ty::variant_info) -> [u8] {\n     let s = [];"}, {"sha": "60704036c221c8b1b6993e810d75ee2e0742e93a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 42, "deletions": 198, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -205,14 +205,14 @@ fn type_of_inner(cx: &@crate_ctxt, sp: &span, t: ty::t) -> TypeRef {\n       }\n       ty::ty_char. { llty = T_char(); }\n       ty::ty_str. { llty = T_ptr(T_str()); }\n-      ty::ty_istr. { llty = T_ivec(T_i8()); }\n+      ty::ty_istr. { llty = T_ptr(T_ivec(T_i8())); }\n       ty::ty_tag(did, _) { llty = type_of_tag(cx, sp, did, t); }\n       ty::ty_box(mt) { llty = T_ptr(T_box(type_of_inner(cx, sp, mt.ty))); }\n       ty::ty_uniq(t) { llty = T_ptr(type_of_inner(cx, sp, t)); }\n       ty::ty_vec(mt) {\n         if ty::type_has_dynamic_size(cx.tcx, mt.ty) {\n-            llty = T_opaque_ivec();\n-        } else { llty = T_ivec(type_of_inner(cx, sp, mt.ty)); }\n+            llty = T_ptr(T_opaque_ivec());\n+        } else { llty = T_ptr(T_ivec(type_of_inner(cx, sp, mt.ty))); }\n       }\n       ty::ty_ptr(mt) { llty = T_ptr(type_of_inner(cx, sp, mt.ty)); }\n       ty::ty_rec(fields) {\n@@ -631,16 +631,6 @@ fn dynamic_size_of(cx: &@block_ctxt, t: ty::t) -> result {\n             } else { max_size_val };\n         ret rslt(bcx, total_size);\n       }\n-      ty::ty_vec(mt) {\n-        let rs = size_of(cx, mt.ty);\n-        let bcx = rs.bcx;\n-        let llunitsz = rs.val;\n-        let llsz =\n-            bld::Add(bcx, llsize_of(T_opaque_ivec()),\n-                          bld::Mul(bcx, llunitsz,\n-                                        C_uint(abi::ivec_default_length)));\n-        ret rslt(bcx, llsz);\n-      }\n     }\n }\n \n@@ -663,13 +653,6 @@ fn dynamic_align_of(cx: &@block_ctxt, t: ty::t) -> result {\n       ty::ty_tag(_, _) {\n         ret rslt(cx, C_int(1)); // FIXME: stub\n       }\n-      ty::ty_vec(tm) {\n-        let rs = align_of(cx, tm.ty);\n-        let bcx = rs.bcx;\n-        let llunitalign = rs.val;\n-        let llalign = umax(bcx, llalign_of(T_int()), llunitalign);\n-        ret rslt(bcx, llalign);\n-      }\n       ty::ty_tup(elts) {\n         let a = C_int(1);\n         let bcx = cx;\n@@ -1326,16 +1309,16 @@ fn make_copy_glue(cx: &@block_ctxt, src: ValueRef, dst: ValueRef, t: ty::t) {\n }\n \n fn make_take_glue(cx: &@block_ctxt, v: ValueRef, t: ty::t) {\n+    let bcx = cx;\n     // NB: v is an *alias* of type t here, not a direct value.\n-\n-    let bcx;\n-\n-    if ty::type_is_boxed(bcx_tcx(cx), t) {\n-        bcx = incr_refcnt_of_boxed(cx, bld::Load(cx, v)).bcx;\n-    } else if ty::type_is_structural(bcx_tcx(cx), t) {\n-        bcx = duplicate_heap_parts_if_necessary(cx, v, t).bcx;\n+    if ty::type_is_boxed(bcx_tcx(bcx), t) {\n+        bcx = incr_refcnt_of_boxed(bcx, bld::Load(bcx, v)).bcx;\n+    } else if ty::type_is_structural(bcx_tcx(bcx), t) {\n         bcx = iter_structural_ty(bcx, v, t, take_ty).bcx;\n-    } else { bcx = cx; }\n+    } else if ty::type_is_ivec(bcx_tcx(bcx), t) {\n+        bcx = ivec::duplicate(bcx, v);\n+        bcx = ivec::iter_ivec(bcx, v, t, take_ty).bcx;\n+    }\n \n     build_return(bcx);\n }\n@@ -1426,51 +1409,17 @@ fn make_free_glue(cx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n     build_return(rs.bcx);\n }\n \n-fn maybe_free_ivec_heap_part(cx: &@block_ctxt, v0: ValueRef, unit_ty: ty::t)\n-   -> result {\n-    let llunitty = type_of_or_i8(cx, unit_ty);\n-    let stack_len =\n-        bld::Load(cx, bld::InBoundsGEP(cx, v0,\n-                                           [C_int(0),\n-                                            C_uint(abi::ivec_elt_len)]));\n-    let maybe_on_heap_cx = new_sub_block_ctxt(cx, ~\"maybe_on_heap\");\n-    let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n-    let maybe_on_heap =\n-        bld::ICmp(cx, lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n-    bld::CondBr(cx, maybe_on_heap, maybe_on_heap_cx.llbb, next_cx.llbb);\n-    // Might be on the heap. Load the heap pointer and free it. (It's ok to\n-    // free a null pointer.)\n-\n-    let stub_ptr =\n-        bld::PointerCast(maybe_on_heap_cx, v0, T_ptr(T_ivec_heap(llunitty)));\n-    let heap_ptr =\n-        {\n-            let v = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n-            let m = bld::InBoundsGEP(maybe_on_heap_cx, stub_ptr, v);\n-            bld::Load(maybe_on_heap_cx, m)\n-        };\n-    let after_free_cx = trans_shared_free(maybe_on_heap_cx, heap_ptr).bcx;\n-    bld::Br(after_free_cx, next_cx.llbb);\n-    ret rslt(next_cx, C_nil());\n-}\n-\n fn make_drop_glue(cx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let ccx = bcx_ccx(cx);\n     let rs =\n         alt ty::struct(ccx.tcx, t) {\n           ty::ty_str. { decr_refcnt_maybe_free(cx, v0, v0, t) }\n-          ty::ty_vec(tm) {\n-            let v1;\n-            if ty::type_has_dynamic_size(ccx.tcx, tm.ty) {\n-                v1 = bld::PointerCast(cx, v0, T_ptr(T_opaque_ivec()));\n-            } else { v1 = v0; }\n-            let rslt = iter_structural_ty(cx, v1, t, drop_ty);\n-            maybe_free_ivec_heap_part(rslt.bcx, v1, tm.ty)\n+          ty::ty_vec(_) {\n+            rslt(ivec::make_drop_glue(cx, v0, t), C_nil())\n           }\n           ty::ty_istr. {\n-            maybe_free_ivec_heap_part(cx, v0,\n-                                      ty::mk_mach(ccx.tcx, ast::ty_u8))\n+            rslt(ivec::make_drop_glue(cx, v0, t), C_nil())\n           }\n           ty::ty_box(_) { decr_refcnt_maybe_free(cx, v0, v0, t) }\n           ty::ty_uniq(_) { trans_shared_free(cx, bld::Load(cx, v0)) }\n@@ -1489,7 +1438,7 @@ fn make_drop_glue(cx: &@block_ctxt, v0: ValueRef, t: ty::t) {\n           }\n           _ {\n             if ty::type_has_pointers(ccx.tcx, t) &&\n-                   ty::type_is_structural(ccx.tcx, t) {\n+               ty::type_is_structural(ccx.tcx, t) {\n                 iter_structural_ty(cx, v0, t, drop_ty)\n             } else { rslt(cx, C_nil()) }\n           }\n@@ -1721,7 +1670,8 @@ fn iter_structural_ty(cx: &@block_ctxt, v: ValueRef, t: ty::t,\n        -> result {\n         ret f(cx, av, t);\n     }\n-    ret iter_structural_ty_full(cx, v, t, bind adaptor_fn(f, _, _, _));\n+    let x = iter_structural_ty_full(cx, v, t, bind adaptor_fn(f, _, _, _));\n+    ret x;\n }\n \n fn load_inbounds(cx: &@block_ctxt, p: ValueRef, idxs: &[ValueRef]) ->\n@@ -1756,61 +1706,6 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n         ret rslt(next_cx, C_nil());\n     }\n \n-    fn iter_ivec(bcx: @block_ctxt, av: ValueRef, unit_ty: ty::t,\n-                 f: &val_and_ty_fn) -> result {\n-        // FIXME: \"unimplemented rebinding existing function\" workaround\n-\n-        fn adapter(bcx: &@block_ctxt, av: ValueRef, unit_ty: ty::t,\n-                   f: val_and_ty_fn) -> result {\n-            ret f(bcx, av, unit_ty);\n-        }\n-        let llunitty = type_of_or_i8(bcx, unit_ty);\n-        let rs = size_of(bcx, unit_ty);\n-        let unit_sz = rs.val;\n-        bcx = rs.bcx;\n-        let a_len_and_data = ivec::get_len_and_data(bcx, av, unit_ty);\n-        let len = a_len_and_data.len;\n-        let a_elem = a_len_and_data.data;\n-        bcx = a_len_and_data.bcx;\n-        // Calculate the last pointer address we want to handle.\n-        // TODO: Optimize this when the size of the unit type is statically\n-        // known to not use pointer casts, which tend to confuse LLVM.\n-\n-        let a_elem_i8 = bld::PointerCast(bcx, a_elem, T_ptr(T_i8()));\n-        let a_end_i8 = bld::GEP(bcx, a_elem_i8, [len]);\n-        let a_end = bld::PointerCast(bcx, a_end_i8, T_ptr(llunitty));\n-\n-        let dest_elem_ptr = alloca(bcx, T_ptr(llunitty));\n-        bld::Store(bcx, a_elem, dest_elem_ptr);\n-\n-        // Now perform the iteration.\n-        let loop_header_cx = new_sub_block_ctxt(\n-            bcx, ~\"iter_ivec_loop_header\");\n-        bld::Br(bcx, loop_header_cx.llbb);\n-        let dest_elem = bld::Load(loop_header_cx, dest_elem_ptr);\n-        let not_yet_at_end =\n-            bld::ICmp(loop_header_cx, lib::llvm::LLVMIntULT, dest_elem,\n-                                      a_end);\n-        let loop_body_cx = new_sub_block_ctxt(bcx, ~\"iter_ivec_loop_body\");\n-        let next_cx = new_sub_block_ctxt(bcx, ~\"iter_ivec_next\");\n-        bld::CondBr(loop_header_cx, not_yet_at_end, loop_body_cx.llbb,\n-                                    next_cx.llbb);\n-\n-        rs = f(loop_body_cx, dest_elem, unit_ty);\n-\n-        loop_body_cx = rs.bcx;\n-\n-        let increment;\n-        if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n-            increment = unit_sz;\n-        } else { increment = C_int(1); }\n-\n-        incr_ptr(loop_body_cx, dest_elem, increment, dest_elem_ptr);\n-        bld::Br(loop_body_cx, loop_header_cx.llbb);\n-\n-        ret rslt(next_cx, C_nil());\n-    }\n-\n     fn iter_variant(cx: @block_ctxt, a_tup: ValueRef,\n                     variant: &ty::variant_info, tps: &[ty::t],\n                     tid: &ast::def_id, f: &val_and_ty_fn) -> result {\n@@ -1913,11 +1808,6 @@ fn iter_structural_ty_full(cx: &@block_ctxt, av: ValueRef, t: ty::t,\n             bld::GEP(cx, av, [C_int(0), C_int(abi::obj_field_box)]);\n         ret iter_boxpp(cx, box_cell_a, f);\n       }\n-      ty::ty_vec(unit_tm) { ret iter_ivec(cx, av, unit_tm.ty, f); }\n-      ty::ty_istr. {\n-        let unit_ty = ty::mk_mach(bcx_tcx(cx), ast::ty_u8);\n-        ret iter_ivec(cx, av, unit_ty, f);\n-      }\n       _ { bcx_ccx(cx).sess.unimpl(~\"type in iter_structural_ty_full\"); }\n     }\n     ret r;\n@@ -1987,25 +1877,21 @@ fn iter_sequence_inner(cx: &@block_ctxt, src: ValueRef,\n // Iterates through the elements of a vec or str.\n fn iter_sequence(cx: @block_ctxt, v: ValueRef, t: ty::t, f: &val_and_ty_fn)\n    -> result {\n-    fn iter_sequence_body(cx: @block_ctxt, v: ValueRef, elt_ty: ty::t,\n+    fn iter_sequence_body(bcx: @block_ctxt, v: ValueRef, elt_ty: ty::t,\n                           f: &val_and_ty_fn, trailing_null: bool,\n                           interior: bool) -> result {\n         let p0;\n         let len;\n-        let bcx;\n+        let llunit_ty = type_of_or_i8(bcx, elt_ty);\n         if !interior {\n-            p0 = bld::GEP(cx, v, [C_int(0), C_int(abi::vec_elt_data)]);\n-            let lp = bld::GEP(cx, v, [C_int(0), C_int(abi::vec_elt_fill)]);\n-            len = bld::Load(cx, lp);\n-            bcx = cx;\n+            p0 = bld::GEP(bcx, v, [C_int(0), C_int(abi::vec_elt_data)]);\n+            let lp = bld::GEP(bcx, v, [C_int(0), C_int(abi::vec_elt_fill)]);\n+            len = bld::Load(bcx, lp);\n         } else {\n-            let len_and_data_rslt = ivec::get_len_and_data(cx, v, elt_ty);\n-            len = len_and_data_rslt.len;\n-            p0 = len_and_data_rslt.data;\n-            bcx = len_and_data_rslt.bcx;\n+            len = ivec::get_fill(bcx, v);\n+            p0 = ivec::get_dataptr(bcx, v, llunit_ty);\n         }\n \n-        let llunit_ty = type_of_or_i8(cx, elt_ty);\n         if trailing_null {\n             let unit_sz = size_of(bcx, elt_ty);\n             bcx = unit_sz.bcx;\n@@ -2277,8 +2163,7 @@ fn compare(cx: &@block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n }\n \n fn take_ty(cx: &@block_ctxt, v: ValueRef, t: ty::t) -> result {\n-    if ty::type_has_pointers(bcx_tcx(cx), t) ||\n-           ty::type_owns_heap_mem(bcx_tcx(cx), t) {\n+    if ty::type_has_pointers(bcx_tcx(cx), t) {\n         ret call_tydesc_glue(cx, v, t, abi::tydesc_field_take_glue);\n     }\n     ret rslt(cx, C_nil());\n@@ -2348,19 +2233,6 @@ fn memmove_ty(cx: &@block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n     } else { ret rslt(cx, bld::Store(cx, bld::Load(cx, src), dst)); }\n }\n \n-// Duplicates any heap-owned memory owned by a value of the given type.\n-fn duplicate_heap_parts_if_necessary(cx: &@block_ctxt, vptr: ValueRef,\n-                                     typ: ty::t) -> result {\n-    alt ty::struct(bcx_tcx(cx), typ) {\n-      ty::ty_vec(tm) { ret ivec::duplicate_heap_part(cx, vptr, tm.ty); }\n-      ty::ty_istr. {\n-        ret ivec::duplicate_heap_part(cx, vptr,\n-                                      ty::mk_mach(bcx_tcx(cx), ast::ty_u8));\n-      }\n-      _ { ret rslt(cx, C_nil()); }\n-    }\n-}\n-\n tag copy_action { INIT; DROP_EXISTING; }\n \n // These are the types that are passed by pointer.\n@@ -2403,7 +2275,8 @@ fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n         ret cx;\n     } else if ty::type_is_nil(ccx.tcx, t) || ty::type_is_bot(ccx.tcx, t) {\n         ret cx;\n-    } else if ty::type_is_boxed(ccx.tcx, t) {\n+    } else if ty::type_is_boxed(ccx.tcx, t) ||\n+              ty::type_is_ivec(ccx.tcx, t) {\n         let bcx = if action == DROP_EXISTING {\n             drop_ty(cx, dst, t).bcx\n         } else { cx };\n@@ -2414,12 +2287,8 @@ fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n         let bcx = if action == DROP_EXISTING {\n             drop_ty(cx, dst, t).bcx\n         } else { cx };\n-        if ty::type_needs_copy_glue(ccx.tcx, t) {\n-            ret call_copy_glue(bcx, dst, src, t, true);\n-        } else {\n-            bcx = memmove_ty(bcx, dst, src, t).bcx;\n-            ret take_ty(bcx, dst, t).bcx;\n-        }\n+        bcx = memmove_ty(bcx, dst, src, t).bcx;\n+        ret take_ty(bcx, dst, t).bcx;\n     }\n     ccx.sess.bug(~\"unexpected type in trans::copy_val_no_check: \" +\n                  ty_to_str(ccx.tcx, t));\n@@ -2443,7 +2312,7 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n     } else if ty::type_is_nil(tcx, t) || ty::type_is_bot(tcx, t) {\n         ret cx;\n     } else if ty::type_is_unique(tcx, t) ||\n-                  ty::type_is_boxed(tcx, t) {\n+              ty::type_is_boxed(tcx, t) {\n         if src.is_mem { src_val = bld::Load(cx, src_val); }\n         if action == DROP_EXISTING {\n             cx = drop_ty(cx, dst, t).bcx;\n@@ -2456,11 +2325,7 @@ fn move_val(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n         ret cx;\n     } else if type_is_structural_or_param(tcx, t) {\n         if action == DROP_EXISTING { cx = drop_ty(cx, dst, t).bcx; }\n-        if ty::type_needs_copy_glue(tcx, t) {\n-            cx = call_copy_glue(cx, dst, src_val, t, false);\n-        } else {\n-            cx = memmove_ty(cx, dst, src_val, t).bcx;\n-        }\n+        cx = memmove_ty(cx, dst, src_val, t).bcx;\n         if src.is_mem {\n             ret zero_alloca(cx, src_val, t).bcx;\n         } else { // Temporary value\n@@ -2483,26 +2348,6 @@ fn move_val_if_temp(cx: @block_ctxt, action: copy_action, dst: ValueRef,\n     ret move_val(cx, action, dst, src, t);\n }\n \n-fn trans_lit_istr(cx: &@block_ctxt, s: &istr) -> result {\n-    let vec_ty = ty::mk_vec(bcx_tcx(cx),\n-                            {ty: ty::mk_mach(bcx_tcx(cx), ast::ty_u8),\n-                             mut: ast::imm});\n-    let strlen = istr::byte_len(s);\n-    let veclen = strlen + 1u; // +1 for \\0\n-    let alloc_res = trans_ivec::alloc_with_heap(cx, vec_ty, veclen);\n-\n-    let bcx = alloc_res.bcx;\n-    let llvecptr = alloc_res.llptr;\n-    let llfirsteltptr = alloc_res.llfirsteltptr;\n-\n-    let llcstr = C_cstr(bcx_ccx(cx), s);\n-\n-    // FIXME: We need to avoid this memmove\n-    bcx = call_memmove(bcx, llfirsteltptr, llcstr, C_uint(veclen)).bcx;\n-\n-    ret rslt(bcx, llvecptr);\n-}\n-\n fn trans_crate_lit(cx: &@crate_ctxt, lit: &ast::lit) -> ValueRef {\n     alt lit.node {\n       ast::lit_int(i) { ret C_int(i); }\n@@ -2544,9 +2389,7 @@ fn trans_crate_lit(cx: &@crate_ctxt, lit: &ast::lit) -> ValueRef {\n \n fn trans_lit(cx: &@block_ctxt, lit: &ast::lit) -> result {\n     alt lit.node {\n-      ast::lit_str(s, ast::sk_unique.) {\n-        ret trans_lit_istr(cx, s);\n-      }\n+      ast::lit_str(s, ast::sk_unique.) { ret ivec::trans_istr(cx, s); }\n       _ { ret rslt(cx, trans_crate_lit(bcx_ccx(cx), lit)); }\n     }\n }\n@@ -3492,9 +3335,9 @@ fn trans_index(cx: &@block_ctxt, sp: &span, base: &@ast::expr,\n     maybe_name_value(bcx_ccx(cx), scaled_ix, ~\"scaled_ix\");\n     let interior_len_and_data;\n     if is_interior {\n-        let rslt = ivec::get_len_and_data(bcx, v, unit_ty);\n-        interior_len_and_data = some({len: rslt.len, data: rslt.data});\n-        bcx = rslt.bcx;\n+        let len = ivec::get_fill(bcx, v);\n+        let data = ivec::get_dataptr(bcx, v, type_of_or_i8(bcx, unit_ty));\n+        interior_len_and_data = some({len: len, data: data});\n     } else { interior_len_and_data = none; }\n     let lim;\n     alt interior_len_and_data {\n@@ -3986,7 +3829,11 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n             val = dst.val;\n             add_clean_temp(bcx, val, e_ty);\n         } else {\n-            if lv.is_mem {\n+            if ty::type_is_ivec(ccx.tcx, e_ty) {\n+                let arg_copy = do_spill(bcx, bld::Load(bcx, val));\n+                bcx = take_ty(bcx, arg_copy, e_ty).bcx;\n+                val = bld::Load(bcx, arg_copy);\n+            } else if lv.is_mem {\n                 bcx = take_ty(bcx, val, e_ty).bcx;\n                 val = load_if_immediate(bcx, val, e_ty);\n             } else if is_ext_vec_plus {\n@@ -4291,7 +4138,7 @@ fn trans_expr(cx: &@block_ctxt, e: &@ast::expr) -> result {\n \n fn trans_expr_out(cx: &@block_ctxt, e: &@ast::expr, output: out_method) ->\n    result {\n-    // FIXME Fill in cx.sp\n+    // Fixme Fill in cx.sp\n     alt e.node {\n       ast::expr_lit(lit) { ret trans_lit(cx, *lit); }\n       ast::expr_unary(op, x) {\n@@ -4534,7 +4381,7 @@ fn with_out_method(work: fn(&out_method) -> result, cx: @block_ctxt,\n // immediate-ness of the type.\n fn type_is_immediate(ccx: &@crate_ctxt, t: ty::t) -> bool {\n     ret ty::type_is_scalar(ccx.tcx, t) || ty::type_is_boxed(ccx.tcx, t) ||\n-            ty::type_is_native(ccx.tcx, t);\n+        ty::type_is_native(ccx.tcx, t) || ty::type_is_ivec(ccx.tcx, t);\n }\n \n fn do_spill(cx: &@block_ctxt, v: ValueRef) -> ValueRef {\n@@ -5812,9 +5659,6 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span, main_llfn: ValueRef,\n         let args = [lloutputarg, lltaskarg, llenvarg];\n         if takes_ivec { args += [llargvarg]; }\n         bld::FastCall(bcx, main_llfn, args);\n-        // We're responsible for freeing the arg vector\n-        bcx = maybe_free_ivec_heap_part(bcx, llargvarg,\n-                                        ty::mk_str(ccx.tcx)).bcx;\n         build_return(bcx);\n \n         finish_fn(fcx, lltop);"}, {"sha": "6b2cb1fe533b23ec5a98c432c0e734e8696b0db1", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 12, "deletions": 45, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -5,6 +5,7 @@\n \n import std::int;\n import std::vec;\n+import std::vec::to_ptr;\n import std::str;\n import std::istr;\n import std::uint;\n@@ -454,7 +455,7 @@ fn struct_elt(llstructty: TypeRef, n: uint) -> TypeRef {\n     let elt_count = llvm::LLVMCountStructElementTypes(llstructty);\n     assert (n < elt_count);\n     let elt_tys = std::vec::init_elt(T_nil(), elt_count);\n-    llvm::LLVMGetStructElementTypes(llstructty, std::vec::to_ptr(elt_tys));\n+    llvm::LLVMGetStructElementTypes(llstructty, to_ptr(elt_tys));\n     ret llvm::LLVMGetElementType(elt_tys[n]);\n }\n \n@@ -539,7 +540,7 @@ fn T_size_t() -> TypeRef {\n }\n \n fn T_fn(inputs: &[TypeRef], output: TypeRef) -> TypeRef {\n-    ret llvm::LLVMFunctionType(output, std::vec::to_ptr(inputs),\n+    ret llvm::LLVMFunctionType(output, to_ptr(inputs),\n                                std::vec::len::<TypeRef>(inputs), False);\n }\n \n@@ -550,8 +551,8 @@ fn T_fn_pair(cx: &crate_ctxt, tfn: TypeRef) -> TypeRef {\n fn T_ptr(t: TypeRef) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n \n fn T_struct(elts: &[TypeRef]) -> TypeRef {\n-    ret llvm::LLVMStructType(std::vec::to_ptr(elts), std::vec::len(elts),\n-                             False);\n+    ret llvm::LLVMStructType(to_ptr(elts),\n+                             std::vec::len(elts), False);\n }\n \n fn T_named_struct(name: &istr) -> TypeRef {\n@@ -562,8 +563,8 @@ fn T_named_struct(name: &istr) -> TypeRef {\n }\n \n fn set_struct_body(t: TypeRef, elts: &[TypeRef]) {\n-    llvm::LLVMStructSetBody(t, std::vec::to_ptr(elts), std::vec::len(elts),\n-                            False);\n+    llvm::LLVMStructSetBody(t, to_ptr(elts),\n+                            std::vec::len(elts), False);\n }\n \n fn T_empty_struct() -> TypeRef { ret T_struct([]); }\n@@ -606,7 +607,7 @@ fn T_tydesc_field(cx: &crate_ctxt, field: int) -> TypeRef {\n     let tydesc_elts: [TypeRef] =\n         std::vec::init_elt::<TypeRef>(T_nil(), abi::n_tydesc_fields as uint);\n     llvm::LLVMGetStructElementTypes(cx.tydesc_type,\n-                                    std::vec::to_ptr::<TypeRef>(tydesc_elts));\n+                                    to_ptr::<TypeRef>(tydesc_elts));\n     let t = llvm::LLVMGetElementType(tydesc_elts[field]);\n     ret t;\n }\n@@ -676,48 +677,14 @@ fn T_opaque_vec_ptr() -> TypeRef { ret T_ptr(T_evec(T_int())); }\n //\n // TODO: Support user-defined vector sizes.\n fn T_ivec(t: TypeRef) -> TypeRef {\n-    ret T_struct([T_int(), // Length (\"fill\"; if zero, heapified)\n-                  T_int(), // Alloc\n-                  T_array(t, abi::ivec_default_length)]); // Body elements\n-\n+    ret T_struct([T_int(), // fill\n+                  T_int(), // alloc\n+                  T_array(t, 0u)]); // elements\n }\n \n-\n // Note that the size of this one is in bytes.\n fn T_opaque_ivec() -> TypeRef {\n-    ret T_struct([T_int(), // Length (\"fill\"; if zero, heapified)\n-                  T_int(), // Alloc\n-                  T_array(T_i8(), 0u)]); // Body elements\n-\n-}\n-\n-fn T_ivec_heap_part(t: TypeRef) -> TypeRef {\n-    ret T_struct([T_int(), // Real length\n-                  T_array(t, 0u)]); // Body elements\n-\n-}\n-\n-\n-// Interior vector on the heap, also known as the \"stub\". Cast to this when\n-// the allocated length (second element of T_ivec above) is zero.\n-fn T_ivec_heap(t: TypeRef) -> TypeRef {\n-    ret T_struct([T_int(), // Length (zero)\n-                  T_int(), // Alloc\n-                  T_ptr(T_ivec_heap_part(t))]); // Pointer\n-\n-}\n-\n-fn T_opaque_ivec_heap_part() -> TypeRef {\n-    ret T_struct([T_int(), // Real length\n-                  T_array(T_i8(), 0u)]); // Body elements\n-\n-}\n-\n-fn T_opaque_ivec_heap() -> TypeRef {\n-    ret T_struct([T_int(), // Length (zero)\n-                  T_int(), // Alloc\n-                  T_ptr(T_opaque_ivec_heap_part())]); // Pointer\n-\n+    ret T_ivec(T_i8());\n }\n \n fn T_str() -> TypeRef { ret T_evec(T_i8()); }"}, {"sha": "ce64ed561f9d0f6f7e84eef53522b05fbebd943b", "filename": "src/comp/middle/trans_ivec.rs", "status": "modified", "additions": 229, "deletions": 687, "changes": 916, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_ivec.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -8,768 +8,310 @@ import trans::{call_memmove, trans_shared_malloc, llsize_of,\n                alloca, array_alloca, size_of, llderivedtydescs_block_ctxt,\n                lazily_emit_tydesc_glue, get_tydesc, load_inbounds,\n                move_val_if_temp, trans_lval, node_id_type,\n-               new_sub_block_ctxt, tps_normal};\n-import bld = trans_build;\n+               new_sub_block_ctxt, tps_normal, do_spill};\n+import trans_build::*;\n import trans_common::*;\n \n-fn alloc_with_heap(bcx: @block_ctxt, typ: &ty::t, vecsz: uint) ->\n-    {bcx: @block_ctxt,\n-     unit_ty: ty::t,\n-     llunitsz: ValueRef,\n-     llptr: ValueRef,\n-     llfirsteltptr: ValueRef} {\n-\n-    let unit_ty;\n-    alt ty::struct(bcx_tcx(bcx), typ) {\n-      ty::ty_vec(mt) { unit_ty = mt.ty; }\n-      _ { bcx_ccx(bcx).sess.bug(~\"non-ivec type in trans_ivec\"); }\n-    }\n-    let llunitty = type_of_or_i8(bcx, unit_ty);\n-\n-    let ares = alloc(bcx, unit_ty);\n-    bcx = ares.bcx;\n-    let llvecptr = ares.llptr;\n-    let unit_sz = ares.llunitsz;\n-    let llalen = ares.llalen;\n-\n-    add_clean_temp(bcx, llvecptr, typ);\n-\n-    let lllen = bld::Mul(bcx, C_uint(vecsz), unit_sz);\n-    // Allocate the vector pieces and store length and allocated length.\n-\n-    let llfirsteltptr;\n-    if vecsz > 0u && vecsz <= abi::ivec_default_length {\n-        // Interior case.\n-\n-        bld::Store(bcx, lllen,\n-                        bld::InBoundsGEP(bcx, llvecptr,\n-                                              [C_int(0),\n-                                               C_uint(abi::ivec_elt_len)]));\n-        bld::Store(bcx, llalen,\n-                        bld::InBoundsGEP(bcx, llvecptr,\n-                                              [C_int(0),\n-                                               C_uint(abi::ivec_elt_alen)]));\n-        llfirsteltptr =\n-            bld::InBoundsGEP(bcx, llvecptr,\n-                                  [C_int(0), C_uint(abi::ivec_elt_elems),\n-                                   C_int(0)]);\n-    } else {\n-        // Heap case.\n+fn get_fill(bcx: &@block_ctxt, vptr: ValueRef) -> ValueRef {\n+    Load(bcx, InBoundsGEP(bcx, vptr, [C_int(0), C_uint(abi::ivec_elt_fill)]))\n+}\n+fn get_alloc(bcx: &@block_ctxt, vptr: ValueRef) -> ValueRef {\n+    Load(bcx, InBoundsGEP(bcx, vptr, [C_int(0), C_uint(abi::ivec_elt_alloc)]))\n+}\n+fn get_dataptr(bcx: &@block_ctxt, vpt: ValueRef,\n+               unit_ty: TypeRef) -> ValueRef {\n+    let ptr = InBoundsGEP(bcx, vpt, [C_int(0), C_uint(abi::ivec_elt_elems)]);\n+    PointerCast(bcx, ptr, T_ptr(unit_ty))\n+}\n \n-        let stub_z = [C_int(0), C_uint(abi::ivec_heap_stub_elt_zero)];\n-        let stub_a = [C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)];\n-        let stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n-        let llstubty = T_ivec_heap(llunitty);\n-        let llstubptr = bld::PointerCast(bcx, llvecptr, T_ptr(llstubty));\n-        bld::Store(bcx, C_int(0), bld::InBoundsGEP(bcx, llstubptr, stub_z));\n-        let llheapty = T_ivec_heap_part(llunitty);\n-        if vecsz == 0u {\n-            // Null heap pointer indicates a zero-length vector.\n+fn pointer_add(bcx: &@block_ctxt, ptr: ValueRef, bytes: ValueRef)\n+    -> ValueRef {\n+    let old_ty = val_ty(ptr);\n+    let bptr = PointerCast(bcx, ptr, T_ptr(T_i8()));\n+    ret PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n+}\n \n-            bld::Store(bcx, llalen, bld::InBoundsGEP(bcx, llstubptr, stub_a));\n-            bld::Store(bcx, C_null(T_ptr(llheapty)),\n-                            bld::InBoundsGEP(bcx, llstubptr, stub_p));\n-            llfirsteltptr = C_null(T_ptr(llunitty));\n-        } else {\n-            bld::Store(bcx, lllen, bld::InBoundsGEP(bcx, llstubptr, stub_a));\n+// FIXME factor out a scaling version wrapping a non-scaling version\n+fn alloc(bcx: &@block_ctxt, vec_ty: &ty::t, vecsz: ValueRef, is_scaled: bool)\n+    -> {bcx: @block_ctxt,\n+        val: ValueRef,\n+        unit_ty: ty::t,\n+        llunitsz: ValueRef,\n+        llunitty: TypeRef} {\n \n-            let llheapsz = bld::Add(bcx, llsize_of(llheapty), lllen);\n-            let rslt = trans_shared_malloc(bcx, T_ptr(llheapty), llheapsz);\n-            bcx = rslt.bcx;\n-            let llheapptr = rslt.val;\n-            bld::Store(bcx, llheapptr,\n-                            bld::InBoundsGEP(bcx, llstubptr, stub_p));\n-            let heap_l = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n-            bld::Store(bcx, lllen, bld::InBoundsGEP(bcx, llheapptr, heap_l));\n-            llfirsteltptr =\n-                bld::InBoundsGEP(bcx, llheapptr,\n-                                      [C_int(0),\n-                                       C_uint(abi::ivec_heap_elt_elems),\n-                                       C_int(0)]);\n-        }\n+    let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n+    let llunitty = type_of_or_i8(bcx, unit_ty);\n+    let llvecty = T_ivec(llunitty);\n+    let {bcx, val: unit_sz} = size_of(bcx, unit_ty);\n+\n+    let fill = if is_scaled { vecsz }\n+               else { Mul(bcx, vecsz, unit_sz) };\n+    let vecsize = Add(bcx, fill, llsize_of(llvecty));\n+    let {bcx, val: vecptr} =\n+        trans_shared_malloc(bcx, T_ptr(llvecty), vecsize);\n+    add_clean_temp(bcx, vecptr, vec_ty);\n+\n+    Store(bcx, fill, InBoundsGEP\n+          (bcx, vecptr, [C_int(0), C_uint(abi::ivec_elt_fill)]));\n+    Store(bcx, fill, InBoundsGEP\n+          (bcx, vecptr, [C_int(0), C_uint(abi::ivec_elt_alloc)]));\n+    ret {bcx: bcx, val: vecptr,\n+         unit_ty: unit_ty, llunitsz: unit_sz, llunitty: llunitty};\n+}\n+fn duplicate(bcx: &@block_ctxt, vptrptr: ValueRef) -> @block_ctxt {\n+    let vptr = Load(bcx, vptrptr);\n+    let fill = get_fill(bcx, vptr);\n+    let size = Add(bcx, fill, llsize_of(T_opaque_ivec()));\n+    let {bcx, val: newptr} = trans_shared_malloc(bcx, val_ty(vptr), size);\n+    let bcx = call_memmove(bcx, newptr, vptr, size).bcx;\n+    Store(bcx, fill,\n+          InBoundsGEP(bcx, newptr, [C_int(0), C_uint(abi::ivec_elt_alloc)]));\n+    Store(bcx, newptr, vptrptr);\n+    ret bcx;\n+}\n+fn make_drop_glue(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t)\n+    -> @block_ctxt {\n+    let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n+    let vptr = Load(bcx, vptrptr);\n+    let drop_cx = new_sub_block_ctxt(bcx, ~\"drop\");\n+    let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n+    let null_test = IsNull(bcx, vptr);\n+    CondBr(bcx, null_test, next_cx.llbb, drop_cx.llbb);\n+    if ty::type_needs_drop(bcx_tcx(bcx), unit_ty) {\n+        drop_cx = iter_ivec(drop_cx, vptrptr, vec_ty, trans::drop_ty).bcx;\n     }\n-    ret {\n-        bcx: bcx,\n-        unit_ty: unit_ty,\n-        llunitsz: unit_sz,\n-        llptr: llvecptr,\n-        llfirsteltptr: llfirsteltptr};\n+    drop_cx = trans::trans_shared_free(drop_cx, vptr).bcx;\n+    Br(drop_cx, next_cx.llbb);\n+    ret next_cx;\n }\n \n-fn trans_ivec(bcx: @block_ctxt, args: &[@ast::expr],\n+fn trans_ivec(bcx: &@block_ctxt, args: &[@ast::expr],\n               id: ast::node_id) -> result {\n-\n-    let typ = node_id_type(bcx_ccx(bcx), id);\n-    let alloc_res = alloc_with_heap(bcx, typ, vec::len(args));\n-\n-    let bcx = alloc_res.bcx;\n-    let unit_ty = alloc_res.unit_ty;\n-    let llunitsz = alloc_res.llunitsz;\n-    let llvecptr = alloc_res.llptr;\n-    let llfirsteltptr = alloc_res.llfirsteltptr;\n+    let vec_ty = node_id_type(bcx_ccx(bcx), id);\n+    let {bcx, val: vptr, llunitsz, unit_ty, llunitty} =\n+        alloc(bcx, vec_ty, C_uint(vec::len(args)), false);\n \n     // Store the individual elements.\n+    let dataptr = get_dataptr(bcx, vptr, llunitty);\n     let i = 0u;\n-    for e: @ast::expr in args {\n+    for e in args {\n         let lv = trans_lval(bcx, e);\n         bcx = lv.res.bcx;\n-        let lleltptr;\n-        if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n-            lleltptr =\n-                bld::InBoundsGEP(bcx, llfirsteltptr,\n-                                      [bld::Mul(bcx, C_uint(i), llunitsz)]);\n+        let lleltptr = if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n+            InBoundsGEP(bcx, dataptr, [Mul(bcx, C_uint(i), llunitsz)])\n         } else {\n-            lleltptr = bld::InBoundsGEP(bcx, llfirsteltptr, [C_uint(i)]);\n-        }\n+            InBoundsGEP(bcx, dataptr, [C_uint(i)])\n+        };\n         bcx = move_val_if_temp(bcx, INIT, lleltptr, lv, unit_ty);\n         i += 1u;\n     }\n-    ret rslt(bcx, llvecptr);\n+    ret rslt(bcx, vptr);\n }\n+fn trans_istr(bcx: &@block_ctxt, s: istr) -> result {\n+    let veclen = std::istr::byte_len(s) + 1u; // +1 for \\0\n+    let {bcx, val: sptr, _} =\n+        alloc(bcx, ty::mk_istr(bcx_tcx(bcx)), C_uint(veclen), false);\n \n-// Returns the length of an interior vector and a pointer to its first\n-// element, in that order.\n-fn get_len_and_data(bcx: &@block_ctxt, orig_v: ValueRef, unit_ty: ty::t)\n-    -> {len: ValueRef, data: ValueRef, bcx: @block_ctxt} {\n-    // If this interior vector has dynamic size, we can't assume anything\n-    // about the LLVM type of the value passed in, so we cast it to an\n-    // opaque vector type.\n-    let v;\n-    if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n-        v = bld::PointerCast(bcx, orig_v, T_ptr(T_opaque_ivec()));\n-    } else { v = orig_v; }\n-\n-    let llunitty = type_of_or_i8(bcx, unit_ty);\n-    let stack_len =\n-        load_inbounds(bcx, v, [C_int(0), C_uint(abi::ivec_elt_len)]);\n-    let stack_elem =\n-        bld::InBoundsGEP(bcx, v,\n-                              [C_int(0), C_uint(abi::ivec_elt_elems),\n-                               C_int(0)]);\n-    let on_heap =\n-        bld::ICmp(bcx, lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n-    let on_heap_cx = new_sub_block_ctxt(bcx, ~\"on_heap\");\n-    let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n-    bld::CondBr(bcx, on_heap, on_heap_cx.llbb, next_cx.llbb);\n-    let heap_stub =\n-        bld::PointerCast(on_heap_cx, v, T_ptr(T_ivec_heap(llunitty)));\n-    let heap_ptr =\n-        load_inbounds(on_heap_cx, heap_stub,\n-                      [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)]);\n-\n-    // Check whether the heap pointer is null. If it is, the vector length\n-    // is truly zero.\n-\n-    let llstubty = T_ivec_heap(llunitty);\n-    let llheapptrty = struct_elt(llstubty, abi::ivec_heap_stub_elt_ptr);\n-    let heap_ptr_is_null =\n-        bld::ICmp(on_heap_cx, lib::llvm::LLVMIntEQ, heap_ptr,\n-                              C_null(T_ptr(llheapptrty)));\n-    let zero_len_cx = new_sub_block_ctxt(bcx, ~\"zero_len\");\n-    let nonzero_len_cx = new_sub_block_ctxt(bcx, ~\"nonzero_len\");\n-    bld::CondBr(on_heap_cx, heap_ptr_is_null, zero_len_cx.llbb,\n-                            nonzero_len_cx.llbb);\n-    // Technically this context is unnecessary, but it makes this function\n-    // clearer.\n-\n-    let zero_len = C_int(0);\n-    let zero_elem = C_null(T_ptr(llunitty));\n-    bld::Br(zero_len_cx, next_cx.llbb);\n-    // If we're here, then we actually have a heapified vector.\n-\n-    let heap_len =\n-        load_inbounds(nonzero_len_cx, heap_ptr,\n-                      [C_int(0), C_uint(abi::ivec_heap_elt_len)]);\n-    let heap_elem =\n-        {\n-        let v =\n-            [C_int(0), C_uint(abi::ivec_heap_elt_elems), C_int(0)];\n-        bld::InBoundsGEP(nonzero_len_cx, heap_ptr, v)\n-    };\n+    let llcstr = C_cstr(bcx_ccx(bcx), s);\n+    let bcx = call_memmove(bcx, get_dataptr(bcx, sptr, T_i8()),\n+                           llcstr, C_uint(veclen)).bcx;\n \n-    bld::Br(nonzero_len_cx, next_cx.llbb);\n-    // Now we can figure out the length of `v` and get a pointer to its\n-    // first element.\n-\n-    let len =\n-        bld::Phi(next_cx, T_int(), [stack_len, zero_len, heap_len],\n-                          [bcx.llbb, zero_len_cx.llbb,\n-                           nonzero_len_cx.llbb]);\n-    let elem =\n-        bld::Phi(next_cx, T_ptr(llunitty),\n-                          [stack_elem, zero_elem, heap_elem],\n-                          [bcx.llbb, zero_len_cx.llbb,\n-                           nonzero_len_cx.llbb]);\n-    ret {len: len, data: elem, bcx: next_cx};\n+    ret rslt(bcx, sptr);\n }\n \n-// Returns a tuple consisting of a pointer to the newly-reserved space and\n-// a block context. Updates the length appropriately.\n-fn reserve_space(cx: &@block_ctxt, llunitty: TypeRef, v: ValueRef,\n-                 len_needed: ValueRef) -> result {\n-    let stack_len_ptr =\n-        bld::InBoundsGEP(cx, v, [C_int(0), C_uint(abi::ivec_elt_len)]);\n-    let stack_len = bld::Load(cx, stack_len_ptr);\n-    let alen =\n-        load_inbounds(cx, v, [C_int(0), C_uint(abi::ivec_elt_alen)]);\n-    // There are four cases we have to consider:\n-    // (1) On heap, no resize necessary.\n-    // (2) On heap, need to resize.\n-    // (3) On stack, no resize necessary.\n-    // (4) On stack, need to spill to heap.\n-\n-    let maybe_on_heap =\n-        bld::ICmp(cx, lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n-    let maybe_on_heap_cx = new_sub_block_ctxt(cx, ~\"maybe_on_heap\");\n-    let on_stack_cx = new_sub_block_ctxt(cx, ~\"on_stack\");\n-    bld::CondBr(cx, maybe_on_heap, maybe_on_heap_cx.llbb,\n-                    on_stack_cx.llbb);\n-    let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n-    // We're possibly on the heap, unless the vector is zero-length.\n-\n-    let stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n-    let stub_ptr =\n-        bld::PointerCast(maybe_on_heap_cx, v,\n-                                           T_ptr(T_ivec_heap(llunitty)));\n-    let heap_ptr = load_inbounds(maybe_on_heap_cx, stub_ptr, stub_p);\n-    let on_heap =\n-        bld::ICmp(maybe_on_heap_cx, lib::llvm::LLVMIntNE, heap_ptr,\n-                                    C_null(val_ty(heap_ptr)));\n-    let on_heap_cx = new_sub_block_ctxt(cx, ~\"on_heap\");\n-    bld::CondBr(maybe_on_heap_cx, on_heap, on_heap_cx.llbb,\n-                                  on_stack_cx.llbb);\n-    // We're definitely on the heap. Check whether we need to resize.\n-\n-    let heap_len_ptr =\n-        bld::InBoundsGEP(on_heap_cx, heap_ptr,\n-                                     [C_int(0),\n-                                      C_uint(abi::ivec_heap_elt_len)]);\n-    let heap_len = bld::Load(on_heap_cx, heap_len_ptr);\n-    let new_heap_len = bld::Add(on_heap_cx, heap_len, len_needed);\n-    let heap_len_unscaled =\n-        bld::UDiv(on_heap_cx, heap_len, llsize_of(llunitty));\n-    let heap_no_resize_needed =\n-        bld::ICmp(on_heap_cx, lib::llvm::LLVMIntULE, new_heap_len, alen);\n-    let heap_no_resize_cx = new_sub_block_ctxt(cx, ~\"heap_no_resize\");\n-    let heap_resize_cx = new_sub_block_ctxt(cx, ~\"heap_resize\");\n-    bld::CondBr(on_heap_cx, heap_no_resize_needed, heap_no_resize_cx.llbb,\n-                            heap_resize_cx.llbb);\n-    // Case (1): We're on the heap and don't need to resize.\n-\n-    let heap_data_no_resize =\n-        {\n-        let v =\n-            [C_int(0), C_uint(abi::ivec_heap_elt_elems),\n-             heap_len_unscaled];\n-        bld::InBoundsGEP(heap_no_resize_cx, heap_ptr, v)\n-    };\n-    bld::Store(heap_no_resize_cx, new_heap_len, heap_len_ptr);\n-    bld::Br(heap_no_resize_cx, next_cx.llbb);\n-    // Case (2): We're on the heap and need to resize. This path is rare,\n-    // so we delegate to cold glue.\n-\n-    {\n-        let p =\n-            bld::PointerCast(heap_resize_cx, v, T_ptr(T_opaque_ivec()));\n-        let upcall = bcx_ccx(cx).upcalls.ivec_resize_shared;\n-        bld::Call(heap_resize_cx, upcall,\n-                                  [cx.fcx.lltaskptr, p, new_heap_len]);\n-    }\n-    let heap_ptr_resize = load_inbounds(heap_resize_cx, stub_ptr, stub_p);\n-\n-    let heap_data_resize =\n-        {\n-        let v =\n-            [C_int(0), C_uint(abi::ivec_heap_elt_elems),\n-             heap_len_unscaled];\n-        bld::InBoundsGEP(heap_resize_cx, heap_ptr_resize, v)\n-    };\n-    bld::Br(heap_resize_cx, next_cx.llbb);\n-    // We're on the stack. Check whether we need to spill to the heap.\n-\n-    let new_stack_len = bld::Add(on_stack_cx, stack_len, len_needed);\n-    let stack_no_spill_needed =\n-        bld::ICmp(on_stack_cx, lib::llvm::LLVMIntULE, new_stack_len,\n-                               alen);\n-    let stack_len_unscaled =\n-        bld::UDiv(on_stack_cx, stack_len, llsize_of(llunitty));\n-    let stack_no_spill_cx = new_sub_block_ctxt(cx, ~\"stack_no_spill\");\n-    let stack_spill_cx = new_sub_block_ctxt(cx, ~\"stack_spill\");\n-    bld::CondBr(on_stack_cx, stack_no_spill_needed,\n-                             stack_no_spill_cx.llbb, stack_spill_cx.llbb);\n-    // Case (3): We're on the stack and don't need to spill.\n-\n-    let stack_data_no_spill =\n-        bld::InBoundsGEP(stack_no_spill_cx, v,\n-                                            [C_int(0),\n-                                             C_uint(abi::ivec_elt_elems),\n-                                             stack_len_unscaled]);\n-    bld::Store(stack_no_spill_cx, new_stack_len, stack_len_ptr);\n-    bld::Br(stack_no_spill_cx, next_cx.llbb);\n-    // Case (4): We're on the stack and need to spill. Like case (2), this\n-    // path is rare, so we delegate to cold glue.\n-\n-    {\n-        let p =\n-            bld::PointerCast(stack_spill_cx, v, T_ptr(T_opaque_ivec()));\n-        let upcall = bcx_ccx(cx).upcalls.ivec_spill_shared;\n-        bld::Call(stack_spill_cx, upcall,\n-                                  [cx.fcx.lltaskptr, p, new_stack_len]);\n-    }\n-    let spill_stub =\n-        bld::PointerCast(stack_spill_cx, v, T_ptr(T_ivec_heap(llunitty)));\n-\n-    let heap_ptr_spill =\n-        load_inbounds(stack_spill_cx, spill_stub, stub_p);\n-\n-    let heap_data_spill =\n-        {\n-        let v =\n-            [C_int(0), C_uint(abi::ivec_heap_elt_elems),\n-             stack_len_unscaled];\n-        bld::InBoundsGEP(stack_spill_cx, heap_ptr_spill, v)\n-    };\n-    bld::Br(stack_spill_cx, next_cx.llbb);\n-    // Phi together the different data pointers to get the result.\n-\n-    let data_ptr =\n-        bld::Phi(next_cx, T_ptr(llunitty),\n-                          [heap_data_no_resize, heap_data_resize,\n-                           stack_data_no_spill, heap_data_spill],\n-                          [heap_no_resize_cx.llbb, heap_resize_cx.llbb,\n-                           stack_no_spill_cx.llbb, stack_spill_cx.llbb]);\n-    ret rslt(next_cx, data_ptr);\n-}\n-fn trans_append(cx: &@block_ctxt, t: ty::t, lhs: ValueRef,\n+fn trans_append(cx: &@block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n                 rhs: ValueRef) -> result {\n     // Cast to opaque interior vector types if necessary.\n-    if ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n-        lhs = bld::PointerCast(cx, lhs, T_ptr(T_opaque_ivec()));\n-        rhs = bld::PointerCast(cx, rhs, T_ptr(T_opaque_ivec()));\n+    let unit_ty = ty::sequence_element_type(bcx_tcx(cx), vec_ty);\n+    let dynamic = ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty);\n+    if dynamic {\n+        lhsptr = PointerCast(cx, lhsptr, T_ptr(T_ptr(T_opaque_ivec())));\n+        rhs = PointerCast(cx, rhs, T_ptr(T_opaque_ivec()));\n     }\n-\n-    let unit_ty = ty::sequence_element_type(bcx_tcx(cx), t);\n-    let llunitty = type_of_or_i8(cx, unit_ty);\n-\n-    let rs = size_of(cx, unit_ty);\n-    let bcx = rs.bcx;\n-    let unit_sz = rs.val;\n-\n-    // Gather the various type descriptors we'll need.\n-\n-    // FIXME (issue #511): This is needed to prevent a leak.\n-    let no_tydesc_info = none;\n-\n-    rs = get_tydesc(bcx, t, false, tps_normal, no_tydesc_info).result;\n-    bcx = rs.bcx;\n-    rs = get_tydesc(bcx, unit_ty, false, tps_normal, no_tydesc_info).result;\n-    bcx = rs.bcx;\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, none);\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, none);\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, none);\n-    lazily_emit_tydesc_glue(bcx, abi::tydesc_field_copy_glue, none);\n-    let rhs_len_and_data = get_len_and_data(bcx, rhs, unit_ty);\n-    let rhs_len = rhs_len_and_data.len;\n-    let rhs_data = rhs_len_and_data.data;\n-    bcx = rhs_len_and_data.bcx;\n-\n-    let have_istrs = alt ty::struct(bcx_tcx(cx), t) {\n+    let strings = alt ty::struct(bcx_tcx(cx), vec_ty) {\n       ty::ty_istr. { true }\n       ty::ty_vec(_) { false }\n-      _ { bcx_tcx(cx).sess.bug(~\"non-istr/ivec in trans_append\"); }\n-    };\n-\n-    let extra_len = if have_istrs {\n-        // Only need one of the nulls\n-        bld::Sub(bcx, rhs_len, C_uint(1u))\n-    } else { rhs_len };\n-\n-    rs = reserve_space(bcx, llunitty, lhs, extra_len);\n-    bcx = rs.bcx;\n-\n-    let lhs_data = if have_istrs {\n-        let lhs_data = rs.val;\n-        let lhs_data_without_null_ptr = alloca(bcx, T_ptr(llunitty));\n-        incr_ptr(bcx, lhs_data, C_int(-1),\n-                 lhs_data_without_null_ptr);\n-        bld::Load(bcx, lhs_data_without_null_ptr)\n-    } else {\n-        rs.val\n     };\n \n-    // If rhs is lhs then our rhs pointer may have changed\n-    rhs_len_and_data = get_len_and_data(bcx, rhs, unit_ty);\n-    rhs_data = rhs_len_and_data.data;\n-    bcx = rhs_len_and_data.bcx;\n-\n-    // Work out the end pointer.\n-\n-    let lhs_unscaled_idx = bld::UDiv(bcx, rhs_len, llsize_of(llunitty));\n-    let lhs_end = bld::InBoundsGEP(bcx, lhs_data, [lhs_unscaled_idx]);\n-    // Now emit the copy loop.\n+    let {bcx, val: unit_sz} = size_of(cx, unit_ty);\n+    let llunitty = type_of_or_i8(cx, unit_ty);\n \n-    let dest_ptr = alloca(bcx, T_ptr(llunitty));\n-    bld::Store(bcx, lhs_data, dest_ptr);\n-    let src_ptr = alloca(bcx, T_ptr(llunitty));\n-    bld::Store(bcx, rhs_data, src_ptr);\n-    let copy_loop_header_cx = new_sub_block_ctxt(bcx, ~\"copy_loop_header\");\n-    bld::Br(bcx, copy_loop_header_cx.llbb);\n-    let copy_dest_ptr = bld::Load(copy_loop_header_cx, dest_ptr);\n-    let not_yet_at_end =\n-        bld::ICmp(copy_loop_header_cx, lib::llvm::LLVMIntNE,\n-                                       copy_dest_ptr, lhs_end);\n-    let copy_loop_body_cx = new_sub_block_ctxt(bcx, ~\"copy_loop_body\");\n+    let lhs = Load(bcx, lhsptr);\n+    let self_append = ICmp(bcx, lib::llvm::LLVMIntEQ, lhs, rhs);\n+    let lfill = get_fill(bcx, lhs);\n+    let rfill = get_fill(bcx, rhs);\n+    let new_fill = Add(bcx, lfill, rfill);\n+    if strings { new_fill = Sub(bcx, new_fill, C_int(1)); }\n+    let opaque_lhs = PointerCast(bcx, lhsptr, T_ptr(T_ptr(T_opaque_ivec())));\n+    Call(bcx, bcx_ccx(cx).upcalls.ivec_grow,\n+         [cx.fcx.lltaskptr, opaque_lhs, new_fill]);\n+    // Was overwritten if we resized\n+    let lhs = Load(bcx, lhsptr);\n+    let rhs = Select(bcx, self_append, lhs, rhs);\n+\n+    let lhs_data = get_dataptr(bcx, lhs, llunitty);\n+    let lhs_off = lfill;\n+    if strings { lhs_off = Sub(bcx, lfill, C_int(1)); }\n+    let write_ptr = pointer_add(bcx, lhs_data, lhs_off);\n+    let write_ptr_ptr = do_spill(bcx, write_ptr);\n+    let end_ptr = pointer_add(bcx, write_ptr, rfill);\n+    let read_ptr_ptr = do_spill(bcx, get_dataptr(bcx, rhs, llunitty));\n+\n+    let header_cx = new_sub_block_ctxt(bcx, ~\"copy_loop_header\");\n+    Br(bcx, header_cx.llbb);\n+    let write_ptr = Load(header_cx, write_ptr_ptr);\n+    let not_yet_at_end = ICmp(header_cx, lib::llvm::LLVMIntNE,\n+                              write_ptr, end_ptr);\n+    let body_cx = new_sub_block_ctxt(bcx, ~\"copy_loop_body\");\n     let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n-    bld::CondBr(copy_loop_header_cx, not_yet_at_end,\n-                                     copy_loop_body_cx.llbb,\n-                                     next_cx.llbb);\n-\n-    let copy_src_ptr = bld::Load(copy_loop_body_cx, src_ptr);\n-    let copy_src =\n-        load_if_immediate(copy_loop_body_cx, copy_src_ptr, unit_ty);\n+    CondBr(header_cx, not_yet_at_end,\n+           body_cx.llbb, next_cx.llbb);\n \n-    let post_copy_cx = copy_val\n-        (copy_loop_body_cx, INIT, copy_dest_ptr, copy_src, unit_ty);\n+    let read_ptr = Load(body_cx, read_ptr_ptr);\n+    let body_cx = copy_val(body_cx, INIT, write_ptr,\n+                           load_if_immediate(body_cx, read_ptr, unit_ty),\n+                           unit_ty);\n     // Increment both pointers.\n-    if ty::type_has_dynamic_size(bcx_tcx(cx), t) {\n+    if dynamic {\n         // We have to increment by the dynamically-computed size.\n-        incr_ptr(post_copy_cx, copy_dest_ptr, unit_sz, dest_ptr);\n-        incr_ptr(post_copy_cx, copy_src_ptr, unit_sz, src_ptr);\n+        incr_ptr(body_cx, write_ptr, unit_sz, write_ptr_ptr);\n+        incr_ptr(body_cx, read_ptr, unit_sz, read_ptr_ptr);\n     } else {\n-        incr_ptr(post_copy_cx, copy_dest_ptr, C_int(1), dest_ptr);\n-        incr_ptr(post_copy_cx, copy_src_ptr, C_int(1), src_ptr);\n+        incr_ptr(body_cx, write_ptr, C_int(1), write_ptr_ptr);\n+        incr_ptr(body_cx, read_ptr, C_int(1), read_ptr_ptr);\n     }\n-\n-    bld::Br(post_copy_cx, copy_loop_header_cx.llbb);\n+    Br(body_cx, header_cx.llbb);\n     ret rslt(next_cx, C_nil());\n }\n \n-fn trans_append_literal(bcx: &@block_ctxt, v: ValueRef, vec_ty: ty::t,\n+fn trans_append_literal(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n                         vals: &[@ast::expr]) -> @block_ctxt {\n     let elt_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n     let ti = none;\n     let {bcx, val: td} =\n         get_tydesc(bcx, elt_ty, false, tps_normal, ti).result;\n-    trans::lazily_emit_all_tydesc_glue(bcx, ti);\n-    let opaque_v = bld::PointerCast(bcx, v, T_ptr(T_opaque_ivec()));\n+    trans::lazily_emit_tydesc_glue(bcx, abi::tydesc_field_take_glue, ti);\n+    let opaque_v = PointerCast(bcx, vptrptr, T_ptr(T_ptr(T_opaque_ivec())));\n     for val in vals {\n         let {bcx: e_bcx, val: elt} = trans::trans_expr(bcx, val);\n         bcx = e_bcx;\n         let spilled = trans::spill_if_immediate(bcx, elt, elt_ty);\n-        bld::Call(bcx, bcx_ccx(bcx).upcalls.ivec_push,\n-                       [bcx.fcx.lltaskptr, opaque_v, td,\n-                        bld::PointerCast(bcx, spilled, T_ptr(T_i8()))]);\n+        Call(bcx, bcx_ccx(bcx).upcalls.ivec_push,\n+             [bcx.fcx.lltaskptr, opaque_v, td,\n+              PointerCast(bcx, spilled, T_ptr(T_i8()))]);\n     }\n     ret bcx;\n }\n \n-type alloc_result =\n-    {bcx: @block_ctxt,\n-     llptr: ValueRef,\n-     llunitsz: ValueRef,\n-     llalen: ValueRef};\n-\n-fn alloc(cx: &@block_ctxt, unit_ty: ty::t) -> alloc_result {\n-    let dynamic = ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty);\n-\n-    let bcx;\n-    if dynamic {\n-        bcx = llderivedtydescs_block_ctxt(cx.fcx);\n-    } else { bcx = cx; }\n-\n-    let llunitsz;\n-    let rslt = size_of(bcx, unit_ty);\n-    bcx = rslt.bcx;\n-    llunitsz = rslt.val;\n-\n-    if dynamic { cx.fcx.llderivedtydescs = bcx.llbb; }\n-\n-    let llalen =\n-        bld::Mul(bcx, llunitsz, C_uint(abi::ivec_default_length));\n-\n-    let llptr;\n-    let llunitty = type_of_or_i8(bcx, unit_ty);\n-    let bcx_result;\n-    if dynamic {\n-        let llarraysz = bld::Add(bcx, llsize_of(T_opaque_ivec()), llalen);\n-        let llvecptr = array_alloca(bcx, T_i8(), llarraysz);\n-\n-        bcx_result = cx;\n-        llptr =\n-            bld::PointerCast(bcx_result, llvecptr,\n-                                         T_ptr(T_opaque_ivec()));\n-    } else { llptr = alloca(bcx, T_ivec(llunitty)); bcx_result = bcx; }\n-\n-    ret {bcx: bcx_result,\n-         llptr: llptr,\n-         llunitsz: llunitsz,\n-         llalen: llalen};\n-}\n-\n-fn trans_add(cx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n+fn trans_add(bcx: &@block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n              rhs: ValueRef) -> result {\n-    let bcx = cx;\n-    let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n-\n-    let ares = alloc(bcx, unit_ty);\n-    bcx = ares.bcx;\n-    let llvecptr = ares.llptr;\n-    let unit_sz = ares.llunitsz;\n-    let llalen = ares.llalen;\n-\n-    add_clean_temp(bcx, llvecptr, vec_ty);\n-\n-    let llunitty = type_of_or_i8(bcx, unit_ty);\n-    let llheappartty = T_ivec_heap_part(llunitty);\n-    let lhs_len_and_data = get_len_and_data(bcx, lhs, unit_ty);\n-    let lhs_len = lhs_len_and_data.len;\n-    let lhs_data = lhs_len_and_data.data;\n-    bcx = lhs_len_and_data.bcx;\n-\n-    lhs_len = alt ty::struct(bcx_tcx(bcx), vec_ty) {\n-      ty::ty_istr. {\n-        // Forget about the trailing null on the left side\n-        bld::Sub(bcx, lhs_len, C_uint(1u))\n-      }\n-      ty::ty_vec(_) { lhs_len }\n-      _ { bcx_tcx(bcx).sess.bug(~\"non-istr/ivec in trans_add\") }\n+    let strings = alt ty::struct(bcx_tcx(bcx), vec_ty) {\n+      ty::ty_istr. { true }\n+      ty::ty_vec(_) { false }\n     };\n+    let lhs_fill = get_fill(bcx, lhs);\n+    if strings { lhs_fill = Sub(bcx, lhs_fill, C_int(1)); }\n+    let rhs_fill = get_fill(bcx, rhs);\n+    let new_fill = Add(bcx, lhs_fill, rhs_fill);\n+    let {bcx, val: new_vec, unit_ty, llunitsz, llunitty} =\n+        alloc(bcx, vec_ty, new_fill, true);\n+\n+    // Emit the copy loop\n+    let write_ptr_ptr = do_spill(bcx, get_dataptr(bcx, new_vec, llunitty));\n+    let lhs_ptr = get_dataptr(bcx, lhs, llunitty);\n+    let lhs_ptr_ptr = do_spill(bcx, lhs_ptr);\n+    let lhs_end_ptr = pointer_add(bcx, lhs_ptr, lhs_fill);\n+    let rhs_ptr = get_dataptr(bcx, rhs, llunitty);\n+    let rhs_ptr_ptr = do_spill(bcx, rhs_ptr);\n+    let rhs_end_ptr = pointer_add(bcx, rhs_ptr, rhs_fill);\n \n-    let rhs_len_and_data = get_len_and_data(bcx, rhs, unit_ty);\n-    let rhs_len = rhs_len_and_data.len;\n-    let rhs_data = rhs_len_and_data.data;\n-    bcx = rhs_len_and_data.bcx;\n-    let lllen = bld::Add(bcx, lhs_len, rhs_len);\n-    // We have three cases to handle here:\n-    // (1) Length is zero ([] + []).\n-    // (2) Copy onto stack.\n-    // (3) Allocate on heap and copy there.\n-\n-    let len_is_zero =\n-        bld::ICmp(bcx, lib::llvm::LLVMIntEQ, lllen, C_int(0));\n-    let zero_len_cx = new_sub_block_ctxt(bcx, ~\"zero_len\");\n-    let nonzero_len_cx = new_sub_block_ctxt(bcx, ~\"nonzero_len\");\n-    bld::CondBr(bcx, len_is_zero, zero_len_cx.llbb, nonzero_len_cx.llbb);\n-    // Case (1): Length is zero.\n-\n-    let stub_z = [C_int(0), C_uint(abi::ivec_heap_stub_elt_zero)];\n-    let stub_a = [C_int(0), C_uint(abi::ivec_heap_stub_elt_alen)];\n-    let stub_p = [C_int(0), C_uint(abi::ivec_heap_stub_elt_ptr)];\n-\n-    let vec_l = [C_int(0), C_uint(abi::ivec_elt_len)];\n-    let vec_a = [C_int(0), C_uint(abi::ivec_elt_alen)];\n-\n-    let stub_ptr_zero =\n-        bld::PointerCast(zero_len_cx, llvecptr,\n-                                      T_ptr(T_ivec_heap(llunitty)));\n-    bld::Store(zero_len_cx, C_int(0),\n-                            bld::InBoundsGEP(zero_len_cx, stub_ptr_zero,\n-                                                          stub_z));\n-    bld::Store(zero_len_cx, llalen,\n-                            bld::InBoundsGEP(zero_len_cx, stub_ptr_zero,\n-                                                          stub_a));\n-    bld::Store(zero_len_cx, C_null(T_ptr(llheappartty)),\n-                            bld::InBoundsGEP(zero_len_cx, stub_ptr_zero,\n-                                                          stub_p));\n-    let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n-    bld::Br(zero_len_cx, next_cx.llbb);\n-    // Determine whether we need to spill to the heap.\n-\n-    let on_stack =\n-        bld::ICmp(nonzero_len_cx, lib::llvm::LLVMIntULE, lllen, llalen);\n-    let stack_cx = new_sub_block_ctxt(bcx, ~\"stack\");\n-    let heap_cx = new_sub_block_ctxt(bcx, ~\"heap\");\n-    bld::CondBr(nonzero_len_cx, on_stack, stack_cx.llbb, heap_cx.llbb);\n-    // Case (2): Copy onto stack.\n-\n-    bld::Store(stack_cx, lllen,\n-                         bld::InBoundsGEP(stack_cx, llvecptr, vec_l));\n-    bld::Store(stack_cx, llalen,\n-                         bld::InBoundsGEP(stack_cx, llvecptr, vec_a));\n-    let dest_ptr_stack =\n-        bld::InBoundsGEP(stack_cx, llvecptr,\n-                                   [C_int(0), C_uint(abi::ivec_elt_elems),\n-                                    C_int(0)]);\n-    let copy_cx = new_sub_block_ctxt(bcx, ~\"copy\");\n-    bld::Br(stack_cx, copy_cx.llbb);\n-    // Case (3): Allocate on heap and copy there.\n-\n-    let stub_ptr_heap =\n-        bld::PointerCast(heap_cx, llvecptr, T_ptr(T_ivec_heap(llunitty)));\n-    bld::Store(heap_cx, C_int(0),\n-                        bld::InBoundsGEP(heap_cx, stub_ptr_heap, stub_z));\n-    bld::Store(heap_cx, lllen,\n-                        bld::InBoundsGEP(heap_cx, stub_ptr_heap, stub_a));\n-    let heap_sz = bld::Add(heap_cx, llsize_of(llheappartty), lllen);\n-    let rs = trans_shared_malloc(heap_cx, T_ptr(llheappartty), heap_sz);\n-    let heap_part = rs.val;\n-    heap_cx = rs.bcx;\n-    bld::Store(heap_cx, heap_part,\n-                        bld::InBoundsGEP(heap_cx, stub_ptr_heap, stub_p));\n-    {\n-        let v = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n-        bld::Store(heap_cx, lllen,\n-                            bld::InBoundsGEP(heap_cx, heap_part, v));\n-    }\n-    let dest_ptr_heap =\n-        bld::InBoundsGEP(heap_cx, heap_part,\n-                                  [C_int(0),\n-                                   C_uint(abi::ivec_heap_elt_elems),\n-                                   C_int(0)]);\n-    bld::Br(heap_cx, copy_cx.llbb);\n-    // Emit the copy loop.\n-\n-    let first_dest_ptr =\n-        bld::Phi(copy_cx, T_ptr(llunitty),\n-                          [dest_ptr_stack, dest_ptr_heap],\n-                          [stack_cx.llbb, heap_cx.llbb]);\n-\n-    let lhs_end_ptr;\n-    let rhs_end_ptr;\n-    if ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty) {\n-        lhs_end_ptr = bld::InBoundsGEP(copy_cx, lhs_data, [lhs_len]);\n-        rhs_end_ptr = bld::InBoundsGEP(copy_cx, rhs_data, [rhs_len]);\n-    } else {\n-        let lhs_len_unscaled = bld::UDiv(copy_cx, lhs_len, unit_sz);\n-        lhs_end_ptr =\n-            bld::InBoundsGEP(copy_cx, lhs_data, [lhs_len_unscaled]);\n-        let rhs_len_unscaled = bld::UDiv(copy_cx, rhs_len, unit_sz);\n-        rhs_end_ptr =\n-            bld::InBoundsGEP(copy_cx, rhs_data, [rhs_len_unscaled]);\n-    }\n-\n-    let dest_ptr_ptr = alloca(copy_cx, T_ptr(llunitty));\n-    bld::Store(copy_cx, first_dest_ptr, dest_ptr_ptr);\n-    let lhs_ptr_ptr = alloca(copy_cx, T_ptr(llunitty));\n-    bld::Store(copy_cx, lhs_data, lhs_ptr_ptr);\n-    let rhs_ptr_ptr = alloca(copy_cx, T_ptr(llunitty));\n-    bld::Store(copy_cx, rhs_data, rhs_ptr_ptr);\n-    let lhs_copy_cx = new_sub_block_ctxt(bcx, ~\"lhs_copy\");\n-    bld::Br(copy_cx, lhs_copy_cx.llbb);\n     // Copy in elements from the LHS.\n-\n-    let lhs_ptr = bld::Load(lhs_copy_cx, lhs_ptr_ptr);\n+    let lhs_cx = new_sub_block_ctxt(bcx, ~\"lhs_copy_header\");\n+    Br(bcx, lhs_cx.llbb);\n+    let lhs_ptr = Load(lhs_cx, lhs_ptr_ptr);\n     let not_at_end_lhs =\n-        bld::ICmp(lhs_copy_cx, lib::llvm::LLVMIntNE, lhs_ptr,\n-                               lhs_end_ptr);\n-    let lhs_do_copy_cx = new_sub_block_ctxt(bcx, ~\"lhs_do_copy\");\n-    let rhs_copy_cx = new_sub_block_ctxt(bcx, ~\"rhs_copy\");\n-    bld::CondBr(lhs_copy_cx, not_at_end_lhs, lhs_do_copy_cx.llbb,\n-                             rhs_copy_cx.llbb);\n-    let dest_ptr_lhs_copy = bld::Load(lhs_do_copy_cx, dest_ptr_ptr);\n-    let lhs_val = load_if_immediate(lhs_do_copy_cx, lhs_ptr, unit_ty);\n-    lhs_do_copy_cx = copy_val(lhs_do_copy_cx, INIT, dest_ptr_lhs_copy,\n-                              lhs_val, unit_ty);\n-\n+        ICmp(lhs_cx, lib::llvm::LLVMIntNE, lhs_ptr, lhs_end_ptr);\n+    let lhs_copy_cx = new_sub_block_ctxt(bcx, ~\"lhs_copy_body\");\n+    let rhs_cx = new_sub_block_ctxt(bcx, ~\"rhs_copy_header\");\n+    CondBr(lhs_cx, not_at_end_lhs, lhs_copy_cx.llbb, rhs_cx.llbb);\n+    let write_ptr = Load(lhs_copy_cx, write_ptr_ptr);\n+    lhs_copy_cx =\n+        copy_val(lhs_copy_cx, INIT, write_ptr,\n+                 load_if_immediate(lhs_copy_cx, lhs_ptr, unit_ty), unit_ty);\n     // Increment both pointers.\n-    if ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty) {\n+    if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n         // We have to increment by the dynamically-computed size.\n-        incr_ptr(lhs_do_copy_cx, dest_ptr_lhs_copy, unit_sz,\n-                 dest_ptr_ptr);\n-        incr_ptr(lhs_do_copy_cx, lhs_ptr, unit_sz, lhs_ptr_ptr);\n+        incr_ptr(lhs_copy_cx, write_ptr, llunitsz, write_ptr_ptr);\n+        incr_ptr(lhs_copy_cx, lhs_ptr, llunitsz, lhs_ptr_ptr);\n     } else {\n-        incr_ptr(lhs_do_copy_cx, dest_ptr_lhs_copy, C_int(1),\n-                 dest_ptr_ptr);\n-        incr_ptr(lhs_do_copy_cx, lhs_ptr, C_int(1), lhs_ptr_ptr);\n+        incr_ptr(lhs_copy_cx, write_ptr, C_int(1), write_ptr_ptr);\n+        incr_ptr(lhs_copy_cx, lhs_ptr, C_int(1), lhs_ptr_ptr);\n     }\n+    Br(lhs_copy_cx, lhs_cx.llbb);\n \n-    bld::Br(lhs_do_copy_cx, lhs_copy_cx.llbb);\n     // Copy in elements from the RHS.\n-\n-    let rhs_ptr = bld::Load(rhs_copy_cx, rhs_ptr_ptr);\n+    let rhs_ptr = Load(rhs_cx, rhs_ptr_ptr);\n     let not_at_end_rhs =\n-        bld::ICmp(rhs_copy_cx, lib::llvm::LLVMIntNE, rhs_ptr,\n-                               rhs_end_ptr);\n-    let rhs_do_copy_cx = new_sub_block_ctxt(bcx, ~\"rhs_do_copy\");\n-    bld::CondBr(rhs_copy_cx, not_at_end_rhs, rhs_do_copy_cx.llbb,\n-                             next_cx.llbb);\n-    let dest_ptr_rhs_copy = bld::Load(rhs_do_copy_cx, dest_ptr_ptr);\n-    let rhs_val = load_if_immediate(rhs_do_copy_cx, rhs_ptr, unit_ty);\n-    rhs_do_copy_cx = copy_val(rhs_do_copy_cx, INIT, dest_ptr_rhs_copy,\n-                              rhs_val, unit_ty);\n-\n+        ICmp(rhs_cx, lib::llvm::LLVMIntNE, rhs_ptr, rhs_end_ptr);\n+    let rhs_copy_cx = new_sub_block_ctxt(bcx, ~\"rhs_copy_body\");\n+    let next_cx = new_sub_block_ctxt(bcx, ~\"next\");\n+    CondBr(rhs_cx, not_at_end_rhs, rhs_copy_cx.llbb, next_cx.llbb);\n+    let write_ptr = Load(rhs_copy_cx, write_ptr_ptr);\n+    rhs_copy_cx =\n+        copy_val(rhs_copy_cx, INIT, write_ptr,\n+                 load_if_immediate(rhs_copy_cx, rhs_ptr, unit_ty), unit_ty);\n     // Increment both pointers.\n-    if ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty) {\n+    if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n         // We have to increment by the dynamically-computed size.\n-        incr_ptr(rhs_do_copy_cx, dest_ptr_rhs_copy, unit_sz,\n-                 dest_ptr_ptr);\n-        incr_ptr(rhs_do_copy_cx, rhs_ptr, unit_sz, rhs_ptr_ptr);\n+        incr_ptr(rhs_copy_cx, write_ptr, llunitsz, write_ptr_ptr);\n+        incr_ptr(rhs_copy_cx, rhs_ptr, llunitsz, rhs_ptr_ptr);\n     } else {\n-        incr_ptr(rhs_do_copy_cx, dest_ptr_rhs_copy, C_int(1),\n-                 dest_ptr_ptr);\n-        incr_ptr(rhs_do_copy_cx, rhs_ptr, C_int(1), rhs_ptr_ptr);\n+        incr_ptr(rhs_copy_cx, write_ptr, C_int(1), write_ptr_ptr);\n+        incr_ptr(rhs_copy_cx, rhs_ptr, C_int(1), rhs_ptr_ptr);\n     }\n+    Br(rhs_copy_cx, rhs_cx.llbb);\n \n-    bld::Br(rhs_do_copy_cx, rhs_copy_cx.llbb);\n-    // Finally done!\n-\n-    ret rslt(next_cx, llvecptr);\n+    ret rslt(next_cx, new_vec);\n }\n \n-// NB: This does *not* adjust reference counts. The caller must have done\n-// this via take_ty() beforehand.\n-fn duplicate_heap_part(cx: &@block_ctxt, orig_vptr: ValueRef,\n-                       unit_ty: ty::t) -> result {\n-    // Cast to an opaque interior vector if we can't trust the pointer\n-    // type.\n-    let vptr;\n-    if ty::type_has_dynamic_size(bcx_tcx(cx), unit_ty) {\n-        vptr = bld::PointerCast(cx, orig_vptr, T_ptr(T_opaque_ivec()));\n-    } else { vptr = orig_vptr; }\n-\n-    let llunitty = type_of_or_i8(cx, unit_ty);\n-    let llheappartty = T_ivec_heap_part(llunitty);\n-\n-    // Check to see if the vector is heapified.\n-    let stack_len_ptr =\n-        bld::InBoundsGEP(cx, vptr, [C_int(0), C_uint(abi::ivec_elt_len)]);\n-    let stack_len = bld::Load(cx, stack_len_ptr);\n-    let stack_len_is_zero =\n-        bld::ICmp(cx, lib::llvm::LLVMIntEQ, stack_len, C_int(0));\n-    let maybe_on_heap_cx = new_sub_block_ctxt(cx, ~\"maybe_on_heap\");\n-    let next_cx = new_sub_block_ctxt(cx, ~\"next\");\n-    bld::CondBr(cx, stack_len_is_zero, maybe_on_heap_cx.llbb,\n-                    next_cx.llbb);\n-\n-    let stub_ptr =\n-        bld::PointerCast(maybe_on_heap_cx, vptr,\n-                                           T_ptr(T_ivec_heap(llunitty)));\n-    let heap_ptr_ptr =\n-        bld::InBoundsGEP(maybe_on_heap_cx,\n-            stub_ptr,\n-            [C_int(0),\n-             C_uint(abi::ivec_heap_stub_elt_ptr)]);\n-    let heap_ptr = bld::Load(maybe_on_heap_cx, heap_ptr_ptr);\n-    let heap_ptr_is_nonnull =\n-        bld::ICmp(maybe_on_heap_cx, lib::llvm::LLVMIntNE, heap_ptr,\n-                                    C_null(T_ptr(llheappartty)));\n-    let on_heap_cx = new_sub_block_ctxt(cx, ~\"on_heap\");\n-    bld::CondBr(maybe_on_heap_cx, heap_ptr_is_nonnull, on_heap_cx.llbb,\n-                                  next_cx.llbb);\n-\n-    // Ok, the vector is on the heap. Copy the heap part.\n-    let alen_ptr =\n-        bld::InBoundsGEP(on_heap_cx, stub_ptr,\n-            [C_int(0),\n-             C_uint(abi::ivec_heap_stub_elt_alen)]);\n-    let alen = bld::Load(on_heap_cx, alen_ptr);\n-\n-    let heap_part_sz =\n-        bld::Add(on_heap_cx, alen, llsize_of(T_opaque_ivec_heap_part()));\n-    let rs =\n-        trans_shared_malloc(on_heap_cx, T_ptr(llheappartty),\n-                            heap_part_sz);\n-    on_heap_cx = rs.bcx;\n-    let new_heap_ptr = rs.val;\n-\n-    rs = call_memmove(on_heap_cx, new_heap_ptr, heap_ptr, heap_part_sz);\n-    on_heap_cx = rs.bcx;\n-\n-    bld::Store(on_heap_cx, new_heap_ptr, heap_ptr_ptr);\n-    bld::Br(on_heap_cx, next_cx.llbb);\n+// FIXME factor out a utility that can be used to create the loops built\n+// above\n+fn iter_ivec(bcx: &@block_ctxt, vptrptr: ValueRef, vec_ty: ty::t,\n+             f: &trans::val_and_ty_fn) -> result {\n+    let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);\n+    let llunitty = type_of_or_i8(bcx, unit_ty);\n+    let {bcx, val: unit_sz} = size_of(bcx, unit_ty);\n+\n+    let vptr = Load(bcx, PointerCast(bcx, vptrptr,\n+                                     T_ptr(T_ptr(T_ivec(llunitty)))));\n+    let fill = get_fill(bcx, vptr);\n+    let data_ptr = get_dataptr(bcx, vptr, llunitty);\n+\n+    // Calculate the last pointer address we want to handle.\n+    // TODO: Optimize this when the size of the unit type is statically\n+    // known to not use pointer casts, which tend to confuse LLVM.\n+    let data_end_ptr = pointer_add(bcx, data_ptr, fill);\n+    let data_ptr_ptr = do_spill(bcx, data_ptr);\n+\n+    // Now perform the iteration.\n+    let header_cx = new_sub_block_ctxt(bcx, ~\"iter_ivec_loop_header\");\n+    Br(bcx, header_cx.llbb);\n+    let data_ptr = Load(header_cx, data_ptr_ptr);\n+    let not_yet_at_end = ICmp(header_cx, lib::llvm::LLVMIntULT,\n+                              data_ptr, data_end_ptr);\n+    let body_cx = new_sub_block_ctxt(bcx, ~\"iter_ivec_loop_body\");\n+    let next_cx = new_sub_block_ctxt(bcx, ~\"iter_ivec_next\");\n+    CondBr(header_cx, not_yet_at_end, body_cx.llbb, next_cx.llbb);\n+    body_cx = f(body_cx, data_ptr, unit_ty).bcx;\n+    let increment = if ty::type_has_dynamic_size(bcx_tcx(bcx), unit_ty) {\n+        unit_sz\n+    } else { C_int(1) };\n+    incr_ptr(body_cx, data_ptr, increment, data_ptr_ptr);\n+    Br(body_cx, header_cx.llbb);\n \n     ret rslt(next_cx, C_nil());\n }\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "2574a0837dc4e87dd76b25430ace955fb395102e", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 16, "deletions": 103, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -158,13 +158,13 @@ export type_kind;\n export type_err;\n export type_err_to_str;\n export type_has_dynamic_size;\n-export type_needs_copy_glue;\n export type_has_pointers;\n export type_needs_drop;\n export type_is_bool;\n export type_is_bot;\n export type_is_box;\n export type_is_boxed;\n+export type_is_ivec;\n export type_is_fp;\n export type_is_integral;\n export type_is_native;\n@@ -178,7 +178,6 @@ export type_is_copyable;\n export type_is_tup_like;\n export type_is_str;\n export type_is_unique;\n-export type_owns_heap_mem;\n export type_autoderef;\n export type_param;\n export unify;\n@@ -226,7 +225,6 @@ type ctxt =\n       short_names_cache: hashmap<t, @istr>,\n       has_pointer_cache: hashmap<t, bool>,\n       kind_cache: hashmap<t, ast::kind>,\n-      owns_heap_mem_cache: hashmap<t, bool>,\n       ast_ty_to_ty_cache: hashmap<@ast::ty, option::t<t>>};\n \n type ty_ctxt = ctxt;\n@@ -418,7 +416,6 @@ fn mk_ctxt(s: session::session, dm: resolve::def_map,\n           short_names_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n           has_pointer_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n           kind_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n-          owns_heap_mem_cache: map::mk_hashmap(ty::hash_ty, ty::eq_ty),\n           ast_ty_to_ty_cache: map::mk_hashmap(ast_util::hash_ty,\n                                               ast_util::eq_ty)};\n     populate_type_store(cx);\n@@ -828,8 +825,6 @@ fn type_is_structural(cx: &ctxt, ty: t) -> bool {\n       ty_fn(_, _, _, _, _) { ret true; }\n       ty_obj(_) { ret true; }\n       ty_res(_, _, _) { ret true; }\n-      ty_vec(_) { ret true; }\n-      ty_istr. { ret true; }\n       _ { ret false; }\n     }\n }\n@@ -861,8 +856,6 @@ fn type_is_str(cx: &ctxt, ty: t) -> bool {\n \n fn sequence_is_interior(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n-\n-\n       ty::ty_str. {\n         ret false;\n       }\n@@ -919,8 +912,20 @@ fn type_is_boxed(cx: &ctxt, ty: t) -> bool {\n     }\n }\n \n+fn type_is_ivec(cx: &ctxt, ty: t) -> bool {\n+    ret alt struct(cx, ty) {\n+      ty_vec(_) { true }\n+      ty_istr. { true }\n+      _ { false }\n+    };\n+}\n+\n fn type_is_unique(cx: &ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) { ty_uniq(_) { ret true; } _ { ret false; } }\n+    alt struct(cx, ty) {\n+      ty_uniq(_) { ret true; }\n+      ty_vec(_) { true }\n+      ty_istr. { true }\n+      _ { ret false; } }\n }\n \n fn type_is_scalar(cx: &ctxt, ty: t) -> bool {\n@@ -947,13 +952,8 @@ fn type_has_pointers(cx: &ctxt, ty: t) -> bool {\n \n     let result = false;\n     alt struct(cx, ty) {\n-\n-\n       // scalar types\n-      ty_nil. {\n-        /* no-op */\n-\n-      }\n+      ty_nil. {/* no-op */ }\n       ty_bot. {/* no-op */ }\n       ty_bool. {/* no-op */ }\n       ty_int. {/* no-op */ }\n@@ -996,6 +996,7 @@ fn type_has_pointers(cx: &ctxt, ty: t) -> bool {\n fn type_needs_drop(cx: &ctxt, ty: t) -> bool {\n     ret alt struct(cx, ty) {\n           ty_res(_, _, _) { true }\n+          ty_param(_, _) { true }\n           _ { type_has_pointers(cx, ty) }\n         };\n }\n@@ -1152,7 +1153,6 @@ fn type_structurally_contains(cx: &ctxt, ty: t,\n         }\n         ret false;\n       }\n-      ty_vec(mt) { ret type_structurally_contains(cx, mt.ty, test); }\n       ty_rec(fields) {\n         for field in fields {\n             if type_structurally_contains(cx, field.mt.ty, test) { ret true; }\n@@ -1182,17 +1182,6 @@ fn type_has_dynamic_size(cx: &ctxt, ty: t) -> bool {\n     });\n }\n \n-fn type_needs_copy_glue(cx: &ctxt, ty: t) -> bool {\n-    ret type_structurally_contains(cx, ty, fn(sty: &sty) -> bool {\n-        ret alt sty {\n-          ty_param(_, _) { true }\n-          ty_vec(_) { true }\n-          ty_istr. { true }\n-          _ { false }\n-        };\n-    });\n-}\n-\n fn type_is_integral(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_int. { ret true; }\n@@ -1246,82 +1235,6 @@ fn type_is_signed(cx: &ctxt, ty: t) -> bool {\n     }\n }\n \n-fn type_owns_heap_mem(cx: &ctxt, ty: t) -> bool {\n-    alt cx.owns_heap_mem_cache.find(ty) {\n-      some(result) { ret result; }\n-      none. {/* fall through */ }\n-    }\n-\n-    let result = false;\n-    alt struct(cx, ty) {\n-      ty_vec(_) { result = true; }\n-      ty_istr. { result = true; }\n-\n-\n-\n-      // scalar types\n-      ty_nil. {\n-        result = false;\n-      }\n-      ty_bot. { result = false; }\n-      ty_bool. { result = false; }\n-      ty_int. { result = false; }\n-      ty_float. { result = false; }\n-      ty_uint. { result = false; }\n-      ty_machine(_) { result = false; }\n-      ty_char. { result = false; }\n-      ty_type. { result = false; }\n-      ty_native(_) { result = false; }\n-\n-\n-\n-      // boxed types\n-      ty_str. {\n-        result = false;\n-      }\n-      ty_box(_) { result = false; }\n-      ty_fn(_, _, _, _, _) { result = false; }\n-      ty_native_fn(_, _, _) { result = false; }\n-      ty_obj(_) { result = false; }\n-\n-\n-\n-      // structural types\n-      ty_tag(did, tps) {\n-        let variants = tag_variants(cx, did);\n-        for variant: variant_info in variants {\n-            for aty: t in variant.args {\n-                // Perform any type parameter substitutions.\n-                let arg_ty = substitute_type_params(cx, tps, aty);\n-                if type_owns_heap_mem(cx, arg_ty) { result = true; }\n-            }\n-        }\n-      }\n-      ty_rec(flds) {\n-        for f: field in flds {\n-            if type_owns_heap_mem(cx, f.mt.ty) { result = true; }\n-        }\n-      }\n-      ty_tup(elts) {\n-        for m in elts { if type_owns_heap_mem(cx, m) { result = true; } }\n-      }\n-      ty_res(_, inner, tps) {\n-        result =\n-            type_owns_heap_mem(cx, substitute_type_params(cx, tps, inner));\n-      }\n-\n-\n-      ty_ptr(_) {\n-        result = false;\n-      }\n-      ty_var(_) { fail \"ty_var in type_owns_heap_mem\"; }\n-      ty_param(_, _) { result = false; }\n-    }\n-\n-    cx.owns_heap_mem_cache.insert(ty, result);\n-    ret result;\n-}\n-\n // Whether a type is Plain Old Data (i.e. can be safely memmoved).\n fn type_is_pod(cx: &ctxt, ty: t) -> bool {\n     let result = true;"}, {"sha": "94f2dd3c99f8a0b7bde6a812fbf21eee567bd614", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -60,7 +60,7 @@ type parser =\n         fn get_sess() -> parse_sess;\n     };\n \n-fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, path: &istr,\n+fn new_parser_from_file(sess: parse_sess, cfg: &ast::crate_cfg, path: &istr,\n                         chpos: uint, byte_pos: uint, ftype: file_type) ->\n    parser {\n     let src = io::read_whole_file_str(path);\n@@ -69,11 +69,10 @@ fn new_parser_from_file(sess: parse_sess, cfg: ast::crate_cfg, path: &istr,\n     sess.cm.files += [filemap];\n     let itr = @interner::mk(istr::hash, istr::eq);\n     let rdr = lexer::new_reader(sess.cm, src, filemap, itr);\n-\n     ret new_parser(sess, cfg, rdr, ftype);\n }\n \n-fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n+fn new_parser(sess: parse_sess, cfg: &ast::crate_cfg, rdr: lexer::reader,\n               ftype: file_type) -> parser {\n     obj stdio_parser(sess: parse_sess,\n                      cfg: ast::crate_cfg,\n@@ -141,7 +140,6 @@ fn new_parser(sess: parse_sess, cfg: ast::crate_cfg, rdr: lexer::reader,\n         fn get_id() -> node_id { ret next_node_id(sess); }\n         fn get_sess() -> parse_sess { ret sess; }\n     }\n-\n     let tok0 = lexer::next_token(rdr);\n     let span0 = ast_util::mk_sp(tok0.chpos, rdr.get_chpos());\n     ret stdio_parser(sess, cfg, ftype, tok0.tok, span0, span0, [],"}, {"sha": "92738d01f9207d3f3ea2f4b02cfd10713be32e71", "filename": "src/lib/aio.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Flib%2Faio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Flib%2Faio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Faio.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -45,7 +45,7 @@ tag request {\n type ctx = chan<request>;\n \n fn ip_to_sbuf(ip: net::ip_addr) -> *u8 {\n-    vec::to_ptr(str::bytes(net::format_addr(ip)))\n+    vec::unsafe::to_ptr(str::bytes(net::format_addr(ip)))\n }\n \n fn connect_task(ip: net::ip_addr, portnum: int, evt: chan<socket_event>) {\n@@ -132,7 +132,7 @@ fn request_task(c: chan<ctx>) {\n             task::spawn(bind server_task(ip, portnum, events, server));\n           }\n           write(socket, v, status) {\n-            rustrt::aio_writedata(socket, vec::to_ptr::<u8>(v),\n+            rustrt::aio_writedata(socket, vec::unsafe::to_ptr::<u8>(v),\n                                   vec::len::<u8>(v), status);\n           }\n           close_server(server, status) {"}, {"sha": "342d3bbd9c3f9d8fccbb22815e44a216d87671a9", "filename": "src/lib/io.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -59,7 +59,8 @@ obj FILE_buf_reader(f: os::libc::FILE, res: option::t<@FILE_res>) {\n     fn read(len: uint) -> [u8] {\n         let buf = [];\n         vec::reserve::<u8>(buf, len);\n-        let read = os::libc::fread(vec::to_ptr::<u8>(buf), 1u, len, f);\n+        let read = os::libc::fread(vec::unsafe::to_ptr::<u8>(buf),\n+                                   1u, len, f);\n         vec::unsafe::set_len::<u8>(buf, read);\n         ret buf;\n     }\n@@ -237,7 +238,7 @@ type buf_writer =\n obj FILE_writer(f: os::libc::FILE, res: option::t<@FILE_res>) {\n     fn write(v: &[u8]) {\n         let len = vec::len::<u8>(v);\n-        let vbuf = vec::to_ptr::<u8>(v);\n+        let vbuf = vec::unsafe::to_ptr::<u8>(v);\n         let nout = os::libc::fwrite(vbuf, len, 1u, f);\n         if nout < 1u { log_err \"error dumping buffer\"; }\n     }\n@@ -255,7 +256,7 @@ obj fd_buf_writer(fd: int, res: option::t<@fd_res>) {\n         let count = 0u;\n         let vbuf;\n         while count < len {\n-            vbuf = ptr::offset(vec::to_ptr::<u8>(v), count);\n+            vbuf = ptr::offset(vec::unsafe::to_ptr::<u8>(v), count);\n             let nout = os::libc::write(fd, vbuf, len);\n             if nout < 0 {\n                 log_err \"error dumping buffer\";"}, {"sha": "6d6940db872f1bca6779e5518fa708fa80e59405", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -27,7 +27,8 @@ fn spawn_process(prog: &istr, args: &[istr], in_fd: int, out_fd: int,\n     // pointer to its buffer\n     let argv = arg_vec(prog, args);\n     let pid =\n-        rustrt::rust_run_program(vec::to_ptr(argv), in_fd, out_fd, err_fd);\n+        rustrt::rust_run_program(vec::unsafe::to_ptr(argv),\n+                                 in_fd, out_fd, err_fd);\n     ret pid;\n }\n "}, {"sha": "54739e4188d7b0695a9a3ad71070e7350ada91f6", "filename": "src/lib/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -60,7 +60,7 @@ native \"rust\" mod rustrt {\n     fn str_buf(s: str) -> sbuf;\n     fn str_byte_len(s: str) -> uint;\n     fn str_alloc(n_bytes: uint) -> str;\n-    fn str_from_ivec(b: &[mutable? u8]) -> str;\n+    fn str_from_vec(b: &[mutable? u8]) -> str;\n     fn str_from_cstr(cstr: sbuf) -> str;\n     fn str_from_buf(buf: sbuf, len: uint) -> str;\n     fn str_push_byte(s: str, byte: uint) -> str;\n@@ -187,10 +187,10 @@ fn bytes(s: str) -> [u8] {\n }\n \n fn unsafe_from_bytes(v: &[mutable? u8]) -> str {\n-    ret rustrt::str_from_ivec(v);\n+    ret rustrt::str_from_vec(v);\n }\n \n-fn unsafe_from_byte(u: u8) -> str { ret rustrt::str_from_ivec([u]); }\n+fn unsafe_from_byte(u: u8) -> str { ret rustrt::str_from_vec([u]); }\n \n fn str_from_cstr(cstr: sbuf) -> str { ret rustrt::str_from_cstr(cstr); }\n "}, {"sha": "28c347cd2c8a8cb64dc1cbdacd83aaa256ffbf0d", "filename": "src/lib/vec.rs", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -6,27 +6,20 @@ import uint::next_power_of_two;\n import ptr::addr_of;\n \n native \"rust-intrinsic\" mod rusti {\n-    fn ivec_len<T>(v: &[T]) -> uint;\n+    fn vec_len<T>(v: &[T]) -> uint;\n }\n \n native \"rust\" mod rustrt {\n-    fn ivec_reserve_shared<T>(v: &mutable [mutable? T], n: uint);\n-    fn ivec_on_heap<T>(v: &[T]) -> uint;\n-    fn ivec_to_ptr<T>(v: &[T]) -> *T;\n-    fn ivec_copy_from_buf_shared<T>(v: &mutable [mutable? T], ptr: *T,\n-                                    count: uint);\n+    fn vec_reserve_shared<T>(v: &mutable [mutable? T], n: uint);\n+    fn vec_from_buf_shared<T>(ptr: *T, count: uint) -> [T];\n }\n \n /// Reserves space for `n` elements in the given vector.\n fn reserve<@T>(v: &mutable [mutable? T], n: uint) {\n-    rustrt::ivec_reserve_shared(v, n);\n+    rustrt::vec_reserve_shared(v, n);\n }\n \n-fn on_heap<T>(v: &[T]) -> bool { ret rustrt::ivec_on_heap(v) != 0u; }\n-\n-fn to_ptr<T>(v: &[T]) -> *T { ret rustrt::ivec_to_ptr(v); }\n-\n-fn len<T>(v: &[mutable? T]) -> uint { ret rusti::ivec_len(v); }\n+fn len<T>(v: &[mutable? T]) -> uint { ret rusti::vec_len(v); }\n \n type init_op<T> = fn(uint) -> T;\n \n@@ -310,32 +303,27 @@ iter iter2<@T>(v: &[T]) -> (uint, T) {\n }\n \n mod unsafe {\n-    type ivec_repr =\n-        {mutable fill: uint,\n-         mutable alloc: uint,\n-         heap_part: *mutable ivec_heap_part};\n-    type ivec_heap_part = {mutable fill: uint};\n-\n-    fn copy_from_buf<T>(v: &mutable [T], ptr: *T, count: uint) {\n-        ret rustrt::ivec_copy_from_buf_shared(v, ptr, count);\n-    }\n+    type ivec_repr = {mutable fill: uint,\n+                      mutable alloc: uint,\n+                      data: u8};\n \n-    fn from_buf<T>(ptr: *T, bytes: uint) -> [T] {\n-        let v = [];\n-        copy_from_buf(v, ptr, bytes);\n-        ret v;\n+    fn from_buf<T>(ptr: *T, elts: uint) -> [T] {\n+        ret rustrt::vec_from_buf_shared(ptr, elts);\n     }\n \n     fn set_len<T>(v: &mutable [T], new_len: uint) {\n-        let new_fill = new_len * sys::size_of::<T>();\n-        let stack_part: *mutable ivec_repr =\n-            ::unsafe::reinterpret_cast(addr_of(v));\n-        if (*stack_part).fill == 0u {\n-            (*(*stack_part).heap_part).fill = new_fill; // On heap.\n-        } else {\n-            (*stack_part).fill = new_fill; // On stack.\n-        }\n+        let repr: **ivec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        (**repr).fill = new_len * sys::size_of::<T>();\n     }\n+\n+    fn to_ptr<T>(v: &[T]) -> *T {\n+        let repr: **ivec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n+        ret ::unsafe::reinterpret_cast(addr_of((**repr).data));\n+    }\n+}\n+\n+fn to_ptr<T>(v: &[T]) -> *T {\n+    ret unsafe::to_ptr(v);\n }\n \n // Local Variables:"}, {"sha": "bbe0fc811dd3ccd5317a0b2156ec4c5bc4eb1d06", "filename": "src/rt/intrinsics/intrinsics.cpp", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.cpp?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -9,17 +9,10 @@ extern \"C\" CDECL void\n upcall_fail(rust_task *task, char const *expr, char const *file, size_t line);\n \n extern \"C\" void\n-rust_intrinsic_ivec_len(rust_task *task, size_t *retptr, type_desc *ty,\n-                        rust_ivec *v)\n+rust_intrinsic_vec_len(rust_task *task, size_t *retptr, type_desc *ty,\n+                       rust_vec **vp)\n {\n-    size_t fill;\n-    if (v->fill)\n-        fill = v->fill;\n-    else if (v->payload.ptr)\n-        fill = v->payload.ptr->fill;\n-    else\n-        fill = 0;\n-    *retptr = fill / ty->size;\n+    *retptr = (*vp)->fill / ty->size;\n }\n \n extern \"C\" void"}, {"sha": "872cec7fa214e133fb1aaec2fa2ccfbed0fbf2bf", "filename": "src/rt/intrinsics/intrinsics.ll.in", "status": "modified", "additions": 5, "deletions": 22, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Fintrinsics%2Fintrinsics.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Fintrinsics%2Fintrinsics.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.ll.in?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -40,9 +40,7 @@ target triple = \"@CFG_LLVM_TRIPLE@\"\n %struct.registers_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32 }\n %\"class.rust_task::wakeup_callback\" = type { i32 (...)** }\n %struct.rc_base.5 = type { i32 }\n-%struct.rust_ivec = type { i32, i32, %union.rust_ivec_payload }\n-%union.rust_ivec_payload = type { %struct.rust_ivec_heap* }\n-%struct.rust_ivec_heap = type { i32, [0 x i8] }\n+%struct.rust_vec = type { i32, i32, [ 0 x i8 ] }\n %class.rust_port = type { i32, %class.rust_kernel*, %struct.rust_task*, i32, %class.ptr_vec, %class.ptr_vec.7, %class.rust_chan*, %class.lock_and_signal }\n %class.ptr_vec = type { %struct.rust_task*, i32, i32, %struct.rust_token** }\n %struct.rust_token = type opaque\n@@ -53,29 +51,14 @@ target triple = \"@CFG_LLVM_TRIPLE@\"\n @.str = private unnamed_addr constant [42 x i8] c\"attempt to cast values of differing sizes\\00\", align 1\n @.str1 = private unnamed_addr constant [15 x i8] c\"intrinsics.cpp\\00\", align 1\n \n-define linkonce_odr void @rust_intrinsic_ivec_len(%struct.rust_task* nocapture %task, i32* nocapture %retptr, %struct.type_desc* nocapture %ty, %struct.rust_ivec* nocapture %v) nounwind {\n+define linkonce_odr void @rust_intrinsic_vec_len(%struct.rust_task* nocapture %task, i32* nocapture %retptr, %struct.type_desc* nocapture %ty, %struct.rust_vec** nocapture %v) nounwind {\n entry:\n-  %fill1 = getelementptr inbounds %struct.rust_ivec* %v, i32 0, i32 0\n+  %ptr1 = load %struct.rust_vec** %v, align 4, !tbaa !0\n+  %fill1 = getelementptr inbounds %struct.rust_vec* %ptr1, i32 0, i32 0\n   %tmp2 = load i32* %fill1, align 4, !tbaa !0\n-  %tobool = icmp eq i32 %tmp2, 0\n-  br i1 %tobool, label %if.else, label %if.end17\n-\n-if.else:                                          ; preds = %entry\n-  %ptr = getelementptr inbounds %struct.rust_ivec* %v, i32 0, i32 2, i32 0\n-  %tmp7 = load %struct.rust_ivec_heap** %ptr, align 4, !tbaa !3\n-  %tobool8 = icmp eq %struct.rust_ivec_heap* %tmp7, null\n-  br i1 %tobool8, label %if.end17, label %if.then9\n-\n-if.then9:                                         ; preds = %if.else\n-  %fill14 = getelementptr inbounds %struct.rust_ivec_heap* %tmp7, i32 0, i32 0\n-  %tmp15 = load i32* %fill14, align 4, !tbaa !0\n-  br label %if.end17\n-\n-if.end17:                                         ; preds = %if.else, %entry, %if.then9\n-  %fill.0 = phi i32 [ %tmp15, %if.then9 ], [ %tmp2, %entry ], [ 0, %if.else ]\n   %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n   %tmp20 = load i32* %size, align 4, !tbaa !0\n-  %div = udiv i32 %fill.0, %tmp20\n+  %div = udiv i32 %tmp2, %tmp20\n   store i32 %div, i32* %retptr, align 4, !tbaa !0\n   ret void\n }"}, {"sha": "6df51e6750386720f12c8d07460024a5ef7fcfbe", "filename": "src/rt/main.ll.in", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Fmain.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Fmain.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmain.ll.in?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -10,21 +10,21 @@\n \n %task = type { i32, i32, i32, i32, i32, i32, i32, i32 }\n \n-%ivec = type { i32, i32, [4 x { i32, i32, i32, i32, [0 x i8] }*] }\n+%vec = type { i32, i32, [0 x i8] }\n \n @_rust_crate_map_toplevel = external global %0\n \n declare i32 @rust_start(i32, i32, i32, i32)\n \n-declare external fastcc void @_rust_main(i1* nocapture, %task*, %2* nocapture, %ivec*)\n+declare external fastcc void @_rust_main(i1* nocapture, %task*, %2* nocapture, %vec*)\n \n-define void @_rust_main_wrap(i1* nocapture, %task *, %2* nocapture, %ivec *)\n+define void @_rust_main_wrap(i1* nocapture, %task *, %2* nocapture, %vec *)\n {\n-  tail call fastcc void @_rust_main(i1* %0, %task *%1, %2* nocapture %2, %ivec* %3)\n+  tail call fastcc void @_rust_main(i1* %0, %task *%1, %2* nocapture %2, %vec* %3)\n   ret void\n }\n \n define i32 @\"MAIN\"(i32, i32) {\n-  %3 = tail call i32 @rust_start(i32 ptrtoint (void (i1*, %task*, %2*, %ivec*)* @_rust_main_wrap to i32), i32 %0, i32 %1, i32 ptrtoint (%0* @_rust_crate_map_toplevel to i32))\n+  %3 = tail call i32 @rust_start(i32 ptrtoint (void (i1*, %task*, %2*, %vec*)* @_rust_main_wrap to i32), i32 %0, i32 %1, i32 ptrtoint (%0* @_rust_crate_map_toplevel to i32))\n   ret i32 %3\n }"}, {"sha": "b5a462154edae916d49d9066a68c32667444c723", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -10,7 +10,7 @@ command_line_args : public kernel_owned<command_line_args>\n     rust_str **strs;\n \n     // [str] passed to rust_task::start.\n-    rust_ivec *args;\n+    rust_vec *args;\n \n     command_line_args(rust_task *task,\n                       int sys_argc,\n@@ -51,21 +51,13 @@ command_line_args : public kernel_owned<command_line_args>\n             strs[i]->ref_count++;\n         }\n \n-        size_t ivec_interior_sz =\n-            sizeof(size_t) * 2 + sizeof(rust_str *) * 4;\n-        args = (rust_ivec *)\n-            kernel->malloc(ivec_interior_sz,\n+        args = (rust_vec *)\n+            kernel->malloc(vec_size<rust_str*>(argc),\n                            \"command line arg interior\");\n-        args->fill = 0;\n-        size_t ivec_exterior_sz = sizeof(rust_str *) * argc;\n-        args->alloc = ivec_exterior_sz;\n-        // NB: _rust_main owns the ivec payload and will be responsible for\n+        args->fill = args->alloc = sizeof(rust_str *) * argc;\n+        // NB: _rust_main owns the vec and will be responsible for\n         // freeing it\n-        args->payload.ptr = (rust_ivec_heap *)\n-            kernel->malloc(ivec_exterior_sz + sizeof(size_t),\n-                           \"command line arg exterior\");\n-        args->payload.ptr->fill = ivec_exterior_sz;\n-        memcpy(&args->payload.ptr->data, strs, ivec_exterior_sz);\n+        memcpy(&args->data[0], strs, args->fill);\n     }\n \n     ~command_line_args() {"}, {"sha": "a8929677aff91e7ed9b9adb32f39cb5b478f4d88", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 45, "deletions": 177, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -206,18 +206,14 @@ str_byte_len(rust_task *task, rust_str *s)\n }\n \n extern \"C\" CDECL rust_str *\n-str_from_ivec(rust_task *task, rust_ivec *v)\n+str_from_vec(rust_task *task, rust_vec **vp)\n {\n-    bool is_interior = v->fill || !v->payload.ptr;\n-    uintptr_t fill = is_interior ? v->fill : v->payload.ptr->fill;\n-    void *data = is_interior ? v->payload.data : v->payload.ptr->data;\n-\n-    rust_str *st =\n-        vec_alloc_with_data(task,\n-                            fill + 1,   // +1 to fit at least '\\0'\n-                            fill,\n-                            1,\n-                            fill ? data : NULL);\n+    rust_vec* v = *vp;\n+    rust_str *st = vec_alloc_with_data(task,\n+                                       v->fill + 1, // +1 for \\0\n+                                       v->fill,\n+                                       1,\n+                                       &v->data[0]);\n     if (!st) {\n         task->fail();\n         return NULL;\n@@ -226,6 +222,33 @@ str_from_ivec(rust_task *task, rust_ivec *v)\n     return st;\n }\n \n+extern \"C\" CDECL void\n+vec_reserve_shared(rust_task* task, type_desc* ty, rust_vec** vp,\n+                    size_t n_elts) {\n+    size_t new_sz = n_elts * ty->size;\n+    if (new_sz > (*vp)->alloc) {\n+        size_t new_alloc = next_power_of_two(new_sz);\n+        *vp = (rust_vec*)task->kernel->realloc(*vp, new_alloc +\n+                                                sizeof(rust_vec));\n+        (*vp)->alloc = new_alloc;\n+    }\n+}\n+\n+/**\n+ * Copies elements in an unsafe buffer to the given interior vector. The\n+ * vector must have size zero.\n+ */\n+extern \"C\" CDECL rust_vec*\n+vec_from_buf_shared(rust_task *task, type_desc *ty,\n+                     void *ptr, size_t count) {\n+    size_t fill = ty->size * count;\n+    rust_vec* v = (rust_vec*)task->kernel->malloc(fill + sizeof(rust_vec),\n+                                                    \"vec_from_buf\");\n+    v->fill = v->alloc = fill;\n+    memmove(&v->data[0], ptr, fill);\n+    return v;\n+}\n+\n extern \"C\" CDECL rust_str *\n str_from_cstr(rust_task *task, char *sbuf)\n {\n@@ -471,23 +494,19 @@ rust_list_files(rust_task *task, rust_str *path) {\n       closedir(dirp);\n   }\n #endif\n-  size_t str_ivec_sz =\n-      sizeof(size_t)            // fill\n-      + sizeof(size_t)          // alloc\n-      + sizeof(rust_str *) * 4; // payload\n-  rust_box *box = (rust_box *)task->malloc(sizeof(rust_box) + str_ivec_sz,\n-                                           \"rust_box(list_files_ivec)\");\n+  rust_box *box =\n+      (rust_box *)task->malloc(sizeof(rust_box) + sizeof(rust_vec*),\n+                               \"rust_box(list_files_vec)\");\n+  rust_vec* vec =\n+      (rust_vec*)task->kernel->malloc(vec_size<rust_str*>(strings.size()),\n+                                       \"list_files_vec\");\n \n   box->ref_count = 1;\n-  rust_ivec *iv = (rust_ivec *)&box->data;\n-  iv->fill = 0;\n-\n-  size_t alloc_sz = sizeof(rust_str *) * strings.size();\n-  iv->alloc = alloc_sz;\n-  iv->payload.ptr = (rust_ivec_heap *)\n-      task->kernel->malloc(alloc_sz + sizeof(size_t), \"files ivec\");\n-  iv->payload.ptr->fill = alloc_sz;\n-  memcpy(&iv->payload.ptr->data, strings.data(), alloc_sz);\n+  rust_vec** box_content = (rust_vec**)&box->data[0];\n+  *box_content = vec;\n+  size_t alloc_sz = sizeof(rust_str*) * strings.size();\n+  vec->fill = vec->alloc = alloc_sz;\n+  memcpy(&vec->data[0], strings.data(), alloc_sz);\n   return box;\n }\n \n@@ -549,157 +568,6 @@ nano_time(rust_task *task, uint64_t *ns) {\n     *ns = t.time_ns();\n }\n \n-/**\n- * Preallocates the exact number of bytes in the given interior vector.\n- */\n-extern \"C\" CDECL void\n-ivec_reserve(rust_task *task, type_desc *ty, rust_ivec *v, size_t n_elems)\n-{\n-    size_t new_alloc = n_elems * ty->size;\n-    if (new_alloc <= v->alloc)\n-        return;     // Already big enough.\n-\n-    rust_ivec_heap *heap_part;\n-    if (v->fill || !v->payload.ptr) {\n-        // On stack; spill to heap.\n-        heap_part = (rust_ivec_heap *)task->malloc(new_alloc +\n-                                                   sizeof(size_t),\n-                                                   \"ivec reserve heap part\");\n-        heap_part->fill = v->fill;\n-        memcpy(&heap_part->data, v->payload.data, v->fill);\n-\n-        v->fill = 0;\n-        v->payload.ptr = heap_part;\n-    } else {\n-        // On heap; resize.\n-        heap_part = (rust_ivec_heap *)\n-            task->realloc(v->payload.ptr,\n-                          new_alloc + sizeof(size_t));\n-        v->payload.ptr = heap_part;\n-    }\n-\n-    v->alloc = new_alloc;\n-}\n-\n-/**\n- * Preallocates the exact number of bytes in the given interior vector.\n- */\n-extern \"C\" CDECL void\n-ivec_reserve_shared(rust_task *task, type_desc *ty, rust_ivec *v,\n-                    size_t n_elems)\n-{\n-    size_t new_alloc = n_elems * ty->size;\n-    if (new_alloc <= v->alloc)\n-        return;     // Already big enough.\n-\n-    rust_ivec_heap *heap_part;\n-    if (v->fill || !v->payload.ptr) {\n-        // On stack; spill to heap.\n-        heap_part = (rust_ivec_heap *)\n-            task->kernel->malloc(new_alloc + sizeof(size_t),\n-                                 \"ivec reserve shared\");\n-        heap_part->fill = v->fill;\n-        memcpy(&heap_part->data, v->payload.data, v->fill);\n-\n-        v->fill = 0;\n-        v->payload.ptr = heap_part;\n-    } else {\n-        // On heap; resize.\n-        heap_part = (rust_ivec_heap *)task->kernel->realloc(v->payload.ptr,\n-                                                new_alloc + sizeof(size_t));\n-        v->payload.ptr = heap_part;\n-    }\n-\n-    v->alloc = new_alloc;\n-}\n-\n-/**\n- * Returns true if the given vector is on the heap and false if it's on the\n- * stack.\n- */\n-extern \"C\" CDECL bool\n-ivec_on_heap(rust_task *task, type_desc *ty, rust_ivec *v)\n-{\n-    return !v->fill && v->payload.ptr;\n-}\n-\n-/**\n- * Returns an unsafe pointer to the data part of an interior vector.\n- */\n-extern \"C\" CDECL void *\n-ivec_to_ptr(rust_task *task, type_desc *ty, rust_ivec *v)\n-{\n-    return v->fill ? v->payload.data : v->payload.ptr->data;\n-}\n-\n-static size_t\n-get_ivec_size(rust_ivec *v)\n-{\n-    if (v->fill)\n-        return v->fill;\n-    if (v->payload.ptr)\n-        return v->payload.ptr->fill;\n-    return 0;\n-}\n-\n-/**\n- * Copies elements in an unsafe buffer to the given interior vector. The\n- * vector must have size zero.\n- */\n-extern \"C\" CDECL void\n-ivec_copy_from_buf(rust_task *task, type_desc *ty, rust_ivec *v, void *ptr,\n-                   size_t count)\n-{\n-    size_t old_size = get_ivec_size(v);\n-    if (old_size) {\n-        task->fail();\n-        return;\n-    }\n-\n-    ivec_reserve(task, ty, v, count);\n-\n-    size_t new_size = count * ty->size;\n-    if (v->fill || !v->payload.ptr) {\n-        // On stack.\n-        memmove(v->payload.data, ptr, new_size);\n-        v->fill = new_size;\n-        return;\n-    }\n-\n-    // On heap.\n-    memmove(v->payload.ptr->data, ptr, new_size);\n-    v->payload.ptr->fill = new_size;\n-}\n-\n-/**\n- * Copies elements in an unsafe buffer to the given interior vector. The\n- * vector must have size zero.\n- */\n-extern \"C\" CDECL void\n-ivec_copy_from_buf_shared(rust_task *task, type_desc *ty, rust_ivec *v,\n-                   void *ptr, size_t count)\n-{\n-    size_t old_size = get_ivec_size(v);\n-    if (old_size) {\n-        task->fail();\n-        return;\n-    }\n-\n-    ivec_reserve_shared(task, ty, v, count);\n-\n-    size_t new_size = count * ty->size;\n-    if (v->fill || !v->payload.ptr) {\n-        // On stack.\n-        memmove(v->payload.data, ptr, new_size);\n-        v->fill = new_size;\n-        return;\n-    }\n-\n-    // On heap.\n-    memmove(v->payload.ptr->data, ptr, new_size);\n-    v->payload.ptr->fill = new_size;\n-}\n-\n extern \"C\" CDECL void\n pin_task(rust_task *task) {\n     task->pin();"}, {"sha": "c08663bface24f1d5fdc20c6e87c61aeec317f8c", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -226,17 +226,6 @@ size_of::walk_struct(bool align, const uint8_t *end_sp) {\n     sa = struct_sa;\n }\n \n-void\n-size_of::walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n-    if (!elem_sa.is_set())\n-        walk(align);    // Determine the size the slow way.\n-    else\n-        sa = elem_sa;   // Use the size hint.\n-\n-    sa.set(sizeof(rust_ivec) - sizeof(uintptr_t) + sa.size * 4,\n-           max(sa.alignment, sizeof(uintptr_t)));\n-}\n-\n \n // Copy constructors\n \n@@ -321,8 +310,8 @@ class cmp : public data<cmp,ptr_pair> {\n         walk_vec(align, is_pod, get_evec_data_range(dp));\n     }\n \n-    void walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n-        walk_vec(align, is_pod, get_ivec_data_range(dp));\n+    void walk_vec(bool align, bool is_pod, uint16_t sp_size) {\n+        walk_vec(align, is_pod, get_vec_data_range(dp));\n     }\n \n     void walk_box(bool align) {"}, {"sha": "2ce4fcb56454dcf67a19325ddd1e32a08f4862e2", "filename": "src/rt/rust_shape.h", "status": "modified", "additions": 25, "deletions": 60, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frust_shape.h", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frust_shape.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.h?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -37,7 +37,7 @@ const uint8_t SHAPE_I64 = 7u;\n const uint8_t SHAPE_F32 = 8u;\n const uint8_t SHAPE_F64 = 9u;\n const uint8_t SHAPE_EVEC = 10u;\n-const uint8_t SHAPE_IVEC = 11u;\n+const uint8_t SHAPE_VEC = 11u;\n const uint8_t SHAPE_TAG = 12u;\n const uint8_t SHAPE_BOX = 13u;\n const uint8_t SHAPE_STRUCT = 17u;\n@@ -192,7 +192,7 @@ class ctxt {\n \n private:\n     void walk_evec(bool align);\n-    void walk_ivec(bool align);\n+    void walk_vec(bool align);\n     void walk_tag(bool align);\n     void walk_box(bool align);\n     void walk_struct(bool align);\n@@ -278,6 +278,7 @@ class type_param {\n template<typename T>\n void\n ctxt<T>::walk(bool align) {\n+  \n     switch (*sp++) {\n     case SHAPE_U8:      WALK_NUMBER(uint8_t);   break;\n     case SHAPE_U16:     WALK_NUMBER(uint16_t);  break;\n@@ -290,7 +291,7 @@ ctxt<T>::walk(bool align) {\n     case SHAPE_F32:     WALK_NUMBER(float);     break;\n     case SHAPE_F64:     WALK_NUMBER(double);    break;\n     case SHAPE_EVEC:    walk_evec(align);       break;\n-    case SHAPE_IVEC:    walk_ivec(align);       break;\n+    case SHAPE_VEC:     walk_vec(align);        break;\n     case SHAPE_TAG:     walk_tag(align);        break;\n     case SHAPE_BOX:     walk_box(align);        break;\n     case SHAPE_STRUCT:  walk_struct(align);     break;\n@@ -347,18 +348,13 @@ ctxt<T>::walk_evec(bool align) {\n \n template<typename T>\n void\n-ctxt<T>::walk_ivec(bool align) {\n+ctxt<T>::walk_vec(bool align) {\n     bool is_pod = *sp++;\n-    size_align elem_sa = get_size_align(sp);\n \n     uint16_t sp_size = get_u16_bump(sp);\n     const uint8_t *end_sp = sp + sp_size;\n \n-    // FIXME: Hack to work around our incorrect alignment in some cases.\n-    if (elem_sa.alignment == 8)\n-        elem_sa.alignment = 4;\n-\n-    static_cast<T *>(this)->walk_ivec(align, is_pod, elem_sa);\n+    static_cast<T *>(this)->walk_vec(align, is_pod, sp_size);\n \n     sp = end_sp;\n }\n@@ -471,8 +467,8 @@ class print : public ctxt<print> {\n     void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n         DPRINT(\"evec<\"); walk(align); DPRINT(\">\");\n     }\n-    void walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n-        DPRINT(\"ivec<\"); walk(align); DPRINT(\">\");\n+    void walk_vec(bool align, bool is_pod, uint16_t sp_size) {\n+        DPRINT(\"vec<\"); walk(align); DPRINT(\">\");\n     }\n     void walk_box(bool align) {\n         DPRINT(\"box<\"); walk(align); DPRINT(\">\");\n@@ -522,7 +518,6 @@ class size_of : public ctxt<size_of> {\n \n     void walk_tag(bool align, tag_info &tinfo);\n     void walk_struct(bool align, const uint8_t *end_sp);\n-    void walk_ivec(bool align, bool is_pod, size_align &elem_sa);\n \n     void walk_box(bool align)   { sa.set(sizeof(void *),   sizeof(void *)); }\n     void walk_port(bool align)  { sa.set(sizeof(void *),   sizeof(void *)); }\n@@ -534,6 +529,9 @@ class size_of : public ctxt<size_of> {\n     void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n         sa.set(sizeof(void *), sizeof(void *));\n     }\n+    void walk_vec(bool align, bool is_pod, uint16_t sp_size) {\n+        sa.set(sizeof(void*), sizeof(void*));\n+    }\n \n     void walk_var(bool align, uint8_t param_index) {\n         const type_param *param = &params[param_index];\n@@ -725,9 +723,9 @@ class data : public ctxt< data<T,U> > {\n     void walk_variant(bool align, tag_info &tinfo, uint32_t variant);\n \n     static std::pair<uint8_t *,uint8_t *> get_evec_data_range(ptr dp);\n-    static std::pair<uint8_t *,uint8_t *> get_ivec_data_range(ptr dp);\n+    static std::pair<uint8_t *,uint8_t *> get_vec_data_range(ptr dp);\n     static std::pair<ptr_pair,ptr_pair> get_evec_data_range(ptr_pair &dp);\n-    static std::pair<ptr_pair,ptr_pair> get_ivec_data_range(ptr_pair &dp);\n+    static std::pair<ptr_pair,ptr_pair> get_vec_data_range(ptr_pair &dp);\n \n public:\n     U dp;\n@@ -740,7 +738,6 @@ class data : public ctxt< data<T,U> > {\n     : ctxt< data<T,U> >(in_task, in_sp, in_params, in_tables), dp(in_dp) {}\n \n     void walk_tag(bool align, tag_info &tinfo);\n-    void walk_ivec(bool align, bool is_pod, size_align &elem_sa);\n \n     void walk_struct(bool align, const uint8_t *end_sp) {\n         static_cast<T *>(this)->walk_struct(align, end_sp);\n@@ -749,6 +746,9 @@ class data : public ctxt< data<T,U> > {\n     void walk_evec(bool align, bool is_pod, uint16_t sp_size) {\n         DATA_SIMPLE(void *, walk_evec(align, is_pod, sp_size));\n     }\n+    void walk_vec(bool align, bool is_pod, uint16_t sp_size) {\n+        DATA_SIMPLE(void *, walk_vec(align, is_pod, sp_size));\n+    }\n \n     void walk_box(bool align)   { DATA_SIMPLE(void *, walk_box(align)); }\n     void walk_port(bool align)  { DATA_SIMPLE(void *, walk_port(align)); }\n@@ -815,27 +815,10 @@ data<T,U>::get_evec_data_range(ptr dp) {\n \n template<typename T,typename U>\n std::pair<uint8_t *,uint8_t *>\n-data<T,U>::get_ivec_data_range(ptr dp) {\n-    size_t fill = bump_dp<size_t>(dp);\n-    bump_dp<size_t>(dp);    // Skip over alloc.\n-    uint8_t *payload_dp = dp;\n-    rust_ivec_payload payload = bump_dp<rust_ivec_payload>(dp);\n-\n-    uint8_t *start, *end;\n-    if (!fill) {\n-        if (!payload.ptr) {             // Zero length.\n-            start = end = NULL;\n-        } else {                        // On heap.\n-            fill = payload.ptr->fill;\n-            start = payload.ptr->data;\n-            end = start + fill;\n-        }\n-    } else {                            // On stack.\n-        start = payload_dp;\n-        end = start + fill;\n-    }\n-\n-    return std::make_pair(start, end);\n+data<T,U>::get_vec_data_range(ptr dp) {\n+    rust_vec* ptr = bump_dp<rust_vec*>(dp);\n+    uint8_t* data = &ptr->data[0];\n+    return std::make_pair(data, data + ptr->fill);\n }\n \n template<typename T,typename U>\n@@ -850,32 +833,14 @@ data<T,U>::get_evec_data_range(ptr_pair &dp) {\n \n template<typename T,typename U>\n std::pair<ptr_pair,ptr_pair>\n-data<T,U>::get_ivec_data_range(ptr_pair &dp) {\n-    std::pair<uint8_t *,uint8_t *> fst = get_ivec_data_range(dp.fst);\n-    std::pair<uint8_t *,uint8_t *> snd = get_ivec_data_range(dp.snd);\n+data<T,U>::get_vec_data_range(ptr_pair &dp) {\n+    std::pair<uint8_t *,uint8_t *> fst = get_vec_data_range(dp.fst);\n+    std::pair<uint8_t *,uint8_t *> snd = get_vec_data_range(dp.snd);\n     ptr_pair start(fst.first, snd.first);\n     ptr_pair end(fst.second, snd.second);\n     return std::make_pair(start, end);\n }\n \n-template<typename T,typename U>\n-void\n-data<T,U>::walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n-    if (!elem_sa.is_set())\n-        elem_sa = size_of::get(*this);\n-    else if (elem_sa.alignment == 8)\n-        elem_sa.alignment = 4;  // FIXME: This is an awful hack.\n-\n-    // Get a pointer to the interior vector, and determine its size.\n-    if (align) dp = align_to(dp, ALIGNOF(rust_ivec *));\n-    U end_dp = dp + sizeof(rust_ivec) - sizeof(uintptr_t) + elem_sa.size * 4;\n-\n-    // Call to the implementation.\n-    static_cast<T *>(this)->walk_ivec(align, is_pod, elem_sa);\n-\n-    dp = end_dp;\n-}\n-\n template<typename T,typename U>\n void\n data<T,U>::walk_tag(bool align, tag_info &tinfo) {\n@@ -978,8 +943,8 @@ class log : public data<log,ptr> {\n         walk_vec(align, is_pod, get_evec_data_range(dp));\n     }\n \n-    void walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n-        walk_vec(align, is_pod, get_ivec_data_range(dp));\n+    void walk_vec(bool align, bool is_pod, uint16_t sp_size) {\n+        walk_vec(align, is_pod, get_vec_data_range(dp));\n     }\n \n     void walk_tag(bool align, tag_info &tinfo, uint32_t tag_variant) {"}, {"sha": "c94e993e7e63c49b8b79cac4ba46440d186bb732", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 19, "deletions": 65, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -61,16 +61,6 @@ upcall_log_str(rust_task *task, uint32_t level, rust_str *str) {\n     }\n }\n \n-extern \"C\" CDECL void\n-upcall_log_istr(rust_task *task, uint32_t level, rust_ivec *str) {\n-    LOG_UPCALL_ENTRY(task);\n-    if (task->sched->log_lvl < level)\n-        return;\n-    const char *buf = (const char *)\n-        (str->fill ? str->payload.data : str->payload.ptr->data);\n-    task->sched->log(task, level, \"rust: %s\", buf);\n-}\n-\n extern \"C\" CDECL void\n upcall_yield(rust_task *task) {\n     LOG_UPCALL_ENTRY(task);\n@@ -354,69 +344,33 @@ upcall_get_type_desc(rust_task *task,\n     return td;\n }\n \n-/**\n- * Resizes an interior vector that has been spilled to the heap.\n- */\n extern \"C\" CDECL void\n-upcall_ivec_resize_shared(rust_task *task,\n-                          rust_ivec *v,\n-                          size_t newsz) {\n+upcall_vec_grow(rust_task* task, rust_vec** vp, size_t new_sz) {\n     LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->sched->lock);\n-    I(task->sched, !v->fill);\n-\n-    size_t new_alloc = next_power_of_two(newsz);\n-    rust_ivec_heap *new_heap_part = (rust_ivec_heap *)\n-        task->kernel->realloc(v->payload.ptr, new_alloc + sizeof(size_t));\n-\n-    new_heap_part->fill = newsz;\n-    v->alloc = new_alloc;\n-    v->payload.ptr = new_heap_part;\n-}\n-\n-/**\n- * Spills an interior vector to the heap.\n- */\n-extern \"C\" CDECL void\n-upcall_ivec_spill_shared(rust_task *task,\n-                         rust_ivec *v,\n-                         size_t newsz) {\n-    LOG_UPCALL_ENTRY(task);\n-    scoped_lock with(task->sched->lock);\n-    size_t new_alloc = next_power_of_two(newsz);\n-\n-    rust_ivec_heap *heap_part = (rust_ivec_heap *)\n-        task->kernel->malloc(new_alloc + sizeof(size_t),\n-                             \"ivec spill shared\");\n-    heap_part->fill = newsz;\n-    memcpy(&heap_part->data, v->payload.data, v->fill);\n-\n-    v->fill = 0;\n-    v->alloc = new_alloc;\n-    v->payload.ptr = heap_part;\n+    // FIXME factor this into a utility function\n+    if (new_sz > (*vp)->alloc) {\n+        size_t new_alloc = next_power_of_two(new_sz);\n+        *vp = (rust_vec*)task->kernel->realloc(*vp, new_alloc +\n+                                                sizeof(rust_vec));\n+        (*vp)->alloc = new_alloc;\n+    }\n+    (*vp)->fill = new_sz;\n }\n \n extern \"C\" CDECL void\n-upcall_ivec_push(rust_task* task, rust_ivec* v, type_desc* elt_ty, void* x) {\n+upcall_vec_push(rust_task* task, rust_vec** vp, type_desc* elt_ty,\n+                 void* elt) {\n     LOG_UPCALL_ENTRY(task);\n-    bool is_interior = v->fill || !v->payload.ptr;\n-    size_t sz = elt_ty->size;\n-    size_t old_fill = is_interior ? v->fill : v->payload.ptr->fill;\n-    size_t new_sz = sz + old_fill;\n+    rust_vec* v = *vp;\n+    size_t new_sz = v->fill + elt_ty->size;\n     if (new_sz > v->alloc) {\n-        if (is_interior) {\n-            upcall_ivec_spill_shared(task, v, new_sz);\n-            is_interior = false;\n-        } else {\n-            upcall_ivec_resize_shared(task, v, new_sz);\n-        }\n-    } else {\n-        if (is_interior) v->fill = new_sz;\n-        else v->payload.ptr->fill = new_sz;\n+        size_t new_alloc = next_power_of_two(new_sz);\n+        *vp = v = (rust_vec*)task->kernel->realloc(v, new_alloc +\n+                                                    sizeof(rust_vec));\n+        v->alloc = new_alloc;\n     }\n-    uint8_t* dataptr = is_interior ? &v->payload.data[0]\n-                                   : &v->payload.ptr->data[0];\n-    copy_elements(task, elt_ty, dataptr + old_fill, x, sz);\n+    copy_elements(task, elt_ty, &v->data[0] + v->fill, elt, elt_ty->size);\n+    v->fill += elt_ty->size;\n }\n \n "}, {"sha": "10cdbce6109a0c9ee5cbf9e06ca903855eea7fa8", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -197,28 +197,18 @@ typedef rust_evec rust_str;\n // Interior vectors (rust-user-code level).\n \n struct\n-rust_ivec_heap\n-{\n-    size_t fill;\n-    uint8_t data[];\n-};\n-\n-// Note that the payload is actually size 4*sizeof(elem), even when heapified\n-union\n-rust_ivec_payload\n-{\n-    rust_ivec_heap *ptr;    // if on heap\n-    uint8_t data[];         // if on stack\n-};\n-\n-struct\n-rust_ivec\n+rust_vec\n {\n     size_t fill;    // in bytes; if zero, heapified\n     size_t alloc;   // in bytes\n-    rust_ivec_payload payload;\n+    uint8_t data[0];\n };\n \n+template <typename T>\n+inline size_t vec_size(size_t elems) {\n+    return sizeof(rust_vec) + sizeof(T) * elems;\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "add0e8da455cf547964595c589f1623347661a2b", "filename": "src/rt/rust_uv.cpp", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frust_uv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frust_uv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uv.cpp?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -113,12 +113,12 @@ static socket_data *make_socket(rust_task *task, rust_chan *chan) {\n static uv_buf_t alloc_buffer(uv_stream_t *socket, size_t suggested_size) {\n   LOG_CALLBACK_ENTRY(socket);\n   uv_buf_t buf;\n-  size_t actual_size = suggested_size + sizeof (rust_ivec_heap);\n+  size_t actual_size = suggested_size + sizeof (rust_vec);\n   socket_data *data = (socket_data*)socket->data;\n   char *base =\n     reinterpret_cast<char*>(data->task->kernel->malloc(actual_size,\n                                                        \"read buffer\"));\n-  buf.base = base + sizeof (rust_ivec_heap);\n+  buf.base = base + sizeof (rust_vec);\n   buf.len = suggested_size;\n   return buf;\n }\n@@ -129,26 +129,23 @@ static void read_progress(uv_stream_t *socket, ssize_t nread, uv_buf_t buf) {\n   I(data->task->sched, data->reader != NULL);\n   I(data->task->sched, nread <= ssize_t(buf.len));\n \n-  rust_ivec_heap *base = reinterpret_cast<rust_ivec_heap*>(\n-      reinterpret_cast<char*>(buf.base) - sizeof (rust_ivec_heap));\n-  rust_ivec v;\n-  v.fill = 0;\n-  v.alloc = buf.len;\n-  v.payload.ptr = base;\n+  rust_vec *v = reinterpret_cast<rust_vec*>(\n+      reinterpret_cast<char*>(buf.base) - sizeof (rust_vec));\n+  v->alloc = buf.len;\n \n   switch (nread) {\n     case -1: // End of stream\n-      base->fill = 0;\n+      v->fill = 0;\n       uv_read_stop(socket);\n       break;\n     case 0: // Nothing read\n-      data->task->kernel->free(base);\n+      data->task->kernel->free(v);\n       return;\n     default: // Got nread bytes\n-      base->fill = nread;\n+      v->fill = nread;\n       break;\n   }\n-  data->reader->send(&v);\n+  data->reader->send(v);\n }\n \n static void new_connection(uv_handle_t *socket, int status) {"}, {"sha": "3157b474b60cb8936e83816977a42d87b99480ab", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -30,12 +30,6 @@ get_task_pointer\n get_task_trampoline\n get_time\n hack_allow_leaks\n-ivec_copy_from_buf\n-ivec_copy_from_buf_shared\n-ivec_on_heap\n-ivec_reserve\n-ivec_reserve_shared\n-ivec_to_ptr\n last_os_error\n leak\n migrate_alloc\n@@ -70,7 +64,9 @@ str_buf\n str_byte_len\n str_from_buf\n str_from_cstr\n-str_from_ivec\n+str_from_vec\n+vec_reserve_shared\n+vec_from_buf_shared\n str_push_byte\n str_slice\n task_sleep\n@@ -86,14 +82,13 @@ upcall_fail\n upcall_free\n upcall_get_type_desc\n upcall_grow_task\n-upcall_ivec_resize_shared\n-upcall_ivec_spill_shared\n-upcall_ivec_push\n+upcall_vec_grow\n+upcall_vec_push\n upcall_kill\n upcall_log_double\n upcall_log_float\n upcall_log_int\n-upcall_log_istr\n+upcall_log_str\n upcall_log_str\n upcall_log_type\n upcall_malloc"}, {"sha": "956c97f23ecf9adb28fcdf9ef8ea6e66f89d6c24", "filename": "src/test/run-pass/interior-vec.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Ftest%2Frun-pass%2Finterior-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Ftest%2Frun-pass%2Finterior-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finterior-vec.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -1,28 +1,28 @@\n-import rusti::ivec_len;\n+import rusti::vec_len;\n \n native \"rust-intrinsic\" mod rusti {\n-    fn ivec_len<T>(v: &[T]) -> uint;\n+    fn vec_len<T>(v: &[T]) -> uint;\n }\n \n fn main() {\n     let v: [int] = [];\n-    assert (ivec_len(v) == 0u); // zero-length\n+    assert (vec_len(v) == 0u); // zero-length\n     let x = [1, 2];\n-    assert (ivec_len(x) == 2u); // on stack\n+    assert (vec_len(x) == 2u); // on stack\n     let y = [1, 2, 3, 4, 5];\n-    assert (ivec_len(y) == 5u); // on heap\n+    assert (vec_len(y) == 5u); // on heap\n \n     v += [];\n-    assert (ivec_len(v) == 0u); // zero-length append\n+    assert (vec_len(v) == 0u); // zero-length append\n     x += [3];\n-    assert (ivec_len(x) == 3u); // on-stack append\n+    assert (vec_len(x) == 3u); // on-stack append\n     y += [6, 7, 8, 9];\n-    assert (ivec_len(y) == 9u); // on-heap append\n+    assert (vec_len(y) == 9u); // on-heap append\n \n     let vv = v + v;\n-    assert (ivec_len(vv) == 0u); // zero-length add\n+    assert (vec_len(vv) == 0u); // zero-length add\n     let xx = x + [4];\n-    assert (ivec_len(xx) == 4u); // on-stack add\n+    assert (vec_len(xx) == 4u); // on-stack add\n     let yy = y + [10, 11];\n-    assert (ivec_len(yy) == 11u); // on-heap add\n+    assert (vec_len(yy) == 11u); // on-heap add\n }"}, {"sha": "2f9e691b62de3a71346b2a0f33afe6113e089271", "filename": "src/test/stdtest/vec.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c9c5ee252a8523778377f2832765442e611e85a4/src%2Ftest%2Fstdtest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9c5ee252a8523778377f2832765442e611e85a4/src%2Ftest%2Fstdtest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fvec.rs?ref=c9c5ee252a8523778377f2832765442e611e85a4", "patch": "@@ -18,21 +18,12 @@ fn square_if_odd(n: &uint) -> option::t<uint> {\n \n fn add(x: &uint, y: &uint) -> uint { ret x + y; }\n \n-#[test]\n-fn test_reserve_and_on_heap() {\n-    let v: [int] = [1, 2];\n-    assert (!vec::on_heap(v));\n-    vec::reserve(v, 8u);\n-    assert (vec::on_heap(v));\n-}\n-\n #[test]\n fn test_unsafe_ptrs() {\n     // Test on-stack copy-from-buf.\n     let a = [1, 2, 3];\n     let ptr = vec::to_ptr(a);\n-    let b = [];\n-    vec::unsafe::copy_from_buf(b, ptr, 3u);\n+    let b = vec::unsafe::from_buf(ptr, 3u);\n     assert (vec::len(b) == 3u);\n     assert (b[0] == 1);\n     assert (b[1] == 2);\n@@ -41,8 +32,7 @@ fn test_unsafe_ptrs() {\n     // Test on-heap copy-from-buf.\n     let c = [1, 2, 3, 4, 5];\n     ptr = vec::to_ptr(c);\n-    let d = [];\n-    vec::unsafe::copy_from_buf(d, ptr, 5u);\n+    let d = vec::unsafe::from_buf(ptr, 5u);\n     assert (vec::len(d) == 5u);\n     assert (d[0] == 1);\n     assert (d[1] == 2);"}]}