{"sha": "5407fbdef83b552ac5ee35c9577319c59d851467", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0MDdmYmRlZjgzYjU1MmFjNWVlMzVjOTU3NzMxOWM1OWQ4NTE0Njc=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-02-02T14:55:10Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-02-21T19:03:34Z"}, "message": "Match discriminant -> scrutinee", "tree": {"sha": "b689a7d9261fde475fe75d20d85e5cbbd41be82e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b689a7d9261fde475fe75d20d85e5cbbd41be82e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5407fbdef83b552ac5ee35c9577319c59d851467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5407fbdef83b552ac5ee35c9577319c59d851467", "html_url": "https://github.com/rust-lang/rust/commit/5407fbdef83b552ac5ee35c9577319c59d851467", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5407fbdef83b552ac5ee35c9577319c59d851467/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d51b5cdd82ec0e36212fc75b83652372980d56ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/d51b5cdd82ec0e36212fc75b83652372980d56ca", "html_url": "https://github.com/rust-lang/rust/commit/d51b5cdd82ec0e36212fc75b83652372980d56ca"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "07db67a6ae00ff738e23275ae507ec31ad1cac1d", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5407fbdef83b552ac5ee35c9577319c59d851467/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5407fbdef83b552ac5ee35c9577319c59d851467/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=5407fbdef83b552ac5ee35c9577319c59d851467", "patch": "@@ -53,8 +53,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Block { body: ast_block } => {\n                 this.ast_block(destination, block, ast_block, source_info)\n             }\n-            ExprKind::Match { discriminant, arms } => {\n-                this.match_expr(destination, expr_span, block, discriminant, arms)\n+            ExprKind::Match { scrutinee, arms } => {\n+                this.match_expr(destination, expr_span, block, scrutinee, arms)\n             }\n             ExprKind::NeverToAny { source } => {\n                 let source = this.hir.mirror(source);"}, {"sha": "ae1de50dabfdc531ffb509d7c11866267868ebc5", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5407fbdef83b552ac5ee35c9577319c59d851467/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5407fbdef83b552ac5ee35c9577319c59d851467/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=5407fbdef83b552ac5ee35c9577319c59d851467", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// ```text\n     /// [ 0. Pre-match ]\n     ///        |\n-    /// [ 1. Evaluate Scrutinee]\n+    /// [ 1. Evaluate Scrutinee (expression being matched on) ]\n     /// [ (fake read of scrutinee) ]\n     ///        |\n     /// [ 2. Decision tree -- check discriminants ] <--------+\n@@ -102,38 +102,38 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         destination: &Place<'tcx>,\n         span: Span,\n         mut block: BasicBlock,\n-        discriminant: ExprRef<'tcx>,\n+        scrutinee: ExprRef<'tcx>,\n         arms: Vec<Arm<'tcx>>,\n     ) -> BlockAnd<()> {\n         let tcx = self.hir.tcx();\n \n         // Step 1. Evaluate the scrutinee and add the fake read of it.\n \n-        let discriminant_span = discriminant.span();\n-        let discriminant_place = unpack!(block = self.as_place(block, discriminant));\n+        let scrutinee_span = scrutinee.span();\n+        let scrutinee_place = unpack!(block = self.as_place(block, scrutinee));\n \n-        // Matching on a `discriminant_place` with an uninhabited type doesn't\n+        // Matching on a `scrutinee_place` with an uninhabited type doesn't\n         // generate any memory reads by itself, and so if the place \"expression\"\n         // contains unsafe operations like raw pointer dereferences or union\n         // field projections, we wouldn't know to require an `unsafe` block\n         // around a `match` equivalent to `std::intrinsics::unreachable()`.\n         // See issue #47412 for this hole being discovered in the wild.\n         //\n         // HACK(eddyb) Work around the above issue by adding a dummy inspection\n-        // of `discriminant_place`, specifically by applying `ReadForMatch`.\n+        // of `scrutinee_place`, specifically by applying `ReadForMatch`.\n         //\n-        // NOTE: ReadForMatch also checks that the discriminant is initialized.\n+        // NOTE: ReadForMatch also checks that the scrutinee is initialized.\n         // This is currently needed to not allow matching on an uninitialized,\n         // uninhabited value. If we get never patterns, those will check that\n         // the place is initialized, and so this read would only be used to\n         // check safety.\n \n-        let source_info = self.source_info(discriminant_span);\n+        let source_info = self.source_info(scrutinee_span);\n         self.cfg.push(block, Statement {\n             source_info,\n             kind: StatementKind::FakeRead(\n                 FakeReadCause::ForMatchedPlace,\n-                discriminant_place.clone(),\n+                scrutinee_place.clone(),\n             ),\n         });\n \n@@ -175,7 +175,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             Candidate {\n                                 span: pattern.span,\n                                 match_pairs: vec![\n-                                    MatchPair::new(discriminant_place.clone(), pattern),\n+                                    MatchPair::new(scrutinee_place.clone(), pattern),\n                                 ],\n                                 bindings: vec![],\n                                 ascriptions: vec![],\n@@ -216,10 +216,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             .flat_map(|(_, candidates)| candidates)\n             .collect::<Vec<_>>();\n \n-        // this will generate code to test discriminant_place and\n+        // this will generate code to test scrutinee_place and\n         // branch to the appropriate arm block\n         let otherwise = self.match_candidates(\n-            discriminant_span,\n+            scrutinee_span,\n             candidates,\n             block,\n             &mut fake_borrows,\n@@ -245,7 +245,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // places. Create the required temporaries for them.\n \n         let fake_borrow_temps = if let Some(ref borrows) = fake_borrows {\n-            self.calculate_fake_borrows(borrows, discriminant_span)\n+            self.calculate_fake_borrows(borrows, scrutinee_span)\n         } else {\n             Vec::new()\n         };\n@@ -267,7 +267,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 LintLevel::Inherited,\n                 &arm.patterns[..],\n                 ArmHasGuard(arm.guard.is_some()),\n-                Some((Some(&discriminant_place), discriminant_span)),\n+                Some((Some(&scrutinee_place), scrutinee_span)),\n             );\n \n             for (pat_index, candidate) in candidates.into_iter().enumerate() {\n@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     arm.guard.clone(),\n                     arm_block,\n                     &fake_borrow_temps,\n-                    discriminant_span,\n+                    scrutinee_span,\n                     pat_index,\n                 );\n             }\n@@ -1302,7 +1302,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         guard: Option<Guard<'tcx>>,\n         arm_block: BasicBlock,\n         fake_borrows: &Vec<(&Place<'tcx>, BorrowKind, Local)>,\n-        discriminant_span: Span,\n+        scrutinee_span: Span,\n         pat_index: usize,\n     ) {\n         debug!(\"bind_and_guard_matched_candidate(candidate={:?})\", candidate);\n@@ -1427,7 +1427,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             let re_erased = tcx.types.re_erased;\n-            let discriminant_source_info = self.source_info(discriminant_span);\n+            let scrutinee_source_info = self.source_info(scrutinee_span);\n             for &(place, borrow_kind, temp) in fake_borrows {\n                 let borrow = Rvalue::Ref(\n                     re_erased,\n@@ -1436,7 +1436,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 );\n                 self.cfg.push_assign(\n                     block,\n-                    discriminant_source_info,\n+                    scrutinee_source_info,\n                     &Place::Local(temp),\n                     borrow,\n                 );"}, {"sha": "3c38f870b04b85476337e8d4166cc9ce3f445427", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5407fbdef83b552ac5ee35c9577319c59d851467/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5407fbdef83b552ac5ee35c9577319c59d851467/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=5407fbdef83b552ac5ee35c9577319c59d851467", "patch": "@@ -611,7 +611,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n         hir::ExprKind::Match(ref discr, ref arms, _) => {\n             ExprKind::Match {\n-                discriminant: discr.to_ref(),\n+                scrutinee: discr.to_ref(),\n                 arms: arms.iter().map(|a| convert_arm(cx, a)).collect(),\n             }\n         }"}, {"sha": "bce0a0dd0a8bdf8781a5294a31a132961b336c78", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5407fbdef83b552ac5ee35c9577319c59d851467/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5407fbdef83b552ac5ee35c9577319c59d851467/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=5407fbdef83b552ac5ee35c9577319c59d851467", "patch": "@@ -203,7 +203,7 @@ pub enum ExprKind<'tcx> {\n         body: ExprRef<'tcx>,\n     },\n     Match {\n-        discriminant: ExprRef<'tcx>,\n+        scrutinee: ExprRef<'tcx>,\n         arms: Vec<Arm<'tcx>>,\n     },\n     Block {"}]}