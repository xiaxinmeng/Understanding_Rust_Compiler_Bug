{"sha": "d761e84968de093ac2e0850293af1057b6fb44ee", "node_id": "C_kwDOAAsO6NoAKGQ3NjFlODQ5NjhkZTA5M2FjMmUwODUwMjkzYWYxMDU3YjZmYjQ0ZWU", "commit": {"author": {"name": "Ibraheem Ahmed", "email": "ibrah1440@gmail.com", "date": "2021-12-08T01:59:16Z"}, "committer": {"name": "Ibraheem Ahmed", "email": "ibrah1440@gmail.com", "date": "2021-12-08T02:07:47Z"}, "message": "implement `core::future::join`", "tree": {"sha": "900e0c19f844b69dcd5986542ae84fcf68476d26", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/900e0c19f844b69dcd5986542ae84fcf68476d26"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d761e84968de093ac2e0850293af1057b6fb44ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d761e84968de093ac2e0850293af1057b6fb44ee", "html_url": "https://github.com/rust-lang/rust/commit/d761e84968de093ac2e0850293af1057b6fb44ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d761e84968de093ac2e0850293af1057b6fb44ee/comments", "author": {"login": "ibraheemdev", "id": 34988408, "node_id": "MDQ6VXNlcjM0OTg4NDA4", "avatar_url": "https://avatars.githubusercontent.com/u/34988408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibraheemdev", "html_url": "https://github.com/ibraheemdev", "followers_url": "https://api.github.com/users/ibraheemdev/followers", "following_url": "https://api.github.com/users/ibraheemdev/following{/other_user}", "gists_url": "https://api.github.com/users/ibraheemdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibraheemdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibraheemdev/subscriptions", "organizations_url": "https://api.github.com/users/ibraheemdev/orgs", "repos_url": "https://api.github.com/users/ibraheemdev/repos", "events_url": "https://api.github.com/users/ibraheemdev/events{/privacy}", "received_events_url": "https://api.github.com/users/ibraheemdev/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibraheemdev", "id": 34988408, "node_id": "MDQ6VXNlcjM0OTg4NDA4", "avatar_url": "https://avatars.githubusercontent.com/u/34988408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibraheemdev", "html_url": "https://github.com/ibraheemdev", "followers_url": "https://api.github.com/users/ibraheemdev/followers", "following_url": "https://api.github.com/users/ibraheemdev/following{/other_user}", "gists_url": "https://api.github.com/users/ibraheemdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibraheemdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibraheemdev/subscriptions", "organizations_url": "https://api.github.com/users/ibraheemdev/orgs", "repos_url": "https://api.github.com/users/ibraheemdev/repos", "events_url": "https://api.github.com/users/ibraheemdev/events{/privacy}", "received_events_url": "https://api.github.com/users/ibraheemdev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "477fd7038c235689913abf9208dfa9371cbacd88", "url": "https://api.github.com/repos/rust-lang/rust/commits/477fd7038c235689913abf9208dfa9371cbacd88", "html_url": "https://github.com/rust-lang/rust/commit/477fd7038c235689913abf9208dfa9371cbacd88"}], "stats": {"total": 151, "additions": 151, "deletions": 0}, "files": [{"sha": "752a3ea92ba415a685677d8696246b75f1877244", "filename": "library/core/src/future/join.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/d761e84968de093ac2e0850293af1057b6fb44ee/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d761e84968de093ac2e0850293af1057b6fb44ee/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs?ref=d761e84968de093ac2e0850293af1057b6fb44ee", "patch": "@@ -0,0 +1,147 @@\n+#![allow(unused_imports)] // items are used by the macro\n+\n+use crate::cell::UnsafeCell;\n+use crate::future::{poll_fn, Future};\n+use crate::pin::Pin;\n+use crate::task::Poll;\n+/// Polls multiple futures simultaneously, returning a tuple\n+/// of all results once complete.\n+///\n+/// While `join!(a, b)` is similar to `(a.await, b.await)`,\n+/// `join!` polls both futures concurrently and is therefore more efficient.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(future_join, future_poll_fn)]\n+///\n+/// use std::future::join;\n+///\n+/// async fn one() -> usize { 1 }\n+/// async fn two() -> usize { 2 }\n+///\n+/// # let _ =  async {\n+/// let x = join!(one(), two());\n+/// assert_eq!(x, (1, 2));\n+/// # };\n+/// ```\n+///\n+/// `join!` is variadic, so you can pass any number of futures:\n+///\n+/// ```\n+/// #![feature(future_join, future_poll_fn)]\n+///\n+/// use std::future::join;\n+///\n+/// async fn one() -> usize { 1 }\n+/// async fn two() -> usize { 2 }\n+/// async fn three() -> usize { 3 }\n+///\n+/// # let _ = async {\n+/// let x = join!(one(), two(), three());\n+/// assert_eq!(x, (1, 2, 3));\n+/// # };\n+/// ```\n+#[unstable(feature = \"future_join\", issue = \"91642\")]\n+pub macro join {\n+    ( $($fut:expr),* $(,)?) => {\n+        join! { @count: (), @futures: {}, @rest: ($($fut,)*) }\n+    },\n+    // Recurse until we have the position of each future in the tuple\n+    (\n+        // A token for each future that has been expanded: \"_ _ _\"\n+        @count: ($($count:tt)*),\n+        // Futures and their positions in the tuple: \"{ a => (_), b => (_ _)) }\"\n+        @futures: { $($fut:tt)* },\n+        // The future currently being expanded, and the rest\n+        @rest: ($current:expr, $($rest:tt)*)\n+    ) => {\n+        join! {\n+            @count: ($($count)* _), // Add to the count\n+            @futures: { $($fut)* $current => ($($count)*), }, // Add the future from @rest with it's position\n+            @rest: ($($rest)*) // And leave the rest\n+        }\n+    },\n+    // Now generate the output future\n+    (\n+        @count: ($($count:tt)*),\n+        @futures: {\n+            $( $fut:expr => ( $($pos:tt)* ), )*\n+        },\n+        @rest: ()\n+    ) => {{\n+        let mut futures = ( $( MaybeDone::Future($fut), )* );\n+\n+        poll_fn(move |cx| {\n+            let mut done = true;\n+\n+            $(\n+                // Extract the future from the tuple\n+                let ( $($pos,)* fut, .. ) = &mut futures;\n+\n+                // SAFETY: the futures are never moved\n+                done &= unsafe { Pin::new_unchecked(fut).poll(cx).is_ready() };\n+            )*\n+\n+            if done {\n+                Poll::Ready(($({\n+                    let ( $($pos,)* fut, .. ) = &mut futures;\n+\n+                    // SAFETY: the futures are never moved\n+                    unsafe { Pin::new_unchecked(fut).take_output().unwrap() }\n+                }),*))\n+            } else {\n+                Poll::Pending\n+            }\n+        }).await\n+    }}\n+}\n+\n+/// Future used by `join!` that stores it's output to\n+/// be later taken and doesn't panic when polled after ready.\n+#[allow(dead_code)]\n+#[unstable(feature = \"future_join\", issue = \"none\")]\n+enum MaybeDone<F: Future> {\n+    Future(F),\n+    Done(F::Output),\n+    Took,\n+}\n+\n+#[unstable(feature = \"future_join\", issue = \"none\")]\n+impl<F: Future + Unpin> Unpin for MaybeDone<F> {}\n+\n+#[unstable(feature = \"future_join\", issue = \"none\")]\n+impl<F: Future> MaybeDone<F> {\n+    #[allow(dead_code)]\n+    fn take_output(self: Pin<&mut Self>) -> Option<F::Output> {\n+        unsafe {\n+            match &*self {\n+                MaybeDone::Done(_) => match mem::replace(self.get_unchecked_mut(), Self::Took) {\n+                    MaybeDone::Done(val) => Some(val),\n+                    _ => unreachable!(),\n+                },\n+                _ => None,\n+            }\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"future_join\", issue = \"none\")]\n+impl<F: Future> Future for MaybeDone<F> {\n+    type Output = ();\n+\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        unsafe {\n+            match self.as_mut().get_unchecked_mut() {\n+                MaybeDone::Future(f) => match Pin::new_unchecked(f).poll(cx) {\n+                    Poll::Ready(val) => self.set(Self::Done(val)),\n+                    Poll::Pending => return Poll::Pending,\n+                },\n+                MaybeDone::Done(_) => {}\n+                MaybeDone::Took => unreachable!(),\n+            }\n+        }\n+\n+        Poll::Ready(())\n+    }\n+}"}, {"sha": "88db584aefd08df0a75ccaca7efab0d29fa8edeb", "filename": "library/core/src/future/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d761e84968de093ac2e0850293af1057b6fb44ee/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d761e84968de093ac2e0850293af1057b6fb44ee/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fmod.rs?ref=d761e84968de093ac2e0850293af1057b6fb44ee", "patch": "@@ -11,13 +11,17 @@ use crate::{\n \n mod future;\n mod into_future;\n+mod join;\n mod pending;\n mod poll_fn;\n mod ready;\n \n #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n pub use self::future::Future;\n \n+#[unstable(feature = \"future_join\", issue = \"91642\")]\n+pub use self::join::join;\n+\n #[unstable(feature = \"into_future\", issue = \"67644\")]\n pub use into_future::IntoFuture;\n "}]}