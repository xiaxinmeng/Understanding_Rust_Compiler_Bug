{"sha": "bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkOTBiOTM2ZDczYzBlYTJjMjYxY2Q4ZTdiOWM0Mzc2NGNiMmRhMDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-19T13:22:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-19T13:22:10Z"}, "message": "auto merge of #19884 : nikomatsakis/rust/issue-19730-perfect-forwarding, r=pnkfelix\n\nRewrite how the HRTB algorithm matches impls against obligations. Instead of impls providing higher-ranked trait-references, impls now once again only have early-bound regions. The skolemization checks are thus moved out into trait matching itself. This allows to implement \"perfect forwarding\" impls like those described in #19730. This PR builds on a previous PR that was already reviewed by @pnkfelix.\r\n\r\nr? @pnkfelix \r\n\r\nFixes #19730", "tree": {"sha": "1e06eeba880be012ebfa11ab64911625c17c972e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e06eeba880be012ebfa11ab64911625c17c972e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "html_url": "https://github.com/rust-lang/rust/commit/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0efafac398ff7f28c5f0fe756c15b9008b3e0534", "url": "https://api.github.com/repos/rust-lang/rust/commits/0efafac398ff7f28c5f0fe756c15b9008b3e0534", "html_url": "https://github.com/rust-lang/rust/commit/0efafac398ff7f28c5f0fe756c15b9008b3e0534"}, {"sha": "ebf1e4f23adba8fc2a4441b8c2a7473c3a7c9d65", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebf1e4f23adba8fc2a4441b8c2a7473c3a7c9d65", "html_url": "https://github.com/rust-lang/rust/commit/ebf1e4f23adba8fc2a4441b8c2a7473c3a7c9d65"}], "stats": {"total": 5613, "additions": 3197, "deletions": 2416}, "files": [{"sha": "4ef2e681992aed87682b00fde9be91e6b448b549", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -762,8 +762,8 @@ mod test {\n         expected: &'b [int],\n     }\n \n-    impl<'a, 'b> FnMut(&int) -> bool for Counter<'a, 'b> {\n-        extern \"rust-call\" fn call_mut(&mut self, (&x,): (&int,)) -> bool {\n+    impl<'a, 'b, 'c> FnMut(&'c int) -> bool for Counter<'a, 'b> {\n+        extern \"rust-call\" fn call_mut(&mut self, (&x,): (&'c int,)) -> bool {\n             assert_eq!(x, self.expected[*self.i]);\n             *self.i += 1;\n             true"}, {"sha": "8fe41c0bd89c26e73b742cb047c38c9d54a7de26", "filename": "src/libcore/str.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -21,6 +21,7 @@ pub use self::Searcher::{Naive, TwoWay, TwoWayLong};\n \n use char::Char;\n use char;\n+use clone::Clone;\n use cmp::{Eq, mod};\n use default::Default;\n use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n@@ -31,7 +32,7 @@ use mem;\n use num::Int;\n use option::Option;\n use option::Option::{None, Some};\n-use ops::FnMut;\n+use ops::{Fn, FnMut};\n use ptr::RawPtr;\n use raw::{Repr, Slice};\n use slice::{mod, SliceExt};\n@@ -316,7 +317,23 @@ impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsets<'a> {\n \n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n-pub type Bytes<'a> = Map<&'a u8, u8, slice::Items<'a, u8>, fn(&u8) -> u8>;\n+pub type Bytes<'a> = Map<&'a u8, u8, slice::Items<'a, u8>, BytesFn>;\n+\n+/// A temporary new type wrapper that ensures that the `Bytes` iterator\n+/// is cloneable.\n+#[deriving(Copy)]\n+#[experimental = \"iterator type instability\"]\n+pub struct BytesFn(fn(&u8) -> u8);\n+\n+impl<'a> Fn(&'a u8) -> u8 for BytesFn {\n+    extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n+        (self.0)(ptr)\n+    }\n+}\n+\n+impl Clone for BytesFn {\n+    fn clone(&self) -> BytesFn { *self }\n+}\n \n /// An iterator over the substrings of a string, separated by `sep`.\n #[deriving(Clone)]\n@@ -2009,7 +2026,7 @@ impl StrPrelude for str {\n     fn bytes(&self) -> Bytes {\n         fn deref(&x: &u8) -> u8 { x }\n \n-        self.as_bytes().iter().map(deref)\n+        self.as_bytes().iter().map(BytesFn(deref))\n     }\n \n     #[inline]"}, {"sha": "f6fd9f60e5c3f666337675029dce02d35d10cb8c", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -1784,9 +1784,7 @@ impl LintPass for Stability {\n                                 method_num: index,\n                                 ..\n                             }) => {\n-                                ty::trait_item(cx.tcx,\n-                                               trait_ref.def_id,\n-                                               index).def_id()\n+                                ty::trait_item(cx.tcx, trait_ref.def_id, index).def_id()\n                             }\n                         }\n                     }"}, {"sha": "7f1df80da3c8fa9dcdf94f1cf1086a529673e8d9", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -704,7 +704,7 @@ pub fn get_enum_variants<'tcx>(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::Nod\n         let name = item_name(&*intr, item);\n         let (ctor_ty, arg_tys, arg_names) = match ctor_ty.sty {\n             ty::ty_bare_fn(ref f) =>\n-                (Some(ctor_ty), f.sig.inputs.clone(), None),\n+                (Some(ctor_ty), f.sig.0.inputs.clone(), None),\n             _ => { // Nullary or struct enum variant.\n                 let mut arg_names = Vec::new();\n                 let arg_tys = get_struct_fields(intr.clone(), cdata, did.node)"}, {"sha": "f2a41c48d1203753408e4b8d5cc94b5835a0d75d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -21,7 +21,7 @@ pub use self::DefIdSource::*;\n use middle::region;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, AsPredicate, Ty};\n \n use std::rc::Rc;\n use std::str;\n@@ -414,7 +414,7 @@ fn parse_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> Ty<'tcx> {\n       }\n       'x' => {\n         assert_eq!(next(st), '[');\n-        let trait_ref = parse_trait_ref(st, |x,y| conv(x,y));\n+        let trait_ref = ty::Binder(parse_trait_ref(st, |x,y| conv(x,y)));\n         let bounds = parse_existential_bounds(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n         return ty::mk_trait(st.tcx, trait_ref, bounds);\n@@ -603,7 +603,7 @@ fn parse_bare_fn_ty<'a, 'tcx>(st: &mut PState<'a, 'tcx>,\n     }\n }\n \n-fn parse_sig<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> ty::FnSig<'tcx> {\n+fn parse_sig<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> ty::PolyFnSig<'tcx> {\n     assert_eq!(next(st), '[');\n     let mut inputs = Vec::new();\n     while peek(st) != ']' {\n@@ -622,9 +622,9 @@ fn parse_sig<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did) -> ty::FnSig<'\n         }\n         _ => ty::FnConverging(parse_ty(st, |x,y| conv(x,y)))\n     };\n-    ty::FnSig {inputs: inputs,\n-               output: output,\n-               variadic: variadic}\n+    ty::Binder(ty::FnSig {inputs: inputs,\n+                        output: output,\n+                        variadic: variadic})\n }\n \n // Rust metadata parsing\n@@ -669,13 +669,13 @@ pub fn parse_predicate<'a,'tcx>(st: &mut PState<'a, 'tcx>,\n                                 -> ty::Predicate<'tcx>\n {\n     match next(st) {\n-        't' => ty::Predicate::Trait(Rc::new(parse_trait_ref(st, conv))),\n-        'e' => ty::Predicate::Equate(parse_ty(st, |x,y| conv(x,y)),\n-                                     parse_ty(st, |x,y| conv(x,y))),\n-        'r' => ty::Predicate::RegionOutlives(parse_region(st, |x,y| conv(x,y)),\n-                                             parse_region(st, |x,y| conv(x,y))),\n-        'o' => ty::Predicate::TypeOutlives(parse_ty(st, |x,y| conv(x,y)),\n-                                           parse_region(st, |x,y| conv(x,y))),\n+        't' => Rc::new(ty::Binder(parse_trait_ref(st, conv))).as_predicate(),\n+        'e' => ty::Binder(ty::EquatePredicate(parse_ty(st, |x,y| conv(x,y)),\n+                                              parse_ty(st, |x,y| conv(x,y)))).as_predicate(),\n+        'r' => ty::Binder(ty::OutlivesPredicate(parse_region(st, |x,y| conv(x,y)),\n+                                                parse_region(st, |x,y| conv(x,y)))).as_predicate(),\n+        'o' => ty::Binder(ty::OutlivesPredicate(parse_ty(st, |x,y| conv(x,y)),\n+                                                parse_region(st, |x,y| conv(x,y)))).as_predicate(),\n         c => panic!(\"Encountered invalid character in metadata: {}\", c)\n     }\n }\n@@ -759,10 +759,12 @@ fn parse_bounds<'a, 'tcx>(st: &mut PState<'a, 'tcx>, conv: conv_did)\n     loop {\n         match next(st) {\n             'R' => {\n-                param_bounds.region_bounds.push(parse_region(st, |x, y| conv (x, y)));\n+                param_bounds.region_bounds.push(\n+                    parse_region(st, |x, y| conv (x, y)));\n             }\n             'I' => {\n-                param_bounds.trait_bounds.push(Rc::new(parse_trait_ref(st, |x,y| conv(x,y))));\n+                param_bounds.trait_bounds.push(\n+                    Rc::new(ty::Binder(parse_trait_ref(st, |x,y| conv(x,y)))));\n             }\n             '.' => {\n                 return param_bounds;"}, {"sha": "5d7d85d4679d7c9d8ed6e46913a4467a36dd91e1", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -251,7 +251,7 @@ fn enc_sty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n         ty::ty_trait(box ty::TyTrait { ref principal,\n                                        ref bounds }) => {\n             mywrite!(w, \"x[\");\n-            enc_trait_ref(w, cx, principal);\n+            enc_trait_ref(w, cx, &principal.0);\n             enc_existential_bounds(w, cx, bounds);\n             mywrite!(w, \"]\");\n         }\n@@ -351,18 +351,18 @@ pub fn enc_closure_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n }\n \n fn enc_fn_sig<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n-                        fsig: &ty::FnSig<'tcx>) {\n+                        fsig: &ty::PolyFnSig<'tcx>) {\n     mywrite!(w, \"[\");\n-    for ty in fsig.inputs.iter() {\n+    for ty in fsig.0.inputs.iter() {\n         enc_ty(w, cx, *ty);\n     }\n     mywrite!(w, \"]\");\n-    if fsig.variadic {\n+    if fsig.0.variadic {\n         mywrite!(w, \"V\");\n     } else {\n         mywrite!(w, \"N\");\n     }\n-    match fsig.output {\n+    match fsig.0.output {\n         ty::FnConverging(result_type) => {\n             enc_ty(w, cx, result_type);\n         }\n@@ -401,7 +401,7 @@ pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n \n     for tp in bs.trait_bounds.iter() {\n         mywrite!(w, \"I\");\n-        enc_trait_ref(w, cx, &**tp);\n+        enc_trait_ref(w, cx, &tp.0);\n     }\n \n     mywrite!(w, \".\");\n@@ -425,19 +425,19 @@ pub fn enc_predicate<'a, 'tcx>(w: &mut SeekableMemWriter,\n     match *p {\n         ty::Predicate::Trait(ref trait_ref) => {\n             mywrite!(w, \"t\");\n-            enc_trait_ref(w, cx, &**trait_ref);\n+            enc_trait_ref(w, cx, &trait_ref.0);\n         }\n-        ty::Predicate::Equate(a, b) => {\n+        ty::Predicate::Equate(ty::Binder(ty::EquatePredicate(a, b))) => {\n             mywrite!(w, \"e\");\n             enc_ty(w, cx, a);\n             enc_ty(w, cx, b);\n         }\n-        ty::Predicate::RegionOutlives(a, b) => {\n+        ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(a, b))) => {\n             mywrite!(w, \"r\");\n             enc_region(w, cx, a);\n             enc_region(w, cx, b);\n         }\n-        ty::Predicate::TypeOutlives(a, b) => {\n+        ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(a, b))) => {\n             mywrite!(w, \"o\");\n             enc_ty(w, cx, a);\n             enc_region(w, cx, b);"}, {"sha": "69fbd59fd924142ae2dd9d26d33515b8a098aab4", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -1113,7 +1113,7 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n                     this.emit_enum_variant(\"UnsizeVtable\", 2, 4, |this| {\n                         this.emit_enum_variant_arg(0, |this| {\n                             try!(this.emit_struct_field(\"principal\", 0, |this| {\n-                                Ok(this.emit_trait_ref(ecx, &*principal))\n+                                Ok(this.emit_trait_ref(ecx, &principal.0))\n                             }));\n                             this.emit_struct_field(\"bounds\", 1, |this| {\n                                 Ok(this.emit_existential_bounds(ecx, b))\n@@ -1277,7 +1277,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n             rbml_w.id(id);\n             rbml_w.tag(c::tag_table_val, |rbml_w| {\n-                rbml_w.emit_trait_ref(ecx, &**trait_ref);\n+                rbml_w.emit_trait_ref(ecx, &trait_ref.0);\n             })\n         })\n     }\n@@ -1356,6 +1356,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n     fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n     fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                               -> Rc<ty::TraitRef<'tcx>>;\n+    fn read_poly_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                   -> Rc<ty::PolyTraitRef<'tcx>>;\n     fn read_type_param_def<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                    -> ty::TypeParameterDef<'tcx>;\n     fn read_predicate<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1548,6 +1550,19 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap())\n     }\n \n+    fn read_poly_trait_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n+                                   -> Rc<ty::PolyTraitRef<'tcx>> {\n+        Rc::new(ty::Binder(self.read_opaque(|this, doc| {\n+            let ty = tydecode::parse_trait_ref_data(\n+                doc.data,\n+                dcx.cdata.cnum,\n+                doc.start,\n+                dcx.tcx,\n+                |s, a| this.convert_def_id(dcx, s, a));\n+            Ok(ty)\n+        }).unwrap()))\n+    }\n+\n     fn read_type_param_def<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                    -> ty::TypeParameterDef<'tcx> {\n         self.read_opaque(|this, doc| {\n@@ -1753,7 +1768,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                     2 => {\n                         let ty_trait = try!(this.read_enum_variant_arg(0, |this| {\n                             let principal = try!(this.read_struct_field(\"principal\", 0, |this| {\n-                                Ok(this.read_trait_ref(dcx))\n+                                Ok(this.read_poly_trait_ref(dcx))\n                             }));\n                             Ok(ty::TyTrait {\n                                 principal: (*principal).clone(),\n@@ -1926,7 +1941,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         dcx.tcx.method_map.borrow_mut().insert(method_call, method);\n                     }\n                     c::tag_table_object_cast_map => {\n-                        let trait_ref = val_dsr.read_trait_ref(dcx);\n+                        let trait_ref = val_dsr.read_poly_trait_ref(dcx);\n                         dcx.tcx.object_cast_map.borrow_mut()\n                                                .insert(id, trait_ref);\n                     }"}, {"sha": "af2be6e088dd530570282acf64a7d48fba41063d", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -31,7 +31,6 @@ use middle::infer;\n use middle::traits;\n use middle::mem_categorization as mc;\n use middle::expr_use_visitor as euv;\n-use util::common::ErrorReported;\n use util::nodemap::NodeSet;\n \n use syntax::ast;\n@@ -122,17 +121,12 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n         let ty = ty::node_id_to_type(self.tcx, e.id);\n         let infcx = infer::new_infer_ctxt(self.tcx);\n         let mut fulfill_cx = traits::FulfillmentContext::new();\n-        match traits::trait_ref_for_builtin_bound(self.tcx, ty::BoundSync, ty) {\n-            Ok(trait_ref) => {\n-                fulfill_cx.register_trait_ref(self.tcx, trait_ref,\n-                                              traits::ObligationCause::dummy());\n-                let env = ty::empty_parameter_environment();\n-                if !fulfill_cx.select_all_or_error(&infcx, &env, self.tcx).is_ok() {\n-                    self.tcx.sess.span_err(e.span, \"shared static items must have a \\\n-                                                    type which implements Sync\");\n-                }\n-            }\n-            Err(ErrorReported) => { }\n+        fulfill_cx.register_builtin_bound(self.tcx, ty, ty::BoundSync,\n+                                          traits::ObligationCause::dummy());\n+        let env = ty::empty_parameter_environment();\n+        if !fulfill_cx.select_all_or_error(&infcx, &env, self.tcx).is_ok() {\n+            self.tcx.sess.span_err(e.span, \"shared static items must have a \\\n+                                            type which implements Sync\");\n         }\n     }\n }"}, {"sha": "5c0d4b4841ee385377969dfb3db65c0ddb7be444", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -60,7 +60,7 @@ pub fn simplify_type(tcx: &ty::ctxt,\n         ty::ty_vec(..) => Some(VecSimplifiedType),\n         ty::ty_ptr(_) => Some(PtrSimplifiedType),\n         ty::ty_trait(ref trait_info) => {\n-            Some(TraitSimplifiedType(trait_info.principal.def_id))\n+            Some(TraitSimplifiedType(trait_info.principal.def_id()))\n         }\n         ty::ty_struct(def_id, _) => {\n             Some(StructSimplifiedType(def_id))\n@@ -83,10 +83,10 @@ pub fn simplify_type(tcx: &ty::ctxt,\n             Some(TupleSimplifiedType(tys.len()))\n         }\n         ty::ty_closure(ref f) => {\n-            Some(FunctionSimplifiedType(f.sig.inputs.len()))\n+            Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n         }\n         ty::ty_bare_fn(ref f) => {\n-            Some(FunctionSimplifiedType(f.sig.inputs.len()))\n+            Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n         }\n         ty::ty_param(_) => {\n             if can_simplify_params {"}, {"sha": "805d4532aa1c49ff802d4ff4c7f16d8ae3e08a17", "filename": "src/librustc/middle/infer/coercion.rs", "status": "modified", "additions": 9, "deletions": 21, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcoercion.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -60,10 +60,9 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use super::{CoerceResult, resolve_type, Coercion};\n+use super::{CoerceResult, Coercion};\n use super::combine::{CombineFields, Combine};\n use super::sub::Sub;\n-use super::resolve::try_resolve_tvar_shallow;\n \n use middle::subst;\n use middle::ty::{AutoPtr, AutoDerefRef, AdjustDerefRef, AutoUnsize, AutoUnsafe};\n@@ -197,18 +196,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     pub fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n         F: FnOnce(&ty::sty<'tcx>) -> T,\n     {\n-        match resolve_type(self.get_ref().infcx, None,\n-                           a, try_resolve_tvar_shallow) {\n-            Ok(t) => {\n-                f(&t.sty)\n-            }\n-            Err(e) => {\n-                self.get_ref().infcx.tcx.sess.span_bug(\n-                    self.get_ref().trace.origin.span(),\n-                    format!(\"failed to resolve even without \\\n-                             any force options: {}\", e).as_slice());\n-            }\n-        }\n+        f(&self.get_ref().infcx.shallow_resolve(a).sty)\n     }\n \n     // ~T -> &T or &mut T -> &T (including where T = [U] or str)\n@@ -286,7 +274,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             let ty = ty::mk_rptr(self.get_ref().infcx.tcx,\n                                                  r_borrow,\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                            try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoPtr(AutoUnsize({})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -309,7 +297,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                             let ty = ty::mk_ptr(self.get_ref().infcx.tcx,\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                            try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoPtr(AutoUnsize({})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -327,7 +315,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     match self.unsize_ty(t_a, sty_a, t_b) {\n                         Some((ty, kind)) => {\n                             let ty = ty::mk_uniq(self.get_ref().infcx.tcx, ty);\n-                            try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoUnsizeUniq({}))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -366,7 +354,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 }\n                 (_, &ty::ty_trait(box ty::TyTrait { ref principal, bounds })) => {\n                     // FIXME what is the purpose of `ty`?\n-                    let ty = ty::mk_trait(tcx, (*principal).clone(), bounds);\n+                    let ty = ty::mk_trait(tcx, principal.clone(), bounds);\n                     Some((ty, ty::UnsizeVtable(ty::TyTrait { principal: (*principal).clone(),\n                                                              bounds: bounds },\n                                                ty_a)))\n@@ -384,7 +372,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     let mut result = None;\n                     let mut tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n                     for (i, (tp_a, tp_b)) in tps {\n-                        if self.get_ref().infcx.try(|| sub.tys(*tp_a, *tp_b)).is_ok() {\n+                        if self.get_ref().infcx.try(|_| sub.tys(*tp_a, *tp_b)).is_ok() {\n                             continue;\n                         }\n                         match\n@@ -397,7 +385,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                 let mut new_substs = substs_a.clone();\n                                 new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n                                 let ty = ty::mk_struct(tcx, did_a, new_substs);\n-                                if self.get_ref().infcx.try(|| sub.tys(ty, ty_b)).is_err() {\n+                                if self.get_ref().infcx.try(|_| sub.tys(ty, ty_b)).is_err() {\n                                     debug!(\"Unsized type parameter '{}', but still \\\n                                             could not match types {} and {}\",\n                                            ppaux::ty_to_string(tcx, *tp_a),\n@@ -476,7 +464,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n                     debug!(\"mutbl={} b_mutbl={}\", mutbl, b_mutbl);\n                     // FIXME what is purpose of this type `tr`?\n-                    let tr = ty::mk_trait(tcx, (*principal).clone(), bounds);\n+                    let tr = ty::mk_trait(tcx, principal.clone(), bounds);\n                     try!(self.subtype(mk_ty(tr), b));\n                     Ok(Some(AdjustDerefRef(AutoDerefRef {\n                         autoderefs: 1,"}, {"sha": "82ddbcee5a72e50a44a5f5cd010e9119e42e8ef6", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 107, "deletions": 11, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -195,7 +195,7 @@ pub trait Combine<'tcx> {\n                    b: &ty::BareFnTy<'tcx>) -> cres<'tcx, ty::BareFnTy<'tcx>> {\n         let unsafety = try!(self.unsafeties(a.unsafety, b.unsafety));\n         let abi = try!(self.abi(a.abi, b.abi));\n-        let sig = try!(self.fn_sigs(&a.sig, &b.sig));\n+        let sig = try!(self.binders(&a.sig, &b.sig));\n         Ok(ty::BareFnTy {unsafety: unsafety,\n                          abi: abi,\n                          sig: sig})\n@@ -222,7 +222,7 @@ pub trait Combine<'tcx> {\n         let unsafety = try!(self.unsafeties(a.unsafety, b.unsafety));\n         let onceness = try!(self.oncenesses(a.onceness, b.onceness));\n         let bounds = try!(self.existential_bounds(a.bounds, b.bounds));\n-        let sig = try!(self.fn_sigs(&a.sig, &b.sig));\n+        let sig = try!(self.binders(&a.sig, &b.sig));\n         let abi = try!(self.abi(a.abi, b.abi));\n         Ok(ty::ClosureTy {\n             unsafety: unsafety,\n@@ -234,7 +234,43 @@ pub trait Combine<'tcx> {\n         })\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>) -> cres<'tcx, ty::FnSig<'tcx>>;\n+    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>) -> cres<'tcx, ty::FnSig<'tcx>> {\n+        if a.variadic != b.variadic {\n+            return Err(ty::terr_variadic_mismatch(expected_found(self, a.variadic, b.variadic)));\n+        }\n+\n+        let inputs = try!(argvecs(self,\n+                                  a.inputs.as_slice(),\n+                                  b.inputs.as_slice()));\n+\n+        let output = try!(match (a.output, b.output) {\n+            (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n+                Ok(ty::FnConverging(try!(self.tys(a_ty, b_ty)))),\n+            (ty::FnDiverging, ty::FnDiverging) =>\n+                Ok(ty::FnDiverging),\n+            (a, b) =>\n+                Err(ty::terr_convergence_mismatch(\n+                    expected_found(self, a != ty::FnDiverging, b != ty::FnDiverging))),\n+        });\n+\n+        return Ok(ty::FnSig {inputs: inputs,\n+                             output: output,\n+                             variadic: a.variadic});\n+\n+\n+        fn argvecs<'tcx, C: Combine<'tcx>>(combiner: &C,\n+                                           a_args: &[Ty<'tcx>],\n+                                           b_args: &[Ty<'tcx>])\n+                                           -> cres<'tcx, Vec<Ty<'tcx>>>\n+        {\n+            if a_args.len() == b_args.len() {\n+                a_args.iter().zip(b_args.iter())\n+                    .map(|(a, b)| combiner.args(*a, *b)).collect()\n+            } else {\n+                Err(ty::terr_arg_count)\n+            }\n+        }\n+    }\n \n     fn args(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         self.contratys(a, b).and_then(|t| Ok(t))\n@@ -301,11 +337,47 @@ pub trait Combine<'tcx> {\n     fn trait_refs(&self,\n                   a: &ty::TraitRef<'tcx>,\n                   b: &ty::TraitRef<'tcx>)\n-                  -> cres<'tcx, ty::TraitRef<'tcx>>;\n+                  -> cres<'tcx, ty::TraitRef<'tcx>>\n+    {\n+        // Different traits cannot be related\n+        if a.def_id != b.def_id {\n+            Err(ty::terr_traits(expected_found(self, a.def_id, b.def_id)))\n+        } else {\n+            let substs = try!(self.substs(a.def_id, &a.substs, &b.substs));\n+            Ok(ty::TraitRef { def_id: a.def_id, substs: substs })\n+        }\n+    }\n+\n+    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n+        where T : Combineable<'tcx>;\n     // this must be overridden to do correctly, so as to account for higher-ranked\n     // behavior\n }\n \n+pub trait Combineable<'tcx> : Repr<'tcx> + TypeFoldable<'tcx> {\n+    fn combine<C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> cres<'tcx, Self>;\n+}\n+\n+impl<'tcx> Combineable<'tcx> for ty::TraitRef<'tcx> {\n+    fn combine<C:Combine<'tcx>>(combiner: &C,\n+                                a: &ty::TraitRef<'tcx>,\n+                                b: &ty::TraitRef<'tcx>)\n+                                -> cres<'tcx, ty::TraitRef<'tcx>>\n+    {\n+        combiner.trait_refs(a, b)\n+    }\n+}\n+\n+impl<'tcx> Combineable<'tcx> for ty::FnSig<'tcx> {\n+    fn combine<C:Combine<'tcx>>(combiner: &C,\n+                                a: &ty::FnSig<'tcx>,\n+                                b: &ty::FnSig<'tcx>)\n+                                -> cres<'tcx, ty::FnSig<'tcx>>\n+    {\n+        combiner.fn_sigs(a, b)\n+    }\n+}\n+\n #[deriving(Clone)]\n pub struct CombineFields<'a, 'tcx: 'a> {\n     pub infcx: &'a InferCtxt<'a, 'tcx>,\n@@ -410,7 +482,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n       (&ty::ty_trait(ref a_),\n        &ty::ty_trait(ref b_)) => {\n           debug!(\"Trying to match traits {} and {}\", a, b);\n-          let principal = try!(this.trait_refs(&a_.principal, &b_.principal));\n+          let principal = try!(this.binders(&a_.principal, &b_.principal));\n           let bounds = try!(this.existential_bounds(a_.bounds, b_.bounds));\n           Ok(ty::mk_trait(tcx, principal, bounds))\n       }\n@@ -706,14 +778,38 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         match r {\n-            ty::ReLateBound(..) | ty::ReEarlyBound(..) => r,\n-            _ if self.make_region_vars => {\n-                // FIXME: This is non-ideal because we don't give a\n-                // very descriptive origin for this region variable.\n-                self.infcx.next_region_var(MiscVariable(self.span))\n+            // Never make variables for regions bound within the type itself.\n+            ty::ReLateBound(..) => { return r; }\n+\n+            // Early-bound regions should really have been substituted away before\n+            // we get to this point.\n+            ty::ReEarlyBound(..) => {\n+                self.tcx().sess.span_bug(\n+                    self.span,\n+                    format!(\"Encountered early bound region when generalizing: {}\",\n+                            r.repr(self.tcx()))[]);\n+            }\n+\n+            // Always make a fresh region variable for skolemized regions;\n+            // the higher-ranked decision procedures rely on this.\n+            ty::ReInfer(ty::ReSkolemized(..)) => { }\n+\n+            // For anything else, we make a region variable, unless we\n+            // are *equating*, in which case it's just wasteful.\n+            ty::ReEmpty |\n+            ty::ReStatic |\n+            ty::ReScope(..) |\n+            ty::ReInfer(ty::ReVar(..)) |\n+            ty::ReFree(..) => {\n+                if !self.make_region_vars {\n+                    return r;\n+                }\n             }\n-            _ => r,\n         }\n+\n+        // FIXME: This is non-ideal because we don't give a\n+        // very descriptive origin for this region variable.\n+        self.infcx.next_region_var(MiscVariable(self.span))\n     }\n }\n "}, {"sha": "2a4d20f4dd3799ccdbe7b0fac6dad97333e92d4c", "filename": "src/librustc/middle/infer/equate.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fequate.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -133,15 +133,10 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         }\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n-               -> cres<'tcx, ty::FnSig<'tcx>> {\n-        try!(self.sub().fn_sigs(a, b));\n-        self.sub().fn_sigs(b, a)\n-    }\n-\n-    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n-                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n-        try!(self.sub().trait_refs(a, b));\n-        self.sub().trait_refs(b, a)\n+    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n+        where T : Combineable<'tcx>\n+    {\n+        try!(self.sub().binders(a, b));\n+        self.sub().binders(b, a)\n     }\n }"}, {"sha": "b4c1c0b396b64ceb15284e4662ca500b36be8fac", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -395,7 +395,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String> {\n         match *values {\n             infer::Types(ref exp_found) => self.expected_found_str(exp_found),\n-            infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found)\n+            infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n+            infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found)\n         }\n     }\n \n@@ -1640,7 +1641,7 @@ pub trait Resolvable<'tcx> {\n \n impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>) -> Ty<'tcx> {\n-        infcx.resolve_type_vars_if_possible(*self)\n+        infcx.resolve_type_vars_if_possible(self)\n     }\n     fn contains_error(&self) -> bool {\n         ty::type_is_error(*self)\n@@ -1650,13 +1651,23 @@ impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n impl<'tcx> Resolvable<'tcx> for Rc<ty::TraitRef<'tcx>> {\n     fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n                    -> Rc<ty::TraitRef<'tcx>> {\n-        Rc::new(infcx.resolve_type_vars_in_trait_ref_if_possible(&**self))\n+        Rc::new(infcx.resolve_type_vars_if_possible(&**self))\n     }\n     fn contains_error(&self) -> bool {\n         ty::trait_ref_contains_error(&**self)\n     }\n }\n \n+impl<'tcx> Resolvable<'tcx> for Rc<ty::PolyTraitRef<'tcx>> {\n+    fn resolve<'a>(&self, infcx: &InferCtxt<'a, 'tcx>)\n+                   -> Rc<ty::PolyTraitRef<'tcx>> {\n+        Rc::new(infcx.resolve_type_vars_if_possible(&**self))\n+    }\n+    fn contains_error(&self) -> bool {\n+        ty::trait_ref_contains_error(&self.0)\n+    }\n+}\n+\n fn lifetimes_in_scope(tcx: &ty::ctxt,\n                       scope_id: ast::NodeId)\n                       -> Vec<ast::LifetimeDef> {"}, {"sha": "ebff854060caec7cfb107e4ad1db2aeb2b9af9bd", "filename": "src/librustc/middle/infer/freshen.rs", "status": "renamed", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -8,21 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Skolemization is the process of replacing unknown variables with fresh types. The idea is that\n-//! the type, after skolemization, contains no inference variables but instead contains either a\n+//! Freshening is the process of replacing unknown variables with fresh types. The idea is that\n+//! the type, after freshening, contains no inference variables but instead contains either a\n //! value for each variable or fresh \"arbitrary\" types wherever a variable would have been.\n //!\n-//! Skolemization is used primarily to get a good type for inserting into a cache. The result\n+//! Freshening is used primarily to get a good type for inserting into a cache. The result\n //! summarizes what the type inferencer knows \"so far\". The primary place it is used right now is\n //! in the trait matching algorithm, which needs to be able to cache whether an `impl` self type\n //! matches some other type X -- *without* affecting `X`. That means if that if the type `X` is in\n //! fact an unbound type variable, we want the match to be regarded as ambiguous, because depending\n //! on what type that type variable is ultimately assigned, the match may or may not succeed.\n //!\n-//! Note that you should be careful not to allow the output of skolemization to leak to the user in\n-//! error messages or in any other form. Skolemization is only really useful as an internal detail.\n+//! Note that you should be careful not to allow the output of freshening to leak to the user in\n+//! error messages or in any other form. Freshening is only really useful as an internal detail.\n //!\n-//! __An important detail concerning regions.__ The skolemizer also replaces *all* regions with\n+//! __An important detail concerning regions.__ The freshener also replaces *all* regions with\n //! 'static. The reason behind this is that, in general, we do not take region relationships into\n //! account when making type-overloaded decisions. This is important because of the design of the\n //! region inferencer, which is not based on unification but rather on accumulating and then\n@@ -39,47 +39,47 @@ use std::collections::hash_map;\n use super::InferCtxt;\n use super::unify::InferCtxtMethodsForSimplyUnifiableTypes;\n \n-pub struct TypeSkolemizer<'a, 'tcx:'a> {\n+pub struct TypeFreshener<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    skolemization_count: uint,\n-    skolemization_map: hash_map::HashMap<ty::InferTy, Ty<'tcx>>,\n+    freshen_count: uint,\n+    freshen_map: hash_map::HashMap<ty::InferTy, Ty<'tcx>>,\n }\n \n-impl<'a, 'tcx> TypeSkolemizer<'a, 'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeSkolemizer<'a, 'tcx> {\n-        TypeSkolemizer {\n+impl<'a, 'tcx> TypeFreshener<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> TypeFreshener<'a, 'tcx> {\n+        TypeFreshener {\n             infcx: infcx,\n-            skolemization_count: 0,\n-            skolemization_map: hash_map::HashMap::new(),\n+            freshen_count: 0,\n+            freshen_map: hash_map::HashMap::new(),\n         }\n     }\n \n-    fn skolemize<F>(&mut self,\n-                    opt_ty: Option<Ty<'tcx>>,\n-                    key: ty::InferTy,\n-                    skolemizer: F)\n-                    -> Ty<'tcx> where\n+    fn freshen<F>(&mut self,\n+                  opt_ty: Option<Ty<'tcx>>,\n+                  key: ty::InferTy,\n+                  freshener: F)\n+                  -> Ty<'tcx> where\n         F: FnOnce(uint) -> ty::InferTy,\n     {\n         match opt_ty {\n             Some(ty) => { return ty.fold_with(self); }\n             None => { }\n         }\n \n-        match self.skolemization_map.entry(key) {\n+        match self.freshen_map.entry(key) {\n             hash_map::Occupied(entry) => *entry.get(),\n             hash_map::Vacant(entry) => {\n-                let index = self.skolemization_count;\n-                self.skolemization_count += 1;\n-                let t = ty::mk_infer(self.infcx.tcx, skolemizer(index));\n+                let index = self.freshen_count;\n+                self.freshen_count += 1;\n+                let t = ty::mk_infer(self.infcx.tcx, freshener(index));\n                 entry.set(t);\n                 t\n             }\n         }\n     }\n }\n \n-impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n+impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     fn tcx<'b>(&'b self) -> &'b ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n@@ -106,37 +106,37 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeSkolemizer<'a, 'tcx> {\n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match t.sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n-                self.skolemize(self.infcx.type_variables.borrow().probe(v),\n+                self.freshen(self.infcx.type_variables.borrow().probe(v),\n                                ty::TyVar(v),\n-                               ty::SkolemizedTy)\n+                               ty::FreshTy)\n             }\n \n             ty::ty_infer(ty::IntVar(v)) => {\n-                self.skolemize(self.infcx.probe_var(v),\n-                               ty::IntVar(v),\n-                               ty::SkolemizedIntTy)\n+                self.freshen(self.infcx.probe_var(v),\n+                             ty::IntVar(v),\n+                             ty::FreshIntTy)\n             }\n \n             ty::ty_infer(ty::FloatVar(v)) => {\n-                self.skolemize(self.infcx.probe_var(v),\n-                               ty::FloatVar(v),\n-                               ty::SkolemizedIntTy)\n+                self.freshen(self.infcx.probe_var(v),\n+                             ty::FloatVar(v),\n+                             ty::FreshIntTy)\n             }\n \n-            ty::ty_infer(ty::SkolemizedTy(c)) |\n-            ty::ty_infer(ty::SkolemizedIntTy(c)) => {\n-                if c >= self.skolemization_count {\n+            ty::ty_infer(ty::FreshTy(c)) |\n+            ty::ty_infer(ty::FreshIntTy(c)) => {\n+                if c >= self.freshen_count {\n                     self.tcx().sess.bug(\n-                        format!(\"Encountered a skolemized type with id {} \\\n+                        format!(\"Encountered a freshend type with id {} \\\n                                  but our counter is only at {}\",\n                                 c,\n-                                self.skolemization_count).as_slice());\n+                                self.freshen_count).as_slice());\n                 }\n                 t\n             }\n \n             ty::ty_open(..) => {\n-                self.tcx().sess.bug(\"Cannot skolemize an open existential type\");\n+                self.tcx().sess.bug(\"Cannot freshen an open existential type\");\n             }\n \n             ty::ty_bool |", "previous_filename": "src/librustc/middle/infer/skolemize.rs"}, {"sha": "434be32fe5fa70162c642c910e716ca9c7acf0e5", "filename": "src/librustc/middle/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fglb.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -121,13 +121,9 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n         super_lattice_tys(self, a, b)\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n-               -> cres<'tcx, ty::FnSig<'tcx>> {\n-        self.higher_ranked_glb(a, b)\n-    }\n-\n-    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n-                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n+    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n+        where T : Combineable<'tcx>\n+    {\n         self.higher_ranked_glb(a, b)\n     }\n }"}, {"sha": "f6f254c0e8dfce198a1162bcc7a38e06126b315a", "filename": "src/librustc/middle/infer/higher_ranked/doc.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fdoc.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -249,19 +249,21 @@\n //! in T and try to, in some cases, replace them with bound regions to\n //! yield the final result.\n //!\n-//! To decide whether to replace a region `R` that appears in `T` with a\n-//! bound region, the algorithms make use of two bits of information.\n-//! First is a set `V` that contains all region variables created as part\n-//! of the LUB/GLB computation. `V` will contain the region variables\n-//! created to replace the bound regions in the input types, but it also\n-//! contains 'intermediate' variables created to represent the LUB/GLB of\n-//! individual regions.  Basically, when asked to compute the LUB/GLB of a\n-//! region variable with another region, the inferencer cannot oblige\n-//! immediately since the values of that variables are not known.\n-//! Therefore, it creates a new variable that is related to the two\n-//! regions.  For example, the LUB of two variables `$x` and `$y` is a\n-//! fresh variable `$z` that is constrained such that `$x <= $z` and `$y\n-//! <= $z`.  So `V` will contain these intermediate variables as well.\n+//! To decide whether to replace a region `R` that appears in `T` with\n+//! a bound region, the algorithms make use of two bits of\n+//! information.  First is a set `V` that contains all region\n+//! variables created as part of the LUB/GLB computation (roughly; see\n+//! `region_vars_confined_to_snapshot()` for full details). `V` will\n+//! contain the region variables created to replace the bound regions\n+//! in the input types, but it also contains 'intermediate' variables\n+//! created to represent the LUB/GLB of individual regions.\n+//! Basically, when asked to compute the LUB/GLB of a region variable\n+//! with another region, the inferencer cannot oblige immediately\n+//! since the values of that variables are not known.  Therefore, it\n+//! creates a new variable that is related to the two regions.  For\n+//! example, the LUB of two variables `$x` and `$y` is a fresh\n+//! variable `$z` that is constrained such that `$x <= $z` and `$y <=\n+//! $z`.  So `V` will contain these intermediate variables as well.\n //!\n //! The other important factor in deciding how to replace a region in T is\n //! the function `Tainted($r)` which, for a region variable, identifies"}, {"sha": "ab0f98ec74a7fe9e8e0bdf4f1973081840f5f466", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 390, "deletions": 221, "changes": 611, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -11,37 +11,40 @@\n //! Helper routines for higher-ranked things. See the `doc` module at\n //! the end of the file for details.\n \n-use super::{combine, cres, InferCtxt, HigherRankedType};\n-use super::combine::Combine;\n-use super::region_inference::{RegionMark};\n+use super::{CombinedSnapshot, cres, InferCtxt, HigherRankedType, SkolemizationMap};\n+use super::combine::{Combine, Combineable};\n \n-use middle::ty::{mod, Ty, replace_late_bound_regions};\n-use middle::ty_fold::{mod, HigherRankedFoldable, TypeFoldable};\n+use middle::ty::{mod, Binder};\n+use middle::ty_fold::{mod, TypeFoldable};\n use syntax::codemap::Span;\n-use util::nodemap::FnvHashMap;\n-use util::ppaux::{bound_region_to_string, Repr};\n-\n-pub trait HigherRankedCombineable<'tcx>: HigherRankedFoldable<'tcx> +\n-                                         TypeFoldable<'tcx> + Repr<'tcx> {\n-    fn super_combine<C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> cres<'tcx, Self>;\n-}\n+use util::nodemap::{FnvHashMap, FnvHashSet};\n+use util::ppaux::Repr;\n \n pub trait HigherRankedRelations<'tcx> {\n-    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n-        where T : HigherRankedCombineable<'tcx>;\n+    fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n+        where T : Combineable<'tcx>;\n+\n+    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n+        where T : Combineable<'tcx>;\n+\n+    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n+        where T : Combineable<'tcx>;\n+}\n \n-    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n-        where T : HigherRankedCombineable<'tcx>;\n+trait InferCtxtExt<'tcx> {\n+    fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region>;\n \n-    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n-        where T : HigherRankedCombineable<'tcx>;\n+    fn region_vars_confined_to_snapshot(&self,\n+                                        snapshot: &CombinedSnapshot)\n+                                        -> Vec<ty::RegionVid>;\n }\n \n impl<'tcx,C> HigherRankedRelations<'tcx> for C\n     where C : Combine<'tcx>\n {\n-    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n-        where T : HigherRankedCombineable<'tcx>\n+    fn higher_ranked_sub<T>(&self, a: &Binder<T>, b: &Binder<T>)\n+                            -> cres<'tcx, Binder<T>>\n+        where T : Combineable<'tcx>\n     {\n         debug!(\"higher_ranked_sub(a={}, b={})\",\n                a.repr(self.tcx()), b.repr(self.tcx()));\n@@ -54,114 +57,95 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n         // please see the large comment at the end of the file in the (inlined) module\n         // `doc`.\n \n-        // Make a mark so we can examine \"all bindings that were\n+        // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        let mark = self.infcx().region_vars.mark();\n-\n-        // First, we instantiate each bound region in the subtype with a fresh\n-        // region variable.\n-        let (a_prime, _) =\n-            self.infcx().replace_late_bound_regions_with_fresh_var(\n-                self.trace().origin.span(),\n-                HigherRankedType,\n-                a);\n-\n-        // Second, we instantiate each bound region in the supertype with a\n-        // fresh concrete region.\n-        let (b_prime, skol_map) = {\n-            replace_late_bound_regions(self.tcx(), b, |br, _| {\n-                let skol = self.infcx().region_vars.new_skolemized(br);\n-                debug!(\"Bound region {} skolemized to {}\",\n-                       bound_region_to_string(self.tcx(), \"\", false, br),\n-                       skol);\n-                skol\n-            })\n-        };\n-\n-        debug!(\"a_prime={}\", a_prime.repr(self.tcx()));\n-        debug!(\"b_prime={}\", b_prime.repr(self.tcx()));\n-\n-        // Compare types now that bound regions have been replaced.\n-        let result = try!(HigherRankedCombineable::super_combine(self, &a_prime, &b_prime));\n-\n-        // Presuming type comparison succeeds, we need to check\n-        // that the skolemized regions do not \"leak\".\n-        let new_vars =\n-            self.infcx().region_vars.vars_created_since_mark(mark);\n-        for (&skol_br, &skol) in skol_map.iter() {\n-            let tainted = self.infcx().region_vars.tainted(mark, skol);\n-            for tainted_region in tainted.iter() {\n-                // Each skolemized should only be relatable to itself\n-                // or new variables:\n-                match *tainted_region {\n-                    ty::ReInfer(ty::ReVar(ref vid)) => {\n-                        if new_vars.iter().any(|x| x == vid) { continue; }\n-                    }\n-                    _ => {\n-                        if *tainted_region == skol { continue; }\n+        return self.infcx().try(|snapshot| {\n+            // First, we instantiate each bound region in the subtype with a fresh\n+            // region variable.\n+            let (a_prime, _) =\n+                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                    self.trace().origin.span(),\n+                    HigherRankedType,\n+                    a);\n+\n+            // Second, we instantiate each bound region in the supertype with a\n+            // fresh concrete region.\n+            let (b_prime, skol_map) =\n+                self.infcx().skolemize_late_bound_regions(b, snapshot);\n+\n+            debug!(\"a_prime={}\", a_prime.repr(self.tcx()));\n+            debug!(\"b_prime={}\", b_prime.repr(self.tcx()));\n+\n+            // Compare types now that bound regions have been replaced.\n+            let result = try!(Combineable::combine(self, &a_prime, &b_prime));\n+\n+            // Presuming type comparison succeeds, we need to check\n+            // that the skolemized regions do not \"leak\".\n+            match leak_check(self.infcx(), &skol_map, snapshot) {\n+                Ok(()) => { }\n+                Err((skol_br, tainted_region)) => {\n+                    if self.a_is_expected() {\n+                        debug!(\"Not as polymorphic!\");\n+                        return Err(ty::terr_regions_insufficiently_polymorphic(skol_br,\n+                                                                               tainted_region));\n+                    } else {\n+                        debug!(\"Overly polymorphic!\");\n+                        return Err(ty::terr_regions_overly_polymorphic(skol_br,\n+                                                                       tainted_region));\n                     }\n-                };\n-\n-                // A is not as polymorphic as B:\n-                if self.a_is_expected() {\n-                    debug!(\"Not as polymorphic!\");\n-                    return Err(ty::terr_regions_insufficiently_polymorphic(\n-                        skol_br, *tainted_region));\n-                } else {\n-                    debug!(\"Overly polymorphic!\");\n-                    return Err(ty::terr_regions_overly_polymorphic(\n-                        skol_br, *tainted_region));\n                 }\n             }\n-        }\n \n-        debug!(\"higher_ranked_sub: OK result={}\",\n-               result.repr(self.tcx()));\n+            debug!(\"higher_ranked_sub: OK result={}\",\n+                   result.repr(self.tcx()));\n \n-        return Ok(result);\n+            Ok(ty::Binder(result))\n+        });\n     }\n \n-    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n-        where T : HigherRankedCombineable<'tcx>\n+    fn higher_ranked_lub<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n+        where T : Combineable<'tcx>\n     {\n-        // Make a mark so we can examine \"all bindings that were\n+        // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        let mark = self.infcx().region_vars.mark();\n-\n-        // Instantiate each bound region with a fresh region variable.\n-        let span = self.trace().origin.span();\n-        let (a_with_fresh, a_map) =\n-            self.infcx().replace_late_bound_regions_with_fresh_var(\n-                span, HigherRankedType, a);\n-        let (b_with_fresh, _) =\n-            self.infcx().replace_late_bound_regions_with_fresh_var(\n-                span, HigherRankedType, b);\n-\n-        // Collect constraints.\n-        let result0 =\n-            try!(HigherRankedCombineable::super_combine(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"lub result0 = {}\", result0.repr(self.tcx()));\n-\n-        // Generalize the regions appearing in result0 if possible\n-        let new_vars = self.infcx().region_vars.vars_created_since_mark(mark);\n-        let span = self.trace().origin.span();\n-        let result1 =\n-            fold_regions_in(\n-                self.tcx(),\n-                &result0,\n-                |r, debruijn| generalize_region(self.infcx(), span, mark, debruijn,\n-                                                new_vars.as_slice(), &a_map, r));\n-\n-        debug!(\"lub({},{}) = {}\",\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()),\n-               result1.repr(self.tcx()));\n-\n-        return Ok(result1);\n+        return self.infcx().try(|snapshot| {\n+            // Instantiate each bound region with a fresh region variable.\n+            let span = self.trace().origin.span();\n+            let (a_with_fresh, a_map) =\n+                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                    span, HigherRankedType, a);\n+            let (b_with_fresh, _) =\n+                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                    span, HigherRankedType, b);\n+\n+            // Collect constraints.\n+            let result0 =\n+                try!(Combineable::combine(self, &a_with_fresh, &b_with_fresh));\n+            let result0 =\n+                self.infcx().resolve_type_vars_if_possible(&result0);\n+            debug!(\"lub result0 = {}\", result0.repr(self.tcx()));\n+\n+            // Generalize the regions appearing in result0 if possible\n+            let new_vars = self.infcx().region_vars_confined_to_snapshot(snapshot);\n+            let span = self.trace().origin.span();\n+            let result1 =\n+                fold_regions_in(\n+                    self.tcx(),\n+                    &result0,\n+                    |r, debruijn| generalize_region(self.infcx(), span, snapshot, debruijn,\n+                                                    new_vars.as_slice(), &a_map, r));\n+\n+            debug!(\"lub({},{}) = {}\",\n+                   a.repr(self.tcx()),\n+                   b.repr(self.tcx()),\n+                   result1.repr(self.tcx()));\n+\n+            Ok(ty::Binder(result1))\n+        });\n \n         fn generalize_region(infcx: &InferCtxt,\n                              span: Span,\n-                             mark: RegionMark,\n+                             snapshot: &CombinedSnapshot,\n                              debruijn: ty::DebruijnIndex,\n                              new_vars: &[ty::RegionVid],\n                              a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n@@ -174,7 +158,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                 return r0;\n             }\n \n-            let tainted = infcx.region_vars.tainted(mark, r0);\n+            let tainted = infcx.tainted_regions(snapshot, r0);\n \n             // Variables created during LUB computation which are\n             // *related* to regions that pre-date the LUB computation\n@@ -209,53 +193,55 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n         }\n     }\n \n-    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<'tcx, T>\n-        where T : HigherRankedCombineable<'tcx>\n+    fn higher_ranked_glb<T>(&self, a: &Binder<T>, b: &Binder<T>) -> cres<'tcx, Binder<T>>\n+        where T : Combineable<'tcx>\n     {\n         debug!(\"{}.higher_ranked_glb({}, {})\",\n                self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n \n-        // Make a mark so we can examine \"all bindings that were\n+        // Make a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n-        let mark = self.infcx().region_vars.mark();\n-\n-        // Instantiate each bound region with a fresh region variable.\n-        let (a_with_fresh, a_map) =\n-            self.infcx().replace_late_bound_regions_with_fresh_var(\n-                self.trace().origin.span(), HigherRankedType, a);\n-        let (b_with_fresh, b_map) =\n-            self.infcx().replace_late_bound_regions_with_fresh_var(\n-                self.trace().origin.span(), HigherRankedType, b);\n-        let a_vars = var_ids(self, &a_map);\n-        let b_vars = var_ids(self, &b_map);\n-\n-        // Collect constraints.\n-        let result0 =\n-            try!(HigherRankedCombineable::super_combine(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"glb result0 = {}\", result0.repr(self.tcx()));\n-\n-        // Generalize the regions appearing in fn_ty0 if possible\n-        let new_vars = self.infcx().region_vars.vars_created_since_mark(mark);\n-        let span = self.trace().origin.span();\n-        let result1 =\n-            fold_regions_in(\n-                self.tcx(),\n-                &result0,\n-                |r, debruijn| generalize_region(self.infcx(), span, mark, debruijn,\n-                                                new_vars.as_slice(),\n-                                                &a_map, a_vars.as_slice(), b_vars.as_slice(),\n-                                                r));\n-\n-        debug!(\"glb({},{}) = {}\",\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()),\n-               result1.repr(self.tcx()));\n-\n-        return Ok(result1);\n+        return self.infcx().try(|snapshot| {\n+            // Instantiate each bound region with a fresh region variable.\n+            let (a_with_fresh, a_map) =\n+                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                    self.trace().origin.span(), HigherRankedType, a);\n+            let (b_with_fresh, b_map) =\n+                self.infcx().replace_late_bound_regions_with_fresh_var(\n+                    self.trace().origin.span(), HigherRankedType, b);\n+            let a_vars = var_ids(self, &a_map);\n+            let b_vars = var_ids(self, &b_map);\n+\n+            // Collect constraints.\n+            let result0 =\n+                try!(Combineable::combine(self, &a_with_fresh, &b_with_fresh));\n+            let result0 =\n+                self.infcx().resolve_type_vars_if_possible(&result0);\n+            debug!(\"glb result0 = {}\", result0.repr(self.tcx()));\n+\n+            // Generalize the regions appearing in result0 if possible\n+            let new_vars = self.infcx().region_vars_confined_to_snapshot(snapshot);\n+            let span = self.trace().origin.span();\n+            let result1 =\n+                fold_regions_in(\n+                    self.tcx(),\n+                    &result0,\n+                    |r, debruijn| generalize_region(self.infcx(), span, snapshot, debruijn,\n+                                                    new_vars.as_slice(),\n+                                                    &a_map, a_vars.as_slice(), b_vars.as_slice(),\n+                                                    r));\n+\n+            debug!(\"glb({},{}) = {}\",\n+                   a.repr(self.tcx()),\n+                   b.repr(self.tcx()),\n+                   result1.repr(self.tcx()));\n+\n+            Ok(ty::Binder(result1))\n+        });\n \n         fn generalize_region(infcx: &InferCtxt,\n                              span: Span,\n-                             mark: RegionMark,\n+                             snapshot: &CombinedSnapshot,\n                              debruijn: ty::DebruijnIndex,\n                              new_vars: &[ty::RegionVid],\n                              a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n@@ -267,7 +253,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                 return r0;\n             }\n \n-            let tainted = infcx.region_vars.tainted(mark, r0);\n+            let tainted = infcx.tainted_regions(snapshot, r0);\n \n             let mut a_r = None;\n             let mut b_r = None;\n@@ -345,67 +331,6 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n     }\n }\n \n-impl<'tcx> HigherRankedCombineable<'tcx> for ty::FnSig<'tcx> {\n-    fn super_combine<C:Combine<'tcx>>(combiner: &C, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n-                                      -> cres<'tcx, ty::FnSig<'tcx>>\n-    {\n-        if a.variadic != b.variadic {\n-            return Err(ty::terr_variadic_mismatch(\n-                combine::expected_found(combiner, a.variadic, b.variadic)));\n-        }\n-\n-        let inputs = try!(argvecs(combiner,\n-                                  a.inputs.as_slice(),\n-                                  b.inputs.as_slice()));\n-\n-        let output = try!(match (a.output, b.output) {\n-            (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n-                Ok(ty::FnConverging(try!(combiner.tys(a_ty, b_ty)))),\n-            (ty::FnDiverging, ty::FnDiverging) =>\n-                Ok(ty::FnDiverging),\n-            (a, b) =>\n-                Err(ty::terr_convergence_mismatch(\n-                    combine::expected_found(combiner, a != ty::FnDiverging, b != ty::FnDiverging))),\n-        });\n-\n-        return Ok(ty::FnSig {inputs: inputs,\n-                             output: output,\n-                             variadic: a.variadic});\n-\n-\n-        fn argvecs<'tcx, C: Combine<'tcx>>(combiner: &C,\n-                                           a_args: &[Ty<'tcx>],\n-                                           b_args: &[Ty<'tcx>])\n-                                           -> cres<'tcx, Vec<Ty<'tcx>>>\n-        {\n-            if a_args.len() == b_args.len() {\n-                a_args.iter().zip(b_args.iter())\n-                    .map(|(a, b)| combiner.args(*a, *b)).collect()\n-            } else {\n-                Err(ty::terr_arg_count)\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> HigherRankedCombineable<'tcx> for ty::TraitRef<'tcx> {\n-    fn super_combine<C:Combine<'tcx>>(combiner: &C,\n-                                      a: &ty::TraitRef<'tcx>,\n-                                      b: &ty::TraitRef<'tcx>)\n-                                      -> cres<'tcx, ty::TraitRef<'tcx>>\n-    {\n-        // Different traits cannot be related\n-        if a.def_id != b.def_id {\n-            Err(ty::terr_traits(\n-                combine::expected_found(combiner, a.def_id, b.def_id)))\n-        } else {\n-            let substs = try!(combiner.substs(a.def_id, &a.substs, &b.substs));\n-            Ok(ty::TraitRef { def_id: a.def_id,\n-                              substs: substs })\n-        }\n-    }\n-}\n-\n fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n                                    map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n                                    -> Vec<ty::RegionVid> {\n@@ -426,11 +351,14 @@ fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n     }\n }\n \n-fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>, value: &T, mut fldr: F) -> T where\n-    T: HigherRankedFoldable<'tcx>,\n-    F: FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n+fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>,\n+                               unbound_value: &T,\n+                               mut fldr: F)\n+                               -> T\n+    where T : Combineable<'tcx>,\n+          F : FnMut(ty::Region, ty::DebruijnIndex) -> ty::Region,\n {\n-    value.fold_contents(&mut ty_fold::RegionFolder::new(tcx, |region, current_depth| {\n+    unbound_value.fold_with(&mut ty_fold::RegionFolder::new(tcx, &mut |region, current_depth| {\n         // we should only be encountering \"escaping\" late-bound regions here,\n         // because the ones at the current level should have been replaced\n         // with fresh variables\n@@ -443,3 +371,244 @@ fn fold_regions_in<'tcx, T, F>(tcx: &ty::ctxt<'tcx>, value: &T, mut fldr: F) ->\n     }))\n }\n \n+impl<'a,'tcx> InferCtxtExt<'tcx> for InferCtxt<'a,'tcx> {\n+    fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region> {\n+        self.region_vars.tainted(&snapshot.region_vars_snapshot, r)\n+    }\n+\n+    fn region_vars_confined_to_snapshot(&self,\n+                                        snapshot: &CombinedSnapshot)\n+                                        -> Vec<ty::RegionVid>\n+    {\n+        /*!\n+         * Returns the set of region variables that do not affect any\n+         * types/regions which existed before `snapshot` was\n+         * started. This is used in the sub/lub/glb computations. The\n+         * idea here is that when we are computing lub/glb of two\n+         * regions, we sometimes create intermediate region variables.\n+         * Those region variables may touch some of the skolemized or\n+         * other \"forbidden\" regions we created to replace bound\n+         * regions, but they don't really represent an \"external\"\n+         * constraint.\n+         *\n+         * However, sometimes fresh variables are created for other\n+         * purposes too, and those *may* represent an external\n+         * constraint. In particular, when a type variable is\n+         * instantiated, we create region variables for all the\n+         * regions that appear within, and if that type variable\n+         * pre-existed the snapshot, then those region variables\n+         * represent external constraints.\n+         *\n+         * An example appears in the unit test\n+         * `sub_free_bound_false_infer`.  In this test, we want to\n+         * know whether\n+         *\n+         * ```rust\n+         * fn(_#0t) <: for<'a> fn(&'a int)\n+         * ```\n+         *\n+         * Note that the subtype has a type variable. Because the type\n+         * variable can't be instantiated with a region that is bound\n+         * in the fn signature, this comparison ought to fail. But if\n+         * we're not careful, it will succeed.\n+         *\n+         * The reason is that when we walk through the subtyping\n+         * algorith, we begin by replacing `'a` with a skolemized\n+         * variable `'1`. We then have `fn(_#0t) <: fn(&'1 int)`. This\n+         * can be made true by unifying `_#0t` with `&'1 int`. In the\n+         * process, we create a fresh variable for the skolemized\n+         * region, `'$2`, and hence we have that `_#0t == &'$2\n+         * int`. However, because `'$2` was created during the sub\n+         * computation, if we're not careful we will erroneously\n+         * assume it is one of the transient region variables\n+         * representing a lub/glb internally. Not good.\n+         *\n+         * To prevent this, we check for type variables which were\n+         * unified during the snapshot, and say that any region\n+         * variable created during the snapshot but which finds its\n+         * way into a type variable is considered to \"escape\" the\n+         * snapshot.\n+         */\n+\n+        let mut region_vars =\n+            self.region_vars.vars_created_since_snapshot(&snapshot.region_vars_snapshot);\n+\n+        let escaping_types =\n+            self.type_variables.borrow().types_escaping_snapshot(&snapshot.type_snapshot);\n+\n+        let escaping_region_vars: FnvHashSet<_> =\n+            escaping_types\n+            .iter()\n+            .flat_map(|&t| ty_fold::collect_regions(self.tcx, &t).into_iter())\n+            .collect();\n+\n+        region_vars.retain(|&region_vid| {\n+            let r = ty::ReInfer(ty::ReVar(region_vid));\n+            !escaping_region_vars.contains(&r)\n+        });\n+\n+        debug!(\"region_vars_confined_to_snapshot: region_vars={} escaping_types={}\",\n+               region_vars.repr(self.tcx),\n+               escaping_types.repr(self.tcx));\n+\n+        region_vars\n+    }\n+}\n+\n+pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n+                                               binder: &ty::Binder<T>,\n+                                               snapshot: &CombinedSnapshot)\n+                                               -> (T, SkolemizationMap)\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+{\n+    /*!\n+     * Replace all regions bound by `binder` with skolemized regions and\n+     * return a map indicating which bound-region was replaced with what\n+     * skolemized region. This is the first step of checking subtyping\n+     * when higher-ranked things are involved. See `doc.rs` for more details.\n+     */\n+\n+    let (result, map) = ty::replace_late_bound_regions(infcx.tcx, binder, |br, _| {\n+        infcx.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n+    });\n+\n+    debug!(\"skolemize_bound_regions(binder={}, result={}, map={})\",\n+           binder.repr(infcx.tcx),\n+           result.repr(infcx.tcx),\n+           map.repr(infcx.tcx));\n+\n+    (result, map)\n+}\n+\n+pub fn leak_check<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                           skol_map: &SkolemizationMap,\n+                           snapshot: &CombinedSnapshot)\n+                           -> Result<(),(ty::BoundRegion,ty::Region)>\n+{\n+    /*!\n+     * Searches the region constriants created since `snapshot` was started\n+     * and checks to determine whether any of the skolemized regions created\n+     * in `skol_map` would \"escape\" -- meaning that they are related to\n+     * other regions in some way. If so, the higher-ranked subtyping doesn't\n+     * hold. See `doc.rs` for more details.\n+     */\n+\n+    debug!(\"leak_check: skol_map={}\",\n+           skol_map.repr(infcx.tcx));\n+\n+    let new_vars = infcx.region_vars_confined_to_snapshot(snapshot);\n+    for (&skol_br, &skol) in skol_map.iter() {\n+        let tainted = infcx.tainted_regions(snapshot, skol);\n+        for &tainted_region in tainted.iter() {\n+            // Each skolemized should only be relatable to itself\n+            // or new variables:\n+            match tainted_region {\n+                ty::ReInfer(ty::ReVar(vid)) => {\n+                    if new_vars.iter().any(|&x| x == vid) { continue; }\n+                }\n+                _ => {\n+                    if tainted_region == skol { continue; }\n+                }\n+            };\n+\n+            debug!(\"{} (which replaced {}) is tainted by {}\",\n+                   skol.repr(infcx.tcx),\n+                   skol_br.repr(infcx.tcx),\n+                   tainted_region.repr(infcx.tcx));\n+\n+            // A is not as polymorphic as B:\n+            return Err((skol_br, tainted_region));\n+        }\n+    }\n+    Ok(())\n+}\n+\n+/// This code converts from skolemized regions back to late-bound\n+/// regions. It works by replacing each region in the taint set of a\n+/// skolemized region with a bound-region. The bound region will be bound\n+/// by the outer-most binder in `value`; the caller must ensure that there is\n+/// such a binder and it is the right place.\n+///\n+/// This routine is only intended to be used when the leak-check has\n+/// passed; currently, it's used in the trait matching code to create\n+/// a set of nested obligations frmo an impl that matches against\n+/// something higher-ranked.  More details can be found in\n+/// `middle::traits::doc.rs`.\n+///\n+/// As a brief example, consider the obligation `for<'a> Fn(&'a int)\n+/// -> &'a int`, and the impl:\n+///\n+///     impl<A,R> Fn<A,R> for SomethingOrOther\n+///         where A : Clone\n+///     { ... }\n+///\n+/// Here we will have replaced `'a` with a skolemized region\n+/// `'0`. This means that our substitution will be `{A=>&'0\n+/// int, R=>&'0 int}`.\n+///\n+/// When we apply the substitution to the bounds, we will wind up with\n+/// `&'0 int : Clone` as a predicate. As a last step, we then go and\n+/// replace `'0` with a late-bound region `'a`.  The depth is matched\n+/// to the depth of the predicate, in this case 1, so that the final\n+/// predicate is `for<'a> &'a int : Clone`.\n+pub fn plug_leaks<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n+                             skol_map: SkolemizationMap,\n+                             snapshot: &CombinedSnapshot,\n+                             value: &T)\n+                             -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+{\n+    debug_assert!(leak_check(infcx, &skol_map, snapshot).is_ok());\n+\n+    debug!(\"plug_leaks(skol_map={}, value={})\",\n+           skol_map.repr(infcx.tcx),\n+           value.repr(infcx.tcx));\n+\n+    // Compute a mapping from the \"taint set\" of each skolemized\n+    // region back to the `ty::BoundRegion` that it originally\n+    // represented. Because `leak_check` passed, we know that that\n+    // these taint sets are mutually disjoint.\n+    let inv_skol_map: FnvHashMap<ty::Region, ty::BoundRegion> =\n+        skol_map\n+        .into_iter()\n+        .flat_map(|(skol_br, skol)| {\n+            infcx.tainted_regions(snapshot, skol)\n+                .into_iter()\n+                .map(move |tainted_region| (tainted_region, skol_br))\n+        })\n+        .collect();\n+\n+    debug!(\"plug_leaks: inv_skol_map={}\",\n+           inv_skol_map.repr(infcx.tcx));\n+\n+    // Remove any instantiated type variables from `value`; those can hide\n+    // references to regions from the `fold_regions` code below.\n+    let value = infcx.resolve_type_vars_if_possible(value);\n+\n+    // Map any skolemization byproducts back to a late-bound\n+    // region. Put that late-bound region at whatever the outermost\n+    // binder is that we encountered in `value`. The caller is\n+    // responsible for ensuring that (a) `value` contains at least one\n+    // binder and (b) that binder is the one we want to use.\n+    let result = ty_fold::fold_regions(infcx.tcx, &value, |r, current_depth| {\n+        match inv_skol_map.get(&r) {\n+            None => r,\n+            Some(br) => {\n+                // It is the responsibility of the caller to ensure\n+                // that each skolemized region appears within a\n+                // binder. In practice, this routine is only used by\n+                // trait checking, and all of the skolemized regions\n+                // appear inside predicates, which always have\n+                // binders, so this assert is satisfied.\n+                assert!(current_depth > 1);\n+\n+                ty::ReLateBound(ty::DebruijnIndex::new(current_depth - 1), br.clone())\n+            }\n+        }\n+    });\n+\n+    debug!(\"plug_leaks: result={}\",\n+           result.repr(infcx.tcx));\n+\n+    result\n+}"}, {"sha": "f4909b2889163c73217538da16a65489c0375da9", "filename": "src/librustc/middle/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Flub.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -113,17 +113,13 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n         Ok(self.infcx().region_vars.lub_regions(Subtype(self.trace()), a, b))\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n-               -> cres<'tcx, ty::FnSig<'tcx>> {\n-        self.higher_ranked_lub(a, b)\n-    }\n-\n     fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> cres<'tcx, Ty<'tcx>> {\n         super_lattice_tys(self, a, b)\n     }\n \n-    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n-                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n+    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n+        where T : Combineable<'tcx>\n+    {\n         self.higher_ranked_lub(a, b)\n     }\n }"}, {"sha": "f419f050cf5943f9b3d4cde20a1bac5809c4d93b", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 149, "deletions": 93, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -19,21 +19,14 @@ pub use self::TypeOrigin::*;\n pub use self::ValuePairs::*;\n pub use self::fixup_err::*;\n pub use middle::ty::IntVarValue;\n-pub use self::resolve::resolve_and_force_all_but_regions;\n-pub use self::resolve::{force_all, not_regions};\n-pub use self::resolve::{force_ivar};\n-pub use self::resolve::{force_tvar, force_rvar};\n-pub use self::resolve::{resolve_ivar, resolve_all};\n-pub use self::resolve::{resolve_nested_tvar};\n-pub use self::resolve::{resolve_rvar};\n-pub use self::skolemize::TypeSkolemizer;\n+pub use self::freshen::TypeFreshener;\n \n use middle::subst;\n use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n use middle::ty::replace_late_bound_regions;\n use middle::ty::{mod, Ty};\n-use middle::ty_fold::{HigherRankedFoldable, TypeFolder, TypeFoldable};\n+use middle::ty_fold::{TypeFolder, TypeFoldable};\n use std::cell::{RefCell};\n use std::rc::Rc;\n use syntax::ast;\n@@ -42,12 +35,11 @@ use syntax::codemap::Span;\n use util::common::indent;\n use util::nodemap::FnvHashMap;\n use util::ppaux::{ty_to_string};\n-use util::ppaux::{trait_ref_to_string, Repr};\n+use util::ppaux::{Repr, UserString};\n \n use self::coercion::Coerce;\n use self::combine::{Combine, CombineFields};\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n-use self::resolve::{resolver};\n use self::equate::Equate;\n use self::sub::Sub;\n use self::lub::Lub;\n@@ -60,12 +52,12 @@ pub mod doc;\n pub mod equate;\n pub mod error_reporting;\n pub mod glb;\n-pub mod higher_ranked;\n+mod higher_ranked;\n pub mod lattice;\n pub mod lub;\n pub mod region_inference;\n pub mod resolve;\n-mod skolemize;\n+mod freshen;\n pub mod sub;\n pub mod type_variable;\n pub mod unify;\n@@ -98,6 +90,10 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n         RegionVarBindings<'a, 'tcx>,\n }\n \n+/// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n+/// region that each late-bound region was replaced with.\n+pub type SkolemizationMap = FnvHashMap<ty::BoundRegion,ty::Region>;\n+\n /// Why did we require that the two types be related?\n ///\n /// See `error_reporting.rs` for more details\n@@ -142,6 +138,7 @@ impl Copy for TypeOrigin {}\n pub enum ValuePairs<'tcx> {\n     Types(ty::expected_found<Ty<'tcx>>),\n     TraitRefs(ty::expected_found<Rc<ty::TraitRef<'tcx>>>),\n+    PolyTraitRefs(ty::expected_found<Rc<ty::PolyTraitRef<'tcx>>>),\n }\n \n /// The trace designates the path through inference that we took to\n@@ -353,7 +350,7 @@ pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                               b: Ty<'tcx>)\n                               -> ures<'tcx> {\n     debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.probe(|| {\n+    cx.probe(|_| {\n         let trace = TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n             values: Types(expected_found(true, a, b))\n@@ -366,7 +363,7 @@ pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                              a: Ty<'tcx>, b: Ty<'tcx>)\n                              -> ures<'tcx> {\n     debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.probe(|| {\n+    cx.probe(|_| {\n         let trace = TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),\n             values: Types(expected_found(true, a, b))\n@@ -410,17 +407,17 @@ pub fn mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n         || cx.eq_types(a_is_expected, origin, a, b))\n }\n \n-pub fn mk_sub_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n+pub fn mk_sub_poly_trait_refs<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n                                    a_is_expected: bool,\n                                    origin: TypeOrigin,\n-                                   a: Rc<ty::TraitRef<'tcx>>,\n-                                   b: Rc<ty::TraitRef<'tcx>>)\n+                                   a: Rc<ty::PolyTraitRef<'tcx>>,\n+                                   b: Rc<ty::PolyTraitRef<'tcx>>)\n                                    -> ures<'tcx>\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n            a.repr(cx.tcx), b.repr(cx.tcx));\n     cx.commit_if_ok(\n-        || cx.sub_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n+        || cx.sub_poly_trait_refs(a_is_expected, origin, a.clone(), b.clone()))\n }\n \n fn expected_found<T>(a_is_expected: bool,\n@@ -453,22 +450,6 @@ pub fn mk_coercety<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n     })\n }\n \n-// See comment on the type `resolve_state` below\n-pub fn resolve_type<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                              span: Option<Span>,\n-                              a: Ty<'tcx>,\n-                              modes: uint)\n-                              -> fres<Ty<'tcx>> {\n-    let mut resolver = resolver(cx, modes, span);\n-    cx.commit_unconditionally(|| resolver.resolve_type_chk(a))\n-}\n-\n-pub fn resolve_region(cx: &InferCtxt, r: ty::Region, modes: uint)\n-                      -> fres<ty::Region> {\n-    let mut resolver = resolver(cx, modes, None);\n-    resolver.resolve_region_chk(r)\n-}\n-\n trait then<'tcx> {\n     fn then<T, F>(&self, f: F) -> Result<T, ty::type_err<'tcx>> where\n         T: Clone,\n@@ -520,6 +501,7 @@ pub fn uok<'tcx>() -> ures<'tcx> {\n     Ok(())\n }\n \n+#[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot {\n     type_snapshot: type_variable::Snapshot,\n     int_snapshot: unify::Snapshot<ty::IntVid>,\n@@ -528,8 +510,8 @@ pub struct CombinedSnapshot {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn skolemize<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n-        t.fold_with(&mut self.skolemizer())\n+    pub fn freshen<T:TypeFoldable<'tcx>>(&self, t: T) -> T {\n+        t.fold_with(&mut self.freshener())\n     }\n \n     pub fn type_var_diverges(&'a self, ty: Ty) -> bool {\n@@ -539,8 +521,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn skolemizer<'b>(&'b self) -> TypeSkolemizer<'b, 'tcx> {\n-        skolemize::TypeSkolemizer::new(self)\n+    pub fn freshener<'b>(&'b self) -> TypeFreshener<'b, 'tcx> {\n+        freshen::TypeFreshener::new(self)\n     }\n \n     pub fn combine_fields<'b>(&'b self, a_is_expected: bool, trace: TypeTrace<'tcx>)\n@@ -629,16 +611,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn commit_if_ok<T, E, F>(&self, f: F) -> Result<T, E> where\n         F: FnOnce() -> Result<T, E>\n     {\n-        self.commit_unconditionally(move || self.try(move || f()))\n+        self.commit_unconditionally(move || self.try(move |_| f()))\n     }\n \n     /// Execute `f`, unroll bindings on panic\n     pub fn try<T, E, F>(&self, f: F) -> Result<T, E> where\n-        F: FnOnce() -> Result<T, E>\n+        F: FnOnce(&CombinedSnapshot) -> Result<T, E>\n     {\n         debug!(\"try()\");\n         let snapshot = self.start_snapshot();\n-        let r = f();\n+        let r = f(&snapshot);\n         debug!(\"try() -- r.is_ok() = {}\", r.is_ok());\n         match r {\n             Ok(_) => {\n@@ -653,11 +635,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     /// Execute `f` then unroll any bindings it creates\n     pub fn probe<R, F>(&self, f: F) -> R where\n-        F: FnOnce() -> R,\n+        F: FnOnce(&CombinedSnapshot) -> R,\n     {\n         debug!(\"probe()\");\n         let snapshot = self.start_snapshot();\n-        let r = f();\n+        let r = f(&snapshot);\n         self.rollback_to(snapshot);\n         r\n     }\n@@ -715,15 +697,93 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         self.commit_if_ok(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n-                values: TraitRefs(expected_found(a_is_expected,\n-                                                 a.clone(), b.clone()))\n+                values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n             self.sub(a_is_expected, trace).trait_refs(&*a, &*b).to_ures()\n         })\n     }\n-}\n \n-impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    pub fn sub_poly_trait_refs(&self,\n+                               a_is_expected: bool,\n+                               origin: TypeOrigin,\n+                               a: Rc<ty::PolyTraitRef<'tcx>>,\n+                               b: Rc<ty::PolyTraitRef<'tcx>>)\n+                               -> ures<'tcx>\n+    {\n+        debug!(\"sub_poly_trait_refs({} <: {})\",\n+               a.repr(self.tcx),\n+               b.repr(self.tcx));\n+        self.commit_if_ok(|| {\n+            let trace = TypeTrace {\n+                origin: origin,\n+                values: PolyTraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n+            };\n+            self.sub(a_is_expected, trace).binders(&*a, &*b).to_ures()\n+        })\n+    }\n+\n+    pub fn skolemize_late_bound_regions<T>(&self,\n+                                           value: &ty::Binder<T>,\n+                                           snapshot: &CombinedSnapshot)\n+                                           -> (T, SkolemizationMap)\n+        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    {\n+        /*! See `higher_ranked::skolemize_late_bound_regions` */\n+\n+        higher_ranked::skolemize_late_bound_regions(self, value, snapshot)\n+    }\n+\n+    pub fn leak_check(&self,\n+                      skol_map: &SkolemizationMap,\n+                      snapshot: &CombinedSnapshot)\n+                      -> ures<'tcx>\n+    {\n+        /*! See `higher_ranked::leak_check` */\n+\n+        match higher_ranked::leak_check(self, skol_map, snapshot) {\n+            Ok(()) => Ok(()),\n+            Err((br, r)) => Err(ty::terr_regions_insufficiently_polymorphic(br, r))\n+        }\n+    }\n+\n+    pub fn plug_leaks<T>(&self,\n+                         skol_map: SkolemizationMap,\n+                         snapshot: &CombinedSnapshot,\n+                         value: &T)\n+                         -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    {\n+        /*! See `higher_ranked::leak_check` */\n+\n+        higher_ranked::plug_leaks(self, skol_map, snapshot, value)\n+    }\n+\n+    pub fn equality_predicate(&self,\n+                              span: Span,\n+                              predicate: &ty::PolyEquatePredicate<'tcx>)\n+                              -> ures<'tcx> {\n+        self.try(|snapshot| {\n+            let (ty::EquatePredicate(a, b), skol_map) =\n+                self.skolemize_late_bound_regions(predicate, snapshot);\n+            let origin = EquatePredicate(span);\n+            let () = try!(mk_eqty(self, false, origin, a, b));\n+            self.leak_check(&skol_map, snapshot)\n+        })\n+    }\n+\n+    pub fn region_outlives_predicate(&self,\n+                                     span: Span,\n+                                     predicate: &ty::PolyRegionOutlivesPredicate)\n+                                     -> ures<'tcx> {\n+        self.try(|snapshot| {\n+            let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n+                self.skolemize_late_bound_regions(predicate, snapshot);\n+            let origin = RelateRegionParamBound(span);\n+            let () = mk_subr(self, origin, r_b, r_a); // `b : a` ==> `a <= b`\n+            self.leak_check(&skol_map, snapshot)\n+        })\n+    }\n+\n     pub fn next_ty_var_id(&self, diverging: bool) -> TyVid {\n         self.type_variables\n             .borrow_mut()\n@@ -821,7 +881,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn ty_to_string(&self, t: Ty<'tcx>) -> String {\n         ty_to_string(self.tcx,\n-                     self.resolve_type_vars_if_possible(t))\n+                     self.resolve_type_vars_if_possible(&t))\n     }\n \n     pub fn tys_to_string(&self, ts: &[Ty<'tcx>]) -> String {\n@@ -830,24 +890,25 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n \n     pub fn trait_ref_to_string(&self, t: &Rc<ty::TraitRef<'tcx>>) -> String {\n-        let t = self.resolve_type_vars_in_trait_ref_if_possible(&**t);\n-        trait_ref_to_string(self.tcx, &t)\n-    }\n-\n-    pub fn contains_unbound_type_variables(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        match resolve_type(self,\n-                           None,\n-                           typ, resolve_nested_tvar | resolve_ivar) {\n-          Ok(new_type) => new_type,\n-          Err(_) => typ\n-        }\n+        let t = self.resolve_type_vars_if_possible(&**t);\n+        t.user_string(self.tcx)\n     }\n \n     pub fn shallow_resolve(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match typ.sty {\n             ty::ty_infer(ty::TyVar(v)) => {\n+                // Not entirely obvious: if `typ` is a type variable,\n+                // it can be resolved to an int/float variable, which\n+                // can then be recursively resolved, hence the\n+                // recursion. Note though that we prevent type\n+                // variables from unifying to other type variables\n+                // directly (though they may be embedded\n+                // structurally), and we prevent cycles in any case,\n+                // so this recursion should always be of very limited\n+                // depth.\n                 self.type_variables.borrow()\n                     .probe(v)\n+                    .map(|t| self.shallow_resolve(t))\n                     .unwrap_or(typ)\n             }\n \n@@ -867,35 +928,32 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn resolve_type_vars_if_possible(&self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        match resolve_type(self,\n-                           None,\n-                           typ, resolve_nested_tvar | resolve_ivar) {\n-          Ok(new_type) => new_type,\n-          Err(_) => typ\n-        }\n+    pub fn resolve_type_vars_if_possible<T:TypeFoldable<'tcx>>(&self, value: &T) -> T {\n+        /*!\n+         * Where possible, replaces type/int/float variables in\n+         * `value` with their final value. Note that region variables\n+         * are unaffected. If a type variable has not been unified, it\n+         * is left as is.  This is an idempotent operation that does\n+         * not affect inference state in any way and so you can do it\n+         * at will.\n+         */\n+\n+        let mut r = resolve::OpportunisticTypeResolver::new(self);\n+        value.fold_with(&mut r)\n     }\n \n-    pub fn resolve_type_vars_in_trait_ref_if_possible(&self,\n-                                                      trait_ref: &ty::TraitRef<'tcx>)\n-                                                      -> ty::TraitRef<'tcx> {\n-        // make up a dummy type just to reuse/abuse the resolve machinery\n-        let dummy0 = ty::mk_trait(self.tcx,\n-                                  (*trait_ref).clone(),\n-                                  ty::region_existential_bound(ty::ReStatic));\n-        let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n-        match dummy1.sty {\n-            ty::ty_trait(box ty::TyTrait { ref principal, .. }) => {\n-                (*principal).clone()\n-            }\n-            _ => {\n-                self.tcx.sess.bug(\n-                    format!(\"resolve_type_vars_if_possible() yielded {} \\\n-                             when supplied with {}\",\n-                            self.ty_to_string(dummy0),\n-                            self.ty_to_string(dummy1)).as_slice());\n-            }\n-        }\n+    pub fn fully_resolve<T:TypeFoldable<'tcx>>(&self, value: &T) -> fres<T> {\n+        /*!\n+         * Attempts to resolve all type/region variables in\n+         * `value`. Region inference must have been run already (e.g.,\n+         * by calling `resolve_regions_and_report_errors`).  If some\n+         * variable was never unified, an `Err` results.\n+         *\n+         * This method is idempotent, but it not typically not invoked\n+         * except during the writeback phase.\n+         */\n+\n+        resolve::fully_resolve(self, value)\n     }\n \n     // [Note-Type-error-reporting]\n@@ -929,9 +987,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     {\n         debug!(\"hi! expected_ty = {}, actual_ty = {}\", expected_ty, actual_ty);\n \n-        let resolved_expected = expected_ty.map(|e_ty| {\n-            self.resolve_type_vars_if_possible(e_ty)\n-        });\n+        let resolved_expected = expected_ty.map(|e_ty| self.resolve_type_vars_if_possible(&e_ty));\n \n         match resolved_expected {\n             Some(t) if ty::type_is_error(t) => (),\n@@ -958,7 +1014,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                  err: Option<&ty::type_err<'tcx>>) where\n         M: FnOnce(String) -> String,\n     {\n-        let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n+        let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n \n         // Don't report an error if actual type is ty_err.\n         if ty::type_is_error(actual_ty) {\n@@ -989,9 +1045,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n-        value: &T)\n+        value: &ty::Binder<T>)\n         -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n-        where T : HigherRankedFoldable<'tcx>\n+        where T : TypeFoldable<'tcx> + Repr<'tcx>\n     {\n         ty::replace_late_bound_regions(\n             self.tcx,"}, {"sha": "d34373e66a1e029aceae2923c462f5510d7eaa00", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -81,7 +81,6 @@ impl Copy for TwoRegions {}\n pub enum UndoLogEntry {\n     OpenSnapshot,\n     CommitedSnapshot,\n-    Mark,\n     AddVar(RegionVid),\n     AddConstraint(Constraint),\n     AddVerify(uint),\n@@ -225,19 +224,12 @@ pub struct RegionVarBindings<'a, 'tcx: 'a> {\n }\n \n #[deriving(Show)]\n+#[allow(missing_copy_implementations)]\n pub struct RegionSnapshot {\n-    length: uint\n+    length: uint,\n+    skolemization_count: uint,\n }\n \n-impl Copy for RegionSnapshot {}\n-\n-#[deriving(Show)]\n-pub struct RegionMark {\n-    length: uint\n-}\n-\n-impl Copy for RegionMark {}\n-\n impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     pub fn new(tcx: &'a ty::ctxt<'tcx>) -> RegionVarBindings<'a, 'tcx> {\n         RegionVarBindings {\n@@ -263,14 +255,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         let length = self.undo_log.borrow().len();\n         debug!(\"RegionVarBindings: start_snapshot({})\", length);\n         self.undo_log.borrow_mut().push(OpenSnapshot);\n-        RegionSnapshot { length: length }\n-    }\n-\n-    pub fn mark(&self) -> RegionMark {\n-        let length = self.undo_log.borrow().len();\n-        debug!(\"RegionVarBindings: mark({})\", length);\n-        self.undo_log.borrow_mut().push(Mark);\n-        RegionMark { length: length }\n+        RegionSnapshot { length: length, skolemization_count: self.skolemization_count.get() }\n     }\n \n     pub fn commit(&self, snapshot: RegionSnapshot) {\n@@ -284,6 +269,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         } else {\n             (*undo_log)[snapshot.length] = CommitedSnapshot;\n         }\n+        self.skolemization_count.set(snapshot.skolemization_count);\n     }\n \n     pub fn rollback_to(&self, snapshot: RegionSnapshot) {\n@@ -296,7 +282,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 OpenSnapshot => {\n                     panic!(\"Failure to observe stack discipline\");\n                 }\n-                Mark | CommitedSnapshot => { }\n+                CommitedSnapshot => { }\n                 AddVar(vid) => {\n                     let mut var_origins = self.var_origins.borrow_mut();\n                     var_origins.pop().unwrap();\n@@ -322,6 +308,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         }\n         let c = undo_log.pop().unwrap();\n         assert!(c == OpenSnapshot);\n+        self.skolemization_count.set(snapshot.skolemization_count);\n     }\n \n     pub fn num_vars(&self) -> uint {\n@@ -340,7 +327,25 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         return vid;\n     }\n \n-    pub fn new_skolemized(&self, br: ty::BoundRegion) -> Region {\n+    /// Creates a new skolemized region. Skolemized regions are fresh\n+    /// regions used when performing higher-ranked computations. They\n+    /// must be used in a very particular way and are never supposed\n+    /// to \"escape\" out into error messages or the code at large.\n+    ///\n+    /// The idea is to always create a snapshot. Skolemized regions\n+    /// can be created in the context of this snapshot, but once the\n+    /// snapshot is commited or rolled back, their numbers will be\n+    /// recycled, so you must be finished with them. See the extensive\n+    /// comments in `higher_ranked.rs` to see how it works (in\n+    /// particular, the subtyping comparison).\n+    ///\n+    /// The `snapshot` argument to this function is not really used;\n+    /// it's just there to make it explicit which snapshot bounds the\n+    /// skolemized region that results.\n+    pub fn new_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot) -> Region {\n+        assert!(self.in_snapshot());\n+        assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n+\n         let sc = self.skolemization_count.get();\n         self.skolemization_count.set(sc + 1);\n         ReInfer(ReSkolemized(sc, br))\n@@ -597,8 +602,8 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         ReInfer(ReVar(c))\n     }\n \n-    pub fn vars_created_since_mark(&self, mark: RegionMark)\n-                                   -> Vec<RegionVid>\n+    pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot)\n+                                       -> Vec<RegionVid>\n     {\n         self.undo_log.borrow()\n             .slice_from(mark.length)\n@@ -613,7 +618,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     /// Computes all regions that have been related to `r0` in any way since the mark `mark` was\n     /// made---`r0` itself will be the first entry. This is used when checking whether skolemized\n     /// regions are being improperly related to other regions.\n-    pub fn tainted(&self, mark: RegionMark, r0: Region) -> Vec<Region> {\n+    pub fn tainted(&self, mark: &RegionSnapshot, r0: Region) -> Vec<Region> {\n         debug!(\"tainted(mark={}, r0={})\", mark, r0.repr(self.tcx));\n         let _indenter = indenter();\n \n@@ -668,7 +673,6 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                         }\n                     }\n                     &AddCombination(..) |\n-                    &Mark |\n                     &AddVar(..) |\n                     &OpenSnapshot |\n                     &CommitedSnapshot => {"}, {"sha": "12400de31ed9e5a3ad886bd845920214239a22a4", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 76, "deletions": 221, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -8,253 +8,108 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Resolution is the process of removing type variables and replacing\n-// them with their inferred values.  Unfortunately our inference has\n-// become fairly complex and so there are a number of options to\n-// control *just how much* you want to resolve and how you want to do\n-// it.\n-//\n-// # Controlling the scope of resolution\n-//\n-// The options resolve_* determine what kinds of variables get\n-// resolved.  Generally resolution starts with a top-level type\n-// variable; we will always resolve this.  However, once we have\n-// resolved that variable, we may end up with a type that still\n-// contains type variables.  For example, if we resolve `<T0>` we may\n-// end up with something like `[<T1>]`.  If the option\n-// `resolve_nested_tvar` is passed, we will then go and recursively\n-// resolve `<T1>`.\n-//\n-// The options `resolve_rvar` controls whether we resolve region\n-// variables. The options `resolve_fvar` and `resolve_ivar` control\n-// whether we resolve floating point and integral variables,\n-// respectively.\n-//\n-// # What do if things are unconstrained\n-//\n-// Sometimes we will encounter a variable that has no constraints, and\n-// therefore cannot sensibly be mapped to any particular result.  By\n-// default, we will leave such variables as is (so you will get back a\n-// variable in your result).  The options force_* will cause the\n-// resolution to fail in this case instead, except for the case of\n-// integral variables, which resolve to `int` if forced.\n-//\n-// # resolve_all and force_all\n-//\n-// The options are a bit set, so you can use the *_all to resolve or\n-// force all kinds of variables (including those we may add in the\n-// future).  If you want to resolve everything but one type, you are\n-// probably better off writing `resolve_all - resolve_ivar`.\n-\n-#![allow(non_upper_case_globals)]\n-\n-use super::{fixup_err, fres, InferCtxt};\n-use super::{unresolved_int_ty,unresolved_float_ty,unresolved_ty};\n-\n-use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n-use middle::ty::{IntType, UintType};\n+use super::{InferCtxt, fixup_err, fres, unresolved_ty, unresolved_int_ty, unresolved_float_ty};\n use middle::ty::{mod, Ty};\n-use middle::ty_fold;\n-use syntax::codemap::Span;\n-use util::ppaux::{Repr, ty_to_string};\n-\n-pub const resolve_nested_tvar: uint = 0b0000000001;\n-pub const resolve_rvar: uint        = 0b0000000010;\n-pub const resolve_ivar: uint        = 0b0000000100;\n-pub const resolve_fvar: uint        = 0b0000001000;\n-pub const resolve_all: uint         = 0b0000001111;\n-pub const force_tvar: uint          = 0b0000100000;\n-pub const force_rvar: uint          = 0b0001000000;\n-pub const force_ivar: uint          = 0b0010000000;\n-pub const force_fvar: uint          = 0b0100000000;\n-pub const force_all: uint           = 0b0111100000;\n-\n-pub const not_regions: uint         = !(force_rvar | resolve_rvar);\n-\n-pub const try_resolve_tvar_shallow: uint = 0;\n-pub const resolve_and_force_all_but_regions: uint =\n-    (resolve_all | force_all) & not_regions;\n-\n-pub struct ResolveState<'a, 'tcx: 'a> {\n+use middle::ty_fold::{mod, TypeFoldable};\n+use util::ppaux::Repr;\n+\n+///////////////////////////////////////////////////////////////////////////\n+// OPPORTUNISTIC TYPE RESOLVER\n+\n+/// The opportunistic type resolver can be used at any time. It simply replaces\n+/// type variables that have been unified with the things they have\n+/// been unified with (similar to `shallow_resolve`, but deep). This is\n+/// useful for printing messages etc but also required at various\n+/// points for correctness.\n+pub struct OpportunisticTypeResolver<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n-    modes: uint,\n-    err: Option<fixup_err>,\n-    type_depth: uint,\n }\n \n-pub fn resolver<'a, 'tcx>(infcx: &'a InferCtxt<'a, 'tcx>,\n-                          modes: uint,\n-                          _: Option<Span>)\n-                          -> ResolveState<'a, 'tcx> {\n-    ResolveState {\n-        infcx: infcx,\n-        modes: modes,\n-        err: None,\n-        type_depth: 0,\n+impl<'a, 'tcx> OpportunisticTypeResolver<'a, 'tcx> {\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> OpportunisticTypeResolver<'a, 'tcx> {\n+        OpportunisticTypeResolver { infcx: infcx }\n     }\n }\n \n-impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for ResolveState<'a, 'tcx> {\n+impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for OpportunisticTypeResolver<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> {\n         self.infcx.tcx\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        self.resolve_type(t)\n-    }\n-\n-    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        self.resolve_region(r)\n-    }\n-}\n-\n-impl<'a, 'tcx> ResolveState<'a, 'tcx> {\n-    pub fn should(&mut self, mode: uint) -> bool {\n-        (self.modes & mode) == mode\n-    }\n-\n-    pub fn resolve_type_chk(&mut self, typ: Ty<'tcx>) -> fres<Ty<'tcx>> {\n-        self.err = None;\n-\n-        debug!(\"Resolving {} (modes={:x})\",\n-               ty_to_string(self.infcx.tcx, typ),\n-               self.modes);\n-\n-        // n.b. This is a hokey mess because the current fold doesn't\n-        // allow us to pass back errors in any useful way.\n-\n-        let rty = self.resolve_type(typ);\n-        match self.err {\n-            None => {\n-                debug!(\"Resolved {} to {} (modes={:x})\",\n-                       ty_to_string(self.infcx.tcx, typ),\n-                       ty_to_string(self.infcx.tcx, rty),\n-                       self.modes);\n-                return Ok(rty);\n-            }\n-            Some(e) => {\n-                return Err(e);\n-            }\n-        }\n-    }\n-\n-    pub fn resolve_region_chk(&mut self,\n-                              orig: ty::Region)\n-                              -> fres<ty::Region> {\n-        self.err = None;\n-        let resolved = self.resolve_region(orig);\n-        match self.err {\n-          None => Ok(resolved),\n-          Some(e) => Err(e)\n+        if !ty::type_has_ty_infer(t) {\n+            t // micro-optimize -- if there is nothing in this type that this fold affects...\n+        } else {\n+            let t0 = self.infcx.shallow_resolve(t);\n+            ty_fold::super_fold_ty(self, t0)\n         }\n     }\n+}\n \n-    pub fn resolve_type(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"resolve_type({})\", typ.repr(self.infcx.tcx));\n-\n-        if !ty::type_needs_infer(typ) {\n-            return typ;\n-        }\n-\n-        if self.type_depth > 0 && !self.should(resolve_nested_tvar) {\n-            return typ;\n-        }\n-\n-        match typ.sty {\n-            ty::ty_infer(TyVar(vid)) => {\n-                self.resolve_ty_var(vid)\n-            }\n-            ty::ty_infer(IntVar(vid)) => {\n-                self.resolve_int_var(vid)\n-            }\n-            ty::ty_infer(FloatVar(vid)) => {\n-                self.resolve_float_var(vid)\n-            }\n-            _ => {\n-                if self.modes & resolve_all == 0 {\n-                    // if we are only resolving top-level type\n-                    // variables, and this is not a top-level type\n-                    // variable, then shortcircuit for efficiency\n-                    typ\n-                } else {\n-                    self.type_depth += 1;\n-                    let result = ty_fold::super_fold_ty(self, typ);\n-                    self.type_depth -= 1;\n-                    result\n-                }\n-            }\n-        }\n+///////////////////////////////////////////////////////////////////////////\n+// FULL TYPE RESOLUTION\n+\n+/// Full type resolution replaces all type and region variables with\n+/// their concrete results. If any variable cannot be replaced (never unified, etc)\n+/// then an `Err` result is returned.\n+pub fn fully_resolve<'a, 'tcx, T>(infcx: &InferCtxt<'a,'tcx>, value: &T) -> fres<T>\n+    where T : TypeFoldable<'tcx>\n+{\n+    let mut full_resolver = FullTypeResolver { infcx: infcx, err: None };\n+    let result = value.fold_with(&mut full_resolver);\n+    match full_resolver.err {\n+        None => Ok(result),\n+        Some(e) => Err(e),\n     }\n+}\n \n-    pub fn resolve_region(&mut self, orig: ty::Region) -> ty::Region {\n-        debug!(\"Resolve_region({})\", orig.repr(self.infcx.tcx));\n-        match orig {\n-          ty::ReInfer(ty::ReVar(rid)) => self.resolve_region_var(rid),\n-          _ => orig\n-        }\n-    }\n+// N.B. This type is not public because the protocol around checking the\n+// `err` field is not enforcable otherwise.\n+struct FullTypeResolver<'a, 'tcx:'a> {\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n+    err: Option<fixup_err>,\n+}\n \n-    pub fn resolve_region_var(&mut self, rid: RegionVid) -> ty::Region {\n-        if !self.should(resolve_rvar) {\n-            return ty::ReInfer(ty::ReVar(rid));\n-        }\n-        self.infcx.region_vars.resolve_var(rid)\n+impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.infcx.tcx\n     }\n \n-    pub fn resolve_ty_var(&mut self, vid: TyVid) -> Ty<'tcx> {\n-        let tcx = self.infcx.tcx;\n-        let tv = self.infcx.type_variables.borrow();\n-        match tv.probe(vid) {\n-            Some(t) => {\n-                self.resolve_type(t)\n-            }\n-            None => {\n-                if self.should(force_tvar) {\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        if !ty::type_needs_infer(t) {\n+            t // micro-optimize -- if there is nothing in this type that this fold affects...\n+        } else {\n+            let t = self.infcx.shallow_resolve(t);\n+            match t.sty {\n+                ty::ty_infer(ty::TyVar(vid)) => {\n                     self.err = Some(unresolved_ty(vid));\n+                    ty::mk_err()\n+                }\n+                ty::ty_infer(ty::IntVar(vid)) => {\n+                    self.err = Some(unresolved_int_ty(vid));\n+                    ty::mk_err()\n+                }\n+                ty::ty_infer(ty::FloatVar(vid)) => {\n+                    self.err = Some(unresolved_float_ty(vid));\n+                    ty::mk_err()\n+                }\n+                ty::ty_infer(_) => {\n+                    self.infcx.tcx.sess.bug(\n+                        format!(\"Unexpected type in full type resolver: {}\",\n+                                t.repr(self.infcx.tcx))[]);\n+                }\n+                _ => {\n+                    ty_fold::super_fold_ty(self, t)\n                 }\n-                ty::mk_var(tcx, vid)\n-            }\n-        }\n-    }\n-\n-    pub fn resolve_int_var(&mut self, vid: IntVid) -> Ty<'tcx> {\n-        if !self.should(resolve_ivar) {\n-            return ty::mk_int_var(self.infcx.tcx, vid);\n-        }\n-\n-        let tcx = self.infcx.tcx;\n-        let table = &self.infcx.int_unification_table;\n-        let node = table.borrow_mut().get(tcx, vid);\n-        match node.value {\n-          Some(IntType(t)) => ty::mk_mach_int(t),\n-          Some(UintType(t)) => ty::mk_mach_uint(t),\n-          None => {\n-            if self.should(force_ivar) {\n-                // As a last resort, emit an error.\n-                self.err = Some(unresolved_int_ty(vid));\n             }\n-            ty::mk_int_var(self.infcx.tcx, vid)\n-          }\n         }\n     }\n \n-    pub fn resolve_float_var(&mut self, vid: FloatVid) -> Ty<'tcx> {\n-        if !self.should(resolve_fvar) {\n-            return ty::mk_float_var(self.infcx.tcx, vid);\n-        }\n-\n-        let tcx = self.infcx.tcx;\n-        let table = &self.infcx.float_unification_table;\n-        let node = table.borrow_mut().get(tcx, vid);\n-        match node.value {\n-          Some(t) => ty::mk_mach_float(t),\n-          None => {\n-            if self.should(force_fvar) {\n-                // As a last resort, emit an error.\n-                self.err = Some(unresolved_float_ty(vid));\n-            }\n-            ty::mk_float_var(self.infcx.tcx, vid)\n-          }\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        match r {\n+          ty::ReInfer(ty::ReVar(rid)) => self.infcx.region_vars.resolve_var(rid),\n+          _ => r,\n         }\n     }\n }\n+"}, {"sha": "2b8adfb7c1eeb880d1d48663d93c74d23646fa81", "filename": "src/librustc/middle/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fsub.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -155,13 +155,9 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n         }\n     }\n \n-    fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>)\n-               -> cres<'tcx, ty::FnSig<'tcx>> {\n-        self.higher_ranked_sub(a, b)\n-    }\n-\n-    fn trait_refs(&self, a: &ty::TraitRef<'tcx>, b: &ty::TraitRef<'tcx>)\n-                  -> cres<'tcx, ty::TraitRef<'tcx>> {\n+    fn binders<T>(&self, a: &ty::Binder<T>, b: &ty::Binder<T>) -> cres<'tcx, ty::Binder<T>>\n+        where T : Combineable<'tcx>\n+    {\n         self.higher_ranked_sub(a, b)\n     }\n }"}, {"sha": "0d7f542535c2f3ab4c585abf731b345c3a7c369d", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -13,7 +13,9 @@ use self::TypeVariableValue::*;\n use self::UndoEntry::*;\n \n use middle::ty::{mod, Ty};\n+use std::cmp::min;\n use std::mem;\n+use std::uint;\n use util::snapshot_vec as sv;\n \n pub struct TypeVariableTable<'tcx> {\n@@ -78,7 +80,6 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///\n     /// Precondition: neither `a` nor `b` are known.\n     pub fn relate_vars(&mut self, a: ty::TyVid, dir: RelationDir, b: ty::TyVid) {\n-\n         if a != b {\n             self.relations(a).push((dir, b));\n             self.relations(b).push((dir.opposite(), a));\n@@ -151,6 +152,49 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     pub fn commit(&mut self, s: Snapshot) {\n         self.values.commit(s.snapshot);\n     }\n+\n+    pub fn types_escaping_snapshot(&self, s: &Snapshot) -> Vec<Ty<'tcx>> {\n+        /*!\n+         * Find the set of type variables that existed *before* `s`\n+         * but which have only been unified since `s` started, and\n+         * return the types with which they were unified. So if we had\n+         * a type variable `V0`, then we started the snapshot, then we\n+         * created a type variable `V1`, unifed `V0` with `T0`, and\n+         * unified `V1` with `T1`, this function would return `{T0}`.\n+         */\n+\n+        let mut new_elem_threshold = uint::MAX;\n+        let mut escaping_types = Vec::new();\n+        let actions_since_snapshot = self.values.actions_since_snapshot(&s.snapshot);\n+        debug!(\"actions_since_snapshot.len() = {}\", actions_since_snapshot.len());\n+        for action in actions_since_snapshot.iter() {\n+            match *action {\n+                sv::UndoLog::NewElem(index) => {\n+                    // if any new variables were created during the\n+                    // snapshot, remember the lower index (which will\n+                    // always be the first one we see). Note that this\n+                    // action must precede those variables being\n+                    // specified.\n+                    new_elem_threshold = min(new_elem_threshold, index);\n+                    debug!(\"NewElem({}) new_elem_threshold={}\", index, new_elem_threshold);\n+                }\n+\n+                sv::UndoLog::Other(SpecifyVar(vid, _)) => {\n+                    if vid.index < new_elem_threshold {\n+                        // quick check to see if this variable was\n+                        // created since the snapshot started or not.\n+                        let escaping_type = self.probe(vid).unwrap();\n+                        escaping_types.push(escaping_type);\n+                    }\n+                    debug!(\"SpecifyVar({}) new_elem_threshold={}\", vid, new_elem_threshold);\n+                }\n+\n+                _ => { }\n+            }\n+        }\n+\n+        escaping_types\n+    }\n }\n \n impl<'tcx> sv::SnapshotVecDelegate<TypeVariableData<'tcx>,UndoEntry> for Delegate {"}, {"sha": "ea19111ce3d670f08125320dea1786588396a9d6", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -124,8 +124,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n                     let typ = ty::node_id_to_type(self.tcx, expr.id);\n                     match typ.sty {\n                         ty_bare_fn(ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n-                            if let ty::FnConverging(to) = bare_fn_ty.sig.output {\n-                                let from = bare_fn_ty.sig.inputs[0];\n+                            if let ty::FnConverging(to) = bare_fn_ty.sig.0.output {\n+                                let from = bare_fn_ty.sig.0.inputs[0];\n                                 self.check_transmute(expr.span, from, to, expr.id);\n                             }\n                         }"}, {"sha": "4df655882b1551dc71442c1c6ddf6725e3cc9ff9", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -1534,6 +1534,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                     .unwrap()\n                     .closure_type\n                     .sig\n+                    .0\n                     .output,\n             _ => ty::ty_fn_ret(fn_ty)\n         }"}, {"sha": "33701905aa11098a68f963b355b728138c39d340", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -108,7 +108,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                 ast::ItemTy(_, ref generics) |\n                 ast::ItemEnum(_, ref generics) |\n                 ast::ItemStruct(_, ref generics) |\n-                ast::ItemTrait(_, ref generics, _, _, _) => {\n+                ast::ItemTrait(_, ref generics, _, _, _) |\n+                ast::ItemImpl(_, ref generics, _, _, _) => {\n                     // These kinds of items have only early bound lifetime parameters.\n                     let lifetimes = &generics.lifetimes;\n                     let early_scope = EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE);\n@@ -117,12 +118,6 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                         visit::walk_item(this, item);\n                     });\n                 }\n-                ast::ItemImpl(_, ref generics, _, _, _) => {\n-                    // Impls have both early- and late-bound lifetimes.\n-                    this.visit_early_late(subst::TypeSpace, generics, |this| {\n-                        visit::walk_item(this, item);\n-                    })\n-                }\n             }\n         });\n     }"}, {"sha": "9804f6d222afde9513661697da44141411ac3ef0", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -17,7 +17,8 @@ use super::util;\n use middle::subst;\n use middle::subst::Subst;\n use middle::ty::{mod, Ty};\n-use middle::infer::{mod, InferCtxt};\n+use middle::infer::InferCtxt;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n use util::ppaux::Repr;\n@@ -37,18 +38,14 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n     let impl1_substs =\n         util::fresh_substs_for_impl(infcx, DUMMY_SP, impl1_def_id);\n     let impl1_trait_ref =\n-        ty::impl_trait_ref(infcx.tcx, impl1_def_id).unwrap()\n-                                                   .subst(infcx.tcx, &impl1_substs);\n-    let impl1_trait_ref =\n-        infcx.replace_late_bound_regions_with_fresh_var(DUMMY_SP,\n-                                                        infer::FnCall,\n-                                                        &impl1_trait_ref).0;\n+        (*ty::impl_trait_ref(infcx.tcx, impl1_def_id).unwrap()).subst(infcx.tcx, &impl1_substs);\n \n     // Determine whether `impl2` can provide an implementation for those\n     // same types.\n     let param_env = ty::empty_parameter_environment();\n     let mut selcx = SelectionContext::intercrate(infcx, &param_env, infcx.tcx);\n-    let obligation = Obligation::new(ObligationCause::dummy(), impl1_trait_ref);\n+    let obligation = Obligation::new(ObligationCause::dummy(),\n+                                     Rc::new(ty::Binder(impl1_trait_ref)));\n     debug!(\"impl_can_satisfy(obligation={})\", obligation.repr(infcx.tcx));\n     selcx.evaluate_impl(impl2_def_id, &obligation)\n }\n@@ -143,7 +140,7 @@ pub fn ty_is_local<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         }\n \n         ty::ty_trait(ref tt) => {\n-            tt.principal.def_id.krate == ast::LOCAL_CRATE\n+            tt.principal.def_id().krate == ast::LOCAL_CRATE\n         }\n \n         // Type parameters may be bound to types that are not local to"}, {"sha": "80697cb3a41db7ffe7e02debc682e996eb3441c9", "filename": "src/librustc/middle/traits/doc.rs", "status": "modified", "additions": 510, "deletions": 396, "changes": 906, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fdoc.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -8,399 +8,513 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! # TRAIT RESOLUTION\n-//!\n-//! This document describes the general process and points out some non-obvious\n-//! things.\n-//!\n-//! ## Major concepts\n-//!\n-//! Trait resolution is the process of pairing up an impl with each\n-//! reference to a trait. So, for example, if there is a generic function like:\n-//!\n-//!     fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> { ... }\n-//!\n-//! and then a call to that function:\n-//!\n-//!     let v: Vec<int> = clone_slice([1, 2, 3].as_slice())\n-//!\n-//! it is the job of trait resolution to figure out (in which case)\n-//! whether there exists an impl of `int : Clone`\n-//!\n-//! Note that in some cases, like generic functions, we may not be able to\n-//! find a specific impl, but we can figure out that the caller must\n-//! provide an impl. To see what I mean, consider the body of `clone_slice`:\n-//!\n-//!     fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> {\n-//!         let mut v = Vec::new();\n-//!         for e in x.iter() {\n-//!             v.push((*e).clone()); // (*)\n-//!         }\n-//!     }\n-//!\n-//! The line marked `(*)` is only legal if `T` (the type of `*e`)\n-//! implements the `Clone` trait. Naturally, since we don't know what `T`\n-//! is, we can't find the specific impl; but based on the bound `T:Clone`,\n-//! we can say that there exists an impl which the caller must provide.\n-//!\n-//! We use the term *obligation* to refer to a trait reference in need of\n-//! an impl.\n-//!\n-//! ## Overview\n-//!\n-//! Trait resolution consists of three major parts:\n-//!\n-//! - SELECTION: Deciding how to resolve a specific obligation. For\n-//!   example, selection might decide that a specific obligation can be\n-//!   resolved by employing an impl which matches the self type, or by\n-//!   using a parameter bound. In the case of an impl, Selecting one\n-//!   obligation can create *nested obligations* because of where clauses\n-//!   on the impl itself. It may also require evaluating those nested\n-//!   obligations to resolve ambiguities.\n-//!\n-//! - FULFILLMENT: The fulfillment code is what tracks that obligations\n-//!   are completely fulfilled. Basically it is a worklist of obligations\n-//!   to be selected: once selection is successful, the obligation is\n-//!   removed from the worklist and any nested obligations are enqueued.\n-//!\n-//! - COHERENCE: The coherence checks are intended to ensure that there\n-//!   are never overlapping impls, where two impls could be used with\n-//!   equal precedence.\n-//!\n-//! ## Selection\n-//!\n-//! Selection is the process of deciding whether an obligation can be\n-//! resolved and, if so, how it is to be resolved (via impl, where clause, etc).\n-//! The main interface is the `select()` function, which takes an obligation\n-//! and returns a `SelectionResult`. There are three possible outcomes:\n-//!\n-//! - `Ok(Some(selection))` -- yes, the obligation can be resolved, and\n-//!   `selection` indicates how. If the impl was resolved via an impl,\n-//!   then `selection` may also indicate nested obligations that are required\n-//!   by the impl.\n-//!\n-//! - `Ok(None)` -- we are not yet sure whether the obligation can be\n-//!   resolved or not. This happens most commonly when the obligation\n-//!   contains unbound type variables.\n-//!\n-//! - `Err(err)` -- the obligation definitely cannot be resolved due to a\n-//!   type error, or because there are no impls that could possibly apply,\n-//!   etc.\n-//!\n-//! The basic algorithm for selection is broken into two big phases:\n-//! candidate assembly and confirmation.\n-//!\n-//! ### Candidate assembly\n-//!\n-//! Searches for impls/where-clauses/etc that might\n-//! possibly be used to satisfy the obligation. Each of those is called\n-//! a candidate. To avoid ambiguity, we want to find exactly one\n-//! candidate that is definitively applicable. In some cases, we may not\n-//! know whether an impl/where-clause applies or not -- this occurs when\n-//! the obligation contains unbound inference variables.\n-//!\n-//! The basic idea for candidate assembly is to do a first pass in which\n-//! we identify all possible candidates. During this pass, all that we do\n-//! is try and unify the type parameters. (In particular, we ignore any\n-//! nested where clauses.) Presuming that this unification succeeds, the\n-//! impl is added as a candidate.\n-//!\n-//! Once this first pass is done, we can examine the set of candidates. If\n-//! it is a singleton set, then we are done: this is the only impl in\n-//! scope that could possibly apply. Otherwise, we can winnow down the set\n-//! of candidates by using where clauses and other conditions. If this\n-//! reduced set yields a single, unambiguous entry, we're good to go,\n-//! otherwise the result is considered ambiguous.\n-//!\n-//! #### The basic process: Inferring based on the impls we see\n-//!\n-//! This process is easier if we work through some examples. Consider\n-//! the following trait:\n-//!\n-//! ```\n-//! trait Convert<Target> {\n-//!     fn convert(&self) -> Target;\n-//! }\n-//! ```\n-//!\n-//! This trait just has one method. It's about as simple as it gets. It\n-//! converts from the (implicit) `Self` type to the `Target` type. If we\n-//! wanted to permit conversion between `int` and `uint`, we might\n-//! implement `Convert` like so:\n-//!\n-//! ```rust\n-//! impl Convert<uint> for int { ... } // int -> uint\n-//! impl Convert<int> for uint { ... } // uint -> uint\n-//! ```\n-//!\n-//! Now imagine there is some code like the following:\n-//!\n-//! ```rust\n-//! let x: int = ...;\n-//! let y = x.convert();\n-//! ```\n-//!\n-//! The call to convert will generate a trait reference `Convert<$Y> for\n-//! int`, where `$Y` is the type variable representing the type of\n-//! `y`. When we match this against the two impls we can see, we will find\n-//! that only one remains: `Convert<uint> for int`. Therefore, we can\n-//! select this impl, which will cause the type of `$Y` to be unified to\n-//! `uint`. (Note that while assembling candidates, we do the initial\n-//! unifications in a transaction, so that they don't affect one another.)\n-//!\n-//! There are tests to this effect in src/test/run-pass:\n-//!\n-//!    traits-multidispatch-infer-convert-source-and-target.rs\n-//!    traits-multidispatch-infer-convert-target.rs\n-//!\n-//! #### Winnowing: Resolving ambiguities\n-//!\n-//! But what happens if there are multiple impls where all the types\n-//! unify? Consider this example:\n-//!\n-//! ```rust\n-//! trait Get {\n-//!     fn get(&self) -> Self;\n-//! }\n-//!\n-//! impl<T:Copy> Get for T {\n-//!     fn get(&self) -> T { *self }\n-//! }\n-//!\n-//! impl<T:Get> Get for Box<T> {\n-//!     fn get(&self) -> Box<T> { box get_it(&**self) }\n-//! }\n-//! ```\n-//!\n-//! What happens when we invoke `get_it(&box 1_u16)`, for example? In this\n-//! case, the `Self` type is `Box<u16>` -- that unifies with both impls,\n-//! because the first applies to all types, and the second to all\n-//! boxes. In the olden days we'd have called this ambiguous. But what we\n-//! do now is do a second *winnowing* pass that considers where clauses\n-//! and attempts to remove candidates -- in this case, the first impl only\n-//! applies if `Box<u16> : Copy`, which doesn't hold. After winnowing,\n-//! then, we are left with just one candidate, so we can proceed. There is\n-//! a test of this in `src/test/run-pass/traits-conditional-dispatch.rs`.\n-//!\n-//! #### Matching\n-//!\n-//! The subroutines that decide whether a particular impl/where-clause/etc\n-//! applies to a particular obligation. At the moment, this amounts to\n-//! unifying the self types, but in the future we may also recursively\n-//! consider some of the nested obligations, in the case of an impl.\n-//!\n-//! #### Lifetimes and selection\n-//!\n-//! Because of how that lifetime inference works, it is not possible to\n-//! give back immediate feedback as to whether a unification or subtype\n-//! relationship between lifetimes holds or not. Therefore, lifetime\n-//! matching is *not* considered during selection. This is reflected in\n-//! the fact that subregion assignment is infallible. This may yield\n-//! lifetime constraints that will later be found to be in error (in\n-//! contrast, the non-lifetime-constraints have already been checked\n-//! during selection and can never cause an error, though naturally they\n-//! may lead to other errors downstream).\n-//!\n-//! #### Where clauses\n-//!\n-//! Besides an impl, the other major way to resolve an obligation is via a\n-//! where clause. The selection process is always given a *parameter\n-//! environment* which contains a list of where clauses, which are\n-//! basically obligations that can assume are satisfiable. We will iterate\n-//! over that list and check whether our current obligation can be found\n-//! in that list, and if so it is considered satisfied. More precisely, we\n-//! want to check whether there is a where-clause obligation that is for\n-//! the same trait (or some subtrait) and for which the self types match,\n-//! using the definition of *matching* given above.\n-//!\n-//! Consider this simple example:\n-//!\n-//!      trait A1 { ... }\n-//!      trait A2 : A1 { ... }\n-//!\n-//!      trait B { ... }\n-//!\n-//!      fn foo<X:A2+B> { ... }\n-//!\n-//! Clearly we can use methods offered by `A1`, `A2`, or `B` within the\n-//! body of `foo`. In each case, that will incur an obligation like `X :\n-//! A1` or `X : A2`. The parameter environment will contain two\n-//! where-clauses, `X : A2` and `X : B`. For each obligation, then, we\n-//! search this list of where-clauses.  To resolve an obligation `X:A1`,\n-//! we would note that `X:A2` implies that `X:A1`.\n-//!\n-//! ### Confirmation\n-//!\n-//! Confirmation unifies the output type parameters of the trait with the\n-//! values found in the obligation, possibly yielding a type error.  If we\n-//! return to our example of the `Convert` trait from the previous\n-//! section, confirmation is where an error would be reported, because the\n-//! impl specified that `T` would be `uint`, but the obligation reported\n-//! `char`. Hence the result of selection would be an error.\n-//!\n-//! ### Selection during translation\n-//!\n-//! During type checking, we do not store the results of trait selection.\n-//! We simply wish to verify that trait selection will succeed. Then\n-//! later, at trans time, when we have all concrete types available, we\n-//! can repeat the trait selection.  In this case, we do not consider any\n-//! where-clauses to be in scope. We know that therefore each resolution\n-//! will resolve to a particular impl.\n-//!\n-//! One interesting twist has to do with nested obligations. In general, in trans,\n-//! we only need to do a \"shallow\" selection for an obligation. That is, we wish to\n-//! identify which impl applies, but we do not (yet) need to decide how to select\n-//! any nested obligations. Nonetheless, we *do* currently do a complete resolution,\n-//! and that is because it can sometimes inform the results of type inference. That is,\n-//! we do not have the full substitutions in terms of the type varibales of the impl available\n-//! to us, so we must run trait selection to figure everything out.\n-//!\n-//! Here is an example:\n-//!\n-//!     trait Foo { ... }\n-//!     impl<U,T:Bar<U>> Foo for Vec<T> { ... }\n-//!\n-//!     impl Bar<uint> for int { ... }\n-//!\n-//! After one shallow round of selection for an obligation like `Vec<int>\n-//! : Foo`, we would know which impl we want, and we would know that\n-//! `T=int`, but we do not know the type of `U`.  We must select the\n-//! nested obligation `int : Bar<U>` to find out that `U=uint`.\n-//!\n-//! It would be good to only do *just as much* nested resolution as\n-//! necessary. Currently, though, we just do a full resolution.\n-//!\n-//! ## Method matching\n-//!\n-//! Method dispach follows a slightly different path than normal trait\n-//! selection. This is because it must account for the transformed self\n-//! type of the receiver and various other complications. The procedure is\n-//! described in `select.rs` in the \"METHOD MATCHING\" section.\n-//!\n-//! # Caching and subtle considerations therewith\n-//!\n-//! In general we attempt to cache the results of trait selection.  This\n-//! is a somewhat complex process. Part of the reason for this is that we\n-//! want to be able to cache results even when all the types in the trait\n-//! reference are not fully known. In that case, it may happen that the\n-//! trait selection process is also influencing type variables, so we have\n-//! to be able to not only cache the *result* of the selection process,\n-//! but *replay* its effects on the type variables.\n-//!\n-//! ## An example\n-//!\n-//! The high-level idea of how the cache works is that we first replace\n-//! all unbound inference variables with skolemized versions. Therefore,\n-//! if we had a trait reference `uint : Foo<$1>`, where `$n` is an unbound\n-//! inference variable, we might replace it with `uint : Foo<%0>`, where\n-//! `%n` is a skolemized type. We would then look this up in the cache.\n-//! If we found a hit, the hit would tell us the immediate next step to\n-//! take in the selection process: i.e., apply impl #22, or apply where\n-//! clause `X : Foo<Y>`. Let's say in this case there is no hit.\n-//! Therefore, we search through impls and where clauses and so forth, and\n-//! we come to the conclusion that the only possible impl is this one,\n-//! with def-id 22:\n-//!\n-//!     impl Foo<int> for uint { ... } // Impl #22\n-//!\n-//! We would then record in the cache `uint : Foo<%0> ==>\n-//! ImplCandidate(22)`. Next we would confirm `ImplCandidate(22)`, which\n-//! would (as a side-effect) unify `$1` with `int`.\n-//!\n-//! Now, at some later time, we might come along and see a `uint :\n-//! Foo<$3>`.  When skolemized, this would yield `uint : Foo<%0>`, just as\n-//! before, and hence the cache lookup would succeed, yielding\n-//! `ImplCandidate(22)`. We would confirm `ImplCandidate(22)` which would\n-//! (as a side-effect) unify `$3` with `int`.\n-//!\n-//! ## Where clauses and the local vs global cache\n-//!\n-//! One subtle interaction is that the results of trait lookup will vary\n-//! depending on what where clauses are in scope. Therefore, we actually\n-//! have *two* caches, a local and a global cache. The local cache is\n-//! attached to the `ParameterEnvironment` and the global cache attached\n-//! to the `tcx`. We use the local cache whenever the result might depend\n-//! on the where clauses that are in scope. The determination of which\n-//! cache to use is done by the method `pick_candidate_cache` in\n-//! `select.rs`.\n-//!\n-//! There are two cases where we currently use the local cache. The\n-//! current rules are probably more conservative than necessary.\n-//!\n-//! ### Trait references that involve parameter types\n-//!\n-//! The most obvious case where you need the local environment is\n-//! when the trait reference includes parameter types. For example,\n-//! consider the following function:\n-//!\n-//!     impl<T> Vec<T> {\n-//!         fn foo(x: T)\n-//!             where T : Foo\n-//!         { ... }\n-//!\n-//!         fn bar(x: T)\n-//!         { ... }\n-//!     }\n-//!\n-//! If there is an obligation `T : Foo`, or `int : Bar<T>`, or whatever,\n-//! clearly the results from `foo` and `bar` are potentially different,\n-//! since the set of where clauses in scope are different.\n-//!\n-//! ### Trait references with unbound variables when where clauses are in scope\n-//!\n-//! There is another less obvious interaction which involves unbound variables\n-//! where *only* where clauses are in scope (no impls). This manifested as\n-//! issue #18209 (`run-pass/trait-cache-issue-18209.rs`). Consider\n-//! this snippet:\n-//!\n-//! ```\n-//! pub trait Foo {\n-//!     fn load_from() -> Box<Self>;\n-//!     fn load() -> Box<Self> {\n-//!         Foo::load_from()\n-//!     }\n-//! }\n-//! ```\n-//!\n-//! The default method will incur an obligation `$0 : Foo` from the call\n-//! to `load_from`. If there are no impls, this can be eagerly resolved to\n-//! `VtableParam(Self : Foo)` and cached. Because the trait reference\n-//! doesn't involve any parameters types (only the resolution does), this\n-//! result was stored in the global cache, causing later calls to\n-//! `Foo::load_from()` to get nonsense.\n-//!\n-//! To fix this, we always use the local cache if there are unbound\n-//! variables and where clauses in scope. This is more conservative than\n-//! necessary as far as I can tell. However, it still seems to be a simple\n-//! rule and I observe ~99% hit rate on rustc, so it doesn't seem to hurt\n-//! us in particular.\n-//!\n-//! Here is an example of the kind of subtle case that I would be worried\n-//! about with a more complex rule (although this particular case works\n-//! out ok). Imagine the trait reference doesn't directly reference a\n-//! where clause, but the where clause plays a role in the winnowing\n-//! phase. Something like this:\n-//!\n-//! ```\n-//! pub trait Foo<T> { ... }\n-//! pub trait Bar { ... }\n-//! impl<U,T:Bar> Foo<U> for T { ... } // Impl A\n-//! impl Foo<char> for uint { ... }    // Impl B\n-//! ```\n-//!\n-//! Now, in some function, we have no where clauses in scope, and we have\n-//! an obligation `$1 : Foo<$0>`. We might then conclude that `$0=char`\n-//! and `$1=uint`: this is because for impl A to apply, `uint:Bar` would\n-//! have to hold, and we know it does not or else the coherence check\n-//! would have failed.  So we might enter into our global cache: `$1 :\n-//! Foo<$0> => Impl B`.  Then we come along in a different scope, where a\n-//! generic type `A` is around with the bound `A:Bar`. Now suddenly the\n-//! impl is viable.\n-//!\n-//! The flaw in this imaginary DOOMSDAY SCENARIO is that we would not\n-//! currently conclude that `$1 : Foo<$0>` implies that `$0 == uint` and\n-//! `$1 == char`, even though it is true that (absent type parameters)\n-//! there is no other type the user could enter. However, it is not\n-//! *completely* implausible that we *could* draw this conclusion in the\n-//! future; we wouldn't have to guess types, in particular, we could be\n-//! led by the impls.\n+/*!\n+\n+# TRAIT RESOLUTION\n+\n+This document describes the general process and points out some non-obvious\n+things.\n+\n+## Major concepts\n+\n+Trait resolution is the process of pairing up an impl with each\n+reference to a trait. So, for example, if there is a generic function like:\n+\n+    fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> { ... }\n+\n+and then a call to that function:\n+\n+    let v: Vec<int> = clone_slice([1, 2, 3].as_slice())\n+\n+it is the job of trait resolution to figure out (in which case)\n+whether there exists an impl of `int : Clone`\n+\n+Note that in some cases, like generic functions, we may not be able to\n+find a specific impl, but we can figure out that the caller must\n+provide an impl. To see what I mean, consider the body of `clone_slice`:\n+\n+    fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> {\n+        let mut v = Vec::new();\n+        for e in x.iter() {\n+            v.push((*e).clone()); // (*)\n+        }\n+    }\n+\n+The line marked `(*)` is only legal if `T` (the type of `*e`)\n+implements the `Clone` trait. Naturally, since we don't know what `T`\n+is, we can't find the specific impl; but based on the bound `T:Clone`,\n+we can say that there exists an impl which the caller must provide.\n+\n+We use the term *obligation* to refer to a trait reference in need of\n+an impl.\n+\n+## Overview\n+\n+Trait resolution consists of three major parts:\n+\n+- SELECTION: Deciding how to resolve a specific obligation. For\n+  example, selection might decide that a specific obligation can be\n+  resolved by employing an impl which matches the self type, or by\n+  using a parameter bound. In the case of an impl, Selecting one\n+  obligation can create *nested obligations* because of where clauses\n+  on the impl itself. It may also require evaluating those nested\n+  obligations to resolve ambiguities.\n+\n+- FULFILLMENT: The fulfillment code is what tracks that obligations\n+  are completely fulfilled. Basically it is a worklist of obligations\n+  to be selected: once selection is successful, the obligation is\n+  removed from the worklist and any nested obligations are enqueued.\n+\n+- COHERENCE: The coherence checks are intended to ensure that there\n+  are never overlapping impls, where two impls could be used with\n+  equal precedence.\n+\n+## Selection\n+\n+Selection is the process of deciding whether an obligation can be\n+resolved and, if so, how it is to be resolved (via impl, where clause, etc).\n+The main interface is the `select()` function, which takes an obligation\n+and returns a `SelectionResult`. There are three possible outcomes:\n+\n+- `Ok(Some(selection))` -- yes, the obligation can be resolved, and\n+  `selection` indicates how. If the impl was resolved via an impl,\n+  then `selection` may also indicate nested obligations that are required\n+  by the impl.\n+\n+- `Ok(None)` -- we are not yet sure whether the obligation can be\n+  resolved or not. This happens most commonly when the obligation\n+  contains unbound type variables.\n+\n+- `Err(err)` -- the obligation definitely cannot be resolved due to a\n+  type error, or because there are no impls that could possibly apply,\n+  etc.\n+\n+The basic algorithm for selection is broken into two big phases:\n+candidate assembly and confirmation.\n+\n+### Candidate assembly\n+\n+Searches for impls/where-clauses/etc that might\n+possibly be used to satisfy the obligation. Each of those is called\n+a candidate. To avoid ambiguity, we want to find exactly one\n+candidate that is definitively applicable. In some cases, we may not\n+know whether an impl/where-clause applies or not -- this occurs when\n+the obligation contains unbound inference variables.\n+\n+The basic idea for candidate assembly is to do a first pass in which\n+we identify all possible candidates. During this pass, all that we do\n+is try and unify the type parameters. (In particular, we ignore any\n+nested where clauses.) Presuming that this unification succeeds, the\n+impl is added as a candidate.\n+\n+Once this first pass is done, we can examine the set of candidates. If\n+it is a singleton set, then we are done: this is the only impl in\n+scope that could possibly apply. Otherwise, we can winnow down the set\n+of candidates by using where clauses and other conditions. If this\n+reduced set yields a single, unambiguous entry, we're good to go,\n+otherwise the result is considered ambiguous.\n+\n+#### The basic process: Inferring based on the impls we see\n+\n+This process is easier if we work through some examples. Consider\n+the following trait:\n+\n+```\n+trait Convert<Target> {\n+    fn convert(&self) -> Target;\n+}\n+```\n+\n+This trait just has one method. It's about as simple as it gets. It\n+converts from the (implicit) `Self` type to the `Target` type. If we\n+wanted to permit conversion between `int` and `uint`, we might\n+implement `Convert` like so:\n+\n+```rust\n+impl Convert<uint> for int { ... } // int -> uint\n+impl Convert<int> for uint { ... } // uint -> uint\n+```\n+\n+Now imagine there is some code like the following:\n+\n+```rust\n+let x: int = ...;\n+let y = x.convert();\n+```\n+\n+The call to convert will generate a trait reference `Convert<$Y> for\n+int`, where `$Y` is the type variable representing the type of\n+`y`. When we match this against the two impls we can see, we will find\n+that only one remains: `Convert<uint> for int`. Therefore, we can\n+select this impl, which will cause the type of `$Y` to be unified to\n+`uint`. (Note that while assembling candidates, we do the initial\n+unifications in a transaction, so that they don't affect one another.)\n+\n+There are tests to this effect in src/test/run-pass:\n+\n+   traits-multidispatch-infer-convert-source-and-target.rs\n+   traits-multidispatch-infer-convert-target.rs\n+\n+#### Winnowing: Resolving ambiguities\n+\n+But what happens if there are multiple impls where all the types\n+unify? Consider this example:\n+\n+```rust\n+trait Get {\n+    fn get(&self) -> Self;\n+}\n+\n+impl<T:Copy> Get for T {\n+    fn get(&self) -> T { *self }\n+}\n+\n+impl<T:Get> Get for Box<T> {\n+    fn get(&self) -> Box<T> { box get_it(&**self) }\n+}\n+```\n+\n+What happens when we invoke `get_it(&box 1_u16)`, for example? In this\n+case, the `Self` type is `Box<u16>` -- that unifies with both impls,\n+because the first applies to all types, and the second to all\n+boxes. In the olden days we'd have called this ambiguous. But what we\n+do now is do a second *winnowing* pass that considers where clauses\n+and attempts to remove candidates -- in this case, the first impl only\n+applies if `Box<u16> : Copy`, which doesn't hold. After winnowing,\n+then, we are left with just one candidate, so we can proceed. There is\n+a test of this in `src/test/run-pass/traits-conditional-dispatch.rs`.\n+\n+#### Matching\n+\n+The subroutines that decide whether a particular impl/where-clause/etc\n+applies to a particular obligation. At the moment, this amounts to\n+unifying the self types, but in the future we may also recursively\n+consider some of the nested obligations, in the case of an impl.\n+\n+#### Lifetimes and selection\n+\n+Because of how that lifetime inference works, it is not possible to\n+give back immediate feedback as to whether a unification or subtype\n+relationship between lifetimes holds or not. Therefore, lifetime\n+matching is *not* considered during selection. This is reflected in\n+the fact that subregion assignment is infallible. This may yield\n+lifetime constraints that will later be found to be in error (in\n+contrast, the non-lifetime-constraints have already been checked\n+during selection and can never cause an error, though naturally they\n+may lead to other errors downstream).\n+\n+#### Where clauses\n+\n+Besides an impl, the other major way to resolve an obligation is via a\n+where clause. The selection process is always given a *parameter\n+environment* which contains a list of where clauses, which are\n+basically obligations that can assume are satisfiable. We will iterate\n+over that list and check whether our current obligation can be found\n+in that list, and if so it is considered satisfied. More precisely, we\n+want to check whether there is a where-clause obligation that is for\n+the same trait (or some subtrait) and for which the self types match,\n+using the definition of *matching* given above.\n+\n+Consider this simple example:\n+\n+     trait A1 { ... }\n+     trait A2 : A1 { ... }\n+\n+     trait B { ... }\n+\n+     fn foo<X:A2+B> { ... }\n+\n+Clearly we can use methods offered by `A1`, `A2`, or `B` within the\n+body of `foo`. In each case, that will incur an obligation like `X :\n+A1` or `X : A2`. The parameter environment will contain two\n+where-clauses, `X : A2` and `X : B`. For each obligation, then, we\n+search this list of where-clauses.  To resolve an obligation `X:A1`,\n+we would note that `X:A2` implies that `X:A1`.\n+\n+### Confirmation\n+\n+Confirmation unifies the output type parameters of the trait with the\n+values found in the obligation, possibly yielding a type error.  If we\n+return to our example of the `Convert` trait from the previous\n+section, confirmation is where an error would be reported, because the\n+impl specified that `T` would be `uint`, but the obligation reported\n+`char`. Hence the result of selection would be an error.\n+\n+### Selection during translation\n+\n+During type checking, we do not store the results of trait selection.\n+We simply wish to verify that trait selection will succeed. Then\n+later, at trans time, when we have all concrete types available, we\n+can repeat the trait selection.  In this case, we do not consider any\n+where-clauses to be in scope. We know that therefore each resolution\n+will resolve to a particular impl.\n+\n+One interesting twist has to do with nested obligations. In general, in trans,\n+we only need to do a \"shallow\" selection for an obligation. That is, we wish to\n+identify which impl applies, but we do not (yet) need to decide how to select\n+any nested obligations. Nonetheless, we *do* currently do a complete resolution,\n+and that is because it can sometimes inform the results of type inference. That is,\n+we do not have the full substitutions in terms of the type varibales of the impl available\n+to us, so we must run trait selection to figure everything out.\n+\n+Here is an example:\n+\n+    trait Foo { ... }\n+    impl<U,T:Bar<U>> Foo for Vec<T> { ... }\n+\n+    impl Bar<uint> for int { ... }\n+\n+After one shallow round of selection for an obligation like `Vec<int>\n+: Foo`, we would know which impl we want, and we would know that\n+`T=int`, but we do not know the type of `U`.  We must select the\n+nested obligation `int : Bar<U>` to find out that `U=uint`.\n+\n+It would be good to only do *just as much* nested resolution as\n+necessary. Currently, though, we just do a full resolution.\n+\n+# Higher-ranked trait bounds\n+\n+One of the more subtle concepts at work are *higher-ranked trait\n+bounds*. An example of such a bound is `for<'a> MyTrait<&'a int>`.\n+Let's walk through how selection on higher-ranked trait references\n+works.\n+\n+## Basic matching and skolemization leaks\n+\n+Let's walk through the test `compile-fail/hrtb-just-for-static.rs` to see\n+how it works. The test starts with the trait `Foo`:\n+\n+```rust\n+trait Foo<X> {\n+    fn foo(&self, x: X) { }\n+}\n+```\n+\n+Let's say we have a function `want_hrtb` that wants a type which\n+implements `Foo<&'a int>` for any `'a`:\n+\n+```rust\n+fn want_hrtb<T>() where T : for<'a> Foo<&'a int> { ... }\n+```\n+\n+Now we have a struct `AnyInt` that implements `Foo<&'a int>` for any\n+`'a`:\n+\n+```rust\n+struct AnyInt;\n+impl<'a> Foo<&'a int> for AnyInt { }\n+```\n+\n+And the question is, does `AnyInt : for<'a> Foo<&'a int>`? We want the\n+answer to be yes. The algorithm for figuring it out is closely related\n+to the subtyping for higher-ranked types (which is described in\n+`middle::infer::higher_ranked::doc`, but also in a [paper by SPJ] that\n+I recommend you read).\n+\n+1. Skolemize the obligation.\n+2. Match the impl against the skolemized obligation.\n+3. Check for skolemization leaks.\n+\n+[paper by SPJ]: http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n+\n+So let's work through our example. The first thing we would do is to\n+skolemize the obligation, yielding `AnyInt : Foo<&'0 int>` (here `'0`\n+represents skolemized region #0). Note that now have no quantifiers;\n+in terms of the compiler type, this changes from a `ty::PolyTraitRef`\n+to a `TraitRef`. We would then create the `TraitRef` from the impl,\n+using fresh variables for it's bound regions (and thus getting\n+`Foo<&'$a int>`, where `'$a` is the inference variable for `'a`). Next\n+we relate the two trait refs, yielding a graph with the constraint\n+that `'0 == '$a`. Finally, we check for skolemization \"leaks\" -- a\n+leak is basically any attempt to relate a skolemized region to another\n+skolemized region, or to any region that pre-existed the impl match.\n+The leak check is done by searching from the skolemized region to find\n+the set of regions that it is related to in any way. This is called\n+the \"taint\" set. To pass the check, that set must consist *solely* of\n+itself and region variables from the impl. If the taint set includes\n+any other region, then the match is a failure. In this case, the taint\n+set for `'0` is `{'0, '$a}`, and hence the check will succeed.\n+\n+Let's consider a failure case. Imagine we also have a struct\n+\n+```rust\n+struct StaticInt;\n+impl Foo<&'static int> for StaticInt;\n+```\n+\n+We want the obligation `StaticInt : for<'a> Foo<&'a int>` to be\n+considered unsatisfied. The check begins just as before. `'a` is\n+skolemized to `'0` and the impl trait reference is instantiated to\n+`Foo<&'static int>`. When we relate those two, we get a constraint\n+like `'static == '0`. This means that the taint set for `'0` is `{'0,\n+'static}`, which fails the leak check.\n+\n+## Higher-ranked trait obligations\n+\n+Once the basic matching is done, we get to another interesting topic:\n+how to deal with impl obligations. I'll work through a simple example\n+here. Imagine we have the traits `Foo` and `Bar` and an associated impl:\n+\n+```\n+trait Foo<X> {\n+    fn foo(&self, x: X) { }\n+}\n+\n+trait Bar<X> {\n+    fn bar(&self, x: X) { }\n+}\n+\n+impl<X,F> Foo<X> for F\n+    where F : Bar<X>\n+{\n+}\n+```\n+\n+Now let's say we have a obligation `for<'a> Foo<&'a int>` and we match\n+this impl. What obligation is generated as a result? We want to get\n+`for<'a> Bar<&'a int>`, but how does that happen?\n+\n+After the matching, we are in a position where we have a skolemized\n+substitution like `X => &'0 int`. If we apply this substitution to the\n+impl obligations, we get `F : Bar<&'0 int>`. Obviously this is not\n+directly usable because the skolemized region `'0` cannot leak out of\n+our computation.\n+\n+What we do is to create an inverse mapping from the taint set of `'0`\n+back to the original bound region (`'a`, here) that `'0` resulted\n+from. (This is done in `higher_ranked::plug_leaks`). We know that the\n+leak check passed, so this taint set consists solely of the skolemized\n+region itself plus various intermediate region variables. We then walk\n+the trait-reference and convert every region in that taint set back to\n+a late-bound region, so in this case we'd wind up with `for<'a> F :\n+Bar<&'a int>`.\n+\n+# Caching and subtle considerations therewith\n+\n+In general we attempt to cache the results of trait selection.  This\n+is a somewhat complex process. Part of the reason for this is that we\n+want to be able to cache results even when all the types in the trait\n+reference are not fully known. In that case, it may happen that the\n+trait selection process is also influencing type variables, so we have\n+to be able to not only cache the *result* of the selection process,\n+but *replay* its effects on the type variables.\n+\n+## An example\n+\n+The high-level idea of how the cache works is that we first replace\n+all unbound inference variables with skolemized versions. Therefore,\n+if we had a trait reference `uint : Foo<$1>`, where `$n` is an unbound\n+inference variable, we might replace it with `uint : Foo<%0>`, where\n+`%n` is a skolemized type. We would then look this up in the cache.\n+If we found a hit, the hit would tell us the immediate next step to\n+take in the selection process: i.e., apply impl #22, or apply where\n+clause `X : Foo<Y>`. Let's say in this case there is no hit.\n+Therefore, we search through impls and where clauses and so forth, and\n+we come to the conclusion that the only possible impl is this one,\n+with def-id 22:\n+\n+    impl Foo<int> for uint { ... } // Impl #22\n+\n+We would then record in the cache `uint : Foo<%0> ==>\n+ImplCandidate(22)`. Next we would confirm `ImplCandidate(22)`, which\n+would (as a side-effect) unify `$1` with `int`.\n+\n+Now, at some later time, we might come along and see a `uint :\n+Foo<$3>`.  When skolemized, this would yield `uint : Foo<%0>`, just as\n+before, and hence the cache lookup would succeed, yielding\n+`ImplCandidate(22)`. We would confirm `ImplCandidate(22)` which would\n+(as a side-effect) unify `$3` with `int`.\n+\n+## Where clauses and the local vs global cache\n+\n+One subtle interaction is that the results of trait lookup will vary\n+depending on what where clauses are in scope. Therefore, we actually\n+have *two* caches, a local and a global cache. The local cache is\n+attached to the `ParameterEnvironment` and the global cache attached\n+to the `tcx`. We use the local cache whenever the result might depend\n+on the where clauses that are in scope. The determination of which\n+cache to use is done by the method `pick_candidate_cache` in\n+`select.rs`.\n+\n+There are two cases where we currently use the local cache. The\n+current rules are probably more conservative than necessary.\n+\n+### Trait references that involve parameter types\n+\n+The most obvious case where you need the local environment is\n+when the trait reference includes parameter types. For example,\n+consider the following function:\n+\n+    impl<T> Vec<T> {\n+        fn foo(x: T)\n+            where T : Foo\n+        { ... }\n+\n+        fn bar(x: T)\n+        { ... }\n+    }\n+\n+If there is an obligation `T : Foo`, or `int : Bar<T>`, or whatever,\n+clearly the results from `foo` and `bar` are potentially different,\n+since the set of where clauses in scope are different.\n+\n+### Trait references with unbound variables when where clauses are in scope\n+\n+There is another less obvious interaction which involves unbound variables\n+where *only* where clauses are in scope (no impls). This manifested as\n+issue #18209 (`run-pass/trait-cache-issue-18209.rs`). Consider\n+this snippet:\n+\n+```\n+pub trait Foo {\n+    fn load_from() -> Box<Self>;\n+    fn load() -> Box<Self> {\n+        Foo::load_from()\n+    }\n+}\n+```\n+\n+The default method will incur an obligation `$0 : Foo` from the call\n+to `load_from`. If there are no impls, this can be eagerly resolved to\n+`VtableParam(Self : Foo)` and cached. Because the trait reference\n+doesn't involve any parameters types (only the resolution does), this\n+result was stored in the global cache, causing later calls to\n+`Foo::load_from()` to get nonsense.\n+\n+To fix this, we always use the local cache if there are unbound\n+variables and where clauses in scope. This is more conservative than\n+necessary as far as I can tell. However, it still seems to be a simple\n+rule and I observe ~99% hit rate on rustc, so it doesn't seem to hurt\n+us in particular.\n+\n+Here is an example of the kind of subtle case that I would be worried\n+about with a more complex rule (although this particular case works\n+out ok). Imagine the trait reference doesn't directly reference a\n+where clause, but the where clause plays a role in the winnowing\n+phase. Something like this:\n+\n+```\n+pub trait Foo<T> { ... }\n+pub trait Bar { ... }\n+impl<U,T:Bar> Foo<U> for T { ... } // Impl A\n+impl Foo<char> for uint { ... }    // Impl B\n+```\n+\n+Now, in some function, we have no where clauses in scope, and we have\n+an obligation `$1 : Foo<$0>`. We might then conclude that `$0=char`\n+and `$1=uint`: this is because for impl A to apply, `uint:Bar` would\n+have to hold, and we know it does not or else the coherence check\n+would have failed.  So we might enter into our global cache: `$1 :\n+Foo<$0> => Impl B`.  Then we come along in a different scope, where a\n+generic type `A` is around with the bound `A:Bar`. Now suddenly the\n+impl is viable.\n+\n+The flaw in this imaginary DOOMSDAY SCENARIO is that we would not\n+currently conclude that `$1 : Foo<$0>` implies that `$0 == uint` and\n+`$1 == char`, even though it is true that (absent type parameters)\n+there is no other type the user could enter. However, it is not\n+*completely* implausible that we *could* draw this conclusion in the\n+future; we wouldn't have to guess types, in particular, we could be\n+led by the impls.\n+\n+*/"}, {"sha": "213d97b4b344aecd851b8bfa1bf6387e49fc891b", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use middle::infer::InferCtxt;\n use middle::mem_categorization::Typer;\n use middle::ty::{mod, Ty};\n-use middle::infer::{mod, InferCtxt};\n use std::collections::HashSet;\n use std::collections::hash_map::{Occupied, Vacant};\n use std::default::Default;\n@@ -28,7 +28,7 @@ use super::ObligationCause;\n use super::PredicateObligation;\n use super::Selection;\n use super::select::SelectionContext;\n-use super::trait_ref_for_builtin_bound;\n+use super::poly_trait_ref_for_builtin_bound;\n use super::Unimplemented;\n \n /// The fulfillment context is used to drive trait resolution.  It\n@@ -107,7 +107,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n                                   builtin_bound: ty::BuiltinBound,\n                                   cause: ObligationCause<'tcx>)\n     {\n-        match trait_ref_for_builtin_bound(tcx, builtin_bound, ty) {\n+        match poly_trait_ref_for_builtin_bound(tcx, builtin_bound, ty) {\n             Ok(trait_ref) => {\n                 self.register_trait_ref(tcx, trait_ref, cause);\n             }\n@@ -117,7 +117,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n     pub fn register_trait_ref<'a>(&mut self,\n                                   tcx: &ty::ctxt<'tcx>,\n-                                  trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                                  trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n                                   cause: ObligationCause<'tcx>)\n     {\n         /*!\n@@ -329,30 +329,47 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n             }\n         }\n \n-        ty::Predicate::Equate(a, b) => {\n-            let origin = infer::EquatePredicate(predicate.cause.span);\n-            match infer::mk_eqty(selcx.infcx(), false, origin, a, b) {\n-                Ok(()) => {\n-                    true\n-                }\n+        ty::Predicate::Equate(ref binder) => {\n+            match selcx.infcx().equality_predicate(predicate.cause.span, binder) {\n+                Ok(()) => { }\n                 Err(_) => {\n                     errors.push(\n                         FulfillmentError::new(\n                             predicate.clone(),\n                             CodeSelectionError(Unimplemented)));\n-                    true\n                 }\n             }\n+            true\n         }\n \n-        ty::Predicate::RegionOutlives(r_a, r_b) => {\n-            let origin = infer::RelateRegionParamBound(predicate.cause.span);\n-            let () = infer::mk_subr(selcx.infcx(), origin, r_b, r_a); // `b : a` ==> `a <= b`\n+        ty::Predicate::RegionOutlives(ref binder) => {\n+            match selcx.infcx().region_outlives_predicate(predicate.cause.span, binder) {\n+                Ok(()) => { }\n+                Err(_) => {\n+                    errors.push(\n+                        FulfillmentError::new(\n+                            predicate.clone(),\n+                            CodeSelectionError(Unimplemented)));\n+                }\n+            }\n+\n             true\n         }\n \n-        ty::Predicate::TypeOutlives(t_a, r_b) => {\n-            register_region_obligation(tcx, t_a, r_b, predicate.cause, region_obligations);\n+        ty::Predicate::TypeOutlives(ref binder) => {\n+            // For now, we just check that there are no higher-ranked\n+            // regions.  If there are, we will call this obligation an\n+            // error. Eventually we should be able to support some\n+            // cases here, I imagine (e.g., `for<'a> int : 'a`).\n+            if ty::count_late_bound_regions(selcx.tcx(), binder) != 0 {\n+                errors.push(\n+                    FulfillmentError::new(\n+                        predicate.clone(),\n+                        CodeSelectionError(Unimplemented)));\n+            } else {\n+                let ty::OutlivesPredicate(t_a, r_b) = binder.0;\n+                register_region_obligation(tcx, t_a, r_b, predicate.cause, region_obligations);\n+            }\n             true\n         }\n     }\n@@ -385,3 +402,4 @@ fn register_region_obligation<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n \n }\n+"}, {"sha": "3289acd0c2e5e0b78ba4a893c1fcdd4540cdf2b2", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -33,7 +33,7 @@ pub use self::util::supertraits;\n pub use self::util::Supertraits;\n pub use self::util::search_trait_and_supertraits_from_bound;\n pub use self::util::transitive_bounds;\n-pub use self::util::trait_ref_for_builtin_bound;\n+pub use self::util::poly_trait_ref_for_builtin_bound;\n \n mod coherence;\n mod fulfill;\n@@ -54,7 +54,7 @@ pub struct Obligation<'tcx, T> {\n }\n \n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n-pub type TraitObligation<'tcx> = Obligation<'tcx, Rc<ty::TraitRef<'tcx>>>;\n+pub type TraitObligation<'tcx> = Obligation<'tcx, Rc<ty::PolyTraitRef<'tcx>>>;\n \n /// Why did we incur this obligation? Used for error reporting.\n #[deriving(Copy, Clone)]\n@@ -115,7 +115,9 @@ pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n pub enum SelectionError<'tcx> {\n     Unimplemented,\n     Overflow,\n-    OutputTypeParameterMismatch(Rc<ty::TraitRef<'tcx>>, Rc<ty::TraitRef<'tcx>>, ty::type_err<'tcx>),\n+    OutputTypeParameterMismatch(Rc<ty::PolyTraitRef<'tcx>>,\n+                                Rc<ty::PolyTraitRef<'tcx>>,\n+                                ty::type_err<'tcx>),\n }\n \n pub struct FulfillmentError<'tcx> {\n@@ -226,7 +228,7 @@ pub struct VtableBuiltinData<N> {\n #[deriving(PartialEq,Eq,Clone)]\n pub struct VtableParamData<'tcx> {\n     // In the above example, this would `Eq`\n-    pub bound: Rc<ty::TraitRef<'tcx>>,\n+    pub bound: Rc<ty::PolyTraitRef<'tcx>>,\n }\n \n /// True if neither the trait nor self type is local. Note that `impl_def_id` must refer to an impl\n@@ -278,7 +280,7 @@ impl<'tcx,O> Obligation<'tcx,O> {\n     }\n }\n \n-impl<'tcx> Obligation<'tcx,Rc<ty::TraitRef<'tcx>>> {\n+impl<'tcx> TraitObligation<'tcx> {\n     pub fn self_ty(&self) -> Ty<'tcx> {\n         self.trait_ref.self_ty()\n     }"}, {"sha": "6c7ae666ae06cdc9e80f1ce9dac1f36e9316d483", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 238, "deletions": 198, "changes": 436, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -28,9 +28,9 @@ use super::{util};\n use middle::fast_reject;\n use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n-use middle::ty::{mod, Ty};\n+use middle::ty::{mod, AsPredicate, RegionEscape, Ty};\n use middle::infer;\n-use middle::infer::{InferCtxt, TypeSkolemizer};\n+use middle::infer::{InferCtxt, TypeFreshener};\n use middle::ty_fold::TypeFoldable;\n use std::cell::RefCell;\n use std::collections::hash_map::HashMap;\n@@ -44,12 +44,12 @@ pub struct SelectionContext<'cx, 'tcx:'cx> {\n     param_env: &'cx ty::ParameterEnvironment<'tcx>,\n     typer: &'cx (Typer<'tcx>+'cx),\n \n-    /// Skolemizer used specifically for skolemizing entries on the\n+    /// Freshener used specifically for skolemizing entries on the\n     /// obligation stack. This ensures that all entries on the stack\n     /// at one time will have the same set of skolemized entries,\n     /// which is important for checking for trait bounds that\n     /// recursively require themselves.\n-    skolemizer: TypeSkolemizer<'cx, 'tcx>,\n+    freshener: TypeFreshener<'cx, 'tcx>,\n \n     /// If true, indicates that the evaluation should be conservative\n     /// and consider the possibility of types outside this crate.\n@@ -73,15 +73,15 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n     obligation: &'prev TraitObligation<'tcx>,\n \n     /// Trait ref from `obligation` but skolemized with the\n-    /// selection-context's skolemizer. Used to check for recursion.\n-    skol_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    /// selection-context's freshener. Used to check for recursion.\n+    fresh_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n \n     previous: Option<&'prev TraitObligationStack<'prev, 'tcx>>\n }\n \n #[deriving(Clone)]\n pub struct SelectionCache<'tcx> {\n-    hashmap: RefCell<HashMap<Rc<ty::TraitRef<'tcx>>,\n+    hashmap: RefCell<HashMap<Rc<ty::PolyTraitRef<'tcx>>,\n                              SelectionResult<'tcx, Candidate<'tcx>>>>,\n }\n \n@@ -172,7 +172,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             infcx: infcx,\n             param_env: param_env,\n             typer: typer,\n-            skolemizer: infcx.skolemizer(),\n+            freshener: infcx.freshener(),\n             intercrate: false,\n         }\n     }\n@@ -185,7 +185,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             infcx: infcx,\n             param_env: param_env,\n             typer: typer,\n-            skolemizer: infcx.skolemizer(),\n+            freshener: infcx.freshener(),\n             intercrate: true,\n         }\n     }\n@@ -288,8 +288,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.evaluate_obligation_recursively(previous_stack, &obligation)\n             }\n \n-            ty::Predicate::Equate(a, b) => {\n-                match infer::can_mk_eqty(self.infcx, a, b) {\n+            ty::Predicate::Equate(ref p) => {\n+                let result = self.infcx.probe(|_| {\n+                    self.infcx.equality_predicate(obligation.cause.span, p)\n+                });\n+                match result {\n                     Ok(()) => EvaluatedToOk,\n                     Err(_) => EvaluatedToErr(Unimplemented),\n                 }\n@@ -347,16 +350,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // This suffices to allow chains like `FnMut` implemented in\n         // terms of `Fn` etc, but we could probably make this more\n         // precise still.\n-        let input_types = stack.skol_trait_ref.input_types();\n-        let unbound_input_types = input_types.iter().any(|&t| ty::type_is_skolemized(t));\n+        let input_types = stack.fresh_trait_ref.0.input_types();\n+        let unbound_input_types = input_types.iter().any(|&t| ty::type_is_fresh(t));\n         if\n             unbound_input_types &&\n              (self.intercrate ||\n               stack.iter().skip(1).any(\n-                  |prev| stack.skol_trait_ref.def_id == prev.skol_trait_ref.def_id))\n+                  |prev| stack.fresh_trait_ref.def_id() == prev.fresh_trait_ref.def_id()))\n         {\n             debug!(\"evaluate_stack({}) --> unbound argument, recursion -->  ambiguous\",\n-                   stack.skol_trait_ref.repr(self.tcx()));\n+                   stack.fresh_trait_ref.repr(self.tcx()));\n             return EvaluatedToAmbig;\n         }\n \n@@ -373,19 +376,19 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // `Option<Box<List<T>>>` is `Send` if `Box<List<T>>` is\n         // `Send`.\n         //\n-        // Note that we do this comparison using the `skol_trait_ref`\n+        // Note that we do this comparison using the `fresh_trait_ref`\n         // fields. Because these have all been skolemized using\n-        // `self.skolemizer`, we can be sure that (a) this will not\n+        // `self.freshener`, we can be sure that (a) this will not\n         // affect the inferencer state and (b) that if we see two\n         // skolemized types with the same index, they refer to the\n         // same unbound type variable.\n         if\n             stack.iter()\n             .skip(1) // skip top-most frame\n-            .any(|prev| stack.skol_trait_ref == prev.skol_trait_ref)\n+            .any(|prev| stack.fresh_trait_ref == prev.fresh_trait_ref)\n         {\n             debug!(\"evaluate_stack({}) --> recursive\",\n-                   stack.skol_trait_ref.repr(self.tcx()));\n+                   stack.fresh_trait_ref.repr(self.tcx()));\n             return EvaluatedToOk;\n         }\n \n@@ -407,13 +410,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                impl_def_id.repr(self.tcx()),\n                obligation.repr(self.tcx()));\n \n-        self.infcx.probe(|| {\n-            match self.match_impl(impl_def_id, obligation) {\n+        self.infcx.probe(|snapshot| {\n+            let (skol_obligation_trait_ref, skol_map) =\n+                self.infcx().skolemize_late_bound_regions(&*obligation.trait_ref, snapshot);\n+            match self.match_impl(impl_def_id, obligation, snapshot,\n+                                  &skol_map, Rc::new(skol_obligation_trait_ref)) {\n                 Ok(substs) => {\n                     let vtable_impl = self.vtable_impl(impl_def_id,\n                                                        substs,\n                                                        obligation.cause,\n-                                                       obligation.recursion_depth + 1);\n+                                                       obligation.recursion_depth + 1,\n+                                                       skol_map,\n+                                                       snapshot);\n                     self.winnow_selection(None, VtableImpl(vtable_impl)).may_apply()\n                 }\n                 Err(()) => {\n@@ -445,20 +453,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         // Check the cache. Note that we skolemize the trait-ref\n-        // separately rather than using `stack.skol_trait_ref` -- this\n+        // separately rather than using `stack.fresh_trait_ref` -- this\n         // is because we want the unbound variables to be replaced\n         // with fresh skolemized types starting from index 0.\n-        let cache_skol_trait_ref =\n-            self.infcx.skolemize(stack.obligation.trait_ref.clone());\n-        debug!(\"candidate_from_obligation(cache_skol_trait_ref={}, obligation={})\",\n-               cache_skol_trait_ref.repr(self.tcx()),\n+        let cache_fresh_trait_ref =\n+            self.infcx.freshen(stack.obligation.trait_ref.clone());\n+        debug!(\"candidate_from_obligation(cache_fresh_trait_ref={}, obligation={})\",\n+               cache_fresh_trait_ref.repr(self.tcx()),\n                stack.repr(self.tcx()));\n         assert!(!stack.obligation.trait_ref.has_escaping_regions());\n \n-        match self.check_candidate_cache(cache_skol_trait_ref.clone()) {\n+        match self.check_candidate_cache(cache_fresh_trait_ref.clone()) {\n             Some(c) => {\n-                debug!(\"CACHE HIT: cache_skol_trait_ref={}, candidate={}\",\n-                       cache_skol_trait_ref.repr(self.tcx()),\n+                debug!(\"CACHE HIT: cache_fresh_trait_ref={}, candidate={}\",\n+                       cache_fresh_trait_ref.repr(self.tcx()),\n                        c.repr(self.tcx()));\n                 return c;\n             }\n@@ -467,9 +475,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // If no match, compute result and insert into cache.\n         let candidate = self.candidate_from_obligation_no_cache(stack);\n-        debug!(\"CACHE MISS: cache_skol_trait_ref={}, candidate={}\",\n-               cache_skol_trait_ref.repr(self.tcx()), candidate.repr(self.tcx()));\n-        self.insert_candidate_cache(cache_skol_trait_ref, candidate.clone());\n+        debug!(\"CACHE MISS: cache_fresh_trait_ref={}, candidate={}\",\n+               cache_fresh_trait_ref.repr(self.tcx()), candidate.repr(self.tcx()));\n+        self.insert_candidate_cache(cache_fresh_trait_ref, candidate.clone());\n         candidate\n     }\n \n@@ -569,7 +577,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn pick_candidate_cache(&self,\n-                            cache_skol_trait_ref: &Rc<ty::TraitRef<'tcx>>)\n+                            cache_fresh_trait_ref: &Rc<ty::PolyTraitRef<'tcx>>)\n                             -> &SelectionCache<'tcx>\n     {\n         // High-level idea: we have to decide whether to consult the\n@@ -591,7 +599,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // If the trait refers to any parameters in scope, then use\n         // the cache of the param-environment.\n         if\n-            cache_skol_trait_ref.input_types().iter().any(\n+            cache_fresh_trait_ref.0.input_types().iter().any(\n                 |&t| ty::type_has_self(t) || ty::type_has_params(t))\n         {\n             return &self.param_env.selection_cache;\n@@ -604,7 +612,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // See the discussion in doc.rs for more details.\n         if\n             !self.param_env.caller_bounds.is_empty() &&\n-            cache_skol_trait_ref.input_types().iter().any(\n+            cache_fresh_trait_ref.0.input_types().iter().any(\n                 |&t| ty::type_has_ty_infer(t))\n         {\n             return &self.param_env.selection_cache;\n@@ -615,21 +623,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn check_candidate_cache(&mut self,\n-                             cache_skol_trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                             cache_fresh_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n                              -> Option<SelectionResult<'tcx, Candidate<'tcx>>>\n     {\n-        let cache = self.pick_candidate_cache(&cache_skol_trait_ref);\n+        let cache = self.pick_candidate_cache(&cache_fresh_trait_ref);\n         let hashmap = cache.hashmap.borrow();\n-        hashmap.get(&cache_skol_trait_ref).map(|c| (*c).clone())\n+        hashmap.get(&cache_fresh_trait_ref).map(|c| (*c).clone())\n     }\n \n     fn insert_candidate_cache(&mut self,\n-                              cache_skol_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                              cache_fresh_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n                               candidate: SelectionResult<'tcx, Candidate<'tcx>>)\n     {\n-        let cache = self.pick_candidate_cache(&cache_skol_trait_ref);\n+        let cache = self.pick_candidate_cache(&cache_fresh_trait_ref);\n         let mut hashmap = cache.hashmap.borrow_mut();\n-        hashmap.insert(cache_skol_trait_ref, candidate);\n+        hashmap.insert(cache_fresh_trait_ref, candidate);\n     }\n \n     fn assemble_candidates<'o>(&mut self,\n@@ -648,7 +656,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n \n-        match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.def_id) {\n+        match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.def_id()) {\n             Some(ty::BoundCopy) => {\n                 debug!(\"obligation self ty is {}\",\n                        obligation.self_ty().repr(self.tcx()));\n@@ -696,7 +704,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"assemble_candidates_from_caller_bounds({})\",\n                obligation.repr(self.tcx()));\n \n-        let caller_trait_refs: Vec<Rc<ty::TraitRef>> =\n+        let caller_trait_refs: Vec<_> =\n             self.param_env.caller_bounds.predicates.iter()\n             .filter_map(|o| o.to_trait())\n             .collect();\n@@ -708,8 +716,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let matching_bounds =\n             all_bounds.filter(\n                 |bound| self.infcx.probe(\n-                    || self.match_trait_refs(obligation,\n-                                             (*bound).clone())).is_ok());\n+                    |_| self.match_where_clause(obligation, bound.clone())).is_ok());\n \n         let param_candidates =\n             matching_bounds.map(\n@@ -731,7 +738,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                            candidates: &mut CandidateSet<'tcx>)\n                                            -> Result<(),SelectionError<'tcx>>\n     {\n-        let kind = match self.fn_family_trait_kind(obligation.trait_ref.def_id) {\n+        let kind = match self.fn_family_trait_kind(obligation.trait_ref.def_id()) {\n             Some(k) => k,\n             None => { return Ok(()); }\n         };\n@@ -779,7 +786,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // We provide a `Fn` impl for fn pointers. There is no need to provide\n         // the other traits (e.g. `FnMut`) since those are provided by blanket\n         // impls.\n-        if Some(obligation.trait_ref.def_id) != self.tcx().lang_items.fn_trait() {\n+        if Some(obligation.trait_ref.def_id()) != self.tcx().lang_items.fn_trait() {\n             return Ok(());\n         }\n \n@@ -793,11 +800,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::ty_bare_fn(ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n-                sig: ty::FnSig {\n+                sig: ty::Binder(ty::FnSig {\n                     inputs: _,\n                     output: ty::FnConverging(_),\n                     variadic: false\n-                }\n+                })\n             }) => {\n                 candidates.vec.push(FnPointerCandidate);\n             }\n@@ -814,10 +821,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       candidates: &mut CandidateSet<'tcx>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n-        let all_impls = self.all_impls(obligation.trait_ref.def_id);\n+        let all_impls = self.all_impls(obligation.trait_ref.def_id());\n         for &impl_def_id in all_impls.iter() {\n-            self.infcx.probe(|| {\n-                match self.match_impl(impl_def_id, obligation) {\n+            self.infcx.probe(|snapshot| {\n+                let (skol_obligation_trait_ref, skol_map) =\n+                    self.infcx().skolemize_late_bound_regions(&*obligation.trait_ref, snapshot);\n+                match self.match_impl(impl_def_id, obligation, snapshot,\n+                                      &skol_map, Rc::new(skol_obligation_trait_ref)) {\n                     Ok(_) => {\n                         candidates.vec.push(ImplCandidate(impl_def_id));\n                     }\n@@ -845,15 +855,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             candidate: &Candidate<'tcx>)\n                             -> EvaluationResult<'tcx>\n     {\n-        /*!\n-         * Further evaluate `candidate` to decide whether all type parameters match\n-         * and whether nested obligations are met. Returns true if `candidate` remains\n-         * viable after this further scrutiny.\n-         */\n-\n-        debug!(\"winnow_candidate: depth={} candidate={}\",\n-               stack.obligation.recursion_depth, candidate.repr(self.tcx()));\n-        let result = self.infcx.probe(|| {\n+        debug!(\"winnow_candidate: candidate={}\", candidate.repr(self.tcx()));\n+        let result = self.infcx.probe(|_| {\n             let candidate = (*candidate).clone();\n             match self.confirm_candidate(stack.obligation, candidate) {\n                 Ok(selection) => self.winnow_selection(Some(stack), selection),\n@@ -916,18 +919,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                        candidate_i.repr(self.tcx()),\n                        candidate_j.repr(self.tcx()));\n \n-                self.infcx.probe(|| {\n+                self.infcx.probe(|snapshot| {\n+                    let (skol_obligation_trait_ref, skol_map) =\n+                        self.infcx().skolemize_late_bound_regions(\n+                            &*stack.obligation.trait_ref, snapshot);\n                     let impl_substs =\n-                        self.rematch_impl(impl_def_id, stack.obligation);\n+                        self.rematch_impl(impl_def_id, stack.obligation, snapshot,\n+                                          &skol_map, Rc::new(skol_obligation_trait_ref));\n                     let impl_trait_ref =\n                         ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap();\n                     let impl_trait_ref =\n                         impl_trait_ref.subst(self.tcx(), &impl_substs);\n+                    let poly_impl_trait_ref =\n+                        Rc::new(ty::Binder((*impl_trait_ref).clone()));\n                     let origin =\n                         infer::RelateOutputImplTypes(stack.obligation.cause.span);\n                     self.infcx\n-                        .sub_trait_refs(false, origin,\n-                                        impl_trait_ref, vt.bound.clone())\n+                        .sub_poly_trait_refs(false, origin, poly_impl_trait_ref, vt.bound.clone())\n                         .is_ok()\n                 })\n             }\n@@ -1071,26 +1079,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n+            ty::ty_trait(ref data) => {\n                 match bound {\n                     ty::BoundSized => {\n                         Err(Unimplemented)\n                     }\n                     ty::BoundCopy | ty::BoundSync | ty::BoundSend => {\n-                        if bounds.builtin_bounds.contains(&bound) {\n+                        if data.bounds.builtin_bounds.contains(&bound) {\n                             Ok(If(Vec::new()))\n                         } else {\n                             // Recursively check all supertraits to find out if any further\n                             // bounds are required and thus we must fulfill.\n-                            // We have to create a temp trait ref here since TyTraits don't\n-                            // have actual self type info (which is required for the\n-                            // supertraits iterator).\n-                            let tmp_tr = Rc::new(ty::TraitRef {\n-                                def_id: principal.def_id,\n-                                substs: principal.substs.with_self_ty(ty::mk_err())\n-                            });\n+                            let tmp_tr = data.principal_trait_ref_with_self_ty(ty::mk_err());\n                             for tr in util::supertraits(self.tcx(), tmp_tr) {\n-                                let td = ty::lookup_trait_def(self.tcx(), tr.def_id);\n+                                let td = ty::lookup_trait_def(self.tcx(), tr.def_id());\n \n                                 if td.bounds.builtin_bounds.contains(&bound) {\n                                     return Ok(If(Vec::new()))\n@@ -1276,8 +1278,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::ty_open(_) |\n-            ty::ty_infer(ty::SkolemizedTy(_)) |\n-            ty::ty_infer(ty::SkolemizedIntTy(_)) => {\n+            ty::ty_infer(ty::FreshTy(_)) |\n+            ty::ty_infer(ty::FreshIntTy(_)) => {\n                 self.tcx().sess.bug(\n                     format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n@@ -1404,10 +1406,21 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                obligation.repr(self.tcx()),\n                param.repr(self.tcx()));\n \n-        let () = try!(self.confirm(obligation.cause,\n-                                   obligation.trait_ref.clone(),\n-                                   param.bound.clone()));\n-        Ok(param)\n+        // During evaluation, we already checked that this\n+        // where-clause trait-ref could be unified with the obligation\n+        // trait-ref. Repeat that unification now without any\n+        // transactional boundary; it should not fail.\n+        match self.confirm_poly_trait_refs(obligation.cause,\n+                                           obligation.trait_ref.clone(),\n+                                           param.bound.clone()) {\n+            Ok(()) => Ok(param),\n+            Err(_) => {\n+                self.tcx().sess.bug(\n+                    format!(\"Where clause `{}` was applicable to `{}` but now is not\",\n+                            param.bound.repr(self.tcx()),\n+                            obligation.repr(self.tcx())).as_slice());\n+            }\n+        }\n     }\n \n     fn confirm_builtin_candidate(&mut self,\n@@ -1454,8 +1467,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligations.push(Obligation {\n                 cause: obligation.cause,\n                 recursion_depth: obligation.recursion_depth+1,\n-                trait_ref: ty::Predicate::TypeOutlives(obligation.self_ty(),\n-                                                       ty::ReStatic)\n+                trait_ref: ty::Binder(ty::OutlivesPredicate(obligation.self_ty(),\n+                                                            ty::ReStatic)).as_predicate(),\n             });\n         }\n \n@@ -1480,23 +1493,44 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // First, create the substitutions by matching the impl again,\n         // this time not in a probe.\n-        let substs = self.rematch_impl(impl_def_id, obligation);\n-        debug!(\"confirm_impl_candidate substs={}\", substs);\n-        Ok(self.vtable_impl(impl_def_id, substs, obligation.cause, obligation.recursion_depth + 1))\n+        self.infcx.try(|snapshot| {\n+            let (skol_obligation_trait_ref, skol_map) =\n+                self.infcx().skolemize_late_bound_regions(&*obligation.trait_ref, snapshot);\n+            let substs = self.rematch_impl(impl_def_id, obligation,\n+                                           snapshot, &skol_map, Rc::new(skol_obligation_trait_ref));\n+            debug!(\"confirm_impl_candidate substs={}\", substs);\n+            Ok(self.vtable_impl(impl_def_id, substs, obligation.cause,\n+                                obligation.recursion_depth + 1, skol_map, snapshot))\n+        })\n     }\n \n     fn vtable_impl(&mut self,\n                    impl_def_id: ast::DefId,\n                    substs: Substs<'tcx>,\n                    cause: ObligationCause<'tcx>,\n-                   recursion_depth: uint)\n+                   recursion_depth: uint,\n+                   skol_map: infer::SkolemizationMap,\n+                   snapshot: &infer::CombinedSnapshot)\n                    -> VtableImplData<'tcx, PredicateObligation<'tcx>>\n     {\n+        debug!(\"vtable_impl(impl_def_id={}, substs={}, recursion_depth={}, skol_map={})\",\n+               impl_def_id.repr(self.tcx()),\n+               substs.repr(self.tcx()),\n+               recursion_depth,\n+               skol_map.repr(self.tcx()));\n+\n         let impl_predicates =\n             self.impl_predicates(cause,\n                                  recursion_depth,\n                                  impl_def_id,\n-                                 &substs);\n+                                 &substs,\n+                                 skol_map,\n+                                 snapshot);\n+\n+        debug!(\"vtable_impl: impl_def_id={} impl_predicates={}\",\n+               impl_def_id.repr(self.tcx()),\n+               impl_predicates.repr(self.tcx()));\n+\n         VtableImplData { impl_def_id: impl_def_id,\n                          substs: substs,\n                          nested: impl_predicates }\n@@ -1526,23 +1560,22 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n-        let arguments_tuple = ty::mk_tup(self.tcx(), sig.inputs.to_vec());\n-        let output_type = sig.output.unwrap();\n+        let arguments_tuple = ty::mk_tup(self.tcx(), sig.0.inputs.to_vec());\n+        let output_type = sig.0.output.unwrap();\n         let substs =\n             Substs::new_trait(\n                 vec![arguments_tuple, output_type],\n                 vec![],\n                 vec![],\n                 self_ty);\n-        let trait_ref = Rc::new(ty::TraitRef {\n-            def_id: obligation.trait_ref.def_id,\n+        let trait_ref = Rc::new(ty::Binder(ty::TraitRef {\n+            def_id: obligation.trait_ref.def_id(),\n             substs: substs,\n-        });\n+        }));\n \n-        let () =\n-            try!(self.confirm(obligation.cause,\n-                              obligation.trait_ref.clone(),\n-                              trait_ref));\n+        try!(self.confirm_poly_trait_refs(obligation.cause,\n+                                          obligation.trait_ref.clone(),\n+                                          trait_ref));\n \n         Ok(self_ty)\n     }\n@@ -1569,26 +1602,69 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n \n         let closure_sig = &closure_type.sig;\n-        let arguments_tuple = closure_sig.inputs[0];\n+        let arguments_tuple = closure_sig.0.inputs[0];\n         let substs =\n             Substs::new_trait(\n                 vec![arguments_tuple.subst(self.tcx(), substs),\n-                     closure_sig.output.unwrap().subst(self.tcx(), substs)],\n+                     closure_sig.0.output.unwrap().subst(self.tcx(), substs)],\n                 vec![],\n                 vec![],\n                 obligation.self_ty());\n-        let trait_ref = Rc::new(ty::TraitRef {\n-            def_id: obligation.trait_ref.def_id,\n+        let trait_ref = Rc::new(ty::Binder(ty::TraitRef {\n+            def_id: obligation.trait_ref.def_id(),\n             substs: substs,\n-        });\n+        }));\n \n         debug!(\"confirm_unboxed_closure_candidate(closure_def_id={}, trait_ref={})\",\n                closure_def_id.repr(self.tcx()),\n                trait_ref.repr(self.tcx()));\n \n-        self.confirm(obligation.cause,\n-                     obligation.trait_ref.clone(),\n-                     trait_ref)\n+        self.confirm_poly_trait_refs(obligation.cause,\n+                                     obligation.trait_ref.clone(),\n+                                     trait_ref)\n+    }\n+\n+    /// In the case of unboxed closure types and fn pointers,\n+    /// we currently treat the input type parameters on the trait as\n+    /// outputs. This means that when we have a match we have only\n+    /// considered the self type, so we have to go back and make sure\n+    /// to relate the argument types too.  This is kind of wrong, but\n+    /// since we control the full set of impls, also not that wrong,\n+    /// and it DOES yield better error messages (since we don't report\n+    /// errors as if there is no applicable impl, but rather report\n+    /// errors are about mismatched argument types.\n+    ///\n+    /// Here is an example. Imagine we have an unboxed closure expression\n+    /// and we desugared it so that the type of the expression is\n+    /// `Closure`, and `Closure` expects an int as argument. Then it\n+    /// is \"as if\" the compiler generated this impl:\n+    ///\n+    ///     impl Fn(int) for Closure { ... }\n+    ///\n+    /// Now imagine our obligation is `Fn(uint) for Closure`. So far\n+    /// we have matched the self-type `Closure`. At this point we'll\n+    /// compare the `int` to `uint` and generate an error.\n+    ///\n+    /// Note that this checking occurs *after* the impl has selected,\n+    /// because these output type parameters should not affect the\n+    /// selection of the impl. Therefore, if there is a mismatch, we\n+    /// report an error to the user.\n+    fn confirm_poly_trait_refs(&mut self,\n+                               obligation_cause: ObligationCause,\n+                               obligation_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n+                               expected_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n+                               -> Result<(), SelectionError<'tcx>>\n+    {\n+        let origin = infer::RelateOutputImplTypes(obligation_cause.span);\n+\n+        let obligation_trait_ref = obligation_trait_ref.clone();\n+        match self.infcx.sub_poly_trait_refs(false,\n+                                             origin,\n+                                             expected_trait_ref.clone(),\n+                                             obligation_trait_ref.clone()) {\n+            Ok(()) => Ok(()),\n+            Err(e) => Err(OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n+        }\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -1603,10 +1679,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn rematch_impl(&mut self,\n                     impl_def_id: ast::DefId,\n-                    obligation: &TraitObligation<'tcx>)\n+                    obligation: &TraitObligation<'tcx>,\n+                    snapshot: &infer::CombinedSnapshot,\n+                    skol_map: &infer::SkolemizationMap,\n+                    skol_obligation_trait_ref: Rc<ty::TraitRef<'tcx>>)\n                     -> Substs<'tcx>\n     {\n-        match self.match_impl(impl_def_id, obligation) {\n+        match self.match_impl(impl_def_id, obligation, snapshot,\n+                              skol_map, skol_obligation_trait_ref) {\n             Ok(substs) => {\n                 substs\n             }\n@@ -1622,11 +1702,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     fn match_impl(&mut self,\n                   impl_def_id: ast::DefId,\n-                  obligation: &TraitObligation<'tcx>)\n+                  obligation: &TraitObligation<'tcx>,\n+                  snapshot: &infer::CombinedSnapshot,\n+                  skol_map: &infer::SkolemizationMap,\n+                  skol_obligation_trait_ref: Rc<ty::TraitRef<'tcx>>)\n                   -> Result<Substs<'tcx>, ()>\n     {\n-        let impl_trait_ref = ty::impl_trait_ref(self.tcx(),\n-                                                impl_def_id).unwrap();\n+        let impl_trait_ref = ty::impl_trait_ref(self.tcx(), impl_def_id).unwrap();\n \n         // Before we create the substitutions and everything, first\n         // consider a \"quick reject\". This avoids creating more types\n@@ -1642,10 +1724,37 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n                                                   &impl_substs);\n \n-        match self.match_trait_refs(obligation, impl_trait_ref) {\n-            Ok(()) => Ok(impl_substs),\n-            Err(()) => Err(())\n+        debug!(\"match_impl(impl_def_id={}, obligation={}, \\\n+               impl_trait_ref={}, skol_obligation_trait_ref={})\",\n+               impl_def_id.repr(self.tcx()),\n+               obligation.repr(self.tcx()),\n+               impl_trait_ref.repr(self.tcx()),\n+               skol_obligation_trait_ref.repr(self.tcx()));\n+\n+        let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n+        match self.infcx.sub_trait_refs(false,\n+                                        origin,\n+                                        impl_trait_ref,\n+                                        skol_obligation_trait_ref) {\n+            Ok(()) => { }\n+            Err(e) => {\n+                debug!(\"match_impl: failed sub_trait_refs due to `{}`\",\n+                       ty::type_err_to_str(self.tcx(), &e));\n+                return Err(());\n+            }\n+        }\n+\n+        match self.infcx.leak_check(skol_map, snapshot) {\n+            Ok(()) => { }\n+            Err(e) => {\n+                debug!(\"match_impl: failed leak check due to `{}`\",\n+                       ty::type_err_to_str(self.tcx(), &e));\n+                return Err(());\n+            }\n         }\n+\n+        debug!(\"match_impl: success impl_substs={}\", impl_substs.repr(self.tcx()));\n+        Ok(impl_substs)\n     }\n \n     fn fast_reject_trait_refs(&mut self,\n@@ -1671,20 +1780,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n     }\n \n-    fn match_trait_refs(&mut self,\n-                        obligation: &TraitObligation<'tcx>,\n-                        trait_ref: Rc<ty::TraitRef<'tcx>>)\n+    fn match_where_clause(&mut self,\n+                          obligation: &TraitObligation<'tcx>,\n+                          where_clause_trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n                         -> Result<(),()>\n     {\n-        debug!(\"match_trait_refs: obligation={} trait_ref={}\",\n+        debug!(\"match_where_clause: obligation={} where_clause_trait_ref={}\",\n                obligation.repr(self.tcx()),\n-               trait_ref.repr(self.tcx()));\n+               where_clause_trait_ref.repr(self.tcx()));\n \n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n-        match self.infcx.sub_trait_refs(false,\n-                                        origin,\n-                                        trait_ref,\n-                                        obligation.trait_ref.clone()) {\n+        match self.infcx.sub_poly_trait_refs(false,\n+                                             origin,\n+                                             where_clause_trait_ref,\n+                                             obligation.trait_ref.clone()) {\n             Ok(()) => Ok(()),\n             Err(_) => Err(()),\n         }\n@@ -1758,78 +1867,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    ///////////////////////////////////////////////////////////////////////////\n-    // Confirmation\n-    //\n-    // The final step of selection: once we know how an obligation is\n-    // is resolved, we confirm that selection in order to have\n-    // side-effects on the typing environment. This step also unifies\n-    // the output type parameters from the obligation with those found\n-    // on the impl/bound, which may yield type errors.\n-\n-    /// Relates the output type parameters from an impl to the\n-    /// trait.  This may lead to type errors. The confirmation step\n-    /// is separated from the main match procedure because these\n-    /// type errors do not cause us to select another impl.\n-    ///\n-    /// As an example, consider matching the obligation\n-    /// `Iterator<char> for Elems<int>` using the following impl:\n-    ///\n-    ///    impl<T> Iterator<T> for Elems<T> { ... }\n-    ///\n-    /// The match phase will succeed with substitution `T=int`.\n-    /// The confirm step will then try to unify `int` and `char`\n-    /// and yield an error.\n-    fn confirm_impl_vtable(&mut self,\n-                           impl_def_id: ast::DefId,\n-                           obligation_cause: ObligationCause<'tcx>,\n-                           obligation_trait_ref: Rc<ty::TraitRef<'tcx>>,\n-                           substs: &Substs<'tcx>)\n-                           -> Result<(), SelectionError<'tcx>>\n-    {\n-        let impl_trait_ref = ty::impl_trait_ref(self.tcx(),\n-                                                impl_def_id).unwrap();\n-        let impl_trait_ref = impl_trait_ref.subst(self.tcx(),\n-                                                  substs);\n-        self.confirm(obligation_cause, obligation_trait_ref, impl_trait_ref)\n-    }\n-\n-    /// After we have determined which impl applies, and with what substitutions, there is one last\n-    /// step. We have to go back and relate the \"output\" type parameters from the obligation to the\n-    /// types that are specified in the impl.\n-    ///\n-    /// For example, imagine we have:\n-    ///\n-    ///     impl<T> Iterator<T> for Vec<T> { ... }\n-    ///\n-    /// and our obligation is `Iterator<Foo> for Vec<int>` (note the mismatch in the obligation\n-    /// types). Up until this step, no error would be reported: the self type is `Vec<int>`, and\n-    /// that matches `Vec<T>` with the substitution `T=int`. At this stage, we could then go and\n-    /// check that the type parameters to the `Iterator` trait match. (In terms of the parameters,\n-    /// the `expected_trait_ref` here would be `Iterator<int> for Vec<int>`, and the\n-    /// `obligation_trait_ref` would be `Iterator<Foo> for Vec<int>`.\n-    ///\n-    /// Note that this checking occurs *after* the impl has selected, because these output type\n-    /// parameters should not affect the selection of the impl. Therefore, if there is a mismatch,\n-    /// we report an error to the user.\n-    fn confirm(&mut self,\n-               obligation_cause: ObligationCause,\n-               obligation_trait_ref: Rc<ty::TraitRef<'tcx>>,\n-               expected_trait_ref: Rc<ty::TraitRef<'tcx>>)\n-               -> Result<(), SelectionError<'tcx>>\n-    {\n-        let origin = infer::RelateOutputImplTypes(obligation_cause.span);\n-\n-        let obligation_trait_ref = obligation_trait_ref.clone();\n-        match self.infcx.sub_trait_refs(false,\n-                                        origin,\n-                                        expected_trait_ref.clone(),\n-                                        obligation_trait_ref.clone()) {\n-            Ok(()) => Ok(()),\n-            Err(e) => Err(OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n-        }\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // Miscellany\n \n@@ -1838,11 +1875,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             obligation: &'o TraitObligation<'tcx>)\n                             -> TraitObligationStack<'o, 'tcx>\n     {\n-        let skol_trait_ref = obligation.trait_ref.fold_with(&mut self.skolemizer);\n+        let fresh_trait_ref = obligation.trait_ref.fold_with(&mut self.freshener);\n \n         TraitObligationStack {\n             obligation: obligation,\n-            skol_trait_ref: skol_trait_ref,\n+            fresh_trait_ref: fresh_trait_ref,\n             previous: previous_stack.map(|p| p), // FIXME variance\n         }\n     }\n@@ -1861,11 +1898,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                        cause: ObligationCause<'tcx>,\n                        recursion_depth: uint,\n                        impl_def_id: ast::DefId,\n-                       impl_substs: &Substs<'tcx>)\n+                       impl_substs: &Substs<'tcx>,\n+                       skol_map: infer::SkolemizationMap,\n+                       snapshot: &infer::CombinedSnapshot)\n                        -> VecPerParamSpace<PredicateObligation<'tcx>>\n     {\n         let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n         let bounds = impl_generics.to_bounds(self.tcx(), impl_substs);\n+        let bounds = self.infcx().plug_leaks(skol_map, snapshot, &bounds);\n         util::predicates_for_generics(self.tcx(), cause, recursion_depth, &bounds)\n     }\n "}, {"sha": "27824ba5c6e77b13b6b0043615692e924927462b", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -47,15 +47,15 @@ struct StackEntry<'tcx> {\n \n pub fn elaborate_trait_ref<'cx, 'tcx>(\n     tcx: &'cx ty::ctxt<'tcx>,\n-    trait_ref: Rc<ty::TraitRef<'tcx>>)\n+    trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n     -> Elaborator<'cx, 'tcx>\n {\n     elaborate_predicates(tcx, vec![ty::Predicate::Trait(trait_ref)])\n }\n \n pub fn elaborate_trait_refs<'cx, 'tcx>(\n     tcx: &'cx ty::ctxt<'tcx>,\n-    trait_refs: &[Rc<ty::TraitRef<'tcx>>])\n+    trait_refs: &[Rc<ty::PolyTraitRef<'tcx>>])\n     -> Elaborator<'cx, 'tcx>\n {\n     let predicates = trait_refs.iter()\n@@ -174,23 +174,23 @@ pub struct Supertraits<'cx, 'tcx:'cx> {\n }\n \n pub fn supertraits<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                              trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                              trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n                               -> Supertraits<'cx, 'tcx>\n {\n     let elaborator = elaborate_trait_ref(tcx, trait_ref);\n     Supertraits { elaborator: elaborator }\n }\n \n pub fn transitive_bounds<'cx, 'tcx>(tcx: &'cx ty::ctxt<'tcx>,\n-                                    bounds: &[Rc<ty::TraitRef<'tcx>>])\n+                                    bounds: &[Rc<ty::PolyTraitRef<'tcx>>])\n                                     -> Supertraits<'cx, 'tcx>\n {\n     let elaborator = elaborate_trait_refs(tcx, bounds);\n     Supertraits { elaborator: elaborator }\n }\n \n-impl<'cx, 'tcx> Iterator<Rc<ty::TraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n-    fn next(&mut self) -> Option<Rc<ty::TraitRef<'tcx>>> {\n+impl<'cx, 'tcx> Iterator<Rc<ty::PolyTraitRef<'tcx>>> for Supertraits<'cx, 'tcx> {\n+    fn next(&mut self) -> Option<Rc<ty::PolyTraitRef<'tcx>>> {\n         loop {\n             match self.elaborator.next() {\n                 None => {\n@@ -266,18 +266,18 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n     })\n }\n \n-pub fn trait_ref_for_builtin_bound<'tcx>(\n+pub fn poly_trait_ref_for_builtin_bound<'tcx>(\n     tcx: &ty::ctxt<'tcx>,\n     builtin_bound: ty::BuiltinBound,\n     param_ty: Ty<'tcx>)\n-    -> Result<Rc<ty::TraitRef<'tcx>>, ErrorReported>\n+    -> Result<Rc<ty::PolyTraitRef<'tcx>>, ErrorReported>\n {\n     match tcx.lang_items.from_builtin_kind(builtin_bound) {\n         Ok(def_id) => {\n-            Ok(Rc::new(ty::TraitRef {\n+            Ok(Rc::new(ty::Binder(ty::TraitRef {\n                 def_id: def_id,\n                 substs: Substs::empty().with_self_ty(param_ty)\n-            }))\n+            })))\n         }\n         Err(e) => {\n             tcx.sess.err(e.as_slice());\n@@ -294,7 +294,7 @@ pub fn predicate_for_builtin_bound<'tcx>(\n     param_ty: Ty<'tcx>)\n     -> Result<PredicateObligation<'tcx>, ErrorReported>\n {\n-    let trait_ref = try!(trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty));\n+    let trait_ref = try!(poly_trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty));\n     Ok(Obligation {\n         cause: cause,\n         recursion_depth: recursion_depth,\n@@ -306,14 +306,14 @@ pub fn predicate_for_builtin_bound<'tcx>(\n /// of caller obligations), search through the trait and supertraits to find one where `test(d)` is\n /// true, where `d` is the def-id of the trait/supertrait. If any is found, return `Some(p)` where\n /// `p` is the path to that trait/supertrait. Else `None`.\n-pub fn search_trait_and_supertraits_from_bound<'tcx, F>(tcx: &ty::ctxt<'tcx>,\n-                                                        caller_bound: Rc<ty::TraitRef<'tcx>>,\n-                                                        mut test: F)\n-                                                        -> Option<VtableParamData<'tcx>> where\n-    F: FnMut(ast::DefId) -> bool,\n+pub fn search_trait_and_supertraits_from_bound<'tcx,F>(tcx: &ty::ctxt<'tcx>,\n+                                                       caller_bound: Rc<ty::PolyTraitRef<'tcx>>,\n+                                                       mut test: F)\n+                                                       -> Option<VtableParamData<'tcx>>\n+    where F: FnMut(ast::DefId) -> bool,\n {\n     for bound in transitive_bounds(tcx, &[caller_bound]) {\n-        if test(bound.def_id) {\n+        if test(bound.def_id()) {\n             let vtable_param = VtableParamData { bound: bound };\n             return Some(vtable_param);\n         }"}, {"sha": "6839e8bcc45db248efa01ca30a64e1c8eb0e4f0c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 302, "deletions": 165, "changes": 467, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -60,7 +60,7 @@ use middle::subst::{mod, Subst, Substs, VecPerParamSpace};\n use middle::traits::ObligationCause;\n use middle::traits;\n use middle::ty;\n-use middle::ty_fold::{mod, TypeFoldable, TypeFolder, HigherRankedFoldable};\n+use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::{trait_store_to_string, ty_to_string};\n use util::ppaux::{Repr, UserString};\n@@ -478,7 +478,9 @@ pub enum MethodOrigin<'tcx> {\n #[deriving(Clone, Show)]\n pub struct MethodParam<'tcx> {\n     // the precise trait reference that occurs as a bound -- this may\n-    // be a supertrait of what the user actually typed.\n+    // be a supertrait of what the user actually typed. Note that it\n+    // never contains bound regions; those regions should have been\n+    // instantiated with fresh variables at this point.\n     pub trait_ref: Rc<ty::TraitRef<'tcx>>,\n \n     // index of uint in the list of methods for the trait\n@@ -609,7 +611,7 @@ pub enum vtable_origin<'tcx> {\n \n // For every explicit cast into an object type, maps from the cast\n // expr to the associated trait ref.\n-pub type ObjectCastMap<'tcx> = RefCell<NodeMap<Rc<ty::TraitRef<'tcx>>>>;\n+pub type ObjectCastMap<'tcx> = RefCell<NodeMap<Rc<ty::PolyTraitRef<'tcx>>>>;\n \n /// A restriction that certain types must be the same size. The use of\n /// `transmute` gives rise to these restrictions.\n@@ -908,7 +910,7 @@ pub fn type_escapes_depth(ty: Ty, depth: uint) -> bool {\n pub struct BareFnTy<'tcx> {\n     pub unsafety: ast::Unsafety,\n     pub abi: abi::Abi,\n-    pub sig: FnSig<'tcx>,\n+    pub sig: PolyFnSig<'tcx>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n@@ -917,7 +919,7 @@ pub struct ClosureTy<'tcx> {\n     pub onceness: ast::Onceness,\n     pub store: TraitStore,\n     pub bounds: ExistentialBounds,\n-    pub sig: FnSig<'tcx>,\n+    pub sig: PolyFnSig<'tcx>,\n     pub abi: abi::Abi,\n }\n \n@@ -944,17 +946,15 @@ impl<'tcx> Copy for FnOutput<'tcx> {}\n /// - `inputs` is the list of arguments and their modes.\n /// - `output` is the return type.\n /// - `variadic` indicates whether this is a varidic function. (only true for foreign fns)\n-///\n-/// Note that a `FnSig` introduces a level of region binding, to\n-/// account for late-bound parameters that appear in the types of the\n-/// fn's arguments or the fn's return type.\n #[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct FnSig<'tcx> {\n     pub inputs: Vec<Ty<'tcx>>,\n     pub output: FnOutput<'tcx>,\n     pub variadic: bool\n }\n \n+pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n+\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct ParamTy {\n     pub space: subst::ParamSpace,\n@@ -1308,10 +1308,25 @@ pub enum sty<'tcx> {\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct TyTrait<'tcx> {\n     // Principal trait reference.\n-    pub principal: TraitRef<'tcx>, // would use Rc<TraitRef>, but it runs afoul of some static rules\n+    pub principal: PolyTraitRef<'tcx>,\n     pub bounds: ExistentialBounds\n }\n \n+impl<'tcx> TyTrait<'tcx> {\n+    /// Object types don't have a self-type specified. Therefore, when\n+    /// we convert the principal trait-ref into a normal trait-ref,\n+    /// you must give *some* self-type. A common choice is `mk_err()`\n+    /// or some skolemized type.\n+    pub fn principal_trait_ref_with_self_ty(&self, self_ty: Ty<'tcx>)\n+                                            -> Rc<ty::PolyTraitRef<'tcx>>\n+    {\n+        Rc::new(ty::Binder(ty::TraitRef {\n+            def_id: self.principal.def_id(),\n+            substs: self.principal.substs().with_self_ty(self_ty),\n+        }))\n+    }\n+}\n+\n /// A complete reference to a trait. These take numerous guises in syntax,\n /// but perhaps the most recognizable form is in a where clause:\n ///\n@@ -1333,21 +1348,36 @@ pub struct TraitRef<'tcx> {\n     pub substs: Substs<'tcx>,\n }\n \n-/// Binder serves as a synthetic binder for lifetimes. It is used when\n-/// we wish to replace the escaping higher-ranked lifetimes in a type\n-/// or something else that is not itself a binder (this is because the\n-/// `replace_late_bound_regions` function replaces all lifetimes bound\n-/// by the binder supplied to it; but a type is not a binder, so you\n-/// must introduce an artificial one).\n-#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n-pub struct Binder<T> {\n-    pub value: T\n-}\n+pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n+\n+impl<'tcx> PolyTraitRef<'tcx> {\n+    pub fn self_ty(&self) -> Ty<'tcx> {\n+        self.0.self_ty()\n+    }\n+\n+    pub fn def_id(&self) -> ast::DefId {\n+        self.0.def_id\n+    }\n+\n+    pub fn substs(&self) -> &Substs<'tcx> {\n+        &self.0.substs\n+    }\n \n-pub fn bind<T>(value: T) -> Binder<T> {\n-    Binder { value: value }\n+    pub fn input_types(&self) -> &[Ty<'tcx>] {\n+        self.0.input_types()\n+    }\n }\n \n+/// Binder is a binder for higher-ranked lifetimes. It is part of the\n+/// compiler's representation for things like `for<'a> Fn(&'a int)`\n+/// (which would be represented by the type `PolyTraitRef ==\n+/// Binder<TraitRef>`). Note that when we skolemize, instantiate,\n+/// erase, or otherwise \"discharge\" these bound reons, we change the\n+/// type from `Binder<T>` to just `T` (see\n+/// e.g. `liberate_late_bound_regions`).\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub struct Binder<T>(pub T);\n+\n #[deriving(Clone, PartialEq)]\n pub enum IntVarValue {\n     IntType(ast::IntTy),\n@@ -1416,7 +1446,7 @@ impl<'tcx> Copy for type_err<'tcx> {}\n pub struct ParamBounds<'tcx> {\n     pub region_bounds: Vec<ty::Region>,\n     pub builtin_bounds: BuiltinBounds,\n-    pub trait_bounds: Vec<Rc<TraitRef<'tcx>>>\n+    pub trait_bounds: Vec<Rc<PolyTraitRef<'tcx>>>\n }\n \n /// Bounds suitable for an existentially quantified type parameter\n@@ -1505,12 +1535,16 @@ pub enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n     FloatVar(FloatVid),\n-    SkolemizedTy(uint),\n+\n+    /// A `FreshTy` is one that is generated as a replacement for an\n+    /// unbound type variable. This is convenient for caching etc. See\n+    /// `middle::infer::freshen` for more details.\n+    FreshTy(uint),\n \n     // FIXME -- once integral fallback is impl'd, we should remove\n     // this type. It's only needed to prevent spurious errors for\n     // integers whose type winds up never being constrained.\n-    SkolemizedIntTy(uint),\n+    FreshIntTy(uint),\n }\n \n impl Copy for InferTy {}\n@@ -1577,8 +1611,8 @@ impl fmt::Show for InferTy {\n             TyVar(ref v) => v.fmt(f),\n             IntVar(ref v) => v.fmt(f),\n             FloatVar(ref v) => v.fmt(f),\n-            SkolemizedTy(v) => write!(f, \"SkolemizedTy({})\", v),\n-            SkolemizedIntTy(v) => write!(f, \"SkolemizedIntTy({})\", v),\n+            FreshTy(v) => write!(f, \"FreshTy({})\", v),\n+            FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n         }\n     }\n }\n@@ -1657,30 +1691,67 @@ pub enum Predicate<'tcx> {\n     /// Corresponds to `where Foo : Bar<A,B,C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the parameters in the `TypeSpace`.\n-    Trait(Rc<TraitRef<'tcx>>),\n+    Trait(Rc<PolyTraitRef<'tcx>>),\n \n     /// where `T1 == T2`.\n-    Equate(/* T1 */ Ty<'tcx>, /* T2 */ Ty<'tcx>),\n+    Equate(PolyEquatePredicate<'tcx>),\n \n     /// where 'a : 'b\n-    RegionOutlives(/* 'a */ Region, /* 'b */ Region),\n+    RegionOutlives(PolyRegionOutlivesPredicate),\n \n     /// where T : 'a\n-    TypeOutlives(Ty<'tcx>, Region),\n+    TypeOutlives(PolyTypeOutlivesPredicate<'tcx>),\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub struct EquatePredicate<'tcx>(pub Ty<'tcx>, pub Ty<'tcx>); // `0 == 1`\n+pub type PolyEquatePredicate<'tcx> = ty::Binder<EquatePredicate<'tcx>>;\n+\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub struct OutlivesPredicate<A,B>(pub A, pub B); // `A : B`\n+pub type PolyOutlivesPredicate<A,B> = ty::Binder<OutlivesPredicate<A,B>>;\n+pub type PolyRegionOutlivesPredicate = PolyOutlivesPredicate<ty::Region, ty::Region>;\n+pub type PolyTypeOutlivesPredicate<'tcx> = PolyOutlivesPredicate<Ty<'tcx>, ty::Region>;\n+\n+pub trait AsPredicate<'tcx> {\n+    fn as_predicate(&self) -> Predicate<'tcx>;\n+}\n+\n+impl<'tcx> AsPredicate<'tcx> for Rc<PolyTraitRef<'tcx>> {\n+    fn as_predicate(&self) -> Predicate<'tcx> {\n+        Predicate::Trait(self.clone())\n+    }\n+}\n+\n+impl<'tcx> AsPredicate<'tcx> for PolyEquatePredicate<'tcx> {\n+    fn as_predicate(&self) -> Predicate<'tcx> {\n+        Predicate::Equate(self.clone())\n+    }\n+}\n+\n+impl<'tcx> AsPredicate<'tcx> for PolyRegionOutlivesPredicate {\n+    fn as_predicate(&self) -> Predicate<'tcx> {\n+        Predicate::RegionOutlives(self.clone())\n+    }\n+}\n+\n+impl<'tcx> AsPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n+    fn as_predicate(&self) -> Predicate<'tcx> {\n+        Predicate::TypeOutlives(self.clone())\n+    }\n }\n \n impl<'tcx> Predicate<'tcx> {\n     pub fn has_escaping_regions(&self) -> bool {\n         match *self {\n             Predicate::Trait(ref trait_ref) => trait_ref.has_escaping_regions(),\n-            Predicate::Equate(a, b) => (ty::type_has_escaping_regions(a) ||\n-                                        ty::type_has_escaping_regions(b)),\n-            Predicate::RegionOutlives(a, b) => a.escapes_depth(0) || b.escapes_depth(0),\n-            Predicate::TypeOutlives(a, b) => ty::type_has_escaping_regions(a) || b.escapes_depth(0),\n+            Predicate::Equate(ref p) => p.has_escaping_regions(),\n+            Predicate::RegionOutlives(ref p) => p.has_escaping_regions(),\n+            Predicate::TypeOutlives(ref p) => p.has_escaping_regions(),\n         }\n     }\n \n-    pub fn to_trait(&self) -> Option<Rc<TraitRef<'tcx>>> {\n+    pub fn to_trait(&self) -> Option<Rc<PolyTraitRef<'tcx>>> {\n         match *self {\n             Predicate::Trait(ref t) => {\n                 Some(t.clone())\n@@ -1748,14 +1819,6 @@ impl<'tcx> TraitRef<'tcx> {\n         // associated types.\n         self.substs.types.as_slice()\n     }\n-\n-    pub fn has_escaping_regions(&self) -> bool {\n-        self.substs.has_regions_escaping_depth(1)\n-    }\n-\n-    pub fn has_bound_regions(&self) -> bool {\n-        self.substs.has_regions_escaping_depth(0)\n-    }\n }\n \n /// When type checking, we use the `ParameterEnvironment` to track\n@@ -2160,7 +2223,7 @@ impl FlagComputation {\n \n             &ty_trait(box TyTrait { ref principal, ref bounds }) => {\n                 let mut computation = FlagComputation::new();\n-                computation.add_substs(&principal.substs);\n+                computation.add_substs(principal.substs());\n                 self.add_bound_computation(&computation);\n \n                 self.add_bounds(bounds);\n@@ -2208,12 +2271,12 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_fn_sig(&mut self, fn_sig: &FnSig) {\n+    fn add_fn_sig(&mut self, fn_sig: &PolyFnSig) {\n         let mut computation = FlagComputation::new();\n \n-        computation.add_tys(fn_sig.inputs[]);\n+        computation.add_tys(fn_sig.0.inputs[]);\n \n-        if let ty::FnConverging(output) = fn_sig.output {\n+        if let ty::FnConverging(output) = fn_sig.0.output {\n             computation.add_ty(output);\n         }\n \n@@ -2356,17 +2419,17 @@ pub fn mk_ctor_fn<'tcx>(cx: &ctxt<'tcx>,\n                BareFnTy {\n                    unsafety: ast::Unsafety::Normal,\n                    abi: abi::Rust,\n-                   sig: FnSig {\n+                   sig: ty::Binder(FnSig {\n                     inputs: input_args,\n                     output: ty::FnConverging(output),\n                     variadic: false\n-                   }\n+                   })\n                 })\n }\n \n \n pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n-                      principal: ty::TraitRef<'tcx>,\n+                      principal: ty::PolyTraitRef<'tcx>,\n                       bounds: ExistentialBounds)\n                       -> Ty<'tcx> {\n     // take a copy of substs so that we own the vectors inside\n@@ -2439,7 +2502,7 @@ pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n             maybe_walk_ty(tm.ty, f);\n         }\n         ty_trait(box TyTrait { ref principal, .. }) => {\n-            for subty in principal.substs.types.iter() {\n+            for subty in principal.substs().types.iter() {\n                 maybe_walk_ty(*subty, |x| f(x));\n             }\n         }\n@@ -2452,14 +2515,14 @@ pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n         }\n         ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty(*tt, |x| f(x)); } }\n         ty_bare_fn(ref ft) => {\n-            for a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n-            if let ty::FnConverging(output) = ft.sig.output {\n+            for a in ft.sig.0.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n+            if let ty::FnConverging(output) = ft.sig.0.output {\n                 maybe_walk_ty(output, f);\n             }\n         }\n         ty_closure(ref ft) => {\n-            for a in ft.sig.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n-            if let ty::FnConverging(output) = ft.sig.output {\n+            for a in ft.sig.0.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n+            if let ty::FnConverging(output) = ft.sig.0.output {\n                 maybe_walk_ty(output, f);\n             }\n         }\n@@ -2961,7 +3024,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             // Scalar and unique types are sendable, and durable\n-            ty_infer(ty::SkolemizedIntTy(_)) |\n+            ty_infer(ty::FreshIntTy(_)) |\n             ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n             ty_bare_fn(_) | ty::ty_char => {\n                 TC::None\n@@ -3182,7 +3245,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n \n     fn kind_bounds_to_contents<'tcx>(cx: &ctxt<'tcx>,\n                                      bounds: BuiltinBounds,\n-                                     traits: &[Rc<TraitRef<'tcx>>])\n+                                     traits: &[Rc<PolyTraitRef<'tcx>>])\n                                      -> TypeContents {\n         let _i = indenter();\n         let mut tc = TC::All;\n@@ -3198,7 +3261,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n         // those inherited from traits with builtin-kind-supertraits.\n         fn each_inherited_builtin_bound<'tcx, F>(cx: &ctxt<'tcx>,\n                                                  bounds: BuiltinBounds,\n-                                                 traits: &[Rc<TraitRef<'tcx>>],\n+                                                 traits: &[Rc<PolyTraitRef<'tcx>>],\n                                                  mut f: F) where\n             F: FnMut(BuiltinBound),\n         {\n@@ -3207,7 +3270,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             each_bound_trait_and_supertraits(cx, traits, |trait_ref| {\n-                let trait_def = lookup_trait_def(cx, trait_ref.def_id);\n+                let trait_def = lookup_trait_def(cx, trait_ref.def_id());\n                 for bound in trait_def.bounds.builtin_bounds.iter() {\n                     f(bound);\n                 }\n@@ -3567,10 +3630,10 @@ pub fn type_is_integral(ty: Ty) -> bool {\n     }\n }\n \n-pub fn type_is_skolemized(ty: Ty) -> bool {\n+pub fn type_is_fresh(ty: Ty) -> bool {\n     match ty.sty {\n-      ty_infer(SkolemizedTy(_)) => true,\n-      ty_infer(SkolemizedIntTy(_)) => true,\n+      ty_infer(FreshTy(_)) => true,\n+      ty_infer(FreshIntTy(_)) => true,\n       _ => false\n     }\n }\n@@ -3828,15 +3891,15 @@ pub fn node_id_item_substs<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> ItemSubsts\n \n pub fn fn_is_variadic(fty: Ty) -> bool {\n     match fty.sty {\n-        ty_bare_fn(ref f) => f.sig.variadic,\n-        ty_closure(ref f) => f.sig.variadic,\n+        ty_bare_fn(ref f) => f.sig.0.variadic,\n+        ty_closure(ref f) => f.sig.0.variadic,\n         ref s => {\n             panic!(\"fn_is_variadic() called on non-fn type: {}\", s)\n         }\n     }\n }\n \n-pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx FnSig<'tcx> {\n+pub fn ty_fn_sig<'tcx>(fty: Ty<'tcx>) -> &'tcx PolyFnSig<'tcx> {\n     match fty.sty {\n         ty_bare_fn(ref f) => &f.sig,\n         ty_closure(ref f) => &f.sig,\n@@ -3857,7 +3920,7 @@ pub fn ty_fn_abi(fty: Ty) -> abi::Abi {\n \n // Type accessors for substructures of types\n pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> &'tcx [Ty<'tcx>] {\n-    ty_fn_sig(fty).inputs.as_slice()\n+    ty_fn_sig(fty).0.inputs.as_slice()\n }\n \n pub fn ty_closure_store(fty: Ty) -> TraitStore {\n@@ -3876,8 +3939,8 @@ pub fn ty_closure_store(fty: Ty) -> TraitStore {\n \n pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> FnOutput<'tcx> {\n     match fty.sty {\n-        ty_bare_fn(ref f) => f.sig.output,\n-        ty_closure(ref f) => f.sig.output,\n+        ty_bare_fn(ref f) => f.sig.0.output,\n+        ty_closure(ref f) => f.sig.0.output,\n         ref s => {\n             panic!(\"ty_fn_ret() called on non-fn type: {}\", s)\n         }\n@@ -4393,7 +4456,7 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n         ty_bare_fn(_) => \"extern fn\".to_string(),\n         ty_closure(_) => \"fn\".to_string(),\n         ty_trait(ref inner) => {\n-            format!(\"trait {}\", item_path_str(cx, inner.principal.def_id))\n+            format!(\"trait {}\", item_path_str(cx, inner.principal.def_id()))\n         }\n         ty_struct(id, _) => {\n             format!(\"struct {}\", item_path_str(cx, id))\n@@ -4403,8 +4466,8 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n         ty_infer(TyVar(_)) => \"inferred type\".to_string(),\n         ty_infer(IntVar(_)) => \"integral variable\".to_string(),\n         ty_infer(FloatVar(_)) => \"floating-point variable\".to_string(),\n-        ty_infer(SkolemizedTy(_)) => \"skolemized type\".to_string(),\n-        ty_infer(SkolemizedIntTy(_)) => \"skolemized integral type\".to_string(),\n+        ty_infer(FreshTy(_)) => \"skolemized type\".to_string(),\n+        ty_infer(FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n         ty_param(ref p) => {\n             if p.space == subst::SelfSpace {\n                 \"Self\".to_string()\n@@ -4770,7 +4833,8 @@ pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                         ast::ItemImpl(_, _, ref opt_trait, _, _) => {\n                             match opt_trait {\n                                 &Some(ref t) => {\n-                                    Some(ty::node_id_to_trait_ref(cx, t.ref_id))\n+                                    let trait_ref = ty::node_id_to_trait_ref(cx, t.ref_id);\n+                                    Some(trait_ref)\n                                 }\n                                 &None => None\n                             }\n@@ -4813,7 +4877,7 @@ pub fn try_add_builtin_trait(\n pub fn ty_to_def_id(ty: Ty) -> Option<ast::DefId> {\n     match ty.sty {\n         ty_trait(ref tt) =>\n-            Some(tt.principal.def_id),\n+            Some(tt.principal.def_id()),\n         ty_struct(id, _) |\n         ty_enum(id, _) |\n         ty_unboxed_closure(id, _, _) =>\n@@ -5073,10 +5137,10 @@ pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n /// Given a reference to a trait, returns the \"superbounds\" declared\n /// on the trait, with appropriate substitutions applied.\n pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n-                                      trait_ref: &TraitRef<'tcx>)\n+                                      trait_ref: &PolyTraitRef<'tcx>)\n                                       -> Vec<ty::Predicate<'tcx>>\n {\n-    let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n+    let trait_def = lookup_trait_def(tcx, trait_ref.def_id());\n \n     debug!(\"bounds_for_trait_ref(trait_def={}, trait_ref={})\",\n            trait_def.repr(tcx), trait_ref.repr(tcx));\n@@ -5149,8 +5213,9 @@ pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n         trait_def.bounds.trait_bounds\n         .iter()\n         .map(|bound_trait_ref| {\n-            ty::TraitRef::new(bound_trait_ref.def_id,\n-                              bound_trait_ref.substs.subst(tcx, &trait_ref.substs))\n+            ty::Binder(\n+                ty::TraitRef::new(bound_trait_ref.def_id(),\n+                                  bound_trait_ref.substs().subst(tcx, trait_ref.substs())))\n         })\n         .map(|bound_trait_ref| Rc::new(bound_trait_ref))\n         .collect();\n@@ -5161,9 +5226,9 @@ pub fn predicates_for_trait_ref<'tcx>(tcx: &ctxt<'tcx>,\n     // The region bounds and builtin bounds do not currently introduce\n     // binders so we can just substitute in a straightforward way here.\n     let region_bounds =\n-        trait_def.bounds.region_bounds.subst(tcx, &trait_ref.substs);\n+        trait_def.bounds.region_bounds.subst(tcx, trait_ref.substs());\n     let builtin_bounds =\n-        trait_def.bounds.builtin_bounds.subst(tcx, &trait_ref.substs);\n+        trait_def.bounds.builtin_bounds.subst(tcx, trait_ref.substs());\n \n     let bounds = ty::ParamBounds {\n         trait_bounds: trait_bounds,\n@@ -5183,18 +5248,21 @@ pub fn predicates<'tcx>(\n     let mut vec = Vec::new();\n \n     for builtin_bound in bounds.builtin_bounds.iter() {\n-        match traits::trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n-            Ok(trait_ref) => { vec.push(Predicate::Trait(trait_ref)); }\n+        match traits::poly_trait_ref_for_builtin_bound(tcx, builtin_bound, param_ty) {\n+            Ok(trait_ref) => { vec.push(trait_ref.as_predicate()); }\n             Err(ErrorReported) => { }\n         }\n     }\n \n     for &region_bound in bounds.region_bounds.iter() {\n-        vec.push(Predicate::TypeOutlives(param_ty, region_bound));\n+        // account for the binder being introduced below; no need to shift `param_ty`\n+        // because, at present at least, it can only refer to early-bound regions\n+        let region_bound = ty_fold::shift_region(region_bound, 1);\n+        vec.push(ty::Binder(ty::OutlivesPredicate(param_ty, region_bound)).as_predicate());\n     }\n \n     for bound_trait_ref in bounds.trait_bounds.iter() {\n-        vec.push(Predicate::Trait((*bound_trait_ref).clone()));\n+        vec.push(bound_trait_ref.as_predicate());\n     }\n \n     vec\n@@ -5483,18 +5551,6 @@ pub fn normalize_ty<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n             subst::Substs { regions: subst::ErasedRegions,\n                             types: substs.types.fold_with(self) }\n         }\n-\n-        fn fold_fn_sig(&mut self,\n-                       sig: &ty::FnSig<'tcx>)\n-                       -> ty::FnSig<'tcx> {\n-            // The binder-id is only relevant to bound regions, which\n-            // are erased at trans time.\n-            ty::FnSig {\n-                inputs: sig.inputs.fold_with(self),\n-                output: sig.output.fold_with(self),\n-                variadic: sig.variadic,\n-            }\n-        }\n     }\n }\n \n@@ -5545,10 +5601,10 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n // relation on the supertraits from each bounded trait's constraint\n // list.\n pub fn each_bound_trait_and_supertraits<'tcx, F>(tcx: &ctxt<'tcx>,\n-                                                 bounds: &[Rc<TraitRef<'tcx>>],\n+                                                 bounds: &[Rc<PolyTraitRef<'tcx>>],\n                                                  mut f: F)\n                                                  -> bool where\n-    F: FnMut(Rc<TraitRef<'tcx>>) -> bool,\n+    F: FnMut(Rc<PolyTraitRef<'tcx>>) -> bool,\n {\n     for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n         if !f(bound_trait_ref) {\n@@ -5559,18 +5615,18 @@ pub fn each_bound_trait_and_supertraits<'tcx, F>(tcx: &ctxt<'tcx>,\n }\n \n pub fn object_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n-                                  opt_principal: Option<&TraitRef<'tcx>>, // None for boxed closures\n+                                  opt_principal: Option<&PolyTraitRef<'tcx>>, // None for closures\n                                   others: BuiltinBounds)\n                                   -> Vec<ty::Region>\n {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n     // a skolemized type.\n-    let open_ty = ty::mk_infer(tcx, SkolemizedTy(0));\n+    let open_ty = ty::mk_infer(tcx, FreshTy(0));\n \n     let opt_trait_ref = opt_principal.map_or(Vec::new(), |principal| {\n-        let substs = principal.substs.with_self_ty(open_ty);\n-        vec!(Rc::new(ty::TraitRef::new(principal.def_id, substs)))\n+        let substs = principal.substs().with_self_ty(open_ty);\n+        vec!(Rc::new(ty::Binder(ty::TraitRef::new(principal.def_id(), substs))))\n     });\n \n     let param_bounds = ty::ParamBounds {\n@@ -5583,19 +5639,27 @@ pub fn object_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n     ty::required_region_bounds(tcx, open_ty, predicates)\n }\n \n-/// Given a type which must meet the builtin bounds and trait bounds, returns a set of lifetimes\n-/// which the type must outlive.\n+/// Given a set of predicates that apply to an object type, returns\n+/// the region bounds that the (erased) `Self` type must\n+/// outlive. Precisely *because* the `Self` type is erased, the\n+/// parameter `erased_self_ty` must be supplied to indicate what type\n+/// has been used to represent `Self` in the predicates\n+/// themselves. This should really be a unique type; `FreshTy(0)` is a\n+/// popular choice (see `object_region_bounds` above).\n ///\n-/// Requires that trait definitions have been processed.\n+/// Requires that trait definitions have been processed so that we can\n+/// elaborate predicates and walk supertraits.\n pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n-                                    param_ty: Ty<'tcx>,\n+                                    erased_self_ty: Ty<'tcx>,\n                                     predicates: Vec<ty::Predicate<'tcx>>)\n                                     -> Vec<ty::Region>\n {\n-    debug!(\"required_region_bounds(param_ty={}, predicates={})\",\n-           param_ty.repr(tcx),\n+    debug!(\"required_region_bounds(erased_self_ty={}, predicates={})\",\n+           erased_self_ty.repr(tcx),\n            predicates.repr(tcx));\n \n+    assert!(!erased_self_ty.has_escaping_regions());\n+\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|predicate| {\n             match predicate {\n@@ -5604,9 +5668,22 @@ pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n                 ty::Predicate::RegionOutlives(..) => {\n                     None\n                 }\n-                ty::Predicate::TypeOutlives(t, r) => {\n-                    if t == param_ty {\n-                        Some(r)\n+                ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(t, r))) => {\n+                    // Search for a bound of the form `erased_self_ty\n+                    // : 'a`, but be wary of something like `for<'a>\n+                    // erased_self_ty : 'a` (we interpret a\n+                    // higher-ranked bound like that as 'static,\n+                    // though at present the code in `fulfill.rs`\n+                    // considers such bounds to be unsatisfiable, so\n+                    // it's kind of a moot point since you could never\n+                    // construct such an object, but this seems\n+                    // correct even if that code changes).\n+                    if t == erased_self_ty && !r.has_escaping_regions() {\n+                        if r.has_escaping_regions() {\n+                            Some(ty::ReStatic)\n+                        } else {\n+                            Some(r)\n+                        }\n                     } else {\n                         None\n                     }\n@@ -5824,12 +5901,12 @@ pub fn trait_item_of_item(tcx: &ctxt, def_id: ast::DefId)\n \n /// Creates a hash of the type `Ty` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n-pub fn hash_crate_independent(tcx: &ctxt, ty: Ty, svh: &Svh) -> u64 {\n+pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -> u64 {\n     let mut state = sip::SipState::new();\n     helper(tcx, ty, svh, &mut state);\n     return state.result();\n \n-    fn helper(tcx: &ctxt, ty: Ty, svh: &Svh, state: &mut sip::SipState) {\n+    fn helper<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh, state: &mut sip::SipState) {\n         macro_rules! byte( ($b:expr) => { ($b as u8).hash(state) } );\n         macro_rules! hash( ($e:expr) => { $e.hash(state) } );\n \n@@ -5862,7 +5939,7 @@ pub fn hash_crate_independent(tcx: &ctxt, ty: Ty, svh: &Svh) -> u64 {\n         let mt = |state: &mut sip::SipState, mt: mt| {\n             mt.mutbl.hash(state);\n         };\n-        let fn_sig = |state: &mut sip::SipState, sig: &FnSig| {\n+        let fn_sig = |state: &mut sip::SipState, sig: &Binder<FnSig<'tcx>>| {\n             let sig = anonymize_late_bound_regions(tcx, sig);\n             for a in sig.inputs.iter() { helper(tcx, *a, svh, state); }\n             if let ty::FnConverging(output) = sig.output {\n@@ -5938,7 +6015,7 @@ pub fn hash_crate_independent(tcx: &ctxt, ty: Ty, svh: &Svh) -> u64 {\n                 }\n                 ty_trait(box TyTrait { ref principal, bounds }) => {\n                     byte!(17);\n-                    did(state, principal.def_id);\n+                    did(state, principal.def_id());\n                     hash!(bounds);\n \n                     let principal = anonymize_late_bound_regions(tcx, principal);\n@@ -6033,7 +6110,7 @@ pub fn construct_parameter_environment<'tcx>(\n     //\n \n     let bounds = generics.to_bounds(tcx, &free_substs);\n-    let bounds = liberate_late_bound_regions(tcx, free_id_scope, &bind(bounds)).value;\n+    let bounds = liberate_late_bound_regions(tcx, free_id_scope, &ty::Binder(bounds));\n \n     //\n     // Compute region bounds. For now, these relations are stored in a\n@@ -6088,16 +6165,20 @@ pub fn construct_parameter_environment<'tcx>(\n                 Predicate::Trait(..) | Predicate::Equate(..) | Predicate::TypeOutlives(..) => {\n                     // No region bounds here\n                 }\n-                Predicate::RegionOutlives(ty::ReFree(fr_a), ty::ReFree(fr_b)) => {\n-                    // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n-                    tcx.region_maps.relate_free_regions(fr_b, fr_a);\n-                }\n-                Predicate::RegionOutlives(r_a, r_b) => {\n-                    // All named regions are instantiated with free regions.\n-                    tcx.sess.bug(\n-                        format!(\"record_region_bounds: non free region: {} / {}\",\n-                                r_a.repr(tcx),\n-                                r_b.repr(tcx)).as_slice());\n+                Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n+                    match (r_a, r_b) {\n+                        (ty::ReFree(fr_a), ty::ReFree(fr_b)) => {\n+                            // Record that `'a:'b`. Or, put another way, `'b <= 'a`.\n+                            tcx.region_maps.relate_free_regions(fr_b, fr_a);\n+                        }\n+                        _ => {\n+                            // All named regions are instantiated with free regions.\n+                            tcx.sess.bug(\n+                                format!(\"record_region_bounds: non free region: {} / {}\",\n+                                        r_a.repr(tcx),\n+                                        r_b.repr(tcx)).as_slice());\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -6200,7 +6281,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n                 accumulator.push(region)\n             }\n             ty_trait(ref t) => {\n-                accumulator.push_all(t.principal.substs.regions().as_slice());\n+                accumulator.push_all(t.principal.substs().regions().as_slice());\n             }\n             ty_enum(_, ref substs) |\n             ty_struct(_, ref substs) => {\n@@ -6289,25 +6370,35 @@ impl<'tcx> AutoDerefRef<'tcx> {\n \n /// Replace any late-bound regions bound in `value` with free variants attached to scope-id\n /// `scope_id`.\n-pub fn liberate_late_bound_regions<'tcx, HR>(\n+pub fn liberate_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n     scope: region::CodeExtent,\n-    value: &HR)\n-    -> HR\n-    where HR : HigherRankedFoldable<'tcx>\n+    value: &Binder<T>)\n+    -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n     replace_late_bound_regions(\n         tcx, value,\n         |br, _| ty::ReFree(ty::FreeRegion{scope: scope, bound_region: br})).0\n }\n \n+pub fn count_late_bound_regions<'tcx, T>(\n+    tcx: &ty::ctxt<'tcx>,\n+    value: &Binder<T>)\n+    -> uint\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+{\n+    let (_, skol_map) = replace_late_bound_regions(tcx, value, |_, _| ty::ReStatic);\n+    skol_map.len()\n+}\n+\n /// Replace any late-bound regions bound in `value` with `'static`. Useful in trans but also\n /// method lookup and a few other places where precise region relationships are not required.\n-pub fn erase_late_bound_regions<'tcx, HR>(\n+pub fn erase_late_bound_regions<'tcx, T>(\n     tcx: &ty::ctxt<'tcx>,\n-    value: &HR)\n-    -> HR\n-    where HR : HigherRankedFoldable<'tcx>\n+    value: &Binder<T>)\n+    -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n     replace_late_bound_regions(tcx, value, |_, _| ty::ReStatic).0\n }\n@@ -6320,8 +6411,12 @@ pub fn erase_late_bound_regions<'tcx, HR>(\n /// `FnSig`s or `TraitRef`s which are equivalent up to region naming will become\n /// structurally identical.  For example, `for<'a, 'b> fn(&'a int, &'b int)` and\n /// `for<'a, 'b> fn(&'b int, &'a int)` will become identical after anonymization.\n-pub fn anonymize_late_bound_regions<'tcx, HR>(tcx: &ctxt<'tcx>, sig: &HR) -> HR\n-                                              where HR: HigherRankedFoldable<'tcx> {\n+pub fn anonymize_late_bound_regions<'tcx, T>(\n+    tcx: &ctxt<'tcx>,\n+    sig: &Binder<T>)\n+    -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>,\n+{\n     let mut counter = 0;\n     replace_late_bound_regions(tcx, sig, |_, db| {\n         counter += 1;\n@@ -6330,39 +6425,35 @@ pub fn anonymize_late_bound_regions<'tcx, HR>(tcx: &ctxt<'tcx>, sig: &HR) -> HR\n }\n \n /// Replaces the late-bound-regions in `value` that are bound by `value`.\n-pub fn replace_late_bound_regions<'tcx, HR, F>(\n+pub fn replace_late_bound_regions<'tcx, T, F>(\n     tcx: &ty::ctxt<'tcx>,\n-    value: &HR,\n+    binder: &Binder<T>,\n     mut mapf: F)\n--> (HR, FnvHashMap<ty::BoundRegion, ty::Region>) where\n-    HR : HigherRankedFoldable<'tcx>,\n-    F: FnMut(BoundRegion, DebruijnIndex) -> ty::Region,\n+    -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>,\n+          F : FnMut(BoundRegion, DebruijnIndex) -> ty::Region,\n {\n-    debug!(\"replace_late_bound_regions({})\", value.repr(tcx));\n+    debug!(\"replace_late_bound_regions({})\", binder.repr(tcx));\n \n     let mut map = FnvHashMap::new();\n-    let value = {\n-        let mut f = ty_fold::RegionFolder::new(tcx, |region, current_depth| {\n-            debug!(\"region={}\", region.repr(tcx));\n-            match region {\n-                ty::ReLateBound(debruijn, br) if debruijn.depth == current_depth => {\n-                    * match map.entry(br) {\n-                        Vacant(entry) => entry.set(mapf(br, debruijn)),\n-                        Occupied(entry) => entry.into_mut(),\n-                    }\n-                }\n-                _ => {\n-                    region\n+\n+    // Note: fold the field `0`, not the binder, so that late-bound\n+    // regions bound by `binder` are considered free.\n+    let value = ty_fold::fold_regions(tcx, &binder.0, |region, current_depth| {\n+        debug!(\"region={}\", region.repr(tcx));\n+        match region {\n+            ty::ReLateBound(debruijn, br) if debruijn.depth == current_depth => {\n+                * match map.entry(br) {\n+                    Vacant(entry) => entry.set(mapf(br, debruijn)),\n+                    Occupied(entry) => entry.into_mut(),\n                 }\n             }\n-        });\n+            _ => {\n+                region\n+            }\n+        }\n+    });\n \n-        // Note: use `fold_contents` not `fold_with`. If we used\n-        // `fold_with`, it would consider the late-bound regions bound\n-        // by `value` to be bound, but we want to consider them as\n-        // `free`.\n-        value.fold_contents(&mut f)\n-    };\n     debug!(\"resulting map: {} value: {}\", map, value.repr(tcx));\n     (value, map)\n }\n@@ -6440,9 +6531,9 @@ impl<'tcx> Repr<'tcx> for ty::Predicate<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         match *self {\n             Predicate::Trait(ref a) => a.repr(tcx),\n-            Predicate::Equate(a, b) => format!(\"Equate({},{})\", a.repr(tcx), b.repr(tcx)),\n-            Predicate::RegionOutlives(a, b) => format!(\"Outlives({}:{})\", a.repr(tcx), b.repr(tcx)),\n-            Predicate::TypeOutlives(a, b) => format!(\"Outlives({}:{})\", a.repr(tcx), b.repr(tcx)),\n+            Predicate::Equate(ref pair) => format!(\"Equate({})\", pair.repr(tcx)),\n+            Predicate::RegionOutlives(ref pair) => format!(\"Outlives({})\", pair.repr(tcx)),\n+            Predicate::TypeOutlives(ref pair) => format!(\"Outlives({})\", pair.repr(tcx)),\n         }\n     }\n }\n@@ -6538,3 +6629,49 @@ pub fn can_type_implement_copy<'tcx>(tcx: &ctxt<'tcx>,\n \n     Ok(())\n }\n+\n+pub trait RegionEscape {\n+    fn has_escaping_regions(&self) -> bool {\n+        self.has_regions_escaping_depth(0)\n+    }\n+\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool;\n+}\n+\n+impl<'tcx> RegionEscape for Ty<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        ty::type_escapes_depth(*self, depth)\n+    }\n+}\n+\n+impl RegionEscape for Region {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.escapes_depth(depth)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for TraitRef<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.substs.types.iter().any(|t| t.has_regions_escaping_depth(depth)) &&\n+            self.substs.regions().iter().any(|t| t.has_regions_escaping_depth(depth))\n+    }\n+}\n+\n+impl<'tcx,T:RegionEscape> RegionEscape for Binder<T> {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.0.has_regions_escaping_depth(depth + 1)\n+    }\n+}\n+\n+impl<'tcx> RegionEscape for EquatePredicate<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n+impl<T:RegionEscape,U:RegionEscape> RegionEscape for OutlivesPredicate<T,U> {\n+    fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.0.has_regions_escaping_depth(depth) || self.1.has_regions_escaping_depth(depth)\n+    }\n+}\n+"}, {"sha": "71e42a9dbb3de8fe72e89685844a5733b85b793b", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 56, "deletions": 80, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -93,8 +93,8 @@ pub trait TypeFolder<'tcx> {\n     }\n \n     fn fold_fn_sig(&mut self,\n-                sig: &ty::FnSig<'tcx>)\n-                -> ty::FnSig<'tcx> {\n+                   sig: &ty::FnSig<'tcx>)\n+                   -> ty::FnSig<'tcx> {\n         super_fold_fn_sig(self, sig)\n     }\n \n@@ -183,7 +183,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Vec<T> {\n impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n         folder.enter_region_binder();\n-        let result = ty::bind(self.value.fold_with(folder));\n+        let result = ty::Binder(self.0.fold_with(folder));\n         folder.exit_region_binder();\n         result\n     }\n@@ -409,15 +409,12 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n         match *self {\n             ty::Predicate::Trait(ref a) =>\n                 ty::Predicate::Trait(a.fold_with(folder)),\n-            ty::Predicate::Equate(ref a, ref b) =>\n-                ty::Predicate::Equate(a.fold_with(folder),\n-                                        b.fold_with(folder)),\n-            ty::Predicate::RegionOutlives(ref a, ref b) =>\n-                ty::Predicate::RegionOutlives(a.fold_with(folder),\n-                                                b.fold_with(folder)),\n-            ty::Predicate::TypeOutlives(ref a, ref b) =>\n-                ty::Predicate::TypeOutlives(a.fold_with(folder),\n-                                              b.fold_with(folder)),\n+            ty::Predicate::Equate(ref binder) =>\n+                ty::Predicate::Equate(binder.fold_with(folder)),\n+            ty::Predicate::RegionOutlives(ref binder) =>\n+                ty::Predicate::RegionOutlives(binder.fold_with(folder)),\n+            ty::Predicate::TypeOutlives(ref binder) =>\n+                ty::Predicate::TypeOutlives(binder.fold_with(folder)),\n         }\n     }\n }\n@@ -501,6 +498,23 @@ impl<'tcx> TypeFoldable<'tcx> for traits::VtableParamData<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::EquatePredicate<'tcx> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::EquatePredicate<'tcx> {\n+        ty::EquatePredicate(self.0.fold_with(folder),\n+                            self.1.fold_with(folder))\n+    }\n+}\n+\n+impl<'tcx,T,U> TypeFoldable<'tcx> for ty::OutlivesPredicate<T,U>\n+    where T : TypeFoldable<'tcx>,\n+          U : TypeFoldable<'tcx>,\n+{\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::OutlivesPredicate<T,U> {\n+        ty::OutlivesPredicate(self.0.fold_with(folder),\n+                              self.1.fold_with(folder))\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // \"super\" routines: these are the default implementations for TypeFolder.\n //\n@@ -532,16 +546,6 @@ pub fn super_fold_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n pub fn super_fold_fn_sig<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                     sig: &ty::FnSig<'tcx>)\n                                                     -> ty::FnSig<'tcx>\n-{\n-    this.enter_region_binder();\n-    let result = super_fold_fn_sig_contents(this, sig);\n-    this.exit_region_binder();\n-    result\n-}\n-\n-pub fn super_fold_fn_sig_contents<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                             sig: &ty::FnSig<'tcx>)\n-                                                             -> ty::FnSig<'tcx>\n {\n     ty::FnSig { inputs: sig.inputs.fold_with(this),\n                 output: sig.output.fold_with(this),\n@@ -583,16 +587,6 @@ pub fn super_fold_closure_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n pub fn super_fold_trait_ref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                        t: &ty::TraitRef<'tcx>)\n                                                        -> ty::TraitRef<'tcx>\n-{\n-    this.enter_region_binder();\n-    let result = super_fold_trait_ref_contents(this, t);\n-    this.exit_region_binder();\n-    result\n-}\n-\n-pub fn super_fold_trait_ref_contents<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                                t: &ty::TraitRef<'tcx>)\n-                                                                -> ty::TraitRef<'tcx>\n {\n     ty::TraitRef {\n         def_id: t.def_id,\n@@ -706,40 +700,6 @@ pub fn super_fold_item_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Higher-ranked things\n-\n-/// Designates a \"binder\" for late-bound regions.\n-pub trait HigherRankedFoldable<'tcx>: Repr<'tcx> {\n-    /// Folds the contents of `self`, ignoring the region binder created\n-    /// by `self`.\n-    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n-}\n-\n-impl<'tcx> HigherRankedFoldable<'tcx> for ty::FnSig<'tcx> {\n-    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig<'tcx> {\n-        super_fold_fn_sig_contents(folder, self)\n-    }\n-}\n-\n-impl<'tcx> HigherRankedFoldable<'tcx> for ty::TraitRef<'tcx> {\n-    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef<'tcx> {\n-        super_fold_trait_ref_contents(folder, self)\n-    }\n-}\n-\n-impl<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>> HigherRankedFoldable<'tcx> for ty::Binder<T> {\n-    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n-        ty::bind(self.value.fold_with(folder))\n-    }\n-}\n-\n-impl<'tcx, T:HigherRankedFoldable<'tcx>> HigherRankedFoldable<'tcx> for Rc<T> {\n-    fn fold_contents<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n-        Rc::new((**self).fold_contents(folder))\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n@@ -751,7 +711,7 @@ pub struct BottomUpFolder<'a, 'tcx: 'a, F> where F: FnMut(Ty<'tcx>) -> Ty<'tcx>\n impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n     F: FnMut(Ty<'tcx>) -> Ty<'tcx>,\n {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n         let t1 = super_fold_ty(self, ty);\n@@ -770,18 +730,17 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx, F> where\n /// regions (aka \"lifetimes\") that are bound within a type are not\n /// visited by this folder; only regions that occur free will be\n /// visited by `fld_r`.\n-///\n-/// (The distinction between \"free\" and \"bound\" is represented by\n-/// keeping track of each `FnSig` in the lexical context of the\n-/// current position of the fold.)\n-pub struct RegionFolder<'a, 'tcx: 'a, F> where F: FnMut(ty::Region, uint) -> ty::Region {\n+\n+pub struct RegionFolder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     current_depth: uint,\n-    fld_r: F,\n+    fld_r: &'a mut (FnMut(ty::Region, uint) -> ty::Region + 'a),\n }\n \n-impl<'a, 'tcx, F> RegionFolder<'a, 'tcx, F> where F: FnMut(ty::Region, uint) -> ty::Region {\n-    pub fn new(tcx: &'a ty::ctxt<'tcx>, fld_r: F) -> RegionFolder<'a, 'tcx, F> {\n+impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n+    pub fn new<F>(tcx: &'a ty::ctxt<'tcx>, fld_r: &'a mut F) -> RegionFolder<'a, 'tcx>\n+        where F : FnMut(ty::Region, uint) -> ty::Region\n+    {\n         RegionFolder {\n             tcx: tcx,\n             current_depth: 1,\n@@ -790,10 +749,27 @@ impl<'a, 'tcx, F> RegionFolder<'a, 'tcx, F> where F: FnMut(ty::Region, uint) ->\n     }\n }\n \n-impl<'a, 'tcx, F> TypeFolder<'tcx> for RegionFolder<'a, 'tcx, F> where\n-    F: FnMut(ty::Region, uint) -> ty::Region,\n+pub fn collect_regions<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> Vec<ty::Region>\n+    where T : TypeFoldable<'tcx>\n+{\n+    let mut vec = Vec::new();\n+    fold_regions(tcx, value, |r, _| { vec.push(r); r });\n+    vec\n+}\n+\n+pub fn fold_regions<'tcx,T,F>(tcx: &ty::ctxt<'tcx>,\n+                              value: &T,\n+                              mut f: F)\n+                              -> T\n+    where F : FnMut(ty::Region, uint) -> ty::Region,\n+          T : TypeFoldable<'tcx>,\n {\n-    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n+    value.fold_with(&mut RegionFolder::new(tcx, &mut f))\n+}\n+\n+impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n+{\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n \n     fn enter_region_binder(&mut self) {\n         self.current_depth += 1;\n@@ -813,7 +789,7 @@ impl<'a, 'tcx, F> TypeFolder<'tcx> for RegionFolder<'a, 'tcx, F> where\n             _ => {\n                 debug!(\"RegionFolder.fold_region({}) folding free region (current_depth={})\",\n                        r.repr(self.tcx()), self.current_depth);\n-                (self.fld_r)(r, self.current_depth)\n+                self.fld_r.call_mut((r, self.current_depth))\n             }\n         }\n     }\n@@ -869,7 +845,7 @@ pub fn shift_regions<'tcx, T:TypeFoldable<'tcx>+Repr<'tcx>>(tcx: &ty::ctxt<'tcx>\n     debug!(\"shift_regions(value={}, amount={})\",\n            value.repr(tcx), amount);\n \n-    value.fold_with(&mut RegionFolder::new(tcx, |region, _current_depth| {\n+    value.fold_with(&mut RegionFolder::new(tcx, &mut |region, _current_depth| {\n         shift_region(region, amount)\n     }))\n }"}, {"sha": "b0124977c9f1b9ff25a083591fbe11803b8eaf35", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 101, "deletions": 41, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -23,7 +23,10 @@ use middle::ty::{ty_param, ty_ptr, ty_rptr, ty_tup, ty_open};\n use middle::ty::{ty_unboxed_closure};\n use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n+use middle::ty_fold::TypeFoldable;\n \n+use std::collections::HashMap;\n+use std::hash::{Hash, Hasher};\n use std::rc::Rc;\n use syntax::abi;\n use syntax::ast_map;\n@@ -40,7 +43,7 @@ pub trait Repr<'tcx> for Sized? {\n }\n \n /// Produces a string suitable for showing to the user.\n-pub trait UserString<'tcx> {\n+pub trait UserString<'tcx> : Repr<'tcx> {\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String;\n }\n \n@@ -248,21 +251,12 @@ pub fn vec_map_to_string<T, F>(ts: &[T], f: F) -> String where\n     format!(\"[{}]\", tstrs.connect(\", \"))\n }\n \n-pub fn fn_sig_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::FnSig<'tcx>) -> String {\n-    format!(\"fn{} -> {}\", typ.inputs.repr(cx), typ.output.repr(cx))\n-}\n-\n-pub fn trait_ref_to_string<'tcx>(cx: &ctxt<'tcx>,\n-                                 trait_ref: &ty::TraitRef<'tcx>) -> String {\n-    trait_ref.user_string(cx).to_string()\n-}\n-\n pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n     fn bare_fn_to_string<'tcx>(cx: &ctxt<'tcx>,\n                                unsafety: ast::Unsafety,\n                                abi: abi::Abi,\n                                ident: Option<ast::Ident>,\n-                               sig: &ty::FnSig<'tcx>)\n+                               sig: &ty::PolyFnSig<'tcx>)\n                                -> String {\n         let mut s = String::new();\n         match unsafety {\n@@ -336,15 +330,15 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                                 s: &mut String,\n                                 bra: char,\n                                 ket: char,\n-                                sig: &ty::FnSig<'tcx>,\n+                                sig: &ty::PolyFnSig<'tcx>,\n                                 bounds: &str) {\n         s.push(bra);\n-        let strs = sig.inputs\n+        let strs = sig.0.inputs\n             .iter()\n             .map(|a| ty_to_string(cx, *a))\n             .collect::<Vec<_>>();\n         s.push_str(strs.connect(\", \").as_slice());\n-        if sig.variadic {\n+        if sig.0.variadic {\n             s.push_str(\", ...\");\n         }\n         s.push(ket);\n@@ -354,7 +348,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             s.push_str(bounds);\n         }\n \n-        match sig.output {\n+        match sig.0.output {\n             ty::FnConverging(t) => {\n                 if !ty::type_is_nil(t) {\n                    s.push_str(\" -> \");\n@@ -374,8 +368,8 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             ty::IntVar(ref vid) if print_var_ids => vid.repr(cx),\n             ty::FloatVar(ref vid) if print_var_ids => vid.repr(cx),\n             ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) => format!(\"_\"),\n-            ty::SkolemizedTy(v) => format!(\"SkolemizedTy({})\", v),\n-            ty::SkolemizedIntTy(v) => format!(\"SkolemizedIntTy({})\", v)\n+            ty::FreshTy(v) => format!(\"FreshTy({})\", v),\n+            ty::FreshIntTy(v) => format!(\"FreshIntTy({})\", v)\n         }\n     }\n \n@@ -433,16 +427,11 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         ty_trait(box ty::TyTrait {\n             ref principal, ref bounds\n         }) => {\n-            let base = ty::item_path_str(cx, principal.def_id);\n-            let trait_def = ty::lookup_trait_def(cx, principal.def_id);\n-            let did = trait_def.trait_ref.def_id;\n-            let ty = parameterized(cx, base.as_slice(),\n-                                   &principal.substs, &trait_def.generics,\n-                                   did);\n+            let principal = principal.user_string(cx);\n             let bound_str = bounds.user_string(cx);\n             let bound_sep = if bound_str.is_empty() { \"\" } else { \" + \" };\n             format!(\"{}{}{}\",\n-                    ty,\n+                    principal,\n                     bound_sep,\n                     bound_str)\n         }\n@@ -749,7 +738,7 @@ impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n         // tells you everything you need to know.\n         let base = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        format!(\"<{} : {}>\",\n+        format!(\"TraitRef({}, {})\",\n                 self.substs.self_ty().repr(tcx),\n                 parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics, self.def_id))\n     }\n@@ -1018,7 +1007,7 @@ impl<'tcx> Repr<'tcx> for ty::BareFnTy<'tcx> {\n \n impl<'tcx> Repr<'tcx> for ty::FnSig<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        fn_sig_to_string(tcx, self)\n+        format!(\"fn{} -> {}\", self.inputs.repr(tcx), self.output.repr(tcx))\n     }\n }\n \n@@ -1161,15 +1150,17 @@ impl<'tcx> UserString<'tcx> for ty::BuiltinBounds {\n     }\n }\n \n-impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n+impl<'tcx, T> UserString<'tcx> for ty::Binder<T>\n+    where T : UserString<'tcx> + TypeFoldable<'tcx>\n+{\n     fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n         // Replace any anonymous late-bound regions with named\n         // variants, using gensym'd identifiers, so that we can\n         // clearly differentiate between named and unnamed regions in\n         // the output. We'll probably want to tweak this over time to\n         // decide just how much information to give.\n         let mut names = Vec::new();\n-        let (trait_ref, _) = ty::replace_late_bound_regions(tcx, self, |br, debruijn| {\n+        let (unbound_value, _) = ty::replace_late_bound_regions(tcx, self, |br, debruijn| {\n             ty::ReLateBound(debruijn, match br {\n                 ty::BrNamed(_, name) => {\n                     names.push(token::get_name(name));\n@@ -1178,27 +1169,29 @@ impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n                 ty::BrAnon(_) |\n                 ty::BrFresh(_) |\n                 ty::BrEnv => {\n-                    let name = token::gensym(\"r\");\n+                    let name = token::gensym(\"'r\");\n                     names.push(token::get_name(name));\n                     ty::BrNamed(ast_util::local_def(ast::DUMMY_NODE_ID), name)\n                 }\n             })\n         });\n         let names: Vec<_> = names.iter().map(|s| s.get()).collect();\n \n-        // Let the base string be either `SomeTrait` for `for<'a,'b> SomeTrait`,\n-        // depending on whether there are bound regions.\n-        let path_str = ty::item_path_str(tcx, self.def_id);\n-        let base =\n-            if names.is_empty() {\n-                path_str\n-            } else {\n-                format!(\"for<{}> {}\", names.connect(\",\"), path_str)\n-            };\n+        let value_str = unbound_value.user_string(tcx);\n+        if names.len() == 0 {\n+            value_str\n+        } else {\n+            format!(\"for<{}> {}\", names.connect(\",\"), value_str)\n+        }\n+    }\n+}\n \n+impl<'tcx> UserString<'tcx> for ty::TraitRef<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        let path_str = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        let did = trait_def.trait_ref.def_id;\n-        parameterized(tcx, base.as_slice(), &trait_ref.substs, &trait_def.generics, did)\n+        parameterized(tcx, path_str.as_slice(), &self.substs,\n+                      &trait_def.generics, self.def_id)\n     }\n }\n \n@@ -1340,6 +1333,73 @@ impl<'tcx, A:Repr<'tcx>, B:Repr<'tcx>> Repr<'tcx> for (A,B) {\n \n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for ty::Binder<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"Binder({})\", self.value.repr(tcx))\n+        format!(\"Binder({})\", self.0.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx, S, H, K, V> Repr<'tcx> for HashMap<K,V,H>\n+    where K : Hash<S> + Eq + Repr<'tcx>,\n+          V : Repr<'tcx>,\n+          H : Hasher<S>\n+{\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"HashMap({})\",\n+                self.iter()\n+                    .map(|(k,v)| format!(\"{} => {}\", k.repr(tcx), v.repr(tcx)))\n+                    .collect::<Vec<String>>()\n+                    .connect(\", \"))\n+    }\n+}\n+\n+impl<'tcx, T, U> Repr<'tcx> for ty::OutlivesPredicate<T,U>\n+    where T : Repr<'tcx> + TypeFoldable<'tcx>,\n+          U : Repr<'tcx> + TypeFoldable<'tcx>,\n+{\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"OutlivesPredicate({}, {})\",\n+                self.0.repr(tcx),\n+                self.1.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx, T, U> UserString<'tcx> for ty::OutlivesPredicate<T,U>\n+    where T : UserString<'tcx> + TypeFoldable<'tcx>,\n+          U : UserString<'tcx> + TypeFoldable<'tcx>,\n+{\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"{} : {}\",\n+                self.0.user_string(tcx),\n+                self.1.user_string(tcx))\n+    }\n+}\n+\n+impl<'tcx> Repr<'tcx> for ty::EquatePredicate<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"EquatePredicate({}, {})\",\n+                self.0.repr(tcx),\n+                self.1.repr(tcx))\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for ty::EquatePredicate<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"{} == {}\",\n+                self.0.user_string(tcx),\n+                self.1.user_string(tcx))\n+    }\n+}\n+\n+impl<'tcx> UserString<'tcx> for ty::Predicate<'tcx> {\n+    fn user_string(&self, tcx: &ctxt<'tcx>) -> String {\n+        match *self {\n+            ty::Predicate::Trait(ref trait_ref) => {\n+                format!(\"{} : {}\",\n+                        trait_ref.self_ty().user_string(tcx),\n+                        trait_ref.user_string(tcx))\n+            }\n+            ty::Predicate::Equate(ref predicate) => predicate.user_string(tcx),\n+            ty::Predicate::RegionOutlives(ref predicate) => predicate.user_string(tcx),\n+            ty::Predicate::TypeOutlives(ref predicate) => predicate.user_string(tcx),\n+        }\n     }\n }"}, {"sha": "749c39d7a6b92219591dac776430ff97d6686bb9", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -23,7 +23,7 @@ use self::UndoLog::*;\n use std::mem;\n \n #[deriving(PartialEq)]\n-enum UndoLog<T,U> {\n+pub enum UndoLog<T,U> {\n     /// Indicates where a snapshot started.\n     OpenSnapshot,\n \n@@ -113,6 +113,12 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n         Snapshot { length: length }\n     }\n \n+    pub fn actions_since_snapshot(&self,\n+                                  snapshot: &Snapshot)\n+                                  -> &[UndoLog<T,U>] {\n+        self.undo_log[snapshot.length..]\n+    }\n+\n     fn assert_open_snapshot(&self, snapshot: &Snapshot) {\n         // Or else there was a failure to follow a stack discipline:\n         assert!(self.undo_log.len() > snapshot.length);"}, {"sha": "b2c661cc58aa40ef035d6b9412bb892858e1ce60", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 125, "deletions": 2, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -25,6 +25,7 @@ use rustc_typeck::middle::infer::combine::Combine;\n use rustc_typeck::middle::infer;\n use rustc_typeck::middle::infer::lub::Lub;\n use rustc_typeck::middle::infer::glb::Glb;\n+use rustc_typeck::middle::infer::sub::Sub;\n use rustc_typeck::util::ppaux::{ty_to_string, Repr, UserString};\n use rustc::session::{mod,config};\n use syntax::{abi, ast, ast_map, ast_util};\n@@ -274,11 +275,11 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             onceness: ast::Many,\n             store: ty::RegionTraitStore(region_bound, ast::MutMutable),\n             bounds: ty::region_existential_bound(region_bound),\n-            sig: ty::FnSig {\n+            sig: ty::Binder(ty::FnSig {\n                 inputs: input_tys.to_vec(),\n                 output: ty::FnConverging(output_ty),\n                 variadic: false,\n-            },\n+            }),\n             abi: abi::Rust,\n         })\n     }\n@@ -341,6 +342,11 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         infer::TypeTrace::dummy()\n     }\n \n+    pub fn sub(&self) -> Sub<'a, 'tcx> {\n+        let trace = self.dummy_type_trace();\n+        Sub(self.infcx.combine_fields(true, trace))\n+    }\n+\n     pub fn lub(&self) -> Lub<'a, 'tcx> {\n         let trace = self.dummy_type_trace();\n         Lub(self.infcx.combine_fields(true, trace))\n@@ -359,6 +365,33 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         }\n     }\n \n+    /// Checks that `t1 <: t2` is true (this may register additional\n+    /// region checks).\n+    pub fn check_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n+        match self.sub().tys(t1, t2) {\n+            Ok(_) => { }\n+            Err(ref e) => {\n+                panic!(\"unexpected error computing sub({},{}): {}\",\n+                       t1.repr(self.infcx.tcx),\n+                       t2.repr(self.infcx.tcx),\n+                       ty::type_err_to_str(self.infcx.tcx, e));\n+            }\n+        }\n+    }\n+\n+    /// Checks that `t1 <: t2` is false (this may register additional\n+    /// region checks).\n+    pub fn check_not_sub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>) {\n+        match self.sub().tys(t1, t2) {\n+            Err(_) => { }\n+            Ok(_) => {\n+                panic!(\"unexpected success computing sub({},{})\",\n+                       t1.repr(self.infcx.tcx),\n+                       t2.repr(self.infcx.tcx));\n+            }\n+        }\n+    }\n+\n     /// Checks that `LUB(t1,t2) == t_lub`\n     pub fn check_lub(&self, t1: Ty<'tcx>, t2: Ty<'tcx>, t_lub: Ty<'tcx>) {\n         match self.lub().tys(t1, t2) {\n@@ -421,6 +454,74 @@ fn contravariant_region_ptr_err() {\n              })\n }\n \n+#[test]\n+fn sub_free_bound_false() {\n+    //! Test that:\n+    //!\n+    //!     fn(&'a int) <: for<'b> fn(&'b int)\n+    //!\n+    //! does NOT hold.\n+\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+        env.check_not_sub(env.t_fn(&[t_rptr_free1], ty::mk_int()),\n+                          env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+    })\n+}\n+\n+#[test]\n+fn sub_bound_free_true() {\n+    //! Test that:\n+    //!\n+    //!     for<'a> fn(&'a int) <: fn(&'b int)\n+    //!\n+    //! DOES hold.\n+\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        env.check_sub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_free1], ty::mk_int()));\n+    })\n+}\n+\n+#[test]\n+fn sub_free_bound_false_infer() {\n+    //! Test that:\n+    //!\n+    //!     fn(_#1) <: for<'b> fn(&'b int)\n+    //!\n+    //! does NOT hold for any instantiation of `_#1`.\n+\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_infer1 = env.infcx.next_ty_var();\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+        env.check_not_sub(env.t_fn(&[t_infer1], ty::mk_int()),\n+                          env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+    })\n+}\n+\n+#[test]\n+fn lub_free_bound_infer() {\n+    //! Test result of:\n+    //!\n+    //!     LUB(fn(_#1), for<'b> fn(&'b int))\n+    //!\n+    //! This should yield `fn(&'_ int)`. We check\n+    //! that it yields `fn(&'x int)` for some free `'x`,\n+    //! anyhow.\n+\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_infer1 = env.infcx.next_ty_var();\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        env.check_lub(env.t_fn(&[t_infer1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_free1], ty::mk_int()));\n+    });\n+}\n+\n #[test]\n fn lub_bound_bound() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n@@ -524,6 +625,28 @@ fn glb_bound_free() {\n     })\n }\n \n+#[test]\n+fn glb_bound_free_infer() {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+        let t_infer1 = env.infcx.next_ty_var();\n+\n+        // compute GLB(fn(_) -> int, for<'b> fn(&'b int) -> int),\n+        // which should yield for<'b> fn(&'b int) -> int\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_infer1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n+\n+        // as a side-effect, computing GLB should unify `_` with\n+        // `&'_ int`\n+        let t_resolve1 = env.infcx.shallow_resolve(t_infer1);\n+        match t_resolve1.sty {\n+            ty::ty_rptr(..) => { }\n+            _ => { panic!(\"t_resolve1={}\", t_resolve1.repr(env.infcx.tcx)); }\n+        }\n+    })\n+}\n+\n #[test]\n fn glb_bound_static() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {"}, {"sha": "b947b1746fcab26b35dfd012cac62ac8ca3595d9", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -282,19 +282,19 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n     let (inputs, output, abi, env) = match fn_ty.sty {\n         ty::ty_bare_fn(ref f) => {\n-            (f.sig.inputs.clone(), f.sig.output, f.abi, None)\n+            (f.sig.0.inputs.clone(), f.sig.0.output, f.abi, None)\n         }\n         ty::ty_closure(ref f) => {\n-            (f.sig.inputs.clone(), f.sig.output, f.abi, Some(Type::i8p(ccx)))\n+            (f.sig.0.inputs.clone(), f.sig.0.output, f.abi, Some(Type::i8p(ccx)))\n         }\n         ty::ty_unboxed_closure(closure_did, _, ref substs) => {\n             let unboxed_closures = ccx.tcx().unboxed_closures.borrow();\n             let unboxed_closure = &(*unboxed_closures)[closure_did];\n             let function_type = unboxed_closure.closure_type.clone();\n             let self_type = self_type_for_unboxed_closure(ccx, closure_did, fn_ty);\n             let llenvironment_type = type_of_explicit_arg(ccx, self_type);\n-            (function_type.sig.inputs.iter().map(|t| t.subst(ccx.tcx(), substs)).collect(),\n-             function_type.sig.output.subst(ccx.tcx(), substs),\n+            (function_type.sig.0.inputs.iter().map(|t| t.subst(ccx.tcx(), substs)).collect(),\n+             function_type.sig.0.output.subst(ccx.tcx(), substs),\n              RustCall,\n              Some(llenvironment_type))\n         }\n@@ -1998,7 +1998,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(ref bft) => bft.sig.output.unwrap(),\n+        ty::ty_bare_fn(ref bft) => bft.sig.0.output.unwrap(),\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n@@ -2070,7 +2070,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n     let ctor_ty = ctor_ty.subst(ccx.tcx(), param_substs);\n \n     let result_ty = match ctor_ty.sty {\n-        ty::ty_bare_fn(ref bft) => bft.sig.output,\n+        ty::ty_bare_fn(ref bft) => bft.sig.0.output,\n         _ => ccx.sess().bug(\n             format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n@@ -2439,31 +2439,31 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n     // at either 1 or 2 depending on whether there's an env slot or not\n     let mut first_arg_offset = if has_env { 2 } else { 1 };\n     let mut attrs = llvm::AttrBuilder::new();\n-    let ret_ty = fn_sig.output;\n+    let ret_ty = fn_sig.0.output;\n \n     // These have an odd calling convention, so we need to manually\n     // unpack the input ty's\n     let input_tys = match fn_ty.sty {\n         ty::ty_unboxed_closure(_, _, _) => {\n             assert!(abi == RustCall);\n \n-            match fn_sig.inputs[0].sty {\n+            match fn_sig.0.inputs[0].sty {\n                 ty::ty_tup(ref inputs) => inputs.clone(),\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         },\n         ty::ty_bare_fn(_) if abi == RustCall => {\n-            let mut inputs = vec![fn_sig.inputs[0]];\n+            let mut inputs = vec![fn_sig.0.inputs[0]];\n \n-            match fn_sig.inputs[1].sty {\n+            match fn_sig.0.inputs[1].sty {\n                 ty::ty_tup(ref t_in) => {\n                     inputs.push_all(t_in.as_slice());\n                     inputs\n                 }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n             }\n         }\n-        _ => fn_sig.inputs.clone()\n+        _ => fn_sig.0.inputs.clone()\n     };\n \n     if let ty::FnConverging(ret_ty) = ret_ty {"}, {"sha": "f8303a6f030809effcfc022516fb2a46eb022dcb", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -280,9 +280,9 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n         match bare_fn_ty.sty {\n             ty::ty_bare_fn(ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n                                           abi: synabi::Rust,\n-                                          sig: ty::FnSig { inputs: ref input_tys,\n-                                                           output: output_ty,\n-                                                           variadic: false }}) =>\n+                                          sig: ty::Binder(ty::FnSig { inputs: ref input_tys,\n+                                                                      output: output_ty,\n+                                                                      variadic: false })}) =>\n             {\n                 (input_tys, output_ty)\n             }\n@@ -296,12 +296,12 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let tuple_fn_ty = ty::mk_bare_fn(tcx,\n                                      ty::BareFnTy { unsafety: ast::Unsafety::Normal,\n                                                     abi: synabi::RustCall,\n-                                                    sig: ty::FnSig {\n+                                                    sig: ty::Binder(ty::FnSig {\n                                                         inputs: vec![bare_fn_ty_ref,\n                                                                      tuple_input_ty],\n                                                         output: output_ty,\n                                                         variadic: false\n-                                                    }});\n+                                                    })});\n     debug!(\"tuple_fn_ty: {}\", tuple_fn_ty.repr(tcx));\n \n     //\n@@ -422,7 +422,6 @@ pub fn trans_fn_ref_with_substs<'blk, 'tcx>(\n             match impl_or_trait_item {\n                 ty::MethodTraitItem(method) => {\n                     let trait_ref = ty::impl_trait_ref(tcx, impl_id).unwrap();\n-                    let trait_ref = ty::erase_late_bound_regions(tcx, &trait_ref);\n \n                     // Compute the first substitution\n                     let first_subst =\n@@ -657,8 +656,8 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = callee.bcx;\n \n     let (abi, ret_ty) = match callee_ty.sty {\n-        ty::ty_bare_fn(ref f) => (f.abi, f.sig.output),\n-        ty::ty_closure(ref f) => (f.abi, f.sig.output),\n+        ty::ty_bare_fn(ref f) => (f.abi, f.sig.0.output),\n+        ty::ty_closure(ref f) => (f.abi, f.sig.0.output),\n         _ => panic!(\"expected bare rust fn or closure in trans_call_inner\")\n     };\n "}, {"sha": "af3daf224e3265afb21e5dc3d440d80189dce8bc", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -658,9 +658,9 @@ pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let arena = TypedArena::new();\n     let empty_param_substs = Substs::trans_empty();\n-    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, true, f.sig.output,\n+    let fcx = new_fn_ctxt(ccx, llfn, ast::DUMMY_NODE_ID, true, f.sig.0.output,\n                           &empty_param_substs, None, &arena);\n-    let bcx = init_function(&fcx, true, f.sig.output);\n+    let bcx = init_function(&fcx, true, f.sig.0.output);\n \n     let args = create_datums_for_fn_args(&fcx,\n                                          ty::ty_fn_args(closure_ty)\n@@ -676,7 +676,7 @@ pub fn get_wrapper_for_bare_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     llargs.extend(args.iter().map(|arg| arg.val));\n \n     let retval = Call(bcx, fn_ptr, llargs.as_slice(), None);\n-    match f.sig.output {\n+    match f.sig.0.output {\n         ty::FnConverging(output_type) => {\n             if return_type_is_void(ccx, output_type) || fcx.llretslotptr.get().is_some() {\n                 RetVoid(bcx);"}, {"sha": "a8e88eca0e19f1f49216bf8d44d71d9628377fb2", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -764,7 +764,7 @@ pub fn expr_ty_adjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ex: &ast::Expr) -> T\n /// guarantee to us that all nested obligations *could be* resolved if we wanted to.\n pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                     span: Span,\n-                                    trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                                    trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n                                     -> traits::Vtable<'tcx, ()>\n {\n     let tcx = ccx.tcx();\n@@ -783,7 +783,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     debug!(\"trans fulfill_obligation: trait_ref={}\", trait_ref.repr(ccx.tcx()));\n \n-    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id);\n+    ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id());\n     let infcx = infer::new_infer_ctxt(tcx);\n \n     // Parameter environment is used to give details about type parameters,\n@@ -848,12 +848,12 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    // Use skolemize to simultaneously replace all type variables with\n+    // Use freshen to simultaneously replace all type variables with\n     // their bindings and replace all regions with 'static.  This is\n     // sort of overkill because we do not expect there to be any\n-    // unbound type variables, hence no skolemized types should ever\n-    // be inserted.\n-    let vtable = vtable.fold_with(&mut infcx.skolemizer());\n+    // unbound type variables, hence no `TyFresh` types should ever be\n+    // inserted.\n+    let vtable = vtable.fold_with(&mut infcx.freshener());\n \n     info!(\"Cache miss: {}\", trait_ref.repr(ccx.tcx()));\n     ccx.trait_cache().borrow_mut().insert(trait_ref,"}, {"sha": "af003b011579f2687e56897f14f841517dd24970", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -99,7 +99,7 @@ pub struct LocalCrateContext<'tcx> {\n     monomorphized: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::TraitRef<'tcx>>), ValueRef>>,\n+    vtables: RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::PolyTraitRef<'tcx>>), ValueRef>>,\n     /// Cache of constant strings,\n     const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n \n@@ -150,7 +150,7 @@ pub struct LocalCrateContext<'tcx> {\n     /// contexts around the same size.\n     n_llvm_insns: Cell<uint>,\n \n-    trait_cache: RefCell<FnvHashMap<Rc<ty::TraitRef<'tcx>>,\n+    trait_cache: RefCell<FnvHashMap<Rc<ty::PolyTraitRef<'tcx>>,\n                                     traits::Vtable<'tcx, ()>>>,\n }\n \n@@ -601,7 +601,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.monomorphizing\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::TraitRef<'tcx>>),\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(Ty<'tcx>, Rc<ty::PolyTraitRef<'tcx>>),\n                                                             ValueRef>> {\n         &self.local.vtables\n     }\n@@ -699,7 +699,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local.n_llvm_insns.set(self.local.n_llvm_insns.get() + 1);\n     }\n \n-    pub fn trait_cache(&self) -> &RefCell<FnvHashMap<Rc<ty::TraitRef<'tcx>>,\n+    pub fn trait_cache(&self) -> &RefCell<FnvHashMap<Rc<ty::PolyTraitRef<'tcx>>,\n                                                      traits::Vtable<'tcx, ()>>> {\n         &self.local.trait_cache\n     }"}, {"sha": "96c39b5796ec4ccb7a0f5b010d85350d1195d13d", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -429,8 +429,8 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 from_def_id_and_substs(self,\n                                        cx,\n-                                       trait_data.principal.def_id,\n-                                       &trait_data.principal.substs,\n+                                       trait_data.principal.def_id(),\n+                                       trait_data.principal.substs(),\n                                        &mut unique_type_id);\n             },\n             ty::ty_bare_fn(ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n@@ -442,7 +442,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 unique_type_id.push_str(\" fn(\");\n \n-                for &parameter_type in sig.inputs.iter() {\n+                for &parameter_type in sig.0.inputs.iter() {\n                     let parameter_type_id =\n                         self.get_unique_type_id_of_type(cx, parameter_type);\n                     let parameter_type_id =\n@@ -451,12 +451,12 @@ impl<'tcx> TypeMap<'tcx> {\n                     unique_type_id.push(',');\n                 }\n \n-                if sig.variadic {\n+                if sig.0.variadic {\n                     unique_type_id.push_str(\"...\");\n                 }\n \n                 unique_type_id.push_str(\")->\");\n-                match sig.output {\n+                match sig.0.output {\n                     ty::FnConverging(ret_ty) => {\n                         let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                         let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n@@ -575,7 +575,7 @@ impl<'tcx> TypeMap<'tcx> {\n             }\n         };\n \n-        for &parameter_type in sig.inputs.iter() {\n+        for &parameter_type in sig.0.inputs.iter() {\n             let parameter_type_id =\n                 self.get_unique_type_id_of_type(cx, parameter_type);\n             let parameter_type_id =\n@@ -584,13 +584,13 @@ impl<'tcx> TypeMap<'tcx> {\n             unique_type_id.push(',');\n         }\n \n-        if sig.variadic {\n+        if sig.0.variadic {\n             unique_type_id.push_str(\"...\");\n         }\n \n         unique_type_id.push_str(\"|->\");\n \n-        match sig.output {\n+        match sig.0.output {\n             ty::FnConverging(ret_ty) => {\n                 let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                 let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n@@ -2787,13 +2787,13 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                       unique_type_id: UniqueTypeId,\n-                                      signature: &ty::FnSig<'tcx>,\n+                                      signature: &ty::PolyFnSig<'tcx>,\n                                       span: Span)\n                                       -> MetadataCreationResult {\n-    let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.inputs.len() + 1);\n+    let mut signature_metadata: Vec<DIType> = Vec::with_capacity(signature.0.inputs.len() + 1);\n \n     // return type\n-    signature_metadata.push(match signature.output {\n+    signature_metadata.push(match signature.0.output {\n         ty::FnConverging(ret_ty) => match ret_ty.sty {\n             ty::ty_tup(ref tys) if tys.is_empty() => ptr::null_mut(),\n             _ => type_metadata(cx, ret_ty, span)\n@@ -2802,7 +2802,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     });\n \n     // regular arguments\n-    for &argument_type in signature.inputs.iter() {\n+    for &argument_type in signature.0.inputs.iter() {\n         signature_metadata.push(type_metadata(cx, argument_type, span));\n     }\n \n@@ -2834,7 +2834,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     // But it does not describe the trait's methods.\n \n     let def_id = match trait_type.sty {\n-        ty::ty_trait(box ty::TyTrait { ref principal, .. }) => principal.def_id,\n+        ty::ty_trait(box ty::TyTrait { ref principal, .. }) => principal.def_id(),\n         _ => {\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(format!(\"debuginfo: Unexpected trait-object type in \\\n@@ -3765,8 +3765,8 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             output.push(']');\n         },\n         ty::ty_trait(ref trait_data) => {\n-            push_item_name(cx, trait_data.principal.def_id, false, output);\n-            push_type_params(cx, &trait_data.principal.substs, output);\n+            push_item_name(cx, trait_data.principal.def_id(), false, output);\n+            push_type_params(cx, trait_data.principal.substs(), output);\n         },\n         ty::ty_bare_fn(ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n             if unsafety == ast::Unsafety::Unsafe {\n@@ -3781,17 +3781,17 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push_str(\"fn(\");\n \n-            if sig.inputs.len() > 0 {\n-                for &parameter_type in sig.inputs.iter() {\n+            if sig.0.inputs.len() > 0 {\n+                for &parameter_type in sig.0.inputs.iter() {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n                 }\n                 output.pop();\n                 output.pop();\n             }\n \n-            if sig.variadic {\n-                if sig.inputs.len() > 0 {\n+            if sig.0.variadic {\n+                if sig.0.inputs.len() > 0 {\n                     output.push_str(\", ...\");\n                 } else {\n                     output.push_str(\"...\");\n@@ -3800,7 +3800,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push(')');\n \n-            match sig.output {\n+            match sig.0.output {\n                 ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n                 ty::FnConverging(result_type) => {\n                     output.push_str(\" -> \");\n@@ -3841,17 +3841,17 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             };\n \n-            if sig.inputs.len() > 0 {\n-                for &parameter_type in sig.inputs.iter() {\n+            if sig.0.inputs.len() > 0 {\n+                for &parameter_type in sig.0.inputs.iter() {\n                     push_debuginfo_type_name(cx, parameter_type, true, output);\n                     output.push_str(\", \");\n                 }\n                 output.pop();\n                 output.pop();\n             }\n \n-            if sig.variadic {\n-                if sig.inputs.len() > 0 {\n+            if sig.0.variadic {\n+                if sig.0.inputs.len() > 0 {\n                     output.push_str(\", ...\");\n                 } else {\n                     output.push_str(\"...\");\n@@ -3860,7 +3860,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             output.push(param_list_closing_char);\n \n-            match sig.output {\n+            match sig.0.output {\n                 ty::FnConverging(result_type) if ty::type_is_nil(result_type) => {}\n                 ty::FnConverging(result_type) => {\n                     output.push_str(\" -> \");"}, {"sha": "db44e0ce27197c9a99be286d0625e2f8e381947f", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -316,10 +316,10 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           bcx.ty_to_string(unadjusted_ty)).as_slice())\n             },\n             &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n-                let substs = principal.substs.with_self_ty(unadjusted_ty).erase_regions();\n+                let substs = principal.substs().with_self_ty(unadjusted_ty).erase_regions();\n                 let trait_ref =\n-                    Rc::new(ty::TraitRef { def_id: principal.def_id,\n-                                           substs: substs });\n+                    Rc::new(ty::Binder(ty::TraitRef { def_id: principal.def_id(),\n+                                                      substs: substs }));\n                 let trait_ref = trait_ref.subst(bcx.tcx(), bcx.fcx.param_substs);\n                 let box_ty = mk_ty(unadjusted_ty);\n                 PointerCast(bcx,"}, {"sha": "d07203199305097d3cf85d48fc7afe301543bb5d", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -22,7 +22,6 @@ use trans::machine;\n use trans::type_::Type;\n use trans::type_of::*;\n use trans::type_of;\n-use middle::ty::FnSig;\n use middle::ty::{mod, Ty};\n use middle::subst::{Subst, Substs};\n use std::cmp;\n@@ -41,7 +40,7 @@ use util::ppaux::Repr;\n \n struct ForeignTypes<'tcx> {\n     /// Rust signature of the function\n-    fn_sig: ty::FnSig<'tcx>,\n+    fn_sig: ty::PolyFnSig<'tcx>,\n \n     /// Adapter object for handling native ABI rules (trust me, you\n     /// don't want to know)\n@@ -179,7 +178,7 @@ pub fn register_foreign_item_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // Make sure the calling convention is right for variadic functions\n     // (should've been caught if not in typeck)\n-    if tys.fn_sig.variadic {\n+    if tys.fn_sig.0.variadic {\n         assert!(cc == llvm::CCallConv);\n     }\n \n@@ -386,7 +385,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         debug!(\"llforeign_ret_ty={}\", ccx.tn().type_to_string(llforeign_ret_ty));\n \n         if llrust_ret_ty == llforeign_ret_ty {\n-            match fn_sig.output {\n+            match fn_sig.0.output {\n                 ty::FnConverging(result_ty) => {\n                     base::store_ty(bcx, llforeign_retval, llretptr, result_ty)\n                 }\n@@ -632,7 +631,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         };\n \n         // Push Rust return pointer, using null if it will be unused.\n-        let rust_uses_outptr = match tys.fn_sig.output {\n+        let rust_uses_outptr = match tys.fn_sig.0.output {\n             ty::FnConverging(ret_ty) => type_of::return_uses_outptr(ccx, ret_ty),\n             ty::FnDiverging => false\n         };\n@@ -665,7 +664,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                             return_ty={}\",\n                            ccx.tn().val_to_string(slot),\n                            ccx.tn().type_to_string(llrust_ret_ty),\n-                           tys.fn_sig.output.repr(tcx));\n+                           tys.fn_sig.0.output.repr(tcx));\n                     llrust_args.push(slot);\n                     return_alloca = Some(slot);\n                 }\n@@ -680,8 +679,8 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Build up the arguments to the call to the rust function.\n         // Careful to adapt for cases where the native convention uses\n         // a pointer and Rust does not or vice versa.\n-        for i in range(0, tys.fn_sig.inputs.len()) {\n-            let rust_ty = tys.fn_sig.inputs[i];\n+        for i in range(0, tys.fn_sig.0.inputs.len()) {\n+            let rust_ty = tys.fn_sig.0.inputs[i];\n             let llrust_ty = tys.llsig.llarg_tys[i];\n             let rust_indirect = type_of::arg_is_indirect(ccx, rust_ty);\n             let llforeign_arg_ty = tys.fn_ty.arg_tys[i];\n@@ -826,10 +825,10 @@ pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n /// because foreign functions just plain ignore modes. They also don't pass aggregate values by\n /// pointer like we do.\n fn foreign_signature<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                               fn_sig: &ty::FnSig<'tcx>, arg_tys: &[Ty<'tcx>])\n+                               fn_sig: &ty::PolyFnSig<'tcx>, arg_tys: &[Ty<'tcx>])\n                                -> LlvmSignature {\n     let llarg_tys = arg_tys.iter().map(|&arg| arg_type_of(ccx, arg)).collect();\n-    let (llret_ty, ret_def) = match fn_sig.output {\n+    let (llret_ty, ret_def) = match fn_sig.0.output {\n         ty::FnConverging(ret_ty) =>\n             (type_of::arg_type_of(ccx, ret_ty), !return_type_is_void(ccx, ret_ty)),\n         ty::FnDiverging =>\n@@ -853,7 +852,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(ref fn_ty) => fn_ty.sig.clone(),\n         _ => ccx.sess().bug(\"foreign_types_for_fn_ty called on non-function type\")\n     };\n-    let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs.as_slice());\n+    let llsig = foreign_signature(ccx, &fn_sig, fn_sig.0.inputs.as_slice());\n     let fn_ty = cabi::compute_abi_info(ccx,\n                                        llsig.llarg_tys.as_slice(),\n                                        llsig.llret_ty,\n@@ -913,7 +912,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n         llargument_tys.push(llarg_ty);\n     }\n \n-    if tys.fn_sig.variadic {\n+    if tys.fn_sig.0.variadic {\n         Type::variadic_func(llargument_tys.as_slice(), &llreturn_ty)\n     } else {\n         Type::func(llargument_tys.as_slice(), &llreturn_ty)"}, {"sha": "dea095ecaf594c558a39ad752f86d928e8265a69", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -227,8 +227,8 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let fty = ty::lookup_item_type(bcx.tcx(), dtor_did).ty.subst(bcx.tcx(), substs);\n     let self_ty = match fty.sty {\n         ty::ty_bare_fn(ref f) => {\n-            assert!(f.sig.inputs.len() == 1);\n-            f.sig.inputs[0]\n+            assert!(f.sig.0.inputs.len() == 1);\n+            f.sig.0.inputs[0]\n         }\n         _ => bcx.sess().bug(format!(\"Expected function type, found {}\",\n                                     bcx.ty_to_string(fty)).as_slice())"}, {"sha": "a6f7c849f4d95ab8e390a7d00573bfda08225a1e", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -150,7 +150,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n \n     let ret_ty = match callee_ty.sty {\n-        ty::ty_bare_fn(ref f) => f.sig.output,\n+        ty::ty_bare_fn(ref f) => f.sig.0.output,\n         _ => panic!(\"expected bare_fn in trans_intrinsic_call\")\n     };\n     let foreign_item = tcx.map.expect_foreign_item(node);"}, {"sha": "f1c3c9be396af0c93d7d4a17f729b51bf22080ea", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -133,16 +133,16 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             method_num\n         }) => {\n             let trait_ref =\n-                Rc::new(trait_ref.subst(bcx.tcx(), bcx.fcx.param_substs));\n+                Rc::new(ty::Binder((**trait_ref).subst(bcx.tcx(), bcx.fcx.param_substs)));\n             let span = bcx.tcx().map.span(method_call.expr_id);\n             debug!(\"method_call={} trait_ref={}\",\n                    method_call,\n                    trait_ref.repr(bcx.tcx()));\n             let origin = fulfill_obligation(bcx.ccx(),\n                                             span,\n-                                            (*trait_ref).clone());\n+                                            trait_ref.clone());\n             debug!(\"origin = {}\", origin.repr(bcx.tcx()));\n-            trans_monomorphized_callee(bcx, method_call, trait_ref.def_id,\n+            trans_monomorphized_callee(bcx, method_call, trait_ref.def_id(),\n                                        method_num, origin)\n         }\n \n@@ -239,8 +239,8 @@ pub fn trans_static_method_callee(bcx: Block,\n                                              rcvr_assoc,\n                                              Vec::new()));\n     debug!(\"trait_substs={}\", trait_substs.repr(bcx.tcx()));\n-    let trait_ref = Rc::new(ty::TraitRef { def_id: trait_id,\n-                                           substs: trait_substs });\n+    let trait_ref = Rc::new(ty::Binder(ty::TraitRef { def_id: trait_id,\n+                                                      substs: trait_substs }));\n     let vtbl = fulfill_obligation(bcx.ccx(),\n                                   DUMMY_SP,\n                                   trait_ref);\n@@ -480,8 +480,8 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ty::ty_bare_fn(ref f) if f.abi == Rust || f.abi == RustCall => {\n             type_of_rust_fn(ccx,\n                             Some(Type::i8p(ccx)),\n-                            f.sig.inputs.slice_from(1),\n-                            f.sig.output,\n+                            f.sig.0.inputs.slice_from(1),\n+                            f.sig.0.output,\n                             f.abi)\n         }\n         _ => {\n@@ -515,7 +515,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// This will hopefully change now that DST is underway.\n pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               box_ty: Ty<'tcx>,\n-                              trait_ref: Rc<ty::TraitRef<'tcx>>)\n+                              trait_ref: Rc<ty::PolyTraitRef<'tcx>>)\n                               -> ValueRef\n {\n     debug!(\"get_vtable(box_ty={}, trait_ref={})\",\n@@ -670,7 +670,7 @@ fn emit_vtable_methods<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     datum: Datum<'tcx, Expr>,\n                                     id: ast::NodeId,\n-                                    trait_ref: Rc<ty::TraitRef<'tcx>>,\n+                                    trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n                                     dest: expr::Dest)\n                                     -> Block<'blk, 'tcx> {\n     let mut bcx = bcx;"}, {"sha": "aa6fd7f0b39417d1ec74bf32554b4d7f88579a40", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -146,16 +146,16 @@ pub fn type_of_fn_from_ty<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fty: Ty<'tcx>)\n         ty::ty_closure(ref f) => {\n             type_of_rust_fn(cx,\n                             Some(Type::i8p(cx)),\n-                            f.sig.inputs.as_slice(),\n-                            f.sig.output,\n+                            f.sig.0.inputs.as_slice(),\n+                            f.sig.0.output,\n                             f.abi)\n         }\n         ty::ty_bare_fn(ref f) => {\n             if f.abi == abi::Rust || f.abi == abi::RustCall {\n                 type_of_rust_fn(cx,\n                                 None,\n-                                f.sig.inputs.as_slice(),\n-                                f.sig.output,\n+                                f.sig.0.inputs.as_slice(),\n+                                f.sig.0.output,\n                                 f.abi)\n             } else {\n                 foreign::lltype_for_foreign_fn(cx, fty)"}, {"sha": "4f4bebabead2cf538ed1228faeb71adb8611dcbb", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 51, "deletions": 41, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -53,8 +53,7 @@ use middle::def;\n use middle::resolve_lifetime as rl;\n use middle::subst::{FnSpace, TypeSpace, AssocSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n-use middle::ty::{mod, Ty};\n-use middle::ty_fold;\n+use middle::ty::{mod, RegionEscape, Ty};\n use rscope::{mod, UnelidableRscope, RegionScope, SpecificRscope,\n              ShiftedRscope, BindingRscope};\n use TypeAndSubsts;\n@@ -524,6 +523,20 @@ fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n     vec![input_ty, output]\n }\n \n+pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n+    this: &AC,\n+    rscope: &RS,\n+    ast_trait_ref: &ast::PolyTraitRef,\n+    self_ty: Option<Ty<'tcx>>,\n+    allow_eq: AllowEqConstraints)\n+    -> Rc<ty::PolyTraitRef<'tcx>>\n+    where AC: AstConv<'tcx>, RS: RegionScope\n+{\n+    let trait_ref =\n+        instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty, allow_eq);\n+    let trait_ref = (*trait_ref).clone();\n+    Rc::new(ty::Binder(trait_ref)) // Ugh.\n+}\n \n /// Instantiates the path for the given trait reference, assuming that it's\n /// bound to a valid trait type. Returns the def_id for the defining trait.\n@@ -537,9 +550,7 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n                                          where AC: AstConv<'tcx>,\n                                                RS: RegionScope\n {\n-    match ::lookup_def_tcx(this.tcx(),\n-                           ast_trait_ref.path.span,\n-                           ast_trait_ref.ref_id) {\n+    match ::lookup_def_tcx(this.tcx(), ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => {\n             let trait_ref = Rc::new(ast_path_to_trait_ref(this,\n                                                           rscope,\n@@ -749,7 +760,7 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                    rscope: &RS,\n                                    ty: &ast::Ty,\n                                    bounds: &[ast::TyParamBound])\n-                                   -> Result<ty::TraitRef<'tcx>, ErrorReported>\n+                                   -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n     where AC : AstConv<'tcx>, RS : RegionScope\n {\n     /*!\n@@ -767,12 +778,12 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n         ast::TyPath(ref path, id) => {\n             match this.tcx().def_map.borrow().get(&id) {\n                 Some(&def::DefTrait(trait_def_id)) => {\n-                    return Ok(ast_path_to_trait_ref(this,\n-                                                    rscope,\n-                                                    trait_def_id,\n-                                                    None,\n-                                                    path,\n-                                                    AllowEqConstraints::Allow));\n+                    return Ok(ty::Binder(ast_path_to_trait_ref(this,\n+                                                               rscope,\n+                                                               trait_def_id,\n+                                                               None,\n+                                                               path,\n+                                                               AllowEqConstraints::Allow)));\n                 }\n                 _ => {\n                     span_err!(this.tcx().sess, ty.span, E0172, \"expected a reference to a trait\");\n@@ -814,7 +825,7 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n fn trait_ref_to_object_type<'tcx,AC,RS>(this: &AC,\n                                         rscope: &RS,\n                                         span: Span,\n-                                        trait_ref: ty::TraitRef<'tcx>,\n+                                        trait_ref: ty::PolyTraitRef<'tcx>,\n                                         bounds: &[ast::TyParamBound])\n                                         -> Ty<'tcx>\n     where AC : AstConv<'tcx>, RS : RegionScope\n@@ -982,12 +993,12 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     def::DefTrait(trait_def_id) => {\n                         // N.B. this case overlaps somewhat with\n                         // TyObjectSum, see that fn for details\n-                        let result = ast_path_to_trait_ref(this,\n-                                                           rscope,\n-                                                           trait_def_id,\n-                                                           None,\n-                                                           path,\n-                                                           AllowEqConstraints::Allow);\n+                        let result = ty::Binder(ast_path_to_trait_ref(this,\n+                                                                      rscope,\n+                                                                      trait_def_id,\n+                                                                      None,\n+                                                                      path,\n+                                                                      AllowEqConstraints::Allow));\n                         trait_ref_to_object_type(this, rscope, path.span, result, &[])\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n@@ -1039,7 +1050,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                 let ty_param_defs = tcx.ty_param_defs.borrow();\n                                 let tp_def = &(*ty_param_defs)[did.node];\n                                 let assoc_tys = tp_def.bounds.trait_bounds.iter()\n-                                    .filter_map(|b| find_assoc_ty(this, &**b, assoc_ident))\n+                                    .filter_map(|b| find_assoc_ty(this, &b.0, assoc_ident))\n                                     .collect();\n                                 (assoc_tys, token::get_name(tp_def.name).to_string())\n                             }\n@@ -1189,10 +1200,9 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n     let (self_ty, mut implied_output_region) = match opt_self_info {\n         None => (None, None),\n         Some(self_info) => {\n-            // Shift regions in the self type by 1 to account for the binding\n-            // level introduced by the function itself.\n-            let untransformed_self_ty =\n-                ty_fold::shift_regions(this.tcx(), 1, &self_info.untransformed_self_ty);\n+            // This type comes from an impl or trait; no late-bound\n+            // regions should be present.\n+            assert!(!self_info.untransformed_self_ty.has_escaping_regions());\n \n             // Figure out and record the explicit self category.\n             let explicit_self_category =\n@@ -1203,19 +1213,19 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n                     (None, None)\n                 }\n                 ty::ByValueExplicitSelfCategory => {\n-                    (Some(untransformed_self_ty), None)\n+                    (Some(self_info.untransformed_self_ty), None)\n                 }\n                 ty::ByReferenceExplicitSelfCategory(region, mutability) => {\n                     (Some(ty::mk_rptr(this.tcx(),\n                                       region,\n                                       ty::mt {\n-                                        ty: untransformed_self_ty,\n+                                        ty: self_info.untransformed_self_ty,\n                                         mutbl: mutability\n                                       })),\n                      Some(region))\n                 }\n                 ty::ByBoxExplicitSelfCategory => {\n-                    (Some(ty::mk_uniq(this.tcx(), untransformed_self_ty)), None)\n+                    (Some(ty::mk_uniq(this.tcx(), self_info.untransformed_self_ty)), None)\n                 }\n             }\n         }\n@@ -1267,11 +1277,11 @@ fn ty_of_method_or_bare_fn<'a, 'tcx, AC: AstConv<'tcx>>(\n     (ty::BareFnTy {\n         unsafety: unsafety,\n         abi: abi,\n-        sig: ty::FnSig {\n+        sig: ty::Binder(ty::FnSig {\n             inputs: self_and_input_tys,\n             output: output_ty,\n             variadic: decl.variadic\n-        }\n+        }),\n     }, explicit_self_category_result)\n }\n \n@@ -1409,9 +1419,9 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n         store: store,\n         bounds: bounds,\n         abi: abi,\n-        sig: ty::FnSig {inputs: input_tys,\n-                        output: output_ty,\n-                        variadic: decl.variadic}\n+        sig: ty::Binder(ty::FnSig {inputs: input_tys,\n+                                   output: output_ty,\n+                                   variadic: decl.variadic}),\n     }\n }\n \n@@ -1423,7 +1433,7 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    principal_trait_ref: Option<&ty::TraitRef<'tcx>>, // None for boxed closures\n+    principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>, // None for boxed closures\n     ast_bounds: &[ast::TyParamBound])\n     -> ty::ExistentialBounds\n {\n@@ -1450,11 +1460,11 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n \n     let main_trait_bound = match partitioned_bounds.trait_bounds.remove(0) {\n         Some(trait_bound) => {\n-            Some(instantiate_trait_ref(this,\n-                                       rscope,\n-                                       &trait_bound.trait_ref,\n-                                       None,\n-                                       AllowEqConstraints::Allow))\n+            Some(instantiate_poly_trait_ref(this,\n+                                            rscope,\n+                                            trait_bound,\n+                                            None,\n+                                            AllowEqConstraints::Allow))\n         }\n         None => {\n             this.tcx().sess.span_err(\n@@ -1481,7 +1491,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n     this: &AC,\n     rscope: &RS,\n     span: Span,\n-    principal_trait_ref: Option<&ty::TraitRef<'tcx>>, // None for boxed closures\n+    principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>, // None for boxed closures\n     partitioned_bounds: PartitionedBounds)\n     -> ty::ExistentialBounds\n     where AC: AstConv<'tcx>, RS:RegionScope\n@@ -1519,7 +1529,7 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                   span: Span,\n                                   explicit_region_bounds: &[&ast::Lifetime],\n-                                  principal_trait_ref: Option<&ty::TraitRef<'tcx>>,\n+                                  principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>,\n                                   builtin_bounds: ty::BuiltinBounds)\n                                   -> Option<ty::Region>\n {\n@@ -1579,7 +1589,7 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     rscope: &RS,\n     span: Span,\n     region_bounds: &[&ast::Lifetime],\n-    principal_trait_ref: Option<&ty::TraitRef<'tcx>>, // None for closures\n+    principal_trait_ref: Option<&ty::PolyTraitRef<'tcx>>, // None for closures\n     builtin_bounds: ty::BuiltinBounds)\n     -> ty::Region\n {"}, {"sha": "44cc5fce53da35c81c0f118e2eff0b7382f2324f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::def;\n-use middle::infer::{mod, resolve};\n+use middle::infer;\n use middle::pat_util::{PatIdMap, pat_id_map, pat_is_binding, pat_is_const};\n use middle::subst::{Subst, Substs};\n use middle::ty::{mod, Ty};\n@@ -18,6 +18,7 @@ use check::{check_expr_coercable_to_type, demand, FnCtxt, Expectation};\n use check::{instantiate_path, structurally_resolved_type, valid_range_bounds};\n use require_same_types;\n use util::nodemap::FnvHashMap;\n+use util::ppaux::Repr;\n \n use std::cmp;\n use std::collections::hash_map::{Occupied, Vacant};\n@@ -33,6 +34,10 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n+    debug!(\"check_pat(pat={},expected={})\",\n+           pat.repr(tcx),\n+           expected.repr(tcx));\n+\n     match pat.node {\n         ast::PatWild(_) => {\n             fcx.write_ty(pat.id, expected);\n@@ -143,11 +148,8 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         ast::PatRegion(ref inner) => {\n             let inner_ty = fcx.infcx().next_ty_var();\n \n-            let mutbl = infer::resolve_type(\n-                fcx.infcx(), Some(pat.span),\n-                expected, resolve::try_resolve_tvar_shallow)\n-                .ok()\n-                .and_then(|t| ty::deref(t, true))\n+            let mutbl =\n+                ty::deref(fcx.infcx().shallow_resolve(expected), true)\n                 .map_or(ast::MutImmutable, |mt| mt.mutbl);\n \n             let mt = ty::mt { ty: inner_ty, mutbl: mutbl };\n@@ -214,23 +216,21 @@ pub fn check_dereferencable<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n                                       inner: &ast::Pat) -> bool {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n-    match infer::resolve_type(\n-        fcx.infcx(), Some(span),\n-        expected, resolve::try_resolve_tvar_shallow) {\n-        Ok(t) if pat_is_binding(&tcx.def_map, inner) => {\n-            ty::deref(t, true).map_or(true, |mt| match mt.ty.sty {\n-                ty::ty_trait(_) => {\n-                    // This is \"x = SomeTrait\" being reduced from\n-                    // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n-                    span_err!(tcx.sess, span, E0033,\n-                        \"type `{}` cannot be dereferenced\",\n-                        fcx.infcx().ty_to_string(t));\n-                    false\n-                }\n-                _ => true\n-            })\n-        }\n-        _ => true\n+    if pat_is_binding(&tcx.def_map, inner) {\n+        let expected = fcx.infcx().shallow_resolve(expected);\n+        ty::deref(expected, true).map_or(true, |mt| match mt.ty.sty {\n+            ty::ty_trait(_) => {\n+                // This is \"x = SomeTrait\" being reduced from\n+                // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n+                span_err!(tcx.sess, span, E0033,\n+                          \"type `{}` cannot be dereferenced\",\n+                          fcx.infcx().ty_to_string(expected));\n+                false\n+            }\n+            _ => true\n+        })\n+    } else {\n+        true\n     }\n }\n "}, {"sha": "2ade3040d6cff52e4b8382ce47c447b09bca0da8", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -129,7 +129,7 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n     // Tuple up the arguments and insert the resulting function type into\n     // the `unboxed_closures` table.\n-    fn_ty.sig.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.inputs)];\n+    fn_ty.sig.0.inputs = vec![ty::mk_tup(fcx.tcx(), fn_ty.sig.0.inputs)];\n \n     debug!(\"unboxed_closure for {} --> sig={} kind={}\",\n            expr_def_id.repr(fcx.tcx()),\n@@ -180,23 +180,23 @@ fn deduce_unboxed_closure_expectations_from_expected_type<'a,'tcx>(\n \n fn deduce_unboxed_closure_expectations_from_trait_ref<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n-    trait_ref: &ty::TraitRef<'tcx>)\n+    trait_ref: &ty::PolyTraitRef<'tcx>)\n     -> Option<(ty::FnSig<'tcx>, ty::UnboxedClosureKind)>\n {\n     let tcx = fcx.tcx();\n \n     debug!(\"deduce_unboxed_closure_expectations_from_object_type({})\",\n            trait_ref.repr(tcx));\n \n-    let kind = match tcx.lang_items.fn_trait_kind(trait_ref.def_id) {\n+    let kind = match tcx.lang_items.fn_trait_kind(trait_ref.def_id()) {\n         Some(k) => k,\n         None => { return None; }\n     };\n \n     debug!(\"found object type {}\", kind);\n \n-    let arg_param_ty = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n-    let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(arg_param_ty);\n+    let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n+    let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(&arg_param_ty);\n     debug!(\"arg_param_ty {}\", arg_param_ty.repr(tcx));\n \n     let input_tys = match arg_param_ty.sty {\n@@ -205,8 +205,8 @@ fn deduce_unboxed_closure_expectations_from_trait_ref<'a,'tcx>(\n     };\n     debug!(\"input_tys {}\", input_tys.repr(tcx));\n \n-    let ret_param_ty = *trait_ref.substs.types.get(subst::TypeSpace, 1);\n-    let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(ret_param_ty);\n+    let ret_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 1);\n+    let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n     debug!(\"ret_param_ty {}\", ret_param_ty.repr(tcx));\n \n     let fn_sig = ty::FnSig {"}, {"sha": "9af9eaf75f5a516927815c585297fde3b24c6ea2", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -12,8 +12,6 @@\n use check::FnCtxt;\n use middle::ty::{mod, Ty};\n use middle::infer;\n-use middle::infer::resolve_type;\n-use middle::infer::resolve::try_resolve_tvar_shallow;\n \n use std::result::Result::{Err, Ok};\n use syntax::ast;\n@@ -63,12 +61,7 @@ pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n     debug!(\"demand::coerce(expected = {}, expr_ty = {})\",\n            expected.repr(fcx.ccx.tcx),\n            expr_ty.repr(fcx.ccx.tcx));\n-    let expected = if ty::type_needs_infer(expected) {\n-        resolve_type(fcx.infcx(),\n-                     None,\n-                     expected,\n-                     try_resolve_tvar_shallow).unwrap_or(expected)\n-    } else { expected };\n+    let expected = fcx.infcx().resolve_type_vars_if_possible(&expected);\n     match fcx.mk_assignty(expr, expr_ty, expected) {\n       Ok(()) => { /* ok */ }\n       Err(ref err) => {"}, {"sha": "2c220f298262fdb40d603809c818da0ae8e31f0a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 31, "deletions": 41, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -16,9 +16,9 @@ use middle::traits;\n use middle::ty::{mod, Ty};\n use middle::ty::{MethodCall, MethodCallee, MethodObject, MethodOrigin,\n                  MethodParam, MethodStatic, MethodTraitObject, MethodTypeParam};\n+use middle::ty_fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n-use middle::ty_fold::HigherRankedFoldable;\n use syntax::ast;\n use syntax::codemap::Span;\n use std::rc::Rc;\n@@ -114,7 +114,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // Create the final `MethodCallee`.\n         let fty = ty::mk_bare_fn(self.tcx(), ty::BareFnTy {\n-            sig: method_sig,\n+            sig: ty::Binder(method_sig),\n             unsafety: pick.method_ty.fty.unsafety,\n             abi: pick.method_ty.fty.abi.clone(),\n         });\n@@ -222,17 +222,19 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     // argument type), but those cases have already\n                     // been ruled out when we deemed the trait to be\n                     // \"object safe\".\n-                    let substs = data.principal.substs.clone().with_self_ty(object_ty);\n-                    let original_trait_ref =\n-                        Rc::new(ty::TraitRef::new(data.principal.def_id, substs));\n-                    let upcast_trait_ref = this.upcast(original_trait_ref.clone(), trait_def_id);\n-                    debug!(\"original_trait_ref={} upcast_trait_ref={} target_trait={}\",\n-                           original_trait_ref.repr(this.tcx()),\n+                    let original_poly_trait_ref =\n+                        data.principal_trait_ref_with_self_ty(object_ty);\n+                    let upcast_poly_trait_ref =\n+                        this.upcast(original_poly_trait_ref.clone(), trait_def_id);\n+                    let upcast_trait_ref =\n+                        this.replace_late_bound_regions_with_fresh_var(&*upcast_poly_trait_ref);\n+                    debug!(\"original_poly_trait_ref={} upcast_trait_ref={} target_trait={}\",\n+                           original_poly_trait_ref.repr(this.tcx()),\n                            upcast_trait_ref.repr(this.tcx()),\n                            trait_def_id.repr(this.tcx()));\n                     let substs = upcast_trait_ref.substs.clone();\n                     let origin = MethodTraitObject(MethodObject {\n-                        trait_ref: upcast_trait_ref,\n+                        trait_ref: Rc::new(upcast_trait_ref),\n                         object_trait_id: trait_def_id,\n                         method_num: method_num,\n                         real_index: real_index,\n@@ -272,16 +274,21 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                                                  &trait_def.generics,\n                                                                  self.infcx().next_ty_var());\n \n-                let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs.clone()));\n+                let trait_ref =\n+                    Rc::new(ty::TraitRef::new(trait_def_id, substs.clone()));\n                 let origin = MethodTypeParam(MethodParam { trait_ref: trait_ref,\n                                                            method_num: method_num });\n                 (substs, origin)\n             }\n \n-            probe::WhereClausePick(ref trait_ref, method_num) => {\n-                let origin = MethodTypeParam(MethodParam { trait_ref: (*trait_ref).clone(),\n+            probe::WhereClausePick(ref poly_trait_ref, method_num) => {\n+                // Where clauses can have bound regions in them. We need to instantiate\n+                // those to convert from a poly-trait-ref to a trait-ref.\n+                let trait_ref = self.replace_late_bound_regions_with_fresh_var(&**poly_trait_ref);\n+                let substs = trait_ref.substs.clone();\n+                let origin = MethodTypeParam(MethodParam { trait_ref: Rc::new(trait_ref),\n                                                            method_num: method_num });\n-                (trait_ref.substs.clone(), origin)\n+                (substs, origin)\n             }\n         }\n     }\n@@ -378,25 +385,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                               all_substs: subst::Substs<'tcx>)\n                               -> InstantiatedMethodSig<'tcx>\n     {\n-        // If this method comes from an impl (as opposed to a trait),\n-        // it may have late-bound regions from the impl that appear in\n-        // the substitutions, method signature, and\n-        // bounds. Instantiate those at this point. (If it comes from\n-        // a trait, this step has no effect, as there are no\n-        // late-bound regions to instantiate.)\n-        //\n-        // The binder level here corresponds to the impl.\n-        let (all_substs, (method_sig, method_generics)) =\n-            self.replace_late_bound_regions_with_fresh_var(\n-                &ty::bind((all_substs,\n-                           (pick.method_ty.fty.sig.clone(),\n-                            pick.method_ty.generics.clone())))).value;\n-\n-        debug!(\"late-bound lifetimes from impl instantiated, \\\n-                all_substs={} method_sig={} method_generics={}\",\n-               all_substs.repr(self.tcx()),\n-               method_sig.repr(self.tcx()),\n-               method_generics.repr(self.tcx()));\n+        debug!(\"instantiate_method_sig(pick={}, all_substs={})\",\n+               pick.repr(self.tcx()),\n+               all_substs.repr(self.tcx()));\n \n         // Instantiate the bounds on the method with the\n         // type/early-bound-regions substitutions performed.  The only\n@@ -426,16 +417,15 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 all_substs.clone()\n             }\n         };\n-        let method_bounds =\n-            method_generics.to_bounds(self.tcx(), &method_bounds_substs);\n+        let method_bounds = pick.method_ty.generics.to_bounds(self.tcx(), &method_bounds_substs);\n \n         debug!(\"method_bounds after subst = {}\",\n                method_bounds.repr(self.tcx()));\n \n         // Substitute the type/early-bound-regions into the method\n         // signature. In addition, the method signature may bind\n         // late-bound regions, so instantiate those.\n-        let method_sig = method_sig.subst(self.tcx(), &all_substs);\n+        let method_sig = pick.method_ty.fty.sig.subst(self.tcx(), &all_substs);\n         let method_sig = self.replace_late_bound_regions_with_fresh_var(&method_sig);\n \n         debug!(\"late-bound lifetimes from method instantiated, method_sig={}\",\n@@ -481,7 +471,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             _ => return,\n         };\n \n-        match sig.inputs[0].sty {\n+        match sig.0.inputs[0].sty {\n             ty::ty_rptr(_, ty::mt {\n                 ty: _,\n                 mutbl: ast::MutMutable,\n@@ -637,12 +627,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n     }\n \n     fn upcast(&mut self,\n-              source_trait_ref: Rc<ty::TraitRef<'tcx>>,\n+              source_trait_ref: Rc<ty::PolyTraitRef<'tcx>>,\n               target_trait_def_id: ast::DefId)\n-              -> Rc<ty::TraitRef<'tcx>>\n+              -> Rc<ty::PolyTraitRef<'tcx>>\n     {\n         for super_trait_ref in traits::supertraits(self.tcx(), source_trait_ref.clone()) {\n-            if super_trait_ref.def_id == target_trait_def_id {\n+            if super_trait_ref.def_id() == target_trait_def_id {\n                 return super_trait_ref;\n             }\n         }\n@@ -654,8 +644,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     target_trait_def_id.repr(self.tcx()))[]);\n     }\n \n-    fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &T) -> T\n-        where T : HigherRankedFoldable<'tcx>\n+    fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &ty::Binder<T>) -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx>\n     {\n         self.infcx().replace_late_bound_regions_with_fresh_var(\n             self.span, infer::FnCall, value).0"}, {"sha": "ffaeceb3eed11a84111fb991ebfd02f9120f6f03", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -100,7 +100,7 @@ pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            call_expr.repr(fcx.tcx()),\n            self_expr.repr(fcx.tcx()));\n \n-    let self_ty = fcx.infcx().resolve_type_vars_if_possible(self_ty);\n+    let self_ty = fcx.infcx().resolve_type_vars_if_possible(&self_ty);\n     let pick = try!(probe::probe(fcx, span, method_name, self_ty, call_expr.id));\n     Ok(confirm::confirm(fcx, span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n }\n@@ -169,9 +169,10 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n \n     // Construct an obligation\n+    let poly_trait_ref = Rc::new(ty::Binder((*trait_ref).clone()));\n     let obligation = traits::Obligation::misc(span,\n                                               fcx.body_id,\n-                                              ty::Predicate::Trait(trait_ref.clone()));\n+                                              poly_trait_ref.as_predicate());\n \n     // Now we want to know if this can be matched\n     let mut selcx = traits::SelectionContext::new(fcx.infcx(),\n@@ -194,17 +195,14 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n     // Substitute the trait parameters into the method type and\n     // instantiate late-bound regions to get the actual method type.\n-    //\n-    // Note that as the method comes from a trait, it can only have\n-    // late-bound regions from the fn itself, not the impl.\n     let ref bare_fn_ty = method_ty.fty;\n     let fn_sig = bare_fn_ty.sig.subst(tcx, &trait_ref.substs);\n     let fn_sig = fcx.infcx().replace_late_bound_regions_with_fresh_var(span,\n                                                                        infer::FnCall,\n                                                                        &fn_sig).0;\n     let transformed_self_ty = fn_sig.inputs[0];\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n-        sig: fn_sig,\n+        sig: ty::Binder(fn_sig),\n         unsafety: bare_fn_ty.unsafety,\n         abi: bare_fn_ty.abi.clone(),\n     });"}, {"sha": "b5776f9aeb34ac158fece9de0fd969014ac8d620", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 52, "deletions": 65, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -19,8 +19,7 @@ use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n use middle::ty::{mod, Ty};\n-use middle::ty::{MethodObject};\n-use middle::ty_fold::HigherRankedFoldable;\n+use middle::ty_fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n use syntax::ast;\n@@ -58,11 +57,11 @@ struct Candidate<'tcx> {\n \n enum CandidateKind<'tcx> {\n     InherentImplCandidate(/* Impl */ ast::DefId, subst::Substs<'tcx>),\n-    ObjectCandidate(MethodObject<'tcx>),\n+    ObjectCandidate(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n     ExtensionImplCandidate(/* Impl */ ast::DefId, Rc<ty::TraitRef<'tcx>>,\n                            subst::Substs<'tcx>, MethodIndex),\n     UnboxedClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClauseCandidate(Rc<ty::TraitRef<'tcx>>, MethodIndex),\n+    WhereClauseCandidate(Rc<ty::PolyTraitRef<'tcx>>, MethodIndex),\n }\n \n pub struct Pick<'tcx> {\n@@ -77,7 +76,7 @@ pub enum PickKind<'tcx> {\n     ObjectPick(/* Trait */ ast::DefId, /* method_num */ uint, /* real_index */ uint),\n     ExtensionImplPick(/* Impl */ ast::DefId, MethodIndex),\n     TraitPick(/* Trait */ ast::DefId, MethodIndex),\n-    WhereClausePick(/* Trait */ Rc<ty::TraitRef<'tcx>>, MethodIndex),\n+    WhereClausePick(/* Trait */ Rc<ty::PolyTraitRef<'tcx>>, MethodIndex),\n }\n \n pub type PickResult<'tcx> = Result<Pick<'tcx>, MethodError>;\n@@ -149,7 +148,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // this creates one big transaction so that all type variables etc\n     // that we create during the probe process are removed later\n     let mut dummy = Some((steps, opt_simplified_steps)); // FIXME(#18101) need once closures\n-    fcx.infcx().probe(|| {\n+    fcx.infcx().probe(|_| {\n         let (steps, opt_simplified_steps) = dummy.take().unwrap();\n         let mut probe_cx = ProbeContext::new(fcx, span, method_name, steps, opt_simplified_steps);\n         probe_cx.assemble_inherent_candidates();\n@@ -231,9 +230,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                self_ty.repr(self.tcx()));\n \n         match self_ty.sty {\n-            ty::ty_trait(box ty::TyTrait { ref principal, bounds, .. }) => {\n-                self.assemble_inherent_candidates_from_object(self_ty, &*principal, bounds);\n-                self.assemble_inherent_impl_candidates_for_type(principal.def_id);\n+            ty::ty_trait(box ref data) => {\n+                self.assemble_inherent_candidates_from_object(self_ty, data);\n+                self.assemble_inherent_impl_candidates_for_type(data.principal.def_id());\n             }\n             ty::ty_enum(did, _) |\n             ty::ty_struct(did, _) |\n@@ -290,8 +289,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n     fn assemble_inherent_candidates_from_object(&mut self,\n                                                 self_ty: Ty<'tcx>,\n-                                                principal: &ty::TraitRef<'tcx>,\n-                                                _bounds: ty::ExistentialBounds) {\n+                                                data: &ty::TyTrait<'tcx>) {\n         debug!(\"assemble_inherent_candidates_from_object(self_ty={})\",\n                self_ty.repr(self.tcx()));\n \n@@ -304,29 +302,17 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // a substitution that replaces `Self` with the object type\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n-        let rcvr_substs = principal.substs.clone().with_self_ty(self_ty);\n-        let trait_ref = Rc::new(ty::TraitRef {\n-            def_id: principal.def_id,\n-            substs: rcvr_substs.clone()\n-        });\n-\n+        let trait_ref = data.principal_trait_ref_with_self_ty(self_ty);\n         self.elaborate_bounds(&[trait_ref.clone()], false, |this, new_trait_ref, m, method_num| {\n             let vtable_index =\n-                get_method_index(tcx, &*new_trait_ref,\n-                                 trait_ref.clone(), method_num);\n+                get_method_index(tcx, &*new_trait_ref, trait_ref.clone(), method_num);\n \n-            let xform_self_ty =\n-                this.xform_self_ty(&m, &new_trait_ref.substs);\n+            let xform_self_ty = this.xform_self_ty(&m, new_trait_ref.substs());\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 method_ty: m,\n-                kind: ObjectCandidate(MethodObject {\n-                    trait_ref: new_trait_ref,\n-                    object_trait_id: principal.def_id,\n-                    method_num: method_num,\n-                    real_index: vtable_index\n-                })\n+                kind: ObjectCandidate(new_trait_ref.def_id(), method_num, vtable_index)\n             });\n         });\n     }\n@@ -358,27 +344,27 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n         self.elaborate_bounds(bounds.as_slice(), true, |this, trait_ref, m, method_num| {\n             let xform_self_ty =\n-                this.xform_self_ty(&m, &trait_ref.substs);\n+                this.xform_self_ty(&m, trait_ref.substs());\n \n             debug!(\"found match: trait_ref={} substs={} m={}\",\n                    trait_ref.repr(this.tcx()),\n-                   trait_ref.substs.repr(this.tcx()),\n+                   trait_ref.substs().repr(this.tcx()),\n                    m.repr(this.tcx()));\n             assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n-                       trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n+                       trait_ref.substs().types.get_slice(subst::TypeSpace).len());\n             assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n-                       trait_ref.substs.regions().get_slice(subst::TypeSpace).len());\n+                       trait_ref.substs().regions().get_slice(subst::TypeSpace).len());\n             assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n-                       trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n+                       trait_ref.substs().types.get_slice(subst::SelfSpace).len());\n             assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n-                       trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n+                       trait_ref.substs().regions().get_slice(subst::SelfSpace).len());\n \n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n             // artifacts. This means it is safe to put into the\n             // `WhereClauseCandidate` and (eventually) into the\n             // `WhereClausePick`.\n-            assert!(trait_ref.substs.types.iter().all(|&t| !ty::type_needs_infer(t)));\n+            assert!(trait_ref.substs().types.iter().all(|&t| !ty::type_needs_infer(t)));\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n@@ -392,10 +378,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     // create the candidates.\n     fn elaborate_bounds(\n         &mut self,\n-        bounds: &[Rc<ty::TraitRef<'tcx>>],\n+        bounds: &[Rc<ty::PolyTraitRef<'tcx>>],\n         num_includes_types: bool,\n         mk_cand: for<'b> |this: &mut ProbeContext<'b, 'tcx>,\n-                          tr: Rc<ty::TraitRef<'tcx>>,\n+                          tr: Rc<ty::PolyTraitRef<'tcx>>,\n                           m: Rc<ty::Method<'tcx>>,\n                           method_num: uint|)\n     {\n@@ -405,20 +391,20 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let mut cache = HashSet::new();\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n             // Already visited this trait, skip it.\n-            if !cache.insert(bound_trait_ref.def_id) {\n+            if !cache.insert(bound_trait_ref.def_id()) {\n                 continue;\n             }\n \n             let (pos, method) = match trait_method(tcx,\n-                                                   bound_trait_ref.def_id,\n+                                                   bound_trait_ref.def_id(),\n                                                    self.method_name,\n                                                    num_includes_types) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n \n             if !self.has_applicable_self(&*method) {\n-                self.record_static_candidate(TraitSource(bound_trait_ref.def_id));\n+                self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n             } else {\n                 mk_cand(self, bound_trait_ref, method, pos);\n             }\n@@ -756,7 +742,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                self_ty.repr(self.tcx()),\n                probe.repr(self.tcx()));\n \n-        self.infcx().probe(|| {\n+        self.infcx().probe(|_| {\n             // First check that the self type can be related.\n             match self.make_sub_ty(self_ty, probe.xform_self_ty) {\n                 Ok(()) => { }\n@@ -779,7 +765,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n \n                     // Erase any late-bound regions bound in the impl\n                     // which appear in the bounds.\n-                    let impl_bounds = self.erase_late_bound_regions(&ty::bind(impl_bounds)).value;\n+                    let impl_bounds = self.erase_late_bound_regions(&ty::Binder(impl_bounds));\n \n                     // Convert the bounds into obligations.\n                     let obligations =\n@@ -881,9 +867,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn xform_self_ty(&self,\n                      method: &Rc<ty::Method<'tcx>>,\n                      substs: &subst::Substs<'tcx>)\n-                     -> Ty<'tcx> {\n+                     -> Ty<'tcx>\n+    {\n         debug!(\"xform_self_ty(self_ty={}, substs={})\",\n-               method.fty.sig.inputs[0].repr(self.tcx()),\n+               method.fty.sig.0.inputs[0].repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n         // It is possible for type parameters or early-bound lifetimes\n@@ -916,15 +903,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n \n         // Replace early-bound regions and types.\n-        let xform_self_ty = method.fty.sig.inputs[0].subst(self.tcx(), substs);\n+        let xform_self_ty = method.fty.sig.0.inputs[0].subst(self.tcx(), substs);\n \n         // Replace late-bound regions bound in the impl or\n-        // where-clause (2 levels of binding).\n-        let xform_self_ty =\n-            self.erase_late_bound_regions(&ty::bind(ty::bind(xform_self_ty))).value.value;\n-\n-        // Replace late-bound regions bound in the method (1 level of binding).\n-        self.erase_late_bound_regions(&ty::bind(xform_self_ty)).value\n+        // where-clause (2 levels of binding) and method (1 level of binding).\n+        self.erase_late_bound_regions(\n+            &self.erase_late_bound_regions(\n+                &ty::Binder(ty::Binder(xform_self_ty))))\n     }\n \n     fn impl_substs(&self,\n@@ -962,8 +947,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     ///    region got replaced with the same variable, which requires a bit more coordination\n     ///    and/or tracking the substitution and\n     ///    so forth.\n-    fn erase_late_bound_regions<T>(&self, value: &T) -> T\n-        where T : HigherRankedFoldable<'tcx>\n+    fn erase_late_bound_regions<T>(&self, value: &ty::Binder<T>) -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx>\n     {\n         ty::erase_late_bound_regions(self.tcx(), value)\n     }\n@@ -1007,8 +992,8 @@ fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n // Determine the index of a method in the list of all methods belonging\n // to a trait and its supertraits.\n fn get_method_index<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                          trait_ref: &ty::TraitRef<'tcx>,\n-                          subtrait: Rc<ty::TraitRef<'tcx>>,\n+                          trait_ref: &ty::PolyTraitRef<'tcx>,\n+                          subtrait: Rc<ty::PolyTraitRef<'tcx>>,\n                           n_method: uint) -> uint {\n     // We need to figure the \"real index\" of the method in a\n     // listing of all the methods of an object. We do this by\n@@ -1017,10 +1002,10 @@ fn get_method_index<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // methods from them.\n     let mut method_count = n_method;\n     ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n-        if bound_ref.def_id == trait_ref.def_id {\n+        if bound_ref.def_id() == trait_ref.def_id() {\n             false\n         } else {\n-            let trait_items = ty::trait_items(tcx, bound_ref.def_id);\n+            let trait_items = ty::trait_items(tcx, bound_ref.def_id());\n             for trait_item in trait_items.iter() {\n                 match *trait_item {\n                     ty::MethodTraitItem(_) => method_count += 1,\n@@ -1042,8 +1027,8 @@ impl<'tcx> Candidate<'tcx> {\n                 InherentImplCandidate(def_id, _) => {\n                     InherentImplPick(def_id)\n                 }\n-                ObjectCandidate(ref data) => {\n-                    ObjectPick(data.trait_ref.def_id, data.method_num, data.real_index)\n+                ObjectCandidate(def_id, method_num, real_index) => {\n+                    ObjectPick(def_id, method_num, real_index)\n                 }\n                 ExtensionImplCandidate(def_id, _, _, index) => {\n                     ExtensionImplPick(def_id, index)\n@@ -1057,7 +1042,7 @@ impl<'tcx> Candidate<'tcx> {\n                     // inference variables or other artifacts. This\n                     // means they are safe to put into the\n                     // `WhereClausePick`.\n-                    assert!(trait_ref.substs.types.iter().all(|&t| !ty::type_needs_infer(t)));\n+                    assert!(trait_ref.substs().types.iter().all(|&t| !ty::type_needs_infer(t)));\n \n                     WhereClausePick((*trait_ref).clone(), index)\n                 }\n@@ -1068,10 +1053,10 @@ impl<'tcx> Candidate<'tcx> {\n     fn to_source(&self) -> CandidateSource {\n         match self.kind {\n             InherentImplCandidate(def_id, _) => ImplSource(def_id),\n-            ObjectCandidate(ref obj) => TraitSource(obj.trait_ref.def_id),\n+            ObjectCandidate(def_id, _, _) => TraitSource(def_id),\n             ExtensionImplCandidate(def_id, _, _, _) => ImplSource(def_id),\n             UnboxedClosureCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n-            WhereClauseCandidate(ref trait_ref, _) => TraitSource(trait_ref.def_id),\n+            WhereClauseCandidate(ref trait_ref, _) => TraitSource(trait_ref.def_id()),\n         }\n     }\n \n@@ -1084,10 +1069,12 @@ impl<'tcx> Candidate<'tcx> {\n             UnboxedClosureCandidate(trait_def_id, method_num) => {\n                 Some((trait_def_id, method_num))\n             }\n-            ExtensionImplCandidate(_, ref trait_ref, _, method_num) |\n-            WhereClauseCandidate(ref trait_ref, method_num) => {\n+            ExtensionImplCandidate(_, ref trait_ref, _, method_num) => {\n                 Some((trait_ref.def_id, method_num))\n             }\n+            WhereClauseCandidate(ref trait_ref, method_num) => {\n+                Some((trait_ref.def_id(), method_num))\n+            }\n         }\n     }\n }\n@@ -1105,8 +1092,8 @@ impl<'tcx> Repr<'tcx> for CandidateKind<'tcx> {\n         match *self {\n             InherentImplCandidate(ref a, ref b) =>\n                 format!(\"InherentImplCandidate({},{})\", a.repr(tcx), b.repr(tcx)),\n-            ObjectCandidate(ref a) =>\n-                format!(\"ObjectCandidate({})\", a.repr(tcx)),\n+            ObjectCandidate(a, b, c) =>\n+                format!(\"ObjectCandidate({},{},{})\", a.repr(tcx), b, c),\n             ExtensionImplCandidate(ref a, ref b, ref c, ref d) =>\n                 format!(\"ExtensionImplCandidate({},{},{},{})\", a.repr(tcx), b.repr(tcx),\n                         c.repr(tcx), d),"}, {"sha": "9e249cc449d0749b66be3bcade9d01d55f3313bf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 61, "deletions": 133, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -506,7 +506,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for GatherLocalsVisitor<'a, 'tcx> {\n fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n                       unsafety: ast::Unsafety,\n                       unsafety_id: ast::NodeId,\n-                      fn_sig: &ty::FnSig<'tcx>,\n+                      fn_sig: &ty::PolyFnSig<'tcx>,\n                       decl: &ast::FnDecl,\n                       fn_id: ast::NodeId,\n                       body: &ast::Block,\n@@ -625,23 +625,20 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n         let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n         check_bare_fn(ccx, &**decl, &**body, it.id, fn_pty.ty, param_env);\n       }\n-      ast::ItemImpl(_, _, ref opt_trait_ref, _, ref impl_items) => {\n+      ast::ItemImpl(_, _, _, _, ref impl_items) => {\n         debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n \n         let impl_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n \n-        match *opt_trait_ref {\n-            Some(ref ast_trait_ref) => {\n-                let impl_trait_ref =\n-                    ty::node_id_to_trait_ref(ccx.tcx, ast_trait_ref.ref_id);\n+          match ty::impl_trait_ref(ccx.tcx, local_def(it.id)) {\n+              Some(impl_trait_ref) => {\n                 check_impl_items_against_trait(ccx,\n                                                it.span,\n-                                               ast_trait_ref,\n                                                &*impl_trait_ref,\n                                                impl_items.as_slice());\n-            }\n-            None => { }\n-        }\n+              }\n+              None => { }\n+          }\n \n         for impl_item in impl_items.iter() {\n             match *impl_item {\n@@ -722,12 +719,7 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let param_env = ParameterEnvironment::for_item(ccx.tcx, method.id);\n \n     let fty = ty::node_id_to_type(ccx.tcx, method.id);\n-    debug!(\"fty (raw): {}\", fty.repr(ccx.tcx));\n-\n-    let body_id = method.pe_body().id;\n-    let fty = liberate_late_bound_regions(\n-        ccx.tcx, CodeExtent::from_node_id(body_id), &ty::bind(fty)).value;\n-    debug!(\"fty (liberated): {}\", fty.repr(ccx.tcx));\n+    debug!(\"check_method_body: fty={}\", fty.repr(ccx.tcx));\n \n     check_bare_fn(ccx,\n                   &*method.pe_fn_decl(),\n@@ -739,7 +731,6 @@ fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                             impl_span: Span,\n-                                            ast_trait_ref: &ast::TraitRef,\n                                             impl_trait_ref: &ty::TraitRef<'tcx>,\n                                             impl_items: &[ast::ImplItem]) {\n     // Locate trait methods\n@@ -772,21 +763,16 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                                     impl_method.span,\n                                                     impl_method.pe_body().id,\n                                                     &**trait_method_ty,\n-                                                    impl_trait_ref);\n+                                                    &*impl_trait_ref);\n                             }\n                             _ => {\n                                 // This is span_bug as it should have already been\n                                 // caught in resolve.\n-                                tcx.sess\n-                                   .span_bug(impl_method.span,\n-                                             format!(\"item `{}` is of a \\\n-                                                      different kind from \\\n-                                                      its trait `{}`\",\n-                                                     token::get_name(\n-                                                        impl_item_ty.name()),\n-                                                     pprust::path_to_string(\n-                                                        &ast_trait_ref.path))\n-                                             .as_slice());\n+                                tcx.sess.span_bug(\n+                                    impl_method.span,\n+                                    format!(\"item `{}` is of a different kind from its trait `{}`\",\n+                                            token::get_name(impl_item_ty.name()),\n+                                            impl_trait_ref.repr(tcx)).as_slice());\n                             }\n                         }\n                     }\n@@ -795,11 +781,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         // caught in resolve.\n                         tcx.sess.span_bug(\n                             impl_method.span,\n-                            format!(\n-                                \"method `{}` is not a member of trait `{}`\",\n-                                token::get_name(impl_item_ty.name()),\n-                                pprust::path_to_string(\n-                                    &ast_trait_ref.path)).as_slice());\n+                            format!(\"method `{}` is not a member of trait `{}`\",\n+                                    token::get_name(impl_item_ty.name()),\n+                                    impl_trait_ref.repr(tcx)).as_slice());\n                     }\n                 }\n             }\n@@ -812,27 +796,19 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 // corresponding type definition in the trait.\n                 let opt_associated_type =\n                     trait_items.iter()\n-                               .find(|ti| {\n-                                   ti.name() == typedef_ty.name()\n-                               });\n+                               .find(|ti| ti.name() == typedef_ty.name());\n                 match opt_associated_type {\n                     Some(associated_type) => {\n                         match (associated_type, &typedef_ty) {\n-                            (&ty::TypeTraitItem(_),\n-                             &ty::TypeTraitItem(_)) => {}\n+                            (&ty::TypeTraitItem(_), &ty::TypeTraitItem(_)) => {}\n                             _ => {\n                                 // This is `span_bug` as it should have\n                                 // already been caught in resolve.\n-                                tcx.sess\n-                                   .span_bug(typedef.span,\n-                                             format!(\"item `{}` is of a \\\n-                                                      different kind from \\\n-                                                      its trait `{}`\",\n-                                                     token::get_name(\n-                                                        typedef_ty.name()),\n-                                                     pprust::path_to_string(\n-                                                        &ast_trait_ref.path))\n-                                             .as_slice());\n+                                tcx.sess.span_bug(\n+                                    typedef.span,\n+                                    format!(\"item `{}` is of a different kind from its trait `{}`\",\n+                                            token::get_name(typedef_ty.name()),\n+                                            impl_trait_ref.repr(tcx)).as_slice());\n                             }\n                         }\n                     }\n@@ -845,17 +821,15 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 \"associated type `{}` is not a member of \\\n                                  trait `{}`\",\n                                 token::get_name(typedef_ty.name()),\n-                                pprust::path_to_string(\n-                                    &ast_trait_ref.path)).as_slice());\n+                                impl_trait_ref.repr(tcx)).as_slice());\n                     }\n                 }\n             }\n         }\n     }\n \n     // Check for missing items from trait\n-    let provided_methods = ty::provided_trait_methods(tcx,\n-                                                      impl_trait_ref.def_id);\n+    let provided_methods = ty::provided_trait_methods(tcx, impl_trait_ref.def_id);\n     let mut missing_methods = Vec::new();\n     for trait_item in trait_items.iter() {\n         match *trait_item {\n@@ -870,8 +844,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         }\n                     });\n                 let is_provided =\n-                    provided_methods.iter().any(\n-                        |m| m.name == trait_method.name);\n+                    provided_methods.iter().any(|m| m.name == trait_method.name);\n                 if !is_implemented && !is_provided {\n                     missing_methods.push(format!(\"`{}`\", token::get_name(trait_method.name)));\n                 }\n@@ -919,27 +892,6 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"compare_impl_method(impl_trait_ref={})\",\n            impl_trait_ref.repr(tcx));\n \n-    let impl_m_body_scope = CodeExtent::from_node_id(impl_m_body_id);\n-\n-    // The impl's trait ref may bind late-bound regions from the impl.\n-    // Liberate them and assign them the scope of the method body.\n-    //\n-    // An example would be:\n-    //\n-    //     impl<'a> Foo<&'a T> for &'a U { ... }\n-    //\n-    // Here, the region parameter `'a` is late-bound, so the\n-    // trait reference associated with the impl will be\n-    //\n-    //     for<'a> Foo<&'a T>\n-    //\n-    // liberating will convert this into:\n-    //\n-    //     Foo<&'A T>\n-    //\n-    // where `'A` is the `ReFree` version of `'a`.\n-    let impl_trait_ref = liberate_late_bound_regions(tcx, impl_m_body_scope, impl_trait_ref);\n-\n     debug!(\"impl_trait_ref (liberated) = {}\",\n            impl_trait_ref.repr(tcx));\n \n@@ -996,15 +948,15 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         return;\n     }\n \n-    if impl_m.fty.sig.inputs.len() != trait_m.fty.sig.inputs.len() {\n+    if impl_m.fty.sig.0.inputs.len() != trait_m.fty.sig.0.inputs.len() {\n         span_err!(tcx.sess, impl_m_span, E0050,\n             \"method `{}` has {} parameter{} \\\n              but the declaration in trait `{}` has {}\",\n             token::get_name(trait_m.name),\n-            impl_m.fty.sig.inputs.len(),\n-            if impl_m.fty.sig.inputs.len() == 1 {\"\"} else {\"s\"},\n+            impl_m.fty.sig.0.inputs.len(),\n+            if impl_m.fty.sig.0.inputs.len() == 1 {\"\"} else {\"s\"},\n             ty::item_path_str(tcx, trait_m.def_id),\n-            trait_m.fty.sig.inputs.len());\n+            trait_m.fty.sig.0.inputs.len());\n         return;\n     }\n \n@@ -1081,7 +1033,6 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if !check_region_bounds_on_impl_method(tcx,\n                                            impl_m_span,\n                                            impl_m,\n-                                           impl_m_body_scope,\n                                            &trait_m.generics,\n                                            &impl_m.generics,\n                                            &trait_to_skol_substs,\n@@ -1106,7 +1057,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // `Bound<&'a T>`, the lifetime `'a` will be late-bound with a\n     // depth of 3 (it is nested within 3 binders: the impl, method,\n     // and trait-ref itself). So when we do the liberation, we have\n-    // two introduce two `ty::bind` scopes, one for the impl and one\n+    // two introduce two `ty::Binder` scopes, one for the impl and one\n     // the method.\n     //\n     // The only late-bounded regions that can possibly appear here are\n@@ -1120,11 +1071,7 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .map(|trait_param_def| &trait_param_def.bounds);\n     let impl_bounds =\n         impl_m.generics.types.get_slice(subst::FnSpace).iter()\n-        .map(|impl_param_def|\n-             liberate_late_bound_regions(\n-                 tcx,\n-                 impl_m_body_scope,\n-                 &ty::bind(ty::bind(impl_param_def.bounds.clone()))).value.value);\n+        .map(|impl_param_def| &impl_param_def.bounds);\n     for (i, (trait_param_bounds, impl_param_bounds)) in\n         trait_bounds.zip(impl_bounds).enumerate()\n     {\n@@ -1167,30 +1114,27 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                     let trait_bound =\n                         trait_bound.subst(tcx, &trait_to_skol_substs);\n                     let infcx = infer::new_infer_ctxt(tcx);\n-                    infer::mk_sub_trait_refs(&infcx,\n-                                             true,\n-                                             infer::Misc(impl_m_span),\n-                                             trait_bound,\n-                                             impl_trait_bound.clone()).is_ok()\n+                    infer::mk_sub_poly_trait_refs(&infcx,\n+                                                  true,\n+                                                  infer::Misc(impl_m_span),\n+                                                  trait_bound,\n+                                                  impl_trait_bound.clone()).is_ok()\n                 });\n \n             if !found_match_in_trait {\n                 span_err!(tcx.sess, impl_m_span, E0052,\n-                    \"in method `{}`, type parameter {} requires bound `{}`, which is not \\\n-                     required by the corresponding type parameter in the trait declaration\",\n-                    token::get_name(trait_m.name),\n-                    i,\n-                    ppaux::trait_ref_to_string(tcx, &*impl_trait_bound));\n+                          \"in method `{}`, type parameter {} requires bound `{}`, which is not \\\n+                           required by the corresponding type parameter in the trait declaration\",\n+                          token::get_name(trait_m.name),\n+                          i,\n+                          impl_trait_bound.user_string(tcx));\n             }\n         }\n     }\n \n-    // Compute skolemized form of impl and trait method tys. Note\n-    // that we must liberate the late-bound regions from the impl.\n+    // Compute skolemized form of impl and trait method tys.\n     let impl_fty = ty::mk_bare_fn(tcx, impl_m.fty.clone());\n     let impl_fty = impl_fty.subst(tcx, &impl_to_skol_substs);\n-    let impl_fty = liberate_late_bound_regions(\n-        tcx, impl_m_body_scope, &ty::bind(impl_fty)).value;\n     let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n@@ -1252,7 +1196,6 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     fn check_region_bounds_on_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                                 span: Span,\n                                                 impl_m: &ty::Method<'tcx>,\n-                                                impl_m_body_scope: CodeExtent,\n                                                 trait_generics: &ty::Generics<'tcx>,\n                                                 impl_generics: &ty::Generics<'tcx>,\n                                                 trait_to_skol_substs: &Substs<'tcx>,\n@@ -1302,16 +1245,6 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             let impl_bounds =\n                 impl_param.bounds.subst(tcx, impl_to_skol_substs);\n \n-            // The bounds may reference late-bound regions from the\n-            // impl declaration. In that case, we want to replace\n-            // those with the liberated variety so as to match the\n-            // versions appearing in the `trait_to_skol_substs`.\n-            // There are two-levels of binder to be aware of: the\n-            // impl, and the method.\n-            let impl_bounds =\n-                ty::liberate_late_bound_regions(\n-                    tcx, impl_m_body_scope, &ty::bind(ty::bind(impl_bounds))).value.value;\n-\n             debug!(\"check_region_bounds_on_impl_method: \\\n                    trait_param={} \\\n                    impl_param={} \\\n@@ -1390,13 +1323,7 @@ fn check_cast(fcx: &FnCtxt,\n     let t_1 = fcx.to_ty(t);\n     let t_1 = structurally_resolved_type(fcx, span, t_1);\n \n-    if ty::type_is_scalar(t_1) {\n-        // Supply the type as a hint so as to influence integer\n-        // literals and other things that might care.\n-        check_expr_with_expectation(fcx, e, ExpectCastableToType(t_1))\n-    } else {\n-        check_expr(fcx, e)\n-    }\n+    check_expr_with_expectation(fcx, e, ExpectCastableToType(t_1));\n \n     let t_e = fcx.expr_ty(e);\n \n@@ -1638,7 +1565,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn default_diverging_type_variables_to_nil(&self) {\n         for (_, &ref ty) in self.inh.node_types.borrow_mut().iter_mut() {\n-            if self.infcx().type_var_diverges(self.infcx().resolve_type_vars_if_possible(*ty)) {\n+            if self.infcx().type_var_diverges(self.infcx().resolve_type_vars_if_possible(ty)) {\n                 demand::eqtype(self, codemap::DUMMY_SP, *ty, ty::mk_nil(self.tcx()));\n             }\n         }\n@@ -1653,7 +1580,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn write_object_cast(&self,\n                              key: ast::NodeId,\n-                             trait_ref: Rc<ty::TraitRef<'tcx>>) {\n+                             trait_ref: Rc<ty::PolyTraitRef<'tcx>>) {\n         debug!(\"write_object_cast key={} trait_ref={}\",\n                key, trait_ref.repr(self.tcx()));\n         self.inh.object_cast_map.borrow_mut().insert(key, trait_ref);\n@@ -1751,7 +1678,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.register_unsize_obligations(span, &**u)\n             }\n             ty::UnsizeVtable(ref ty_trait, self_ty) => {\n-                vtable::check_object_safety(self.tcx(), &ty_trait.principal, span);\n+                vtable::check_object_safety(self.tcx(), ty_trait, span);\n+\n                 // If the type is `Foo+'a`, ensures that the type\n                 // being cast to `Foo+'a` implements `Foo`:\n                 vtable::register_object_cast_obligations(self,\n@@ -2486,7 +2414,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let method_type = match method {\n         Some(ref method) => method.ty,\n         None => {\n-            let true_expr_type = fcx.infcx().resolve_type_vars_if_possible(expr_type);\n+            let true_expr_type = fcx.infcx().resolve_type_vars_if_possible(&expr_type);\n \n             if !ty::type_is_error(true_expr_type) {\n                 let ty_string = fcx.infcx().ty_to_string(true_expr_type);\n@@ -2572,13 +2500,13 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 // HACK(eddyb) ignore self in the definition (see above).\n                 check_argument_types(fcx,\n                                      sp,\n-                                     fty.sig.inputs.slice_from(1),\n+                                     fty.sig.0.inputs.slice_from(1),\n                                      callee_expr,\n                                      args_no_rcvr,\n                                      autoref_args,\n-                                     fty.sig.variadic,\n+                                     fty.sig.0.variadic,\n                                      tuple_arguments);\n-                fty.sig.output\n+                fty.sig.0.output\n             }\n             _ => {\n                 fcx.tcx().sess.span_bug(callee_expr.span,\n@@ -2992,11 +2920,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // This is the \"default\" function signature, used in case of error.\n         // In that case, we check each argument against \"error\" in order to\n         // set up all the node type bindings.\n-        let error_fn_sig = FnSig {\n+        let error_fn_sig = ty::Binder(FnSig {\n             inputs: err_args(args.len()),\n             output: ty::FnConverging(ty::mk_err()),\n             variadic: false\n-        };\n+        });\n \n         let fn_sig = match *fn_sty {\n             ty::ty_bare_fn(ty::BareFnTy {ref sig, ..}) |\n@@ -3976,7 +3904,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         vtable::select_new_fcx_obligations(fcx);\n \n         debug!(\"ExprForLoop each item has type {}\",\n-               fcx.infcx().resolve_type_vars_if_possible(typ).repr(fcx.tcx()));\n+               fcx.infcx().resolve_type_vars_if_possible(&typ).repr(fcx.tcx()));\n \n         let pcx = pat_ctxt {\n             fcx: fcx,\n@@ -4371,11 +4299,11 @@ impl<'tcx> Expectation<'tcx> {\n             }\n             ExpectCastableToType(t) => {\n                 ExpectCastableToType(\n-                    fcx.infcx().resolve_type_vars_if_possible(t))\n+                    fcx.infcx().resolve_type_vars_if_possible(&t))\n             }\n             ExpectHasType(t) => {\n                 ExpectHasType(\n-                    fcx.infcx().resolve_type_vars_if_possible(t))\n+                    fcx.infcx().resolve_type_vars_if_possible(&t))\n             }\n         }\n     }\n@@ -5096,7 +5024,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.infcx().replace_late_bound_regions_with_fresh_var(\n             span,\n             infer::FnCall,\n-            &ty::bind((polytype.ty, bounds))).0.value;\n+            &ty::Binder((polytype.ty, bounds))).0;\n \n     debug!(\"after late-bounds have been replaced: ty_late_bound={}\", ty_late_bound.repr(fcx.tcx()));\n     debug!(\"after late-bounds have been replaced: bounds={}\", bounds.repr(fcx.tcx()));\n@@ -5712,11 +5640,11 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n         unsafety: ast::Unsafety::Unsafe,\n         abi: abi::RustIntrinsic,\n-        sig: FnSig {\n+        sig: ty::Binder(FnSig {\n             inputs: inputs,\n             output: output,\n             variadic: false,\n-        }\n+        }),\n     });\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = i_ty.generics.types.len(subst::FnSpace);"}, {"sha": "33c015a9a081cba3cf9895cbc97f531cb14bd7d6", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -124,8 +124,6 @@ use middle::region::CodeExtent;\n use middle::traits;\n use middle::ty::{ReScope};\n use middle::ty::{mod, Ty, MethodCall};\n-use middle::infer::resolve_and_force_all_but_regions;\n-use middle::infer::resolve_type;\n use middle::infer;\n use middle::pat_util;\n use util::nodemap::{DefIdMap, NodeMap, FnvHashMap};\n@@ -307,11 +305,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     /// of b will be `&<R0>.int` and then `*b` will require that `<R0>` be bigger than the let and\n     /// the `*b` expression, so we will effectively resolve `<R0>` to be the block B.\n     pub fn resolve_type(&self, unresolved_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        match resolve_type(self.fcx.infcx(), None, unresolved_ty,\n-                           resolve_and_force_all_but_regions) {\n-            Ok(t) => t,\n-            Err(_) => ty::mk_err()\n-        }\n+        self.fcx.infcx().resolve_type_vars_if_possible(&unresolved_ty)\n     }\n \n     /// Try to resolve the type for the given node.\n@@ -1187,7 +1181,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n                 let fn_sig = ty::ty_fn_sig(method.ty);\n-                let self_ty = fn_sig.inputs[0];\n+                let self_ty = fn_sig.0.inputs[0];\n                 let (m, r) = match self_ty.sty {\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                     _ => rcx.tcx().sess.span_bug(deref_expr.span,\n@@ -1204,7 +1198,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 // Specialized version of constrain_call.\n                 type_must_outlive(rcx, infer::CallRcvr(deref_expr.span),\n                                   self_ty, r_deref_expr);\n-                match fn_sig.output {\n+                match fn_sig.0.output {\n                     ty::FnConverging(return_type) => {\n                         type_must_outlive(rcx, infer::CallReturn(deref_expr.span),\n                                           return_type, r_deref_expr);"}, {"sha": "4db795a1fda5561913c14bec5cac2870bd3a3808", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 54, "deletions": 82, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use check::{FnCtxt, structurally_resolved_type};\n-use middle::subst::{SelfSpace, FnSpace};\n+use middle::subst::{FnSpace};\n use middle::traits;\n use middle::traits::{SelectionError, OutputTypeParameterMismatch, Overflow, Unimplemented};\n use middle::traits::{Obligation, ObligationCause};\n@@ -44,7 +44,7 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n             // Ensure that if ~T is cast to ~Trait, then T : Trait\n             push_cast_obligation(fcx, cast_expr, object_trait, referent_ty);\n-            check_object_safety(fcx.tcx(), &object_trait.principal, source_expr.span);\n+            check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n         }\n \n         (&ty::ty_rptr(referent_region, ty::mt { ty: referent_ty,\n@@ -68,7 +68,7 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                target_region,\n                                referent_region);\n \n-                check_object_safety(fcx.tcx(), &object_trait.principal, source_expr.span);\n+                check_object_safety(fcx.tcx(), object_trait, source_expr.span);\n             }\n         }\n \n@@ -132,24 +132,19 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n // self by value, has no type parameters and does not use the `Self` type, except\n // in self position.\n pub fn check_object_safety<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 object_trait: &ty::TraitRef<'tcx>,\n-                                 span: Span) {\n-\n-    let mut object = object_trait.clone();\n-    if object.substs.types.len(SelfSpace) == 0 {\n-        object.substs.types.push(SelfSpace, ty::mk_err());\n-    }\n-\n-    let object = Rc::new(object);\n-    for tr in traits::supertraits(tcx, object) {\n+                                 object_trait: &ty::TyTrait<'tcx>,\n+                                 span: Span)\n+{\n+    let object_trait_ref = object_trait.principal_trait_ref_with_self_ty(ty::mk_err());\n+    for tr in traits::supertraits(tcx, object_trait_ref) {\n         check_object_safety_inner(tcx, &*tr, span);\n     }\n }\n \n fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                                 object_trait: &ty::TraitRef<'tcx>,\n+                                 object_trait: &ty::PolyTraitRef<'tcx>,\n                                  span: Span) {\n-    let trait_items = ty::trait_items(tcx, object_trait.def_id);\n+    let trait_items = ty::trait_items(tcx, object_trait.def_id());\n \n     let mut errors = Vec::new();\n     for item in trait_items.iter() {\n@@ -163,7 +158,7 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     let mut errors = errors.iter().flat_map(|x| x.iter()).peekable();\n     if errors.peek().is_some() {\n-        let trait_name = ty::item_path_str(tcx, object_trait.def_id);\n+        let trait_name = ty::item_path_str(tcx, object_trait.def_id());\n         span_err!(tcx.sess, span, E0038,\n             \"cannot convert to a trait object because trait `{}` is not object-safe\",\n             trait_name);\n@@ -212,12 +207,12 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n             }\n         };\n         let ref sig = method.fty.sig;\n-        for &input_ty in sig.inputs[1..].iter() {\n+        for &input_ty in sig.0.inputs[1..].iter() {\n             if let Some(msg) = check_for_self_ty(input_ty) {\n                 msgs.push(msg);\n             }\n         }\n-        if let ty::FnConverging(result_type) = sig.output {\n+        if let ty::FnConverging(result_type) = sig.0.output {\n             if let Some(msg) = check_for_self_ty(result_type) {\n                 msgs.push(msg);\n             }\n@@ -237,7 +232,7 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                   span: Span,\n                                                   object_trait: &ty::TyTrait<'tcx>,\n                                                   referent_ty: Ty<'tcx>)\n-                                                  -> Rc<ty::TraitRef<'tcx>>\n+                                                  -> Rc<ty::PolyTraitRef<'tcx>>\n {\n     // We can only make objects from sized types.\n     fcx.register_builtin_bound(\n@@ -256,17 +251,9 @@ pub fn register_object_cast_obligations<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            referent_ty.repr(fcx.tcx()),\n            object_trait_ty.repr(fcx.tcx()));\n \n-    // Take the type parameters from the object type, but set\n-    // the Self type (which is unknown, for the object type)\n-    // to be the type we are casting from.\n-    let mut object_substs = object_trait.principal.substs.clone();\n-    assert!(object_substs.self_ty().is_none());\n-    object_substs.types.push(SelfSpace, referent_ty);\n-\n     // Create the obligation for casting from T to Trait.\n     let object_trait_ref =\n-        Rc::new(ty::TraitRef { def_id: object_trait.principal.def_id,\n-                               substs: object_substs });\n+        object_trait.principal_trait_ref_with_self_ty(referent_ty);\n     let object_obligation =\n         Obligation::new(\n             ObligationCause::new(span,\n@@ -328,36 +315,13 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     match *error {\n         Overflow => {\n             // We could track the stack here more precisely if we wanted, I imagine.\n-            match obligation.trait_ref {\n-                ty::Predicate::Trait(ref trait_ref) => {\n-                    let trait_ref =\n-                        fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(&**trait_ref);\n-                    fcx.tcx().sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"overflow evaluating the trait `{}` for the type `{}`\",\n-                            trait_ref.user_string(fcx.tcx()),\n-                            trait_ref.self_ty().user_string(fcx.tcx())).as_slice());\n-                }\n-\n-                ty::Predicate::Equate(a, b) => {\n-                    let a = fcx.infcx().resolve_type_vars_if_possible(a);\n-                    let b = fcx.infcx().resolve_type_vars_if_possible(b);\n-                    fcx.tcx().sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n-                            \"overflow checking whether the types `{}` and `{}` are equal\",\n-                            a.user_string(fcx.tcx()),\n-                            b.user_string(fcx.tcx())).as_slice());\n-                }\n-\n-                ty::Predicate::TypeOutlives(..) |\n-                ty::Predicate::RegionOutlives(..) => {\n-                    fcx.tcx().sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\"overflow evaluating lifetime predicate\").as_slice());\n-                }\n-            }\n+            let predicate =\n+                fcx.infcx().resolve_type_vars_if_possible(&obligation.trait_ref);\n+            fcx.tcx().sess.span_err(\n+                obligation.cause.span,\n+                format!(\n+                    \"overflow evaluating the requirement `{}`\",\n+                    predicate.user_string(fcx.tcx())).as_slice());\n \n             let current_limit = fcx.tcx().sess.recursion_limit.get();\n             let suggested_limit = current_limit * 2;\n@@ -372,51 +336,59 @@ pub fn report_selection_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Unimplemented => {\n             match obligation.trait_ref {\n                 ty::Predicate::Trait(ref trait_ref) => {\n-                    let trait_ref =\n-                        fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n-                            &**trait_ref);\n+                    let trait_ref = fcx.infcx().resolve_type_vars_if_possible(&**trait_ref);\n                     if !ty::type_is_error(trait_ref.self_ty()) {\n                         fcx.tcx().sess.span_err(\n                             obligation.cause.span,\n                             format!(\n                                 \"the trait `{}` is not implemented for the type `{}`\",\n                                 trait_ref.user_string(fcx.tcx()),\n                                 trait_ref.self_ty().user_string(fcx.tcx())).as_slice());\n-                        note_obligation_cause(fcx, obligation);\n                     }\n                 }\n \n-                ty::Predicate::Equate(a, b) => {\n-                    let a = fcx.infcx().resolve_type_vars_if_possible(a);\n-                    let b = fcx.infcx().resolve_type_vars_if_possible(b);\n-                    let err = infer::can_mk_eqty(fcx.infcx(), a, b).unwrap_err();\n+                ty::Predicate::Equate(ref predicate) => {\n+                    let predicate = fcx.infcx().resolve_type_vars_if_possible(predicate);\n+                    let err = fcx.infcx().equality_predicate(obligation.cause.span,\n+                                                             &predicate).unwrap_err();\n                     fcx.tcx().sess.span_err(\n                         obligation.cause.span,\n                         format!(\n-                            \"mismatched types: the types `{}` and `{}` are not equal ({})\",\n-                            a.user_string(fcx.tcx()),\n-                            b.user_string(fcx.tcx()),\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate.user_string(fcx.tcx()),\n                             ty::type_err_to_str(fcx.tcx(), &err)).as_slice());\n                 }\n \n-                ty::Predicate::TypeOutlives(..) |\n-                ty::Predicate::RegionOutlives(..) => {\n-                    // these kinds of predicates turn into\n-                    // constraints, and hence errors show up in region\n-                    // inference.\n-                    fcx.tcx().sess.span_bug(\n+                ty::Predicate::RegionOutlives(ref predicate) => {\n+                    let predicate = fcx.infcx().resolve_type_vars_if_possible(predicate);\n+                    let err = fcx.infcx().region_outlives_predicate(obligation.cause.span,\n+                                                                    &predicate).unwrap_err();\n+                    fcx.tcx().sess.span_err(\n                         obligation.cause.span,\n-                        format!(\"region predicate error {}\",\n-                                obligation.repr(fcx.tcx())).as_slice());\n+                        format!(\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate.user_string(fcx.tcx()),\n+                            ty::type_err_to_str(fcx.tcx(), &err)).as_slice());\n+                }\n+\n+                ty::Predicate::TypeOutlives(ref predicate) => {\n+                    let predicate = fcx.infcx().resolve_type_vars_if_possible(predicate);\n+                    fcx.tcx().sess.span_err(\n+                        obligation.cause.span,\n+                        format!(\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate.user_string(fcx.tcx())).as_slice());\n                 }\n             }\n+\n+            note_obligation_cause(fcx, obligation);\n         }\n         OutputTypeParameterMismatch(ref expected_trait_ref, ref actual_trait_ref, ref e) => {\n             let expected_trait_ref =\n-                fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n+                fcx.infcx().resolve_type_vars_if_possible(\n                     &**expected_trait_ref);\n             let actual_trait_ref =\n-                fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n+                fcx.infcx().resolve_type_vars_if_possible(\n                     &**actual_trait_ref);\n             if !ty::type_is_error(actual_trait_ref.self_ty()) {\n                 fcx.tcx().sess.span_err(\n@@ -443,7 +415,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     let trait_ref = match obligation.trait_ref {\n         ty::Predicate::Trait(ref trait_ref) => {\n-            fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(&**trait_ref)\n+            fcx.infcx().resolve_type_vars_if_possible(&**trait_ref)\n         }\n         _ => {\n             fcx.tcx().sess.span_bug(\n@@ -458,7 +430,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n            trait_ref.repr(fcx.tcx()),\n            self_ty.repr(fcx.tcx()),\n            obligation.repr(fcx.tcx()));\n-    let all_types = &trait_ref.substs.types;\n+    let all_types = &trait_ref.substs().types;\n     if all_types.iter().any(|&t| ty::type_is_error(t)) {\n     } else if all_types.iter().any(|&t| ty::type_needs_infer(t)) {\n         // This is kind of a hack: it frequently happens that some earlier\n@@ -477,7 +449,7 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // anyway. In that case, why inundate the user.\n         if !fcx.tcx().sess.has_errors() {\n             if fcx.ccx.tcx.lang_items.sized_trait()\n-                  .map_or(false, |sized_id| sized_id == trait_ref.def_id) {\n+                  .map_or(false, |sized_id| sized_id == trait_ref.def_id()) {\n                 fcx.tcx().sess.span_err(\n                     obligation.cause.span,\n                     format!("}, {"sha": "c09ce3db6ddd21ed15b47c0f5c6b6be0c97e032a", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -166,12 +166,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n             // Find the impl self type as seen from the \"inside\" --\n             // that is, with all type parameters converted from bound\n-            // to free, and any late-bound regions on the impl\n-            // liberated.\n+            // to free.\n             let self_ty = ty::node_id_to_type(fcx.tcx(), item.id);\n             let self_ty = self_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n-            let self_ty = liberate_late_bound_regions(\n-                fcx.tcx(), item_scope, &ty::bind(self_ty)).value;\n \n             bounds_checker.check_traits_in_ty(self_ty);\n \n@@ -182,7 +179,6 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 Some(t) => { t }\n             };\n             let trait_ref = (*trait_ref).subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n-            let trait_ref = liberate_late_bound_regions(fcx.tcx(), item_scope, &trait_ref);\n \n             // There are special rules that apply to drop.\n             if\n@@ -222,7 +218,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                     traits::ItemObligation(trait_ref.def_id));\n \n             // Find the supertrait bounds. This will add `int:Bar`.\n-            let predicates = ty::predicates_for_trait_ref(fcx.tcx(), &trait_ref);\n+            let poly_trait_ref = ty::Binder(trait_ref);\n+            let predicates = ty::predicates_for_trait_ref(fcx.tcx(), &poly_trait_ref);\n             for predicate in predicates.into_iter() {\n                 fcx.register_predicate(traits::Obligation::new(cause, predicate));\n             }"}, {"sha": "b73381966e8dcb931ee0a080fa80be7cb7b00f6b", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -19,8 +19,6 @@ use middle::def;\n use middle::pat_util;\n use middle::ty::{mod, Ty, MethodCall, MethodCallee};\n use middle::ty_fold::{TypeFolder,TypeFoldable};\n-use middle::infer::{force_all, resolve_all, resolve_region};\n-use middle::infer::resolve_type;\n use middle::infer;\n use write_substs_to_tcx;\n use write_ty_to_tcx;\n@@ -337,8 +335,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n-    fn resolve<T:ResolveIn<'tcx>>(&self, t: &T, reason: ResolveReason) -> T {\n-        t.resolve_in(&mut Resolver::new(self.fcx, reason))\n+    fn resolve<T:TypeFoldable<'tcx>>(&self, t: &T, reason: ResolveReason) -> T {\n+        t.fold_with(&mut Resolver::new(self.fcx, reason))\n     }\n }\n \n@@ -375,19 +373,6 @@ impl ResolveReason {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Convenience methods for resolving different kinds of things.\n-\n-trait ResolveIn<'tcx> {\n-    fn resolve_in<'a>(&self, resolver: &mut Resolver<'a, 'tcx>) -> Self;\n-}\n-\n-impl<'tcx, T: TypeFoldable<'tcx>> ResolveIn<'tcx> for T {\n-    fn resolve_in<'a>(&self, resolver: &mut Resolver<'a, 'tcx>) -> T {\n-        self.fold_with(resolver)\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // The Resolver. This is the type folding engine that detects\n // unresolved types and so forth.\n@@ -465,21 +450,19 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !ty::type_needs_infer(t) {\n-            return t;\n-        }\n-\n-        match resolve_type(self.infcx, None, t, resolve_all | force_all) {\n+        match self.infcx.fully_resolve(&t) {\n             Ok(t) => t,\n             Err(e) => {\n+                debug!(\"Resolver::fold_ty: input type `{}` not fully resolvable\",\n+                       t.repr(self.tcx));\n                 self.report_error(e);\n                 ty::mk_err()\n             }\n         }\n     }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n-        match resolve_region(self.infcx, r, resolve_all | force_all) {\n+        match self.infcx.fully_resolve(&r) {\n             Ok(r) => r,\n             Err(e) => {\n                 self.report_error(e);"}, {"sha": "5d0bb6622c2e144667664f5983c2c33e7b43347a", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 32, "deletions": 68, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -19,19 +19,19 @@\n use metadata::csearch::{each_impl, get_impl_trait};\n use metadata::csearch;\n use middle::subst::{mod, Subst};\n+use middle::ty::RegionEscape;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n use middle::ty::{ParameterEnvironment, TypeTraitItemId, lookup_item_type};\n use middle::ty::{Ty, ty_bool, ty_char, ty_closure, ty_enum, ty_err};\n use middle::ty::{ty_param, Polytype, ty_ptr};\n use middle::ty::{ty_rptr, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_open};\n use middle::ty::{ty_uint, ty_unboxed_closure, ty_uniq, ty_bare_fn};\n-use middle::ty::{type_is_ty_var};\n use middle::ty;\n use CrateCtxt;\n use middle::infer::combine::Combine;\n use middle::infer::InferCtxt;\n-use middle::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n+use middle::infer::{new_infer_ctxt};\n use std::collections::{HashSet};\n use std::cell::RefCell;\n use std::rc::Rc;\n@@ -52,80 +52,35 @@ mod orphan;\n mod overlap;\n mod unsafety;\n \n-fn get_base_type<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n-                           span: Span,\n-                           original_type: Ty<'tcx>)\n-                           -> Option<Ty<'tcx>> {\n-    let resolved_type = match resolve_type(inference_context,\n-                                           Some(span),\n-                                           original_type,\n-                                           resolve_ivar) {\n-        Ok(resulting_type) if !type_is_ty_var(resulting_type) => resulting_type,\n-        _ => {\n-            inference_context.tcx.sess.span_fatal(span,\n-                                                  \"the type of this value must be known in order \\\n-                                                   to determine the base type\");\n-        }\n-    };\n-\n-    match resolved_type.sty {\n-        ty_enum(..) | ty_struct(..) | ty_unboxed_closure(..) => {\n-            debug!(\"(getting base type) found base type\");\n-            Some(resolved_type)\n+// Returns the def ID of the base type, if there is one.\n+fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n+                                  span: Span,\n+                                  ty: Ty<'tcx>)\n+                                  -> Option<DefId> {\n+    match ty.sty {\n+        ty_enum(def_id, _) |\n+        ty_struct(def_id, _) => {\n+            Some(def_id)\n         }\n \n-        _ if ty::type_is_trait(resolved_type) => {\n-            debug!(\"(getting base type) found base type (trait)\");\n-            Some(resolved_type)\n+        ty_trait(ref t) => {\n+            Some(t.principal.def_id())\n         }\n \n         ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n-        ty_infer(..) | ty_param(..) | ty_err | ty_open(..) | ty_uniq(_) |\n+        ty_param(..) | ty_err | ty_open(..) | ty_uniq(_) |\n         ty_ptr(_) | ty_rptr(_, _) => {\n-            debug!(\"(getting base type) no base type; found {}\",\n-                   original_type.sty);\n             None\n         }\n-        ty_trait(..) => panic!(\"should have been caught\")\n-    }\n-}\n \n-// Returns the def ID of the base type, if there is one.\n-fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n-                                  span: Span,\n-                                  original_type: Ty<'tcx>)\n-                                  -> Option<DefId> {\n-    match get_base_type(inference_context, span, original_type) {\n-        None => None,\n-        Some(base_type) => {\n-            match base_type.sty {\n-                ty_enum(def_id, _) |\n-                ty_struct(def_id, _) |\n-                ty_unboxed_closure(def_id, _, _) => {\n-                    Some(def_id)\n-                }\n-                ty_ptr(ty::mt {ty, ..}) |\n-                ty_rptr(_, ty::mt {ty, ..}) |\n-                ty_uniq(ty) => {\n-                    match ty.sty {\n-                        ty_trait(box ty::TyTrait { ref principal, .. }) => {\n-                            Some(principal.def_id)\n-                        }\n-                        _ => {\n-                            panic!(\"get_base_type() returned a type that wasn't an \\\n-                                   enum, struct, or trait\");\n-                        }\n-                    }\n-                }\n-                ty_trait(box ty::TyTrait { ref principal, .. }) => {\n-                    Some(principal.def_id)\n-                }\n-                _ => {\n-                    panic!(\"get_base_type() returned a type that wasn't an \\\n-                           enum, struct, or trait\");\n-                }\n-            }\n+        ty_infer(..) | ty_unboxed_closure(..) => {\n+            // `ty` comes from a user declaration so we should only expect types\n+            // that the user can type\n+            inference_context.tcx.sess.span_bug(\n+                span,\n+                format!(\"coherence encountered unexpected type searching for base type: {}\",\n+                        ty.repr(inference_context.tcx))[]);\n         }\n     }\n }\n@@ -504,17 +459,26 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         let trait_impls = trait_impls.borrow().clone();\n \n         for &impl_did in trait_impls.iter() {\n+            debug!(\"check_implementations_of_copy: impl_did={}\",\n+                   impl_did.repr(tcx));\n+\n             if impl_did.krate != ast::LOCAL_CRATE {\n                 debug!(\"check_implementations_of_copy(): impl not in this \\\n                         crate\");\n                 continue\n             }\n \n             let self_type = self.get_self_type_for_implementation(impl_did);\n+            debug!(\"check_implementations_of_copy: self_type={} (bound)\",\n+                   self_type.repr(tcx));\n+\n             let span = tcx.map.span(impl_did.node);\n-            let param_env = ParameterEnvironment::for_item(tcx,\n-                                                           impl_did.node);\n+            let param_env = ParameterEnvironment::for_item(tcx, impl_did.node);\n             let self_type = self_type.ty.subst(tcx, &param_env.free_substs);\n+            assert!(!self_type.has_escaping_regions());\n+\n+            debug!(\"check_implementations_of_copy: self_type={} (free)\",\n+                   self_type.repr(tcx));\n \n             match ty::can_type_implement_copy(tcx, self_type, &param_env) {\n                 Ok(()) => {}"}, {"sha": "bb8efd29910702a2f4b0b3f23246b10b8670bf8e", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -55,7 +55,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                         self.check_def_id(item.span, def_id);\n                     }\n                     ty::ty_trait(box ty::TyTrait{ ref principal, ..}) => {\n-                        self.check_def_id(item.span, principal.def_id);\n+                        self.check_def_id(item.span, principal.def_id());\n                     }\n                     _ => {\n                         span_err!(self.tcx.sess, item.span, E0118,"}, {"sha": "280b42f0959d28839182f2cff7a1fb70646d2406", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 81, "deletions": 64, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -42,10 +42,9 @@ use middle::region;\n use middle::resolve_lifetime;\n use middle::subst;\n use middle::subst::{Substs};\n-use middle::ty::{ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n-use middle::ty::{Polytype};\n-use middle::ty::{mod, Ty};\n-use middle::ty_fold::TypeFolder;\n+use middle::ty::{AsPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n+use middle::ty::{mod, RegionEscape, Ty, Polytype};\n+use middle::ty_fold::{mod, TypeFolder, TypeFoldable};\n use middle::infer;\n use rscope::*;\n use {CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n@@ -227,7 +226,7 @@ pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n             ast::StructVariantKind(ref struct_def) => {\n                 let pty = Polytype {\n-                    generics: ty_generics_for_type(\n+                    generics: ty_generics_for_type_or_impl(\n                         ccx,\n                         generics,\n                         DontCreateTypeParametersForAssociatedTypes),\n@@ -240,7 +239,7 @@ pub fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         };\n \n         let pty = Polytype {\n-            generics: ty_generics_for_type(\n+            generics: ty_generics_for_type_or_impl(\n                           ccx,\n                           generics,\n                           DontCreateTypeParametersForAssociatedTypes),\n@@ -652,7 +651,7 @@ fn is_associated_type_valid_for_param(ty: Ty,\n     if let ty::ty_param(param_ty) = ty.sty {\n         let type_parameter = generics.types.get(param_ty.space, param_ty.idx);\n         for trait_bound in type_parameter.bounds.trait_bounds.iter() {\n-            if trait_bound.def_id == trait_id {\n+            if trait_bound.def_id() == trait_id {\n                 return true\n             }\n         }\n@@ -1051,7 +1050,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                       ref selfty,\n                       ref impl_items) => {\n             // Create generics from the generics specified in the impl head.\n-            let ty_generics = ty_generics_for_impl(\n+            let ty_generics = ty_generics_for_type_or_impl(\n                     ccx,\n                     generics,\n                     CreateTypeParametersForAssociatedTypes);\n@@ -1483,7 +1482,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n             let pty = {\n                 let ty = ccx.to_ty(&ExplicitRscope, &**t);\n                 Polytype {\n-                    generics: ty_generics_for_type(\n+                    generics: ty_generics_for_type_or_impl(\n                                   ccx,\n                                   generics,\n                                   DontCreateTypeParametersForAssociatedTypes),\n@@ -1496,7 +1495,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n         }\n         ast::ItemEnum(_, ref generics) => {\n             // Create a new generic polytype.\n-            let ty_generics = ty_generics_for_type(\n+            let ty_generics = ty_generics_for_type_or_impl(\n                 ccx,\n                 generics,\n                 DontCreateTypeParametersForAssociatedTypes);\n@@ -1514,7 +1513,7 @@ pub fn ty_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item)\n             tcx.sess.span_bug(it.span, \"invoked ty_of_item on trait\");\n         }\n         ast::ItemStruct(_, ref generics) => {\n-            let ty_generics = ty_generics_for_type(\n+            let ty_generics = ty_generics_for_type_or_impl(\n                 ccx,\n                 generics,\n                 DontCreateTypeParametersForAssociatedTypes);\n@@ -1581,11 +1580,11 @@ fn ty_of_trait_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-fn ty_generics_for_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                  generics: &ast::Generics,\n-                                  create_type_parameters_for_associated_types:\n-                                      CreateTypeParametersForAssociatedTypesFlag)\n-                                  -> ty::Generics<'tcx> {\n+fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                          generics: &ast::Generics,\n+                                          create_type_parameters_for_associated_types:\n+                                          CreateTypeParametersForAssociatedTypesFlag)\n+                                          -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n                 generics.lifetimes.as_slice(),\n@@ -1638,8 +1637,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let param_id = trait_id;\n \n     let self_trait_ref =\n-        Rc::new(ty::TraitRef { def_id: local_def(trait_id),\n-                               substs: (*substs).clone() });\n+        Rc::new(ty::Binder(ty::TraitRef { def_id: local_def(trait_id),\n+                                          substs: (*substs).clone() }));\n \n     let def = ty::TypeParameterDef {\n         space: subst::SelfSpace,\n@@ -1665,24 +1664,6 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     generics\n }\n \n-fn ty_generics_for_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                  generics: &ast::Generics,\n-                                  create_type_parameters_for_associated_types:\n-                                      CreateTypeParametersForAssociatedTypesFlag)\n-                                  -> ty::Generics<'tcx>\n-{\n-    let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n-    debug!(\"ty_generics_for_impl: early_lifetimes={}\",\n-           early_lifetimes);\n-    ty_generics(ccx,\n-                subst::TypeSpace,\n-                early_lifetimes.as_slice(),\n-                generics.ty_params.as_slice(),\n-                ty::Generics::empty(),\n-                &generics.where_clause,\n-                create_type_parameters_for_associated_types)\n-}\n-\n fn ty_generics_for_fn_or_method<'tcx,AC>(\n         this: &AC,\n         generics: &ast::Generics,\n@@ -1920,8 +1901,12 @@ fn ty_generics<'tcx,AC>(this: &AC,\n         for region_param_def in result.regions.get_slice(space).iter() {\n             let region = region_param_def.to_early_bound_region();\n             for &bound_region in region_param_def.bounds.iter() {\n-                result.predicates.push(space, ty::Predicate::RegionOutlives(region,\n-                                                                            bound_region));\n+                // account for new binder introduced in the predicate below; no need\n+                // to shift `region` because it is never a late-bound region\n+                let bound_region = ty_fold::shift_region(bound_region, 1);\n+                result.predicates.push(\n+                    space,\n+                    ty::Binder(ty::OutlivesPredicate(region, bound_region)).as_predicate());\n             }\n         }\n     }\n@@ -2015,7 +2000,7 @@ fn compute_bounds<'tcx,AC>(this: &AC,\n                             &param_bounds,\n                             span);\n \n-    param_bounds.trait_bounds.sort_by(|a,b| a.def_id.cmp(&b.def_id));\n+    param_bounds.trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n \n     param_bounds\n }\n@@ -2031,13 +2016,13 @@ fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n             tcx,\n             param_bounds.trait_bounds.as_slice(),\n             |trait_ref| {\n-                let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id);\n+                let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id());\n                 if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n                     span_err!(tcx.sess, span, E0129,\n                               \"incompatible bounds on type parameter `{}`, \\\n                                bound `{}` does not allow unsized type\",\n                               name_of_bounded_thing.user_string(tcx),\n-                              ppaux::trait_ref_to_string(tcx, &*trait_ref));\n+                              trait_ref.user_string(tcx));\n                 }\n                 true\n             });\n@@ -2057,14 +2042,14 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n                                      trait_bounds,\n                                      region_bounds } =\n         astconv::partition_bounds(this.tcx(), span, all_bounds.as_slice());\n-    let trait_bounds: Vec<Rc<ty::TraitRef>> =\n+    let trait_bounds: Vec<Rc<ty::PolyTraitRef>> =\n         trait_bounds.into_iter()\n         .map(|bound| {\n-            astconv::instantiate_trait_ref(this,\n-                                           &ExplicitRscope,\n-                                           &bound.trait_ref,\n-                                           Some(param_ty.to_ty(this.tcx())),\n-                                           AllowEqConstraints::Allow)\n+            astconv::instantiate_poly_trait_ref(this,\n+                                                &ExplicitRscope,\n+                                                bound,\n+                                                Some(param_ty.to_ty(this.tcx())),\n+                                                AllowEqConstraints::Allow)\n         })\n         .collect();\n     let region_bounds: Vec<ty::Region> =\n@@ -2155,9 +2140,9 @@ pub fn ty_of_foreign_fn_decl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ty::BareFnTy {\n             abi: abi,\n             unsafety: ast::Unsafety::Unsafe,\n-            sig: ty::FnSig {inputs: input_tys,\n-                            output: output,\n-                            variadic: decl.variadic}\n+            sig: ty::Binder(ty::FnSig {inputs: input_tys,\n+                                       output: output,\n+                                       variadic: decl.variadic}),\n         });\n     let pty = Polytype {\n         generics: ty_generics_for_fn_or_method,\n@@ -2183,8 +2168,12 @@ pub fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     subst::Substs::new(types, regions)\n }\n \n-/// Verifies that the explicit self type of a method matches the impl or\n-/// trait.\n+/// Verifies that the explicit self type of a method matches the impl\n+/// or trait. This is a bit weird but basically because right now we\n+/// don't handle the general case, but instead map it to one of\n+/// several pre-defined options using various heuristics, this method\n+/// comes back to check after the fact that explicit type the user\n+/// wrote actually matches what the pre-defined option said.\n fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n     crate_context: &CrateCtxt<'a, 'tcx>,\n     rs: &RS,\n@@ -2206,19 +2195,21 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         // contain late-bound regions from the method, but not the\n         // trait (since traits only have early-bound region\n         // parameters).\n-        assert!(!ty::type_escapes_depth(required_type, 1));\n+        assert!(!base_type.has_regions_escaping_depth(1));\n         let required_type_free =\n-            ty::liberate_late_bound_regions(\n-                crate_context.tcx, body_scope, &ty::bind(required_type)).value;\n-\n-        // The \"base type\" comes from the impl. It may have late-bound\n-        // regions from the impl or the method.\n-        let base_type_free = // liberate impl regions:\n-            ty::liberate_late_bound_regions(\n-                crate_context.tcx, body_scope, &ty::bind(ty::bind(base_type))).value.value;\n-        let base_type_free = // liberate method regions:\n-            ty::liberate_late_bound_regions(\n-                crate_context.tcx, body_scope, &ty::bind(base_type_free)).value;\n+            liberate_early_bound_regions(\n+                crate_context.tcx, body_scope,\n+                &ty::liberate_late_bound_regions(\n+                    crate_context.tcx, body_scope, &ty::Binder(required_type)));\n+\n+        // The \"base type\" comes from the impl. It too may have late-bound\n+        // regions from the method.\n+        assert!(!base_type.has_regions_escaping_depth(1));\n+        let base_type_free =\n+            liberate_early_bound_regions(\n+                crate_context.tcx, body_scope,\n+                &ty::liberate_late_bound_regions(\n+                    crate_context.tcx, body_scope, &ty::Binder(base_type)));\n \n         debug!(\"required_type={} required_type_free={} \\\n                 base_type={} base_type_free={}\",\n@@ -2239,4 +2230,30 @@ fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n         }));\n         infcx.resolve_regions_and_report_errors(body_id);\n     }\n+\n+    fn liberate_early_bound_regions<'tcx,T>(\n+        tcx: &ty::ctxt<'tcx>,\n+        scope: region::CodeExtent,\n+        value: &T)\n+        -> T\n+        where T : TypeFoldable<'tcx> + Repr<'tcx>\n+    {\n+        /*!\n+         * Convert early-bound regions into free regions; normally this is done by\n+         * applying the `free_substs` from the `ParameterEnvironment`, but this particular\n+         * method-self-type check is kind of hacky and done very early in the process,\n+         * before we really have a `ParameterEnvironment` to check.\n+         */\n+\n+        ty_fold::fold_regions(tcx, value, |region, _| {\n+            match region {\n+                ty::ReEarlyBound(id, _, _, name) => {\n+                    let def_id = local_def(id);\n+                    ty::ReFree(ty::FreeRegion { scope: scope,\n+                                                bound_region: ty::BrNamed(def_id, name) })\n+                }\n+                _ => region\n+            }\n+        })\n+    }\n }"}, {"sha": "5fc2466674ebe61dc9ba1bd5c51a7cf2364b1b6c", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -228,11 +228,11 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n-                sig: ty::FnSig {\n+                sig: ty::Binder(ty::FnSig {\n                     inputs: Vec::new(),\n                     output: ty::FnConverging(ty::mk_nil(tcx)),\n                     variadic: false\n-                }\n+                })\n             });\n \n             require_same_types(tcx, None, false, main_span, main_t, se_ty,\n@@ -276,14 +276,14 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             let se_ty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n                 unsafety: ast::Unsafety::Normal,\n                 abi: abi::Rust,\n-                sig: ty::FnSig {\n+                sig: ty::Binder(ty::FnSig {\n                     inputs: vec!(\n                         ty::mk_int(),\n                         ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, ty::mk_u8()))\n                     ),\n                     output: ty::FnConverging(ty::mk_int()),\n                     variadic: false\n-                }\n+                }),\n             });\n \n             require_same_types(tcx, None, false, start_span, start_t, se_ty,"}, {"sha": "67478e0bfa77eadab2d48057af08363b8a69f06b", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -777,13 +777,13 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::ty_trait(box ty::TyTrait { ref principal, bounds }) => {\n-                let trait_def = ty::lookup_trait_def(self.tcx(), principal.def_id);\n+                let trait_def = ty::lookup_trait_def(self.tcx(), principal.def_id());\n                 let generics = &trait_def.generics;\n \n                 // Traits DO have a Self type parameter, but it is\n                 // erased from object types.\n                 assert!(!generics.types.is_empty_in(subst::SelfSpace) &&\n-                        principal.substs.types.is_empty_in(subst::SelfSpace));\n+                        principal.substs().types.is_empty_in(subst::SelfSpace));\n \n                 // Traits never declare region parameters in the self\n                 // space.\n@@ -799,10 +799,10 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.add_constraints_from_region(bounds.region_bound, contra);\n \n                 self.add_constraints_from_substs(\n-                    principal.def_id,\n+                    principal.def_id(),\n                     generics.types.get_slice(subst::TypeSpace),\n                     generics.regions.get_slice(subst::TypeSpace),\n-                    &principal.substs,\n+                    principal.substs(),\n                     variance);\n             }\n \n@@ -878,13 +878,13 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     /// Adds constraints appropriate for a function with signature\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n-                                sig: &ty::FnSig<'tcx>,\n+                                sig: &ty::PolyFnSig<'tcx>,\n                                 variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n-        for &input in sig.inputs.iter() {\n+        for &input in sig.0.inputs.iter() {\n             self.add_constraints_from_ty(input, contra);\n         }\n-        if let ty::FnConverging(result_type) = sig.output {\n+        if let ty::FnConverging(result_type) = sig.0.output {\n             self.add_constraints_from_ty(result_type, variance);\n         }\n     }"}, {"sha": "661d6ec241ade42319c3342065ef803954c6dfcc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -575,6 +575,12 @@ impl Clean<TyParamBound> for ty::BuiltinBound {\n     }\n }\n \n+impl<'tcx> Clean<TyParamBound> for ty::PolyTraitRef<'tcx> {\n+    fn clean(&self, cx: &DocContext) -> TyParamBound {\n+        self.0.clean(cx)\n+    }\n+}\n+\n impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> TyParamBound {\n         let tcx = match cx.tcx_opt() {\n@@ -913,7 +919,7 @@ impl<'tcx> Clean<Type> for ty::FnOutput<'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig<'tcx>) {\n+impl<'a, 'tcx> Clean<FnDecl> for (ast::DefId, &'a ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n         let mut names = if did.node != 0 {\n@@ -925,10 +931,10 @@ impl<'a, 'tcx> Clean<FnDecl> for (ast::DefId, &'a ty::FnSig<'tcx>) {\n             let _ = names.next();\n         }\n         FnDecl {\n-            output: Return(sig.output.clean(cx)),\n+            output: Return(sig.0.output.clean(cx)),\n             attrs: Vec::new(),\n             inputs: Arguments {\n-                values: sig.inputs.iter().map(|t| {\n+                values: sig.0.inputs.iter().map(|t| {\n                     Argument {\n                         type_: t.clean(cx),\n                         id: 0,\n@@ -1082,22 +1088,22 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n             ty::StaticExplicitSelfCategory => (ast::SelfStatic.clean(cx),\n                                                self.fty.sig.clone()),\n             s => {\n-                let sig = ty::FnSig {\n-                    inputs: self.fty.sig.inputs[1..].to_vec(),\n-                    ..self.fty.sig.clone()\n-                };\n+                let sig = ty::Binder(ty::FnSig {\n+                    inputs: self.fty.sig.0.inputs[1..].to_vec(),\n+                    ..self.fty.sig.0.clone()\n+                });\n                 let s = match s {\n                     ty::ByValueExplicitSelfCategory => SelfValue,\n                     ty::ByReferenceExplicitSelfCategory(..) => {\n-                        match self.fty.sig.inputs[0].sty {\n+                        match self.fty.sig.0.inputs[0].sty {\n                             ty::ty_rptr(r, mt) => {\n                                 SelfBorrowed(r.clean(cx), mt.mutbl.clean(cx))\n                             }\n                             _ => unreachable!(),\n                         }\n                     }\n                     ty::ByBoxExplicitSelfCategory => {\n-                        SelfExplicit(self.fty.sig.inputs[0].clean(cx))\n+                        SelfExplicit(self.fty.sig.0.inputs[0].clean(cx))\n                     }\n                     ty::StaticExplicitSelfCategory => unreachable!(),\n                 };\n@@ -1391,8 +1397,10 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n             }\n             ty::ty_struct(did, ref substs) |\n             ty::ty_enum(did, ref substs) |\n-            ty::ty_trait(box ty::TyTrait { principal: ty::TraitRef { def_id: did, ref substs },\n-                                           .. }) => {\n+            ty::ty_trait(box ty::TyTrait {\n+                principal: ty::Binder(ty::TraitRef { def_id: did, ref substs }),\n+                .. }) =>\n+            {\n                 let fqn = csearch::get_item_path(cx.tcx(), did);\n                 let fqn: Vec<String> = fqn.into_iter().map(|i| {\n                     i.to_string()"}, {"sha": "5a1a186c74c4eab99585f7ca6500d5aecb0f82ce", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -105,8 +105,11 @@ pub trait Visitor<'v> {\n             None => ()\n         }\n     }\n+    fn visit_lifetime_bound(&mut self, lifetime: &'v Lifetime) {\n+        walk_lifetime_bound(self, lifetime)\n+    }\n     fn visit_lifetime_ref(&mut self, lifetime: &'v Lifetime) {\n-        self.visit_name(lifetime.span, lifetime.name)\n+        walk_lifetime_ref(self, lifetime)\n     }\n     fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n@@ -214,10 +217,20 @@ pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n                                               lifetime_def: &'v LifetimeDef) {\n     visitor.visit_name(lifetime_def.lifetime.span, lifetime_def.lifetime.name);\n     for bound in lifetime_def.bounds.iter() {\n-        visitor.visit_lifetime_ref(bound);\n+        visitor.visit_lifetime_bound(bound);\n     }\n }\n \n+pub fn walk_lifetime_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                               lifetime_ref: &'v Lifetime) {\n+    visitor.visit_lifetime_ref(lifetime_ref)\n+}\n+\n+pub fn walk_lifetime_ref<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                             lifetime_ref: &'v Lifetime) {\n+    visitor.visit_name(lifetime_ref.span, lifetime_ref.name)\n+}\n+\n pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n                                               explicit_self: &'v ExplicitSelf) {\n     match explicit_self.node {\n@@ -550,7 +563,7 @@ pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n             visitor.visit_poly_trait_ref(typ);\n         }\n         RegionTyParamBound(ref lifetime) => {\n-            visitor.visit_lifetime_ref(lifetime);\n+            visitor.visit_lifetime_bound(lifetime);\n         }\n     }\n }"}, {"sha": "728b577df1dd4a3e2a3ecb6ee7c85c055220ca8d", "filename": "src/test/compile-fail/bad-match.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fbad-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fbad-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-match.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -14,3 +14,6 @@ fn main() {\n   let int x = 5;\n   match x;\n }\n+\n+fn main() {\n+}"}, {"sha": "5eb8fd69312582100f2e64b7d024f1e1f801ed05", "filename": "src/test/compile-fail/hrtb-conflate-regions.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fhrtb-conflate-regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fhrtb-conflate-regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-conflate-regions.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that an impl with only one bound region `'a` cannot be used to\n+// satisfy a constraint where there are two bound regions.\n+\n+trait Foo<X> {\n+    fn foo(&self, x: X) { }\n+}\n+\n+fn want_foo2<T>()\n+    where T : for<'a,'b> Foo<(&'a int, &'b int)>\n+{\n+}\n+\n+fn want_foo1<T>()\n+    where T : for<'z> Foo<(&'z int, &'z int)>\n+{\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Expressed as a where clause\n+\n+struct SomeStruct;\n+\n+impl<'a> Foo<(&'a int, &'a int)> for SomeStruct\n+{\n+}\n+\n+fn a() { want_foo1::<SomeStruct>(); } // OK -- foo wants just one region\n+fn b() { want_foo2::<SomeStruct>(); } //~ ERROR not implemented\n+\n+fn main() { }"}, {"sha": "36a45400eec1a3e14406ae109c14025288864f2e", "filename": "src/test/compile-fail/hrtb-just-for-static.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fhrtb-just-for-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fhrtb-just-for-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-just-for-static.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a case where you have an impl of `Foo<X>` for all `X` that\n+// is being applied to `for<'a> Foo<&'a mut X>`. Issue #19730.\n+\n+trait Foo<X> {\n+    fn foo(&self, x: X) { }\n+}\n+\n+fn want_hrtb<T>()\n+    where T : for<'a> Foo<&'a int>\n+{\n+}\n+\n+// AnyInt implements Foo<&'a int> for any 'a, so it is a match.\n+struct AnyInt;\n+impl<'a> Foo<&'a int> for AnyInt { }\n+fn give_any() {\n+    want_hrtb::<AnyInt>()\n+}\n+\n+// StaticInt only implements Foo<&'static int>, so it is an error.\n+struct StaticInt;\n+impl Foo<&'static int> for StaticInt { }\n+fn give_static() {\n+    want_hrtb::<StaticInt>() //~ ERROR `for<'a> Foo<&'a int>` is not implemented\n+}\n+\n+fn main() { }"}, {"sha": "a8ee2154fc396d5011070c69db58f74767c7d9fd", "filename": "src/test/compile-fail/hrtb-perfect-forwarding.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fhrtb-perfect-forwarding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fhrtb-perfect-forwarding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-perfect-forwarding.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -0,0 +1,66 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a case where you have an impl of `Foo<X>` for all `X` that\n+// is being applied to `for<'a> Foo<&'a mut X>`. Issue #19730.\n+\n+trait Foo<X> {\n+    fn foo(&mut self, x: X) { }\n+}\n+\n+trait Bar<X> {\n+    fn bar(&mut self, x: X) { }\n+}\n+\n+impl<'a,X,F> Foo<X> for &'a mut F\n+    where F : Foo<X> + Bar<X>\n+{\n+}\n+\n+impl<'a,X,F> Bar<X> for &'a mut F\n+    where F : Bar<X>\n+{\n+}\n+\n+fn no_hrtb<'b,T>(mut t: T)\n+    where T : Bar<&'b int>\n+{\n+    // OK -- `T : Bar<&'b int>`, and thus the impl above ensures that\n+    // `&mut T : Bar<&'b int>`.\n+    no_hrtb(&mut t);\n+}\n+\n+fn bar_hrtb<T>(mut t: T)\n+    where T : for<'b> Bar<&'b int>\n+{\n+    // OK -- `T : for<'b> Bar<&'b int>`, and thus the impl above\n+    // ensures that `&mut T : for<'b> Bar<&'b int>`.  This is an\n+    // example of a \"perfect forwarding\" impl.\n+    bar_hrtb(&mut t);\n+}\n+\n+fn foo_hrtb_bar_not<'b,T>(mut t: T)\n+    where T : for<'a> Foo<&'a int> + Bar<&'b int>\n+{\n+    // Not OK -- The forwarding impl for `Foo` requires that `Bar` also\n+    // be implemented. Thus to satisfy `&mut T : for<'a> Foo<&'a\n+    // int>`, we require `T : for<'a> Bar<&'a int>`, but the where\n+    // clause only specifies `T : Bar<&'b int>`.\n+    foo_hrtb_bar_not(&mut t); //~ ERROR `for<'a> Bar<&'a int>` is not implemented for the type `T`\n+}\n+\n+fn foo_hrtb_bar_hrtb<T>(mut t: T)\n+    where T : for<'a> Foo<&'a int> + for<'b> Bar<&'b int>\n+{\n+    // OK -- now we have `T : for<'b> Bar&'b int>`.\n+    foo_hrtb_bar_hrtb(&mut t);\n+}\n+\n+fn main() { }"}, {"sha": "9fe8f9ab46ddc429fe07edad9ebf3fca50a6d8cc", "filename": "src/test/compile-fail/hrtb-type-outlives.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fhrtb-type-outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fhrtb-type-outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-type-outlives.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test what happens when a HR obligation is applied to an impl with\n+// \"outlives\" bounds. Currently we're pretty conservative here; this\n+// will probably improve in time.\n+\n+trait Foo<X> {\n+    fn foo(&self, x: X) { }\n+}\n+\n+fn want_foo<T>()\n+    where T : for<'a> Foo<&'a int>\n+{\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Expressed as a where clause\n+\n+struct SomeStruct<X> {\n+    x: X\n+}\n+\n+impl<'a,X> Foo<&'a int> for SomeStruct<X>\n+    where X : 'a\n+{\n+}\n+\n+fn one() {\n+    // In fact there is no good reason for this to be an error, but\n+    // whatever, I'm mostly concerned it doesn't ICE right now:\n+    want_foo::<SomeStruct<uint>>();\n+    //~^ ERROR requirement `for<'a> uint : 'a` is not satisfied\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Expressed as shorthand\n+\n+struct AnotherStruct<X> {\n+    x: X\n+}\n+\n+impl<'a,X:'a> Foo<&'a int> for AnotherStruct<X>\n+{\n+}\n+\n+fn two() {\n+    want_foo::<AnotherStruct<uint>>();\n+    //~^ ERROR requirement `for<'a> uint : 'a` is not satisfied\n+}\n+\n+fn main() { }"}, {"sha": "d03885ca7133c57609af0bbb094a4baaa4c37525", "filename": "src/test/compile-fail/issue-14366.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fissue-14366.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fissue-14366.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14366.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -11,5 +11,4 @@\n fn main() {\n     let _x = \"test\" as &::std::any::Any;\n //~^ ERROR the trait `core::kinds::Sized` is not implemented for the type `str`\n-//~^^ ERROR the trait `core::kinds::Sized` is not implemented for the type `str`\n }"}, {"sha": "f3636edeaa589f0d7a99daf52e6dba040f4ad061", "filename": "src/test/compile-fail/issue-15965.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15965.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -10,7 +10,10 @@\n \n fn main() {\n     return\n-        { return () } //~ ERROR the type of this value must be known in this context\n+        { return () }\n+//~^ ERROR the type of this value must be known in this context\n+//~| ERROR this function takes 1 parameter\n+//~| ERROR mismatched types\n     ()\n     ;\n }"}, {"sha": "c8b3463b0911d9cf74de175f3344ff5c7f59c193", "filename": "src/test/compile-fail/issue-18345.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fissue-18345.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fissue-18345.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18345.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -13,7 +13,9 @@ type Transducer<'t, R, T, U> = |Step<'t, R, U>|: 't -> Step<'t, R, T>;\n \n fn mapping<'f, R, T, U>(f: |T|: 'f -> U) -> &'f Transducer<'f, R, T, U> {\n     |step| |r, x|\n-        step(r, f(x)) //~ ERROR the type of this value must be known in this context\n+        step(r, f(x))\n+        //~^ ERROR the type of this value must be known in this context\n+        //~| ERROR this function takes 1 parameter but 2 parameters were supplied\n }\n \n fn main() {}"}, {"sha": "ec44ab7b27705aa9c2c14fc8693aab3d6dd71b4e", "filename": "src/test/compile-fail/issue-18532.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -17,4 +17,5 @@\n fn main() {\n     (return)((),());\n     //~^ ERROR the type of this value must be known\n+    //~| ERROR this function takes 1 parameter\n }"}, {"sha": "f5740992af48eadba48e8fd4b2103f5b0d684950", "filename": "src/test/compile-fail/kindck-inherited-copy-bound.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-inherited-copy-bound.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -21,10 +21,15 @@ impl<T:Copy> Foo for T {\n \n fn take_param<T:Foo>(foo: &T) { }\n \n-fn main() {\n+fn a() {\n     let x = box 3i;\n     take_param(&x); //~ ERROR `core::kinds::Copy` is not implemented\n+}\n \n+fn b() {\n+    let x = box 3i;\n     let y = &x;\n     let z = &x as &Foo; //~ ERROR `core::kinds::Copy` is not implemented\n }\n+\n+fn main() { }"}, {"sha": "b0b37d077c1709f3d5dfb75614c089aced53abb6", "filename": "src/test/compile-fail/unboxed-closures-unsafe-extern-fn.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -20,9 +20,16 @@ fn call_it<F:Fn(&int)->int>(_: &F, _: int) -> int { 0 }\n fn call_it_mut<F:FnMut(&int)->int>(_: &mut F, _: int) -> int { 0 }\n fn call_it_once<F:FnOnce(&int)->int>(_: F, _: int) -> int { 0 }\n \n-fn main() {\n+fn a() {\n     let x = call_it(&square, 22); //~ ERROR not implemented\n+}\n+\n+fn b() {\n     let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+}\n+\n+fn c() {\n     let z = call_it_once(square, 22); //~ ERROR not implemented\n }\n \n+fn main() { }"}, {"sha": "20a4ab85d7ba8e434688e27333fb15bfde997d58", "filename": "src/test/compile-fail/unboxed-closures-wrong-abi.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -20,9 +20,17 @@ fn call_it<F:Fn(&int)->int>(_: &F, _: int) -> int { 0 }\n fn call_it_mut<F:FnMut(&int)->int>(_: &mut F, _: int) -> int { 0 }\n fn call_it_once<F:FnOnce(&int)->int>(_: F, _: int) -> int { 0 }\n \n-fn main() {\n+fn a() {\n     let x = call_it(&square, 22); //~ ERROR not implemented\n+}\n+\n+fn b() {\n     let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+}\n+\n+fn c() {\n     let z = call_it_once(square, 22); //~ ERROR not implemented\n }\n \n+fn main() { }\n+"}, {"sha": "f08cff3cd682137ac517bda985cff47e5081edf8", "filename": "src/test/compile-fail/unboxed-closures-wrong-arg-type-extern-fn.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -21,9 +21,16 @@ fn call_it<F:Fn(&int)->int>(_: &F, _: int) -> int { 0 }\n fn call_it_mut<F:FnMut(&int)->int>(_: &mut F, _: int) -> int { 0 }\n fn call_it_once<F:FnOnce(&int)->int>(_: F, _: int) -> int { 0 }\n \n-fn main() {\n+fn a() {\n     let x = call_it(&square, 22); //~ ERROR not implemented\n+}\n+\n+fn b() {\n     let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+}\n+\n+fn c() {\n     let z = call_it_once(square, 22); //~ ERROR not implemented\n }\n \n+fn main() { }"}, {"sha": "b6bba363e72365f750f22c11e5aa81ecee8528b5", "filename": "src/test/run-pass/hrtb-opt-in-copy.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Frun-pass%2Fhrtb-opt-in-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd90b936d73c0ea2c261cd8e7b9c43764cb2da05/src%2Ftest%2Frun-pass%2Fhrtb-opt-in-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-opt-in-copy.rs?ref=bd90b936d73c0ea2c261cd8e7b9c43764cb2da05", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we handle binder levels correctly when checking whether a\n+// type can implement `Copy`. In particular, we had a bug where we failed to\n+// liberate the late-bound regions from the impl, and thus wound up\n+// searching for an impl of `for<'tcx> Foo<&'tcx T>`. The impl that\n+// exists however is `impl<T> Copy for Foo<T>` and the current rules\n+// did not consider that a match (something I would like to revise in\n+// a later PR).\n+\n+#![allow(dead_code)]\n+\n+use std::kinds::marker;\n+\n+#[deriving(Copy)]\n+struct Foo<T> { x: T }\n+\n+type Ty<'tcx> = &'tcx TyS<'tcx>;\n+\n+enum TyS<'tcx> {\n+    Boop(marker::InvariantLifetime<'tcx>)\n+}\n+\n+enum Bar<'tcx> {\n+    Baz(Foo<Ty<'tcx>>)\n+}\n+\n+impl<'tcx> Copy for Bar<'tcx> { }\n+\n+fn main() { }"}, {"sha": "78f125398edcba56abd35835abeb38107e8e1e70", "filename": "src/test/run-pass/issue-10501.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fissue-10501.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fissue-10501.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10501.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub type Foo = fn(&int) -> ();\n-#[deriving(Clone)]\n-enum Baz { Bar(Foo) }\n-fn main() {}"}, {"sha": "e41613b4ae3057d4e7f8ad81ecf4b4ce96ca7853", "filename": "src/test/run-pass/issue-12741.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fissue-12741.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efafac398ff7f28c5f0fe756c15b9008b3e0534/src%2Ftest%2Frun-pass%2Fissue-12741.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-12741.rs?ref=0efafac398ff7f28c5f0fe756c15b9008b3e0534", "patch": "@@ -1,35 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[deriving(Clone)]\n-pub struct Foo {\n-    f: fn(char, |char| -> char) -> char\n-}\n-\n-impl Foo {\n-    fn bar(&self) -> char {\n-        ((*self).f)('a', |c: char| c)\n-    }\n-}\n-\n-fn bla(c: char, cb: |char| -> char) -> char {\n-    cb(c)\n-}\n-\n-pub fn make_foo() -> Foo {\n-    Foo {\n-        f: bla\n-    }\n-}\n-\n-fn main() {\n-    let a = make_foo();\n-    assert_eq!(a.bar(), 'a');\n-}"}]}