{"sha": "6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZmFmM2E5Y2I3YjYwMWUzYzRlZDJlNjYxZWQyMTNiOGJjNGQ2Mzk=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-02T21:38:49Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-30T16:09:59Z"}, "message": "Stream the dep-graph to a file.", "tree": {"sha": "31098236937df6c67a6bcddd15c0759c96debf3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31098236937df6c67a6bcddd15c0759c96debf3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "html_url": "https://github.com/rust-lang/rust/commit/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16156fb2787f745e57504197bd7fe38b69c6cbea", "url": "https://api.github.com/repos/rust-lang/rust/commits/16156fb2787f745e57504197bd7fe38b69c6cbea", "html_url": "https://github.com/rust-lang/rust/commit/16156fb2787f745e57504197bd7fe38b69c6cbea"}], "stats": {"total": 1630, "additions": 711, "deletions": 919}, "files": [{"sha": "b5680beae142d503f6afef41bc540a6b0926e4f4", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -40,8 +40,9 @@ use rustc_graphviz as dot;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_middle::dep_graph::debug::{DepNodeFilter, EdgeFilter};\n-use rustc_middle::dep_graph::{DepGraphQuery, DepKind, DepNode, DepNodeExt};\n+use rustc_middle::dep_graph::{\n+    DepGraphQuery, DepKind, DepNode, DepNodeExt, DepNodeFilter, EdgeFilter,\n+};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{sym, Symbol};\n@@ -54,7 +55,7 @@ use std::io::{BufWriter, Write};\n pub fn assert_dep_graph(tcx: TyCtxt<'_>) {\n     tcx.dep_graph.with_ignore(|| {\n         if tcx.sess.opts.debugging_opts.dump_dep_graph {\n-            dump_graph(tcx);\n+            tcx.dep_graph.with_query(dump_graph);\n         }\n \n         if !tcx.sess.opts.debugging_opts.query_dep_graph {\n@@ -200,29 +201,29 @@ fn check_paths<'tcx>(tcx: TyCtxt<'tcx>, if_this_changed: &Sources, then_this_wou\n         }\n         return;\n     }\n-    let query = tcx.dep_graph.query();\n-    for &(_, source_def_id, ref source_dep_node) in if_this_changed {\n-        let dependents = query.transitive_predecessors(source_dep_node);\n-        for &(target_span, ref target_pass, _, ref target_dep_node) in then_this_would_need {\n-            if !dependents.contains(&target_dep_node) {\n-                tcx.sess.span_err(\n-                    target_span,\n-                    &format!(\n-                        \"no path from `{}` to `{}`\",\n-                        tcx.def_path_str(source_def_id),\n-                        target_pass\n-                    ),\n-                );\n-            } else {\n-                tcx.sess.span_err(target_span, \"OK\");\n+    tcx.dep_graph.with_query(|query| {\n+        for &(_, source_def_id, ref source_dep_node) in if_this_changed {\n+            let dependents = query.transitive_predecessors(source_dep_node);\n+            for &(target_span, ref target_pass, _, ref target_dep_node) in then_this_would_need {\n+                if !dependents.contains(&target_dep_node) {\n+                    tcx.sess.span_err(\n+                        target_span,\n+                        &format!(\n+                            \"no path from `{}` to `{}`\",\n+                            tcx.def_path_str(source_def_id),\n+                            target_pass\n+                        ),\n+                    );\n+                } else {\n+                    tcx.sess.span_err(target_span, \"OK\");\n+                }\n             }\n         }\n-    }\n+    });\n }\n \n-fn dump_graph(tcx: TyCtxt<'_>) {\n+fn dump_graph(query: &DepGraphQuery) {\n     let path: String = env::var(\"RUST_DEP_GRAPH\").unwrap_or_else(|_| \"dep_graph\".to_string());\n-    let query = tcx.dep_graph.query();\n \n     let nodes = match env::var(\"RUST_DEP_GRAPH_FILTER\") {\n         Ok(string) => {"}, {"sha": "f089cbcfca6e5f150a2bdc40776eb3ab0d1bbc6f", "filename": "compiler/rustc_incremental/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_incremental%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Flib.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -14,7 +14,7 @@ mod assert_dep_graph;\n pub mod assert_module_sources;\n mod persist;\n \n-pub use assert_dep_graph::assert_dep_graph;\n+use assert_dep_graph::assert_dep_graph;\n pub use persist::copy_cgu_workproduct_to_incr_comp_cache_dir;\n pub use persist::delete_workproduct_files;\n pub use persist::finalize_session_directory;\n@@ -26,4 +26,4 @@ pub use persist::prepare_session_directory;\n pub use persist::save_dep_graph;\n pub use persist::save_work_product_index;\n pub use persist::LoadResult;\n-pub use persist::{load_dep_graph, DepGraphFuture};\n+pub use persist::{build_dep_graph, load_dep_graph, DepGraphFuture};"}, {"sha": "145c168f8c4439242d6871bb9e62367341e6da51", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -14,7 +14,6 @@\n //! the required condition is not met.\n \n use rustc_ast::{self as ast, Attribute, NestedMetaItem};\n-use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -381,39 +380,20 @@ impl DirtyCleanVisitor<'tcx> {\n     fn assert_dirty(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_dirty({:?})\", dep_node);\n \n-        let current_fingerprint = self.get_fingerprint(&dep_node);\n-        let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n-\n-        if current_fingerprint == prev_fingerprint {\n+        if self.tcx.dep_graph.is_green(&dep_node) {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx\n                 .sess\n                 .span_err(item_span, &format!(\"`{}` should be dirty but is not\", dep_node_str));\n         }\n     }\n \n-    fn get_fingerprint(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n-        if self.tcx.dep_graph.dep_node_exists(dep_node) {\n-            let dep_node_index = self.tcx.dep_graph.dep_node_index_of(dep_node);\n-            Some(self.tcx.dep_graph.fingerprint_of(dep_node_index))\n-        } else {\n-            None\n-        }\n-    }\n-\n     fn assert_clean(&self, item_span: Span, dep_node: DepNode) {\n         debug!(\"assert_clean({:?})\", dep_node);\n \n-        let current_fingerprint = self.get_fingerprint(&dep_node);\n-        let prev_fingerprint = self.tcx.dep_graph.prev_fingerprint_of(&dep_node);\n-\n         // if the node wasn't previously evaluated and now is (or vice versa),\n         // then the node isn't actually clean or dirty.\n-        if (current_fingerprint == None) ^ (prev_fingerprint == None) {\n-            return;\n-        }\n-\n-        if current_fingerprint != prev_fingerprint {\n+        if self.tcx.dep_graph.is_red(&dep_node) {\n             let dep_node_str = self.dep_node_str(&dep_node);\n             self.tcx\n                 .sess"}, {"sha": "30c6c408bc7c00f033a830945c6abf7f360e4e58", "filename": "compiler/rustc_incremental/src/persist/fs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffs.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -122,6 +122,7 @@ mod tests;\n \n const LOCK_FILE_EXT: &str = \".lock\";\n const DEP_GRAPH_FILENAME: &str = \"dep-graph.bin\";\n+const STAGING_DEP_GRAPH_FILENAME: &str = \"dep-graph.part.bin\";\n const WORK_PRODUCTS_FILENAME: &str = \"work-products.bin\";\n const QUERY_CACHE_FILENAME: &str = \"query-cache.bin\";\n \n@@ -134,6 +135,9 @@ const INT_ENCODE_BASE: usize = base_n::CASE_INSENSITIVE;\n pub fn dep_graph_path(sess: &Session) -> PathBuf {\n     in_incr_comp_dir_sess(sess, DEP_GRAPH_FILENAME)\n }\n+pub fn staging_dep_graph_path(sess: &Session) -> PathBuf {\n+    in_incr_comp_dir_sess(sess, STAGING_DEP_GRAPH_FILENAME)\n+}\n pub fn dep_graph_path_from(incr_comp_session_dir: &Path) -> PathBuf {\n     in_incr_comp_dir(incr_comp_session_dir, DEP_GRAPH_FILENAME)\n }"}, {"sha": "259e540c6125e15b0bb3c2346b1383d2b4683d34", "filename": "compiler/rustc_incremental/src/persist/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fload.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::definitions::Definitions;\n use rustc_middle::dep_graph::{PreviousDepGraph, SerializedDepGraph, WorkProduct, WorkProductId};\n use rustc_middle::ty::query::OnDiskCache;\n use rustc_serialize::opaque::Decoder;\n-use rustc_serialize::Decodable as RustcDecodable;\n+use rustc_serialize::Decodable;\n use rustc_session::Session;\n use std::path::Path;\n \n@@ -120,7 +120,7 @@ pub fn load_dep_graph(sess: &Session) -> DepGraphFuture {\n             // Decode the list of work_products\n             let mut work_product_decoder = Decoder::new(&work_products_data[..], start_pos);\n             let work_products: Vec<SerializedWorkProduct> =\n-                RustcDecodable::decode(&mut work_product_decoder).unwrap_or_else(|e| {\n+                Decodable::decode(&mut work_product_decoder).unwrap_or_else(|e| {\n                     let msg = format!(\n                         \"Error decoding `work-products` from incremental \\\n                                     compilation session directory: {}\","}, {"sha": "1336189bc0d26118586dcf1f891d2798c95f2005", "filename": "compiler/rustc_incremental/src/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fmod.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -18,6 +18,7 @@ pub use fs::prepare_session_directory;\n pub use load::load_query_result_cache;\n pub use load::LoadResult;\n pub use load::{load_dep_graph, DepGraphFuture};\n+pub use save::build_dep_graph;\n pub use save::save_dep_graph;\n pub use save::save_work_product_index;\n pub use work_product::copy_cgu_workproduct_to_incr_comp_cache_dir;"}, {"sha": "d80397970ac6aa26352249e4c021dc04ac900a38", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 84, "deletions": 23, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -1,6 +1,6 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::join;\n-use rustc_middle::dep_graph::{DepGraph, WorkProduct, WorkProductId};\n+use rustc_middle::dep_graph::{DepGraph, PreviousDepGraph, WorkProduct, WorkProductId};\n use rustc_middle::ty::TyCtxt;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_serialize::Encodable as RustcEncodable;\n@@ -15,6 +15,9 @@ use super::file_format;\n use super::fs::*;\n use super::work_product;\n \n+/// Save and dump the DepGraph.\n+///\n+/// No query must be invoked after this function.\n pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n     debug!(\"save_dep_graph()\");\n     tcx.dep_graph.with_ignore(|| {\n@@ -29,23 +32,43 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n \n         let query_cache_path = query_cache_path(sess);\n         let dep_graph_path = dep_graph_path(sess);\n+        let staging_dep_graph_path = staging_dep_graph_path(sess);\n+\n+        join(\n+            || sess.time(\"assert_dep_graph\", || crate::assert_dep_graph(tcx)),\n+            || sess.time(\"check_dirty_clean\", || dirty_clean::check_dirty_clean_annotations(tcx)),\n+        );\n+\n+        if sess.opts.debugging_opts.incremental_info {\n+            tcx.dep_graph.print_incremental_info()\n+        }\n \n         join(\n             move || {\n                 sess.time(\"incr_comp_persist_result_cache\", || {\n                     save_in(sess, query_cache_path, \"query cache\", |e| encode_query_cache(tcx, e));\n                 });\n             },\n-            || {\n+            move || {\n                 sess.time(\"incr_comp_persist_dep_graph\", || {\n-                    save_in(sess, dep_graph_path, \"dependency graph\", |e| {\n-                        sess.time(\"incr_comp_encode_dep_graph\", || encode_dep_graph(tcx, e))\n-                    });\n+                    if let Err(err) = tcx.dep_graph.encode() {\n+                        sess.err(&format!(\n+                            \"failed to write dependency graph to `{}`: {}\",\n+                            staging_dep_graph_path.display(),\n+                            err\n+                        ));\n+                    }\n+                    if let Err(err) = fs::rename(&staging_dep_graph_path, &dep_graph_path) {\n+                        sess.err(&format!(\n+                            \"failed to move dependency graph from `{}` to `{}`: {}\",\n+                            staging_dep_graph_path.display(),\n+                            dep_graph_path.display(),\n+                            err\n+                        ));\n+                    }\n                 });\n             },\n         );\n-\n-        dirty_clean::check_dirty_clean_annotations(tcx);\n     })\n }\n \n@@ -92,7 +115,7 @@ pub fn save_work_product_index(\n     });\n }\n \n-fn save_in<F>(sess: &Session, path_buf: PathBuf, name: &str, encode: F)\n+pub(crate) fn save_in<F>(sess: &Session, path_buf: PathBuf, name: &str, encode: F)\n where\n     F: FnOnce(&mut FileEncoder) -> FileEncodeResult,\n {\n@@ -144,21 +167,6 @@ where\n     debug!(\"save: data written to disk successfully\");\n }\n \n-fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut FileEncoder) -> FileEncodeResult {\n-    // First encode the commandline arguments hash\n-    tcx.sess.opts.dep_tracking_hash().encode(encoder)?;\n-\n-    if tcx.sess.opts.debugging_opts.incremental_info {\n-        tcx.dep_graph.print_incremental_info();\n-    }\n-\n-    // There is a tiny window between printing the incremental info above and encoding the dep\n-    // graph below in which the dep graph could change, thus making the printed incremental info\n-    // slightly out of date. If this matters to you, please feel free to submit a patch. :)\n-\n-    tcx.sess.time(\"incr_comp_encode_serialized_dep_graph\", || tcx.dep_graph.encode(encoder))\n-}\n-\n fn encode_work_product_index(\n     work_products: &FxHashMap<WorkProductId, WorkProduct>,\n     encoder: &mut FileEncoder,\n@@ -177,3 +185,56 @@ fn encode_work_product_index(\n fn encode_query_cache(tcx: TyCtxt<'_>, encoder: &mut FileEncoder) -> FileEncodeResult {\n     tcx.sess.time(\"incr_comp_serialize_result_cache\", || tcx.serialize_query_result_cache(encoder))\n }\n+\n+pub fn build_dep_graph(\n+    sess: &Session,\n+    prev_graph: PreviousDepGraph,\n+    prev_work_products: FxHashMap<WorkProductId, WorkProduct>,\n+) -> Option<DepGraph> {\n+    if sess.opts.incremental.is_none() {\n+        // No incremental compilation.\n+        return None;\n+    }\n+\n+    // Stream the dep-graph to an alternate file, to avoid overwriting anything in case of errors.\n+    let path_buf = staging_dep_graph_path(sess);\n+\n+    let mut encoder = match FileEncoder::new(&path_buf) {\n+        Ok(encoder) => encoder,\n+        Err(err) => {\n+            sess.err(&format!(\n+                \"failed to create dependency graph at `{}`: {}\",\n+                path_buf.display(),\n+                err\n+            ));\n+            return None;\n+        }\n+    };\n+\n+    if let Err(err) = file_format::write_file_header(&mut encoder, sess.is_nightly_build()) {\n+        sess.err(&format!(\n+            \"failed to write dependency graph header to `{}`: {}\",\n+            path_buf.display(),\n+            err\n+        ));\n+        return None;\n+    }\n+\n+    // First encode the commandline arguments hash\n+    if let Err(err) = sess.opts.dep_tracking_hash().encode(&mut encoder) {\n+        sess.err(&format!(\n+            \"failed to write dependency graph hash `{}`: {}\",\n+            path_buf.display(),\n+            err\n+        ));\n+        return None;\n+    }\n+\n+    Some(DepGraph::new(\n+        prev_graph,\n+        prev_work_products,\n+        encoder,\n+        sess.opts.debugging_opts.query_dep_graph,\n+        sess.opts.debugging_opts.incremental_info,\n+    ))\n+}"}, {"sha": "c693155994f56abfad9e80c7fd897a3188be78ae", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -1021,9 +1021,6 @@ pub fn start_codegen<'tcx>(\n         rustc_symbol_mangling::test::report_symbol_names(tcx);\n     }\n \n-    tcx.sess.time(\"assert_dep_graph\", || rustc_incremental::assert_dep_graph(tcx));\n-    tcx.sess.time(\"serialize_dep_graph\", || rustc_incremental::save_dep_graph(tcx));\n-\n     info!(\"Post-codegen\\n{:?}\", tcx.debug_stats());\n \n     if tcx.sess.opts.output_types.contains_key(&OutputType::Mir) {"}, {"sha": "01853eab530dad437b644270e2f5086354aa7391", "filename": "compiler/rustc_interface/src/queries.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fqueries.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -207,7 +207,13 @@ impl<'tcx> Queries<'tcx> {\n                                 })\n                                 .open(self.session())\n                         });\n-                    DepGraph::new(prev_graph, prev_work_products)\n+\n+                    rustc_incremental::build_dep_graph(\n+                        self.session(),\n+                        prev_graph,\n+                        prev_work_products,\n+                    )\n+                    .unwrap_or_else(DepGraph::new_disabled)\n                 }\n             })\n         })\n@@ -435,6 +441,9 @@ impl Compiler {\n             if self.session().opts.debugging_opts.query_stats {\n                 gcx.enter(rustc_query_impl::print_stats);\n             }\n+\n+            self.session()\n+                .time(\"serialize_dep_graph\", || gcx.enter(rustc_incremental::save_dep_graph));\n         }\n \n         _timer = Some(self.session().timer(\"free_global_ctxt\"));"}, {"sha": "d2fe9af34fb625a8a88ae9e94cd4f89f661ddaec", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -8,8 +8,8 @@ use rustc_session::Session;\n mod dep_node;\n \n pub use rustc_query_system::dep_graph::{\n-    debug, hash_result, DepContext, DepNodeColor, DepNodeIndex, SerializedDepNodeIndex,\n-    WorkProduct, WorkProductId,\n+    debug::DepNodeFilter, hash_result, DepContext, DepNodeColor, DepNodeIndex,\n+    SerializedDepNodeIndex, WorkProduct, WorkProductId,\n };\n \n crate use dep_node::make_compile_codegen_unit;\n@@ -20,6 +20,7 @@ pub type TaskDeps = rustc_query_system::dep_graph::TaskDeps<DepKind>;\n pub type DepGraphQuery = rustc_query_system::dep_graph::DepGraphQuery<DepKind>;\n pub type PreviousDepGraph = rustc_query_system::dep_graph::PreviousDepGraph<DepKind>;\n pub type SerializedDepGraph = rustc_query_system::dep_graph::SerializedDepGraph<DepKind>;\n+pub type EdgeFilter = rustc_query_system::dep_graph::debug::EdgeFilter<DepKind>;\n \n impl rustc_query_system::dep_graph::DepKind for DepKind {\n     const NULL: Self = DepKind::Null;"}, {"sha": "4194b28dc7d681fc485c0e765a55430a7745f6dc", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -477,10 +477,7 @@ macro_rules! define_queries {\n                         return\n                     }\n \n-                    debug_assert!(tcx.dep_graph\n-                                     .node_color(dep_node)\n-                                     .map(|c| c.is_green())\n-                                     .unwrap_or(false));\n+                    debug_assert!(tcx.dep_graph.is_green(dep_node));\n \n                     let key = recover(*tcx, dep_node).unwrap_or_else(|| panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash));\n                     if queries::$name::cache_on_disk(tcx, &key, None) {"}, {"sha": "a544ac2c343aeeab2d5fbd4e9e60061a1f88cdd0", "filename": "compiler/rustc_query_system/src/dep_graph/debug.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fdebug.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -1,6 +1,8 @@\n //! Code for debugging the dep-graph.\n \n-use super::{DepKind, DepNode};\n+use super::{DepKind, DepNode, DepNodeIndex};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lock;\n use std::error::Error;\n \n /// A dep-node filter goes from a user-defined string to a query over\n@@ -34,26 +36,28 @@ impl DepNodeFilter {\n \n /// A filter like `F -> G` where `F` and `G` are valid dep-node\n /// filters. This can be used to test the source/target independently.\n-pub struct EdgeFilter {\n+pub struct EdgeFilter<K: DepKind> {\n     pub source: DepNodeFilter,\n     pub target: DepNodeFilter,\n+    pub index_to_node: Lock<FxHashMap<DepNodeIndex, DepNode<K>>>,\n }\n \n-impl EdgeFilter {\n-    pub fn new(test: &str) -> Result<EdgeFilter, Box<dyn Error>> {\n+impl<K: DepKind> EdgeFilter<K> {\n+    pub fn new(test: &str) -> Result<EdgeFilter<K>, Box<dyn Error>> {\n         let parts: Vec<_> = test.split(\"->\").collect();\n         if parts.len() != 2 {\n             Err(format!(\"expected a filter like `a&b -> c&d`, not `{}`\", test).into())\n         } else {\n             Ok(EdgeFilter {\n                 source: DepNodeFilter::new(parts[0]),\n                 target: DepNodeFilter::new(parts[1]),\n+                index_to_node: Lock::new(FxHashMap::default()),\n             })\n         }\n     }\n \n     #[cfg(debug_assertions)]\n-    pub fn test<K: DepKind>(&self, source: &DepNode<K>, target: &DepNode<K>) -> bool {\n+    pub fn test(&self, source: &DepNode<K>, target: &DepNode<K>) -> bool {\n         self.source.test(source) && self.target.test(target)\n     }\n }"}, {"sha": "295b2a97e4cf496a146f7133a5073c2429b2b3d7", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 188, "deletions": 734, "changes": 922, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -3,29 +3,30 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::profiling::QueryInvocationId;\n use rustc_data_structures::sharded::{self, Sharded};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, LockGuard, Lrc, Ordering};\n+use rustc_data_structures::steal::Steal;\n+use rustc_data_structures::sync::{AtomicU32, AtomicU64, Lock, Lrc, Ordering};\n use rustc_data_structures::unlikely;\n use rustc_errors::Diagnostic;\n-use rustc_index::vec::{Idx, IndexVec};\n-use rustc_serialize::{Encodable, Encoder};\n+use rustc_index::vec::IndexVec;\n+use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n \n use parking_lot::{Condvar, Mutex};\n use smallvec::{smallvec, SmallVec};\n use std::collections::hash_map::Entry;\n-use std::env;\n use std::hash::Hash;\n use std::marker::PhantomData;\n use std::mem;\n-use std::ops::Range;\n use std::sync::atomic::Ordering::Relaxed;\n \n-use super::debug::EdgeFilter;\n use super::prev::PreviousDepGraph;\n use super::query::DepGraphQuery;\n-use super::serialized::SerializedDepNodeIndex;\n+use super::serialized::{GraphEncoder, SerializedDepNodeIndex};\n use super::{DepContext, DepKind, DepNode, HasDepContext, WorkProductId};\n use crate::query::QueryContext;\n \n+#[cfg(debug_assertions)]\n+use {super::debug::EdgeFilter, std::env};\n+\n #[derive(Clone)]\n pub struct DepGraph<K: DepKind> {\n     data: Option<Lrc<DepGraphData<K>>>,\n@@ -109,14 +110,22 @@ impl<K: DepKind> DepGraph<K> {\n     pub fn new(\n         prev_graph: PreviousDepGraph<K>,\n         prev_work_products: FxHashMap<WorkProductId, WorkProduct>,\n+        encoder: FileEncoder,\n+        record_graph: bool,\n+        record_stats: bool,\n     ) -> DepGraph<K> {\n         let prev_graph_node_count = prev_graph.node_count();\n \n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: prev_work_products,\n                 dep_node_debug: Default::default(),\n-                current: CurrentDepGraph::new(prev_graph_node_count),\n+                current: CurrentDepGraph::new(\n+                    prev_graph_node_count,\n+                    encoder,\n+                    record_graph,\n+                    record_stats,\n+                ),\n                 emitting_diagnostics: Default::default(),\n                 emitting_diagnostics_cond_var: Condvar::new(),\n                 previous: prev_graph,\n@@ -136,62 +145,10 @@ impl<K: DepKind> DepGraph<K> {\n         self.data.is_some()\n     }\n \n-    pub fn query(&self) -> DepGraphQuery<K> {\n-        let data = self.data.as_ref().unwrap();\n-        let previous = &data.previous;\n-\n-        // Note locking order: `prev_index_to_index`, then `data`.\n-        let prev_index_to_index = data.current.prev_index_to_index.lock();\n-        let data = data.current.data.lock();\n-        let node_count = data.hybrid_indices.len();\n-        let edge_count = self.edge_count(&data);\n-\n-        let mut nodes = Vec::with_capacity(node_count);\n-        let mut edge_list_indices = Vec::with_capacity(node_count);\n-        let mut edge_list_data = Vec::with_capacity(edge_count);\n-\n-        // See `DepGraph`'s `Encodable` implementation for notes on the approach used here.\n-\n-        edge_list_data.extend(data.unshared_edges.iter().map(|i| i.index()));\n-\n-        for &hybrid_index in data.hybrid_indices.iter() {\n-            match hybrid_index.into() {\n-                HybridIndex::New(new_index) => {\n-                    nodes.push(data.new.nodes[new_index]);\n-                    let edges = &data.new.edges[new_index];\n-                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n-                }\n-                HybridIndex::Red(red_index) => {\n-                    nodes.push(previous.index_to_node(data.red.node_indices[red_index]));\n-                    let edges = &data.red.edges[red_index];\n-                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n-                }\n-                HybridIndex::LightGreen(lg_index) => {\n-                    nodes.push(previous.index_to_node(data.light_green.node_indices[lg_index]));\n-                    let edges = &data.light_green.edges[lg_index];\n-                    edge_list_indices.push((edges.start.index(), edges.end.index()));\n-                }\n-                HybridIndex::DarkGreen(prev_index) => {\n-                    nodes.push(previous.index_to_node(prev_index));\n-\n-                    let edges_iter = previous\n-                        .edge_targets_from(prev_index)\n-                        .iter()\n-                        .map(|&dst| prev_index_to_index[dst].unwrap().index());\n-\n-                    let start = edge_list_data.len();\n-                    edge_list_data.extend(edges_iter);\n-                    let end = edge_list_data.len();\n-                    edge_list_indices.push((start, end));\n-                }\n-            }\n+    pub fn with_query(&self, f: impl Fn(&DepGraphQuery<K>)) {\n+        if let Some(data) = &self.data {\n+            data.current.encoder.borrow().with_query(f)\n         }\n-\n-        debug_assert_eq!(nodes.len(), node_count);\n-        debug_assert_eq!(edge_list_indices.len(), node_count);\n-        debug_assert_eq!(edge_list_data.len(), edge_count);\n-\n-        DepGraphQuery::new(&nodes[..], &edge_list_indices[..], &edge_list_data[..])\n     }\n \n     pub fn assert_ignored(&self) {\n@@ -283,56 +240,15 @@ impl<K: DepKind> DepGraph<K> {\n             let print_status = cfg!(debug_assertions) && dcx.sess().opts.debugging_opts.dep_tasks;\n \n             // Intern the new `DepNode`.\n-            let dep_node_index = if let Some(prev_index) = data.previous.node_to_index_opt(&key) {\n-                // Determine the color and index of the new `DepNode`.\n-                let (color, dep_node_index) = if let Some(current_fingerprint) = current_fingerprint\n-                {\n-                    if current_fingerprint == data.previous.fingerprint_by_index(prev_index) {\n-                        if print_status {\n-                            eprintln!(\"[task::green] {:?}\", key);\n-                        }\n-\n-                        // This is a light green node: it existed in the previous compilation,\n-                        // its query was re-executed, and it has the same result as before.\n-                        let dep_node_index =\n-                            data.current.intern_light_green_node(&data.previous, prev_index, edges);\n-\n-                        (DepNodeColor::Green(dep_node_index), dep_node_index)\n-                    } else {\n-                        if print_status {\n-                            eprintln!(\"[task::red] {:?}\", key);\n-                        }\n-\n-                        // This is a red node: it existed in the previous compilation, its query\n-                        // was re-executed, but it has a different result from before.\n-                        let dep_node_index = data.current.intern_red_node(\n-                            &data.previous,\n-                            prev_index,\n-                            edges,\n-                            current_fingerprint,\n-                        );\n-\n-                        (DepNodeColor::Red, dep_node_index)\n-                    }\n-                } else {\n-                    if print_status {\n-                        eprintln!(\"[task::unknown] {:?}\", key);\n-                    }\n-\n-                    // This is a red node, effectively: it existed in the previous compilation\n-                    // session, its query was re-executed, but it doesn't compute a result hash\n-                    // (i.e. it represents a `no_hash` query), so we have no way of determining\n-                    // whether or not the result was the same as before.\n-                    let dep_node_index = data.current.intern_red_node(\n-                        &data.previous,\n-                        prev_index,\n-                        edges,\n-                        Fingerprint::ZERO,\n-                    );\n-\n-                    (DepNodeColor::Red, dep_node_index)\n-                };\n+            let (dep_node_index, prev_and_color) = data.current.intern_node(\n+                &data.previous,\n+                key,\n+                edges,\n+                current_fingerprint,\n+                print_status,\n+            );\n \n+            if let Some((prev_index, color)) = prev_and_color {\n                 debug_assert!(\n                     data.colors.get(prev_index).is_none(),\n                     \"DepGraph::with_task() - Duplicate DepNodeColor \\\n@@ -341,20 +257,7 @@ impl<K: DepKind> DepGraph<K> {\n                 );\n \n                 data.colors.insert(prev_index, color);\n-                dep_node_index\n-            } else {\n-                if print_status {\n-                    eprintln!(\"[task::new] {:?}\", key);\n-                }\n-\n-                // This is a new node: it didn't exist in the previous compilation session.\n-                data.current.intern_new_node(\n-                    &data.previous,\n-                    key,\n-                    edges,\n-                    current_fingerprint.unwrap_or(Fingerprint::ZERO),\n-                )\n-            };\n+            }\n \n             (result, dep_node_index)\n         } else {\n@@ -395,12 +298,8 @@ impl<K: DepKind> DepGraph<K> {\n                 hash: data.current.anon_id_seed.combine(hasher.finish()).into(),\n             };\n \n-            let dep_node_index = data.current.intern_new_node(\n-                &data.previous,\n-                target_dep_node,\n-                task_deps.reads,\n-                Fingerprint::ZERO,\n-            );\n+            let dep_node_index =\n+                data.current.intern_new_node(target_dep_node, task_deps.reads, Fingerprint::ZERO);\n \n             (result, dep_node_index)\n         } else {\n@@ -451,7 +350,7 @@ impl<K: DepKind> DepGraph<K> {\n                         {\n                             if let Some(target) = task_deps.node {\n                                 if let Some(ref forbidden_edge) = data.current.forbidden_edge {\n-                                    let src = self.dep_node_of(dep_node_index);\n+                                    let src = forbidden_edge.index_to_node.lock()[&dep_node_index];\n                                     if forbidden_edge.test(&src, &target) {\n                                         panic!(\"forbidden edge {:?} -> {:?} created\", src, target)\n                                     }\n@@ -488,38 +387,6 @@ impl<K: DepKind> DepGraph<K> {\n         self.data.is_some() && self.dep_node_index_of_opt(dep_node).is_some()\n     }\n \n-    #[cfg(debug_assertions)]\n-    fn dep_node_of(&self, dep_node_index: DepNodeIndex) -> DepNode<K> {\n-        let data = self.data.as_ref().unwrap();\n-        let previous = &data.previous;\n-        let data = data.current.data.lock();\n-\n-        match data.hybrid_indices[dep_node_index].into() {\n-            HybridIndex::New(new_index) => data.new.nodes[new_index],\n-            HybridIndex::Red(red_index) => previous.index_to_node(data.red.node_indices[red_index]),\n-            HybridIndex::LightGreen(light_green_index) => {\n-                previous.index_to_node(data.light_green.node_indices[light_green_index])\n-            }\n-            HybridIndex::DarkGreen(prev_index) => previous.index_to_node(prev_index),\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn fingerprint_of(&self, dep_node_index: DepNodeIndex) -> Fingerprint {\n-        let data = self.data.as_ref().unwrap();\n-        let previous = &data.previous;\n-        let data = data.current.data.lock();\n-\n-        match data.hybrid_indices[dep_node_index].into() {\n-            HybridIndex::New(new_index) => data.new.fingerprints[new_index],\n-            HybridIndex::Red(red_index) => data.red.fingerprints[red_index],\n-            HybridIndex::LightGreen(light_green_index) => {\n-                previous.fingerprint_by_index(data.light_green.node_indices[light_green_index])\n-            }\n-            HybridIndex::DarkGreen(prev_index) => previous.fingerprint_by_index(prev_index),\n-        }\n-    }\n-\n     pub fn prev_fingerprint_of(&self, dep_node: &DepNode<K>) -> Option<Fingerprint> {\n         self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n     }\n@@ -554,29 +421,13 @@ impl<K: DepKind> DepGraph<K> {\n         self.data.as_ref()?.dep_node_debug.borrow().get(&dep_node).cloned()\n     }\n \n-    fn edge_count(&self, node_data: &LockGuard<'_, DepNodeData<K>>) -> usize {\n-        let data = self.data.as_ref().unwrap();\n-        let previous = &data.previous;\n-\n-        let mut edge_count = node_data.unshared_edges.len();\n-\n-        for &hybrid_index in node_data.hybrid_indices.iter() {\n-            if let HybridIndex::DarkGreen(prev_index) = hybrid_index.into() {\n-                edge_count += previous.edge_targets_from(prev_index).len()\n-            }\n-        }\n-\n-        edge_count\n-    }\n-\n-    pub fn node_color(&self, dep_node: &DepNode<K>) -> Option<DepNodeColor> {\n+    fn node_color(&self, dep_node: &DepNode<K>) -> Option<DepNodeColor> {\n         if let Some(ref data) = self.data {\n             if let Some(prev_index) = data.previous.node_to_index_opt(dep_node) {\n                 return data.colors.get(prev_index);\n             } else {\n-                // This is a node that did not exist in the previous compilation\n-                // session, so we consider it to be red.\n-                return Some(DepNodeColor::Red);\n+                // This is a node that did not exist in the previous compilation session.\n+                return None;\n             }\n         }\n \n@@ -862,6 +713,12 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n+    // Returns true if the given node has been marked as green during the\n+    // current compilation session. Used in various assertions\n+    pub fn is_red(&self, dep_node: &DepNode<K>) -> bool {\n+        self.node_color(dep_node) == Some(DepNodeColor::Red)\n+    }\n+\n     // Returns true if the given node has been marked as green during the\n     // current compilation session. Used in various assertions\n     pub fn is_green(&self, dep_node: &DepNode<K>) -> bool {\n@@ -911,106 +768,16 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     pub fn print_incremental_info(&self) {\n-        #[derive(Clone)]\n-        struct Stat<Kind: DepKind> {\n-            kind: Kind,\n-            node_counter: u64,\n-            edge_counter: u64,\n-        }\n-\n-        let data = self.data.as_ref().unwrap();\n-        let prev = &data.previous;\n-        let current = &data.current;\n-        let data = current.data.lock();\n-\n-        let mut stats: FxHashMap<_, Stat<K>> = FxHashMap::with_hasher(Default::default());\n-\n-        for &hybrid_index in data.hybrid_indices.iter() {\n-            let (kind, edge_count) = match hybrid_index.into() {\n-                HybridIndex::New(new_index) => {\n-                    let kind = data.new.nodes[new_index].kind;\n-                    let edge_range = &data.new.edges[new_index];\n-                    (kind, edge_range.end.as_usize() - edge_range.start.as_usize())\n-                }\n-                HybridIndex::Red(red_index) => {\n-                    let kind = prev.index_to_node(data.red.node_indices[red_index]).kind;\n-                    let edge_range = &data.red.edges[red_index];\n-                    (kind, edge_range.end.as_usize() - edge_range.start.as_usize())\n-                }\n-                HybridIndex::LightGreen(lg_index) => {\n-                    let kind = prev.index_to_node(data.light_green.node_indices[lg_index]).kind;\n-                    let edge_range = &data.light_green.edges[lg_index];\n-                    (kind, edge_range.end.as_usize() - edge_range.start.as_usize())\n-                }\n-                HybridIndex::DarkGreen(prev_index) => {\n-                    let kind = prev.index_to_node(prev_index).kind;\n-                    let edge_count = prev.edge_targets_from(prev_index).len();\n-                    (kind, edge_count)\n-                }\n-            };\n-\n-            let stat = stats.entry(kind).or_insert(Stat { kind, node_counter: 0, edge_counter: 0 });\n-            stat.node_counter += 1;\n-            stat.edge_counter += edge_count as u64;\n-        }\n-\n-        let total_node_count = data.hybrid_indices.len();\n-        let total_edge_count = self.edge_count(&data);\n-\n-        // Drop the lock guard.\n-        std::mem::drop(data);\n-\n-        let mut stats: Vec<_> = stats.values().cloned().collect();\n-        stats.sort_by_key(|s| -(s.node_counter as i64));\n-\n-        const SEPARATOR: &str = \"[incremental] --------------------------------\\\n-                                 ----------------------------------------------\\\n-                                 ------------\";\n-\n-        eprintln!(\"[incremental]\");\n-        eprintln!(\"[incremental] DepGraph Statistics\");\n-        eprintln!(\"{}\", SEPARATOR);\n-        eprintln!(\"[incremental]\");\n-        eprintln!(\"[incremental] Total Node Count: {}\", total_node_count);\n-        eprintln!(\"[incremental] Total Edge Count: {}\", total_edge_count);\n-\n-        if cfg!(debug_assertions) {\n-            let total_edge_reads = current.total_read_count.load(Relaxed);\n-            let total_duplicate_edge_reads = current.total_duplicate_read_count.load(Relaxed);\n-\n-            eprintln!(\"[incremental] Total Edge Reads: {}\", total_edge_reads);\n-            eprintln!(\"[incremental] Total Duplicate Edge Reads: {}\", total_duplicate_edge_reads);\n-        }\n-\n-        eprintln!(\"[incremental]\");\n-\n-        eprintln!(\n-            \"[incremental]  {:<36}| {:<17}| {:<12}| {:<17}|\",\n-            \"Node Kind\", \"Node Frequency\", \"Node Count\", \"Avg. Edge Count\"\n-        );\n-\n-        eprintln!(\n-            \"[incremental] -------------------------------------\\\n-                  |------------------\\\n-                  |-------------\\\n-                  |------------------|\"\n-        );\n-\n-        for stat in stats {\n-            let node_kind_ratio = (100.0 * (stat.node_counter as f64)) / (total_node_count as f64);\n-            let node_kind_avg_edges = (stat.edge_counter as f64) / (stat.node_counter as f64);\n-\n-            eprintln!(\n-                \"[incremental]  {:<36}|{:>16.1}% |{:>12} |{:>17.1} |\",\n-                format!(\"{:?}\", stat.kind),\n-                node_kind_ratio,\n-                stat.node_counter,\n-                node_kind_avg_edges,\n-            );\n+        if let Some(data) = &self.data {\n+            data.current.encoder.borrow().print_incremental_info(\n+                data.current.total_read_count.load(Relaxed),\n+                data.current.total_duplicate_read_count.load(Relaxed),\n+            )\n         }\n+    }\n \n-        eprintln!(\"{}\", SEPARATOR);\n-        eprintln!(\"[incremental]\");\n+    pub fn encode(&self) -> FileEncodeResult {\n+        if let Some(data) = &self.data { data.current.encoder.steal().finish() } else { Ok(()) }\n     }\n \n     fn next_virtual_depnode_index(&self) -> DepNodeIndex {\n@@ -1019,142 +786,6 @@ impl<K: DepKind> DepGraph<K> {\n     }\n }\n \n-impl<E: Encoder, K: DepKind + Encodable<E>> Encodable<E> for DepGraph<K> {\n-    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        // We used to serialize the dep graph by creating and serializing a `SerializedDepGraph`\n-        // using data copied from the `DepGraph`. But copying created a large memory spike, so we\n-        // now serialize directly from the `DepGraph` as if it's a `SerializedDepGraph`. Because we\n-        // deserialize that data into a `SerializedDepGraph` in the next compilation session, we\n-        // need `DepGraph`'s `Encodable` and `SerializedDepGraph`'s `Decodable` implementations to\n-        // be in sync. If you update this encoding, be sure to update the decoding, and vice-versa.\n-\n-        let data = self.data.as_ref().unwrap();\n-        let prev = &data.previous;\n-\n-        // Note locking order: `prev_index_to_index`, then `data`.\n-        let prev_index_to_index = data.current.prev_index_to_index.lock();\n-        let data = data.current.data.lock();\n-        let new = &data.new;\n-        let red = &data.red;\n-        let lg = &data.light_green;\n-\n-        let node_count = data.hybrid_indices.len();\n-        let edge_count = self.edge_count(&data);\n-\n-        // `rustc_middle::ty::query::OnDiskCache` expects nodes to be encoded in `DepNodeIndex`\n-        // order. The edges in `edge_list_data` don't need to be in a particular order, as long as\n-        // each node references its edges as a contiguous range within it. Therefore, we can encode\n-        // `edge_list_data` directly from `unshared_edges`. It meets the above requirements, as\n-        // each non-dark-green node already knows the range of edges to reference within it, which\n-        // they'll encode in `edge_list_indices`. Dark green nodes, however, don't have their edges\n-        // in `unshared_edges`, so need to add them to `edge_list_data`.\n-\n-        use HybridIndex::*;\n-\n-        // Encoded values (nodes, etc.) are explicitly typed below to avoid inadvertently\n-        // serializing data in the wrong format (i.e. one incompatible with `SerializedDepGraph`).\n-        e.emit_struct(\"SerializedDepGraph\", 4, |e| {\n-            e.emit_struct_field(\"nodes\", 0, |e| {\n-                // `SerializedDepGraph` expects this to be encoded as a sequence of `DepNode`s.\n-                e.emit_seq(node_count, |e| {\n-                    for (seq_index, &hybrid_index) in data.hybrid_indices.iter().enumerate() {\n-                        let node: DepNode<K> = match hybrid_index.into() {\n-                            New(i) => new.nodes[i],\n-                            Red(i) => prev.index_to_node(red.node_indices[i]),\n-                            LightGreen(i) => prev.index_to_node(lg.node_indices[i]),\n-                            DarkGreen(prev_index) => prev.index_to_node(prev_index),\n-                        };\n-\n-                        e.emit_seq_elt(seq_index, |e| node.encode(e))?;\n-                    }\n-\n-                    Ok(())\n-                })\n-            })?;\n-\n-            e.emit_struct_field(\"fingerprints\", 1, |e| {\n-                // `SerializedDepGraph` expects this to be encoded as a sequence of `Fingerprints`s.\n-                e.emit_seq(node_count, |e| {\n-                    for (seq_index, &hybrid_index) in data.hybrid_indices.iter().enumerate() {\n-                        let fingerprint: Fingerprint = match hybrid_index.into() {\n-                            New(i) => new.fingerprints[i],\n-                            Red(i) => red.fingerprints[i],\n-                            LightGreen(i) => prev.fingerprint_by_index(lg.node_indices[i]),\n-                            DarkGreen(prev_index) => prev.fingerprint_by_index(prev_index),\n-                        };\n-\n-                        e.emit_seq_elt(seq_index, |e| fingerprint.encode(e))?;\n-                    }\n-\n-                    Ok(())\n-                })\n-            })?;\n-\n-            e.emit_struct_field(\"edge_list_indices\", 2, |e| {\n-                // `SerializedDepGraph` expects this to be encoded as a sequence of `(u32, u32)`s.\n-                e.emit_seq(node_count, |e| {\n-                    // Dark green node edges start after the unshared (all other nodes') edges.\n-                    let mut dark_green_edge_index = data.unshared_edges.len();\n-\n-                    for (seq_index, &hybrid_index) in data.hybrid_indices.iter().enumerate() {\n-                        let edge_indices: (u32, u32) = match hybrid_index.into() {\n-                            New(i) => (new.edges[i].start.as_u32(), new.edges[i].end.as_u32()),\n-                            Red(i) => (red.edges[i].start.as_u32(), red.edges[i].end.as_u32()),\n-                            LightGreen(i) => (lg.edges[i].start.as_u32(), lg.edges[i].end.as_u32()),\n-                            DarkGreen(prev_index) => {\n-                                let edge_count = prev.edge_targets_from(prev_index).len();\n-                                let start = dark_green_edge_index as u32;\n-                                dark_green_edge_index += edge_count;\n-                                let end = dark_green_edge_index as u32;\n-                                (start, end)\n-                            }\n-                        };\n-\n-                        e.emit_seq_elt(seq_index, |e| edge_indices.encode(e))?;\n-                    }\n-\n-                    assert_eq!(dark_green_edge_index, edge_count);\n-\n-                    Ok(())\n-                })\n-            })?;\n-\n-            e.emit_struct_field(\"edge_list_data\", 3, |e| {\n-                // `SerializedDepGraph` expects this to be encoded as a sequence of\n-                // `SerializedDepNodeIndex`.\n-                e.emit_seq(edge_count, |e| {\n-                    for (seq_index, &edge) in data.unshared_edges.iter().enumerate() {\n-                        let serialized_edge = SerializedDepNodeIndex::new(edge.index());\n-                        e.emit_seq_elt(seq_index, |e| serialized_edge.encode(e))?;\n-                    }\n-\n-                    let mut seq_index = data.unshared_edges.len();\n-\n-                    for &hybrid_index in data.hybrid_indices.iter() {\n-                        if let DarkGreen(prev_index) = hybrid_index.into() {\n-                            for &edge in prev.edge_targets_from(prev_index) {\n-                                // Dark green node edges are stored in the previous graph\n-                                // and must be converted to edges in the current graph,\n-                                // and then serialized as `SerializedDepNodeIndex`.\n-                                let serialized_edge = SerializedDepNodeIndex::new(\n-                                    prev_index_to_index[edge].as_ref().unwrap().index(),\n-                                );\n-\n-                                e.emit_seq_elt(seq_index, |e| serialized_edge.encode(e))?;\n-                                seq_index += 1;\n-                            }\n-                        }\n-                    }\n-\n-                    assert_eq!(seq_index, edge_count);\n-\n-                    Ok(())\n-                })\n-            })\n-        })\n-    }\n-}\n-\n /// A \"work product\" is an intermediate result that we save into the\n /// incremental directory for later re-use. The primary example are\n /// the object files that we save for each partition at code\n@@ -1193,201 +824,11 @@ pub struct WorkProduct {\n     pub saved_file: Option<String>,\n }\n \n-// The maximum value of the follow index types leaves the upper two bits unused\n-// so that we can store multiple index types in `CompressedHybridIndex`, and use\n-// those bits to encode which index type it contains.\n-\n-// Index type for `NewDepNodeData`.\n-rustc_index::newtype_index! {\n-    struct NewDepNodeIndex {\n-        MAX = 0x7FFF_FFFF\n-    }\n-}\n-\n-// Index type for `RedDepNodeData`.\n-rustc_index::newtype_index! {\n-    struct RedDepNodeIndex {\n-        MAX = 0x7FFF_FFFF\n-    }\n-}\n-\n-// Index type for `LightGreenDepNodeData`.\n-rustc_index::newtype_index! {\n-    struct LightGreenDepNodeIndex {\n-        MAX = 0x7FFF_FFFF\n-    }\n-}\n-\n-/// Compressed representation of `HybridIndex` enum. Bits unused by the\n-/// contained index types are used to encode which index type it contains.\n-#[derive(Copy, Clone)]\n-struct CompressedHybridIndex(u32);\n-\n-impl CompressedHybridIndex {\n-    const NEW_TAG: u32 = 0b0000_0000_0000_0000_0000_0000_0000_0000;\n-    const RED_TAG: u32 = 0b0100_0000_0000_0000_0000_0000_0000_0000;\n-    const LIGHT_GREEN_TAG: u32 = 0b1000_0000_0000_0000_0000_0000_0000_0000;\n-    const DARK_GREEN_TAG: u32 = 0b1100_0000_0000_0000_0000_0000_0000_0000;\n-\n-    const TAG_MASK: u32 = 0b1100_0000_0000_0000_0000_0000_0000_0000;\n-    const INDEX_MASK: u32 = !Self::TAG_MASK;\n-}\n-\n-impl From<NewDepNodeIndex> for CompressedHybridIndex {\n-    #[inline]\n-    fn from(index: NewDepNodeIndex) -> Self {\n-        CompressedHybridIndex(Self::NEW_TAG | index.as_u32())\n-    }\n-}\n-\n-impl From<RedDepNodeIndex> for CompressedHybridIndex {\n-    #[inline]\n-    fn from(index: RedDepNodeIndex) -> Self {\n-        CompressedHybridIndex(Self::RED_TAG | index.as_u32())\n-    }\n-}\n-\n-impl From<LightGreenDepNodeIndex> for CompressedHybridIndex {\n-    #[inline]\n-    fn from(index: LightGreenDepNodeIndex) -> Self {\n-        CompressedHybridIndex(Self::LIGHT_GREEN_TAG | index.as_u32())\n-    }\n-}\n-\n-impl From<SerializedDepNodeIndex> for CompressedHybridIndex {\n-    #[inline]\n-    fn from(index: SerializedDepNodeIndex) -> Self {\n-        CompressedHybridIndex(Self::DARK_GREEN_TAG | index.as_u32())\n-    }\n-}\n-\n-/// Contains an index into one of several node data collections. Elsewhere, we\n-/// store `CompressedHyridIndex` instead of this to save space, but convert to\n-/// this type during processing to take advantage of the enum match ergonomics.\n-enum HybridIndex {\n-    New(NewDepNodeIndex),\n-    Red(RedDepNodeIndex),\n-    LightGreen(LightGreenDepNodeIndex),\n-    DarkGreen(SerializedDepNodeIndex),\n-}\n-\n-impl From<CompressedHybridIndex> for HybridIndex {\n-    #[inline]\n-    fn from(hybrid_index: CompressedHybridIndex) -> Self {\n-        let index = hybrid_index.0 & CompressedHybridIndex::INDEX_MASK;\n-\n-        match hybrid_index.0 & CompressedHybridIndex::TAG_MASK {\n-            CompressedHybridIndex::NEW_TAG => HybridIndex::New(NewDepNodeIndex::from_u32(index)),\n-            CompressedHybridIndex::RED_TAG => HybridIndex::Red(RedDepNodeIndex::from_u32(index)),\n-            CompressedHybridIndex::LIGHT_GREEN_TAG => {\n-                HybridIndex::LightGreen(LightGreenDepNodeIndex::from_u32(index))\n-            }\n-            CompressedHybridIndex::DARK_GREEN_TAG => {\n-                HybridIndex::DarkGreen(SerializedDepNodeIndex::from_u32(index))\n-            }\n-            _ => unreachable!(),\n-        }\n-    }\n-}\n-\n // Index type for `DepNodeData`'s edges.\n rustc_index::newtype_index! {\n     struct EdgeIndex { .. }\n }\n \n-/// Data for nodes in the current graph, divided into different collections\n-/// based on their presence in the previous graph, and if present, their color.\n-/// We divide nodes this way because different types of nodes are able to share\n-/// more or less data with the previous graph.\n-///\n-/// To enable more sharing, we distinguish between two kinds of green nodes.\n-/// Light green nodes are nodes in the previous graph that have been marked\n-/// green because we re-executed their queries and the results were the same as\n-/// in the previous session. Dark green nodes are nodes in the previous graph\n-/// that have been marked green because we were able to mark all of their\n-/// dependencies green.\n-///\n-/// Both light and dark green nodes can share the dep node and fingerprint with\n-/// the previous graph, but for light green nodes, we can't be sure that the\n-/// edges may be shared without comparing them against the previous edges, so we\n-/// store them directly (an approach in which we compare edges with the previous\n-/// edges to see if they can be shared was evaluated, but was not found to be\n-/// very profitable).\n-///\n-/// For dark green nodes, we can share everything with the previous graph, which\n-/// is why the `HybridIndex::DarkGreen` enum variant contains the index of the\n-/// node in the previous graph, and why we don't have a separate collection for\n-/// dark green node data--the collection is the `PreviousDepGraph` itself.\n-///\n-/// (Note that for dark green nodes, the edges in the previous graph\n-/// (`SerializedDepNodeIndex`s) must be converted to edges in the current graph\n-/// (`DepNodeIndex`s). `CurrentDepGraph` contains `prev_index_to_index`, which\n-/// can perform this conversion. It should always be possible, as by definition,\n-/// a dark green node is one whose dependencies from the previous session have\n-/// all been marked green--which means `prev_index_to_index` contains them.)\n-///\n-/// Node data is stored in parallel vectors to eliminate the padding between\n-/// elements that would be needed to satisfy alignment requirements of the\n-/// structure that would contain all of a node's data. We could group tightly\n-/// packing subsets of node data together and use fewer vectors, but for\n-/// consistency's sake, we use separate vectors for each piece of data.\n-struct DepNodeData<K> {\n-    /// Data for nodes not in previous graph.\n-    new: NewDepNodeData<K>,\n-\n-    /// Data for nodes in previous graph that have been marked red.\n-    red: RedDepNodeData,\n-\n-    /// Data for nodes in previous graph that have been marked light green.\n-    light_green: LightGreenDepNodeData,\n-\n-    // Edges for all nodes other than dark-green ones. Edges for each node\n-    // occupy a contiguous region of this collection, which a node can reference\n-    // using two indices. Storing edges this way rather than using an `EdgesVec`\n-    // for each node reduces memory consumption by a not insignificant amount\n-    // when compiling large crates. The downside is that we have to copy into\n-    // this collection the edges from the `EdgesVec`s that are built up during\n-    // query execution. But this is mostly balanced out by the more efficient\n-    // implementation of `DepGraph::serialize` enabled by this representation.\n-    unshared_edges: IndexVec<EdgeIndex, DepNodeIndex>,\n-\n-    /// Mapping from `DepNodeIndex` to an index into a collection above.\n-    /// Indicates which of the above collections contains a node's data.\n-    ///\n-    /// This collection is wasteful in time and space during incr-full builds,\n-    /// because for those, all nodes are new. However, the waste is relatively\n-    /// small, and the maintenance cost of avoiding using this for incr-full\n-    /// builds is somewhat high and prone to bugginess. It does not seem worth\n-    /// it at the time of this writing, but we may want to revisit the idea.\n-    hybrid_indices: IndexVec<DepNodeIndex, CompressedHybridIndex>,\n-}\n-\n-/// Data for nodes not in previous graph. Since we cannot share any data with\n-/// the previous graph, so we must store all of such a node's data here.\n-struct NewDepNodeData<K> {\n-    nodes: IndexVec<NewDepNodeIndex, DepNode<K>>,\n-    edges: IndexVec<NewDepNodeIndex, Range<EdgeIndex>>,\n-    fingerprints: IndexVec<NewDepNodeIndex, Fingerprint>,\n-}\n-\n-/// Data for nodes in previous graph that have been marked red. We can share the\n-/// dep node with the previous graph, but the edges may be different, and the\n-/// fingerprint is known to be different, so we store the latter two directly.\n-struct RedDepNodeData {\n-    node_indices: IndexVec<RedDepNodeIndex, SerializedDepNodeIndex>,\n-    edges: IndexVec<RedDepNodeIndex, Range<EdgeIndex>>,\n-    fingerprints: IndexVec<RedDepNodeIndex, Fingerprint>,\n-}\n-\n-/// Data for nodes in previous graph that have been marked green because we\n-/// re-executed their queries and the results were the same as in the previous\n-/// session. We can share the dep node and the fingerprint with the previous\n-/// graph, but the edges may be different, so we store them directly.\n-struct LightGreenDepNodeData {\n-    node_indices: IndexVec<LightGreenDepNodeIndex, SerializedDepNodeIndex>,\n-    edges: IndexVec<LightGreenDepNodeIndex, Range<EdgeIndex>>,\n-}\n-\n /// `CurrentDepGraph` stores the dependency graph for the current session. It\n /// will be populated as we run queries or tasks. We never remove nodes from the\n /// graph: they are only added.\n@@ -1417,15 +858,15 @@ struct LightGreenDepNodeData {\n /// `new_node_to_index` and `data`, or `prev_index_to_index` and `data`. When\n /// manipulating both, we acquire `new_node_to_index` or `prev_index_to_index`\n /// first, and `data` second.\n-pub(super) struct CurrentDepGraph<K> {\n-    data: Lock<DepNodeData<K>>,\n+pub(super) struct CurrentDepGraph<K: DepKind> {\n+    encoder: Steal<GraphEncoder<K>>,\n     new_node_to_index: Sharded<FxHashMap<DepNode<K>, DepNodeIndex>>,\n     prev_index_to_index: Lock<IndexVec<SerializedDepNodeIndex, Option<DepNodeIndex>>>,\n \n     /// Used to trap when a specific edge is added to the graph.\n     /// This is used for debug purposes and is only active with `debug_assertions`.\n-    #[allow(dead_code)]\n-    forbidden_edge: Option<EdgeFilter>,\n+    #[cfg(debug_assertions)]\n+    forbidden_edge: Option<EdgeFilter<K>>,\n \n     /// Anonymous `DepNode`s are nodes whose IDs we compute from the list of\n     /// their edges. This has the beneficial side-effect that multiple anonymous\n@@ -1447,78 +888,42 @@ pub(super) struct CurrentDepGraph<K> {\n }\n \n impl<K: DepKind> CurrentDepGraph<K> {\n-    fn new(prev_graph_node_count: usize) -> CurrentDepGraph<K> {\n+    fn new(\n+        prev_graph_node_count: usize,\n+        encoder: FileEncoder,\n+        record_graph: bool,\n+        record_stats: bool,\n+    ) -> CurrentDepGraph<K> {\n         use std::time::{SystemTime, UNIX_EPOCH};\n \n         let duration = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();\n         let nanos = duration.as_secs() * 1_000_000_000 + duration.subsec_nanos() as u64;\n         let mut stable_hasher = StableHasher::new();\n         nanos.hash(&mut stable_hasher);\n \n-        let forbidden_edge = if cfg!(debug_assertions) {\n-            match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n-                Ok(s) => match EdgeFilter::new(&s) {\n-                    Ok(f) => Some(f),\n-                    Err(err) => panic!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n-                },\n-                Err(_) => None,\n-            }\n-        } else {\n-            None\n+        #[cfg(debug_assertions)]\n+        let forbidden_edge = match env::var(\"RUST_FORBID_DEP_GRAPH_EDGE\") {\n+            Ok(s) => match EdgeFilter::new(&s) {\n+                Ok(f) => Some(f),\n+                Err(err) => panic!(\"RUST_FORBID_DEP_GRAPH_EDGE invalid: {}\", err),\n+            },\n+            Err(_) => None,\n         };\n \n-        // Pre-allocate the dep node structures. We over-allocate a little so\n-        // that we hopefully don't have to re-allocate during this compilation\n-        // session. The over-allocation for new nodes is 2% plus a small\n-        // constant to account for the fact that in very small crates 2% might\n-        // not be enough. The allocation for red and green node data doesn't\n-        // include a constant, as we don't want to allocate anything for these\n-        // structures during full incremental builds, where they aren't used.\n-        //\n-        // These estimates are based on the distribution of node and edge counts\n-        // seen in rustc-perf benchmarks, adjusted somewhat to account for the\n-        // fact that these benchmarks aren't perfectly representative.\n-        //\n-        // FIXME Use a collection type that doesn't copy node and edge data and\n-        // grow multiplicatively on reallocation. Without such a collection or\n-        // solution having the same effect, there is a performance hazard here\n-        // in both time and space, as growing these collections means copying a\n-        // large amount of data and doubling already large buffer capacities. A\n-        // solution for this will also mean that it's less important to get\n-        // these estimates right.\n-        let new_node_count_estimate = (prev_graph_node_count * 2) / 100 + 200;\n-        let red_node_count_estimate = (prev_graph_node_count * 3) / 100;\n-        let light_green_node_count_estimate = (prev_graph_node_count * 25) / 100;\n-        let total_node_count_estimate = prev_graph_node_count + new_node_count_estimate;\n-\n-        let average_edges_per_node_estimate = 6;\n-        let unshared_edge_count_estimate = average_edges_per_node_estimate\n-            * (new_node_count_estimate + red_node_count_estimate + light_green_node_count_estimate);\n-\n         // We store a large collection of these in `prev_index_to_index` during\n         // non-full incremental builds, and want to ensure that the element size\n         // doesn't inadvertently increase.\n         static_assert_size!(Option<DepNodeIndex>, 4);\n \n+        let new_node_count_estimate = 102 * prev_graph_node_count / 100 + 200;\n+\n         CurrentDepGraph {\n-            data: Lock::new(DepNodeData {\n-                new: NewDepNodeData {\n-                    nodes: IndexVec::with_capacity(new_node_count_estimate),\n-                    edges: IndexVec::with_capacity(new_node_count_estimate),\n-                    fingerprints: IndexVec::with_capacity(new_node_count_estimate),\n-                },\n-                red: RedDepNodeData {\n-                    node_indices: IndexVec::with_capacity(red_node_count_estimate),\n-                    edges: IndexVec::with_capacity(red_node_count_estimate),\n-                    fingerprints: IndexVec::with_capacity(red_node_count_estimate),\n-                },\n-                light_green: LightGreenDepNodeData {\n-                    node_indices: IndexVec::with_capacity(light_green_node_count_estimate),\n-                    edges: IndexVec::with_capacity(light_green_node_count_estimate),\n-                },\n-                unshared_edges: IndexVec::with_capacity(unshared_edge_count_estimate),\n-                hybrid_indices: IndexVec::with_capacity(total_node_count_estimate),\n-            }),\n+            encoder: Steal::new(GraphEncoder::new(\n+                encoder,\n+                prev_graph_node_count,\n+                record_graph,\n+                record_stats,\n+            )),\n             new_node_to_index: Sharded::new(|| {\n                 FxHashMap::with_capacity_and_hasher(\n                     new_node_count_estimate / sharded::SHARDS,\n@@ -1527,6 +932,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             }),\n             prev_index_to_index: Lock::new(IndexVec::from_elem_n(None, prev_graph_node_count)),\n             anon_id_seed: stable_hasher.finish(),\n+            #[cfg(debug_assertions)]\n             forbidden_edge,\n             total_read_count: AtomicU64::new(0),\n             total_duplicate_read_count: AtomicU64::new(0),\n@@ -1535,76 +941,124 @@ impl<K: DepKind> CurrentDepGraph<K> {\n \n     fn intern_new_node(\n         &self,\n-        prev_graph: &PreviousDepGraph<K>,\n-        dep_node: DepNode<K>,\n+        key: DepNode<K>,\n         edges: EdgesVec,\n-        fingerprint: Fingerprint,\n+        current_fingerprint: Fingerprint,\n     ) -> DepNodeIndex {\n-        debug_assert!(\n-            prev_graph.node_to_index_opt(&dep_node).is_none(),\n-            \"node in previous graph should be interned using one \\\n-            of `intern_red_node`, `intern_light_green_node`, etc.\"\n-        );\n-\n-        match self.new_node_to_index.get_shard_by_value(&dep_node).lock().entry(dep_node) {\n+        match self.new_node_to_index.get_shard_by_value(&key).lock().entry(key) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n-                let data = &mut *self.data.lock();\n-                let new_index = data.new.nodes.push(dep_node);\n-                add_edges(&mut data.unshared_edges, &mut data.new.edges, edges);\n-                data.new.fingerprints.push(fingerprint);\n-                let dep_node_index = data.hybrid_indices.push(new_index.into());\n+                let dep_node_index = self.encoder.borrow().send(key, current_fingerprint, edges);\n                 entry.insert(dep_node_index);\n+                #[cfg(debug_assertions)]\n+                if let Some(forbidden_edge) = &self.forbidden_edge {\n+                    forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n+                }\n                 dep_node_index\n             }\n         }\n     }\n \n-    fn intern_red_node(\n+    fn intern_node(\n         &self,\n         prev_graph: &PreviousDepGraph<K>,\n-        prev_index: SerializedDepNodeIndex,\n+        key: DepNode<K>,\n         edges: EdgesVec,\n-        fingerprint: Fingerprint,\n-    ) -> DepNodeIndex {\n-        self.debug_assert_not_in_new_nodes(prev_graph, prev_index);\n+        current_fingerprint: Option<Fingerprint>,\n+        print_status: bool,\n+    ) -> (DepNodeIndex, Option<(SerializedDepNodeIndex, DepNodeColor)>) {\n+        let print_status = cfg!(debug_assertions) && print_status;\n+\n+        if let Some(prev_index) = prev_graph.node_to_index_opt(&key) {\n+            // Determine the color and index of the new `DepNode`.\n+            if let Some(current_fingerprint) = current_fingerprint {\n+                if current_fingerprint == prev_graph.fingerprint_by_index(prev_index) {\n+                    if print_status {\n+                        eprintln!(\"[task::green] {:?}\", key);\n+                    }\n \n-        let mut prev_index_to_index = self.prev_index_to_index.lock();\n+                    // This is a light green node: it existed in the previous compilation,\n+                    // its query was re-executed, and it has the same result as before.\n+                    let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+                    let dep_node_index = match prev_index_to_index[prev_index] {\n+                        Some(dep_node_index) => dep_node_index,\n+                        None => {\n+                            let dep_node_index =\n+                                self.encoder.borrow().send(key, current_fingerprint, edges);\n+                            prev_index_to_index[prev_index] = Some(dep_node_index);\n+                            dep_node_index\n+                        }\n+                    };\n \n-        match prev_index_to_index[prev_index] {\n-            Some(dep_node_index) => dep_node_index,\n-            None => {\n-                let data = &mut *self.data.lock();\n-                let red_index = data.red.node_indices.push(prev_index);\n-                add_edges(&mut data.unshared_edges, &mut data.red.edges, edges);\n-                data.red.fingerprints.push(fingerprint);\n-                let dep_node_index = data.hybrid_indices.push(red_index.into());\n-                prev_index_to_index[prev_index] = Some(dep_node_index);\n-                dep_node_index\n-            }\n-        }\n-    }\n+                    #[cfg(debug_assertions)]\n+                    if let Some(forbidden_edge) = &self.forbidden_edge {\n+                        forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n+                    }\n+                    (dep_node_index, Some((prev_index, DepNodeColor::Green(dep_node_index))))\n+                } else {\n+                    if print_status {\n+                        eprintln!(\"[task::red] {:?}\", key);\n+                    }\n \n-    fn intern_light_green_node(\n-        &self,\n-        prev_graph: &PreviousDepGraph<K>,\n-        prev_index: SerializedDepNodeIndex,\n-        edges: EdgesVec,\n-    ) -> DepNodeIndex {\n-        self.debug_assert_not_in_new_nodes(prev_graph, prev_index);\n+                    // This is a red node: it existed in the previous compilation, its query\n+                    // was re-executed, but it has a different result from before.\n+                    let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+                    let dep_node_index = match prev_index_to_index[prev_index] {\n+                        Some(dep_node_index) => dep_node_index,\n+                        None => {\n+                            let dep_node_index =\n+                                self.encoder.borrow().send(key, current_fingerprint, edges);\n+                            prev_index_to_index[prev_index] = Some(dep_node_index);\n+                            dep_node_index\n+                        }\n+                    };\n \n-        let mut prev_index_to_index = self.prev_index_to_index.lock();\n+                    #[cfg(debug_assertions)]\n+                    if let Some(forbidden_edge) = &self.forbidden_edge {\n+                        forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n+                    }\n+                    (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n+                }\n+            } else {\n+                if print_status {\n+                    eprintln!(\"[task::unknown] {:?}\", key);\n+                }\n \n-        match prev_index_to_index[prev_index] {\n-            Some(dep_node_index) => dep_node_index,\n-            None => {\n-                let data = &mut *self.data.lock();\n-                let light_green_index = data.light_green.node_indices.push(prev_index);\n-                add_edges(&mut data.unshared_edges, &mut data.light_green.edges, edges);\n-                let dep_node_index = data.hybrid_indices.push(light_green_index.into());\n-                prev_index_to_index[prev_index] = Some(dep_node_index);\n-                dep_node_index\n+                // This is a red node, effectively: it existed in the previous compilation\n+                // session, its query was re-executed, but it doesn't compute a result hash\n+                // (i.e. it represents a `no_hash` query), so we have no way of determining\n+                // whether or not the result was the same as before.\n+                let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+                let dep_node_index = match prev_index_to_index[prev_index] {\n+                    Some(dep_node_index) => dep_node_index,\n+                    None => {\n+                        let dep_node_index =\n+                            self.encoder.borrow().send(key, Fingerprint::ZERO, edges);\n+                        prev_index_to_index[prev_index] = Some(dep_node_index);\n+                        dep_node_index\n+                    }\n+                };\n+\n+                #[cfg(debug_assertions)]\n+                if let Some(forbidden_edge) = &self.forbidden_edge {\n+                    forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n+                }\n+                (dep_node_index, Some((prev_index, DepNodeColor::Red)))\n             }\n+        } else {\n+            if print_status {\n+                eprintln!(\"[task::new] {:?}\", key);\n+            }\n+\n+            let current_fingerprint = current_fingerprint.unwrap_or(Fingerprint::ZERO);\n+\n+            // This is a new node: it didn't exist in the previous compilation session.\n+            let dep_node_index = self.intern_new_node(key, edges, current_fingerprint);\n+\n+            (dep_node_index, None)\n         }\n     }\n \n@@ -1620,9 +1074,21 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         match prev_index_to_index[prev_index] {\n             Some(dep_node_index) => dep_node_index,\n             None => {\n-                let mut data = self.data.lock();\n-                let dep_node_index = data.hybrid_indices.push(prev_index.into());\n+                let key = prev_graph.index_to_node(prev_index);\n+                let dep_node_index = self.encoder.borrow().send(\n+                    key,\n+                    prev_graph.fingerprint_by_index(prev_index),\n+                    prev_graph\n+                        .edge_targets_from(prev_index)\n+                        .iter()\n+                        .map(|i| prev_index_to_index[*i].unwrap())\n+                        .collect(),\n+                );\n                 prev_index_to_index[prev_index] = Some(dep_node_index);\n+                #[cfg(debug_assertions)]\n+                if let Some(forbidden_edge) = &self.forbidden_edge {\n+                    forbidden_edge.index_to_node.lock().insert(dep_node_index, key);\n+                }\n                 dep_node_index\n             }\n         }\n@@ -1642,18 +1108,6 @@ impl<K: DepKind> CurrentDepGraph<K> {\n     }\n }\n \n-#[inline]\n-fn add_edges<I: Idx>(\n-    edges: &mut IndexVec<EdgeIndex, DepNodeIndex>,\n-    edge_indices: &mut IndexVec<I, Range<EdgeIndex>>,\n-    new_edges: EdgesVec,\n-) {\n-    let start = edges.next_index();\n-    edges.extend(new_edges);\n-    let end = edges.next_index();\n-    edge_indices.push(start..end);\n-}\n-\n /// The capacity of the `reads` field `SmallVec`\n const TASK_DEPS_READS_CAP: usize = 8;\n type EdgesVec = SmallVec<[DepNodeIndex; TASK_DEPS_READS_CAP]>;"}, {"sha": "1b6ecf3e637f3ff5e753aaa59ec39b6df63bce07", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -13,6 +13,7 @@ pub use serialized::{SerializedDepGraph, SerializedDepNodeIndex};\n \n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n+use rustc_serialize::{opaque::FileEncoder, Encodable};\n use rustc_session::Session;\n \n use std::fmt;\n@@ -59,7 +60,7 @@ impl<T: DepContext> HasDepContext for T {\n }\n \n /// Describe the different families of dependency nodes.\n-pub trait DepKind: Copy + fmt::Debug + Eq + Hash {\n+pub trait DepKind: Copy + fmt::Debug + Eq + Hash + Send + Encodable<FileEncoder> + 'static {\n     const NULL: Self;\n \n     /// Return whether this kind always require evaluation."}, {"sha": "9c85cdd59d9d493eb3a537741e75ba765e73f0a8", "filename": "compiler/rustc_query_system/src/dep_graph/query.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fquery.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -1,36 +1,35 @@\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::graph::implementation::{Direction, Graph, NodeIndex, INCOMING};\n \n-use super::{DepKind, DepNode};\n+use super::{DepKind, DepNode, DepNodeIndex};\n \n pub struct DepGraphQuery<K> {\n     pub graph: Graph<DepNode<K>, ()>,\n     pub indices: FxHashMap<DepNode<K>, NodeIndex>,\n }\n \n impl<K: DepKind> DepGraphQuery<K> {\n-    pub fn new(\n-        nodes: &[DepNode<K>],\n-        edge_list_indices: &[(usize, usize)],\n-        edge_list_data: &[usize],\n-    ) -> DepGraphQuery<K> {\n-        let mut graph = Graph::with_capacity(nodes.len(), edge_list_data.len());\n-        let mut indices = FxHashMap::default();\n-        for node in nodes {\n-            indices.insert(*node, graph.add_node(*node));\n-        }\n+    pub fn new(prev_node_count: usize) -> DepGraphQuery<K> {\n+        let node_count = prev_node_count + prev_node_count / 4;\n+        let edge_count = 6 * node_count;\n \n-        for (source, &(start, end)) in edge_list_indices.iter().enumerate() {\n-            for &target in &edge_list_data[start..end] {\n-                let source = indices[&nodes[source]];\n-                let target = indices[&nodes[target]];\n-                graph.add_edge(source, target, ());\n-            }\n-        }\n+        let graph = Graph::with_capacity(node_count, edge_count);\n+        let indices = FxHashMap::default();\n \n         DepGraphQuery { graph, indices }\n     }\n \n+    pub fn push(&mut self, index: DepNodeIndex, node: DepNode<K>, edges: &[DepNodeIndex]) {\n+        let source = self.graph.add_node(node);\n+        debug_assert_eq!(index.index(), source.0);\n+        self.indices.insert(node, source);\n+\n+        for &target in edges.iter() {\n+            let target = NodeIndex(target.index());\n+            self.graph.add_edge(source, target, ());\n+        }\n+    }\n+\n     pub fn nodes(&self) -> Vec<&DepNode<K>> {\n         self.graph.all_nodes().iter().map(|n| &n.data).collect()\n     }"}, {"sha": "a76100cc2281fda28517cfbe7c33ed9182ea9b8c", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 352, "deletions": 74, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -1,9 +1,18 @@\n //! The data that we will serialize and deserialize.\n \n-use super::{DepKind, DepNode};\n+use super::query::DepGraphQuery;\n+use super::{DepKind, DepNode, DepNodeIndex};\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_index::vec::IndexVec;\n-use rustc_serialize::{Decodable, Decoder};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::{AtomicU32, Lock, Lrc, Ordering};\n+use rustc_index::vec::{Idx, IndexVec};\n+use rustc_serialize::opaque::{self, FileEncodeResult, FileEncoder, IntEncodedWithFixedSize};\n+use rustc_serialize::{Decodable, Encodable};\n+use smallvec::SmallVec;\n+use std::convert::TryInto;\n+\n+#[cfg(parallel_compiler)]\n+use {rustc_data_structures::sync::WorkerLocal, std::sync::mpsc, std::thread};\n \n // The maximum value of `SerializedDepNodeIndex` leaves the upper two bits\n // unused so that we can store multiple index types in `CompressedHybridIndex`,\n@@ -50,78 +59,347 @@ impl<K: DepKind> SerializedDepGraph<K> {\n     }\n }\n \n-impl<D: Decoder, K: DepKind + Decodable<D>> Decodable<D> for SerializedDepGraph<K> {\n-    fn decode(d: &mut D) -> Result<SerializedDepGraph<K>, D::Error> {\n-        // We used to serialize the dep graph by creating and serializing a `SerializedDepGraph`\n-        // using data copied from the `DepGraph`. But copying created a large memory spike, so we\n-        // now serialize directly from the `DepGraph` as if it's a `SerializedDepGraph`. Because we\n-        // deserialize that data into a `SerializedDepGraph` in the next compilation session, we\n-        // need `DepGraph`'s `Encodable` and `SerializedDepGraph`'s `Decodable` implementations to\n-        // be in sync. If you update this decoding, be sure to update the encoding, and vice-versa.\n-        //\n-        // We mimic the sequence of `Encode` and `Encodable` method calls used by the `DepGraph`'s\n-        // `Encodable` implementation with the corresponding sequence of `Decode` and `Decodable`\n-        // method calls. E.g. `Decode::read_struct` pairs with `Encode::emit_struct`, `DepNode`'s\n-        // `decode` pairs with `DepNode`'s `encode`, and so on. Any decoding methods not associated\n-        // with corresponding encoding methods called in `DepGraph`'s `Encodable` implementation\n-        // are off limits, because we'd be relying on their implementation details.\n-        //\n-        // For example, because we know it happens to do the right thing, its tempting to just use\n-        // `IndexVec`'s `Decodable` implementation to decode into some of the collections below,\n-        // even though `DepGraph` doesn't use its `Encodable` implementation. But the `IndexVec`\n-        // implementation could change, and we'd have a bug.\n-        //\n-        // Variables below are explicitly typed so that anyone who changes the `SerializedDepGraph`\n-        // representation without updating this function will encounter a compilation error, and\n-        // know to update this and possibly the `DepGraph` `Encodable` implementation accordingly\n-        // (the latter should serialize data in a format compatible with our representation).\n-\n-        d.read_struct(\"SerializedDepGraph\", 4, |d| {\n-            let nodes: IndexVec<SerializedDepNodeIndex, DepNode<K>> =\n-                d.read_struct_field(\"nodes\", 0, |d| {\n-                    d.read_seq(|d, len| {\n-                        let mut v = IndexVec::with_capacity(len);\n-                        for i in 0..len {\n-                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n-                        }\n-                        Ok(v)\n-                    })\n-                })?;\n-\n-            let fingerprints: IndexVec<SerializedDepNodeIndex, Fingerprint> =\n-                d.read_struct_field(\"fingerprints\", 1, |d| {\n-                    d.read_seq(|d, len| {\n-                        let mut v = IndexVec::with_capacity(len);\n-                        for i in 0..len {\n-                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n-                        }\n-                        Ok(v)\n-                    })\n-                })?;\n-\n-            let edge_list_indices: IndexVec<SerializedDepNodeIndex, (u32, u32)> = d\n-                .read_struct_field(\"edge_list_indices\", 2, |d| {\n-                    d.read_seq(|d, len| {\n-                        let mut v = IndexVec::with_capacity(len);\n-                        for i in 0..len {\n-                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n-                        }\n-                        Ok(v)\n-                    })\n-                })?;\n-\n-            let edge_list_data: Vec<SerializedDepNodeIndex> =\n-                d.read_struct_field(\"edge_list_data\", 3, |d| {\n-                    d.read_seq(|d, len| {\n-                        let mut v = Vec::with_capacity(len);\n-                        for i in 0..len {\n-                            v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n-                        }\n-                        Ok(v)\n+impl<'a, K: DepKind + Decodable<opaque::Decoder<'a>>> Decodable<opaque::Decoder<'a>>\n+    for SerializedDepGraph<K>\n+{\n+    #[instrument(skip(d))]\n+    fn decode(d: &mut opaque::Decoder<'a>) -> Result<SerializedDepGraph<K>, String> {\n+        let position = d.position();\n+\n+        // The last 16 bytes are the node count and edge count.\n+        debug!(\"position: {:?}\", d.position());\n+        d.set_position(d.data.len() - 2 * IntEncodedWithFixedSize::ENCODED_SIZE);\n+        debug!(\"position: {:?}\", d.position());\n+\n+        let node_count = IntEncodedWithFixedSize::decode(d)?.0 as usize;\n+        let edge_count = IntEncodedWithFixedSize::decode(d)?.0 as usize;\n+        debug!(?node_count, ?edge_count);\n+\n+        debug!(\"position: {:?}\", d.position());\n+        d.set_position(position);\n+        debug!(\"position: {:?}\", d.position());\n+\n+        let mut nodes = IndexVec::with_capacity(node_count);\n+        let mut fingerprints = IndexVec::with_capacity(node_count);\n+        let mut edge_list_indices = IndexVec::with_capacity(node_count);\n+        let mut edge_list_data = Vec::with_capacity(edge_count);\n+\n+        for _index in 0..node_count {\n+            let node = NodeInfo::<K, SerializedDepNodeIndex>::decode(d)?;\n+            debug!(?_index, ?node);\n+\n+            let _i: SerializedDepNodeIndex = nodes.push(node.node);\n+            debug_assert_eq!(_i.index(), _index);\n+            let _i: SerializedDepNodeIndex = fingerprints.push(node.fingerprint);\n+            debug_assert_eq!(_i.index(), _index);\n+\n+            let start = edge_list_data.len().try_into().unwrap();\n+            edge_list_data.extend(node.edges.into_iter());\n+            let end = edge_list_data.len().try_into().unwrap();\n+\n+            let _i: SerializedDepNodeIndex = edge_list_indices.push((start, end));\n+            debug_assert_eq!(_i.index(), _index);\n+        }\n+\n+        Ok(SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data })\n+    }\n+}\n+\n+#[derive(Debug, Encodable, Decodable)]\n+pub struct NodeInfo<K: DepKind, I: Idx> {\n+    node: DepNode<K>,\n+    fingerprint: Fingerprint,\n+    edges: SmallVec<[I; 8]>,\n+}\n+\n+struct Stat<K: DepKind> {\n+    kind: K,\n+    node_counter: u64,\n+    edge_counter: u64,\n+}\n+\n+struct Stats<K: DepKind> {\n+    stats: FxHashMap<K, Stat<K>>,\n+    total_node_count: usize,\n+    total_edge_count: usize,\n+}\n+\n+#[instrument(skip(encoder, _record_graph, record_stats))]\n+fn encode_node<K: DepKind>(\n+    encoder: &mut FileEncoder,\n+    _index: DepNodeIndex,\n+    node: &NodeInfo<K, DepNodeIndex>,\n+    _record_graph: &Option<Lrc<Lock<DepGraphQuery<K>>>>,\n+    record_stats: &Option<Lrc<Lock<Stats<K>>>>,\n+) -> FileEncodeResult {\n+    #[cfg(debug_assertions)]\n+    if let Some(record_graph) = &_record_graph {\n+        record_graph.lock().push(_index, node.node, &node.edges);\n+    }\n+\n+    if let Some(record_stats) = &record_stats {\n+        let mut stats = record_stats.lock();\n+        let kind = node.node.kind;\n+        let edge_count = node.edges.len();\n+\n+        let stat =\n+            stats.stats.entry(kind).or_insert(Stat { kind, node_counter: 0, edge_counter: 0 });\n+        stat.node_counter += 1;\n+        stat.edge_counter += edge_count as u64;\n+        stats.total_node_count += 1;\n+        stats.total_edge_count += edge_count;\n+    }\n+\n+    debug!(?_index, ?node);\n+    node.encode(encoder)\n+}\n+\n+fn encode_counts(\n+    mut encoder: FileEncoder,\n+    node_count: usize,\n+    edge_count: usize,\n+) -> FileEncodeResult {\n+    let node_count = node_count.try_into().unwrap();\n+    let edge_count = edge_count.try_into().unwrap();\n+\n+    debug!(?node_count, ?edge_count);\n+    debug!(\"position: {:?}\", encoder.position());\n+    IntEncodedWithFixedSize(node_count).encode(&mut encoder)?;\n+    IntEncodedWithFixedSize(edge_count).encode(&mut encoder)?;\n+    debug!(\"position: {:?}\", encoder.position());\n+    // Drop the encoder so that nothing is written after the counts.\n+    encoder.flush()\n+}\n+\n+#[cfg(not(parallel_compiler))]\n+pub struct GraphEncoder<K: DepKind> {\n+    status: Lock<(FileEncoder, usize, FileEncodeResult)>,\n+    counter: AtomicU32,\n+    record_graph: Option<Lrc<Lock<DepGraphQuery<K>>>>,\n+    record_stats: Option<Lrc<Lock<Stats<K>>>>,\n+}\n+\n+#[cfg(parallel_compiler)]\n+pub struct GraphEncoder<K: DepKind> {\n+    send: WorkerLocal<mpsc::Sender<(DepNodeIndex, NodeInfo<K, DepNodeIndex>)>>,\n+    thread: thread::JoinHandle<FileEncodeResult>,\n+    counter: AtomicU32,\n+    record_graph: Option<Lrc<Lock<DepGraphQuery<K>>>>,\n+    record_stats: Option<Lrc<Lock<Stats<K>>>>,\n+}\n+\n+impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n+    pub fn new(\n+        encoder: FileEncoder,\n+        prev_node_count: usize,\n+        record_graph: bool,\n+        record_stats: bool,\n+    ) -> Self {\n+        let record_graph = if cfg!(debug_assertions) && record_graph {\n+            Some(Lrc::new(Lock::new(DepGraphQuery::new(prev_node_count))))\n+        } else {\n+            None\n+        };\n+        let record_stats = if record_stats {\n+            Some(Lrc::new(Lock::new(Stats {\n+                stats: FxHashMap::default(),\n+                total_node_count: 0,\n+                total_edge_count: 0,\n+            })))\n+        } else {\n+            None\n+        };\n+        let counter = AtomicU32::new(0);\n+\n+        #[cfg(not(parallel_compiler))]\n+        {\n+            let status = Lock::new((encoder, 0, Ok(())));\n+            GraphEncoder { status, counter, record_graph, record_stats }\n+        }\n+        #[cfg(parallel_compiler)]\n+        {\n+            let (send, recv) = mpsc::channel();\n+            let thread = {\n+                let record_graph = record_graph.clone();\n+                let record_stats = record_stats.clone();\n+                thread::spawn(move || {\n+                    encode_graph(encoder, recv, |encoder, index, node| {\n+                        encode_node(encoder, index, node, &record_graph, &record_stats)\n                     })\n-                })?;\n+                })\n+            };\n+            let send = WorkerLocal::new(move |_| send.clone());\n \n-            Ok(SerializedDepGraph { nodes, fingerprints, edge_list_indices, edge_list_data })\n-        })\n+            GraphEncoder { send, thread, counter, record_graph, record_stats }\n+        }\n+    }\n+\n+    pub(crate) fn with_query(&self, f: impl Fn(&DepGraphQuery<K>)) {\n+        if let Some(record_graph) = &self.record_graph {\n+            f(&record_graph.lock())\n+        }\n+    }\n+\n+    pub(crate) fn print_incremental_info(\n+        &self,\n+        total_read_count: u64,\n+        total_duplicate_read_count: u64,\n+    ) {\n+        if let Some(record_stats) = &self.record_stats {\n+            let record_stats = record_stats.lock();\n+\n+            let mut stats: Vec<_> = record_stats.stats.values().collect();\n+            stats.sort_by_key(|s| -(s.node_counter as i64));\n+\n+            const SEPARATOR: &str = \"[incremental] --------------------------------\\\n+                                     ----------------------------------------------\\\n+                                     ------------\";\n+\n+            eprintln!(\"[incremental]\");\n+            eprintln!(\"[incremental] DepGraph Statistics\");\n+            eprintln!(\"{}\", SEPARATOR);\n+            eprintln!(\"[incremental]\");\n+            eprintln!(\"[incremental] Total Node Count: {}\", record_stats.total_node_count);\n+            eprintln!(\"[incremental] Total Edge Count: {}\", record_stats.total_edge_count);\n+\n+            if cfg!(debug_assertions) {\n+                eprintln!(\"[incremental] Total Edge Reads: {}\", total_read_count);\n+                eprintln!(\n+                    \"[incremental] Total Duplicate Edge Reads: {}\",\n+                    total_duplicate_read_count\n+                );\n+            }\n+\n+            eprintln!(\"[incremental]\");\n+            eprintln!(\n+                \"[incremental]  {:<36}| {:<17}| {:<12}| {:<17}|\",\n+                \"Node Kind\", \"Node Frequency\", \"Node Count\", \"Avg. Edge Count\"\n+            );\n+            eprintln!(\"{}\", SEPARATOR);\n+\n+            for stat in stats {\n+                let node_kind_ratio =\n+                    (100.0 * (stat.node_counter as f64)) / (record_stats.total_node_count as f64);\n+                let node_kind_avg_edges = (stat.edge_counter as f64) / (stat.node_counter as f64);\n+\n+                eprintln!(\n+                    \"[incremental]  {:<36}|{:>16.1}% |{:>12} |{:>17.1} |\",\n+                    format!(\"{:?}\", stat.kind),\n+                    node_kind_ratio,\n+                    stat.node_counter,\n+                    node_kind_avg_edges,\n+                );\n+            }\n+\n+            eprintln!(\"{}\", SEPARATOR);\n+            eprintln!(\"[incremental]\");\n+        }\n+    }\n+}\n+\n+#[cfg(not(parallel_compiler))]\n+impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n+    pub(crate) fn send(\n+        &self,\n+        node: DepNode<K>,\n+        fingerprint: Fingerprint,\n+        edges: SmallVec<[DepNodeIndex; 8]>,\n+    ) -> DepNodeIndex {\n+        let index = self.counter.fetch_add(1, Ordering::SeqCst);\n+        let index = DepNodeIndex::from_u32(index);\n+        let &mut (ref mut encoder, ref mut edge_count, ref mut result) = &mut *self.status.lock();\n+        *edge_count += edges.len();\n+        *result = std::mem::replace(result, Ok(())).and_then(|()| {\n+            let node = NodeInfo { node, fingerprint, edges };\n+            encode_node(encoder, index, &node, &self.record_graph, &self.record_stats)\n+        });\n+        index\n+    }\n+\n+    pub fn finish(self) -> FileEncodeResult {\n+        let (encoder, edge_count, result) = self.status.into_inner();\n+        let () = result?;\n+        let node_count = self.counter.into_inner() as usize;\n+\n+        encode_counts(encoder, node_count, edge_count)\n+    }\n+}\n+\n+#[cfg(parallel_compiler)]\n+impl<K: DepKind + Encodable<FileEncoder>> GraphEncoder<K> {\n+    pub(crate) fn send(\n+        &self,\n+        node: DepNode<K>,\n+        fingerprint: Fingerprint,\n+        edges: SmallVec<[DepNodeIndex; 8]>,\n+    ) -> DepNodeIndex {\n+        let node = NodeInfo { node, fingerprint, edges };\n+        let index = self.counter.fetch_add(1, Ordering::SeqCst);\n+        let index = DepNodeIndex::from_u32(index);\n+        self.send.send((index, node)).unwrap();\n+        index\n     }\n+\n+    pub fn finish(self) -> FileEncodeResult {\n+        std::mem::drop(self.send);\n+        self.thread.join().unwrap()\n+    }\n+}\n+\n+#[cfg(parallel_compiler)]\n+#[instrument(skip(encoder, recv, process))]\n+fn encode_graph<K: DepKind + Encodable<FileEncoder>>(\n+    mut encoder: FileEncoder,\n+    recv: mpsc::Receiver<(DepNodeIndex, NodeInfo<K, DepNodeIndex>)>,\n+    process: impl Fn(&mut FileEncoder, DepNodeIndex, &NodeInfo<K, DepNodeIndex>) -> FileEncodeResult,\n+) -> FileEncodeResult {\n+    let mut edge_count: usize = 0;\n+    let node_count: usize = ordered_recv(recv, |index, node| {\n+        edge_count += node.edges.len();\n+        process(&mut encoder, index, node)\n+    })?;\n+\n+    encode_counts(encoder, node_count, edge_count)\n+}\n+\n+/// Since there are multiple producers assigning the DepNodeIndex using an atomic,\n+/// the messages may not arrive in order. This function sorts them as they come.\n+#[cfg(parallel_compiler)]\n+fn ordered_recv<K: DepKind + Encodable<opaque::FileEncoder>>(\n+    recv: mpsc::Receiver<(DepNodeIndex, NodeInfo<K, DepNodeIndex>)>,\n+    mut f: impl FnMut(DepNodeIndex, &NodeInfo<K, DepNodeIndex>) -> FileEncodeResult,\n+) -> Result<usize, std::io::Error> {\n+    let mut pending = Vec::<(DepNodeIndex, _)>::new();\n+    let mut expected = DepNodeIndex::new(0);\n+\n+    // INVARIANT: No message can arrive with an index less than `expected`.\n+    'outer: loop {\n+        pending.sort_by_key(|n| n.0);\n+        for (index, node) in pending.drain_filter(|(index, _)| {\n+            if *index == expected {\n+                expected.increment_by(1);\n+                true\n+            } else {\n+                false\n+            }\n+        }) {\n+            f(index, &node)?;\n+        }\n+\n+        while let Ok((index, node)) = recv.recv() {\n+            if index > expected {\n+                pending.push((index, node));\n+            } else if index == expected {\n+                f(index, &node)?;\n+                expected.increment_by(1);\n+                continue 'outer;\n+            } else {\n+                panic!(\"Unexpected index {:?} while waiting for {:?}\", index, expected);\n+            }\n+        }\n+\n+        break;\n+    }\n+\n+    Ok(expected.as_u32() as usize)\n }"}, {"sha": "071144f38e702f2459a45f58fd5f10e57b6dff85", "filename": "compiler/rustc_query_system/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_system%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Flib.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -2,6 +2,7 @@\n #![feature(const_fn)]\n #![feature(const_panic)]\n #![feature(core_intrinsics)]\n+#![feature(drain_filter)]\n #![feature(hash_raw_entry)]\n #![feature(iter_zip)]\n #![feature(min_specialization)]"}, {"sha": "b58802474757e44bffe8295a4bc9f7262686b01f", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=6bfaf3a9cb7b601e3c4ed2e661ed213b8bc4d639", "patch": "@@ -537,7 +537,7 @@ where\n         // If `-Zincremental-verify-ich` is specified, re-hash results from\n         // the cache and make sure that they have the expected fingerprint.\n         if unlikely!(tcx.dep_context().sess().opts.debugging_opts.incremental_verify_ich) {\n-            incremental_verify_ich(*tcx.dep_context(), &result, dep_node, dep_node_index, query);\n+            incremental_verify_ich(*tcx.dep_context(), &result, dep_node, query);\n         }\n \n         result\n@@ -560,7 +560,7 @@ where\n         //\n         // See issue #82920 for an example of a miscompilation that would get turned into\n         // an ICE by this check\n-        incremental_verify_ich(*tcx.dep_context(), &result, dep_node, dep_node_index, query);\n+        incremental_verify_ich(*tcx.dep_context(), &result, dep_node, query);\n \n         result\n     }\n@@ -570,14 +570,12 @@ fn incremental_verify_ich<CTX, K, V: Debug>(\n     tcx: CTX::DepContext,\n     result: &V,\n     dep_node: &DepNode<CTX::DepKind>,\n-    dep_node_index: DepNodeIndex,\n     query: &QueryVtable<CTX, K, V>,\n ) where\n     CTX: QueryContext,\n {\n     assert!(\n-        Some(tcx.dep_graph().fingerprint_of(dep_node_index))\n-            == tcx.dep_graph().prev_fingerprint_of(dep_node),\n+        tcx.dep_graph().is_green(dep_node),\n         \"fingerprint for green query instance not loaded from cache: {:?}\",\n         dep_node,\n     );\n@@ -588,9 +586,15 @@ fn incremental_verify_ich<CTX, K, V: Debug>(\n     let new_hash = query.hash_result(&mut hcx, result).unwrap_or(Fingerprint::ZERO);\n     debug!(\"END verify_ich({:?})\", dep_node);\n \n-    let old_hash = tcx.dep_graph().fingerprint_of(dep_node_index);\n+    let old_hash = tcx.dep_graph().prev_fingerprint_of(dep_node);\n \n-    assert!(new_hash == old_hash, \"found unstable fingerprints for {:?}: {:?}\", dep_node, result);\n+    assert_eq!(\n+        Some(new_hash),\n+        old_hash,\n+        \"found unstable fingerprints for {:?}: {:?}\",\n+        dep_node,\n+        result\n+    );\n }\n \n fn force_query_with_job<C, CTX>("}]}