{"sha": "753efb5042563dd34a4a524197fa14a129ddf449", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1M2VmYjUwNDI1NjNkZDM0YTRhNTI0MTk3ZmExNGExMjlkZGY0NDk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-23T22:10:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-23T22:10:50Z"}, "message": "rollup merge of #23601: nikomatsakis/by-value-index\n\nThis is a [breaking-change]. When indexing a generic map (hashmap, etc) using the `[]` operator, it is now necessary to borrow explicitly, so change `map[key]` to `map[&key]` (consistent with the `get` routine). However, indexing of string-valued maps with constant strings can now be written `map[\"abc\"]`.\n\nr? @japaric\ncc @aturon @Gankro", "tree": {"sha": "c7f2301e6ba8d7e0e6f16674905a36c55b853085", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7f2301e6ba8d7e0e6f16674905a36c55b853085"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/753efb5042563dd34a4a524197fa14a129ddf449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/753efb5042563dd34a4a524197fa14a129ddf449", "html_url": "https://github.com/rust-lang/rust/commit/753efb5042563dd34a4a524197fa14a129ddf449", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/753efb5042563dd34a4a524197fa14a129ddf449/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "388e5aee1e3df9e25f69815ffebfaa39e2167b5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/388e5aee1e3df9e25f69815ffebfaa39e2167b5f", "html_url": "https://github.com/rust-lang/rust/commit/388e5aee1e3df9e25f69815ffebfaa39e2167b5f"}, {"sha": "57cf2decf755c6eea3275e2a87862756eb8c62ca", "url": "https://api.github.com/repos/rust-lang/rust/commits/57cf2decf755c6eea3275e2a87862756eb8c62ca", "html_url": "https://github.com/rust-lang/rust/commit/57cf2decf755c6eea3275e2a87862756eb8c62ca"}], "stats": {"total": 1130, "additions": 953, "deletions": 177}, "files": [{"sha": "e494527b6a67c921af62f1992a9595c7dab35124", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -169,6 +169,8 @@ pub struct BitVec {\n impl Index<usize> for BitVec {\n     type Output = bool;\n \n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, i: &usize) -> &bool {\n         if self.get(*i).expect(\"index out of bounds\") {\n@@ -177,6 +179,16 @@ impl Index<usize> for BitVec {\n             &FALSE\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, i: usize) -> &bool {\n+        if self.get(i).expect(\"index out of bounds\") {\n+            &TRUE\n+        } else {\n+            &FALSE\n+        }\n+    }\n }\n \n /// Computes how many blocks are needed to store that many bits"}, {"sha": "755f564621a0f7dd8c467958ca6331e8038a6883", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -264,7 +264,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n-    /// assert_eq!(map[1], \"b\");\n+    /// assert_eq!(map[&1], \"b\");\n     /// ```\n     // See `get` for implementation notes, this is basically a copy-paste with mut's added\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -326,7 +326,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///\n     /// map.insert(37, \"b\");\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n-    /// assert_eq!(map[37], \"c\");\n+    /// assert_eq!(map[&37], \"c\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, mut key: K, mut value: V) -> Option<V> {\n@@ -914,12 +914,27 @@ impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Ord, Q: ?Sized, V> Index<Q> for BTreeMap<K, V>\n     where K: Borrow<Q>, Q: Ord\n {\n     type Output = V;\n \n+    #[inline]\n+    fn index(&self, key: &Q) -> &V {\n+        self.get(key).expect(\"no entry found for key\")\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n+    where K: Borrow<Q>, Q: Ord\n+{\n+    type Output = V;\n+\n+    #[inline]\n     fn index(&self, key: &Q) -> &V {\n         self.get(key).expect(\"no entry found for key\")\n     }"}, {"sha": "5b8a5f029762ee418411afc00e736150ff14d171", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -1522,6 +1522,7 @@ macro_rules! node_slice_impl {\n             }\n \n             /// Returns a sub-slice with elements starting with `min_key`.\n+            #[cfg(stage0)]\n             pub fn slice_from(self, min_key: &K) -> $NodeSlice<'a, K, V> {\n                 //  _______________\n                 // |_1_|_3_|_5_|_7_|\n@@ -1549,7 +1550,37 @@ macro_rules! node_slice_impl {\n                 }\n             }\n \n+            /// Returns a sub-slice with elements starting with `min_key`.\n+            #[cfg(not(stage0))]\n+            pub fn slice_from(self, min_key: &K) -> $NodeSlice<'a, K, V> {\n+                //  _______________\n+                // |_1_|_3_|_5_|_7_|\n+                // |   |   |   |   |\n+                // 0 0 1 1 2 2 3 3 4  index\n+                // |   |   |   |   |\n+                // \\___|___|___|___/  slice_from(&0); pos = 0\n+                //     \\___|___|___/  slice_from(&2); pos = 1\n+                //     |___|___|___/  slice_from(&3); pos = 1; result.head_is_edge = false\n+                //         \\___|___/  slice_from(&4); pos = 2\n+                //             \\___/  slice_from(&6); pos = 3\n+                //                \\|/ slice_from(&999); pos = 4\n+                let (pos, pos_is_kv) = self.search_linear(min_key);\n+                $NodeSlice {\n+                    has_edges: self.has_edges,\n+                    edges: if !self.has_edges {\n+                        self.edges\n+                    } else {\n+                        self.edges.$index(pos ..)\n+                    },\n+                    keys: &self.keys[pos ..],\n+                    vals: self.vals.$index(pos ..),\n+                    head_is_edge: !pos_is_kv,\n+                    tail_is_edge: self.tail_is_edge,\n+                }\n+            }\n+\n             /// Returns a sub-slice with elements up to and including `max_key`.\n+            #[cfg(stage0)]\n             pub fn slice_to(self, max_key: &K) -> $NodeSlice<'a, K, V> {\n                 //  _______________\n                 // |_1_|_3_|_5_|_7_|\n@@ -1577,6 +1608,36 @@ macro_rules! node_slice_impl {\n                     tail_is_edge: !pos_is_kv,\n                 }\n             }\n+\n+            /// Returns a sub-slice with elements up to and including `max_key`.\n+            #[cfg(not(stage0))]\n+            pub fn slice_to(self, max_key: &K) -> $NodeSlice<'a, K, V> {\n+                //  _______________\n+                // |_1_|_3_|_5_|_7_|\n+                // |   |   |   |   |\n+                // 0 0 1 1 2 2 3 3 4  index\n+                // |   |   |   |   |\n+                //\\|/  |   |   |   |  slice_to(&0); pos = 0\n+                // \\___/   |   |   |  slice_to(&2); pos = 1\n+                // \\___|___|   |   |  slice_to(&3); pos = 1; result.tail_is_edge = false\n+                // \\___|___/   |   |  slice_to(&4); pos = 2\n+                // \\___|___|___/   |  slice_to(&6); pos = 3\n+                // \\___|___|___|___/  slice_to(&999); pos = 4\n+                let (pos, pos_is_kv) = self.search_linear(max_key);\n+                let pos = pos + if pos_is_kv { 1 } else { 0 };\n+                $NodeSlice {\n+                    has_edges: self.has_edges,\n+                    edges: if !self.has_edges {\n+                        self.edges\n+                    } else {\n+                        self.edges.$index(.. (pos + 1))\n+                    },\n+                    keys: &self.keys[..pos],\n+                    vals: self.vals.$index(.. pos),\n+                    head_is_edge: self.head_is_edge,\n+                    tail_is_edge: !pos_is_kv,\n+                }\n+            }\n         }\n \n         impl<'a, K: 'a, V: 'a> $NodeSlice<'a, K, V> {"}, {"sha": "0d55dc7dba95380025dc413e342372f549f542e2", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -891,34 +891,66 @@ impl<'a> Add<&'a str> for String {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::Range<usize>> for String {\n     type Output = str;\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &str {\n         &self[..][*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &str {\n+        &self[..][index]\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeTo<usize>> for String {\n     type Output = str;\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n         &self[..][*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &str {\n+        &self[..][index]\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFrom<usize>> for String {\n     type Output = str;\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n         &self[..][*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n+        &self[..][index]\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFull> for String {\n     type Output = str;\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &ops::RangeFull) -> &str {\n         unsafe { mem::transmute(&*self.vec) }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: ops::RangeFull) -> &str {\n+        unsafe { mem::transmute(&*self.vec) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "1d76224bd841955573eb0314129eb53a30f7ef37", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -1323,83 +1323,165 @@ impl<T: Hash> Hash for Vec<T> {\n impl<T> Index<usize> for Vec<T> {\n     type Output = T;\n \n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &usize) -> &T {\n         // NB built-in indexing via `&[T]`\n         &(**self)[*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: usize) -> &T {\n+        // NB built-in indexing via `&[T]`\n+        &(**self)[index]\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> IndexMut<usize> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &usize) -> &mut T {\n         // NB built-in indexing via `&mut [T]`\n         &mut (**self)[*index]\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: usize) -> &mut T {\n+        // NB built-in indexing via `&mut [T]`\n+        &mut (**self)[index]\n+    }\n }\n \n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::Range<usize>> for Vec<T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &[T] {\n+        Index::index(&**self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeTo<usize>> for Vec<T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n+        Index::index(&**self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFrom<usize>> for Vec<T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         Index::index(&**self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n+        Index::index(&**self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &ops::RangeFull) -> &[T] {\n         self\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: ops::RangeFull) -> &[T] {\n+        self.as_slice()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         IndexMut::index_mut(&mut **self, index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, _index: &ops::RangeFull) -> &mut [T] {\n         self.as_mut_slice()\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, _index: ops::RangeFull) -> &mut [T] {\n+        self.as_mut_slice()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "591ad48f57912316e9bccf26d97132862ce34706", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -1689,18 +1689,32 @@ impl<A: Hash> Hash for VecDeque<A> {\n impl<A> Index<usize> for VecDeque<A> {\n     type Output = A;\n \n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, i: &usize) -> &A {\n         self.get(*i).expect(\"Out of bounds access\")\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, i: usize) -> &A {\n+        self.get(i).expect(\"Out of bounds access\")\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> IndexMut<usize> for VecDeque<A> {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, i: &usize) -> &mut A {\n         self.get_mut(*i).expect(\"Out of bounds access\")\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, i: usize) -> &mut A {\n+        self.get_mut(i).expect(\"Out of bounds access\")\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "05693ec52756ad0e9a95505e603c75e456ebf987", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -798,6 +798,7 @@ impl<V> Extend<(usize, V)> for VecMap<V> {\n     }\n }\n \n+#[cfg(stage0)]\n impl<V> Index<usize> for VecMap<V> {\n     type Output = V;\n \n@@ -807,10 +808,49 @@ impl<V> Index<usize> for VecMap<V> {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<V> Index<usize> for VecMap<V> {\n+    type Output = V;\n+\n+    #[inline]\n+    fn index<'a>(&'a self, i: usize) -> &'a V {\n+        self.get(&i).expect(\"key not present\")\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<'a,V> Index<&'a usize> for VecMap<V> {\n+    type Output = V;\n+\n+    #[inline]\n+    fn index(&self, i: &usize) -> &V {\n+        self.get(i).expect(\"key not present\")\n+    }\n+}\n+\n+#[cfg(stage0)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<V> IndexMut<usize> for VecMap<V> {\n+    #[inline]\n+    fn index_mut(&mut self, i: &usize) -> &mut V {\n+        self.get_mut(&i).expect(\"key not present\")\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V> IndexMut<usize> for VecMap<V> {\n     #[inline]\n-    fn index_mut<'a>(&'a mut self, i: &usize) -> &'a mut V {\n+    fn index_mut(&mut self, i: usize) -> &mut V {\n+        self.get_mut(&i).expect(\"key not present\")\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, V> IndexMut<&'a usize> for VecMap<V> {\n+    #[inline]\n+    fn index_mut(&mut self, i: &usize) -> &mut V {\n         self.get_mut(i).expect(\"key not present\")\n     }\n }"}, {"sha": "6e6f97a7af7d9e1d2595309f78ef918885ba4965", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -898,7 +898,7 @@ shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// impl Index<Bar> for Foo {\n ///     type Output = Foo;\n ///\n-///     fn index<'a>(&'a self, _index: &Bar) -> &'a Foo {\n+///     fn index<'a>(&'a self, _index: Bar) -> &'a Foo {\n ///         println!(\"Indexing!\");\n ///         self\n ///     }\n@@ -917,8 +917,14 @@ pub trait Index<Idx: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n+    #[cfg(stage0)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index<'a>(&'a self, index: &Idx) -> &'a Self::Output;\n+\n+    /// The method for the indexing (`Foo[Bar]`) operation\n+    #[cfg(not(stage0))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn index<'a>(&'a self, index: Idx) -> &'a Self::Output;\n }\n \n /// The `IndexMut` trait is used to specify the functionality of indexing\n@@ -939,13 +945,13 @@ pub trait Index<Idx: ?Sized> {\n /// impl Index<Bar> for Foo {\n ///     type Output = Foo;\n ///\n-///     fn index<'a>(&'a self, _index: &Bar) -> &'a Foo {\n+///     fn index<'a>(&'a self, _index: Bar) -> &'a Foo {\n ///         self\n ///     }\n /// }\n ///\n /// impl IndexMut<Bar> for Foo {\n-///     fn index_mut<'a>(&'a mut self, _index: &Bar) -> &'a mut Foo {\n+///     fn index_mut<'a>(&'a mut self, _index: Bar) -> &'a mut Foo {\n ///         println!(\"Indexing!\");\n ///         self\n ///     }\n@@ -960,8 +966,14 @@ pub trait Index<Idx: ?Sized> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n     /// The method for the indexing (`Foo[Bar]`) operation\n+    #[cfg(stage0)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index_mut<'a>(&'a mut self, index: &Idx) -> &'a mut Self::Output;\n+\n+    /// The method for the indexing (`Foo[Bar]`) operation\n+    #[cfg(not(stage0))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn index_mut<'a>(&'a mut self, index: Idx) -> &'a mut Self::Output;\n }\n \n /// An unbounded range."}, {"sha": "8826cfc5ee35885d41d8d5078a2a330ad21a477f", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -263,6 +263,7 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n+    #[cfg(stage0)]\n     #[inline]\n     fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n         unsafe {\n@@ -273,6 +274,17 @@ impl<T> SliceExt for [T] {\n         }\n     }\n \n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n+        unsafe {\n+            let self2: &mut [T] = mem::transmute_copy(&self);\n+\n+            (ops::IndexMut::index_mut(self, ops::RangeTo { end: mid } ),\n+             ops::IndexMut::index_mut(self2, ops::RangeFrom { start: mid } ))\n+        }\n+    }\n+\n     #[inline]\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, T> {\n         unsafe {\n@@ -495,25 +507,45 @@ impl<T> SliceExt for [T] {\n impl<T> ops::Index<usize> for [T] {\n     type Output = T;\n \n+    #[cfg(stage0)]\n     fn index(&self, &index: &usize) -> &T {\n         assert!(index < self.len());\n \n         unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n     }\n+\n+    #[cfg(not(stage0))]\n+    fn index(&self, index: usize) -> &T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<usize> for [T] {\n+    #[cfg(stage0)]\n+    #[inline]\n     fn index_mut(&mut self, &index: &usize) -> &mut T {\n         assert!(index < self.len());\n \n         unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: usize) -> &mut T {\n+        assert!(index < self.len());\n+\n+        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::Range<usize>> for [T] {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         assert!(index.start <= index.end);\n@@ -525,34 +557,72 @@ impl<T> ops::Index<ops::Range<usize>> for [T] {\n             )\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &[T] {\n+        assert!(index.start <= index.end);\n+        assert!(index.end <= self.len());\n+        unsafe {\n+            from_raw_parts (\n+                self.as_ptr().offset(index.start as isize),\n+                index.end - index.start\n+            )\n+        }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.index(&ops::Range{ start: 0, end: index.end })\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n+        self.index(ops::Range{ start: 0, end: index.end })\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.index(&ops::Range{ start: index.start, end: self.len() })\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n+        self.index(ops::Range{ start: index.start, end: self.len() })\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Index<RangeFull> for [T] {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &RangeFull) -> &[T] {\n         self\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: RangeFull) -> &[T] {\n+        self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         assert!(index.start <= index.end);\n@@ -564,28 +634,64 @@ impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n             )\n         }\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n+        assert!(index.start <= index.end);\n+        assert!(index.end <= self.len());\n+        unsafe {\n+            from_raw_parts_mut(\n+                self.as_mut_ptr().offset(index.start as isize),\n+                index.end - index.start\n+            )\n+        }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(&ops::Range{ start: 0, end: index.end })\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n+        self.index_mut(ops::Range{ start: 0, end: index.end })\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         let len = self.len();\n         self.index_mut(&ops::Range{ start: index.start, end: len })\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n+        let len = self.len();\n+        self.index_mut(ops::Range{ start: index.start, end: len })\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<RangeFull> for [T] {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, _index: &RangeFull) -> &mut [T] {\n         self\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, _index: RangeFull) -> &mut [T] {\n+        self\n+    }\n }\n \n \n@@ -768,37 +874,69 @@ unsafe impl<'a, T: Sync> Send for Iter<'a, T> {}\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::Range<usize>> for Iter<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &[T] {\n+        self.as_slice().index(index)\n+    }\n }\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeTo<usize>> for Iter<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n+        self.as_slice().index(index)\n+    }\n }\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeFrom<usize>> for Iter<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n+        self.as_slice().index(index)\n+    }\n }\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<RangeFull> for Iter<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &RangeFull) -> &[T] {\n         self.as_slice()\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: RangeFull) -> &[T] {\n+        self.as_slice()\n+    }\n }\n \n impl<'a, T> Iter<'a, T> {\n@@ -861,63 +999,126 @@ unsafe impl<'a, T: Send> Send for IterMut<'a, T> {}\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::Range<usize>> for IterMut<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::Range<usize>) -> &[T] {\n+        self.index(RangeFull).index(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeTo<usize>> for IterMut<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n+        self.index(RangeFull).index(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeFrom<usize>> for IterMut<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n+        self.index(RangeFull).index(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<RangeFull> for IterMut<'a, T> {\n     type Output = [T];\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index(&self, _index: &RangeFull) -> &[T] {\n         make_slice!(T => &[T]: self.ptr, self.end)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index(&self, _index: RangeFull) -> &[T] {\n+        make_slice!(T => &[T]: self.ptr, self.end)\n+    }\n }\n \n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::Range<usize>> for IterMut<'a, T> {\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n+        self.index_mut(RangeFull).index_mut(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeTo<usize>> for IterMut<'a, T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n+        self.index_mut(RangeFull).index_mut(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeFrom<usize>> for IterMut<'a, T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n+        self.index_mut(RangeFull).index_mut(index)\n+    }\n }\n #[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<RangeFull> for IterMut<'a, T> {\n+\n+    #[cfg(stage0)]\n     #[inline]\n     fn index_mut(&mut self, _index: &RangeFull) -> &mut [T] {\n         make_mut_slice!(T => &mut [T]: self.ptr, self.end)\n     }\n+\n+    #[cfg(not(stage0))]\n+    #[inline]\n+    fn index_mut(&mut self, _index: RangeFull) -> &mut [T] {\n+        make_mut_slice!(T => &mut [T]: self.ptr, self.end)\n+    }\n }\n \n "}, {"sha": "b7285d30a7309cc9451a22aef5e4ba7170a3c250", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -1292,6 +1292,7 @@ mod traits {\n     /// // byte 100 is outside the string\n     /// // &s[3 .. 100];\n     /// ```\n+    #[cfg(stage0)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::Range<usize>> for str {\n         type Output = str;\n@@ -1308,6 +1309,49 @@ mod traits {\n         }\n     }\n \n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`..`end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Panics when `begin` and `end` do not point to valid characters\n+    /// or point beyond the last character of the string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(&s[0 .. 1], \"L\");\n+    ///\n+    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n+    ///\n+    /// // these will panic:\n+    /// // byte 2 lies within `\u00f6`:\n+    /// // &s[2 ..3];\n+    ///\n+    /// // byte 8 lies within `\u8001`\n+    /// // &s[1 .. 8];\n+    ///\n+    /// // byte 100 is outside the string\n+    /// // &s[3 .. 100];\n+    /// ```\n+    #[cfg(not(stage0))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl ops::Index<ops::Range<usize>> for str {\n+        type Output = str;\n+        #[inline]\n+        fn index(&self, index: ops::Range<usize>) -> &str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if index.start <= index.end &&\n+               self.is_char_boundary(index.start) &&\n+               self.is_char_boundary(index.end) {\n+                unsafe { self.slice_unchecked(index.start, index.end) }\n+            } else {\n+                super::slice_error_fail(self, index.start, index.end)\n+            }\n+        }\n+    }\n+\n     /// Returns a slice of the string from the beginning to byte\n     /// `end`.\n     ///\n@@ -1318,6 +1362,8 @@ mod traits {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeTo<usize>> for str {\n         type Output = str;\n+\n+        #[cfg(stage0)]\n         #[inline]\n         fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n@@ -1327,6 +1373,17 @@ mod traits {\n                 super::slice_error_fail(self, 0, index.end)\n             }\n         }\n+\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        fn index(&self, index: ops::RangeTo<usize>) -> &str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.end) {\n+                unsafe { self.slice_unchecked(0, index.end) }\n+            } else {\n+                super::slice_error_fail(self, 0, index.end)\n+            }\n+        }\n     }\n \n     /// Returns a slice of the string from `begin` to its end.\n@@ -1338,6 +1395,8 @@ mod traits {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFrom<usize>> for str {\n         type Output = str;\n+\n+        #[cfg(stage0)]\n         #[inline]\n         fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n@@ -1347,15 +1406,34 @@ mod traits {\n                 super::slice_error_fail(self, index.start, self.len())\n             }\n         }\n+\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        fn index(&self, index: ops::RangeFrom<usize>) -> &str {\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.start) {\n+                unsafe { self.slice_unchecked(index.start, self.len()) }\n+            } else {\n+                super::slice_error_fail(self, index.start, self.len())\n+            }\n+        }\n     }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl ops::Index<ops::RangeFull> for str {\n         type Output = str;\n+\n+        #[cfg(stage0)]\n         #[inline]\n         fn index(&self, _index: &ops::RangeFull) -> &str {\n             self\n         }\n+\n+        #[cfg(not(stage0))]\n+        #[inline]\n+        fn index(&self, _index: ops::RangeFull) -> &str {\n+            self\n+        }\n     }\n }\n "}, {"sha": "f201ff374ea0f058db497bebce436a4dc34d06ea", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -111,7 +111,7 @@ impl CStore {\n     }\n \n     pub fn get_crate_data(&self, cnum: ast::CrateNum) -> Rc<crate_metadata> {\n-        (*self.metas.borrow())[cnum].clone()\n+        self.metas.borrow().get(&cnum).unwrap().clone()\n     }\n \n     pub fn get_crate_hash(&self, cnum: ast::CrateNum) -> Svh {"}, {"sha": "fa8d0b2a56e4ee34b8e062ed0bac19948f730897", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -375,7 +375,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n     match ecx.tcx.inherent_impls.borrow().get(&exp.def_id) {\n         Some(implementations) => {\n             for base_impl_did in &**implementations {\n-                for &method_did in &*(*impl_items)[*base_impl_did] {\n+                for &method_did in impl_items.get(base_impl_did).unwrap() {\n                     let impl_item = ty::impl_or_trait_item(\n                         ecx.tcx,\n                         method_did.def_id());\n@@ -1175,7 +1175,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n-        let items = &(*impl_items)[def_id];\n+        let items = impl_items.get(&def_id).unwrap();\n \n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n@@ -1816,7 +1816,7 @@ struct ImplVisitor<'a, 'b:'a, 'c:'a, 'tcx:'b> {\n impl<'a, 'b, 'c, 'tcx, 'v> Visitor<'v> for ImplVisitor<'a, 'b, 'c, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n         if let ast::ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let def_id = self.ecx.tcx.def_map.borrow()[trait_ref.ref_id].def_id();\n+            let def_id = self.ecx.tcx.def_map.borrow().get(&trait_ref.ref_id).unwrap().def_id();\n \n             // Load eagerly if this is an implementation of the Drop trait\n             // or if the trait is not defined in this crate."}, {"sha": "801350e8a1e9c1d50d29d9f28d66f9c7add566ad", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -1228,7 +1228,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                     var_id: var_id,\n                     closure_expr_id: id\n                 };\n-                let upvar_capture = tcx.upvar_capture_map.borrow()[upvar_id].clone();\n+                let upvar_capture = tcx.upvar_capture_map.borrow().get(&upvar_id).unwrap().clone();\n                 var_id.encode(rbml_w);\n                 upvar_capture.encode(rbml_w);\n             })"}, {"sha": "97cd9456098b1bbab4fb5b8947975d9d46af1399", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -874,7 +874,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         ast::PatEnum(_, ref args) => {\n-            let def = cx.tcx.def_map.borrow()[pat_id].full_def();\n+            let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             match def {\n                 DefConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\\n@@ -892,7 +892,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n \n         ast::PatStruct(_, ref pattern_fields, _) => {\n             // Is this a struct or an enum variant?\n-            let def = cx.tcx.def_map.borrow()[pat_id].full_def();\n+            let def = cx.tcx.def_map.borrow().get(&pat_id).unwrap().full_def();\n             let class_id = match def {\n                 DefConst(..) =>\n                     cx.tcx.sess.span_bug(pat_span, \"const pattern should've \\"}, {"sha": "f9598237ff460805cc0494475f97820ff385fb3d", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -150,7 +150,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr, span: Span) -> P<ast::Pat>\n             ast::PatTup(exprs.iter().map(|expr| const_expr_to_pat(tcx, &**expr, span)).collect()),\n \n         ast::ExprCall(ref callee, ref args) => {\n-            let def = tcx.def_map.borrow()[callee.id];\n+            let def = *tcx.def_map.borrow().get(&callee.id).unwrap();\n             if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n                entry.insert(def);\n             }"}, {"sha": "6d4d759476ed5330edde04b58b498f294dc99498", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -158,7 +158,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &ast::Pat,\n                                   pats: &[codemap::Spanned<ast::FieldPat>]) {\n-        let id = match self.tcx.def_map.borrow()[lhs.id].full_def() {\n+        let id = match self.tcx.def_map.borrow().get(&lhs.id).unwrap().full_def() {\n             def::DefVariant(_, id, _) => id,\n             _ => {\n                 match ty::ty_to_def_id(ty::node_id_to_type(self.tcx,\n@@ -496,7 +496,7 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             None => (),\n             Some(impl_list) => {\n                 for impl_did in &**impl_list {\n-                    for item_did in &(*impl_items)[*impl_did] {\n+                    for item_did in &*impl_items.get(impl_did).unwrap() {\n                         if self.live_symbols.contains(&item_did.def_id()\n                                                                .node) {\n                             return true;"}, {"sha": "5d970c59f639bd5e3b4a289a7419ce7ddb52dfd0", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -141,7 +141,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         match expr.node {\n             ast::ExprMethodCall(_, _, _) => {\n                 let method_call = MethodCall::expr(expr.id);\n-                let base_type = (*self.tcx.method_map.borrow())[method_call].ty;\n+                let base_type = self.tcx.method_map.borrow().get(&method_call).unwrap().ty;\n                 debug!(\"effect: method call case, base type is {}\",\n                        ppaux::ty_to_string(self.tcx, base_type));\n                 if type_is_unsafe_function(base_type) {"}, {"sha": "97314b57ef656802a6b773495566051c7a27978c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -442,7 +442,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 if !self.walk_overloaded_operator(expr,\n                                                   &**lhs,\n                                                   vec![&**rhs],\n-                                                  PassArgs::ByRef) {\n+                                                  PassArgs::ByValue) {\n                     self.select_from_expr(&**lhs);\n                     self.consume_expr(&**rhs);\n                 }\n@@ -1012,7 +1012,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n-                let def = def_map.borrow()[pat.id].full_def();\n+                let def = def_map.borrow().get(&pat.id).unwrap().full_def();\n                 match mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     Ok(binding_cmt) => {\n                         delegate.mutate(pat.id, pat.span, binding_cmt, Init);"}, {"sha": "553e3601806677ed1bc37f4ba22ddc4a9fbe7a3e", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -1533,7 +1533,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     ConstrainVarSubReg(_, region) => {\n                         state.result.push(RegionAndOrigin {\n                             region: region,\n-                            origin: this.constraints.borrow()[edge.data].clone()\n+                            origin: this.constraints.borrow().get(&edge.data).unwrap().clone()\n                         });\n                     }\n                 }"}, {"sha": "705f20559afde27711c2c0934f7aba5c68aa5df0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -448,7 +448,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       ast::ExprPath(..) => {\n-        let def = ir.tcx.def_map.borrow()[expr.id].full_def();\n+        let def = ir.tcx.def_map.borrow().get(&expr.id).unwrap().full_def();\n         debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n         if let DefLocal(..) = def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -1302,7 +1302,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n-        match self.ir.tcx.def_map.borrow()[expr.id].full_def() {\n+        match self.ir.tcx.def_map.borrow().get(&expr.id).unwrap().full_def() {\n           DefLocal(nid) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0 {\n@@ -1564,7 +1564,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn check_lvalue(&mut self, expr: &Expr) {\n         match expr.node {\n             ast::ExprPath(..) => {\n-                if let DefLocal(nid) = self.ir.tcx.def_map.borrow()[expr.id].full_def() {\n+                if let DefLocal(nid) = self.ir.tcx.def_map.borrow().get(&expr.id)\n+                                                                   .unwrap()\n+                                                                   .full_def() {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability"}, {"sha": "bdcfc67f92b997a370cad0693f2eab1f729c626f", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -531,7 +531,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::ExprPath(..) => {\n-            let def = self.tcx().def_map.borrow()[expr.id].full_def();\n+            let def = self.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n "}, {"sha": "1bd45b5fc86017cd5a8afea2c994c2e181397d9e", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -128,7 +128,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             }\n             ast::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                match (*self.tcx.method_map.borrow())[method_call].origin {\n+                match (*self.tcx.method_map.borrow()).get(&method_call).unwrap().origin {\n                     ty::MethodStatic(def_id) => {\n                         if is_local(def_id) {\n                             if self.def_id_represents_local_inlined_item(def_id) {"}, {"sha": "d12b737619c8db4d1086a2dab3422f346ff8bb39", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -319,7 +319,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n         // individually as it's possible to have a stable trait with unstable\n         // items.\n         ast::ItemImpl(_, _, _, Some(ref t), _, ref impl_items) => {\n-            let trait_did = tcx.def_map.borrow()[t.ref_id].def_id();\n+            let trait_did = tcx.def_map.borrow().get(&t.ref_id).unwrap().def_id();\n             let trait_items = ty::trait_items(tcx, trait_did);\n \n             for impl_item in impl_items {"}, {"sha": "92d54887308d645e1de0e11c96b388aca2721060", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -854,10 +854,10 @@ fn confirm_impl_candidate<'cx,'tcx>(\n     let impl_items_map = selcx.tcx().impl_items.borrow();\n     let impl_or_trait_items_map = selcx.tcx().impl_or_trait_items.borrow();\n \n-    let impl_items = &impl_items_map[impl_vtable.impl_def_id];\n+    let impl_items = impl_items_map.get(&impl_vtable.impl_def_id).unwrap();\n     let mut impl_ty = None;\n     for impl_item in impl_items {\n-        let assoc_type = match impl_or_trait_items_map[impl_item.def_id()] {\n+        let assoc_type = match *impl_or_trait_items_map.get(&impl_item.def_id()).unwrap() {\n             ty::TypeTraitItem(ref assoc_type) => assoc_type.clone(),\n             ty::MethodTraitItem(..) => { continue; }\n         };"}, {"sha": "e5e89c3fbd4b9802ed729631f7ad8dbafec6195f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -2668,22 +2668,22 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn closure_kind(&self, def_id: ast::DefId) -> ty::ClosureKind {\n-        self.closure_kinds.borrow()[def_id]\n+        *self.closure_kinds.borrow().get(&def_id).unwrap()\n     }\n \n     pub fn closure_type(&self,\n                         def_id: ast::DefId,\n                         substs: &subst::Substs<'tcx>)\n                         -> ty::ClosureTy<'tcx>\n     {\n-        self.closure_tys.borrow()[def_id].subst(self, substs)\n+        self.closure_tys.borrow().get(&def_id).unwrap().subst(self, substs)\n     }\n \n     pub fn type_parameter_def(&self,\n                               node_id: ast::NodeId)\n                               -> TypeParameterDef<'tcx>\n     {\n-        self.ty_param_defs.borrow()[node_id].clone()\n+        self.ty_param_defs.borrow().get(&node_id).unwrap().clone()\n     }\n \n     pub fn pat_contains_ref_binding(&self, pat: &ast::Pat) -> bool {\n@@ -6546,7 +6546,7 @@ impl<'tcx> ctxt<'tcx> {\n     }\n \n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        Some(self.upvar_capture_map.borrow()[upvar_id].clone())\n+        Some(self.upvar_capture_map.borrow().get(&upvar_id).unwrap().clone())\n     }\n }\n "}, {"sha": "2834fce5278c85ab7b3caf36f3de0a47425e6a30", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -486,7 +486,7 @@ impl<'tcx> MoveData<'tcx> {\n             match path.loan_path.kind {\n                 LpVar(..) | LpUpvar(..) | LpDowncast(..) => {\n                     let kill_scope = path.loan_path.kill_scope(tcx);\n-                    let path = self.path_map.borrow()[path.loan_path];\n+                    let path = *self.path_map.borrow().get(&path.loan_path).unwrap();\n                     self.kill_moves(path, kill_scope.node_id(), dfcx_moves);\n                 }\n                 LpExtend(..) => {}"}, {"sha": "e65fe904dd29af28eb5e1a3e1dad8e836afde366", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -418,7 +418,7 @@ struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_def(&mut self, sp: Span, id: ast::NodeId) {\n-        match self.cx.tcx.def_map.borrow()[id].full_def() {\n+        match self.cx.tcx.def_map.borrow().get(&id).unwrap().full_def() {\n             def::DefPrimTy(ast::TyInt(ast::TyIs(_))) => {\n                 self.cx.span_lint(IMPROPER_CTYPES, sp,\n                                   \"found rust type `isize` in foreign module, while \\"}, {"sha": "2e7fe91365a13475dabf5e99106be2e2b82421dd", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n             ast::ItemImpl(_, _, _, _, ref ty, ref impl_items) => {\n                 let public_ty = match ty.node {\n                     ast::TyPath(..) => {\n-                        match self.tcx.def_map.borrow()[ty.id].full_def() {\n+                        match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n                             def::DefPrimTy(..) => true,\n                             def => {\n                                 let did = def.def_id();\n@@ -317,7 +317,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n \n             ast::ItemTy(ref ty, _) if public_first => {\n                 if let ast::TyPath(..) = ty.node {\n-                    match self.tcx.def_map.borrow()[ty.id].full_def() {\n+                    match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n                         def::DefPrimTy(..) | def::DefTyParam(..) => {},\n                         def => {\n                             let did = def.def_id();\n@@ -349,7 +349,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         // crate module gets processed as well.\n         if self.prev_exported {\n             assert!(self.export_map.contains_key(&id), \"wut {}\", id);\n-            for export in &self.export_map[id] {\n+            for export in self.export_map.get(&id).unwrap() {\n                 if is_local(export.def_id) {\n                     self.reexports.insert(export.def_id.node);\n                 }\n@@ -525,7 +525,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             // if we've reached the root, then everything was allowable and this\n             // access is public.\n             if closest_private_id == ast::CRATE_NODE_ID { return Allowable }\n-            closest_private_id = self.parents[closest_private_id];\n+            closest_private_id = *self.parents.get(&closest_private_id).unwrap();\n \n             // If we reached the top, then we were public all the way down and\n             // we can allow this access.\n@@ -543,7 +543,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     /// whether the node is accessible by the current module that iteration is\n     /// inside.\n     fn private_accessible(&self, id: ast::NodeId) -> bool {\n-        let parent = self.parents[id];\n+        let parent = *self.parents.get(&id).unwrap();\n         debug!(\"privacy - accessible parent {}\", self.nodestr(parent));\n \n         // After finding `did`'s closest private member, we roll ourselves back\n@@ -567,7 +567,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 _ => {}\n             }\n \n-            cur = self.parents[cur];\n+            cur = *self.parents.get(&cur).unwrap();\n         }\n     }\n \n@@ -622,7 +622,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                             ast::TyPath(..) => {}\n                             _ => return Some((err_span, err_msg, None)),\n                         };\n-                        let def = self.tcx.def_map.borrow()[ty.id].full_def();\n+                        let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n                         let did = def.def_id();\n                         assert!(is_local(did));\n                         match self.tcx.map.get(did.node) {\n@@ -708,7 +708,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     // Checks that a path is in scope.\n     fn check_path(&mut self, span: Span, path_id: ast::NodeId, last: ast::Ident) {\n         debug!(\"privacy - path {}\", self.nodestr(path_id));\n-        let path_res = self.tcx.def_map.borrow()[path_id];\n+        let path_res = *self.tcx.def_map.borrow().get(&path_id).unwrap();\n         let ck = |tyname: &str| {\n             let ck_public = |def: ast::DefId| {\n                 debug!(\"privacy - ck_public {:?}\", def);\n@@ -881,7 +881,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         }\n                     }\n                     ty::ty_enum(_, _) => {\n-                        match self.tcx.def_map.borrow()[expr.id].full_def() {\n+                        match self.tcx.def_map.borrow().get(&expr.id).unwrap().full_def() {\n                             def::DefVariant(_, variant_id, _) => {\n                                 for field in fields {\n                                     self.check_field(expr.span, variant_id,"}, {"sha": "bb7880161d5d4e364b2ebc7701468e64d3820a77", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -1141,9 +1141,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     // involves just passing the right -l flag.\n \n     let data = if dylib {\n-        &trans.crate_formats[config::CrateTypeDylib]\n+        trans.crate_formats.get(&config::CrateTypeDylib).unwrap()\n     } else {\n-        &trans.crate_formats[config::CrateTypeExecutable]\n+        trans.crate_formats.get(&config::CrateTypeExecutable).unwrap()\n     };\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of"}, {"sha": "53aa6d44fe7e86f014df2b7a65737af761883975", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -219,7 +219,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n                                   ref_id));\n         }\n-        let def = self.analysis.ty_cx.def_map.borrow()[ref_id].full_def();\n+        let def = self.analysis.ty_cx.def_map.borrow().get(&ref_id).unwrap().full_def();\n         match def {\n             def::DefPrimTy(_) => None,\n             _ => Some(def.def_id()),\n@@ -232,7 +232,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n                                              ref_id));\n         }\n-        let def = def_map[ref_id].full_def();\n+        let def = def_map.get(&ref_id).unwrap().full_def();\n         match def {\n             def::DefMod(_) |\n             def::DefForeignMod(_) => Some(recorder::ModRef),\n@@ -269,8 +269,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.collecting = false;\n             let span_utils = self.span.clone();\n             for &(id, ref p, _, _) in &self.collected_paths {\n-                let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n-                    (*self.analysis.ty_cx.node_types.borrow())[id]);\n+                let typ =\n+                    ppaux::ty_to_string(\n+                        &self.analysis.ty_cx,\n+                        *self.analysis.ty_cx.node_types.borrow().get(&id).unwrap());\n                 // get the span only for the name of the variable (I hope the path is only ever a\n                 // variable name, but who knows?)\n                 self.fmt.formal_str(p.span,\n@@ -431,8 +433,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             ast::NamedField(ident, _) => {\n                 let name = get_ident(ident);\n                 let qualname = format!(\"{}::{}\", qualname, name);\n-                let typ = ppaux::ty_to_string(&self.analysis.ty_cx,\n-                    (*self.analysis.ty_cx.node_types.borrow())[field.node.id]);\n+                let typ =\n+                    ppaux::ty_to_string(\n+                        &self.analysis.ty_cx,\n+                        *self.analysis.ty_cx.node_types.borrow().get(&field.node.id).unwrap());\n                 match self.span.sub_span_before_token(field.span, token::Colon) {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n@@ -789,7 +793,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.sess.span_bug(span,\n                                &format!(\"def_map has no key for {} in visit_expr\", id));\n         }\n-        let def = def_map[id].full_def();\n+        let def = def_map.get(&id).unwrap().full_def();\n         let sub_span = self.span.span_for_last_ident(span);\n         match def {\n             def::DefUpvar(..) |\n@@ -832,7 +836,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                  .ty_cx\n                                                  .impl_items\n                                                  .borrow();\n-                            Some((*impl_items)[def_id]\n+                            Some(impl_items.get(&def_id)\n+                                           .unwrap()\n                                            .iter()\n                                            .find(|mr| {\n                                                 ty::impl_or_trait_item(\n@@ -941,7 +946,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                            ex: &ast::Expr,\n                            args: &Vec<P<ast::Expr>>) {\n         let method_map = self.analysis.ty_cx.method_map.borrow();\n-        let method_callee = &(*method_map)[ty::MethodCall::expr(ex.id)];\n+        let method_callee = method_map.get(&ty::MethodCall::expr(ex.id)).unwrap();\n         let (def_id, decl_id) = match method_callee.origin {\n             ty::MethodStatic(def_id) |\n             ty::MethodStaticClosure(def_id) => {\n@@ -1001,7 +1006,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 self.collected_paths.push((p.id, path.clone(), false, recorder::StructRef));\n                 visit::walk_path(self, path);\n \n-                let def = self.analysis.ty_cx.def_map.borrow()[p.id].full_def();\n+                let def = self.analysis.ty_cx.def_map.borrow().get(&p.id).unwrap().full_def();\n                 let struct_def = match def {\n                     def::DefConst(..) => None,\n                     def::DefVariant(_, variant_id, _) => Some(variant_id),\n@@ -1113,7 +1118,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         let glob_map = &self.analysis.glob_map;\n                         let glob_map = glob_map.as_ref().unwrap();\n                         if glob_map.contains_key(&item.id) {\n-                            for n in &glob_map[item.id] {\n+                            for n in glob_map.get(&item.id).unwrap() {\n                                 if name_string.len() > 0 {\n                                     name_string.push_str(\", \");\n                                 }\n@@ -1406,7 +1411,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                    &format!(\"def_map has no key for {} in visit_arm\",\n                                            id));\n             }\n-            let def = def_map[id].full_def();\n+            let def = def_map.get(&id).unwrap().full_def();\n             match def {\n                 def::DefLocal(id)  => {\n                     let value = if *immut {\n@@ -1467,7 +1472,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         for &(id, ref p, ref immut, _) in &self.collected_paths {\n             let value = if *immut { value.to_string() } else { \"<mutable>\".to_string() };\n             let types = self.analysis.ty_cx.node_types.borrow();\n-            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, (*types)[id]);\n+            let typ = ppaux::ty_to_string(&self.analysis.ty_cx, *types.get(&id).unwrap());\n             // Get the span only for the name of the variable (I hope the path\n             // is only ever a variable name, but who knows?).\n             let sub_span = self.span.span_for_last_ident(p.span);"}, {"sha": "eb759393ac6eca125f2432641e792c9d37575c2d", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -1017,7 +1017,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         None => {\n             let data = &m[0].data;\n             for &(ref ident, ref value_ptr) in &m[0].bound_ptrs {\n-                let binfo = data.bindings_map[*ident];\n+                let binfo = *data.bindings_map.get(ident).unwrap();\n                 call_lifetime_start(bcx, binfo.llmatch);\n                 if binfo.trmode == TrByRef && type_is_fat_ptr(bcx.tcx(), binfo.ty) {\n                     expr::copy_fat_ptr(bcx, *value_ptr, binfo.llmatch);"}, {"sha": "62ac6a81b1923dc042357256d2ac8e4dec0a184c", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -269,7 +269,7 @@ pub fn self_type_for_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn kind_for_closure(ccx: &CrateContext, closure_id: ast::DefId) -> ty::ClosureKind {\n-    ccx.tcx().closure_kinds.borrow()[closure_id]\n+    *ccx.tcx().closure_kinds.borrow().get(&closure_id).unwrap()\n }\n \n pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n@@ -2322,7 +2322,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                                          static\");\n               }\n \n-              let v = ccx.static_values().borrow()[item.id].clone();\n+              let v = ccx.static_values().borrow().get(&item.id).unwrap().clone();\n               unsafe {\n                   if !(llvm::LLVMConstIntGetZExtValue(v) != 0) {\n                       ccx.sess().span_fatal(expr.span, \"static assertion failed\");"}, {"sha": "088a34857e753a8991be403b55d93da17de960b4", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -511,7 +511,7 @@ pub fn trans_fn_ref_with_substs<'a, 'tcx>(\n             let ref_ty = match node {\n                 ExprId(id) => ty::node_id_to_type(tcx, id),\n                 MethodCallKey(method_call) => {\n-                    (*tcx.method_map.borrow())[method_call].ty\n+                    tcx.method_map.borrow().get(&method_call).unwrap().ty\n                 }\n             };\n             let ref_ty = monomorphize::apply_param_substs(tcx,"}, {"sha": "61cdde3bfbecd775a24346f063341a12e8bff644", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -709,7 +709,7 @@ impl<'blk, 'tcx> mc::Typer<'tcx> for BlockS<'blk, 'tcx> {\n     }\n \n     fn upvar_capture(&self, upvar_id: ty::UpvarId) -> Option<ty::UpvarCapture> {\n-        Some(self.tcx().upvar_capture_map.borrow()[upvar_id].clone())\n+        Some(self.tcx().upvar_capture_map.borrow().get(&upvar_id).unwrap().clone())\n     }\n \n     fn type_moves_by_default(&self, span: Span, ty: Ty<'tcx>) -> bool {\n@@ -1206,7 +1206,7 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             ty::node_id_item_substs(tcx, id).substs\n         }\n         MethodCallKey(method_call) => {\n-            (*tcx.method_map.borrow())[method_call].substs.clone()\n+            tcx.method_map.borrow().get(&method_call).unwrap().substs.clone()\n         }\n     };\n "}, {"sha": "4b1a03e47e7aebb1f2ef30bf261659b61204e2b4", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -187,7 +187,7 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Special-case constants to cache a common global for all uses.\n     match expr.node {\n         ast::ExprPath(..) => {\n-            let def = ccx.tcx().def_map.borrow()[expr.id].full_def();\n+            let def = ccx.tcx().def_map.borrow().get(&expr.id).unwrap().full_def();\n             match def {\n                 def::DefConst(def_id) => {\n                     if !ccx.tcx().adjustments.borrow().contains_key(&expr.id) {\n@@ -665,7 +665,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n           }\n           ast::ExprPath(..) => {\n-            let def = cx.tcx().def_map.borrow()[e.id].full_def();\n+            let def = cx.tcx().def_map.borrow().get(&e.id).unwrap().full_def();\n             match def {\n                 def::DefFn(..) | def::DefMethod(..) => {\n                     expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n@@ -751,7 +751,7 @@ pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) {\n         let g = base::get_item_val(ccx, id);\n         // At this point, get_item_val has already translated the\n         // constant's initializer to determine its LLVM type.\n-        let v = ccx.static_values().borrow()[id].clone();\n+        let v = ccx.static_values().borrow().get(&id).unwrap().clone();\n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n         let v = if llvm::LLVMTypeOf(v) == Type::i1(ccx).to_ref() {"}, {"sha": "ceb9a29efa8879a9d30ad4544d812c579e87f97f", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -126,7 +126,7 @@ pub fn trans_into<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return datum.store_to_dest(bcx, dest, expr.id);\n     }\n \n-    let qualif = bcx.tcx().const_qualif_map.borrow()[expr.id];\n+    let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n     if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n         if !qualif.intersects(check_const::PREFER_IN_PLACE) {\n             if let SaveIn(lldest) = dest {\n@@ -209,7 +209,7 @@ pub fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let mut bcx = bcx;\n     let fcx = bcx.fcx;\n-    let qualif = bcx.tcx().const_qualif_map.borrow()[expr.id];\n+    let qualif = *bcx.tcx().const_qualif_map.borrow().get(&expr.id).unwrap();\n     let adjusted_global = !qualif.intersects(check_const::NON_STATIC_BORROWS);\n     let global = if !qualif.intersects(check_const::NOT_CONST | check_const::NEEDS_DROP) {\n         let global = consts::get_const_expr_as_global(bcx.ccx(), expr, qualif,\n@@ -843,7 +843,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                base_datum,\n                                                vec![(ix_datum, idx.id)],\n                                                Some(SaveIn(scratch.val)),\n-                                               true));\n+                                               false));\n             let datum = scratch.to_expr_datum();\n             if type_is_sized(bcx.tcx(), elt_ty) {\n                 Datum::new(datum.to_llscalarish(bcx), elt_ty, LvalueExpr)\n@@ -1405,7 +1405,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                         ty.repr(tcx)));\n                 }\n                 Some(node_id) => {\n-                    let def = tcx.def_map.borrow()[node_id].full_def();\n+                    let def = tcx.def_map.borrow().get(&node_id).unwrap().full_def();\n                     match def {\n                         def::DefVariant(enum_id, variant_id, _) => {\n                             let variant_info = ty::enum_variant_with_id(tcx, enum_id, variant_id);\n@@ -1964,7 +1964,7 @@ fn trans_overloaded_op<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    dest: Option<Dest>,\n                                    autoref: bool)\n                                    -> Result<'blk, 'tcx> {\n-    let method_ty = (*bcx.tcx().method_map.borrow())[method_call].ty;\n+    let method_ty = bcx.tcx().method_map.borrow().get(&method_call).unwrap().ty;\n     callee::trans_call_inner(bcx,\n                              expr.debug_loc(),\n                              monomorphize_type(bcx, method_ty),\n@@ -1985,10 +1985,12 @@ fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                          dest: Option<Dest>)\n                                          -> Block<'blk, 'tcx> {\n     let method_call = MethodCall::expr(expr.id);\n-    let method_type = (*bcx.tcx()\n-                           .method_map\n-                           .borrow())[method_call]\n-                           .ty;\n+    let method_type = bcx.tcx()\n+                         .method_map\n+                         .borrow()\n+                         .get(&method_call)\n+                         .unwrap()\n+                         .ty;\n     let mut all_args = vec!(callee);\n     all_args.extend(args.iter().map(|e| &**e));\n     unpack_result!(bcx,"}, {"sha": "71900855266e9f4e7fc1b411d13cd65909460e11", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -1046,7 +1046,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         return (tcx.types.err, ty_path_def);\n     };\n \n-    let ty_param_name = tcx.ty_param_defs.borrow()[ty_param_node_id].name;\n+    let ty_param_name = tcx.ty_param_defs.borrow().get(&ty_param_node_id).unwrap().name;\n \n     let bounds = match this.get_type_parameter_bounds(span, ty_param_node_id) {\n         Ok(v) => v,"}, {"sha": "e8da19efa06afd790bb966de830e877e5f9e498f", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -119,7 +119,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n             demand::eqtype(fcx, pat.span, expected, lhs_ty);\n         }\n         ast::PatEnum(..) | ast::PatIdent(..) if pat_is_const(&tcx.def_map, pat) => {\n-            let const_did = tcx.def_map.borrow()[pat.id].def_id();\n+            let const_did = tcx.def_map.borrow().get(&pat.id).unwrap().def_id();\n             let const_scheme = ty::lookup_item_type(tcx, const_did);\n             assert!(const_scheme.generics.is_empty());\n             let const_ty = pcx.fcx.instantiate_type_scheme(pat.span,\n@@ -163,7 +163,7 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n \n             // if there are multiple arms, make sure they all agree on\n             // what the type of the binding `x` ought to be\n-            let canon_id = pcx.map[path.node];\n+            let canon_id = *pcx.map.get(&path.node).unwrap();\n             if canon_id != pat.id {\n                 let ct = fcx.local_ty(pat.span, canon_id);\n                 demand::eqtype(fcx, pat.span, ct, typ);\n@@ -463,7 +463,7 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow()[pat.id].full_def();\n+    let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n     let (enum_def_id, variant_def_id) = match def {\n         def::DefTrait(_) => {\n             let name = pprust::path_to_string(path);\n@@ -532,7 +532,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let def = tcx.def_map.borrow()[pat.id].full_def();\n+    let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n     let enum_def = def.variant_def_ids()\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n "}, {"sha": "0eb71244ac075fe661dbcc224e643b190d8d696b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -368,7 +368,7 @@ impl<'a, 'tcx> ty::ClosureTyper<'tcx> for FnCtxt<'a, 'tcx> {\n                     substs: &subst::Substs<'tcx>)\n                     -> ty::ClosureTy<'tcx>\n     {\n-        self.inh.closure_tys.borrow()[def_id].subst(self.tcx(), substs)\n+        self.inh.closure_tys.borrow().get(&def_id).unwrap().subst(self.tcx(), substs)\n     }\n \n     fn closure_upvars(&self,\n@@ -549,7 +549,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n         debug!(\"Local variable {} is assigned type {}\",\n                self.fcx.pat_to_string(&*local.pat),\n                self.fcx.infcx().ty_to_string(\n-                   self.fcx.inh.locals.borrow()[local.id].clone()));\n+                   self.fcx.inh.locals.borrow().get(&local.id).unwrap().clone()));\n         visit::walk_local(self, local);\n     }\n \n@@ -565,7 +565,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n                 debug!(\"Pattern binding {} is assigned to {} with type {}\",\n                        token::get_ident(path1.node),\n                        self.fcx.infcx().ty_to_string(\n-                           self.fcx.inh.locals.borrow()[p.id].clone()),\n+                           self.fcx.inh.locals.borrow().get(&p.id).unwrap().clone()),\n                        var_ty.repr(self.fcx.tcx()));\n             }\n         }\n@@ -3327,7 +3327,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 let mut missing_fields = Vec::new();\n                 for class_field in field_types {\n                     let name = class_field.name;\n-                    let (_, seen) = class_field_map[name];\n+                    let (_, seen) = *class_field_map.get(&name).unwrap();\n                     if !seen {\n                         missing_fields.push(\n                             format!(\"`{}`\", &token::get_name(name)))\n@@ -4444,7 +4444,7 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let inh = static_inherited_fields(ccx);\n     let rty = ty::node_id_to_type(ccx.tcx, id);\n     let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(rty), e.id);\n-    let declty = (*fcx.ccx.tcx.tcache.borrow())[local_def(id)].ty;\n+    let declty = fcx.ccx.tcx.tcache.borrow().get(&local_def(id)).unwrap().ty;\n     check_const_with_ty(&fcx, sp, e, declty);\n }\n "}, {"sha": "340cca7d47e7a395619bb5ae60ce9d1724e800a6", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -448,7 +448,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx> {\n \n         let closure_def_id = ast_util::local_def(closure_id);\n         let mut closure_kinds = self.fcx.inh.closure_kinds.borrow_mut();\n-        let existing_kind = closure_kinds[closure_def_id];\n+        let existing_kind = *closure_kinds.get(&closure_def_id).unwrap();\n \n         debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n                closure_id, existing_kind, new_kind);"}, {"sha": "ffd99ff2eece081f7390195ea24506fe83ebb302", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n     fn get_self_type_for_implementation(&self, impl_did: DefId)\n                                         -> TypeScheme<'tcx> {\n-        self.crate_context.tcx.tcache.borrow()[impl_did].clone()\n+        self.crate_context.tcx.tcache.borrow().get(&impl_did).unwrap().clone()\n     }\n \n     // Converts an implementation in the AST to a vector of items.\n@@ -387,7 +387,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         };\n \n         for &impl_did in &*trait_impls.borrow() {\n-            let items = &(*impl_items)[impl_did];\n+            let items = impl_items.get(&impl_did).unwrap();\n             if items.len() < 1 {\n                 // We'll error out later. For now, just don't ICE.\n                 continue;"}, {"sha": "5efc26825eab19ef63b9c939aa5ee9c2ad588980", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -194,7 +194,7 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n \n     fn method_ty(&self, method_id: ast::NodeId) -> Rc<ty::Method<'tcx>> {\n         let def_id = local_def(method_id);\n-        match self.tcx.impl_or_trait_items.borrow()[def_id] {\n+        match *self.tcx.impl_or_trait_items.borrow().get(&def_id).unwrap() {\n             ty::MethodTraitItem(ref mty) => mty.clone(),\n             ty::TypeTraitItem(..) => {\n                 self.tcx.sess.bug(&format!(\"method with id {} has the wrong type\", method_id));\n@@ -545,7 +545,7 @@ fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n                   -> bool\n {\n     if let ast::TyPath(None, _) = ast_ty.node {\n-        let path_res = tcx.def_map.borrow()[ast_ty.id];\n+        let path_res = *tcx.def_map.borrow().get(&ast_ty.id).unwrap();\n         match path_res.base_def {\n             def::DefSelfTy(node_id) =>\n                 path_res.depth == 0 && node_id == param_id,\n@@ -1040,9 +1040,13 @@ fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 tcx.predicates.borrow_mut().insert(local_def(ctor_id), predicates);\n             } else if struct_def.fields[0].node.kind.is_unnamed() {\n                 // Tuple-like.\n-                let inputs: Vec<_> = struct_def.fields.iter().map(\n-                        |field| (*tcx.tcache.borrow())[\n-                            local_def(field.node.id)].ty).collect();\n+                let inputs: Vec<_> =\n+                    struct_def.fields\n+                              .iter()\n+                              .map(|field| tcx.tcache.borrow().get(&local_def(field.node.id))\n+                                                              .unwrap()\n+                                                              .ty)\n+                              .collect();\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n                                                 local_def(ctor_id),\n                                                 &inputs[..],"}, {"sha": "4d15abb91dc148f5044498eae7a42de4ded5e3d9", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -290,7 +290,7 @@ fn resolved_path(w: &mut fmt::Formatter, did: ast::DefId, p: &clean::Path,\n             if ast_util::is_local(did) || cache.inlined.contains(&did) {\n                 Some(repeat(\"../\").take(loc.len()).collect::<String>())\n             } else {\n-                match cache.extern_locations[did.krate] {\n+                match cache.extern_locations[&did.krate] {\n                     render::Remote(ref s) => Some(s.to_string()),\n                     render::Local => {\n                         Some(repeat(\"../\").take(loc.len()).collect::<String>())\n@@ -404,11 +404,11 @@ fn primitive_link(f: &mut fmt::Formatter,\n             needs_termination = true;\n         }\n         Some(&cnum) => {\n-            let path = &m.paths[ast::DefId {\n+            let path = &m.paths[&ast::DefId {\n                 krate: cnum,\n                 node: ast::CRATE_NODE_ID,\n             }];\n-            let loc = match m.extern_locations[cnum] {\n+            let loc = match m.extern_locations[&cnum] {\n                 render::Remote(ref s) => Some(s.to_string()),\n                 render::Local => {\n                     let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());"}, {"sha": "1b2fc5964ab9802e24dfe83f1f9b7fbe1acf2983", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -1404,8 +1404,8 @@ impl<'a> Item<'a> {\n         // located, then we return `None`.\n         } else {\n             let cache = cache();\n-            let path = &cache.external_paths[self.item.def_id];\n-            let root = match cache.extern_locations[self.item.def_id.krate] {\n+            let path = &cache.external_paths[&self.item.def_id];\n+            let root = match cache.extern_locations[&self.item.def_id.krate] {\n                 Remote(ref s) => s.to_string(),\n                 Local => self.cx.root_path.clone(),\n                 Unknown => return None,\n@@ -1863,7 +1863,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 path = if ast_util::is_local(it.def_id) {\n                     cx.current.connect(\"/\")\n                 } else {\n-                    let path = &cache.external_paths[it.def_id];\n+                    let path = &cache.external_paths[&it.def_id];\n                     path[..path.len() - 1].connect(\"/\")\n                 },\n                 ty = shortty(it).to_static_str(),"}, {"sha": "11e10cc2aa7a16cf004fdb8933d7e47283df978d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -196,7 +196,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             Some(tcx) => tcx,\n             None => return false\n         };\n-        let def = tcx.def_map.borrow()[id].def_id();\n+        let def = tcx.def_map.borrow()[&id].def_id();\n         if !ast_util::is_local(def) { return false }\n         let analysis = match self.analysis {\n             Some(analysis) => analysis, None => return false"}, {"sha": "abbfc82319f5b30e24035442aedaaa532c0e80a4", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -1218,6 +1218,7 @@ impl Json {\n     }\n }\n \n+#[cfg(stage0)]\n impl<'a> Index<&'a str>  for Json {\n     type Output = Json;\n \n@@ -1226,6 +1227,16 @@ impl<'a> Index<&'a str>  for Json {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'a> Index<&'a str>  for Json {\n+    type Output = Json;\n+\n+    fn index(&self, idx: &'a str) -> &Json {\n+        self.find(idx).unwrap()\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl Index<uint> for Json {\n     type Output = Json;\n \n@@ -1237,6 +1248,18 @@ impl Index<uint> for Json {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Index<uint> for Json {\n+    type Output = Json;\n+\n+    fn index<'a>(&'a self, idx: uint) -> &'a Json {\n+        match self {\n+            &Json::Array(ref v) => &v[idx],\n+            _ => panic!(\"can only index Json with uint if it is an array\")\n+        }\n+    }\n+}\n+\n /// The output of the streaming parser.\n #[derive(PartialEq, Clone, Debug)]\n pub enum JsonEvent {"}, {"sha": "86664d7eb0cf14ad9b81eaba3c3fe7a5be344bd0", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -1088,7 +1088,7 @@ impl<K, V, S> HashMap<K, V, S>\n     ///     Some(x) => *x = \"b\",\n     ///     None => (),\n     /// }\n-    /// assert_eq!(map[1], \"b\");\n+    /// assert_eq!(map[&1], \"b\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n@@ -1111,7 +1111,7 @@ impl<K, V, S> HashMap<K, V, S>\n     ///\n     /// map.insert(37, \"b\");\n     /// assert_eq!(map.insert(37, \"c\"), Some(\"b\"));\n-    /// assert_eq!(map[37], \"c\");\n+    /// assert_eq!(map[&37], \"c\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, k: K, v: V) -> Option<V> {\n@@ -1244,6 +1244,7 @@ impl<K, V, S> Default for HashMap<K, V, S>\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, Q: ?Sized, V, S> Index<Q> for HashMap<K, V, S>\n     where K: Eq + Hash + Borrow<Q>,\n@@ -1258,6 +1259,21 @@ impl<K, Q: ?Sized, V, S> Index<Q> for HashMap<K, V, S>\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, K, Q: ?Sized, V, S> Index<&'a Q> for HashMap<K, V, S>\n+    where K: Eq + Hash + Borrow<Q>,\n+          Q: Eq + Hash,\n+          S: HashState,\n+{\n+    type Output = V;\n+\n+    #[inline]\n+    fn index(&self, index: &Q) -> &V {\n+        self.get(index).expect(\"no entry found for key\")\n+    }\n+}\n+\n /// HashMap iterator.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a, K: 'a, V: 'a> {\n@@ -2185,7 +2201,7 @@ mod test_map {\n         map.insert(2, 1);\n         map.insert(3, 4);\n \n-        assert_eq!(map[2], 1);\n+        assert_eq!(map[&2], 1);\n     }\n \n     #[test]\n@@ -2197,7 +2213,7 @@ mod test_map {\n         map.insert(2, 1);\n         map.insert(3, 4);\n \n-        map[4];\n+        map[&4];\n     }\n \n     #[test]"}, {"sha": "5851c6e2998095923c744da0d01fceeb6556355b", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -133,6 +133,7 @@ impl<'a> From<&'a OsStr> for OsString {\n     }\n }\n \n+#[cfg(stage0)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Index<ops::RangeFull> for OsString {\n     type Output = OsStr;\n@@ -143,6 +144,17 @@ impl ops::Index<ops::RangeFull> for OsString {\n     }\n }\n \n+#[cfg(not(stage0))]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl ops::Index<ops::RangeFull> for OsString {\n+    type Output = OsStr;\n+\n+    #[inline]\n+    fn index(&self, _index: ops::RangeFull) -> &OsStr {\n+        unsafe { mem::transmute(self.inner.as_slice()) }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Deref for OsString {\n     type Target = OsStr;"}, {"sha": "9f3dae34c7a4bff3a127111110fa955d335748e3", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -634,6 +634,7 @@ impl Wtf8 {\n ///\n /// Panics when `begin` and `end` do not point to code point boundaries,\n /// or point beyond the end of the string.\n+#[cfg(stage0)]\n impl ops::Index<ops::Range<usize>> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -650,12 +651,36 @@ impl ops::Index<ops::Range<usize>> for Wtf8 {\n     }\n }\n \n+/// Return a slice of the given string for the byte range [`begin`..`end`).\n+///\n+/// # Panics\n+///\n+/// Panics when `begin` and `end` do not point to code point boundaries,\n+/// or point beyond the end of the string.\n+#[cfg(not(stage0))]\n+impl ops::Index<ops::Range<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: ops::Range<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if range.start <= range.end &&\n+           is_code_point_boundary(self, range.start) &&\n+           is_code_point_boundary(self, range.end) {\n+            unsafe { slice_unchecked(self, range.start, range.end) }\n+        } else {\n+            slice_error_fail(self, range.start, range.end)\n+        }\n+    }\n+}\n+\n /// Return a slice of the given string from byte `begin` to its end.\n ///\n /// # Panics\n ///\n /// Panics when `begin` is not at a code point boundary,\n /// or is beyond the end of the string.\n+#[cfg(stage0)]\n impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -670,12 +695,34 @@ impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n     }\n }\n \n+/// Return a slice of the given string from byte `begin` to its end.\n+///\n+/// # Panics\n+///\n+/// Panics when `begin` is not at a code point boundary,\n+/// or is beyond the end of the string.\n+#[cfg(not(stage0))]\n+impl ops::Index<ops::RangeFrom<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: ops::RangeFrom<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if is_code_point_boundary(self, range.start) {\n+            unsafe { slice_unchecked(self, range.start, self.len()) }\n+        } else {\n+            slice_error_fail(self, range.start, self.len())\n+        }\n+    }\n+}\n+\n /// Return a slice of the given string from its beginning to byte `end`.\n ///\n /// # Panics\n ///\n /// Panics when `end` is not at a code point boundary,\n /// or is beyond the end of the string.\n+#[cfg(stage0)]\n impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -690,6 +737,28 @@ impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n     }\n }\n \n+/// Return a slice of the given string from its beginning to byte `end`.\n+///\n+/// # Panics\n+///\n+/// Panics when `end` is not at a code point boundary,\n+/// or is beyond the end of the string.\n+#[cfg(not(stage0))]\n+impl ops::Index<ops::RangeTo<usize>> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, range: ops::RangeTo<usize>) -> &Wtf8 {\n+        // is_code_point_boundary checks that the index is in [0, .len()]\n+        if is_code_point_boundary(self, range.end) {\n+            unsafe { slice_unchecked(self, 0, range.end) }\n+        } else {\n+            slice_error_fail(self, 0, range.end)\n+        }\n+    }\n+}\n+\n+#[cfg(stage0)]\n impl ops::Index<ops::RangeFull> for Wtf8 {\n     type Output = Wtf8;\n \n@@ -699,6 +768,16 @@ impl ops::Index<ops::RangeFull> for Wtf8 {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl ops::Index<ops::RangeFull> for Wtf8 {\n+    type Output = Wtf8;\n+\n+    #[inline]\n+    fn index(&self, _range: ops::RangeFull) -> &Wtf8 {\n+        self\n+    }\n+}\n+\n #[inline]\n fn decode_surrogate(second_byte: u8, third_byte: u8) -> u16 {\n     // The first byte is assumed to be 0xED"}, {"sha": "1bf1b09681c4a360b03232187b31610730f7200a", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -716,7 +716,7 @@ mod dynamic_tests {\n         thread_local!(static FOO: RefCell<HashMap<i32, i32>> = map());\n \n         FOO.with(|map| {\n-            assert_eq!(map.borrow()[1], 2);\n+            assert_eq!(map.borrow()[&1], 2);\n         });\n     }\n "}, {"sha": "2fe77bf7a5411cbff2ed0c49a6acfeb769e32491", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -513,7 +513,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             let lname = self.ecx.ident_of(&format!(\"__arg{}\",\n                                                   *name));\n             pats.push(self.ecx.pat_ident(e.span, lname));\n-            names[self.name_positions[*name]] =\n+            names[*self.name_positions.get(name).unwrap()] =\n                 Some(Context::format_arg(self.ecx, e.span, arg_ty,\n                                          self.ecx.expr_ident(e.span, lname)));\n             heads.push(self.ecx.expr_addr_of(e.span, e));"}, {"sha": "5940b791843797cacf97c7225dd9a413e27d74c8", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -236,7 +236,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n                                      argument_gram);\n \n     // Extract the arguments:\n-    let lhses = match *argument_map[lhs_nm] {\n+    let lhses = match **argument_map.get(&lhs_nm).unwrap() {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(def.span, \"wrong-structured lhs\")\n     };\n@@ -245,7 +245,7 @@ pub fn compile<'cx>(cx: &'cx mut ExtCtxt,\n         check_lhs_nt_follows(cx, &**lhs, def.span);\n     }\n \n-    let rhses = match *argument_map[rhs_nm] {\n+    let rhses = match **argument_map.get(&rhs_nm).unwrap() {\n         MatchedSeq(ref s, _) => /* FIXME (#2543) */ (*s).clone(),\n         _ => cx.span_bug(def.span, \"wrong-structured rhs\")\n     };"}, {"sha": "604a3e69a21767909233a369c61149385b64a07a", "filename": "src/test/auxiliary/issue-2631-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2631-a.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -19,6 +19,6 @@ pub type header_map = HashMap<String, Rc<RefCell<Vec<Rc<String>>>>>;\n \n // the unused ty param is necessary so this gets monomorphized\n pub fn request<T>(req: &header_map) {\n-  let data = req[\"METHOD\".to_string()].clone();\n+  let data = req[&\"METHOD\".to_string()].clone();\n   let _x = data.borrow().clone()[0].clone();\n }"}, {"sha": "18db50a831ca8d5b840168b96550869729573054", "filename": "src/test/auxiliary/procedural_mbe_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fprocedural_mbe_matching.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -33,7 +33,7 @@ fn expand_mbe_matches(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n \n     let mac_expr = match TokenTree::parse(cx, &mbe_matcher[..], args) {\n         Success(map) => {\n-            match (&*map[str_to_ident(\"matched\")], &*map[str_to_ident(\"pat\")]) {\n+            match (&*map[&str_to_ident(\"matched\")], &*map[&str_to_ident(\"pat\")]) {\n                 (&MatchedNonterminal(NtExpr(ref matched_expr)),\n                  &MatchedSeq(ref pats, seq_sp)) => {\n                     let pats: Vec<P<Pat>> = pats.iter().map(|pat_nt|"}, {"sha": "bee56c9bf390bb17092d20dc86324435decad8e7", "filename": "src/test/compile-fail/borrowck-overloaded-index-and-overloaded-deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-and-overloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-and-overloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-and-overloaded-deref.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -19,7 +19,7 @@ struct MyVec<T> { x: T }\n \n impl<T> Index<usize> for MyVec<T> {\n     type Output = T;\n-    fn index(&self, _: &usize) -> &T {\n+    fn index(&self, _: usize) -> &T {\n         &self.x\n     }\n }"}, {"sha": "55a6e2ac7b8d6755f8bd2bcac6da1e07105a5d8e", "filename": "src/test/compile-fail/borrowck-overloaded-index-autoderef.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-autoderef.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -18,6 +18,7 @@ struct Foo {\n     y: isize,\n }\n \n+#[cfg(stage0)]\n impl Index<String> for Foo {\n     type Output = isize;\n \n@@ -30,8 +31,20 @@ impl Index<String> for Foo {\n     }\n }\n \n-impl IndexMut<String> for Foo {\n-    fn index_mut<'a>(&'a mut self, z: &String) -> &'a mut isize {\n+impl<'a> Index<&'a String> for Foo {\n+    type Output = isize;\n+\n+    fn index(&self, z: &String) -> &isize {\n+        if *z == \"x\" {\n+            &self.x\n+        } else {\n+            &self.y\n+        }\n+    }\n+}\n+\n+impl<'a> IndexMut<&'a String> for Foo {\n+    fn index_mut(&mut self, z: &String) -> &mut isize {\n         if *z == \"x\" {\n             &mut self.x\n         } else {\n@@ -41,51 +54,51 @@ impl IndexMut<String> for Foo {\n }\n \n fn test1(mut f: Box<Foo>, s: String) {\n-    let _p = &mut f[s];\n-    let _q = &f[s]; //~ ERROR cannot borrow\n+    let _p = &mut f[&s];\n+    let _q = &f[&s]; //~ ERROR cannot borrow\n }\n \n fn test2(mut f: Box<Foo>, s: String) {\n-    let _p = &mut f[s];\n-    let _q = &mut f[s]; //~ ERROR cannot borrow\n+    let _p = &mut f[&s];\n+    let _q = &mut f[&s]; //~ ERROR cannot borrow\n }\n \n struct Bar {\n     foo: Foo\n }\n \n fn test3(mut f: Box<Bar>, s: String) {\n-    let _p = &mut f.foo[s];\n-    let _q = &mut f.foo[s]; //~ ERROR cannot borrow\n+    let _p = &mut f.foo[&s];\n+    let _q = &mut f.foo[&s]; //~ ERROR cannot borrow\n }\n \n fn test4(mut f: Box<Bar>, s: String) {\n-    let _p = &f.foo[s];\n-    let _q = &f.foo[s];\n+    let _p = &f.foo[&s];\n+    let _q = &f.foo[&s];\n }\n \n fn test5(mut f: Box<Bar>, s: String) {\n-    let _p = &f.foo[s];\n-    let _q = &mut f.foo[s]; //~ ERROR cannot borrow\n+    let _p = &f.foo[&s];\n+    let _q = &mut f.foo[&s]; //~ ERROR cannot borrow\n }\n \n fn test6(mut f: Box<Bar>, g: Foo, s: String) {\n-    let _p = &f.foo[s];\n+    let _p = &f.foo[&s];\n     f.foo = g; //~ ERROR cannot assign\n }\n \n fn test7(mut f: Box<Bar>, g: Bar, s: String) {\n-    let _p = &f.foo[s];\n+    let _p = &f.foo[&s];\n     *f = g; //~ ERROR cannot assign\n }\n \n fn test8(mut f: Box<Bar>, g: Foo, s: String) {\n-    let _p = &mut f.foo[s];\n+    let _p = &mut f.foo[&s];\n     f.foo = g; //~ ERROR cannot assign\n }\n \n fn test9(mut f: Box<Bar>, g: Bar, s: String) {\n-    let _p = &mut f.foo[s];\n+    let _p = &mut f.foo[&s];\n     *f = g; //~ ERROR cannot assign\n }\n "}, {"sha": "1b62d9c326d77ad9b845d2ac55b61dc30e300201", "filename": "src/test/compile-fail/borrowck-overloaded-index-move-from-vec.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-move-from-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-move-from-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-move-from-vec.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -19,7 +19,7 @@ struct MyVec<T> {\n impl<T> Index<usize> for MyVec<T> {\n     type Output = T;\n \n-    fn index(&self, &i: &usize) -> &T {\n+    fn index(&self, i: usize) -> &T {\n         &self.data[i]\n     }\n }", "previous_filename": "src/test/compile-fail/borrowck-overloaded-index-2.rs"}, {"sha": "d8615d1905338444f1ff3ab171f15b19b18c3ebe", "filename": "src/test/compile-fail/borrowck-overloaded-index-move-index.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-move-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-move-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-move-index.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::{Index, IndexMut};\n+\n+struct Foo {\n+    x: isize,\n+    y: isize,\n+}\n+\n+impl Index<String> for Foo {\n+    type Output = isize;\n+\n+    fn index(&self, z: String) -> &isize {\n+        if z == \"x\" {\n+            &self.x\n+        } else {\n+            &self.y\n+        }\n+    }\n+}\n+\n+impl IndexMut<String> for Foo {\n+    fn index_mut(&mut self, z: String) -> &mut isize {\n+        if z == \"x\" {\n+            &mut self.x\n+        } else {\n+            &mut self.y\n+        }\n+    }\n+}\n+\n+struct Bar {\n+    x: isize,\n+}\n+\n+impl Index<isize> for Bar {\n+    type Output = isize;\n+\n+    fn index<'a>(&'a self, z: isize) -> &'a isize {\n+        &self.x\n+    }\n+}\n+\n+fn main() {\n+    let mut f = Foo {\n+        x: 1,\n+        y: 2,\n+    };\n+    let mut s = \"hello\".to_string();\n+    let rs = &mut s;\n+\n+    println!(\"{}\", f[s]);\n+    //~^ ERROR cannot move out of `s` because it is borrowed\n+\n+    f[s] = 10;\n+    //~^ ERROR cannot move out of `s` because it is borrowed\n+    //~| ERROR use of moved value: `s`\n+\n+    let s = Bar {\n+        x: 1,\n+    };\n+    let i = 2;\n+    let _j = &i;\n+    println!(\"{}\", s[i]); // no error, i is copy\n+    println!(\"{}\", s[i]);\n+}"}, {"sha": "4c50caf49768dc5cce78fdc4b73303ae41b20c9d", "filename": "src/test/compile-fail/borrowck-overloaded-index-ref-index.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-ref-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-ref-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-index-ref-index.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -15,10 +15,10 @@ struct Foo {\n     y: isize,\n }\n \n-impl Index<String> for Foo {\n+impl<'a> Index<&'a String> for Foo {\n     type Output = isize;\n \n-    fn index<'a>(&'a self, z: &String) -> &'a isize {\n+    fn index(&self, z: &String) -> &isize {\n         if *z == \"x\" {\n             &self.x\n         } else {\n@@ -27,8 +27,8 @@ impl Index<String> for Foo {\n     }\n }\n \n-impl IndexMut<String> for Foo {\n-    fn index_mut<'a>(&'a mut self, z: &String) -> &'a mut isize {\n+impl<'a> IndexMut<&'a String> for Foo {\n+    fn index_mut(&mut self, z: &String) -> &mut isize {\n         if *z == \"x\" {\n             &mut self.x\n         } else {\n@@ -44,7 +44,7 @@ struct Bar {\n impl Index<isize> for Bar {\n     type Output = isize;\n \n-    fn index<'a>(&'a self, z: &isize) -> &'a isize {\n+    fn index<'a>(&'a self, z: isize) -> &'a isize {\n         &self.x\n     }\n }\n@@ -56,9 +56,9 @@ fn main() {\n     };\n     let mut s = \"hello\".to_string();\n     let rs = &mut s;\n-    println!(\"{}\", f[s]);\n+    println!(\"{}\", f[&s]);\n     //~^ ERROR cannot borrow `s` as immutable because it is also borrowed as mutable\n-    f[s] = 10;\n+    f[&s] = 10;\n     //~^ ERROR cannot borrow `s` as immutable because it is also borrowed as mutable\n     let s = Bar {\n         x: 1,", "previous_filename": "src/test/compile-fail/borrowck-overloaded-index.rs"}, {"sha": "021ef7343cbb4432f028f51e030967d23a98db43", "filename": "src/test/compile-fail/dst-index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fcompile-fail%2Fdst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Fcompile-fail%2Fdst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-index.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -20,7 +20,7 @@ struct S;\n impl Index<usize> for S {\n     type Output = str;\n \n-    fn index<'a>(&'a self, _: &usize) -> &'a str {\n+    fn index(&self, _: usize) -> &str {\n         \"hello\"\n     }\n }\n@@ -31,7 +31,7 @@ struct T;\n impl Index<usize> for T {\n     type Output = Debug + 'static;\n \n-    fn index<'a>(&'a self, idx: &usize) -> &'a (Debug + 'static) {\n+    fn index<'a>(&'a self, idx: usize) -> &'a (Debug + 'static) {\n         static x: usize = 42;\n         &x\n     }"}, {"sha": "9539486118b812efd53a8c98368ab85b7528ef9d", "filename": "src/test/run-pass/dst-index.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Fdst-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Fdst-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-index.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -19,7 +19,7 @@ struct S;\n impl Index<uint> for S {\n     type Output = str;\n \n-    fn index<'a>(&'a self, _: &uint) -> &'a str {\n+    fn index<'a>(&'a self, _: uint) -> &'a str {\n         \"hello\"\n     }\n }\n@@ -29,7 +29,7 @@ struct T;\n impl Index<uint> for T {\n     type Output = Debug + 'static;\n \n-    fn index<'a>(&'a self, idx: &uint) -> &'a (Debug + 'static) {\n+    fn index<'a>(&'a self, idx: uint) -> &'a (Debug + 'static) {\n         static X: uint = 42;\n         &X as &(Debug + 'static)\n     }"}, {"sha": "76a5b6488b5a300a69265155008c56d9905b5365", "filename": "src/test/run-pass/issue-15734.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Fissue-15734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Fissue-15734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15734.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -29,15 +29,15 @@ impl<T> Mat<T> {\n impl<T> Index<(uint, uint)> for Mat<T> {\n     type Output = T;\n \n-    fn index<'a>(&'a self, &(row, col): &(uint, uint)) -> &'a T {\n+    fn index<'a>(&'a self, (row, col): (uint, uint)) -> &'a T {\n         &self.data[row * self.cols + col]\n     }\n }\n \n impl<'a, T> Index<(uint, uint)> for &'a Mat<T> {\n     type Output = T;\n \n-    fn index<'b>(&'b self, index: &(uint, uint)) -> &'b T {\n+    fn index<'b>(&'b self, index: (uint, uint)) -> &'b T {\n         (*self).index(index)\n     }\n }\n@@ -47,16 +47,16 @@ struct Row<M> { mat: M, row: uint, }\n impl<T, M: Index<(uint, uint), Output=T>> Index<uint> for Row<M> {\n     type Output = T;\n \n-    fn index<'a>(&'a self, col: &uint) -> &'a T {\n-        &self.mat[(self.row, *col)]\n+    fn index<'a>(&'a self, col: uint) -> &'a T {\n+        &self.mat[(self.row, col)]\n     }\n }\n \n fn main() {\n     let m = Mat::new(vec!(1, 2, 3, 4, 5, 6), 3);\n     let r = m.row(1);\n \n-    assert!(r.index(&2) == &6);\n+    assert!(r.index(2) == &6);\n     assert!(r[2] == 6);\n     assert!(r[2] == 6);\n     assert!(6 == r[2]);"}, {"sha": "b04ae0edbed87b20f791ca3bb893652e94c9e250", "filename": "src/test/run-pass/issue-2804-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804-2.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -16,7 +16,7 @@ extern crate collections;\n use std::collections::HashMap;\n \n fn add_interfaces(managed_ip: String, device: HashMap<String, int>)  {\n-     println!(\"{}, {}\", managed_ip, device[\"interfaces\".to_string()]);\n+     println!(\"{}, {}\", managed_ip, device[\"interfaces\"]);\n }\n \n pub fn main() {}"}, {"sha": "619bd08141fb62259766fb2d856cfbe96ef340d3", "filename": "src/test/run-pass/issue-2804.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Fissue-2804.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2804.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -56,8 +56,7 @@ fn add_interface(_store: int, managed_ip: String, data: json::Json) -> (String,\n \n fn add_interfaces(store: int, managed_ip: String, device: HashMap<String, json::Json>)\n -> Vec<(String, object)> {\n-    match device[\"interfaces\".to_string()]\n-    {\n+    match device[\"interfaces\"] {\n         Json::Array(ref interfaces) =>\n         {\n           interfaces.iter().map(|interface| {\n@@ -67,7 +66,7 @@ fn add_interfaces(store: int, managed_ip: String, device: HashMap<String, json::\n         _ =>\n         {\n             println!(\"Expected list for {} interfaces, found {}\", managed_ip,\n-                   device[\"interfaces\".to_string()]);\n+                     device[\"interfaces\"]);\n             Vec::new()\n         }\n     }"}, {"sha": "7016e28f2ee022800ad3831037e59df33bb6b4df", "filename": "src/test/run-pass/issue-5521.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Fissue-5521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Fissue-5521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5521.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -17,7 +17,7 @@ fn bar(a: foo::map) {\n     if false {\n         panic!();\n     } else {\n-        let _b = &(*a)[2];\n+        let _b = &(*a)[&2];\n     }\n }\n "}, {"sha": "78318e083ba404a09b5de94293eb0b0591bd95d3", "filename": "src/test/run-pass/issue-7660.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Fissue-7660.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Fissue-7660.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7660.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -21,6 +21,6 @@ pub fn main() {\n     let mut m: HashMap<int, A> = HashMap::new();\n     m.insert(1, A(0, 0));\n \n-    let A(ref _a, ref _b) = m[1];\n-    let (a, b) = match m[1] { A(ref _a, ref _b) => (_a, _b) };\n+    let A(ref _a, ref _b) = m[&1];\n+    let (a, b) = match m[&1] { A(ref _a, ref _b) => (_a, _b) };\n }"}, {"sha": "801e71b3038622f504f7c3c738d9eb5798f84c4b", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -52,8 +52,8 @@ impl ops::Not for Point {\n impl ops::Index<bool> for Point {\n     type Output = int;\n \n-    fn index(&self, x: &bool) -> &int {\n-        if *x {\n+    fn index(&self, x: bool) -> &int {\n+        if x {\n             &self.x\n         } else {\n             &self.y"}, {"sha": "b5c9962fe9c3f4d37ef9ff1c9c9483f41904a89d", "filename": "src/test/run-pass/overloaded-index-assoc-list.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -28,7 +28,7 @@ impl<K,V> AssociationList<K,V> {\n     }\n }\n \n-impl<K: PartialEq + std::fmt::Debug, V:Clone> Index<K> for AssociationList<K,V> {\n+impl<'a, K: PartialEq + std::fmt::Debug, V:Clone> Index<&'a K> for AssociationList<K,V> {\n     type Output = V;\n \n     fn index<'a>(&'a self, index: &K) -> &'a V {\n@@ -49,9 +49,9 @@ pub fn main() {\n     list.push(foo.clone(), 22);\n     list.push(bar.clone(), 44);\n \n-    assert!(list[foo] == 22);\n-    assert!(list[bar] == 44);\n+    assert!(list[&foo] == 22);\n+    assert!(list[&bar] == 44);\n \n-    assert!(list[foo] == 22);\n-    assert!(list[bar] == 44);\n+    assert!(list[&foo] == 22);\n+    assert!(list[&bar] == 44);\n }"}, {"sha": "107f0fbc20904b8e4b0fe18d744b5b2040441350", "filename": "src/test/run-pass/overloaded-index-autoderef.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-autoderef.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -23,8 +23,8 @@ struct Foo {\n impl Index<int> for Foo {\n     type Output = int;\n \n-    fn index(&self, z: &int) -> &int {\n-        if *z == 0 {\n+    fn index(&self, z: int) -> &int {\n+        if z == 0 {\n             &self.x\n         } else {\n             &self.y\n@@ -33,8 +33,8 @@ impl Index<int> for Foo {\n }\n \n impl IndexMut<int> for Foo {\n-    fn index_mut(&mut self, z: &int) -> &mut int {\n-        if *z == 0 {\n+    fn index_mut(&mut self, z: int) -> &mut int {\n+        if z == 0 {\n             &mut self.x\n         } else {\n             &mut self.y"}, {"sha": "f01e5541c423b11d2034a77f9bbe557533ffe6e5", "filename": "src/test/run-pass/overloaded-index-in-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-in-field.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -25,8 +25,8 @@ struct Bar {\n impl Index<int> for Foo {\n     type Output = int;\n \n-    fn index(&self, z: &int) -> &int {\n-        if *z == 0 {\n+    fn index(&self, z: int) -> &int {\n+        if z == 0 {\n             &self.x\n         } else {\n             &self.y"}, {"sha": "60e0ed9bfdd0f6298b56c26864542da9cd4ecf26", "filename": "src/test/run-pass/overloaded-index.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Foverloaded-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Foverloaded-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -18,8 +18,8 @@ struct Foo {\n impl Index<int> for Foo {\n     type Output = int;\n \n-    fn index(&self, z: &int) -> &int {\n-        if *z == 0 {\n+    fn index(&self, z: int) -> &int {\n+        if z == 0 {\n             &self.x\n         } else {\n             &self.y\n@@ -28,8 +28,8 @@ impl Index<int> for Foo {\n }\n \n impl IndexMut<int> for Foo {\n-    fn index_mut(&mut self, z: &int) -> &mut int {\n-        if *z == 0 {\n+    fn index_mut(&mut self, z: int) -> &mut int {\n+        if z == 0 {\n             &mut self.x\n         } else {\n             &mut self.y"}, {"sha": "ee9bb80356164504e1dcee563bbc0478316f863c", "filename": "src/test/run-pass/slice.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/753efb5042563dd34a4a524197fa14a129ddf449/src%2Ftest%2Frun-pass%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice.rs?ref=753efb5042563dd34a4a524197fa14a129ddf449", "patch": "@@ -21,53 +21,53 @@ struct Foo;\n \n impl Index<Range<Foo>> for Foo {\n     type Output = Foo;\n-    fn index(&self, index: &Range<Foo>) -> &Foo {\n+    fn index(&self, index: Range<Foo>) -> &Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n impl Index<RangeTo<Foo>> for Foo {\n     type Output = Foo;\n-    fn index(&self, index: &RangeTo<Foo>) -> &Foo {\n+    fn index(&self, index: RangeTo<Foo>) -> &Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n impl Index<RangeFrom<Foo>> for Foo {\n     type Output = Foo;\n-    fn index(&self, index: &RangeFrom<Foo>) -> &Foo {\n+    fn index(&self, index: RangeFrom<Foo>) -> &Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n impl Index<RangeFull> for Foo {\n     type Output = Foo;\n-    fn index(&self, _index: &RangeFull) -> &Foo {\n+    fn index(&self, _index: RangeFull) -> &Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n \n impl IndexMut<Range<Foo>> for Foo {\n-    fn index_mut(&mut self, index: &Range<Foo>) -> &mut Foo {\n+    fn index_mut(&mut self, index: Range<Foo>) -> &mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n impl IndexMut<RangeTo<Foo>> for Foo {\n-    fn index_mut(&mut self, index: &RangeTo<Foo>) -> &mut Foo {\n+    fn index_mut(&mut self, index: RangeTo<Foo>) -> &mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n impl IndexMut<RangeFrom<Foo>> for Foo {\n-    fn index_mut(&mut self, index: &RangeFrom<Foo>) -> &mut Foo {\n+    fn index_mut(&mut self, index: RangeFrom<Foo>) -> &mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }\n }\n impl IndexMut<RangeFull> for Foo {\n-    fn index_mut(&mut self, _index: &RangeFull) -> &mut Foo {\n+    fn index_mut(&mut self, _index: RangeFull) -> &mut Foo {\n         unsafe { COUNT += 1; }\n         self\n     }"}]}