{"sha": "f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzZjI3YTVjNjQ4M2Q5ZTJiYjNjODcyYTNiMDUyOTFhNmUxZDljYjM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-11-21T14:38:17Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-12-18T01:12:31Z"}, "message": "Rewrite VisiblePrivateTypesVisitor", "tree": {"sha": "e8e2f48ec19dc225f2b163f307de90fbecaf9d1d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8e2f48ec19dc225f2b163f307de90fbecaf9d1d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3", "html_url": "https://github.com/rust-lang/rust/commit/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48700be9cbf04d798a6f6ab65c50ab0afe86bc94", "url": "https://api.github.com/repos/rust-lang/rust/commits/48700be9cbf04d798a6f6ab65c50ab0afe86bc94", "html_url": "https://github.com/rust-lang/rust/commit/48700be9cbf04d798a6f6ab65c50ab0afe86bc94"}], "stats": {"total": 580, "additions": 258, "deletions": 322}, "files": [{"sha": "a722c0e38f4c09b5ad53063a0d5a5dbee3b9ef27", "filename": "src/doc/reference.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3", "patch": "@@ -2372,10 +2372,6 @@ The currently implemented features of the reference compiler are:\n                    Such items should not be allowed by the compiler to exist,\n                    so if you need this there probably is a compiler bug.\n \n-* `visible_private_types` - Allows public APIs to expose otherwise private\n-                            types, e.g. as the return type of a public function.\n-                            This capability may be removed in the future.\n-\n * `allow_internal_unstable` - Allows `macro_rules!` macros to be tagged with the\n                               `#[allow_internal_unstable]` attribute, designed\n                               to allow `std` macros to call"}, {"sha": "16183e1115340cb78452906b3e07574cf64e1e31", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 139, "deletions": 314, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3", "patch": "@@ -1101,342 +1101,173 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-struct VisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n+///////////////////////////////////////////////////////////////////////////////\n+/// SearchInterfaceForPrivateItemsVisitor traverses an item's interface and\n+/// finds any private components in it.\n+/// PrivateItemsInPublicInterfacesVisitor ensures there are no private types\n+/// and traits in public interfaces.\n+///////////////////////////////////////////////////////////////////////////////\n+\n+struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    access_levels: &'a AccessLevels,\n-    in_variant: bool,\n+    // Do not report an error when a private type is found\n+    is_quiet: bool,\n+    // Is private component found?\n+    is_public: bool,\n }\n \n-struct CheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    inner: &'a VisiblePrivateTypesVisitor<'b, 'tcx>,\n-    /// whether the type refers to private types.\n-    contains_private: bool,\n-    /// whether we've recurred at all (i.e. if we're pointing at the\n-    /// first type on which visit_ty was called).\n-    at_outer_type: bool,\n-    // whether that first type is a public path.\n-    outer_type_is_public_path: bool,\n-}\n-\n-impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n-    fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n-        let did = match self.tcx.def_map.borrow().get(&path_id).map(|d| d.full_def()) {\n-            // `int` etc. (None doesn't seem to occur.)\n-            None | Some(def::DefPrimTy(..)) | Some(def::DefSelfTy(..)) => return false,\n-            Some(def) => def.def_id(),\n-        };\n-\n-        // A path can only be private if:\n-        // it's in this crate...\n-        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n-            // .. and it corresponds to a private type in the AST (this returns\n-            // None for type parameters)\n-            match self.tcx.map.find(node_id) {\n-                Some(ast_map::NodeItem(ref item)) => item.vis != hir::Public,\n-                Some(_) | None => false,\n-            }\n-        } else {\n-            return false\n+impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n+        if self.is_quiet && !self.is_public {\n+            // We are in quiet mode and a private type is already found, no need to proceed\n+            return\n         }\n-    }\n-\n-    fn trait_is_public(&self, trait_id: ast::NodeId) -> bool {\n-        // FIXME: this would preferably be using `exported_items`, but all\n-        // traits are exported currently (see `EmbargoVisitor.exported_trait`)\n-        self.access_levels.is_public(trait_id)\n-    }\n-\n-    fn check_ty_param_bound(&self,\n-                            ty_param_bound: &hir::TyParamBound) {\n-        if let hir::TraitTyParamBound(ref trait_ref, _) = *ty_param_bound {\n-            if !self.tcx.sess.features.borrow().visible_private_types &&\n-                self.path_is_private_type(trait_ref.trait_ref.ref_id) {\n-                    let span = trait_ref.trait_ref.path.span;\n-                    span_err!(self.tcx.sess, span, E0445,\n-                              \"private trait in exported type parameter bound\");\n+        if let hir::TyPath(..) = ty.node {\n+            let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n+            match def {\n+                def::DefPrimTy(..) | def::DefSelfTy(..) | def::DefTyParam(..) => {\n+                    // Public\n+                }\n+                def::DefStruct(def_id) | def::DefTy(def_id, _) |\n+                def::DefTrait(def_id) | def::DefAssociatedTy(def_id, _) => {\n+                    // Non-local means public, local needs to be checked\n+                    if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+                        if let Some(ast_map::NodeItem(ref item)) = self.tcx.map.find(node_id) {\n+                            if item.vis != hir::Public {\n+                                if !self.is_quiet {\n+                                    span_err!(self.tcx.sess, ty.span, E0446,\n+                                              \"private type in exported type signature\");\n+                                }\n+                                self.is_public = false;\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n             }\n         }\n-    }\n \n-    fn item_is_public(&self, id: &ast::NodeId, vis: hir::Visibility) -> bool {\n-        self.access_levels.is_reachable(*id) || vis == hir::Public\n+        intravisit::walk_ty(self, ty);\n     }\n-}\n \n-impl<'a, 'b, 'tcx, 'v> Visitor<'v> for CheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n-        if let hir::TyPath(..) = ty.node {\n-            if self.inner.path_is_private_type(ty.id) {\n-                self.contains_private = true;\n-                // found what we're looking for so let's stop\n-                // working.\n-                return\n-            } else if self.at_outer_type {\n-                self.outer_type_is_public_path = true;\n+    fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n+        if self.is_quiet && !self.is_public {\n+            // We are in quiet mode and a private type is already found, no need to proceed\n+            return\n+        }\n+        // Non-local means public, local needs to be checked\n+        let def_id = self.tcx.trait_ref_to_def_id(trait_ref);\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+            if let Some(ast_map::NodeItem(ref item)) = self.tcx.map.find(node_id) {\n+                if item.vis != hir::Public {\n+                    if !self.is_quiet {\n+                        span_err!(self.tcx.sess, trait_ref.path.span, E0445,\n+                                  \"private trait in exported type parameter bound\");\n+                    }\n+                    self.is_public = false;\n+                }\n             }\n         }\n-        self.at_outer_type = false;\n-        intravisit::walk_ty(self, ty)\n+\n+        intravisit::walk_trait_ref(self, trait_ref);\n     }\n \n-    // don't want to recurse into [, .. expr]\n+    // Don't recurse into function bodies\n+    fn visit_block(&mut self, _: &hir::Block) {}\n+    // Don't recurse into expressions in array sizes or const initializers\n     fn visit_expr(&mut self, _: &hir::Expr) {}\n+    // Don't recurse into patterns in function arguments\n+    fn visit_pat(&mut self, _: &hir::Pat) {}\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n-    /// We want to visit items in the context of their containing\n-    /// module and so forth, so supply a crate for doing a deep walk.\n-    fn visit_nested_item(&mut self, item: hir::ItemId) {\n-        self.visit_item(self.tcx.map.expect_item(item.id))\n+struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+}\n+\n+impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n+    // A type is considered public if it doesn't contain any private components\n+    fn is_public_ty(&self, ty: &hir::Ty) -> bool {\n+        let mut check = SearchInterfaceForPrivateItemsVisitor {\n+            tcx: self.tcx, is_quiet: true, is_public: true\n+        };\n+        check.visit_ty(ty);\n+        check.is_public\n     }\n \n+    // A trait is considered public if it doesn't contain any private components\n+    fn is_public_trait(&self, trait_ref: &hir::TraitRef) -> bool {\n+        let mut check = SearchInterfaceForPrivateItemsVisitor {\n+            tcx: self.tcx, is_quiet: true, is_public: true\n+        };\n+        check.visit_trait_ref(trait_ref);\n+        check.is_public\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n+        let mut check = SearchInterfaceForPrivateItemsVisitor {\n+            tcx: self.tcx, is_quiet: false, is_public: true\n+        };\n         match item.node {\n-            // contents of a private mod can be reexported, so we need\n-            // to check internals.\n-            hir::ItemMod(_) => {}\n-\n-            // An `extern {}` doesn't introduce a new privacy\n-            // namespace (the contents have their own privacies).\n-            hir::ItemForeignMod(_) => {}\n-\n-            hir::ItemTrait(_, _, ref bounds, _) => {\n-                if !self.trait_is_public(item.id) {\n-                    return\n-                }\n-\n-                for bound in bounds.iter() {\n-                    self.check_ty_param_bound(bound)\n+            // Crates are always public\n+            hir::ItemExternCrate(..) => {}\n+            // All nested items are checked by visit_item\n+            hir::ItemMod(..) => {}\n+            // Checked in resolve\n+            hir::ItemUse(..) => {}\n+            // Subitems of these items have inherited publicity\n+            hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n+            hir::ItemEnum(..) | hir::ItemTrait(..) | hir::ItemTy(..) => {\n+                if item.vis == hir::Public {\n+                    check.visit_item(item);\n                 }\n             }\n-\n-            // impls need some special handling to try to offer useful\n-            // error messages without (too many) false positives\n-            // (i.e. we could just return here to not check them at\n-            // all, or some worse estimation of whether an impl is\n-            // publicly visible).\n-            hir::ItemImpl(_, _, ref g, ref trait_ref, ref self_, ref impl_items) => {\n-                // `impl [... for] Private` is never visible.\n-                let self_contains_private;\n-                // impl [... for] Public<...>, but not `impl [... for]\n-                // Vec<Public>` or `(Public,)` etc.\n-                let self_is_public_path;\n-\n-                // check the properties of the Self type:\n-                {\n-                    let mut visitor = CheckTypeForPrivatenessVisitor {\n-                        inner: self,\n-                        contains_private: false,\n-                        at_outer_type: true,\n-                        outer_type_is_public_path: false,\n-                    };\n-                    visitor.visit_ty(&**self_);\n-                    self_contains_private = visitor.contains_private;\n-                    self_is_public_path = visitor.outer_type_is_public_path;\n+            // Subitems of foreign modules have their own publicity\n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    if foreign_item.vis == hir::Public {\n+                        check.visit_foreign_item(foreign_item);\n+                    }\n                 }\n-\n-                // miscellaneous info about the impl\n-\n-                // `true` iff this is `impl Private for ...`.\n-                let not_private_trait =\n-                    trait_ref.as_ref().map_or(true, // no trait counts as public trait\n-                                              |tr| {\n-                        let did = self.tcx.trait_ref_to_def_id(tr);\n-\n-                        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n-                            self.trait_is_public(node_id)\n-                        } else {\n-                            true // external traits must be public\n-                        }\n-                    });\n-\n-                // `true` iff this is a trait impl or at least one method is public.\n-                //\n-                // `impl Public { $( fn ...() {} )* }` is not visible.\n-                //\n-                // This is required over just using the methods' privacy\n-                // directly because we might have `impl<T: Foo<Private>> ...`,\n-                // and we shouldn't warn about the generics if all the methods\n-                // are private (because `T` won't be visible externally).\n-                let trait_or_some_public_method =\n-                    trait_ref.is_some() ||\n-                    impl_items.iter()\n-                              .any(|impl_item| {\n-                                  match impl_item.node {\n-                                      hir::ImplItemKind::Const(..) |\n-                                      hir::ImplItemKind::Method(..) => {\n-                                          self.access_levels.is_reachable(impl_item.id)\n-                                      }\n-                                      hir::ImplItemKind::Type(_) => false,\n-                                  }\n-                              });\n-\n-                if !self_contains_private &&\n-                        not_private_trait &&\n-                        trait_or_some_public_method {\n-\n-                    intravisit::walk_generics(self, g);\n-\n-                    match *trait_ref {\n-                        None => {\n-                            for impl_item in impl_items {\n-                                // This is where we choose whether to walk down\n-                                // further into the impl to check its items. We\n-                                // should only walk into public items so that we\n-                                // don't erroneously report errors for private\n-                                // types in private items.\n-                                match impl_item.node {\n-                                    hir::ImplItemKind::Const(..) |\n-                                    hir::ImplItemKind::Method(..)\n-                                        if self.item_is_public(&impl_item.id, impl_item.vis) =>\n-                                    {\n-                                        intravisit::walk_impl_item(self, impl_item)\n-                                    }\n-                                    hir::ImplItemKind::Type(..) => {\n-                                        intravisit::walk_impl_item(self, impl_item)\n-                                    }\n-                                    _ => {}\n-                                }\n-                            }\n-                        }\n-                        Some(ref tr) => {\n-                            // Any private types in a trait impl fall into three\n-                            // categories.\n-                            // 1. mentioned in the trait definition\n-                            // 2. mentioned in the type params/generics\n-                            // 3. mentioned in the associated types of the impl\n-                            //\n-                            // Those in 1. can only occur if the trait is in\n-                            // this crate and will've been warned about on the\n-                            // trait definition (there's no need to warn twice\n-                            // so we don't check the methods).\n-                            //\n-                            // Those in 2. are warned via walk_generics and this\n-                            // call here.\n-                            intravisit::walk_path(self, &tr.path);\n-\n-                            // Those in 3. are warned with this call.\n-                            for impl_item in impl_items {\n-                                if let hir::ImplItemKind::Type(ref ty) = impl_item.node {\n-                                    self.visit_ty(ty);\n-                                }\n-                            }\n+            }\n+            // Subitems of structs have their own publicity\n+            hir::ItemStruct(ref struct_def, ref generics) => {\n+                if item.vis == hir::Public {\n+                    check.visit_generics(generics);\n+                    for field in struct_def.fields() {\n+                        if field.node.kind.visibility() == hir::Public {\n+                            check.visit_struct_field(field);\n                         }\n                     }\n-                } else if trait_ref.is_none() && self_is_public_path {\n-                    // impl Public<Private> { ... }. Any public static\n-                    // methods will be visible as `Public::foo`.\n-                    let mut found_pub_static = false;\n+                }\n+            }\n+            // The interface is empty\n+            hir::ItemDefaultImpl(..) => {}\n+            // An inherent impl is public when its type is public\n+            // Subitems of inherent impls have their own publicity\n+            hir::ItemImpl(_, _, ref generics, None, ref ty, ref impl_items) => {\n+                if self.is_public_ty(ty) {\n+                    check.visit_generics(generics);\n                     for impl_item in impl_items {\n-                        match impl_item.node {\n-                            hir::ImplItemKind::Const(..) => {\n-                                if self.item_is_public(&impl_item.id, impl_item.vis) {\n-                                    found_pub_static = true;\n-                                    intravisit::walk_impl_item(self, impl_item);\n-                                }\n-                            }\n-                            hir::ImplItemKind::Method(ref sig, _) => {\n-                                if sig.explicit_self.node == hir::SelfStatic &&\n-                                      self.item_is_public(&impl_item.id, impl_item.vis) {\n-                                    found_pub_static = true;\n-                                    intravisit::walk_impl_item(self, impl_item);\n-                                }\n-                            }\n-                            _ => {}\n+                        if impl_item.vis == hir::Public {\n+                            check.visit_impl_item(impl_item);\n                         }\n                     }\n-                    if found_pub_static {\n-                        intravisit::walk_generics(self, g)\n-                    }\n                 }\n-                return\n-            }\n-\n-            // `type ... = ...;` can contain private types, because\n-            // we're introducing a new name.\n-            hir::ItemTy(..) => return,\n-\n-            // not at all public, so we don't care\n-            _ if !self.item_is_public(&item.id, item.vis) => {\n-                return;\n-            }\n-\n-            _ => {}\n-        }\n-\n-        // We've carefully constructed it so that if we're here, then\n-        // any `visit_ty`'s will be called on things that are in\n-        // public signatures, i.e. things that we're interested in for\n-        // this visitor.\n-        debug!(\"VisiblePrivateTypesVisitor entering item {:?}\", item);\n-        intravisit::walk_item(self, item);\n-    }\n-\n-    fn visit_generics(&mut self, generics: &hir::Generics) {\n-        for ty_param in generics.ty_params.iter() {\n-            for bound in ty_param.bounds.iter() {\n-                self.check_ty_param_bound(bound)\n             }\n-        }\n-        for predicate in &generics.where_clause.predicates {\n-            match predicate {\n-                &hir::WherePredicate::BoundPredicate(ref bound_pred) => {\n-                    for bound in bound_pred.bounds.iter() {\n-                        self.check_ty_param_bound(bound)\n+            // A trait impl is public when both its type and its trait are public\n+            // Subitems of trait impls have inherited publicity\n+            hir::ItemImpl(_, _, ref generics, Some(ref trait_ref), ref ty, ref impl_items) => {\n+                if self.is_public_ty(ty) && self.is_public_trait(trait_ref) {\n+                    check.visit_generics(generics);\n+                    for impl_item in impl_items {\n+                        check.visit_impl_item(impl_item);\n                     }\n                 }\n-                &hir::WherePredicate::RegionPredicate(_) => {}\n-                &hir::WherePredicate::EqPredicate(ref eq_pred) => {\n-                    self.visit_ty(&*eq_pred.ty);\n-                }\n             }\n         }\n     }\n-\n-    fn visit_foreign_item(&mut self, item: &hir::ForeignItem) {\n-        if self.access_levels.is_reachable(item.id) {\n-            intravisit::walk_foreign_item(self, item)\n-        }\n-    }\n-\n-    fn visit_ty(&mut self, t: &hir::Ty) {\n-        debug!(\"VisiblePrivateTypesVisitor checking ty {:?}\", t);\n-        if let hir::TyPath(_, ref p) = t.node {\n-            if !self.tcx.sess.features.borrow().visible_private_types &&\n-                self.path_is_private_type(t.id) {\n-                span_err!(self.tcx.sess, p.span, E0446,\n-                          \"private type in exported type signature\");\n-            }\n-        }\n-        intravisit::walk_ty(self, t)\n-    }\n-\n-    fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics, item_id: ast::NodeId) {\n-        if self.access_levels.is_reachable(v.node.data.id()) {\n-            self.in_variant = true;\n-            intravisit::walk_variant(self, v, g, item_id);\n-            self.in_variant = false;\n-        }\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &hir::StructField) {\n-        let vis = match s.node.kind {\n-            hir::NamedField(_, vis) | hir::UnnamedField(vis) => vis\n-        };\n-        if vis == hir::Public || self.in_variant {\n-            intravisit::walk_struct_field(self, s);\n-        }\n-    }\n-\n-    // we don't need to introspect into these at all: an\n-    // expression/block context can't possibly contain exported things.\n-    // (Making them no-ops stops us from traversing the whole AST without\n-    // having to be super careful about our `walk_...` calls above.)\n-    // FIXME(#29524): Unfortunately this ^^^ is not true, blocks can contain\n-    // exported items (e.g. impls) and actual code in rustc itself breaks\n-    // if we don't traverse blocks in `EmbargoVisitor`\n-    fn visit_block(&mut self, _: &hir::Block) {}\n-    fn visit_expr(&mut self, _: &hir::Expr) {}\n }\n \n pub fn check_crate(tcx: &ty::ctxt,\n@@ -1473,6 +1304,12 @@ pub fn check_crate(tcx: &ty::ctxt,\n \n     tcx.sess.abort_if_errors();\n \n+    // Check for private types and traits in public interfaces\n+    let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n+        tcx: tcx,\n+    };\n+    krate.visit_all_items(&mut visitor);\n+\n     // Build up a set of all exported items in the AST. This is a set of all\n     // items which are reachable from external crates based on visibility.\n     let mut visitor = EmbargoVisitor {\n@@ -1491,19 +1328,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n         }\n     }\n     visitor.update(ast::CRATE_NODE_ID, Some(AccessLevel::Public));\n-\n-    let EmbargoVisitor { access_levels, .. } = visitor;\n-\n-    {\n-        let mut visitor = VisiblePrivateTypesVisitor {\n-            tcx: tcx,\n-            access_levels: &access_levels,\n-            in_variant: false,\n-        };\n-        intravisit::walk_crate(&mut visitor, krate);\n-    }\n-\n-    access_levels\n+    visitor.access_levels\n }\n \n __build_diagnostic_array! { librustc_privacy, DIAGNOSTICS }"}, {"sha": "ee76bba36029bcc374b615b6b7c7eb3a39809397", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3", "patch": "@@ -82,7 +82,7 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n     (\"advanced_slice_patterns\", \"1.0.0\", Some(23121), Active),\n     (\"tuple_indexing\", \"1.0.0\", None, Accepted),\n     (\"associated_types\", \"1.0.0\", None, Accepted),\n-    (\"visible_private_types\", \"1.0.0\", Some(29627), Active),\n+    (\"visible_private_types\", \"1.0.0\", None, Removed),\n     (\"slicing_syntax\", \"1.0.0\", None, Accepted),\n     (\"box_syntax\", \"1.0.0\", Some(27779), Active),\n     (\"placement_in_syntax\", \"1.0.0\", Some(27779), Active),\n@@ -514,7 +514,6 @@ pub enum AttributeGate {\n pub struct Features {\n     pub unboxed_closures: bool,\n     pub rustc_diagnostic_macros: bool,\n-    pub visible_private_types: bool,\n     pub allow_quote: bool,\n     pub allow_asm: bool,\n     pub allow_log_syntax: bool,\n@@ -551,7 +550,6 @@ impl Features {\n         Features {\n             unboxed_closures: false,\n             rustc_diagnostic_macros: false,\n-            visible_private_types: false,\n             allow_quote: false,\n             allow_asm: false,\n             allow_log_syntax: false,\n@@ -1130,7 +1128,6 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler,\n     Features {\n         unboxed_closures: cx.has_feature(\"unboxed_closures\"),\n         rustc_diagnostic_macros: cx.has_feature(\"rustc_diagnostic_macros\"),\n-        visible_private_types: cx.has_feature(\"visible_private_types\"),\n         allow_quote: cx.has_feature(\"quote\"),\n         allow_asm: cx.has_feature(\"asm\"),\n         allow_log_syntax: cx.has_feature(\"log_syntax\"),"}, {"sha": "971bc0f7f26f67cc3334dd053851606a0087c1ef", "filename": "src/test/compile-fail/issue-28325.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3/src%2Ftest%2Fcompile-fail%2Fissue-28325.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3/src%2Ftest%2Fcompile-fail%2Fissue-28325.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28325.rs?ref=f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks for private types in public interfaces\n+\n+mod y {\n+    pub struct Foo { x: u32 }\n+\n+    struct Bar { x: u32 }\n+\n+    impl Foo {\n+        pub fn foo(&self, x: Self, y: Bar) { } //~ ERROR private type in exported type signature\n+    }\n+}\n+\n+mod x {\n+    pub struct Foo { pub x: u32 }\n+\n+    struct Bar { _x: u32 }\n+\n+    impl Foo {\n+        pub fn foo(&self, _x: Self, _y: Bar) { } //~ ERROR private type in exported type signature\n+        pub fn bar(&self) -> Bar { Bar { _x: self.x } }\n+        //~^ ERROR private type in exported type signature\n+    }\n+}\n+\n+pub fn main() {\n+    let f = x::Foo { x: 4 };\n+    let b = f.bar();\n+    f.foo(x::Foo { x: 5 }, b);\n+}"}, {"sha": "ab7baf0b5964f632c1ed1882e97e543982d0cb12", "filename": "src/test/compile-fail/issue-28450.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3/src%2Ftest%2Fcompile-fail%2Fissue-28450.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3/src%2Ftest%2Fcompile-fail%2Fissue-28450.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28450.rs?ref=f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checks for private types in public interfaces\n+\n+struct Priv;\n+\n+pub use self::private::public;\n+\n+mod private {\n+    pub type Priv = super::Priv; //~ ERROR private type in exported type signature\n+\n+    pub fn public(_x: Priv) {\n+    }\n+}\n+\n+struct __CFArray;\n+pub type CFArrayRef = *const __CFArray; //~ ERROR private type in exported type signature\n+trait Pointer { type Pointee; }\n+impl<T> Pointer for *const T { type Pointee = T; }\n+pub type __CFArrayRevealed = <CFArrayRef as Pointer>::Pointee;\n+//~^ ERROR private type in exported type signature\n+\n+type Foo = u8;\n+pub fn foo(f: Foo) {} //~ ERROR private type in exported type signature\n+\n+pub trait Exporter {\n+    type Output;\n+}\n+pub struct Helper;\n+\n+pub fn block() -> <Helper as Exporter>::Output {\n+    struct Inner;\n+    impl Inner {\n+        fn poke(&self) { println!(\"Hello!\"); }\n+    }\n+\n+    impl Exporter for Helper {\n+        type Output = Inner; //~ ERROR private type in exported type signature\n+    }\n+\n+    Inner\n+}\n+\n+fn main() {\n+    block().poke();\n+}"}, {"sha": "be785de44d1943881f65984fcc5dc64952a9bda3", "filename": "src/test/run-pass/issue-29668.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3/src%2Ftest%2Frun-pass%2Fissue-29668.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3/src%2Ftest%2Frun-pass%2Fissue-29668.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29668.rs?ref=f3f27a5c6483d9e2bb3c872a3b05291a6e1d9cb3", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Functions can return unnameable types\n+\n+mod m1 {\n+    mod m2 {\n+        #[derive(Debug)]\n+        pub struct A;\n+    }\n+    use self::m2::A;\n+    pub fn x() -> A { A }\n+}\n+\n+fn main() {\n+    let x = m1::x();\n+    println!(\"{:?}\", x);\n+}"}]}