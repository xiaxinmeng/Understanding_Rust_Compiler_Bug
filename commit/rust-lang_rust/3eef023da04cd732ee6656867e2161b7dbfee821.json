{"sha": "3eef023da04cd732ee6656867e2161b7dbfee821", "node_id": "C_kwDOAAsO6NoAKDNlZWYwMjNkYTA0Y2Q3MzJlZTY2NTY4NjdlMjE2MWI3ZGJmZWU4MjE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-21T16:12:57Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-07-21T16:43:10Z"}, "message": "Address more nits", "tree": {"sha": "a124690e976bfde5f20ad88aadfff696d71a2ec6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a124690e976bfde5f20ad88aadfff696d71a2ec6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3eef023da04cd732ee6656867e2161b7dbfee821", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3eef023da04cd732ee6656867e2161b7dbfee821", "html_url": "https://github.com/rust-lang/rust/commit/3eef023da04cd732ee6656867e2161b7dbfee821", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3eef023da04cd732ee6656867e2161b7dbfee821/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd89978d869587fc025286b0326116819d5b78e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd89978d869587fc025286b0326116819d5b78e4", "html_url": "https://github.com/rust-lang/rust/commit/cd89978d869587fc025286b0326116819d5b78e4"}], "stats": {"total": 74, "additions": 34, "deletions": 40}, "files": [{"sha": "18ffc227fed869e71de9fb50df4482263b38ffa4", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3eef023da04cd732ee6656867e2161b7dbfee821/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eef023da04cd732ee6656867e2161b7dbfee821/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=3eef023da04cd732ee6656867e2161b7dbfee821", "patch": "@@ -955,7 +955,7 @@ pub struct Block<'hir> {\n }\n \n impl<'hir> Block<'hir> {\n-    pub fn peel_blocks(&self) -> &Block<'hir> {\n+    pub fn innermost_block(&self) -> &Block<'hir> {\n         let mut block = self;\n         while let Some(Expr { kind: ExprKind::Block(inner_block, _), .. }) = block.expr {\n             block = inner_block;"}, {"sha": "4e87ec86658f81503f29af7340dae6dbee9b6705", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 31, "deletions": 37, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3eef023da04cd732ee6656867e2161b7dbfee821/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eef023da04cd732ee6656867e2161b7dbfee821/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=3eef023da04cd732ee6656867e2161b7dbfee821", "patch": "@@ -758,22 +758,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         second_ty: Ty<'tcx>,\n         second_span: Span,\n     ) {\n-        let semicolon =\n-            if let Some(first_id) = first_id\n-                && let hir::Node::Block(blk) = self.tcx.hir().get(first_id)\n-                && let Some(remove_semicolon) = self.could_remove_semicolon(blk, second_ty)\n-            {\n-                Some(remove_semicolon)\n-            } else if let Some(second_id) = second_id\n-                && let hir::Node::Block(blk) = self.tcx.hir().get(second_id)\n-                && let Some(remove_semicolon) = self.could_remove_semicolon(blk, first_ty)\n-            {\n-                Some(remove_semicolon)\n-            } else {\n-                None\n-            };\n-        if let Some((sp, boxed)) = semicolon {\n-            if matches!(boxed, StatementAsExpression::NeedsBoxing) {\n+        let remove_semicolon =\n+            [(first_id, second_ty), (second_id, first_ty)].into_iter().find_map(|(id, ty)| {\n+                let hir::Node::Block(blk) = self.tcx.hir().get(id?) else { return None };\n+                self.could_remove_semicolon(blk, ty)\n+            });\n+        match remove_semicolon {\n+            Some((sp, StatementAsExpression::NeedsBoxing)) => {\n                 err.multipart_suggestion(\n                     \"consider removing this semicolon and boxing the expressions\",\n                     vec![\n@@ -785,28 +776,24 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     ],\n                     Applicability::MachineApplicable,\n                 );\n-            } else {\n+            }\n+            Some((sp, StatementAsExpression::CorrectType)) => {\n                 err.span_suggestion_short(\n                     sp,\n                     \"consider removing this semicolon\",\n                     \"\",\n                     Applicability::MachineApplicable,\n                 );\n             }\n-        } else {\n-            let suggested =\n-                if let Some(first_id) = first_id\n-                    && let hir::Node::Block(blk) = self.tcx.hir().get(first_id)\n-                {\n-                    self.consider_returning_binding(blk, second_ty, err)\n-                } else {\n-                    false\n-                };\n-            if !suggested\n-                && let Some(second_id) = second_id\n-                && let hir::Node::Block(blk) = self.tcx.hir().get(second_id)\n-            {\n-                self.consider_returning_binding(blk, first_ty, err);\n+            None => {\n+                for (id, ty) in [(first_id, second_ty), (second_id, first_ty)] {\n+                    if let Some(id) = id\n+                        && let hir::Node::Block(blk) = self.tcx.hir().get(id)\n+                        && self.consider_returning_binding(blk, ty, err)\n+                    {\n+                        break;\n+                    }\n+                }\n             }\n         }\n     }\n@@ -2884,8 +2871,10 @@ impl TyCategory {\n }\n \n impl<'tcx> InferCtxt<'_, 'tcx> {\n+    /// Given a [`hir::Block`], get the span of its last expression or\n+    /// statement, peeling off any inner blocks.\n     pub fn find_block_span(&self, block: &'tcx hir::Block<'tcx>) -> Span {\n-        let block = block.peel_blocks();\n+        let block = block.innermost_block();\n         if let Some(expr) = &block.expr {\n             expr.span\n         } else if let Some(stmt) = block.stmts.last() {\n@@ -2897,27 +2886,30 @@ impl<'tcx> InferCtxt<'_, 'tcx> {\n         }\n     }\n \n+    /// Given a [`hir::HirId`] for a block, get the span of its last expression\n+    /// or statement, peeling off any inner blocks.\n     pub fn find_block_span_from_hir_id(&self, hir_id: hir::HirId) -> Span {\n         match self.tcx.hir().get(hir_id) {\n             hir::Node::Block(blk) => self.find_block_span(blk),\n-            // The parser was in a weird state if either of these happen...\n+            // The parser was in a weird state if either of these happen, but\n+            // it's better not to panic.\n             hir::Node::Expr(e) => e.span,\n             _ => rustc_span::DUMMY_SP,\n         }\n     }\n \n+    /// Be helpful when the user wrote `{... expr; }` and taking the `;` off\n+    /// is enough to fix the error.\n     pub fn could_remove_semicolon(\n         &self,\n         blk: &'tcx hir::Block<'tcx>,\n         expected_ty: Ty<'tcx>,\n     ) -> Option<(Span, StatementAsExpression)> {\n-        let blk = blk.peel_blocks();\n+        let blk = blk.innermost_block();\n         // Do not suggest if we have a tail expr.\n         if blk.expr.is_some() {\n             return None;\n         }\n-        // Be helpful when the user wrote `{... expr;}` and\n-        // taking the `;` off is enough to fix the error.\n         let last_stmt = blk.stmts.last()?;\n         let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n             return None;\n@@ -2987,13 +2979,15 @@ impl<'tcx> InferCtxt<'_, 'tcx> {\n         Some((span, needs_box))\n     }\n \n+    /// Suggest returning a local binding with a compatible type if the block\n+    /// has no return expression.\n     pub fn consider_returning_binding(\n         &self,\n         blk: &'tcx hir::Block<'tcx>,\n         expected_ty: Ty<'tcx>,\n         err: &mut Diagnostic,\n     ) -> bool {\n-        let blk = blk.peel_blocks();\n+        let blk = blk.innermost_block();\n         // Do not suggest if we have a tail expr.\n         if blk.expr.is_some() {\n             return false;"}, {"sha": "f629f6a0099d7a86d19cbd2f1c604b7b325c1024", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3eef023da04cd732ee6656867e2161b7dbfee821/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eef023da04cd732ee6656867e2161b7dbfee821/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=3eef023da04cd732ee6656867e2161b7dbfee821", "patch": "@@ -325,7 +325,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let (error_sp, else_id) = if let ExprKind::Block(block, _) = &else_expr.kind {\n-            let block = block.peel_blocks();\n+            let block = block.innermost_block();\n \n             // Avoid overlapping spans that aren't as readable:\n             // ```\n@@ -366,7 +366,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let then_id = if let ExprKind::Block(block, _) = &then_expr.kind {\n-            let block = block.peel_blocks();\n+            let block = block.innermost_block();\n             // Exclude overlapping spans\n             if block.expr.is_none() && block.stmts.is_empty() {\n                 outer_span = None;"}]}