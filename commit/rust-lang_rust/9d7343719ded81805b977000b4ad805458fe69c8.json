{"sha": "9d7343719ded81805b977000b4ad805458fe69c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNzM0MzcxOWRlZDgxODA1Yjk3NzAwMGI0YWQ4MDU0NThmZTY5Yzg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-02T15:14:06Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-02T15:14:06Z"}, "message": "Merge #9110\n\n9110: internal: simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "e8572154d505e9eddde4e454ac03dfb06589b464", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8572154d505e9eddde4e454ac03dfb06589b464"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d7343719ded81805b977000b4ad805458fe69c8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgt6A+CRBK7hj4Ov3rIwAAOqoIAHh/WLQ+5+qEwRaeUXq62wOH\njz8DyaOdwRAhguMB8BkWb9pii0W990J36q/B96csAjedg6+Kp8uOwpEjRfahiRZe\n9dP0crBJ+GB36bHmtqFmbYxuTpdoZWLvxJFZq4Rp/DCdr8a4M04ZfmvjNeEXqrM7\nK1GJRyoorHR7L/4g6x3gWk1d0XIamnhh/7YQeBYVJ9Vn6q9wHzCy3YfupdS6sMiy\ned9ZUuoaUCx0jy4lyE4hv6nQTDdjt9BrlS9miIZFS59nQ2s+pKIPhMy67oF8hoRC\nzotfKYb8gMQU7mADpD8wBShFrgh5Ug65/XaB2KN0cRrPi5qey82kUbA3P+NAVyQ=\n=BExn\n-----END PGP SIGNATURE-----\n", "payload": "tree e8572154d505e9eddde4e454ac03dfb06589b464\nparent dbdfeeeff91b5e42d8687df09dda1d29f99b34f8\nparent 76fd1b316f38b59991316d5b97582c0203728738\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1622646846 +0000\ncommitter GitHub <noreply@github.com> 1622646846 +0000\n\nMerge #9110\n\n9110: internal: simplify r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d7343719ded81805b977000b4ad805458fe69c8", "html_url": "https://github.com/rust-lang/rust/commit/9d7343719ded81805b977000b4ad805458fe69c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d7343719ded81805b977000b4ad805458fe69c8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbdfeeeff91b5e42d8687df09dda1d29f99b34f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbdfeeeff91b5e42d8687df09dda1d29f99b34f8", "html_url": "https://github.com/rust-lang/rust/commit/dbdfeeeff91b5e42d8687df09dda1d29f99b34f8"}, {"sha": "76fd1b316f38b59991316d5b97582c0203728738", "url": "https://api.github.com/repos/rust-lang/rust/commits/76fd1b316f38b59991316d5b97582c0203728738", "html_url": "https://github.com/rust-lang/rust/commit/76fd1b316f38b59991316d5b97582c0203728738"}], "stats": {"total": 152, "additions": 86, "deletions": 66}, "files": [{"sha": "e0a7021fd3e483e98b07be4bb0e8336821f98da2", "filename": "crates/ide_completion/src/completions/dot.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=9d7343719ded81805b977000b4ad805458fe69c8", "patch": "@@ -8,7 +8,7 @@ use crate::{context::CompletionContext, Completions};\n \n /// Complete dot accesses, i.e. fields or methods.\n pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n-    let dot_receiver = match &ctx.dot_receiver {\n+    let dot_receiver = match ctx.dot_receiver() {\n         Some(expr) => expr,\n         _ => return complete_undotted_self(acc, ctx),\n     };\n@@ -30,7 +30,10 @@ pub(crate) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n }\n \n fn complete_undotted_self(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_trivial_path || !ctx.config.enable_self_on_the_fly {\n+    if !ctx.config.enable_self_on_the_fly {\n+        return;\n+    }\n+    if !ctx.is_trivial_path || ctx.is_path_disallowed() {\n         return;\n     }\n     ctx.scope.process_all_names(&mut |name, def| {"}, {"sha": "d72bf13d31a37c303131f3dcf0a7aa2c74be8445", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=9d7343719ded81805b977000b4ad805458fe69c8", "patch": "@@ -162,19 +162,19 @@ pub(crate) fn position_for_import<'a>(\n     Some(match import_candidate {\n         Some(ImportCandidate::Path(_)) => ctx.name_ref_syntax.as_ref()?.syntax(),\n         Some(ImportCandidate::TraitAssocItem(_)) => ctx.path_qual.as_ref()?.syntax(),\n-        Some(ImportCandidate::TraitMethod(_)) => ctx.dot_receiver.as_ref()?.syntax(),\n+        Some(ImportCandidate::TraitMethod(_)) => ctx.dot_receiver()?.syntax(),\n         None => ctx\n             .name_ref_syntax\n             .as_ref()\n             .map(|name_ref| name_ref.syntax())\n             .or_else(|| ctx.path_qual.as_ref().map(|path| path.syntax()))\n-            .or_else(|| ctx.dot_receiver.as_ref().map(|expr| expr.syntax()))?,\n+            .or_else(|| ctx.dot_receiver().map(|expr| expr.syntax()))?,\n     })\n }\n \n fn import_assets(ctx: &CompletionContext, fuzzy_name: String) -> Option<ImportAssets> {\n     let current_module = ctx.scope.module()?;\n-    if let Some(dot_receiver) = &ctx.dot_receiver {\n+    if let Some(dot_receiver) = ctx.dot_receiver() {\n         ImportAssets::for_fuzzy_method_call(\n             current_module,\n             ctx.sema.type_of_expr(dot_receiver)?,"}, {"sha": "1a7a484a4cdd5935a3a41366e5885aef134a3825", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=9d7343719ded81805b977000b4ad805458fe69c8", "patch": "@@ -31,7 +31,7 @@ pub(crate) fn complete_use_tree_keyword(acc: &mut Completions, ctx: &CompletionC\n     }\n \n     // Suggest .await syntax for types that implement Future trait\n-    if let Some(receiver) = &ctx.dot_receiver {\n+    if let Some(receiver) = ctx.dot_receiver() {\n         if let Some(ty) = ctx.sema.type_of_expr(receiver) {\n             if ty.impls_future(ctx.db) {\n                 let mut item = kw_completion(\"await\");"}, {"sha": "781b96ff185a17aa35714a02bcdab8b32d0ab0d5", "filename": "crates/ide_completion/src/completions/macro_in_item_position.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmacro_in_item_position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmacro_in_item_position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmacro_in_item_position.rs?ref=9d7343719ded81805b977000b4ad805458fe69c8", "patch": "@@ -5,7 +5,7 @@ use crate::{CompletionContext, Completions};\n // Ideally this should be removed and moved into `(un)qualified_path` respectively\n pub(crate) fn complete_macro_in_item_position(acc: &mut Completions, ctx: &CompletionContext) {\n     // Show only macros in top level.\n-    if !ctx.is_new_item {\n+    if !ctx.expects_item() {\n         return;\n     }\n "}, {"sha": "86bbb58e266399909bf697a7c0b69482c2e6241d", "filename": "crates/ide_completion/src/completions/postfix.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=9d7343719ded81805b977000b4ad805458fe69c8", "patch": "@@ -14,6 +14,7 @@ use crate::{\n     completions::postfix::format_like::add_format_like_completions,\n     context::CompletionContext,\n     item::{Builder, CompletionKind},\n+    patterns::ImmediateLocation,\n     CompletionItem, CompletionItemKind, Completions,\n };\n \n@@ -22,13 +23,16 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n         return;\n     }\n \n-    let dot_receiver = match &ctx.dot_receiver {\n-        Some(it) => it,\n-        None => return,\n+    let (dot_receiver, receiver_is_ambiguous_float_literal) = match &ctx.completion_location {\n+        Some(ImmediateLocation::MethodCall { receiver: Some(it) }) => (it, false),\n+        Some(ImmediateLocation::FieldAccess {\n+            receiver: Some(it),\n+            receiver_is_ambiguous_float_literal,\n+        }) => (it, *receiver_is_ambiguous_float_literal),\n+        _ => return,\n     };\n \n-    let receiver_text =\n-        get_receiver_text(dot_receiver, ctx.dot_receiver_is_ambiguous_float_literal);\n+    let receiver_text = get_receiver_text(dot_receiver, receiver_is_ambiguous_float_literal);\n \n     let receiver_ty = match ctx.sema.type_of_expr(&dot_receiver) {\n         Some(it) => it,\n@@ -123,8 +127,7 @@ pub(crate) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n     // The rest of the postfix completions create an expression that moves an argument,\n     // so it's better to consider references now to avoid breaking the compilation\n     let dot_receiver = include_references(dot_receiver);\n-    let receiver_text =\n-        get_receiver_text(&dot_receiver, ctx.dot_receiver_is_ambiguous_float_literal);\n+    let receiver_text = get_receiver_text(&dot_receiver, receiver_is_ambiguous_float_literal);\n \n     match try_enum {\n         Some(try_enum) => match try_enum {"}, {"sha": "6e6a6eb92ef4dc7d7c6484aa476e73cc57db763e", "filename": "crates/ide_completion/src/completions/snippet.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=9d7343719ded81805b977000b4ad805458fe69c8", "patch": "@@ -29,7 +29,7 @@ pub(crate) fn complete_expr_snippet(acc: &mut Completions, ctx: &CompletionConte\n }\n \n pub(crate) fn complete_item_snippet(acc: &mut Completions, ctx: &CompletionContext) {\n-    if !ctx.is_new_item {\n+    if !ctx.expects_item() {\n         return;\n     }\n     let cap = match ctx.config.snippet_cap {"}, {"sha": "6f685c02f3857514c089f09e9fc88ce8bc5f3d33", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 20, "deletions": 45, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=9d7343719ded81805b977000b4ad805458fe69c8", "patch": "@@ -78,11 +78,6 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) can_be_stmt: bool,\n     /// `true` if we expect an expression at the cursor position.\n     pub(super) is_expr: bool,\n-    /// Something is typed at the \"top\" level, in module or impl/trait.\n-    pub(super) is_new_item: bool,\n-    /// The receiver if this is a field or method access, i.e. writing something.$0\n-    pub(super) dot_receiver: Option<ast::Expr>,\n-    pub(super) dot_receiver_is_ambiguous_float_literal: bool,\n     /// If this is a call (method or function) in particular, i.e. the () are already there.\n     pub(super) is_call: bool,\n     /// Like `is_call`, but for tuple patterns.\n@@ -158,9 +153,6 @@ impl<'a> CompletionContext<'a> {\n             path_qual: None,\n             can_be_stmt: false,\n             is_expr: false,\n-            is_new_item: false,\n-            dot_receiver: None,\n-            dot_receiver_is_ambiguous_float_literal: false,\n             is_call: false,\n             is_pattern_call: false,\n             is_macro_call: false,\n@@ -255,6 +247,22 @@ impl<'a> CompletionContext<'a> {\n         )\n     }\n \n+    pub(crate) fn has_dot_receiver(&self) -> bool {\n+        matches!(\n+            &self.completion_location,\n+            Some(ImmediateLocation::FieldAccess { receiver, .. }) | Some(ImmediateLocation::MethodCall { receiver })\n+                if receiver.is_some()\n+        )\n+    }\n+\n+    pub(crate) fn dot_receiver(&self) -> Option<&ast::Expr> {\n+        match &self.completion_location {\n+            Some(ImmediateLocation::MethodCall { receiver })\n+            | Some(ImmediateLocation::FieldAccess { receiver, .. }) => receiver.as_ref(),\n+            _ => None,\n+        }\n+    }\n+\n     pub(crate) fn expects_use_tree(&self) -> bool {\n         matches!(self.completion_location, Some(ImmediateLocation::Use))\n     }\n@@ -267,6 +275,7 @@ impl<'a> CompletionContext<'a> {\n         matches!(self.completion_location, Some(ImmediateLocation::ItemList))\n     }\n \n+    //         fn expects_value(&self) -> bool {\n     pub(crate) fn expects_expression(&self) -> bool {\n         self.is_expr\n     }\n@@ -540,16 +549,7 @@ impl<'a> CompletionContext<'a> {\n         self.name_ref_syntax =\n             find_node_at_offset(original_file, name_ref.syntax().text_range().start());\n \n-        let name_range = name_ref.syntax().text_range();\n-        let top_node = name_ref\n-            .syntax()\n-            .ancestors()\n-            .take_while(|it| it.text_range() == name_range)\n-            .last()\n-            .unwrap();\n-\n-        if matches!(top_node.parent().map(|it| it.kind()), Some(SOURCE_FILE) | Some(ITEM_LIST)) {\n-            self.is_new_item = true;\n+        if matches!(self.completion_location, Some(ImmediateLocation::ItemList)) {\n             return;\n         }\n \n@@ -623,33 +623,8 @@ impl<'a> CompletionContext<'a> {\n                 .unwrap_or(false);\n             self.is_expr = path.syntax().parent().and_then(ast::PathExpr::cast).is_some();\n         }\n-\n-        if let Some(field_expr) = ast::FieldExpr::cast(parent.clone()) {\n-            // The receiver comes before the point of insertion of the fake\n-            // ident, so it should have the same range in the non-modified file\n-            self.dot_receiver = field_expr\n-                .expr()\n-                .map(|e| e.syntax().text_range())\n-                .and_then(|r| find_node_with_range(original_file, r));\n-            self.dot_receiver_is_ambiguous_float_literal =\n-                if let Some(ast::Expr::Literal(l)) = &self.dot_receiver {\n-                    match l.kind() {\n-                        ast::LiteralKind::FloatNumber { .. } => l.token().text().ends_with('.'),\n-                        _ => false,\n-                    }\n-                } else {\n-                    false\n-                };\n-        }\n-\n-        if let Some(method_call_expr) = ast::MethodCallExpr::cast(parent) {\n-            // As above\n-            self.dot_receiver = method_call_expr\n-                .receiver()\n-                .map(|e| e.syntax().text_range())\n-                .and_then(|r| find_node_with_range(original_file, r));\n-            self.is_call = true;\n-        }\n+        self.is_call |=\n+            matches!(self.completion_location, Some(ImmediateLocation::MethodCall { .. }));\n     }\n }\n "}, {"sha": "080898aef00467c550bbabefa9eeabe0fedb02ad", "filename": "crates/ide_completion/src/patterns.rs", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fpatterns.rs?ref=9d7343719ded81805b977000b4ad805458fe69c8", "patch": "@@ -7,21 +7,21 @@ use syntax::{\n     ast::{self, LoopBodyOwner},\n     match_ast, AstNode, Direction, SyntaxElement,\n     SyntaxKind::*,\n-    SyntaxNode, SyntaxToken, TextSize, T,\n+    SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n };\n \n #[cfg(test)]\n use crate::test_utils::{check_pattern_is_applicable, check_pattern_is_not_applicable};\n \n-/// Direct parent container of the cursor position\n+/// Immediate previous node to what we are completing.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub(crate) enum ImmediatePrevSibling {\n     IfExpr,\n     TraitDefName,\n     ImplDefType,\n }\n \n-/// Direct parent container of the cursor position\n+/// Direct parent \"thing\" of what we are currently completing.\n #[derive(Clone, Debug, PartialEq, Eq)]\n pub(crate) enum ImmediateLocation {\n     Use,\n@@ -37,6 +37,15 @@ pub(crate) enum ImmediateLocation {\n     // Fake file ast node\n     ModDeclaration(ast::Module),\n     // Original file ast node\n+    MethodCall {\n+        receiver: Option<ast::Expr>,\n+    },\n+    // Original file ast node\n+    FieldAccess {\n+        receiver: Option<ast::Expr>,\n+        receiver_is_ambiguous_float_literal: bool,\n+    },\n+    // Original file ast node\n     /// The record expr of the field name we are completing\n     RecordExpr(ast::RecordExpr),\n     // Original file ast node\n@@ -164,12 +173,38 @@ pub(crate) fn determine_location(\n                 Some(TRAIT) => ImmediateLocation::Trait,\n                 _ => return None,\n             },\n-            ast::Module(it) => if it.item_list().is_none() {\n+            ast::Module(it) => {\n+                if it.item_list().is_none() {\n                     ImmediateLocation::ModDeclaration(it)\n                 } else {\n-                    return None\n+                    return None;\n+                }\n             },\n             ast::Attr(it) => ImmediateLocation::Attribute(it),\n+            ast::FieldExpr(it) => {\n+                let receiver = it\n+                    .expr()\n+                    .map(|e| e.syntax().text_range())\n+                    .and_then(|r| find_node_with_range(original_file, r));\n+                let receiver_is_ambiguous_float_literal = if let Some(ast::Expr::Literal(l)) = &receiver {\n+                    match l.kind() {\n+                        ast::LiteralKind::FloatNumber { .. } => l.token().text().ends_with('.'),\n+                        _ => false,\n+                    }\n+                } else {\n+                    false\n+                };\n+                ImmediateLocation::FieldAccess {\n+                    receiver,\n+                    receiver_is_ambiguous_float_literal,\n+                }\n+            },\n+            ast::MethodCallExpr(it) => ImmediateLocation::MethodCall {\n+                receiver: it\n+                    .receiver()\n+                    .map(|e| e.syntax().text_range())\n+                    .and_then(|r| find_node_with_range(original_file, r)),\n+            },\n             _ => return None,\n         }\n     };\n@@ -194,6 +229,10 @@ fn maximize_name_ref(name_ref: &ast::NameRef) -> SyntaxNode {\n     name_ref.syntax().clone()\n }\n \n+fn find_node_with_range<N: AstNode>(syntax: &SyntaxNode, range: TextRange) -> Option<N> {\n+    syntax.covering_element(range).ancestors().find_map(N::cast)\n+}\n+\n pub(crate) fn inside_impl_trait_block(element: SyntaxElement) -> bool {\n     // Here we search `impl` keyword up through the all ancestors, unlike in `has_impl_parent`,\n     // where we only check the first parent with different text range."}, {"sha": "1abeed96d7d3a45f25c6c294326a38dd2842deba", "filename": "crates/ide_completion/src/render/function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d7343719ded81805b977000b4ad805458fe69c8/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs?ref=9d7343719ded81805b977000b4ad805458fe69c8", "patch": "@@ -154,7 +154,7 @@ impl<'a> FunctionRender<'a> {\n         };\n \n         let mut params_pats = Vec::new();\n-        let params_ty = if self.ctx.completion.dot_receiver.is_some() || self.receiver.is_some() {\n+        let params_ty = if self.ctx.completion.has_dot_receiver() || self.receiver.is_some() {\n             self.func.method_params(self.ctx.db()).unwrap_or_default()\n         } else {\n             if let Some(s) = ast_params.self_param() {"}]}