{"sha": "0c8e520b3e0d9fbdafb8311f1b18a1f847531051", "node_id": "C_kwDOAAsO6NoAKDBjOGU1MjBiM2UwZDlmYmRhZmI4MzExZjFiMThhMWY4NDc1MzEwNTE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-30T02:41:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-30T02:41:34Z"}, "message": "Auto merge of #90988 - estebank:binding-supposed-to-be-const, r=davidtwco\n\nWhen encountering a binding that could be a const or unit variant, suggest the right path", "tree": {"sha": "4a8fb599f2fefd684dd4925a6fc73416f5cc9688", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a8fb599f2fefd684dd4925a6fc73416f5cc9688"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c8e520b3e0d9fbdafb8311f1b18a1f847531051", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c8e520b3e0d9fbdafb8311f1b18a1f847531051", "html_url": "https://github.com/rust-lang/rust/commit/0c8e520b3e0d9fbdafb8311f1b18a1f847531051", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05c07386b45fbc540ec8cdc1bc41ae9c062b453b", "url": "https://api.github.com/repos/rust-lang/rust/commits/05c07386b45fbc540ec8cdc1bc41ae9c062b453b", "html_url": "https://github.com/rust-lang/rust/commit/05c07386b45fbc540ec8cdc1bc41ae9c062b453b"}, {"sha": "bce5ab2c7864aa553aa70115336271586daba21c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bce5ab2c7864aa553aa70115336271586daba21c", "html_url": "https://github.com/rust-lang/rust/commit/bce5ab2c7864aa553aa70115336271586daba21c"}], "stats": {"total": 252, "additions": 164, "deletions": 88}, "files": [{"sha": "e0a83ba8c0d4ac95ce65bcd3983dbdb3ca1314c3", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 104, "deletions": 30, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=0c8e520b3e0d9fbdafb8311f1b18a1f847531051", "patch": "@@ -123,7 +123,7 @@ impl<'a> Resolver<'a> {\n             let (span, found_use) = if let Some(def_id) = def_id.as_local() {\n                 UsePlacementFinder::check(krate, self.def_id_to_node_id[def_id])\n             } else {\n-                (None, false)\n+                (None, FoundUse::No)\n             };\n             if !candidates.is_empty() {\n                 show_candidates(\n@@ -132,8 +132,9 @@ impl<'a> Resolver<'a> {\n                     &mut err,\n                     span,\n                     &candidates,\n-                    instead,\n+                    if instead { Instead::Yes } else { Instead::No },\n                     found_use,\n+                    IsPattern::No,\n                 );\n             } else if let Some((span, msg, sugg, appl)) = suggestion {\n                 err.span_suggestion(span, msg, sugg, appl);\n@@ -493,14 +494,14 @@ impl<'a> Resolver<'a> {\n     ///\n     /// This takes the error provided, combines it with the span and any additional spans inside the\n     /// error and emits it.\n-    crate fn report_error(&self, span: Span, resolution_error: ResolutionError<'_>) {\n+    crate fn report_error(&mut self, span: Span, resolution_error: ResolutionError<'a>) {\n         self.into_struct_error(span, resolution_error).emit();\n     }\n \n     crate fn into_struct_error(\n-        &self,\n+        &mut self,\n         span: Span,\n-        resolution_error: ResolutionError<'_>,\n+        resolution_error: ResolutionError<'a>,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         match resolution_error {\n             ResolutionError::GenericParamsFromOuterFunction(outer_res, has_generic_params) => {\n@@ -650,7 +651,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 err\n             }\n-            ResolutionError::VariableNotBoundInPattern(binding_error) => {\n+            ResolutionError::VariableNotBoundInPattern(binding_error, parent_scope) => {\n                 let BindingError { name, target, origin, could_be_path } = binding_error;\n \n                 let target_sp = target.iter().copied().collect::<Vec<_>>();\n@@ -670,13 +671,41 @@ impl<'a> Resolver<'a> {\n                 for sp in origin_sp {\n                     err.span_label(sp, \"variable not in all patterns\");\n                 }\n-                if *could_be_path {\n-                    let help_msg = format!(\n-                        \"if you meant to match on a variant or a `const` item, consider \\\n-                         making the path in the pattern qualified: `?::{}`\",\n-                        name,\n+                if could_be_path {\n+                    let import_suggestions = self.lookup_import_candidates(\n+                        Ident::with_dummy_span(name),\n+                        Namespace::ValueNS,\n+                        &parent_scope,\n+                        &|res: Res| match res {\n+                            Res::Def(\n+                                DefKind::Ctor(CtorOf::Variant, CtorKind::Const)\n+                                | DefKind::Ctor(CtorOf::Struct, CtorKind::Const)\n+                                | DefKind::Const\n+                                | DefKind::AssocConst,\n+                                _,\n+                            ) => true,\n+                            _ => false,\n+                        },\n+                    );\n+\n+                    if import_suggestions.is_empty() {\n+                        let help_msg = format!(\n+                            \"if you meant to match on a variant or a `const` item, consider \\\n+                             making the path in the pattern qualified: `path::to::ModOrType::{}`\",\n+                            name,\n+                        );\n+                        err.span_help(span, &help_msg);\n+                    }\n+                    show_candidates(\n+                        &self.definitions,\n+                        self.session,\n+                        &mut err,\n+                        Some(span),\n+                        &import_suggestions,\n+                        Instead::No,\n+                        FoundUse::Yes,\n+                        IsPattern::Yes,\n                     );\n-                    err.span_help(span, &help_msg);\n                 }\n                 err\n             }\n@@ -1022,7 +1051,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     crate fn report_vis_error(\n-        &self,\n+        &mut self,\n         vis_resolution_error: VisResolutionError<'_>,\n     ) -> ErrorGuaranteed {\n         match vis_resolution_error {\n@@ -1453,8 +1482,9 @@ impl<'a> Resolver<'a> {\n             err,\n             None,\n             &import_suggestions,\n-            false,\n-            true,\n+            Instead::No,\n+            FoundUse::Yes,\n+            IsPattern::No,\n         );\n \n         if macro_kind == MacroKind::Derive && (ident.name == sym::Send || ident.name == sym::Sync) {\n@@ -2390,6 +2420,27 @@ fn find_span_immediately_after_crate_name(\n     (next_left_bracket == after_second_colon, from_second_colon)\n }\n \n+/// A suggestion has already been emitted, change the wording slightly to clarify that both are\n+/// independent options.\n+enum Instead {\n+    Yes,\n+    No,\n+}\n+\n+/// Whether an existing place with an `use` item was found.\n+enum FoundUse {\n+    Yes,\n+    No,\n+}\n+\n+/// Whether a binding is part of a pattern or an expression. Used for diagnostics.\n+enum IsPattern {\n+    /// The binding is part of a pattern\n+    Yes,\n+    /// The binding is part of an expression\n+    No,\n+}\n+\n /// When an entity with a given name is not available in scope, we search for\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way\n@@ -2400,8 +2451,9 @@ fn show_candidates(\n     // This is `None` if all placement locations are inside expansions\n     use_placement_span: Option<Span>,\n     candidates: &[ImportSuggestion],\n-    instead: bool,\n-    found_use: bool,\n+    instead: Instead,\n+    found_use: FoundUse,\n+    is_pattern: IsPattern,\n ) {\n     if candidates.is_empty() {\n         return;\n@@ -2428,32 +2480,46 @@ fn show_candidates(\n     }\n \n     if !accessible_path_strings.is_empty() {\n-        let (determiner, kind) = if accessible_path_strings.len() == 1 {\n-            (\"this\", accessible_path_strings[0].1)\n+        let (determiner, kind, name) = if accessible_path_strings.len() == 1 {\n+            (\"this\", accessible_path_strings[0].1, format!(\" `{}`\", accessible_path_strings[0].0))\n         } else {\n-            (\"one of these\", \"items\")\n+            (\"one of these\", \"items\", String::new())\n         };\n \n-        let instead = if instead { \" instead\" } else { \"\" };\n-        let mut msg = format!(\"consider importing {} {}{}\", determiner, kind, instead);\n+        let instead = if let Instead::Yes = instead { \" instead\" } else { \"\" };\n+        let mut msg = if let IsPattern::Yes = is_pattern {\n+            format!(\n+                \"if you meant to match on {}{}{}, use the full path in the pattern\",\n+                kind, instead, name\n+            )\n+        } else {\n+            format!(\"consider importing {} {}{}\", determiner, kind, instead)\n+        };\n \n         for note in accessible_path_strings.iter().flat_map(|cand| cand.3.as_ref()) {\n             err.note(note);\n         }\n \n-        if let Some(span) = use_placement_span {\n+        if let (IsPattern::Yes, Some(span)) = (is_pattern, use_placement_span) {\n+            err.span_suggestions(\n+                span,\n+                &msg,\n+                accessible_path_strings.into_iter().map(|a| a.0),\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else if let Some(span) = use_placement_span {\n             for candidate in &mut accessible_path_strings {\n                 // produce an additional newline to separate the new use statement\n                 // from the directly following item.\n-                let additional_newline = if found_use { \"\" } else { \"\\n\" };\n+                let additional_newline = if let FoundUse::Yes = found_use { \"\" } else { \"\\n\" };\n                 candidate.0 = format!(\"use {};\\n{}\", &candidate.0, additional_newline);\n             }\n \n             err.span_suggestions(\n                 span,\n                 &msg,\n                 accessible_path_strings.into_iter().map(|a| a.0),\n-                Applicability::Unspecified,\n+                Applicability::MaybeIncorrect,\n             );\n         } else {\n             msg.push(':');\n@@ -2468,9 +2534,17 @@ fn show_candidates(\n     } else {\n         assert!(!inaccessible_path_strings.is_empty());\n \n+        let prefix =\n+            if let IsPattern::Yes = is_pattern { \"you might have meant to match on \" } else { \"\" };\n         if inaccessible_path_strings.len() == 1 {\n             let (name, descr, def_id, note) = &inaccessible_path_strings[0];\n-            let msg = format!(\"{} `{}` exists but is inaccessible\", descr, name);\n+            let msg = format!(\n+                \"{}{} `{}`{} exists but is inaccessible\",\n+                prefix,\n+                descr,\n+                name,\n+                if let IsPattern::Yes = is_pattern { \", which\" } else { \"\" }\n+            );\n \n             if let Some(local_def_id) = def_id.and_then(|did| did.as_local()) {\n                 let span = definitions.def_span(local_def_id);\n@@ -2496,7 +2570,7 @@ fn show_candidates(\n                 \"item\".to_string()\n             };\n \n-            let mut msg = format!(\"these {}s exist but are inaccessible\", descr);\n+            let mut msg = format!(\"{}these {}s exist but are inaccessible\", prefix, descr);\n             let mut has_colon = false;\n \n             let mut spans = Vec::new();\n@@ -2537,14 +2611,14 @@ struct UsePlacementFinder {\n }\n \n impl UsePlacementFinder {\n-    fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, bool) {\n+    fn check(krate: &Crate, target_module: NodeId) -> (Option<Span>, FoundUse) {\n         let mut finder =\n             UsePlacementFinder { target_module, first_legal_span: None, first_use_span: None };\n         finder.visit_crate(krate);\n         if let Some(use_span) = finder.first_use_span {\n-            (Some(use_span), true)\n+            (Some(use_span), FoundUse::Yes)\n         } else {\n-            (finder.first_legal_span, false)\n+            (finder.first_legal_span, FoundUse::No)\n         }\n     }\n }"}, {"sha": "aafef3e3137119821d32339eefb152aa442bda57", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=0c8e520b3e0d9fbdafb8311f1b18a1f847531051", "patch": "@@ -1422,7 +1422,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n     /// Searches the current set of local scopes for labels. Returns the `NodeId` of the resolved\n     /// label and reports an error if the label is not found or is unreachable.\n-    fn resolve_label(&self, mut label: Ident) -> Option<NodeId> {\n+    fn resolve_label(&mut self, mut label: Ident) -> Option<NodeId> {\n         let mut suggestion = None;\n \n         // Preserve the original span so that errors contain \"in this macro invocation\"\n@@ -1442,14 +1442,15 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             let ident = label.normalize_to_macro_rules();\n             if let Some((ident, id)) = rib.bindings.get_key_value(&ident) {\n+                let definition_span = ident.span;\n                 return if self.is_label_valid_from_rib(i) {\n                     Some(*id)\n                 } else {\n                     self.report_error(\n                         original_span,\n                         ResolutionError::UnreachableLabel {\n                             name: label.name,\n-                            definition_span: ident.span,\n+                            definition_span,\n                             suggestion,\n                         },\n                     );\n@@ -2135,7 +2136,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         span: Span,\n         err: F,\n     ) where\n-        F: FnOnce(Ident, &str, Option<Symbol>) -> ResolutionError<'_>,\n+        F: FnOnce(Ident, String, Option<Symbol>) -> ResolutionError<'a>,\n     {\n         // If there is a TraitRef in scope for an impl, then the method must be in the trait.\n         let Some((module, _)) = &self.current_trait_ref else { return; };\n@@ -2159,7 +2160,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // We could not find the method: report an error.\n             let candidate = self.find_similarly_named_assoc_item(ident.name, kind);\n             let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n-            self.report_error(span, err(ident, &path_names_to_string(path), candidate));\n+            let path_names = path_names_to_string(path);\n+            self.report_error(span, err(ident, path_names, candidate));\n             return;\n         };\n \n@@ -2183,13 +2185,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             AssocItemKind::TyAlias(..) => (rustc_errors::error_code!(E0325), \"type\"),\n             AssocItemKind::MacCall(..) => span_bug!(span, \"unexpanded macro\"),\n         };\n+        let trait_path = path_names_to_string(path);\n         self.report_error(\n             span,\n             ResolutionError::TraitImplMismatch {\n                 name: ident.name,\n                 kind,\n                 code,\n-                trait_path: path_names_to_string(path),\n+                trait_path,\n                 trait_item_span: binding.span,\n             },\n         );\n@@ -2304,16 +2307,16 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n \n         // 3) Report all missing variables we found.\n-        let mut missing_vars = missing_vars.iter_mut().collect::<Vec<_>>();\n-        missing_vars.sort_by_key(|(sym, _err)| sym.as_str());\n+        let mut missing_vars = missing_vars.into_iter().collect::<Vec<_>>();\n+        missing_vars.sort_by_key(|&(sym, ref _err)| sym);\n \n-        for (name, mut v) in missing_vars {\n-            if inconsistent_vars.contains_key(name) {\n+        for (name, mut v) in missing_vars.into_iter() {\n+            if inconsistent_vars.contains_key(&name) {\n                 v.could_be_path = false;\n             }\n             self.report_error(\n                 *v.origin.iter().next().unwrap(),\n-                ResolutionError::VariableNotBoundInPattern(v),\n+                ResolutionError::VariableNotBoundInPattern(v, self.parent_scope),\n             );\n         }\n \n@@ -2815,7 +2818,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     /// A wrapper around [`Resolver::report_error`].\n     ///\n     /// This doesn't emit errors for function bodies if this is rustdoc.\n-    fn report_error(&self, span: Span, resolution_error: ResolutionError<'_>) {\n+    fn report_error(&mut self, span: Span, resolution_error: ResolutionError<'a>) {\n         if self.should_report_errs() {\n             self.r.report_error(span, resolution_error);\n         }"}, {"sha": "dbc4f337ad3b55a33d4a6aeaaad1a283b838a7c2", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=0c8e520b3e0d9fbdafb8311f1b18a1f847531051", "patch": "@@ -201,13 +201,13 @@ enum ResolutionError<'a> {\n     /// parameter list.\n     NameAlreadyUsedInParameterList(Symbol, Span),\n     /// Error E0407: method is not a member of trait.\n-    MethodNotMemberOfTrait(Ident, &'a str, Option<Symbol>),\n+    MethodNotMemberOfTrait(Ident, String, Option<Symbol>),\n     /// Error E0437: type is not a member of trait.\n-    TypeNotMemberOfTrait(Ident, &'a str, Option<Symbol>),\n+    TypeNotMemberOfTrait(Ident, String, Option<Symbol>),\n     /// Error E0438: const is not a member of trait.\n-    ConstNotMemberOfTrait(Ident, &'a str, Option<Symbol>),\n+    ConstNotMemberOfTrait(Ident, String, Option<Symbol>),\n     /// Error E0408: variable `{}` is not bound in all patterns.\n-    VariableNotBoundInPattern(&'a BindingError),\n+    VariableNotBoundInPattern(BindingError, ParentScope<'a>),\n     /// Error E0409: variable `{}` is bound in inconsistent ways within the same match arm.\n     VariableBoundWithDifferentMode(Symbol, Span),\n     /// Error E0415: identifier is bound more than once in this parameter list."}, {"sha": "356763fab5e3b35e2b612bfa6905940c693cef68", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=0c8e520b3e0d9fbdafb8311f1b18a1f847531051", "patch": "@@ -643,6 +643,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             });\n             let pre = if in_match { \"in the same arm, \" } else { \"\" };\n             err.note(&format!(\"{}a binding must have the same type in all alternatives\", pre));\n+            // FIXME: check if `var_ty` and `ty` can be made the same type by adding or removing\n+            // `ref` or `&` to the pattern.\n             err.emit();\n         }\n     }"}, {"sha": "8fafa275b5c2736d007b97af3122beb4ec19de36", "filename": "src/test/ui/or-patterns/missing-bindings.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fmissing-bindings.stderr?ref=0c8e520b3e0d9fbdafb8311f1b18a1f847531051", "patch": "@@ -103,6 +103,22 @@ LL |     let (A(A(a, b) | B(c), d) | B(e)) = Y;\n    |            |\n    |            pattern doesn't bind `c`\n \n+error[E0408]: variable `d` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:45:33\n+   |\n+LL |     let (A(A(a, b) | B(c), d) | B(e)) = Y;\n+   |                            -    ^^^^ pattern doesn't bind `d`\n+   |                            |\n+   |                            variable not in all patterns\n+\n+error[E0408]: variable `e` is not bound in all patterns\n+  --> $DIR/missing-bindings.rs:45:10\n+   |\n+LL |     let (A(A(a, b) | B(c), d) | B(e)) = Y;\n+   |          ^^^^^^^^^^^^^^^^^^^^     - variable not in all patterns\n+   |          |\n+   |          pattern doesn't bind `e`\n+\n error[E0408]: variable `a` is not bound in all patterns\n   --> $DIR/missing-bindings.rs:45:33\n    |\n@@ -127,22 +143,6 @@ LL |     let (A(A(a, b) | B(c), d) | B(e)) = Y;\n    |                        |\n    |                        variable not in all patterns\n \n-error[E0408]: variable `d` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:45:33\n-   |\n-LL |     let (A(A(a, b) | B(c), d) | B(e)) = Y;\n-   |                            -    ^^^^ pattern doesn't bind `d`\n-   |                            |\n-   |                            variable not in all patterns\n-\n-error[E0408]: variable `e` is not bound in all patterns\n-  --> $DIR/missing-bindings.rs:45:10\n-   |\n-LL |     let (A(A(a, b) | B(c), d) | B(e)) = Y;\n-   |          ^^^^^^^^^^^^^^^^^^^^     - variable not in all patterns\n-   |          |\n-   |          pattern doesn't bind `e`\n-\n error[E0408]: variable `a` is not bound in all patterns\n   --> $DIR/missing-bindings.rs:61:29\n    |"}, {"sha": "989d2d4523099c4ba2066f1fd82e3caa866e3645", "filename": "src/test/ui/resolve/resolve-inconsistent-names.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.rs?ref=0c8e520b3e0d9fbdafb8311f1b18a1f847531051", "patch": "@@ -2,9 +2,9 @@\n \n enum E { A, B, c }\n \n-mod m {\n+pub mod m {\n     const CONST1: usize = 10;\n-    const Const2: usize = 20;\n+    pub const Const2: usize = 20;\n }\n \n fn main() {\n@@ -22,15 +22,14 @@ fn main() {\n         //~| ERROR variable `B` is bound inconsistently\n         //~| ERROR mismatched types\n         //~| ERROR variable `c` is not bound in all patterns\n-        //~| HELP consider making the path in the pattern qualified: `?::A`\n+        //~| HELP if you meant to match on unit variant `E::A`, use the full path in the pattern\n     }\n \n     let z = (10, 20);\n     match z {\n         (CONST1, _) | (_, Const2) => ()\n         //~^ ERROR variable `CONST1` is not bound in all patterns\n-        //~| HELP consider making the path in the pattern qualified: `?::CONST1`\n         //~| ERROR variable `Const2` is not bound in all patterns\n-        //~| HELP consider making the path in the pattern qualified: `?::Const2`\n+        //~| HELP if you meant to match on constant `m::Const2`, use the full path in the pattern\n     }\n }"}, {"sha": "9de191f7d327ac40294239a30b81795d05f134b3", "filename": "src/test/ui/resolve/resolve-inconsistent-names.stderr", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr?ref=0c8e520b3e0d9fbdafb8311f1b18a1f847531051", "patch": "@@ -23,11 +23,10 @@ LL |         (A, B) | (ref B, c) | (c, A) => ()\n    |          |       pattern doesn't bind `A`\n    |          variable not in all patterns\n    |\n-help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `?::A`\n-  --> $DIR/resolve-inconsistent-names.rs:19:10\n+help: if you meant to match on unit variant `E::A`, use the full path in the pattern\n    |\n-LL |         (A, B) | (ref B, c) | (c, A) => ()\n-   |          ^\n+LL |         (E::A, B) | (ref B, c) | (c, A) => ()\n+   |          ~~~~\n \n error[E0408]: variable `B` is not bound in all patterns\n   --> $DIR/resolve-inconsistent-names.rs:19:31\n@@ -63,11 +62,11 @@ LL |         (CONST1, _) | (_, Const2) => ()\n    |          |\n    |          variable not in all patterns\n    |\n-help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `?::CONST1`\n-  --> $DIR/resolve-inconsistent-names.rs:30:10\n+note: you might have meant to match on constant `m::CONST1`, which exists but is inaccessible\n+  --> $DIR/resolve-inconsistent-names.rs:6:5\n    |\n-LL |         (CONST1, _) | (_, Const2) => ()\n-   |          ^^^^^^\n+LL |     const CONST1: usize = 10;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\n \n error[E0408]: variable `Const2` is not bound in all patterns\n   --> $DIR/resolve-inconsistent-names.rs:30:9\n@@ -77,11 +76,10 @@ LL |         (CONST1, _) | (_, Const2) => ()\n    |         |\n    |         pattern doesn't bind `Const2`\n    |\n-help: if you meant to match on a variant or a `const` item, consider making the path in the pattern qualified: `?::Const2`\n-  --> $DIR/resolve-inconsistent-names.rs:30:27\n+help: if you meant to match on constant `m::Const2`, use the full path in the pattern\n    |\n-LL |         (CONST1, _) | (_, Const2) => ()\n-   |                           ^^^^^^\n+LL |         (CONST1, _) | (_, m::Const2) => ()\n+   |                           ~~~~~~~~~\n \n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-names.rs:19:19"}, {"sha": "25c35fd5479f933ce4db6a3563e32ce0a152045e", "filename": "src/test/ui/span/issue-39698.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/src%2Ftest%2Fui%2Fspan%2Fissue-39698.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c8e520b3e0d9fbdafb8311f1b18a1f847531051/src%2Ftest%2Fui%2Fspan%2Fissue-39698.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-39698.stderr?ref=0c8e520b3e0d9fbdafb8311f1b18a1f847531051", "patch": "@@ -1,3 +1,13 @@\n+error[E0408]: variable `d` is not bound in all patterns\n+  --> $DIR/issue-39698.rs:10:37\n+   |\n+LL |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => { println!(\"{:?}\", a); }\n+   |                  -          -       ^^^^^^^^   ^^^^^^^^ pattern doesn't bind `d`\n+   |                  |          |       |\n+   |                  |          |       pattern doesn't bind `d`\n+   |                  |          variable not in all patterns\n+   |                  variable not in all patterns\n+\n error[E0408]: variable `a` is not bound in all patterns\n   --> $DIR/issue-39698.rs:10:23\n    |\n@@ -28,16 +38,6 @@ LL |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => { println!(\"{:?}\n    |         |             pattern doesn't bind `c`\n    |         pattern doesn't bind `c`\n \n-error[E0408]: variable `d` is not bound in all patterns\n-  --> $DIR/issue-39698.rs:10:37\n-   |\n-LL |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => { println!(\"{:?}\", a); }\n-   |                  -          -       ^^^^^^^^   ^^^^^^^^ pattern doesn't bind `d`\n-   |                  |          |       |\n-   |                  |          |       pattern doesn't bind `d`\n-   |                  |          variable not in all patterns\n-   |                  variable not in all patterns\n-\n error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0408`."}]}