{"sha": "c4fcfa2b0d516b9790fa8abdf96bb2308657d60a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0ZmNmYTJiMGQ1MTZiOTc5MGZhOGFiZGY5NmJiMjMwODY1N2Q2MGE=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-08-25T11:57:03Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-09-03T12:00:35Z"}, "message": "Properly format `impl Trait<Type = Foo>` types\n\nIt's a bit complicated because we basically have to 'undo' the desugaring, and\nthe result is very dependent on the specifics of the desugaring and will\nprobably produce weird results otherwise.", "tree": {"sha": "94ae979da298244b9a057b6eacf58875101535b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94ae979da298244b9a057b6eacf58875101535b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4fcfa2b0d516b9790fa8abdf96bb2308657d60a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4fcfa2b0d516b9790fa8abdf96bb2308657d60a", "html_url": "https://github.com/rust-lang/rust/commit/c4fcfa2b0d516b9790fa8abdf96bb2308657d60a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4fcfa2b0d516b9790fa8abdf96bb2308657d60a/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "741e350d4b7c3561f242207541ac9d7cab6ce45f", "url": "https://api.github.com/repos/rust-lang/rust/commits/741e350d4b7c3561f242207541ac9d7cab6ce45f", "html_url": "https://github.com/rust-lang/rust/commit/741e350d4b7c3561f242207541ac9d7cab6ce45f"}], "stats": {"total": 120, "additions": 97, "deletions": 23}, "files": [{"sha": "c0c609d78fd254e87d058cce60fc0d81e95a5b45", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 93, "deletions": 19, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c4fcfa2b0d516b9790fa8abdf96bb2308657d60a/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4fcfa2b0d516b9790fa8abdf96bb2308657d60a/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=c4fcfa2b0d516b9790fa8abdf96bb2308657d60a", "patch": "@@ -121,6 +121,16 @@ pub struct ProjectionTy {\n }\n \n impl ProjectionTy {\n+    pub fn trait_ref(&self, db: &impl HirDatabase) -> TraitRef {\n+        TraitRef {\n+            trait_: self\n+                .associated_ty\n+                .parent_trait(db)\n+                .expect(\"projection ty without parent trait\"),\n+            substs: self.parameters.clone(),\n+        }\n+    }\n+\n     pub fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         self.parameters.walk(f);\n     }\n@@ -341,6 +351,21 @@ impl GenericPredicate {\n         }\n     }\n \n+    pub fn is_implemented(&self) -> bool {\n+        match self {\n+            GenericPredicate::Implemented(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn trait_ref(&self, db: &impl HirDatabase) -> Option<TraitRef> {\n+        match self {\n+            GenericPredicate::Implemented(tr) => Some(tr.clone()),\n+            GenericPredicate::Projection(proj) => Some(proj.projection_ty.trait_ref(db)),\n+            GenericPredicate::Error => None,\n+        }\n+    }\n+\n     pub fn subst(self, substs: &Substs) -> GenericPredicate {\n         match self {\n             GenericPredicate::Implemented(trait_ref) => {\n@@ -769,23 +794,66 @@ impl HirDisplay for Ty {\n                     Ty::Opaque(_) => write!(f, \"impl \")?,\n                     _ => unreachable!(),\n                 };\n-                // looping by hand here just to format the bounds in a slightly nicer way\n+                // Note: This code is written to produce nice results (i.e.\n+                // corresponding to surface Rust) for types that can occur in\n+                // actual Rust. It will have weird results if the predicates\n+                // aren't as expected (i.e. self types = $0, projection\n+                // predicates for a certain trait come after the Implemented\n+                // predicate for that trait).\n                 let mut first = true;\n+                let mut angle_open = false;\n                 for p in predicates.iter() {\n-                    if !first {\n-                        write!(f, \" + \")?;\n-                    }\n-                    first = false;\n                     match p {\n-                        // don't show the $0 self type\n                         GenericPredicate::Implemented(trait_ref) => {\n-                            trait_ref.hir_fmt_ext(f, false)?\n+                            if angle_open {\n+                                write!(f, \">\")?;\n+                            }\n+                            if !first {\n+                                write!(f, \" + \")?;\n+                            }\n+                            // We assume that the self type is $0 (i.e. the\n+                            // existential) here, which is the only thing that's\n+                            // possible in actual Rust, and hence don't print it\n+                            write!(\n+                                f,\n+                                \"{}\",\n+                                trait_ref.trait_.name(f.db).unwrap_or_else(Name::missing)\n+                            )?;\n+                            if trait_ref.substs.len() > 1 {\n+                                write!(f, \"<\")?;\n+                                f.write_joined(&trait_ref.substs[1..], \", \")?;\n+                                // there might be assoc type bindings, so we leave the angle brackets open\n+                                angle_open = true;\n+                            }\n                         }\n-                        GenericPredicate::Projection(_projection_pred) => {\n-                            // TODO show something\n+                        GenericPredicate::Projection(projection_pred) => {\n+                            // in types in actual Rust, these will always come\n+                            // after the corresponding Implemented predicate\n+                            if angle_open {\n+                                write!(f, \", \")?;\n+                            } else {\n+                                write!(f, \"<\")?;\n+                                angle_open = true;\n+                            }\n+                            let name = projection_pred.projection_ty.associated_ty.name(f.db);\n+                            write!(f, \"{} = \", name)?;\n+                            projection_pred.ty.hir_fmt(f)?;\n+                        }\n+                        GenericPredicate::Error => {\n+                            if angle_open {\n+                                // impl Trait<X, {error}>\n+                                write!(f, \", \")?;\n+                            } else if !first {\n+                                // impl Trait + {error}\n+                                write!(f, \" + \")?;\n+                            }\n+                            p.hir_fmt(f)?;\n                         }\n-                        GenericPredicate::Error => p.hir_fmt(f)?,\n                     }\n+                    first = false;\n+                }\n+                if angle_open {\n+                    write!(f, \">\")?;\n                 }\n             }\n             Ty::Unknown => write!(f, \"{{unknown}}\")?,\n@@ -796,13 +864,12 @@ impl HirDisplay for Ty {\n }\n \n impl TraitRef {\n-    fn hir_fmt_ext(\n-        &self,\n-        f: &mut HirFormatter<impl HirDatabase>,\n-        with_self_ty: bool,\n-    ) -> fmt::Result {\n-        if with_self_ty {\n-            write!(f, \"{}: \", self.substs[0].display(f.db),)?;\n+    fn hir_fmt_ext(&self, f: &mut HirFormatter<impl HirDatabase>, use_as: bool) -> fmt::Result {\n+        self.substs[0].hir_fmt(f)?;\n+        if use_as {\n+            write!(f, \" as \")?;\n+        } else {\n+            write!(f, \": \")?;\n         }\n         write!(f, \"{}\", self.trait_.name(f.db).unwrap_or_else(Name::missing))?;\n         if self.substs.len() > 1 {\n@@ -816,7 +883,7 @@ impl TraitRef {\n \n impl HirDisplay for TraitRef {\n     fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> fmt::Result {\n-        self.hir_fmt_ext(f, true)\n+        self.hir_fmt_ext(f, false)\n     }\n }\n \n@@ -831,7 +898,14 @@ impl HirDisplay for GenericPredicate {\n         match self {\n             GenericPredicate::Implemented(trait_ref) => trait_ref.hir_fmt(f)?,\n             GenericPredicate::Projection(projection_pred) => {\n-                // TODO print something\n+                write!(f, \"<\")?;\n+                projection_pred.projection_ty.trait_ref(f.db).hir_fmt_ext(f, true)?;\n+                write!(\n+                    f,\n+                    \">::{} = {}\",\n+                    projection_pred.projection_ty.associated_ty.name(f.db),\n+                    projection_pred.ty.display(f.db)\n+                )?;\n             }\n             GenericPredicate::Error => write!(f, \"{{error}}\")?,\n         }"}, {"sha": "d92d4659b253856d3b2a28cfdda059f729491a14", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c4fcfa2b0d516b9790fa8abdf96bb2308657d60a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4fcfa2b0d516b9790fa8abdf96bb2308657d60a/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=c4fcfa2b0d516b9790fa8abdf96bb2308657d60a", "patch": "@@ -3586,20 +3586,20 @@ fn test<T: Trait<Type = u32>>(x: T, y: impl Trait<Type = i64>) {\n     [166; 169) '{t}': T\n     [167; 168) 't': T\n     [257; 258) 'x': T\n-    [263; 264) 'y': impl Trait + \n+    [263; 264) 'y': impl Trait<Type = i64>\n     [290; 398) '{     ...r>); }': ()\n     [296; 299) 'get': fn get<T>(T) -> <T as Trait>::Type\n     [296; 302) 'get(x)': {unknown}\n     [300; 301) 'x': T\n     [308; 312) 'get2': fn get2<{unknown}, S<{unknown}>>(T) -> U\n     [308; 315) 'get2(x)': {unknown}\n     [313; 314) 'x': T\n-    [321; 324) 'get': fn get<impl Trait + >(T) -> <T as Trait>::Type\n+    [321; 324) 'get': fn get<impl Trait<Type = i64>>(T) -> <T as Trait>::Type\n     [321; 327) 'get(y)': {unknown}\n-    [325; 326) 'y': impl Trait + \n+    [325; 326) 'y': impl Trait<Type = i64>\n     [333; 337) 'get2': fn get2<{unknown}, S<{unknown}>>(T) -> U\n     [333; 340) 'get2(y)': {unknown}\n-    [338; 339) 'y': impl Trait + \n+    [338; 339) 'y': impl Trait<Type = i64>\n     [346; 349) 'get': fn get<S<u64>>(T) -> <T as Trait>::Type\n     [346; 357) 'get(set(S))': u64\n     [350; 353) 'set': fn set<S<u64>>(T) -> T"}]}