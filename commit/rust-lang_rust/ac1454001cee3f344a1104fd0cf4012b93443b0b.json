{"sha": "ac1454001cee3f344a1104fd0cf4012b93443b0b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMTQ1NDAwMWNlZTNmMzQ0YTExMDRmZDBjZjQwMTJiOTM0NDNiMGI=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2020-10-03T18:30:32Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2020-10-26T21:54:45Z"}, "message": "Suggest expressions that look like const generic arguments should be enclosed in brackets\n\nCo-Authored-By: Esteban Kuber <github@kuber.com.ar>", "tree": {"sha": "560b19e8611783f0512745abe841fda57cffb245", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/560b19e8611783f0512745abe841fda57cffb245"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac1454001cee3f344a1104fd0cf4012b93443b0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac1454001cee3f344a1104fd0cf4012b93443b0b", "html_url": "https://github.com/rust-lang/rust/commit/ac1454001cee3f344a1104fd0cf4012b93443b0b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac1454001cee3f344a1104fd0cf4012b93443b0b/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d2726726f8f3128e98191e4c6cb94bd76d0ddd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d2726726f8f3128e98191e4c6cb94bd76d0ddd4", "html_url": "https://github.com/rust-lang/rust/commit/1d2726726f8f3128e98191e4c6cb94bd76d0ddd4"}], "stats": {"total": 817, "additions": 782, "deletions": 35}, "files": [{"sha": "13ffdf04c46b2c42400e46fd8f88ca34b9d182dd", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -222,6 +222,15 @@ pub enum AngleBracketedArg {\n     Constraint(AssocTyConstraint),\n }\n \n+impl AngleBracketedArg {\n+    pub fn span(&self) -> Span {\n+        match self {\n+            AngleBracketedArg::Arg(arg) => arg.span(),\n+            AngleBracketedArg::Constraint(constraint) => constraint.span,\n+        }\n+    }\n+}\n+\n impl Into<Option<P<GenericArgs>>> for AngleBracketedArgs {\n     fn into(self) -> Option<P<GenericArgs>> {\n         Some(P(GenericArgs::AngleBracketed(self)))"}, {"sha": "2bba7e618c0503890393498a0d948a683e56c2cf", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -303,6 +303,13 @@ impl TokenKind {\n             _ => None,\n         }\n     }\n+\n+    pub fn should_end_const_arg(&self) -> bool {\n+        match self {\n+            Gt | Ge | BinOp(Shr) | BinOpEq(Shr) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n impl Token {"}, {"sha": "ef5034e218da47c800c4db661e895ec235a84ead", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -490,7 +490,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     let eagerly_eval = |x: &'tcx ty::Const<'tcx>| x.eval(tcx, relation.param_env()).val;\n \n     // FIXME(eddyb) doesn't look like everything below checks that `a.ty == b.ty`.\n-    // We could probably always assert it early, as `const` generic parameters\n+    // We could probably always assert it early, as const generic parameters\n     // are not allowed to depend on other generic parameters, i.e. are concrete.\n     // (although there could be normalization differences)\n "}, {"sha": "52cbba9d2bf7d1f075fe359928469837b4340834", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 143, "deletions": 4, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -1,13 +1,14 @@\n use super::ty::AllowPlus;\n-use super::{BlockMode, Parser, PathStyle, SemiColonMode, SeqSep, TokenExpectType, TokenType};\n+use super::TokenType;\n+use super::{BlockMode, Parser, PathStyle, Restrictions, SemiColonMode, SeqSep, TokenExpectType};\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Lit, LitKind, TokenKind};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{\n-    self as ast, AngleBracketedArgs, AttrVec, BinOpKind, BindingMode, Block, BlockCheckMode, Expr,\n-    ExprKind, Item, ItemKind, Mutability, Param, Pat, PatKind, Path, PathSegment, QSelf, Ty,\n-    TyKind,\n+    self as ast, AngleBracketedArg, AngleBracketedArgs, AnonConst, AttrVec, BinOpKind, BindingMode,\n+    Block, BlockCheckMode, Expr, ExprKind, GenericArg, Item, ItemKind, Mutability, Param, Pat,\n+    PatKind, Path, PathSegment, QSelf, Ty, TyKind,\n };\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n@@ -1774,4 +1775,142 @@ impl<'a> Parser<'a> {\n             }\n         }\n     }\n+\n+    /// Handle encountering a symbol in a generic argument list that is not a `,` or `>`. In this\n+    /// case, we emit an error and try to suggest enclosing a const argument in braces if it looks\n+    /// like the user has forgotten them.\n+    pub fn handle_ambiguous_unbraced_const_arg(\n+        &mut self,\n+        args: &mut Vec<AngleBracketedArg>,\n+    ) -> PResult<'a, bool> {\n+        // If we haven't encountered a closing `>`, then the argument is malformed.\n+        // It's likely that the user has written a const expression without enclosing it\n+        // in braces, so we try to recover here.\n+        let arg = args.pop().unwrap();\n+        // FIXME: for some reason using `unexpected` or `expected_one_of_not_found` has\n+        // adverse side-effects to subsequent errors and seems to advance the parser.\n+        // We are causing this error here exclusively in case that a `const` expression\n+        // could be recovered from the current parser state, even if followed by more\n+        // arguments after a comma.\n+        let mut err = self.struct_span_err(\n+            self.token.span,\n+            &format!(\"expected one of `,` or `>`, found {}\", super::token_descr(&self.token)),\n+        );\n+        err.span_label(self.token.span, \"expected one of `,` or `>`\");\n+        match self.recover_const_arg(arg.span(), err) {\n+            Ok(arg) => {\n+                args.push(AngleBracketedArg::Arg(arg));\n+                if self.eat(&token::Comma) {\n+                    return Ok(true); // Continue\n+                }\n+            }\n+            Err(mut err) => {\n+                args.push(arg);\n+                // We will emit a more generic error later.\n+                err.delay_as_bug();\n+            }\n+        }\n+        return Ok(false); // Don't continue.\n+    }\n+\n+    /// Handle a generic const argument that had not been enclosed in braces, and suggest enclosing\n+    /// it braces. In this situation, unlike in `handle_ambiguous_unbraced_const_arg`, this is\n+    /// almost certainly a const argument, so we always offer a suggestion.\n+    pub fn handle_unambiguous_unbraced_const_arg(&mut self) -> PResult<'a, P<Expr>> {\n+        let start = self.token.span;\n+        let expr = self.parse_expr_res(Restrictions::CONST_EXPR, None).map_err(|mut err| {\n+            err.span_label(\n+                start.shrink_to_lo(),\n+                \"while parsing a const generic argument starting here\",\n+            );\n+            err\n+        })?;\n+        if !self.expr_is_valid_const_arg(&expr) {\n+            self.struct_span_err(\n+                expr.span,\n+                \"expressions must be enclosed in braces to be used as const generic \\\n+                    arguments\",\n+            )\n+            .multipart_suggestion(\n+                \"enclose the `const` expression in braces\",\n+                vec![\n+                    (expr.span.shrink_to_lo(), \"{ \".to_string()),\n+                    (expr.span.shrink_to_hi(), \" }\".to_string()),\n+                ],\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+        }\n+        Ok(expr)\n+    }\n+\n+    /// Try to recover from possible generic const argument without `{` and `}`.\n+    ///\n+    /// When encountering code like `foo::< bar + 3 >` or `foo::< bar - baz >` we suggest\n+    /// `foo::<{ bar + 3 }>` and `foo::<{ bar - baz }>`, respectively. We only provide a suggestion\n+    /// if we think that that the resulting expression would be well formed.\n+    pub fn recover_const_arg(\n+        &mut self,\n+        start: Span,\n+        mut err: DiagnosticBuilder<'a>,\n+    ) -> PResult<'a, GenericArg> {\n+        let is_op = AssocOp::from_token(&self.token)\n+            .and_then(|op| {\n+                if let AssocOp::Greater\n+                | AssocOp::Less\n+                | AssocOp::ShiftRight\n+                | AssocOp::GreaterEqual\n+                // Don't recover from `foo::<bar = baz>`, because this could be an attempt to\n+                // assign a value to a defaulted generic parameter.\n+                | AssocOp::Assign\n+                | AssocOp::AssignOp(_) = op\n+                {\n+                    None\n+                } else {\n+                    Some(op)\n+                }\n+            })\n+            .is_some();\n+        // This will be true when a trait object type `Foo +` or a path which was a `const fn` with\n+        // type params has been parsed.\n+        let was_op =\n+            matches!(self.prev_token.kind, token::BinOp(token::Plus | token::Shr) | token::Gt);\n+        if !is_op && !was_op {\n+            // We perform these checks and early return to avoid taking a snapshot unnecessarily.\n+            return Err(err);\n+        }\n+        let snapshot = self.clone();\n+        if is_op {\n+            self.bump();\n+        }\n+        match self.parse_expr_res(Restrictions::CONST_EXPR, None) {\n+            Ok(expr) => {\n+                if token::Comma == self.token.kind || self.token.kind.should_end_const_arg() {\n+                    // Avoid the following output by checking that we consumed a full const arg:\n+                    // help: expressions must be enclosed in braces to be used as const generic\n+                    //       arguments\n+                    //    |\n+                    // LL |     let sr: Vec<{ (u32, _, _) = vec![] };\n+                    //    |                 ^                      ^\n+                    err.multipart_suggestion(\n+                        \"expressions must be enclosed in braces to be used as const generic \\\n+                         arguments\",\n+                        vec![\n+                            (start.shrink_to_lo(), \"{ \".to_string()),\n+                            (expr.span.shrink_to_hi(), \" }\".to_string()),\n+                        ],\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                    let value = self.mk_expr_err(start.to(expr.span));\n+                    err.emit();\n+                    return Ok(GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value }));\n+                }\n+            }\n+            Err(mut err) => {\n+                err.cancel();\n+            }\n+        }\n+        *self = snapshot;\n+        Err(err)\n+    }\n }"}, {"sha": "3bb0cfd81d70c7ab323f9ffbdd0c8ea70b2d9cca", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -359,6 +359,18 @@ impl<'a> Parser<'a> {\n     /// Also performs recovery for `and` / `or` which are mistaken for `&&` and `||` respectively.\n     fn check_assoc_op(&self) -> Option<Spanned<AssocOp>> {\n         let (op, span) = match (AssocOp::from_token(&self.token), self.token.ident()) {\n+            // When parsing const expressions, stop parsing when encountering `>`.\n+            (\n+                Some(\n+                    AssocOp::ShiftRight\n+                    | AssocOp::Greater\n+                    | AssocOp::GreaterEqual\n+                    | AssocOp::AssignOp(token::BinOpToken::Shr),\n+                ),\n+                _,\n+            ) if self.restrictions.contains(Restrictions::CONST_EXPR) => {\n+                return None;\n+            }\n             (Some(op), _) => (op, self.token.span),\n             (None, Some((Ident { name: sym::and, span }, false))) => {\n                 self.error_bad_logical_op(\"and\", \"&&\", \"conjunction\");\n@@ -1715,7 +1727,7 @@ impl<'a> Parser<'a> {\n         let lo = self.prev_token.span;\n         let pat = self.parse_top_pat(GateOr::No)?;\n         self.expect(&token::Eq)?;\n-        let expr = self.with_res(Restrictions::NO_STRUCT_LITERAL, |this| {\n+        let expr = self.with_res(self.restrictions | Restrictions::NO_STRUCT_LITERAL, |this| {\n             this.parse_assoc_expr_with(1 + prec_let_scrutinee_needs_par(), None.into())\n         })?;\n         let span = lo.to(expr.span);"}, {"sha": "ca7a627ef18742d1a7489da65adc2e4200fa7b17", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -36,6 +36,7 @@ bitflags::bitflags! {\n     struct Restrictions: u8 {\n         const STMT_EXPR         = 1 << 0;\n         const NO_STRUCT_LITERAL = 1 << 1;\n+        const CONST_EXPR        = 1 << 2;\n     }\n }\n "}, {"sha": "06760547eba0cf1eb1034d43f9f1818f39a8765e", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -397,6 +397,13 @@ impl<'a> Parser<'a> {\n         while let Some(arg) = self.parse_angle_arg()? {\n             args.push(arg);\n             if !self.eat(&token::Comma) {\n+                if !self.token.kind.should_end_const_arg() {\n+                    if self.handle_ambiguous_unbraced_const_arg(&mut args)? {\n+                        // We've managed to (partially) recover, so continue trying to parse\n+                        // arguments.\n+                        continue;\n+                    }\n+                }\n                 break;\n             }\n         }\n@@ -476,41 +483,50 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_ty(span, ast::TyKind::Err))\n     }\n \n+    /// We do not permit arbitrary expressions as const arguments. They must be one of:\n+    /// - An expression surrounded in `{}`.\n+    /// - A literal.\n+    /// - A numeric literal prefixed by `-`.\n+    pub(super) fn expr_is_valid_const_arg(&self, expr: &P<rustc_ast::Expr>) -> bool {\n+        match &expr.kind {\n+            ast::ExprKind::Block(_, _) | ast::ExprKind::Lit(_) => true,\n+            ast::ExprKind::Unary(ast::UnOp::Neg, expr) => match &expr.kind {\n+                ast::ExprKind::Lit(_) => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        }\n+    }\n+\n     /// Parse a generic argument in a path segment.\n     /// This does not include constraints, e.g., `Item = u8`, which is handled in `parse_angle_arg`.\n     fn parse_generic_arg(&mut self) -> PResult<'a, Option<GenericArg>> {\n+        let start = self.token.span;\n         let arg = if self.check_lifetime() && self.look_ahead(1, |t| !t.is_like_plus()) {\n             // Parse lifetime argument.\n             GenericArg::Lifetime(self.expect_lifetime())\n         } else if self.check_const_arg() {\n             // Parse const argument.\n-            let expr = if let token::OpenDelim(token::Brace) = self.token.kind {\n+            let value = if let token::OpenDelim(token::Brace) = self.token.kind {\n                 self.parse_block_expr(\n                     None,\n                     self.token.span,\n                     BlockCheckMode::Default,\n                     ast::AttrVec::new(),\n                 )?\n-            } else if self.token.is_ident() {\n-                // FIXME(const_generics): to distinguish between idents for types and consts,\n-                // we should introduce a GenericArg::Ident in the AST and distinguish when\n-                // lowering to the HIR. For now, idents for const args are not permitted.\n-                if self.token.is_bool_lit() {\n-                    self.parse_literal_maybe_minus()?\n-                } else {\n-                    let span = self.token.span;\n-                    let msg = \"identifiers may currently not be used for const generics\";\n-                    self.struct_span_err(span, msg).emit();\n-                    let block = self.mk_block_err(span);\n-                    self.mk_expr(span, ast::ExprKind::Block(block, None), ast::AttrVec::new())\n-                }\n             } else {\n-                self.parse_literal_maybe_minus()?\n+                self.handle_unambiguous_unbraced_const_arg()?\n             };\n-            GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value: expr })\n+            GenericArg::Const(AnonConst { id: ast::DUMMY_NODE_ID, value })\n         } else if self.check_type() {\n             // Parse type argument.\n-            GenericArg::Type(self.parse_ty()?)\n+            match self.parse_ty() {\n+                Ok(ty) => GenericArg::Type(ty),\n+                Err(err) => {\n+                    // Try to recover from possible `const` arg without braces.\n+                    return self.recover_const_arg(start, err).map(Some);\n+                }\n+            }\n         } else {\n             return Ok(None);\n         };"}, {"sha": "1c3ddd345a53333ab27b792d42fcbf34d75087d9", "filename": "src/test/ui/const-generics/closing-args-token.full.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fclosing-args-token.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fclosing-args-token.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fclosing-args-token.full.stderr?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -0,0 +1,52 @@\n+error: expressions must be enclosed in braces to be used as const generic arguments\n+  --> $DIR/closing-args-token.rs:11:9\n+   |\n+LL |     S::<5 + 2 >> 7>;\n+   |         ^^^^^\n+   |\n+help: enclose the `const` expression in braces\n+   |\n+LL |     S::<{ 5 + 2 } >> 7>;\n+   |         ^       ^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/closing-args-token.rs:11:16\n+   |\n+LL |     S::<5 + 2 >> 7>;\n+   |                ^  ^\n+   |\n+help: split the comparison into two\n+   |\n+LL |     S::<5 + 2 >> 7 && 7>;\n+   |                    ^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/closing-args-token.rs:17:20\n+   |\n+LL |     S::<{ 5 + 2 } >> 7>;\n+   |                    ^  ^\n+   |\n+help: split the comparison into two\n+   |\n+LL |     S::<{ 5 + 2 } >> 7 && 7>;\n+   |                        ^^^^\n+\n+error: expected expression, found `;`\n+  --> $DIR/closing-args-token.rs:22:16\n+   |\n+LL |     T::<0 >= 3>;\n+   |                ^ expected expression\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/closing-args-token.rs:28:12\n+   |\n+LL |     T::<x >>= 2 > 0>;\n+   |            ^^   ^\n+   |\n+help: split the comparison into two\n+   |\n+LL |     T::<x >>= 2 && 2 > 0>;\n+   |                 ^^^^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "1c3ddd345a53333ab27b792d42fcbf34d75087d9", "filename": "src/test/ui/const-generics/closing-args-token.min.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fclosing-args-token.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fclosing-args-token.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fclosing-args-token.min.stderr?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -0,0 +1,52 @@\n+error: expressions must be enclosed in braces to be used as const generic arguments\n+  --> $DIR/closing-args-token.rs:11:9\n+   |\n+LL |     S::<5 + 2 >> 7>;\n+   |         ^^^^^\n+   |\n+help: enclose the `const` expression in braces\n+   |\n+LL |     S::<{ 5 + 2 } >> 7>;\n+   |         ^       ^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/closing-args-token.rs:11:16\n+   |\n+LL |     S::<5 + 2 >> 7>;\n+   |                ^  ^\n+   |\n+help: split the comparison into two\n+   |\n+LL |     S::<5 + 2 >> 7 && 7>;\n+   |                    ^^^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/closing-args-token.rs:17:20\n+   |\n+LL |     S::<{ 5 + 2 } >> 7>;\n+   |                    ^  ^\n+   |\n+help: split the comparison into two\n+   |\n+LL |     S::<{ 5 + 2 } >> 7 && 7>;\n+   |                        ^^^^\n+\n+error: expected expression, found `;`\n+  --> $DIR/closing-args-token.rs:22:16\n+   |\n+LL |     T::<0 >= 3>;\n+   |                ^ expected expression\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/closing-args-token.rs:28:12\n+   |\n+LL |     T::<x >>= 2 > 0>;\n+   |            ^^   ^\n+   |\n+help: split the comparison into two\n+   |\n+LL |     T::<x >>= 2 && 2 > 0>;\n+   |                 ^^^^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "8699637c54e94ce0f332cfd9007235ed321c5a62", "filename": "src/test/ui/const-generics/closing-args-token.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fclosing-args-token.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fclosing-args-token.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fclosing-args-token.rs?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -0,0 +1,32 @@\n+// revisions: full min\n+\n+#![cfg_attr(full, feature(const_generics))]\n+#![cfg_attr(full, allow(incomplete_features))]\n+#![cfg_attr(min, feature(min_const_generics))]\n+\n+struct S<const X: u32>;\n+struct T<const X: bool>;\n+\n+fn bad_args_1() {\n+    S::<5 + 2 >> 7>;\n+    //~^ ERROR expressions must be enclosed in braces to be used as const generic arguments\n+    //~| ERROR comparison operators cannot be chained\n+}\n+\n+fn bad_args_2() {\n+    S::<{ 5 + 2 } >> 7>;\n+    //~^ ERROR comparison operators cannot be chained\n+}\n+\n+fn bad_args_3() {\n+    T::<0 >= 3>;\n+    //~^ ERROR expected expression, found `;`\n+}\n+\n+fn bad_args_4() {\n+    let mut x = 0;\n+    T::<x >>= 2 > 0>;\n+    //~^ ERROR comparison operators cannot be chained\n+}\n+\n+fn main() {}"}, {"sha": "0615a4c206d80745b38aac7653302939f394b08c", "filename": "src/test/ui/const-generics/const-expression-parameter.full.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.full.stderr?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -1,8 +1,13 @@\n-error: expected one of `,` or `>`, found `+`\n-  --> $DIR/const-expression-parameter.rs:16:22\n+error: expressions must be enclosed in braces to be used as const generic arguments\n+  --> $DIR/const-expression-parameter.rs:16:20\n    |\n LL |     i32_identity::<1 + 2>();\n-   |                      ^ expected one of `,` or `>`\n+   |                    ^^^^^\n+   |\n+help: enclose the `const` expression in braces\n+   |\n+LL |     i32_identity::<{ 1 + 2 }>();\n+   |                    ^       ^\n \n error: aborting due to previous error\n "}, {"sha": "0615a4c206d80745b38aac7653302939f394b08c", "filename": "src/test/ui/const-generics/const-expression-parameter.min.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.min.stderr?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -1,8 +1,13 @@\n-error: expected one of `,` or `>`, found `+`\n-  --> $DIR/const-expression-parameter.rs:16:22\n+error: expressions must be enclosed in braces to be used as const generic arguments\n+  --> $DIR/const-expression-parameter.rs:16:20\n    |\n LL |     i32_identity::<1 + 2>();\n-   |                      ^ expected one of `,` or `>`\n+   |                    ^^^^^\n+   |\n+help: enclose the `const` expression in braces\n+   |\n+LL |     i32_identity::<{ 1 + 2 }>();\n+   |                    ^       ^\n \n error: aborting due to previous error\n "}, {"sha": "3ef7c8b32e035afae302569b85e9bc9fcaeb8a86", "filename": "src/test/ui/const-generics/const-expression-parameter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-expression-parameter.rs?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -13,7 +13,7 @@ fn foo_a() {\n }\n \n fn foo_b() {\n-    i32_identity::<1 + 2>(); //~ ERROR expected one of `,` or `>`, found `+`\n+    i32_identity::<1 + 2>(); //~ ERROR expressions must be enclosed in braces\n }\n \n fn foo_c() {"}, {"sha": "b9afd2264307e479966815e9bcbcdfd2694b9eca", "filename": "src/test/ui/const-generics/min_const_generics/const-expression-suggest-missing-braces-without-turbofish.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces-without-turbofish.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces-without-turbofish.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces-without-turbofish.rs?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -0,0 +1,49 @@\n+#![feature(min_const_generics)]\n+\n+fn foo<const C: usize>() {}\n+\n+const BAR: usize = 42;\n+\n+fn a() {\n+    foo<BAR + 3>(); //~ ERROR comparison operators cannot be chained\n+}\n+fn b() {\n+    foo<BAR + BAR>(); //~ ERROR comparison operators cannot be chained\n+}\n+fn c() {\n+    foo<3 + 3>(); //~ ERROR comparison operators cannot be chained\n+}\n+fn d() {\n+    foo<BAR - 3>(); //~ ERROR comparison operators cannot be chained\n+}\n+fn e() {\n+    foo<BAR - BAR>(); //~ ERROR comparison operators cannot be chained\n+}\n+fn f() {\n+    foo<100 - BAR>(); //~ ERROR comparison operators cannot be chained\n+}\n+fn g() {\n+    foo<bar<i32>()>(); //~ ERROR comparison operators cannot be chained\n+    //~^ ERROR expected one of `;` or `}`, found `>`\n+}\n+fn h() {\n+    foo<bar::<i32>()>(); //~ ERROR comparison operators cannot be chained\n+}\n+fn i() {\n+    foo<bar::<i32>() + BAR>(); //~ ERROR comparison operators cannot be chained\n+}\n+fn j() {\n+    foo<bar::<i32>() - BAR>(); //~ ERROR comparison operators cannot be chained\n+}\n+fn k() {\n+    foo<BAR - bar::<i32>()>(); //~ ERROR comparison operators cannot be chained\n+}\n+fn l() {\n+    foo<BAR - bar::<i32>()>(); //~ ERROR comparison operators cannot be chained\n+}\n+\n+const fn bar<const C: usize>() -> usize {\n+    C\n+}\n+\n+fn main() {}"}, {"sha": "103a295fced51af7959f20dafb3a860a7f05a68c", "filename": "src/test/ui/const-generics/min_const_generics/const-expression-suggest-missing-braces-without-turbofish.stderr", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces-without-turbofish.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces-without-turbofish.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces-without-turbofish.stderr?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -0,0 +1,140 @@\n+error: comparison operators cannot be chained\n+  --> $DIR/const-expression-suggest-missing-braces-without-turbofish.rs:8:8\n+   |\n+LL |     foo<BAR + 3>();\n+   |        ^       ^\n+   |\n+help: use `::<...>` instead of `<...>` to specify type arguments\n+   |\n+LL |     foo::<BAR + 3>();\n+   |        ^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/const-expression-suggest-missing-braces-without-turbofish.rs:11:8\n+   |\n+LL |     foo<BAR + BAR>();\n+   |        ^         ^\n+   |\n+help: use `::<...>` instead of `<...>` to specify type arguments\n+   |\n+LL |     foo::<BAR + BAR>();\n+   |        ^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/const-expression-suggest-missing-braces-without-turbofish.rs:14:8\n+   |\n+LL |     foo<3 + 3>();\n+   |        ^     ^\n+   |\n+help: use `::<...>` instead of `<...>` to specify type arguments\n+   |\n+LL |     foo::<3 + 3>();\n+   |        ^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/const-expression-suggest-missing-braces-without-turbofish.rs:17:8\n+   |\n+LL |     foo<BAR - 3>();\n+   |        ^       ^\n+   |\n+help: use `::<...>` instead of `<...>` to specify type arguments\n+   |\n+LL |     foo::<BAR - 3>();\n+   |        ^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/const-expression-suggest-missing-braces-without-turbofish.rs:20:8\n+   |\n+LL |     foo<BAR - BAR>();\n+   |        ^         ^\n+   |\n+help: use `::<...>` instead of `<...>` to specify type arguments\n+   |\n+LL |     foo::<BAR - BAR>();\n+   |        ^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/const-expression-suggest-missing-braces-without-turbofish.rs:23:8\n+   |\n+LL |     foo<100 - BAR>();\n+   |        ^         ^\n+   |\n+help: use `::<...>` instead of `<...>` to specify type arguments\n+   |\n+LL |     foo::<100 - BAR>();\n+   |        ^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/const-expression-suggest-missing-braces-without-turbofish.rs:26:8\n+   |\n+LL |     foo<bar<i32>()>();\n+   |        ^   ^\n+   |\n+help: use `::<...>` instead of `<...>` to specify type arguments\n+   |\n+LL |     foo::<bar<i32>()>();\n+   |        ^^\n+\n+error: expected one of `;` or `}`, found `>`\n+  --> $DIR/const-expression-suggest-missing-braces-without-turbofish.rs:26:19\n+   |\n+LL |     foo<bar<i32>()>();\n+   |                   ^ expected one of `;` or `}`\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/const-expression-suggest-missing-braces-without-turbofish.rs:30:8\n+   |\n+LL |     foo<bar::<i32>()>();\n+   |        ^            ^\n+   |\n+help: use `::<...>` instead of `<...>` to specify type arguments\n+   |\n+LL |     foo::<bar::<i32>()>();\n+   |        ^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/const-expression-suggest-missing-braces-without-turbofish.rs:33:8\n+   |\n+LL |     foo<bar::<i32>() + BAR>();\n+   |        ^                  ^\n+   |\n+help: use `::<...>` instead of `<...>` to specify type arguments\n+   |\n+LL |     foo::<bar::<i32>() + BAR>();\n+   |        ^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/const-expression-suggest-missing-braces-without-turbofish.rs:36:8\n+   |\n+LL |     foo<bar::<i32>() - BAR>();\n+   |        ^                  ^\n+   |\n+help: use `::<...>` instead of `<...>` to specify type arguments\n+   |\n+LL |     foo::<bar::<i32>() - BAR>();\n+   |        ^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/const-expression-suggest-missing-braces-without-turbofish.rs:39:8\n+   |\n+LL |     foo<BAR - bar::<i32>()>();\n+   |        ^                  ^\n+   |\n+help: use `::<...>` instead of `<...>` to specify type arguments\n+   |\n+LL |     foo::<BAR - bar::<i32>()>();\n+   |        ^^\n+\n+error: comparison operators cannot be chained\n+  --> $DIR/const-expression-suggest-missing-braces-without-turbofish.rs:42:8\n+   |\n+LL |     foo<BAR - bar::<i32>()>();\n+   |        ^                  ^\n+   |\n+help: use `::<...>` instead of `<...>` to specify type arguments\n+   |\n+LL |     foo::<BAR - bar::<i32>()>();\n+   |        ^^\n+\n+error: aborting due to 13 previous errors\n+"}, {"sha": "aea3def5aeb2326f4a10742b3d6d62e6503c61bc", "filename": "src/test/ui/const-generics/min_const_generics/const-expression-suggest-missing-braces.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces.rs?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -0,0 +1,55 @@\n+#![feature(min_const_generics)]\n+\n+fn foo<const C: usize>() {}\n+\n+const BAR: usize = 42;\n+\n+fn a() {\n+    foo::<BAR + 3>(); //~ ERROR expected one of\n+}\n+fn b() {\n+    // FIXME(const_generics): these diagnostics are awful, because trait objects without `dyn` were\n+    // a terrible mistake.\n+    foo::<BAR + BAR>();\n+    //~^ ERROR expected trait, found constant `BAR`\n+    //~| ERROR expected trait, found constant `BAR`\n+    //~| ERROR wrong number of const arguments: expected 1, found 0\n+    //~| ERROR wrong number of type arguments: expected 0, found 1\n+    //~| WARN trait objects without an explicit `dyn` are deprecated\n+}\n+fn c() {\n+    foo::<3 + 3>(); //~ ERROR expressions must be enclosed in braces\n+}\n+fn d() {\n+    foo::<BAR - 3>(); //~ ERROR expected one of\n+}\n+fn e() {\n+    foo::<BAR - BAR>(); //~ ERROR expected one of\n+}\n+fn f() {\n+    foo::<100 - BAR>(); //~ ERROR expressions must be enclosed in braces\n+}\n+fn g() {\n+    foo::<bar<i32>()>(); //~ ERROR expected one of\n+}\n+fn h() {\n+    foo::<bar::<i32>()>(); //~ ERROR expected one of\n+}\n+fn i() {\n+    foo::<bar::<i32>() + BAR>(); //~ ERROR expected one of\n+}\n+fn j() {\n+    foo::<bar::<i32>() - BAR>(); //~ ERROR expected one of\n+}\n+fn k() {\n+    foo::<BAR - bar::<i32>()>(); //~ ERROR expected one of\n+}\n+fn l() {\n+    foo::<BAR - bar::<i32>()>(); //~ ERROR expected one of\n+}\n+\n+const fn bar<const C: usize>() -> usize {\n+    C\n+}\n+\n+fn main() {}"}, {"sha": "47e9dc034effff3ca675196c813a2c0325719601", "filename": "src/test/ui/const-generics/min_const_generics/const-expression-suggest-missing-braces.stderr", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fconst-expression-suggest-missing-braces.stderr?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -0,0 +1,157 @@\n+error: expected one of `,` or `>`, found `3`\n+  --> $DIR/const-expression-suggest-missing-braces.rs:8:17\n+   |\n+LL |     foo::<BAR + 3>();\n+   |                 ^ expected one of `,` or `>`\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     foo::<{ BAR + 3 }>();\n+   |           ^         ^\n+\n+error: expressions must be enclosed in braces to be used as const generic arguments\n+  --> $DIR/const-expression-suggest-missing-braces.rs:21:11\n+   |\n+LL |     foo::<3 + 3>();\n+   |           ^^^^^\n+   |\n+help: enclose the `const` expression in braces\n+   |\n+LL |     foo::<{ 3 + 3 }>();\n+   |           ^       ^\n+\n+error: expected one of `,` or `>`, found `-`\n+  --> $DIR/const-expression-suggest-missing-braces.rs:24:15\n+   |\n+LL |     foo::<BAR - 3>();\n+   |               ^ expected one of `,` or `>`\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     foo::<{ BAR - 3 }>();\n+   |           ^         ^\n+\n+error: expected one of `,` or `>`, found `-`\n+  --> $DIR/const-expression-suggest-missing-braces.rs:27:15\n+   |\n+LL |     foo::<BAR - BAR>();\n+   |               ^ expected one of `,` or `>`\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     foo::<{ BAR - BAR }>();\n+   |           ^           ^\n+\n+error: expressions must be enclosed in braces to be used as const generic arguments\n+  --> $DIR/const-expression-suggest-missing-braces.rs:30:11\n+   |\n+LL |     foo::<100 - BAR>();\n+   |           ^^^^^^^^^\n+   |\n+help: enclose the `const` expression in braces\n+   |\n+LL |     foo::<{ 100 - BAR }>();\n+   |           ^           ^\n+\n+error: expected one of `,` or `>`, found `(`\n+  --> $DIR/const-expression-suggest-missing-braces.rs:33:19\n+   |\n+LL |     foo::<bar<i32>()>();\n+   |                   ^ expected one of `,` or `>`\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     foo::<{ bar<i32>() }>();\n+   |           ^            ^\n+\n+error: expected one of `,` or `>`, found `(`\n+  --> $DIR/const-expression-suggest-missing-braces.rs:36:21\n+   |\n+LL |     foo::<bar::<i32>()>();\n+   |                     ^ expected one of `,` or `>`\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     foo::<{ bar::<i32>() }>();\n+   |           ^              ^\n+\n+error: expected one of `,` or `>`, found `(`\n+  --> $DIR/const-expression-suggest-missing-braces.rs:39:21\n+   |\n+LL |     foo::<bar::<i32>() + BAR>();\n+   |                     ^ expected one of `,` or `>`\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     foo::<{ bar::<i32>() + BAR }>();\n+   |           ^                    ^\n+\n+error: expected one of `,` or `>`, found `(`\n+  --> $DIR/const-expression-suggest-missing-braces.rs:42:21\n+   |\n+LL |     foo::<bar::<i32>() - BAR>();\n+   |                     ^ expected one of `,` or `>`\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     foo::<{ bar::<i32>() - BAR }>();\n+   |           ^                    ^\n+\n+error: expected one of `,` or `>`, found `-`\n+  --> $DIR/const-expression-suggest-missing-braces.rs:45:15\n+   |\n+LL |     foo::<BAR - bar::<i32>()>();\n+   |               ^ expected one of `,` or `>`\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     foo::<{ BAR - bar::<i32>() }>();\n+   |           ^                    ^\n+\n+error: expected one of `,` or `>`, found `-`\n+  --> $DIR/const-expression-suggest-missing-braces.rs:48:15\n+   |\n+LL |     foo::<BAR - bar::<i32>()>();\n+   |               ^ expected one of `,` or `>`\n+   |\n+help: expressions must be enclosed in braces to be used as const generic arguments\n+   |\n+LL |     foo::<{ BAR - bar::<i32>() }>();\n+   |           ^                    ^\n+\n+error[E0404]: expected trait, found constant `BAR`\n+  --> $DIR/const-expression-suggest-missing-braces.rs:13:11\n+   |\n+LL |     foo::<BAR + BAR>();\n+   |           ^^^ not a trait\n+\n+error[E0404]: expected trait, found constant `BAR`\n+  --> $DIR/const-expression-suggest-missing-braces.rs:13:17\n+   |\n+LL |     foo::<BAR + BAR>();\n+   |                 ^^^ not a trait\n+\n+warning: trait objects without an explicit `dyn` are deprecated\n+  --> $DIR/const-expression-suggest-missing-braces.rs:13:11\n+   |\n+LL |     foo::<BAR + BAR>();\n+   |           ^^^^^^^^^ help: use `dyn`: `dyn BAR + BAR`\n+   |\n+   = note: `#[warn(bare_trait_objects)]` on by default\n+\n+error[E0107]: wrong number of const arguments: expected 1, found 0\n+  --> $DIR/const-expression-suggest-missing-braces.rs:13:5\n+   |\n+LL |     foo::<BAR + BAR>();\n+   |     ^^^^^^^^^^^^^^^^ expected 1 const argument\n+\n+error[E0107]: wrong number of type arguments: expected 0, found 1\n+  --> $DIR/const-expression-suggest-missing-braces.rs:13:11\n+   |\n+LL |     foo::<BAR + BAR>();\n+   |           ^^^^^^^^^ unexpected type argument\n+\n+error: aborting due to 15 previous errors; 1 warning emitted\n+\n+Some errors have detailed explanations: E0107, E0404.\n+For more information about an error, try `rustc --explain E0107`."}, {"sha": "aeee27a151e821ecfa25cc4f4aecdd6ce6f134f3", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.rs?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -233,6 +233,8 @@ fn inside_const_generic_arguments() {\n     // admit non-IDENT expressions in const generic arguments.\n \n     if A::<\n-        true && let 1 = 1 //~ ERROR expected one of `,` or `>`, found `&&`\n+        true && let 1 = 1\n+        //~^ ERROR `let` expressions are not supported here\n+        //~| ERROR  expressions must be enclosed in braces\n     >::O == 5 {}\n }"}, {"sha": "11155038a91393954fc962dd54de80c8ed441f82", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac1454001cee3f344a1104fd0cf4012b93443b0b/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=ac1454001cee3f344a1104fd0cf4012b93443b0b", "patch": "@@ -1,8 +1,13 @@\n-error: expected one of `,` or `>`, found `&&`\n-  --> $DIR/disallowed-positions.rs:236:14\n+error: expressions must be enclosed in braces to be used as const generic arguments\n+  --> $DIR/disallowed-positions.rs:236:9\n    |\n LL |         true && let 1 = 1\n-   |              ^^ expected one of `,` or `>`\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+help: enclose the `const` expression in braces\n+   |\n+LL |         { true && let 1 = 1 }\n+   |         ^                   ^\n \n error: `let` expressions are not supported here\n   --> $DIR/disallowed-positions.rs:32:9\n@@ -499,6 +504,15 @@ LL |         true && let 1 = 1\n    = note: only supported directly in conditions of `if`- and `while`-expressions\n    = note: as well as when nested within `&&` and parenthesis in those conditions\n \n+error: `let` expressions are not supported here\n+  --> $DIR/disallowed-positions.rs:236:17\n+   |\n+LL |         true && let 1 = 1\n+   |                 ^^^^^^^^^\n+   |\n+   = note: only supported directly in conditions of `if`- and `while`-expressions\n+   = note: as well as when nested within `&&` and parenthesis in those conditions\n+\n warning: the feature `const_generics` is incomplete and may not be safe to use and/or cause compiler crashes\n   --> $DIR/disallowed-positions.rs:20:12\n    |\n@@ -961,7 +975,7 @@ LL |         let 0 = 0?;\n    = help: the trait `Try` is not implemented for `{integer}`\n    = note: required by `into_result`\n \n-error: aborting due to 103 previous errors; 2 warnings emitted\n+error: aborting due to 104 previous errors; 2 warnings emitted\n \n Some errors have detailed explanations: E0277, E0308, E0600, E0614.\n For more information about an error, try `rustc --explain E0277`."}]}