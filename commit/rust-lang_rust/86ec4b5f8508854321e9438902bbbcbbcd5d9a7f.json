{"sha": "86ec4b5f8508854321e9438902bbbcbbcd5d9a7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ZWM0YjVmODUwODg1NDMyMWU5NDM4OTAyYmJiY2JiY2Q1ZDlhN2Y=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-05T22:28:45Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-07T17:08:47Z"}, "message": "Move required_region_bounds to rustc::infer::opaque_types.", "tree": {"sha": "24eeaeb6140cf31a7904efc33af2aa8b7bc8a453", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24eeaeb6140cf31a7904efc33af2aa8b7bc8a453"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86ec4b5f8508854321e9438902bbbcbbcd5d9a7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86ec4b5f8508854321e9438902bbbcbbcd5d9a7f", "html_url": "https://github.com/rust-lang/rust/commit/86ec4b5f8508854321e9438902bbbcbbcd5d9a7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86ec4b5f8508854321e9438902bbbcbbcd5d9a7f/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24d09c7c1b454dae43adc39827311d741dcbf896", "url": "https://api.github.com/repos/rust-lang/rust/commits/24d09c7c1b454dae43adc39827311d741dcbf896", "html_url": "https://github.com/rust-lang/rust/commit/24d09c7c1b454dae43adc39827311d741dcbf896"}], "stats": {"total": 138, "additions": 70, "deletions": 68}, "files": [{"sha": "a22ed9409613267edfd4fb5ecd0876aabf11a6ba", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/86ec4b5f8508854321e9438902bbbcbbcd5d9a7f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ec4b5f8508854321e9438902bbbcbbcd5d9a7f/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=86ec4b5f8508854321e9438902bbbcbbcd5d9a7f", "patch": "@@ -350,7 +350,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             debug!(\"constrain_opaque_type: bounds={:#?}\", bounds);\n             let opaque_type = tcx.mk_opaque(def_id, opaque_defn.substs);\n \n-            let required_region_bounds = tcx.required_region_bounds(opaque_type, bounds.predicates);\n+            let required_region_bounds =\n+                required_region_bounds(tcx, opaque_type, bounds.predicates);\n             debug_assert!(!required_region_bounds.is_empty());\n \n             for required_region in required_region_bounds {\n@@ -1133,7 +1134,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n \n         debug!(\"instantiate_opaque_types: bounds={:?}\", bounds);\n \n-        let required_region_bounds = tcx.required_region_bounds(ty, bounds.predicates.clone());\n+        let required_region_bounds = required_region_bounds(tcx, ty, bounds.predicates.clone());\n         debug!(\"instantiate_opaque_types: required_region_bounds={:?}\", required_region_bounds);\n \n         // Make sure that we are in fact defining the *entire* type\n@@ -1228,3 +1229,67 @@ pub fn may_define_opaque_type(tcx: TyCtxt<'_>, def_id: DefId, opaque_hir_id: hir\n     );\n     res\n }\n+\n+/// Given a set of predicates that apply to an object type, returns\n+/// the region bounds that the (erased) `Self` type must\n+/// outlive. Precisely *because* the `Self` type is erased, the\n+/// parameter `erased_self_ty` must be supplied to indicate what type\n+/// has been used to represent `Self` in the predicates\n+/// themselves. This should really be a unique type; `FreshTy(0)` is a\n+/// popular choice.\n+///\n+/// N.B., in some cases, particularly around higher-ranked bounds,\n+/// this function returns a kind of conservative approximation.\n+/// That is, all regions returned by this function are definitely\n+/// required, but there may be other region bounds that are not\n+/// returned, as well as requirements like `for<'a> T: 'a`.\n+///\n+/// Requires that trait definitions have been processed so that we can\n+/// elaborate predicates and walk supertraits.\n+//\n+// FIXME: callers may only have a `&[Predicate]`, not a `Vec`, so that's\n+// what this code should accept.\n+crate fn required_region_bounds(\n+    tcx: TyCtxt<'tcx>,\n+    erased_self_ty: Ty<'tcx>,\n+    predicates: Vec<ty::Predicate<'tcx>>,\n+) -> Vec<ty::Region<'tcx>> {\n+    debug!(\n+        \"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n+        erased_self_ty, predicates\n+    );\n+\n+    assert!(!erased_self_ty.has_escaping_bound_vars());\n+\n+    traits::elaborate_predicates(tcx, predicates)\n+        .filter_map(|predicate| {\n+            match predicate {\n+                ty::Predicate::Projection(..)\n+                | ty::Predicate::Trait(..)\n+                | ty::Predicate::Subtype(..)\n+                | ty::Predicate::WellFormed(..)\n+                | ty::Predicate::ObjectSafe(..)\n+                | ty::Predicate::ClosureKind(..)\n+                | ty::Predicate::RegionOutlives(..)\n+                | ty::Predicate::ConstEvaluatable(..) => None,\n+                ty::Predicate::TypeOutlives(predicate) => {\n+                    // Search for a bound of the form `erased_self_ty\n+                    // : 'a`, but be wary of something like `for<'a>\n+                    // erased_self_ty : 'a` (we interpret a\n+                    // higher-ranked bound like that as 'static,\n+                    // though at present the code in `fulfill.rs`\n+                    // considers such bounds to be unsatisfiable, so\n+                    // it's kind of a moot point since you could never\n+                    // construct such an object, but this seems\n+                    // correct even if that code changes).\n+                    let ty::OutlivesPredicate(ref t, ref r) = predicate.skip_binder();\n+                    if t == &erased_self_ty && !r.has_escaping_bound_vars() {\n+                        Some(*r)\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }\n+        })\n+        .collect()\n+}"}, {"sha": "551f8fde12b18cf4030e7257d6fe80cbbe0f9149", "filename": "src/librustc/traits/wf.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/86ec4b5f8508854321e9438902bbbcbbcd5d9a7f/src%2Flibrustc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ec4b5f8508854321e9438902bbbcbbcd5d9a7f/src%2Flibrustc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fwf.rs?ref=86ec4b5f8508854321e9438902bbbcbbcd5d9a7f", "patch": "@@ -1,3 +1,4 @@\n+use crate::infer::opaque_types::required_region_bounds;\n use crate::infer::InferCtxt;\n use crate::middle::lang_items;\n use crate::traits::{self, AssocTypeBoundData};\n@@ -668,7 +669,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n /// from the declarations of `SomeTrait`, `Send`, and friends -- if\n /// they declare `trait SomeTrait : 'static`, for example, then\n /// `'static` would appear in the list. The hard work is done by\n-/// `ty::required_region_bounds`, see that for more information.\n+/// `infer::required_region_bounds`, see that for more information.\n pub fn object_region_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     existential_predicates: ty::Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>,\n@@ -689,7 +690,7 @@ pub fn object_region_bounds<'tcx>(\n         })\n         .collect();\n \n-    tcx.required_region_bounds(open_ty, predicates)\n+    required_region_bounds(tcx, open_ty, predicates)\n }\n \n /// Find the span of a generic bound affecting an associated type."}, {"sha": "ee99176dc47f54d89fcb086436e465eb33ad695f", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/86ec4b5f8508854321e9438902bbbcbbcd5d9a7f/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86ec4b5f8508854321e9438902bbbcbbcd5d9a7f/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=86ec4b5f8508854321e9438902bbbcbbcd5d9a7f", "patch": "@@ -393,70 +393,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         (a, b)\n     }\n \n-    /// Given a set of predicates that apply to an object type, returns\n-    /// the region bounds that the (erased) `Self` type must\n-    /// outlive. Precisely *because* the `Self` type is erased, the\n-    /// parameter `erased_self_ty` must be supplied to indicate what type\n-    /// has been used to represent `Self` in the predicates\n-    /// themselves. This should really be a unique type; `FreshTy(0)` is a\n-    /// popular choice.\n-    ///\n-    /// N.B., in some cases, particularly around higher-ranked bounds,\n-    /// this function returns a kind of conservative approximation.\n-    /// That is, all regions returned by this function are definitely\n-    /// required, but there may be other region bounds that are not\n-    /// returned, as well as requirements like `for<'a> T: 'a`.\n-    ///\n-    /// Requires that trait definitions have been processed so that we can\n-    /// elaborate predicates and walk supertraits.\n-    //\n-    // FIXME: callers may only have a `&[Predicate]`, not a `Vec`, so that's\n-    // what this code should accept.\n-    pub fn required_region_bounds(\n-        self,\n-        erased_self_ty: Ty<'tcx>,\n-        predicates: Vec<ty::Predicate<'tcx>>,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        debug!(\n-            \"required_region_bounds(erased_self_ty={:?}, predicates={:?})\",\n-            erased_self_ty, predicates\n-        );\n-\n-        assert!(!erased_self_ty.has_escaping_bound_vars());\n-\n-        traits::elaborate_predicates(self, predicates)\n-            .filter_map(|predicate| {\n-                match predicate {\n-                    ty::Predicate::Projection(..)\n-                    | ty::Predicate::Trait(..)\n-                    | ty::Predicate::Subtype(..)\n-                    | ty::Predicate::WellFormed(..)\n-                    | ty::Predicate::ObjectSafe(..)\n-                    | ty::Predicate::ClosureKind(..)\n-                    | ty::Predicate::RegionOutlives(..)\n-                    | ty::Predicate::ConstEvaluatable(..) => None,\n-                    ty::Predicate::TypeOutlives(predicate) => {\n-                        // Search for a bound of the form `erased_self_ty\n-                        // : 'a`, but be wary of something like `for<'a>\n-                        // erased_self_ty : 'a` (we interpret a\n-                        // higher-ranked bound like that as 'static,\n-                        // though at present the code in `fulfill.rs`\n-                        // considers such bounds to be unsatisfiable, so\n-                        // it's kind of a moot point since you could never\n-                        // construct such an object, but this seems\n-                        // correct even if that code changes).\n-                        let ty::OutlivesPredicate(ref t, ref r) = predicate.skip_binder();\n-                        if t == &erased_self_ty && !r.has_escaping_bound_vars() {\n-                            Some(*r)\n-                        } else {\n-                            None\n-                        }\n-                    }\n-                }\n-            })\n-            .collect()\n-    }\n-\n     /// Calculate the destructor of a given type.\n     pub fn calculate_dtor(\n         self,"}]}