{"sha": "4c090fe310e32300bd6c6a0610f3f23366ea1445", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMDkwZmUzMTBlMzIzMDBiZDZjNmEwNjEwZjNmMjMzNjZlYTE0NDU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-14T15:00:52Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-25T09:49:43Z"}, "message": "bring back MemoryExtra", "tree": {"sha": "78dc95a77e2a18faee155751a62901e4956c4211", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78dc95a77e2a18faee155751a62901e4956c4211"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c090fe310e32300bd6c6a0610f3f23366ea1445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c090fe310e32300bd6c6a0610f3f23366ea1445", "html_url": "https://github.com/rust-lang/rust/commit/4c090fe310e32300bd6c6a0610f3f23366ea1445", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c090fe310e32300bd6c6a0610f3f23366ea1445/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37961dbd2d84a29be49007a5770b96e296f5f349", "url": "https://api.github.com/repos/rust-lang/rust/commits/37961dbd2d84a29be49007a5770b96e296f5f349", "html_url": "https://github.com/rust-lang/rust/commit/37961dbd2d84a29be49007a5770b96e296f5f349"}], "stats": {"total": 286, "additions": 179, "deletions": 107}, "files": [{"sha": "b1e92ef4b51182d13048d0ce58dc035a6ba92726", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 151, "deletions": 99, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/4c090fe310e32300bd6c6a0610f3f23366ea1445/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c090fe310e32300bd6c6a0610f3f23366ea1445/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=4c090fe310e32300bd6c6a0610f3f23366ea1445", "patch": "@@ -53,6 +53,94 @@ pub struct Allocation<Tag=(),Extra=()> {\n     pub extra: Extra,\n }\n \n+\n+pub trait AllocationExtra<Tag, MemoryExtra>: ::std::fmt::Debug + Clone {\n+    /// Hook to initialize the extra data when an allocation gets crated.\n+    fn memory_allocated(\n+        _size: Size,\n+        _memory_extra: &MemoryExtra\n+    ) -> EvalResult<'tcx, Self>;\n+\n+    /// Hook for performing extra checks on a memory read access.\n+    ///\n+    /// Takes read-only access to the allocation so we can keep all the memory read\n+    /// operations take `&self`.  Use a `RefCell` in `AllocExtra` if you\n+    /// need to mutate.\n+    #[inline(always)]\n+    fn memory_read(\n+        _alloc: &Allocation<Tag, Self>,\n+        _ptr: Pointer<Tag>,\n+        _size: Size,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    /// Hook for performing extra checks on a memory write access.\n+    #[inline(always)]\n+    fn memory_written(\n+        _alloc: &mut Allocation<Tag, Self>,\n+        _ptr: Pointer<Tag>,\n+        _size: Size,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+\n+    /// Hook for performing extra checks on a memory deallocation.\n+    /// `size` will be the size of the allocation.\n+    #[inline(always)]\n+    fn memory_deallocated(\n+        _alloc: &mut Allocation<Tag, Self>,\n+        _ptr: Pointer<Tag>,\n+        _size: Size,\n+    ) -> EvalResult<'tcx> {\n+        Ok(())\n+    }\n+}\n+\n+impl AllocationExtra<(), ()> for () {\n+    #[inline(always)]\n+    fn memory_allocated(\n+        _size: Size,\n+        _memory_extra: &()\n+    ) -> EvalResult<'tcx, Self> {\n+        Ok(())\n+    }\n+}\n+\n+impl<Tag, Extra> Allocation<Tag, Extra> {\n+    /// Creates a read-only allocation initialized by the given bytes\n+    pub fn from_bytes(slice: &[u8], align: Align, extra: Extra) -> Self {\n+        let mut undef_mask = UndefMask::new(Size::ZERO);\n+        undef_mask.grow(Size::from_bytes(slice.len() as u64), true);\n+        Self {\n+            bytes: slice.to_owned(),\n+            relocations: Relocations::new(),\n+            undef_mask,\n+            align,\n+            mutability: Mutability::Immutable,\n+            extra,\n+        }\n+    }\n+\n+    pub fn from_byte_aligned_bytes(slice: &[u8], extra: Extra) -> Self {\n+        Allocation::from_bytes(slice, Align::from_bytes(1).unwrap(), extra)\n+    }\n+\n+    pub fn undef(size: Size, align: Align, extra: Extra) -> Self {\n+        assert_eq!(size.bytes() as usize as u64, size.bytes());\n+        Allocation {\n+            bytes: vec![0; size.bytes() as usize],\n+            relocations: Relocations::new(),\n+            undef_mask: UndefMask::new(size),\n+            align,\n+            mutability: Mutability::Mutable,\n+            extra,\n+        }\n+    }\n+}\n+\n+impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n+\n /// Alignment and bounds checks\n impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n@@ -81,21 +169,24 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n }\n \n /// Byte accessors\n-impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n+impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// The last argument controls whether we error out when there are undefined\n     /// or pointer bytes.  You should never call this, call `get_bytes` or\n     /// `get_bytes_with_undef_and_ptr` instead,\n     ///\n     /// This function also guarantees that the resulting pointer will remain stable\n     /// even when new allocations are pushed to the `HashMap`. `copy_repeatedly` relies\n     /// on that.\n-    fn get_bytes_internal(\n+    fn get_bytes_internal<MemoryExtra>(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n         check_defined_and_ptr: bool,\n-    ) -> EvalResult<'tcx, &[u8]> {\n+    ) -> EvalResult<'tcx, &[u8]>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         self.check_bounds(cx, ptr, size)?;\n \n         if check_defined_and_ptr {\n@@ -115,35 +206,44 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n \n     #[inline]\n-    pub fn get_bytes(\n+    pub fn get_bytes<MemoryExtra>(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx, &[u8]> {\n+    ) -> EvalResult<'tcx, &[u8]>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         self.get_bytes_internal(cx, ptr, size, true)\n     }\n \n     /// It is the caller's responsibility to handle undefined and pointer bytes.\n     /// However, this still checks that there are no relocations on the *edges*.\n     #[inline]\n-    pub fn get_bytes_with_undef_and_ptr(\n+    pub fn get_bytes_with_undef_and_ptr<MemoryExtra>(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx, &[u8]> {\n+    ) -> EvalResult<'tcx, &[u8]>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         self.get_bytes_internal(cx, ptr, size, false)\n     }\n \n     /// Just calling this already marks everything as defined and removes relocations,\n     /// so be sure to actually put data there!\n-    pub fn get_bytes_mut(\n+    pub fn get_bytes_mut<MemoryExtra>(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n-    ) -> EvalResult<'tcx, &mut [u8]> {\n+    ) -> EvalResult<'tcx, &mut [u8]>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         assert_ne!(size.bytes(), 0, \"0-sized accesses should never even get a `Pointer`\");\n         self.check_bounds(cx, ptr, size)?;\n \n@@ -160,14 +260,17 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n }\n \n /// Reading and writing\n-impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n+impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// Reads bytes until a `0` is encountered. Will error if the end of the allocation is reached\n     /// before a `0` is found.\n-    pub fn read_c_str(\n+    pub fn read_c_str<MemoryExtra>(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-    ) -> EvalResult<'tcx, &[u8]> {\n+    ) -> EvalResult<'tcx, &[u8]>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         assert_eq!(ptr.offset.bytes() as usize as u64, ptr.offset.bytes());\n         let offset = ptr.offset.bytes() as usize;\n         match self.bytes[offset..].iter().position(|&c| c == 0) {\n@@ -184,13 +287,16 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Validates that `ptr.offset` and `ptr.offset + size` do not point to the middle of a\n     /// relocation. If `allow_ptr_and_undef` is `false`, also enforces that the memory in the\n     /// given range contains neither relocations nor undef bytes.\n-    pub fn check_bytes(\n+    pub fn check_bytes<MemoryExtra>(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size,\n         allow_ptr_and_undef: bool,\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         // Check bounds and relocations on the edges\n         self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n         // Check undef and ptr\n@@ -204,25 +310,31 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Writes `src` to the memory starting at `ptr.offset`.\n     ///\n     /// Will do bounds checks on the allocation.\n-    pub fn write_bytes(\n+    pub fn write_bytes<MemoryExtra>(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         src: &[u8],\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         let bytes = self.get_bytes_mut(cx, ptr, Size::from_bytes(src.len() as u64))?;\n         bytes.clone_from_slice(src);\n         Ok(())\n     }\n \n     /// Sets `count` bytes starting at `ptr.offset` with `val`. Basically `memset`.\n-    pub fn write_repeat(\n+    pub fn write_repeat<MemoryExtra>(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         val: u8,\n         count: Size\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         let bytes = self.get_bytes_mut(cx, ptr, count)?;\n         for b in bytes {\n             *b = val;\n@@ -238,12 +350,15 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///   being valid for ZSTs\n     ///\n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn read_scalar(\n+    pub fn read_scalar<MemoryExtra>(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         size: Size\n-    ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>> {\n+    ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         // get_bytes_unchecked tests relocation edges\n         let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n         // Undef check happens *after* we established that the alignment is correct.\n@@ -273,11 +388,14 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n \n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn read_ptr_sized(\n+    pub fn read_ptr_sized<MemoryExtra>(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n-    ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>> {\n+    ) -> EvalResult<'tcx, ScalarMaybeUndef<Tag>>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         self.read_scalar(cx, ptr, cx.data_layout().pointer_size)\n     }\n \n@@ -289,13 +407,16 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     ///   being valid for ZSTs\n     ///\n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn write_scalar(\n+    pub fn write_scalar<MemoryExtra>(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         val: ScalarMaybeUndef<Tag>,\n         type_size: Size,\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         let val = match val {\n             ScalarMaybeUndef::Scalar(scalar) => scalar,\n             ScalarMaybeUndef::Undef => return self.mark_definedness(ptr, type_size, false),\n@@ -336,12 +457,15 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n \n     /// Note: This function does not do *any* alignment checks, you need to do these before calling\n-    pub fn write_ptr_sized(\n+    pub fn write_ptr_sized<MemoryExtra>(\n         &mut self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n         val: ScalarMaybeUndef<Tag>\n-    ) -> EvalResult<'tcx> {\n+    ) -> EvalResult<'tcx>\n+        // FIXME: Working around https://github.com/rust-lang/rust/issues/56209\n+        where Extra: AllocationExtra<Tag, MemoryExtra>\n+    {\n         let ptr_size = cx.data_layout().pointer_size;\n         self.write_scalar(cx, ptr.into(), val, ptr_size)\n     }\n@@ -465,79 +589,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     }\n }\n \n-pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Default + Clone {\n-    /// Hook for performing extra checks on a memory read access.\n-    ///\n-    /// Takes read-only access to the allocation so we can keep all the memory read\n-    /// operations take `&self`.  Use a `RefCell` in `AllocExtra` if you\n-    /// need to mutate.\n-    #[inline]\n-    fn memory_read(\n-        _alloc: &Allocation<Tag, Self>,\n-        _ptr: Pointer<Tag>,\n-        _size: Size,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    /// Hook for performing extra checks on a memory write access.\n-    #[inline]\n-    fn memory_written(\n-        _alloc: &mut Allocation<Tag, Self>,\n-        _ptr: Pointer<Tag>,\n-        _size: Size,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-\n-    /// Hook for performing extra checks on a memory deallocation.\n-    /// `size` will be the size of the allocation.\n-    #[inline]\n-    fn memory_deallocated(\n-        _alloc: &mut Allocation<Tag, Self>,\n-        _ptr: Pointer<Tag>,\n-        _size: Size,\n-    ) -> EvalResult<'tcx> {\n-        Ok(())\n-    }\n-}\n-\n-impl AllocationExtra<()> for () {}\n-\n-impl<Tag, Extra: Default> Allocation<Tag, Extra> {\n-    /// Creates a read-only allocation initialized by the given bytes\n-    pub fn from_bytes(slice: &[u8], align: Align) -> Self {\n-        let mut undef_mask = UndefMask::new(Size::ZERO);\n-        undef_mask.grow(Size::from_bytes(slice.len() as u64), true);\n-        Self {\n-            bytes: slice.to_owned(),\n-            relocations: Relocations::new(),\n-            undef_mask,\n-            align,\n-            mutability: Mutability::Immutable,\n-            extra: Extra::default(),\n-        }\n-    }\n-\n-    pub fn from_byte_aligned_bytes(slice: &[u8]) -> Self {\n-        Allocation::from_bytes(slice, Align::from_bytes(1).unwrap())\n-    }\n-\n-    pub fn undef(size: Size, align: Align) -> Self {\n-        assert_eq!(size.bytes() as usize as u64, size.bytes());\n-        Allocation {\n-            bytes: vec![0; size.bytes() as usize],\n-            relocations: Relocations::new(),\n-            undef_mask: UndefMask::new(size),\n-            align,\n-            mutability: Mutability::Mutable,\n-            extra: Extra::default(),\n-        }\n-    }\n-}\n-\n-impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n-\n+/// Relocations\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct Relocations<Tag=(), Id=AllocId>(SortedMap<Size, (Tag, Id)>);\n "}, {"sha": "25ef6ddc005e34cc8429ad77dc09b0c1b74e8c4a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c090fe310e32300bd6c6a0610f3f23366ea1445/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c090fe310e32300bd6c6a0610f3f23366ea1445/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=4c090fe310e32300bd6c6a0610f3f23366ea1445", "patch": "@@ -1055,7 +1055,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Allocates a byte or string literal for `mir::interpret`, read-only\n     pub fn allocate_bytes(self, bytes: &[u8]) -> interpret::AllocId {\n         // create an allocation that just contains these bytes\n-        let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);\n+        let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes, ());\n         let alloc = self.intern_const_alloc(alloc);\n         self.alloc_map.lock().allocate(alloc)\n     }"}, {"sha": "73c0f8fff7a08ddcc3703c2c1559fe05b3fca7f3", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c090fe310e32300bd6c6a0610f3f23366ea1445/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c090fe310e32300bd6c6a0610f3f23366ea1445/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=4c090fe310e32300bd6c6a0610f3f23366ea1445", "patch": "@@ -353,6 +353,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     for CompileTimeInterpreter<'a, 'mir, 'tcx>\n {\n     type MemoryKinds = !;\n+    type MemoryExtra = ();\n     type AllocExtra = ();\n     type PointerTag = ();\n "}, {"sha": "481c46cb510c325260de64691c983083bd2c9b51", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c090fe310e32300bd6c6a0610f3f23366ea1445/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c090fe310e32300bd6c6a0610f3f23366ea1445/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=4c090fe310e32300bd6c6a0610f3f23366ea1445", "patch": "@@ -77,8 +77,13 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// The `default()` is used for pointers to consts, statics, vtables and functions.\n     type PointerTag: ::std::fmt::Debug + Default + Copy + Eq + Hash + 'static;\n \n+    /// Extra data stored in memory.  A reference to this is available when `AllocExtra`\n+    /// gets initialized, so you can e.g. have an `Rc` here if there is global state you\n+    /// need access to in the `AllocExtra` hooks.\n+    type MemoryExtra: Default;\n+\n     /// Extra data stored in every allocation.\n-    type AllocExtra: AllocationExtra<Self::PointerTag>;\n+    type AllocExtra: AllocationExtra<Self::PointerTag, Self::MemoryExtra>;\n \n     /// Memory's allocation map\n     type MemoryMap:"}, {"sha": "99bf93c8a9b212f862736c43174bee6494ca7dcb", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4c090fe310e32300bd6c6a0610f3f23366ea1445/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c090fe310e32300bd6c6a0610f3f23366ea1445/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=4c090fe310e32300bd6c6a0610f3f23366ea1445", "patch": "@@ -73,6 +73,9 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     /// that do not exist any more.\n     dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n \n+    /// Extra data added by the machine.\n+    pub extra: M::MemoryExtra,\n+\n     /// Lets us implement `HasDataLayout`, which is awfully convenient.\n     pub(super) tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n }\n@@ -88,13 +91,19 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n \n // FIXME: Really we shouldn't clone memory, ever. Snapshot machinery should instead\n // carefully copy only the reachable parts.\n-impl<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>>\n-    Clone for Memory<'a, 'mir, 'tcx, M>\n+impl<'a, 'mir, 'tcx, M>\n+    Clone\n+for\n+    Memory<'a, 'mir, 'tcx, M>\n+where\n+    M: Machine<'a, 'mir, 'tcx, PointerTag=(), AllocExtra=(), MemoryExtra=()>,\n+    M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n {\n     fn clone(&self) -> Self {\n         Memory {\n             alloc_map: self.alloc_map.clone(),\n             dead_alloc_map: self.dead_alloc_map.clone(),\n+            extra: (),\n             tcx: self.tcx,\n         }\n     }\n@@ -103,8 +112,9 @@ impl<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>>\n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>) -> Self {\n         Memory {\n-            alloc_map: Default::default(),\n+            alloc_map: M::MemoryMap::default(),\n             dead_alloc_map: FxHashMap::default(),\n+            extra: M::MemoryExtra::default(),\n             tcx,\n         }\n     }\n@@ -133,7 +143,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         align: Align,\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> EvalResult<'tcx, Pointer> {\n-        Ok(Pointer::from(self.allocate_with(Allocation::undef(size, align), kind)?))\n+        let extra = AllocationExtra::memory_allocated(size, &self.extra)?;\n+        Ok(Pointer::from(self.allocate_with(Allocation::undef(size, align, extra), kind)?))\n     }\n \n     pub fn reallocate(\n@@ -601,7 +612,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n /// Interning (for CTFE)\n impl<'a, 'mir, 'tcx, M> Memory<'a, 'mir, 'tcx, M>\n where\n-    M: Machine<'a, 'mir, 'tcx, PointerTag=(), AllocExtra=()>,\n+    M: Machine<'a, 'mir, 'tcx, PointerTag=(), AllocExtra=(), MemoryExtra=()>,\n+    // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n {\n     /// mark an allocation as static and initialized, either mutable or not"}, {"sha": "1b47530eaec65437065339102c8f736b4fdbc2ef", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c090fe310e32300bd6c6a0610f3f23366ea1445/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c090fe310e32300bd6c6a0610f3f23366ea1445/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=4c090fe310e32300bd6c6a0610f3f23366ea1445", "patch": "@@ -295,10 +295,12 @@ impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n // separating the pointer tag for `impl Trait`, see https://github.com/rust-lang/rust/issues/54385\n impl<'a, 'mir, 'tcx, Tag, M> EvalContext<'a, 'mir, 'tcx, M>\n where\n+    // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n     Tag: ::std::fmt::Debug+Default+Copy+Eq+Hash+'static,\n     M: Machine<'a, 'mir, 'tcx, PointerTag=Tag>,\n+    // FIXME: Working around https://github.com/rust-lang/rust/issues/24159\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation<Tag, M::AllocExtra>)>,\n-    M::AllocExtra: AllocationExtra<Tag>,\n+    M::AllocExtra: AllocationExtra<Tag, M::MemoryExtra>,\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`."}]}