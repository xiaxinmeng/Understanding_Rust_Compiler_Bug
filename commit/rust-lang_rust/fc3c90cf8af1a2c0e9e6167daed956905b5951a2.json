{"sha": "fc3c90cf8af1a2c0e9e6167daed956905b5951a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjM2M5MGNmOGFmMWEyYzBlOWU2MTY3ZGFlZDk1NjkwNWI1OTUxYTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-15T09:10:42Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-21T09:40:59Z"}, "message": "report an error if we see an unexpected lifetime in impl Trait\n\nBut leave closure substs alone.", "tree": {"sha": "2793b97f1e7ee10f9a0a08461c4d652a4a63d749", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2793b97f1e7ee10f9a0a08461c4d652a4a63d749"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc3c90cf8af1a2c0e9e6167daed956905b5951a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc3c90cf8af1a2c0e9e6167daed956905b5951a2", "html_url": "https://github.com/rust-lang/rust/commit/fc3c90cf8af1a2c0e9e6167daed956905b5951a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc3c90cf8af1a2c0e9e6167daed956905b5951a2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9cbfaa29687395452208a823502cc906a493ae2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9cbfaa29687395452208a823502cc906a493ae2", "html_url": "https://github.com/rust-lang/rust/commit/a9cbfaa29687395452208a823502cc906a493ae2"}], "stats": {"total": 325, "additions": 291, "deletions": 34}, "files": [{"sha": "fad1803259286e8dfb5ebd6b453da13e03b57e74", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fc3c90cf8af1a2c0e9e6167daed956905b5951a2/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc3c90cf8af1a2c0e9e6167daed956905b5951a2/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=fc3c90cf8af1a2c0e9e6167daed956905b5951a2", "patch": "@@ -2074,6 +2074,54 @@ a (non-transparent) struct containing a single float, while `Grams` is a\n transparent wrapper around a float. This can make a difference for the ABI.\n \"##,\n \n+E0909: r##\"\n+The `impl Trait` return type captures lifetime parameters that do not\n+appear within the `impl Trait` itself.\n+\n+Erroneous code example:\n+\n+```compile-fail,E0909\n+use std::cell::Cell;\n+\n+trait Trait<'a> { }\n+\n+impl Trait<'b> for Cell<&'a u32> { }\n+\n+fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y>\n+where 'x: 'y\n+{\n+    x\n+}\n+```\n+\n+Here, the function `foo` returns a value of type `Cell<&'x u32>`,\n+which references the lifetime `'x`. However, the return type is\n+declared as `impl Trait<'y>` -- this indicates that `foo` returns\n+\"some type that implements `Trait<'y>`\", but it also indicates that\n+the return type **only captures data referencing the lifetime `'y`**.\n+In this case, though, we are referencing data with lifetime `'x`, so\n+this function is in error.\n+\n+To fix this, you must reference the lifetime `'x` from the return\n+type. For example, changing the return type to `impl Trait<'y> + 'x`\n+would work:\n+\n+```\n+use std::cell::Cell;\n+\n+trait Trait<'a> { }\n+\n+impl Trait<'b> for Cell<&'a u32> { }\n+\n+fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y> + 'x\n+where 'x: 'y\n+{\n+    x\n+}\n+```\n+\"##,\n+\n+\n }\n \n "}, {"sha": "93e8745af1b57731318feea40405c51953944899", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 154, "deletions": 34, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/fc3c90cf8af1a2c0e9e6167daed956905b5951a2/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc3c90cf8af1a2c0e9e6167daed956905b5951a2/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=fc3c90cf8af1a2c0e9e6167daed956905b5951a2", "patch": "@@ -17,7 +17,7 @@ use traits::{self, PredicateObligation};\n use ty::{self, Ty, TyCtxt};\n use ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n use ty::outlives::Component;\n-use ty::subst::{Kind, UnpackedKind, Substs};\n+use ty::subst::{Kind, Substs, UnpackedKind};\n use util::nodemap::DefIdMap;\n \n pub type AnonTypeMap<'tcx> = DefIdMap<AnonTypeDecl<'tcx>>;\n@@ -113,10 +113,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     ) -> InferOk<'tcx, (T, AnonTypeMap<'tcx>)> {\n         debug!(\n             \"instantiate_anon_types(value={:?}, parent_def_id={:?}, body_id={:?}, param_env={:?})\",\n-            value,\n-            parent_def_id,\n-            body_id,\n-            param_env,\n+            value, parent_def_id, body_id, param_env,\n         );\n         let mut instantiator = Instantiator {\n             infcx: self,\n@@ -458,7 +455,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // Convert the type from the function into a type valid outside\n         // the function, by replacing invalid regions with 'static,\n         // after producing an error for each of them.\n-        let definition_ty = instantiated_ty.fold_with(&mut ReverseMapper { tcx: self.tcx, map });\n+        let definition_ty =\n+            instantiated_ty.fold_with(&mut ReverseMapper::new(\n+                self.tcx,\n+                self.is_tainted_by_errors(),\n+                def_id,\n+                map,\n+                instantiated_ty,\n+            ));\n         debug!(\n             \"infer_anon_definition_from_instantiation: definition_ty={:?}\",\n             definition_ty\n@@ -475,7 +479,49 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n struct ReverseMapper<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-    map: FxHashMap<Kind<'tcx>, Kind<'gcx>>\n+\n+    /// If errors have already been reported in this fn, we suppress\n+    /// our own errors because they are sometimes derivative.\n+    tainted_by_errors: bool,\n+\n+    anon_type_def_id: DefId,\n+    map: FxHashMap<Kind<'tcx>, Kind<'gcx>>,\n+    map_missing_regions_to_empty: bool,\n+\n+    /// initially `Some`, set to `None` once error has been reported\n+    hidden_ty: Option<Ty<'tcx>>,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> ReverseMapper<'cx, 'gcx, 'tcx> {\n+    fn new(\n+        tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+        tainted_by_errors: bool,\n+        anon_type_def_id: DefId,\n+        map: FxHashMap<Kind<'tcx>, Kind<'gcx>>,\n+        hidden_ty: Ty<'tcx>,\n+    ) -> Self {\n+        Self {\n+            tcx,\n+            tainted_by_errors,\n+            anon_type_def_id,\n+            map,\n+            map_missing_regions_to_empty: false,\n+            hidden_ty: Some(hidden_ty),\n+        }\n+    }\n+\n+    fn fold_kind_mapping_missing_regions_to_empty(&mut self, kind: Kind<'tcx>) -> Kind<'tcx> {\n+        assert!(!self.map_missing_regions_to_empty);\n+        self.map_missing_regions_to_empty = true;\n+        let kind = kind.fold_with(self);\n+        self.map_missing_regions_to_empty = false;\n+        kind\n+    }\n+\n+    fn fold_kind_normally(&mut self, kind: Kind<'tcx>) -> Kind<'tcx> {\n+        assert!(!self.map_missing_regions_to_empty);\n+        kind.fold_with(self)\n+    }\n }\n \n impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx> {\n@@ -484,33 +530,105 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx>\n     }\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        // ignore bound regions that appear in the type (e.g., this\n-        // would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n-        if let ty::ReLateBound(..) = *r {\n-            return r;\n+        match r {\n+            // ignore bound regions that appear in the type (e.g., this\n+            // would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n+            ty::ReLateBound(..) => return r,\n+\n+            // ignore `'static`, as that can appear anywhere\n+            ty::ReStatic => return r,\n+\n+            _ => { }\n         }\n \n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n             Some(UnpackedKind::Lifetime(r1)) => r1,\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n             None => {\n-                // No mapping was found. This means that it is either a\n-                // disallowed lifetime, which will be caught by regionck,\n-                // or it is a region in a non-upvar closure generic, which\n-                // is explicitly allowed. If that surprises you, read on.\n+                if !self.map_missing_regions_to_empty && !self.tainted_by_errors {\n+                    if let Some(hidden_ty) = self.hidden_ty.take() {\n+                        let span = self.tcx.def_span(self.anon_type_def_id);\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0909,\n+                            \"hidden type for `impl Trait` captures lifetime that \\\n+                             does not appear in bounds\",\n+                        );\n+\n+                        // Assuming regionck succeeded, then we must\n+                        // be capturing *some* region from the fn\n+                        // header, and hence it must be free, so it's\n+                        // ok to invoke this fn (which doesn't accept\n+                        // all regions, and would ICE if an\n+                        // inappropriate region is given). We check\n+                        // `is_tainted_by_errors` by errors above, so\n+                        // we don't get in here unless regionck\n+                        // succeeded. (Note also that if regionck\n+                        // failed, then the regions we are attempting\n+                        // to map here may well be giving errors\n+                        // *because* the constraints were not\n+                        // satisfiable.)\n+                        self.tcx.note_and_explain_free_region(\n+                            &mut err,\n+                            &format!(\"hidden type `{}` captures \", hidden_ty),\n+                            r,\n+                            \"\"\n+                        );\n+\n+                        err.emit();\n+                    }\n+                }\n+                self.tcx.types.re_empty\n+            },\n+        }\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        match ty.sty {\n+            ty::TyClosure(def_id, substs) => {\n+                // I am a horrible monster and I pray for death. When\n+                // we encounter a closure here, it is always a closure\n+                // from within the function that we are currently\n+                // type-checking -- one that is now being encapsulated\n+                // in an existential abstract type. Ideally, we would\n+                // go through the types/lifetimes that it references\n+                // and treat them just like we would any other type,\n+                // which means we would error out if we find any\n+                // reference to a type/region that is not in the\n+                // \"reverse map\".\n                 //\n-                // The case of closure is a somewhat subtle (read: hacky)\n-                // consideration. The problem is that our closure types\n-                // currently include all the lifetime parameters declared\n-                // on the enclosing function, even if they are unused by\n-                // the closure itself. We can't readily filter them out,\n+                // **However,** in the case of closures, there is a\n+                // somewhat subtle (read: hacky) consideration. The\n+                // problem is that our closure types currently include\n+                // all the lifetime parameters declared on the\n+                // enclosing function, even if they are unused by the\n+                // closure itself. We can't readily filter them out,\n                 // so here we replace those values with `'empty`. This\n                 // can't really make a difference to the rest of the\n-                // compiler; those regions are ignored for the outlives\n-                // relation, and hence don't affect trait selection or\n-                // auto traits, and they are erased during trans.\n-                self.tcx.types.re_empty\n+                // compiler; those regions are ignored for the\n+                // outlives relation, and hence don't affect trait\n+                // selection or auto traits, and they are erased\n+                // during trans.\n+\n+                let generics = self.tcx.generics_of(def_id);\n+                let parent_len = generics.parent_count();\n+                let substs = self.tcx.mk_substs(substs.substs.iter().enumerate().map(\n+                    |(index, &kind)| {\n+                        if index < parent_len {\n+                            // Accommodate missing regions in the parent kinds...\n+                            self.fold_kind_mapping_missing_regions_to_empty(kind)\n+                        } else {\n+                            // ...but not elsewhere.\n+                            self.fold_kind_normally(kind)\n+                        }\n+                    },\n+                ));\n+\n+                self.tcx.mk_closure(def_id, ty::ClosureSubsts { substs })\n             }\n+\n+            _ => ty.super_fold_with(self),\n         }\n     }\n }\n@@ -573,12 +691,13 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                             return self.fold_anon_ty(ty, def_id, substs);\n                         }\n \n-                        debug!(\"instantiate_anon_types_in_map: \\\n-                                encountered anon with wrong parent \\\n-                                def_id={:?} \\\n-                                anon_parent_def_id={:?}\",\n-                               def_id,\n-                               anon_parent_def_id);\n+                        debug!(\n+                            \"instantiate_anon_types_in_map: \\\n+                             encountered anon with wrong parent \\\n+                             def_id={:?} \\\n+                             anon_parent_def_id={:?}\",\n+                            def_id, anon_parent_def_id\n+                        );\n                     }\n                 }\n \n@@ -598,8 +717,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n \n         debug!(\n             \"instantiate_anon_types: TyAnon(def_id={:?}, substs={:?})\",\n-            def_id,\n-            substs\n+            def_id, substs\n         );\n \n         // Use the same type variable if the exact same TyAnon appears more\n@@ -608,8 +726,10 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n             return anon_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n-        let ty_var = infcx.next_ty_var(ty::UniverseIndex::ROOT,\n-                                       TypeVariableOrigin::TypeInference(span));\n+        let ty_var = infcx.next_ty_var(\n+            ty::UniverseIndex::ROOT,\n+            TypeVariableOrigin::TypeInference(span),\n+        );\n \n         let predicates_of = tcx.predicates_of(def_id);\n         let bounds = predicates_of.instantiate(tcx, substs);"}, {"sha": "416bdae517845f4580b1ddad47f134926b4fa213", "filename": "src/test/ui/impl-trait/region-escape-via-bound-contravariant.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fc3c90cf8af1a2c0e9e6167daed956905b5951a2/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc3c90cf8af1a2c0e9e6167daed956905b5951a2/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound-contravariant.rs?ref=fc3c90cf8af1a2c0e9e6167daed956905b5951a2", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// In contrast to `region-escape-via-bound-invariant`, in this case we\n+// *can* return a value of type `&'x u32`, even though `'x` does not\n+// appear in the bounds. This is because `&` is contravariant, and so\n+// we are *actually* returning a `&'y u32`.\n+//\n+// See https://github.com/rust-lang/rust/issues/46541 for more details.\n+\n+// run-pass\n+\n+#![allow(dead_code)]\n+#![feature(conservative_impl_trait)]\n+#![feature(in_band_lifetimes)]\n+#![feature(nll)]\n+\n+trait Trait<'a> { }\n+\n+impl Trait<'b> for &'a u32 { }\n+\n+fn foo(x: &'x u32) -> impl Trait<'y>\n+where 'x: 'y\n+{\n+    x\n+}\n+\n+fn main() { }"}, {"sha": "38c18ce61044e79e8008279d1bbcc543e012f052", "filename": "src/test/ui/impl-trait/region-escape-via-bound.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/fc3c90cf8af1a2c0e9e6167daed956905b5951a2/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc3c90cf8af1a2c0e9e6167daed956905b5951a2/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.rs?ref=fc3c90cf8af1a2c0e9e6167daed956905b5951a2", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we do not allow the region `'x` to escape in the impl\n+// trait **even though** `'y` escapes, which outlives `'x`.\n+//\n+// See https://github.com/rust-lang/rust/issues/46541 for more details.\n+\n+#![allow(dead_code)]\n+#![feature(conservative_impl_trait)]\n+#![feature(in_band_lifetimes)]\n+#![feature(nll)]\n+\n+use std::cell::Cell;\n+\n+trait Trait<'a> { }\n+\n+impl Trait<'b> for Cell<&'a u32> { }\n+\n+fn foo(x: Cell<&'x u32>) -> impl Trait<'y>\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds [E0909]\n+where 'x: 'y\n+{\n+    x\n+}\n+\n+fn main() { }"}, {"sha": "5659fee9bedc6c4411ef9b196ffcbe44cd1f2399", "filename": "src/test/ui/impl-trait/region-escape-via-bound.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fc3c90cf8af1a2c0e9e6167daed956905b5951a2/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc3c90cf8af1a2c0e9e6167daed956905b5951a2/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr?ref=fc3c90cf8af1a2c0e9e6167daed956905b5951a2", "patch": "@@ -0,0 +1,20 @@\n+error[E0909]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/region-escape-via-bound.rs:27:29\n+   |\n+LL | fn foo(x: Cell<&'x u32>) -> impl Trait<'y>\n+   |                             ^^^^^^^^^^^^^^\n+   |\n+note: hidden type `std::cell::Cell<&'x u32>` captures the lifetime 'x as defined on the function body at 27:1\n+  --> $DIR/region-escape-via-bound.rs:27:1\n+   |\n+LL | / fn foo(x: Cell<&'x u32>) -> impl Trait<'y>\n+LL | |     //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds [E0909]\n+LL | | where 'x: 'y\n+LL | | {\n+LL | |     x\n+LL | | }\n+   | |_^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0909`."}]}