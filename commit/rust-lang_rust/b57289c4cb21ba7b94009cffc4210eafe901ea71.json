{"sha": "b57289c4cb21ba7b94009cffc4210eafe901ea71", "node_id": "C_kwDOAAsO6NoAKGI1NzI4OWM0Y2IyMWJhN2I5NDAwOWNmZmM0MjEwZWFmZTkwMWVhNzE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-16T19:23:56Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-11-16T19:23:56Z"}, "message": "Skip test/bench attr expansion in resolution instead of collection", "tree": {"sha": "d7f02d10c92679b896cf3681c59f36b1e63c7843", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7f02d10c92679b896cf3681c59f36b1e63c7843"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b57289c4cb21ba7b94009cffc4210eafe901ea71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b57289c4cb21ba7b94009cffc4210eafe901ea71", "html_url": "https://github.com/rust-lang/rust/commit/b57289c4cb21ba7b94009cffc4210eafe901ea71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b57289c4cb21ba7b94009cffc4210eafe901ea71/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f1e26c3f9804eaaf2941feaa140d6f8c6d8c562", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f1e26c3f9804eaaf2941feaa140d6f8c6d8c562", "html_url": "https://github.com/rust-lang/rust/commit/9f1e26c3f9804eaaf2941feaa140d6f8c6d8c562"}], "stats": {"total": 84, "additions": 47, "deletions": 37}, "files": [{"sha": "6cd185ceeb2cbaa8203a70721ab1f67f58f07a67", "filename": "crates/hir_def/src/builtin_attr.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b57289c4cb21ba7b94009cffc4210eafe901ea71/crates%2Fhir_def%2Fsrc%2Fbuiltin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b57289c4cb21ba7b94009cffc4210eafe901ea71/crates%2Fhir_def%2Fsrc%2Fbuiltin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbuiltin_attr.rs?ref=b57289c4cb21ba7b94009cffc4210eafe901ea71", "patch": "@@ -34,11 +34,6 @@ macro_rules! rustc_attr {\n     };\n }\n \n-// FIXME: We shouldn't special case these at all, but as of now expanding attributes severely degrades\n-// user experience due to lacking support.\n-/// Built-in macro-like attributes.\n-pub const EXTRA_ATTRIBUTES: &[BuiltinAttribute] = &[\"test\", \"bench\"];\n-\n /// \"Inert\" built-in attributes that have a special meaning to rustc or rustdoc.\n #[rustfmt::skip]\n pub const INERT_ATTRIBUTES: &[BuiltinAttribute] = &["}, {"sha": "1abda2d66aaf05e5a6bdc2b139f584799f0d5dd5", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b57289c4cb21ba7b94009cffc4210eafe901ea71/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b57289c4cb21ba7b94009cffc4210eafe901ea71/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=b57289c4cb21ba7b94009cffc4210eafe901ea71", "patch": "@@ -778,21 +778,18 @@ fn attr_macro_as_call_id(\n     krate: CrateId,\n     resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n ) -> Result<MacroCallId, UnresolvedMacro> {\n-    let def: MacroDefId = resolver(item_attr.path.clone())\n+    let attr_path = &item_attr.path;\n+\n+    let def = resolver(attr_path.clone())\n         .filter(MacroDefId::is_attribute)\n-        .ok_or_else(|| UnresolvedMacro { path: item_attr.path.clone() })?;\n-    let last_segment = item_attr\n-        .path\n-        .segments()\n-        .last()\n-        .ok_or_else(|| UnresolvedMacro { path: item_attr.path.clone() })?;\n-    let mut arg = match &macro_attr.input {\n-        Some(input) => match &**input {\n-            attr::AttrInput::Literal(_) => Default::default(),\n-            attr::AttrInput::TokenTree(tt, map) => (tt.clone(), map.clone()),\n-        },\n-        None => Default::default(),\n+        .ok_or_else(|| UnresolvedMacro { path: attr_path.clone() })?;\n+    let last_segment =\n+        attr_path.segments().last().ok_or_else(|| UnresolvedMacro { path: attr_path.clone() })?;\n+    let mut arg = match macro_attr.input.as_deref() {\n+        Some(attr::AttrInput::TokenTree(tt, map)) => (tt.clone(), map.clone()),\n+        _ => Default::default(),\n     };\n+\n     // The parentheses are always disposed here.\n     arg.0.delimiter = None;\n "}, {"sha": "d1e54cd46d5229179ed43e36f54d98b6349fea02", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b57289c4cb21ba7b94009cffc4210eafe901ea71/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b57289c4cb21ba7b94009cffc4210eafe901ea71/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=b57289c4cb21ba7b94009cffc4210eafe901ea71", "patch": "@@ -9,7 +9,7 @@ use base_db::{CrateId, Edition, FileId, ProcMacroId};\n use cfg::{CfgExpr, CfgOptions};\n use hir_expand::{\n     ast_id_map::FileAstId,\n-    builtin_attr_macro::find_builtin_attr,\n+    builtin_attr_macro::{find_builtin_attr, is_builtin_test_or_bench_attr},\n     builtin_derive_macro::find_builtin_derive,\n     builtin_fn_macro::find_builtin_macro,\n     name::{name, AsName, Name},\n@@ -1142,7 +1142,30 @@ impl DefCollector<'_> {\n                     ) {\n                         Ok(call_id) => {\n                             let loc: MacroCallLoc = self.db.lookup_intern_macro_call(call_id);\n-                            if let MacroDefKind::ProcMacro(exp, ..) = &loc.def.kind {\n+\n+                            // Skip #[test]/#[bench] expansion, which would merely result in more memory usage\n+                            // due to duplicating functions into macro expansions\n+                            if is_builtin_test_or_bench_attr(loc.def) {\n+                                let file_id = ast_id.ast_id.file_id;\n+                                let item_tree = self.db.file_item_tree(file_id);\n+                                let mod_dir = self.mod_dirs[&directive.module_id].clone();\n+                                self.skip_attrs.insert(InFile::new(file_id, *mod_item), attr.id);\n+                                ModCollector {\n+                                    def_collector: &mut *self,\n+                                    macro_depth: directive.depth,\n+                                    module_id: directive.module_id,\n+                                    tree_id: TreeId::new(file_id, None),\n+                                    item_tree: &item_tree,\n+                                    mod_dir,\n+                                }\n+                                .collect(&[*mod_item]);\n+\n+                                // Remove the original directive since we resolved it.\n+                                res = ReachedFixedPoint::No;\n+                                return false;\n+                            }\n+\n+                            if let MacroDefKind::ProcMacro(exp, ..) = loc.def.kind {\n                                 if exp.is_dummy() {\n                                     // Proc macros that cannot be expanded are treated as not\n                                     // resolved, in order to fall back later.\n@@ -1774,7 +1797,6 @@ impl ModCollector<'_, '_> {\n                 let name = name.to_smol_str();\n                 let is_inert = builtin_attr::INERT_ATTRIBUTES\n                     .iter()\n-                    .chain(builtin_attr::EXTRA_ATTRIBUTES)\n                     .copied()\n                     .chain(self.def_collector.registered_attrs.iter().map(AsRef::as_ref))\n                     .any(|attr| name == *attr);"}, {"sha": "ec587daf9bab669a3c487571f16244fa7a5a48d8", "filename": "crates/hir_expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b57289c4cb21ba7b94009cffc4210eafe901ea71/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b57289c4cb21ba7b94009cffc4210eafe901ea71/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=b57289c4cb21ba7b94009cffc4210eafe901ea71", "patch": "@@ -46,6 +46,16 @@ register_builtin! {\n     (test_case, TestCase) => dummy_attr_expand\n }\n \n+pub fn is_builtin_test_or_bench_attr(makro: MacroDefId) -> bool {\n+    match makro.kind {\n+        MacroDefKind::BuiltInAttr(expander, ..) => {\n+            BuiltinAttrExpander::find_by_name(&name!(test)) == Some(expander)\n+                || BuiltinAttrExpander::find_by_name(&name!(bench)) == Some(expander)\n+        }\n+        _ => false,\n+    }\n+}\n+\n pub fn find_builtin_attr(\n     ident: &name::Name,\n     krate: CrateId,"}, {"sha": "fdb639f55d2ecf09110969b699e2b53e91ab8b64", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b57289c4cb21ba7b94009cffc4210eafe901ea71/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b57289c4cb21ba7b94009cffc4210eafe901ea71/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=b57289c4cb21ba7b94009cffc4210eafe901ea71", "patch": "@@ -701,16 +701,6 @@ impl<N: AstNode> InFile<N> {\n     }\n }\n \n-impl InFile<ast::Fn> {\n-    pub fn map_out_of_test_attr(self, db: &dyn db::AstDatabase) -> InFile<ast::Fn> {\n-        (|| {\n-            let InFile { file_id, value } = self.file_id.call_node(db)?;\n-            ast::Fn::cast(value).map(|n| InFile::new(file_id, n))\n-        })()\n-        .unwrap_or(self)\n-    }\n-}\n-\n /// In Rust, macros expand token trees to token trees. When we want to turn a\n /// token tree into an AST node, we need to figure out what kind of AST node we\n /// want: something like `foo` can be a type, an expression, or a pattern."}, {"sha": "21130e06075846281c9190a9487685b77168e2fe", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b57289c4cb21ba7b94009cffc4210eafe901ea71/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b57289c4cb21ba7b94009cffc4210eafe901ea71/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=b57289c4cb21ba7b94009cffc4210eafe901ea71", "patch": "@@ -237,8 +237,7 @@ fn find_related_tests(\n                 .map(|f| hir::InFile::new(sema.hir_file_for(f.syntax()), f));\n \n             for fn_def in functions {\n-                // #[test/bench] expands to just the item causing us to lose the attribute, so recover them by going out of the attribute\n-                let InFile { value: fn_def, .. } = &fn_def.map_out_of_test_attr(sema.db);\n+                let InFile { value: fn_def, .. } = &fn_def;\n                 if let Some(runnable) = as_test_runnable(sema, fn_def) {\n                     // direct test\n                     tests.insert(runnable);\n@@ -294,8 +293,7 @@ fn parent_test_module(sema: &Semantics<RootDatabase>, fn_def: &ast::Fn) -> Optio\n }\n \n pub(crate) fn runnable_fn(sema: &Semantics<RootDatabase>, def: hir::Function) -> Option<Runnable> {\n-    // #[test/bench] expands to just the item causing us to lose the attribute, so recover them by going out of the attribute\n-    let func = def.source(sema.db)?.map_out_of_test_attr(sema.db);\n+    let func = def.source(sema.db)?;\n     let name_string = def.name(sema.db).to_string();\n \n     let root = def.module(sema.db).krate().root_module(sema.db);\n@@ -504,8 +502,6 @@ fn has_test_function_or_multiple_test_submodules(\n         match item {\n             hir::ModuleDef::Function(f) => {\n                 if let Some(it) = f.source(sema.db) {\n-                    // #[test/bench] expands to just the item causing us to lose the attribute, so recover them by going out of the attribute\n-                    let it = it.map_out_of_test_attr(sema.db);\n                     if test_related_attribute(&it.value).is_some() {\n                         return true;\n                     }"}]}