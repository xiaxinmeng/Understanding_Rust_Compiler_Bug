{"sha": "fc43df0333d5862a219f16d294ae38b14b9191d3", "node_id": "C_kwDOAAsO6NoAKGZjNDNkZjAzMzNkNTg2MmEyMTlmMTZkMjk0YWUzOGIxNGI5MTkxZDM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-09-20T18:04:35Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-09-22T17:36:11Z"}, "message": "Revert \"Auto merge of #101620 - cjgillot:compute_lint_levels_by_def, r=oli-obk\"\n\nThis reverts commit 2cb9a65684dba47c52de8fa938febf97a73e70a9, reversing\nchanges made to 750bd1a7ff3e010611b97ee75d30b7cbf5f3a03c.", "tree": {"sha": "9b69844fa4ca64623bc06cb0738450061690dfd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9b69844fa4ca64623bc06cb0738450061690dfd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc43df0333d5862a219f16d294ae38b14b9191d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc43df0333d5862a219f16d294ae38b14b9191d3", "html_url": "https://github.com/rust-lang/rust/commit/fc43df0333d5862a219f16d294ae38b14b9191d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc43df0333d5862a219f16d294ae38b14b9191d3/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "381bd2a836f96c9dede1f5ee740e70194d6fb149", "url": "https://api.github.com/repos/rust-lang/rust/commits/381bd2a836f96c9dede1f5ee740e70194d6fb149", "html_url": "https://github.com/rust-lang/rust/commit/381bd2a836f96c9dede1f5ee740e70194d6fb149"}], "stats": {"total": 1158, "additions": 488, "deletions": 670}, "files": [{"sha": "1c440a0a07efcac6a1b40f1adc11cb604fdf99c8", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -339,10 +339,9 @@ impl Diagnostic {\n             // The lint index inside the attribute is manually transferred here.\n             let lint_index = expectation_id.get_lint_index();\n             expectation_id.set_lint_index(None);\n-            let mut stable_id = unstable_to_stable\n+            let mut stable_id = *unstable_to_stable\n                 .get(&expectation_id)\n-                .expect(\"each unstable `LintExpectationId` must have a matching stable id\")\n-                .normalize();\n+                .expect(\"each unstable `LintExpectationId` must have a matching stable id\");\n \n             stable_id.set_lint_index(lint_index);\n             *expectation_id = stable_id;"}, {"sha": "b44cf352233e3fc0c414366400c8d8a162f049b9", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -1205,7 +1205,7 @@ impl HandlerInner {\n \n         if let Some(expectation_id) = diagnostic.level.get_expectation_id() {\n             self.suppressed_expected_diag = true;\n-            self.fulfilled_expectations.insert(expectation_id.normalize());\n+            self.fulfilled_expectations.insert(expectation_id);\n         }\n \n         if matches!(diagnostic.level, Warning(_))"}, {"sha": "7ca6ec5d9623475eaeabb13eba62360d85cd7d8c", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -560,7 +560,7 @@ pub struct LateContext<'tcx> {\n \n /// Context for lint checking of the AST, after expansion, before lowering to HIR.\n pub struct EarlyContext<'a> {\n-    pub builder: LintLevelsBuilder<'a, crate::levels::TopDown>,\n+    pub builder: LintLevelsBuilder<'a>,\n     pub buffered: LintBuffer,\n }\n "}, {"sha": "96ecd79a69cfb3603cae46f45a7c06064ab331a8", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -59,7 +59,6 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n         F: FnOnce(&mut Self),\n     {\n         let is_crate_node = id == ast::CRATE_NODE_ID;\n-        debug!(?id);\n         let push = self.context.builder.push(attrs, is_crate_node, None);\n \n         self.check_id(id);"}, {"sha": "699e81543188f4f44f5c674f8c228ade46986409", "filename": "compiler/rustc_lint/src/expect.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -16,10 +16,8 @@ fn check_expectations(tcx: TyCtxt<'_>, tool_filter: Option<Symbol>) {\n         return;\n     }\n \n-    let lint_expectations = tcx.lint_expectations(());\n     let fulfilled_expectations = tcx.sess.diagnostic().steal_fulfilled_expectation_ids();\n-\n-    tracing::debug!(?lint_expectations, ?fulfilled_expectations);\n+    let lint_expectations = &tcx.lint_levels(()).lint_expectations;\n \n     for (id, expectation) in lint_expectations {\n         // This check will always be true, since `lint_expectations` only"}, {"sha": "1e16ac51e9e5de807f6178de339e694c8f2b006d", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 284, "deletions": 396, "changes": 680, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -6,11 +6,10 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, Diagnostic, LintDiagnosticBuilder, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::{intravisit, HirId};\n-use rustc_index::vec::IndexVec;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::lint::{\n-    reveal_actual_level, struct_lint_level, LevelAndSource, LintExpectation, LintLevelSource,\n-    ShallowLintLevelMap,\n+    struct_lint_level, LevelAndSource, LintExpectation, LintLevelMap, LintLevelSets,\n+    LintLevelSource, LintSet, LintStackIndex, COMMAND_LINE,\n };\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{RegisteredTools, TyCtxt};\n@@ -28,359 +27,68 @@ use crate::errors::{\n     UnknownToolInScopedLint,\n };\n \n-/// Collection of lint levels for the whole crate.\n-/// This is used by AST-based lints, which do not\n-/// wait until we have built HIR to be emitted.\n-#[derive(Debug)]\n-struct LintLevelSets {\n-    /// Linked list of specifications.\n-    list: IndexVec<LintStackIndex, LintSet>,\n-}\n-\n-rustc_index::newtype_index! {\n-    struct LintStackIndex {\n-        ENCODABLE = custom, // we don't need encoding\n-        const COMMAND_LINE = 0,\n-    }\n-}\n-\n-/// Specifications found at this position in the stack.  This map only represents the lints\n-/// found for one set of attributes (like `shallow_lint_levels_on` does).\n-///\n-/// We store the level specifications as a linked list.\n-/// Each `LintSet` represents a set of attributes on the same AST node.\n-/// The `parent` forms a linked list that matches the AST tree.\n-/// This way, walking the linked list is equivalent to walking the AST bottom-up\n-/// to find the specifications for a given lint.\n-#[derive(Debug)]\n-struct LintSet {\n-    // -A,-W,-D flags, a `Symbol` for the flag itself and `Level` for which\n-    // flag.\n-    specs: FxHashMap<LintId, LevelAndSource>,\n-    parent: LintStackIndex,\n-}\n-\n-impl LintLevelSets {\n-    fn new() -> Self {\n-        LintLevelSets { list: IndexVec::new() }\n-    }\n-\n-    fn get_lint_level(\n-        &self,\n-        lint: &'static Lint,\n-        idx: LintStackIndex,\n-        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n-        sess: &Session,\n-    ) -> LevelAndSource {\n-        let lint = LintId::of(lint);\n-        let (level, mut src) = self.raw_lint_id_level(lint, idx, aux);\n-        let level = reveal_actual_level(level, &mut src, sess, lint, |id| {\n-            self.raw_lint_id_level(id, idx, aux)\n-        });\n-        (level, src)\n-    }\n-\n-    fn raw_lint_id_level(\n-        &self,\n-        id: LintId,\n-        mut idx: LintStackIndex,\n-        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n-    ) -> (Option<Level>, LintLevelSource) {\n-        if let Some(specs) = aux {\n-            if let Some(&(level, src)) = specs.get(&id) {\n-                return (Some(level), src);\n-            }\n-        }\n-        loop {\n-            let LintSet { ref specs, parent } = self.list[idx];\n-            if let Some(&(level, src)) = specs.get(&id) {\n-                return (Some(level), src);\n-            }\n-            if idx == COMMAND_LINE {\n-                return (None, LintLevelSource::Default);\n-            }\n-            idx = parent;\n-        }\n-    }\n-}\n-\n-fn lint_expectations(tcx: TyCtxt<'_>, (): ()) -> Vec<(LintExpectationId, LintExpectation)> {\n+fn lint_levels(tcx: TyCtxt<'_>, (): ()) -> LintLevelMap {\n     let store = unerased_lint_store(tcx);\n+    let levels =\n+        LintLevelsBuilder::new(tcx.sess, false, &store, &tcx.resolutions(()).registered_tools);\n+    let mut builder = LintLevelMapBuilder { levels, tcx };\n+    let krate = tcx.hir().krate();\n \n-    let mut builder = LintLevelsBuilder {\n-        sess: tcx.sess,\n-        provider: QueryMapExpectationsWrapper {\n-            tcx,\n-            cur: hir::CRATE_HIR_ID,\n-            specs: ShallowLintLevelMap::default(),\n-            expectations: Vec::new(),\n-            unstable_to_stable_ids: FxHashMap::default(),\n-        },\n-        warn_about_weird_lints: false,\n-        store,\n-        registered_tools: &tcx.resolutions(()).registered_tools,\n-    };\n-\n-    builder.add_command_line();\n-    builder.add_id(hir::CRATE_HIR_ID);\n-    tcx.hir().walk_toplevel_module(&mut builder);\n-\n-    tcx.sess.diagnostic().update_unstable_expectation_id(&builder.provider.unstable_to_stable_ids);\n+    builder.levels.id_to_set.reserve(krate.owners.len() + 1);\n \n-    builder.provider.expectations\n-}\n+    let push =\n+        builder.levels.push(tcx.hir().attrs(hir::CRATE_HIR_ID), true, Some(hir::CRATE_HIR_ID));\n \n-fn shallow_lint_levels_on(tcx: TyCtxt<'_>, hir_id: HirId) -> ShallowLintLevelMap {\n-    let store = unerased_lint_store(tcx);\n-\n-    let mut levels = LintLevelsBuilder {\n-        sess: tcx.sess,\n-        provider: LintLevelQueryMap { tcx, cur: hir_id, specs: ShallowLintLevelMap::default() },\n-        warn_about_weird_lints: false,\n-        store,\n-        registered_tools: &tcx.resolutions(()).registered_tools,\n-    };\n-\n-    let is_crate = hir::CRATE_HIR_ID == hir_id;\n-    if is_crate {\n-        levels.add_command_line();\n-    }\n-    debug!(?hir_id);\n-    levels.add(tcx.hir().attrs(hir_id), is_crate, Some(hir_id));\n+    builder.levels.register_id(hir::CRATE_HIR_ID);\n+    tcx.hir().walk_toplevel_module(&mut builder);\n+    builder.levels.pop(push);\n \n-    levels.provider.specs\n+    builder.levels.update_unstable_expectation_ids();\n+    builder.levels.build_map()\n }\n \n-pub struct TopDown {\n+pub struct LintLevelsBuilder<'s> {\n+    sess: &'s Session,\n+    lint_expectations: Vec<(LintExpectationId, LintExpectation)>,\n+    /// Each expectation has a stable and an unstable identifier. This map\n+    /// is used to map from unstable to stable [`LintExpectationId`]s.\n+    expectation_id_map: FxHashMap<LintExpectationId, LintExpectationId>,\n     sets: LintLevelSets,\n+    id_to_set: FxHashMap<HirId, LintStackIndex>,\n     cur: LintStackIndex,\n-}\n-\n-pub trait LintLevelsProvider {\n-    fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource>;\n-    fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource>;\n-    fn get_lint_level(&self, lint: &'static Lint, sess: &Session) -> LevelAndSource;\n-    fn push_expectation(&mut self, _id: LintExpectationId, _expectation: LintExpectation) {}\n-}\n-\n-impl LintLevelsProvider for TopDown {\n-    fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n-        &self.sets.list[self.cur].specs\n-    }\n-\n-    fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource> {\n-        &mut self.sets.list[self.cur].specs\n-    }\n-\n-    fn get_lint_level(&self, lint: &'static Lint, sess: &Session) -> LevelAndSource {\n-        self.sets.get_lint_level(lint, self.cur, Some(self.current_specs()), sess)\n-    }\n-}\n-\n-struct LintLevelQueryMap<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    cur: HirId,\n-    specs: ShallowLintLevelMap,\n-}\n-\n-impl LintLevelsProvider for LintLevelQueryMap<'_> {\n-    fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n-        &self.specs.specs\n-    }\n-    fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource> {\n-        &mut self.specs.specs\n-    }\n-    fn get_lint_level(&self, lint: &'static Lint, _: &Session) -> LevelAndSource {\n-        self.specs.lint_level_id_at_node(self.tcx, LintId::of(lint), self.cur)\n-    }\n-}\n-\n-struct QueryMapExpectationsWrapper<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    cur: HirId,\n-    specs: ShallowLintLevelMap,\n-    expectations: Vec<(LintExpectationId, LintExpectation)>,\n-    unstable_to_stable_ids: FxHashMap<LintExpectationId, LintExpectationId>,\n-}\n-\n-impl LintLevelsProvider for QueryMapExpectationsWrapper<'_> {\n-    fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n-        &self.specs.specs\n-    }\n-    fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource> {\n-        self.specs.specs.clear();\n-        &mut self.specs.specs\n-    }\n-    fn get_lint_level(&self, lint: &'static Lint, _: &Session) -> LevelAndSource {\n-        self.specs.lint_level_id_at_node(self.tcx, LintId::of(lint), self.cur)\n-    }\n-    fn push_expectation(&mut self, id: LintExpectationId, expectation: LintExpectation) {\n-        let LintExpectationId::Stable { attr_id: Some(attr_id), hir_id, attr_index, .. } = id else { bug!(\"unstable expectation id should already be mapped\") };\n-        let key = LintExpectationId::Unstable { attr_id, lint_index: None };\n-\n-        if !self.unstable_to_stable_ids.contains_key(&key) {\n-            self.unstable_to_stable_ids.insert(\n-                key,\n-                LintExpectationId::Stable { hir_id, attr_index, lint_index: None, attr_id: None },\n-            );\n-        }\n-\n-        self.expectations.push((id.normalize(), expectation));\n-    }\n-}\n-\n-impl<'tcx> LintLevelsBuilder<'_, QueryMapExpectationsWrapper<'tcx>> {\n-    fn add_id(&mut self, hir_id: HirId) {\n-        self.add(self.provider.tcx.hir().attrs(hir_id), hir_id == hir::CRATE_HIR_ID, Some(hir_id));\n-    }\n-}\n-\n-impl<'tcx> intravisit::Visitor<'tcx> for LintLevelsBuilder<'_, QueryMapExpectationsWrapper<'tcx>> {\n-    type NestedFilter = nested_filter::All;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.provider.tcx.hir()\n-    }\n-\n-    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        self.add_id(param.hir_id);\n-        intravisit::walk_param(self, param);\n-    }\n-\n-    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        self.add_id(it.hir_id());\n-        intravisit::walk_item(self, it);\n-    }\n-\n-    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n-        self.add_id(it.hir_id());\n-        intravisit::walk_foreign_item(self, it);\n-    }\n-\n-    fn visit_stmt(&mut self, e: &'tcx hir::Stmt<'tcx>) {\n-        // We will call `add_id` when we walk\n-        // the `StmtKind`. The outer statement itself doesn't\n-        // define the lint levels.\n-        intravisit::walk_stmt(self, e);\n-    }\n-\n-    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n-        self.add_id(e.hir_id);\n-        intravisit::walk_expr(self, e);\n-    }\n-\n-    fn visit_field_def(&mut self, s: &'tcx hir::FieldDef<'tcx>) {\n-        self.add_id(s.hir_id);\n-        intravisit::walk_field_def(self, s);\n-    }\n-\n-    fn visit_variant(&mut self, v: &'tcx hir::Variant<'tcx>) {\n-        self.add_id(v.id);\n-        intravisit::walk_variant(self, v);\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        self.add_id(l.hir_id);\n-        intravisit::walk_local(self, l);\n-    }\n-\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n-        self.add_id(a.hir_id);\n-        intravisit::walk_arm(self, a);\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.add_id(trait_item.hir_id());\n-        intravisit::walk_trait_item(self, trait_item);\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.add_id(impl_item.hir_id());\n-        intravisit::walk_impl_item(self, impl_item);\n-    }\n-}\n-\n-pub struct LintLevelsBuilder<'s, P> {\n-    sess: &'s Session,\n-    provider: P,\n     warn_about_weird_lints: bool,\n     store: &'s LintStore,\n     registered_tools: &'s RegisteredTools,\n }\n \n-pub(crate) struct BuilderPush {\n+pub struct BuilderPush {\n     prev: LintStackIndex,\n+    pub changed: bool,\n }\n \n-impl<'s> LintLevelsBuilder<'s, TopDown> {\n-    pub(crate) fn new(\n+impl<'s> LintLevelsBuilder<'s> {\n+    pub fn new(\n         sess: &'s Session,\n         warn_about_weird_lints: bool,\n         store: &'s LintStore,\n         registered_tools: &'s RegisteredTools,\n     ) -> Self {\n         let mut builder = LintLevelsBuilder {\n             sess,\n-            provider: TopDown { sets: LintLevelSets::new(), cur: COMMAND_LINE },\n+            lint_expectations: Default::default(),\n+            expectation_id_map: Default::default(),\n+            sets: LintLevelSets::new(),\n+            cur: COMMAND_LINE,\n+            id_to_set: Default::default(),\n             warn_about_weird_lints,\n             store,\n             registered_tools,\n         };\n-        builder.process_command_line();\n-        assert_eq!(builder.provider.sets.list.len(), 1);\n+        builder.process_command_line(sess, store);\n+        assert_eq!(builder.sets.list.len(), 1);\n         builder\n     }\n \n-    fn process_command_line(&mut self) {\n-        self.provider.cur = self\n-            .provider\n-            .sets\n-            .list\n-            .push(LintSet { specs: FxHashMap::default(), parent: COMMAND_LINE });\n-        self.add_command_line();\n-    }\n-\n-    /// Pushes a list of AST lint attributes onto this context.\n-    ///\n-    /// This function will return a `BuilderPush` object which should be passed\n-    /// to `pop` when this scope for the attributes provided is exited.\n-    ///\n-    /// This function will perform a number of tasks:\n-    ///\n-    /// * It'll validate all lint-related attributes in `attrs`\n-    /// * It'll mark all lint-related attributes as used\n-    /// * Lint levels will be updated based on the attributes provided\n-    /// * Lint attributes are validated, e.g., a `#[forbid]` can't be switched to\n-    ///   `#[allow]`\n-    ///\n-    /// Don't forget to call `pop`!\n-    pub(crate) fn push(\n-        &mut self,\n-        attrs: &[ast::Attribute],\n-        is_crate_node: bool,\n-        source_hir_id: Option<HirId>,\n-    ) -> BuilderPush {\n-        let prev = self.provider.cur;\n-        self.provider.cur =\n-            self.provider.sets.list.push(LintSet { specs: FxHashMap::default(), parent: prev });\n-\n-        self.add(attrs, is_crate_node, source_hir_id);\n-\n-        if self.provider.current_specs().is_empty() {\n-            self.provider.sets.list.pop();\n-            self.provider.cur = prev;\n-        }\n-\n-        BuilderPush { prev }\n-    }\n-\n-    /// Called after `push` when the scope of a set of attributes are exited.\n-    pub(crate) fn pop(&mut self, push: BuilderPush) {\n-        self.provider.cur = push.prev;\n-    }\n-}\n-\n-impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n     pub(crate) fn sess(&self) -> &Session {\n         self.sess\n     }\n@@ -390,20 +98,24 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n     }\n \n     fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n-        self.provider.current_specs()\n+        &self.sets.list[self.cur].specs\n     }\n \n     fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource> {\n-        self.provider.current_specs_mut()\n+        &mut self.sets.list[self.cur].specs\n     }\n \n-    fn add_command_line(&mut self) {\n-        for &(ref lint_name, level) in &self.sess.opts.lint_opts {\n-            self.store.check_lint_name_cmdline(self.sess, &lint_name, level, self.registered_tools);\n+    fn process_command_line(&mut self, sess: &Session, store: &LintStore) {\n+        self.sets.lint_cap = sess.opts.lint_cap.unwrap_or(Level::Forbid);\n+\n+        self.cur =\n+            self.sets.list.push(LintSet { specs: FxHashMap::default(), parent: COMMAND_LINE });\n+        for &(ref lint_name, level) in &sess.opts.lint_opts {\n+            store.check_lint_name_cmdline(sess, &lint_name, level, self.registered_tools);\n             let orig_level = level;\n             let lint_flag_val = Symbol::intern(lint_name);\n \n-            let Ok(ids) = self.store.find_lints(&lint_name) else {\n+            let Ok(ids) = store.find_lints(&lint_name) else {\n                 // errors handled in check_lint_name_cmdline above\n                 continue\n             };\n@@ -426,11 +138,9 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n     /// Attempts to insert the `id` to `level_src` map entry. If unsuccessful\n     /// (e.g. if a forbid was already inserted on the same scope), then emits a\n     /// diagnostic with no change to `specs`.\n-    fn insert_spec(&mut self, id: LintId, (mut level, src): LevelAndSource) {\n-        let (old_level, old_src) = self.provider.get_lint_level(id.lint, &self.sess);\n-        if let Level::Expect(id) = &mut level && let LintExpectationId::Stable { .. } = id {\n-            *id = id.normalize();\n-        }\n+    fn insert_spec(&mut self, id: LintId, (level, src): LevelAndSource) {\n+        let (old_level, old_src) =\n+            self.sets.get_lint_level(id.lint, self.cur, Some(self.current_specs()), &self.sess);\n         // Setting to a non-forbid level is an error if the lint previously had\n         // a forbid level. Note that this is not necessarily true even with a\n         // `#[forbid(..)]` attribute present, as that is overridden by `--cap-lints`.\n@@ -448,7 +158,7 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                 let id_name = id.lint.name_lower();\n                 let fcw_warning = match old_src {\n                     LintLevelSource::Default => false,\n-                    LintLevelSource::Node { name, .. } => self.store.is_lint_group(name),\n+                    LintLevelSource::Node(symbol, _, _) => self.store.is_lint_group(symbol),\n                     LintLevelSource::CommandLine(symbol, _) => self.store.is_lint_group(symbol),\n                 };\n                 debug!(\n@@ -468,8 +178,8 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                                 id.to_string()\n                             ));\n                         }\n-                        LintLevelSource::Node { span, reason, .. } => {\n-                            diag.span_label(span, \"`forbid` level set here\");\n+                        LintLevelSource::Node(_, forbid_source_span, reason) => {\n+                            diag.span_label(forbid_source_span, \"`forbid` level set here\");\n                             if let Some(rationale) = reason {\n                                 diag.note(rationale.as_str());\n                             }\n@@ -489,8 +199,11 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                             LintLevelSource::Default => {\n                                 OverruledAttributeSub::DefaultSource { id: id.to_string() }\n                             }\n-                            LintLevelSource::Node { span, reason, .. } => {\n-                                OverruledAttributeSub::NodeSource { span, reason }\n+                            LintLevelSource::Node(_, forbid_source_span, reason) => {\n+                                OverruledAttributeSub::NodeSource {\n+                                    span: forbid_source_span,\n+                                    reason,\n+                                }\n                             }\n                             LintLevelSource::CommandLine(_, _) => {\n                                 OverruledAttributeSub::CommandLineSource\n@@ -543,7 +256,29 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n         };\n     }\n \n-    fn add(&mut self, attrs: &[ast::Attribute], is_crate_node: bool, source_hir_id: Option<HirId>) {\n+    /// Pushes a list of AST lint attributes onto this context.\n+    ///\n+    /// This function will return a `BuilderPush` object which should be passed\n+    /// to `pop` when this scope for the attributes provided is exited.\n+    ///\n+    /// This function will perform a number of tasks:\n+    ///\n+    /// * It'll validate all lint-related attributes in `attrs`\n+    /// * It'll mark all lint-related attributes as used\n+    /// * Lint levels will be updated based on the attributes provided\n+    /// * Lint attributes are validated, e.g., a `#[forbid]` can't be switched to\n+    ///   `#[allow]`\n+    ///\n+    /// Don't forget to call `pop`!\n+    pub(crate) fn push(\n+        &mut self,\n+        attrs: &[ast::Attribute],\n+        is_crate_node: bool,\n+        source_hir_id: Option<HirId>,\n+    ) -> BuilderPush {\n+        let prev = self.cur;\n+        self.cur = self.sets.list.push(LintSet { specs: FxHashMap::default(), parent: prev });\n+\n         let sess = self.sess;\n         for (attr_index, attr) in attrs.iter().enumerate() {\n             if attr.has_name(sym::automatically_derived) {\n@@ -558,17 +293,7 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                 None => continue,\n                 // This is the only lint level with a `LintExpectationId` that can be created from an attribute\n                 Some(Level::Expect(unstable_id)) if let Some(hir_id) = source_hir_id => {\n-                    let LintExpectationId::Unstable { attr_id, lint_index } = unstable_id\n-                        else { bug!(\"stable id Level::from_attr\") };\n-\n-                    let stable_id = LintExpectationId::Stable {\n-                        hir_id,\n-                        attr_index: attr_index.try_into().unwrap(),\n-                        lint_index,\n-                        // we pass the previous unstable attr_id such that we can trace the ast id when building a map\n-                        // to go from unstable to stable id.\n-                        attr_id: Some(attr_id),\n-                    };\n+                    let stable_id = self.create_stable_id(unstable_id, hir_id, attr_index);\n \n                     Level::Expect(stable_id)\n                 }\n@@ -683,27 +408,21 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                                 [lint] => *lint == LintId::of(UNFULFILLED_LINT_EXPECTATIONS),\n                                 _ => false,\n                             };\n-                            self.provider.push_expectation(\n+                            self.lint_expectations.push((\n                                 expect_id,\n                                 LintExpectation::new(\n                                     reason,\n                                     sp,\n                                     is_unfulfilled_lint_expectations,\n                                     tool_name,\n                                 ),\n-                            );\n+                            ));\n                         }\n-                        let src = LintLevelSource::Node {\n-                            name: meta_item\n-                                .path\n-                                .segments\n-                                .last()\n-                                .expect(\"empty lint name\")\n-                                .ident\n-                                .name,\n-                            span: sp,\n+                        let src = LintLevelSource::Node(\n+                            meta_item.path.segments.last().expect(\"empty lint name\").ident.name,\n+                            sp,\n                             reason,\n-                        };\n+                        );\n                         for &id in *ids {\n                             if self.check_gated_lint(id, attr.span) {\n                                 self.insert_spec(id, (level, src));\n@@ -716,26 +435,31 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                             Ok(ids) => {\n                                 let complete_name =\n                                     &format!(\"{}::{}\", tool_ident.unwrap().name, name);\n-                                let src = LintLevelSource::Node {\n-                                    name: Symbol::intern(complete_name),\n-                                    span: sp,\n+                                let src = LintLevelSource::Node(\n+                                    Symbol::intern(complete_name),\n+                                    sp,\n                                     reason,\n-                                };\n+                                );\n                                 for &id in ids {\n                                     if self.check_gated_lint(id, attr.span) {\n                                         self.insert_spec(id, (level, src));\n                                     }\n                                 }\n                                 if let Level::Expect(expect_id) = level {\n-                                    self.provider.push_expectation(\n+                                    self.lint_expectations.push((\n                                         expect_id,\n                                         LintExpectation::new(reason, sp, false, tool_name),\n-                                    );\n+                                    ));\n                                 }\n                             }\n                             Err((Some(ids), ref new_lint_name)) => {\n                                 let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                                let (lvl, src) = self.provider.get_lint_level(lint, &sess);\n+                                let (lvl, src) = self.sets.get_lint_level(\n+                                    lint,\n+                                    self.cur,\n+                                    Some(self.current_specs()),\n+                                    &sess,\n+                                );\n                                 struct_lint_level(\n                                     self.sess,\n                                     lint,\n@@ -759,19 +483,19 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                                     },\n                                 );\n \n-                                let src = LintLevelSource::Node {\n-                                    name: Symbol::intern(&new_lint_name),\n-                                    span: sp,\n+                                let src = LintLevelSource::Node(\n+                                    Symbol::intern(&new_lint_name),\n+                                    sp,\n                                     reason,\n-                                };\n+                                );\n                                 for id in ids {\n                                     self.insert_spec(*id, (level, src));\n                                 }\n                                 if let Level::Expect(expect_id) = level {\n-                                    self.provider.push_expectation(\n+                                    self.lint_expectations.push((\n                                         expect_id,\n                                         LintExpectation::new(reason, sp, false, tool_name),\n-                                    );\n+                                    ));\n                                 }\n                             }\n                             Err((None, _)) => {\n@@ -797,7 +521,12 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n \n                     CheckLintNameResult::Warning(msg, renamed) => {\n                         let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                        let (renamed_lint_level, src) = self.provider.get_lint_level(lint, &sess);\n+                        let (renamed_lint_level, src) = self.sets.get_lint_level(\n+                            lint,\n+                            self.cur,\n+                            Some(self.current_specs()),\n+                            &sess,\n+                        );\n                         struct_lint_level(\n                             self.sess,\n                             lint,\n@@ -820,7 +549,12 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                     }\n                     CheckLintNameResult::NoLint(suggestion) => {\n                         let lint = builtin::UNKNOWN_LINTS;\n-                        let (level, src) = self.provider.get_lint_level(lint, self.sess);\n+                        let (level, src) = self.sets.get_lint_level(\n+                            lint,\n+                            self.cur,\n+                            Some(self.current_specs()),\n+                            self.sess,\n+                        );\n                         struct_lint_level(self.sess, lint, level, src, Some(sp.into()), |lint| {\n                             let name = if let Some(tool_ident) = tool_ident {\n                                 format!(\"{}::{}\", tool_ident.name, name)\n@@ -849,21 +583,17 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                     if let CheckLintNameResult::Ok(ids) =\n                         self.store.check_lint_name(&new_name, None, self.registered_tools)\n                     {\n-                        let src = LintLevelSource::Node {\n-                            name: Symbol::intern(&new_name),\n-                            span: sp,\n-                            reason,\n-                        };\n+                        let src = LintLevelSource::Node(Symbol::intern(&new_name), sp, reason);\n                         for &id in ids {\n                             if self.check_gated_lint(id, attr.span) {\n                                 self.insert_spec(id, (level, src));\n                             }\n                         }\n                         if let Level::Expect(expect_id) = level {\n-                            self.provider.push_expectation(\n+                            self.lint_expectations.push((\n                                 expect_id,\n                                 LintExpectation::new(reason, sp, false, tool_name),\n-                            );\n+                            ));\n                         }\n                     } else {\n                         panic!(\"renamed lint does not exist: {}\", new_name);\n@@ -878,12 +608,13 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                     continue;\n                 }\n \n-                let LintLevelSource::Node { name: lint_attr_name, span: lint_attr_span, .. } = *src else {\n+                let LintLevelSource::Node(lint_attr_name, lint_attr_span, _) = *src else {\n                     continue\n                 };\n \n                 let lint = builtin::UNUSED_ATTRIBUTES;\n-                let (lint_level, lint_src) = self.provider.get_lint_level(lint, &self.sess);\n+                let (lint_level, lint_src) =\n+                    self.sets.get_lint_level(lint, self.cur, Some(self.current_specs()), self.sess);\n                 struct_lint_level(\n                     self.sess,\n                     lint,\n@@ -903,13 +634,32 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n                 break;\n             }\n         }\n+\n+        if self.current_specs().is_empty() {\n+            self.sets.list.pop();\n+            self.cur = prev;\n+        }\n+\n+        BuilderPush { prev, changed: prev != self.cur }\n+    }\n+\n+    fn create_stable_id(\n+        &mut self,\n+        unstable_id: LintExpectationId,\n+        hir_id: HirId,\n+        attr_index: usize,\n+    ) -> LintExpectationId {\n+        let stable_id =\n+            LintExpectationId::Stable { hir_id, attr_index: attr_index as u16, lint_index: None };\n+\n+        self.expectation_id_map.insert(unstable_id, stable_id);\n+\n+        stable_id\n     }\n \n     /// Checks if the lint is gated on a feature that is not enabled.\n     ///\n     /// Returns `true` if the lint's feature is enabled.\n-    // FIXME only emit this once for each attribute, instead of repeating it 4 times for\n-    // pre-expansion lints, post-expansion lints, `shallow_lint_levels_on` and `lint_expectations`.\n     fn check_gated_lint(&self, lint_id: LintId, span: Span) -> bool {\n         if let Some(feature) = lint_id.lint.feature_gate {\n             if !self.sess.features_untracked().enabled(feature) {\n@@ -928,14 +678,19 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n         true\n     }\n \n+    /// Called after `push` when the scope of a set of attributes are exited.\n+    pub fn pop(&mut self, push: BuilderPush) {\n+        self.cur = push.prev;\n+    }\n+\n     /// Find the lint level for a lint.\n-    pub fn lint_level(&self, lint: &'static Lint) -> LevelAndSource {\n-        self.provider.get_lint_level(lint, self.sess)\n+    pub fn lint_level(&self, lint: &'static Lint) -> (Level, LintLevelSource) {\n+        self.sets.get_lint_level(lint, self.cur, None, self.sess)\n     }\n \n     /// Used to emit a lint-related diagnostic based on the current state of\n     /// this lint context.\n-    pub(crate) fn struct_lint(\n+    pub fn struct_lint(\n         &self,\n         lint: &'static Lint,\n         span: Option<MultiSpan>,\n@@ -944,8 +699,141 @@ impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n         let (level, src) = self.lint_level(lint);\n         struct_lint_level(self.sess, lint, level, src, span, decorate)\n     }\n+\n+    /// Registers the ID provided with the current set of lints stored in\n+    /// this context.\n+    pub fn register_id(&mut self, id: HirId) {\n+        self.id_to_set.insert(id, self.cur);\n+    }\n+\n+    fn update_unstable_expectation_ids(&self) {\n+        self.sess.diagnostic().update_unstable_expectation_id(&self.expectation_id_map);\n+    }\n+\n+    pub fn build_map(self) -> LintLevelMap {\n+        LintLevelMap {\n+            sets: self.sets,\n+            id_to_set: self.id_to_set,\n+            lint_expectations: self.lint_expectations,\n+        }\n+    }\n+}\n+\n+struct LintLevelMapBuilder<'tcx> {\n+    levels: LintLevelsBuilder<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl LintLevelMapBuilder<'_> {\n+    fn with_lint_attrs<F>(&mut self, id: hir::HirId, f: F)\n+    where\n+        F: FnOnce(&mut Self),\n+    {\n+        let is_crate_hir = id == hir::CRATE_HIR_ID;\n+        let attrs = self.tcx.hir().attrs(id);\n+        let push = self.levels.push(attrs, is_crate_hir, Some(id));\n+\n+        if push.changed {\n+            self.levels.register_id(id);\n+        }\n+        f(self);\n+        self.levels.pop(push);\n+    }\n+}\n+\n+impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n+    type NestedFilter = nested_filter::All;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.tcx.hir()\n+    }\n+\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        self.with_lint_attrs(param.hir_id, |builder| {\n+            intravisit::walk_param(builder, param);\n+        });\n+    }\n+\n+    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n+        self.with_lint_attrs(it.hir_id(), |builder| {\n+            intravisit::walk_item(builder, it);\n+        });\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n+        self.with_lint_attrs(it.hir_id(), |builder| {\n+            intravisit::walk_foreign_item(builder, it);\n+        })\n+    }\n+\n+    fn visit_stmt(&mut self, e: &'tcx hir::Stmt<'tcx>) {\n+        // We will call `with_lint_attrs` when we walk\n+        // the `StmtKind`. The outer statement itself doesn't\n+        // define the lint levels.\n+        intravisit::walk_stmt(self, e);\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n+        self.with_lint_attrs(e.hir_id, |builder| {\n+            intravisit::walk_expr(builder, e);\n+        })\n+    }\n+\n+    fn visit_expr_field(&mut self, field: &'tcx hir::ExprField<'tcx>) {\n+        self.with_lint_attrs(field.hir_id, |builder| {\n+            intravisit::walk_expr_field(builder, field);\n+        })\n+    }\n+\n+    fn visit_field_def(&mut self, s: &'tcx hir::FieldDef<'tcx>) {\n+        self.with_lint_attrs(s.hir_id, |builder| {\n+            intravisit::walk_field_def(builder, s);\n+        })\n+    }\n+\n+    fn visit_variant(&mut self, v: &'tcx hir::Variant<'tcx>) {\n+        self.with_lint_attrs(v.id, |builder| {\n+            intravisit::walk_variant(builder, v);\n+        })\n+    }\n+\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n+        self.with_lint_attrs(l.hir_id, |builder| {\n+            intravisit::walk_local(builder, l);\n+        })\n+    }\n+\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n+        self.with_lint_attrs(a.hir_id, |builder| {\n+            intravisit::walk_arm(builder, a);\n+        })\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n+        self.with_lint_attrs(trait_item.hir_id(), |builder| {\n+            intravisit::walk_trait_item(builder, trait_item);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n+        self.with_lint_attrs(impl_item.hir_id(), |builder| {\n+            intravisit::walk_impl_item(builder, impl_item);\n+        });\n+    }\n+\n+    fn visit_pat_field(&mut self, field: &'tcx hir::PatField<'tcx>) {\n+        self.with_lint_attrs(field.hir_id, |builder| {\n+            intravisit::walk_pat_field(builder, field);\n+        })\n+    }\n+\n+    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {\n+        self.with_lint_attrs(p.hir_id, |builder| {\n+            intravisit::walk_generic_param(builder, p);\n+        });\n+    }\n }\n \n-pub(crate) fn provide(providers: &mut Providers) {\n-    *providers = Providers { shallow_lint_levels_on, lint_expectations, ..*providers };\n+pub fn provide(providers: &mut Providers) {\n+    providers.lint_levels = lint_levels;\n }"}, {"sha": "752a751f6bcf51cdc9db98629ce8e9d720409abc", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -35,7 +35,6 @@\n #![feature(iter_order_by)]\n #![feature(let_chains)]\n #![cfg_attr(bootstrap, feature(let_else))]\n-#![feature(min_specialization)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "11b2d057a07692fd1fbdee07b1b6bc01ac2e03dd", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -92,7 +92,7 @@ pub enum LintExpectationId {\n     /// stable and can be cached. The additional index ensures that nodes with\n     /// several expectations can correctly match diagnostics to the individual\n     /// expectation.\n-    Stable { hir_id: HirId, attr_index: u16, lint_index: Option<u16>, attr_id: Option<AttrId> },\n+    Stable { hir_id: HirId, attr_index: u16, lint_index: Option<u16> },\n }\n \n impl LintExpectationId {\n@@ -116,31 +116,13 @@ impl LintExpectationId {\n \n         *lint_index = new_lint_index\n     }\n-\n-    /// Prepares the id for hashing. Removes references to the ast.\n-    /// Should only be called when the id is stable.\n-    pub fn normalize(self) -> Self {\n-        match self {\n-            Self::Stable { hir_id, attr_index, lint_index, .. } => {\n-                Self::Stable { hir_id, attr_index, lint_index, attr_id: None }\n-            }\n-            Self::Unstable { .. } => {\n-                unreachable!(\"`normalize` called when `ExpectationId` is unstable\")\n-            }\n-        }\n-    }\n }\n \n impl<HCX: rustc_hir::HashStableContext> HashStable<HCX> for LintExpectationId {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         match self {\n-            LintExpectationId::Stable {\n-                hir_id,\n-                attr_index,\n-                lint_index: Some(lint_index),\n-                attr_id: _,\n-            } => {\n+            LintExpectationId::Stable { hir_id, attr_index, lint_index: Some(lint_index) } => {\n                 hir_id.hash_stable(hcx, hasher);\n                 attr_index.hash_stable(hcx, hasher);\n                 lint_index.hash_stable(hcx, hasher);\n@@ -160,12 +142,9 @@ impl<HCX: rustc_hir::HashStableContext> ToStableHashKey<HCX> for LintExpectation\n     #[inline]\n     fn to_stable_hash_key(&self, _: &HCX) -> Self::KeyType {\n         match self {\n-            LintExpectationId::Stable {\n-                hir_id,\n-                attr_index,\n-                lint_index: Some(lint_index),\n-                attr_id: _,\n-            } => (*hir_id, *attr_index, *lint_index),\n+            LintExpectationId::Stable { hir_id, attr_index, lint_index: Some(lint_index) } => {\n+                (*hir_id, *attr_index, *lint_index)\n+            }\n             _ => {\n                 unreachable!(\"HashStable should only be called for a filled `LintExpectationId`\")\n             }"}, {"sha": "1fa0c6bababe4db2a22d457ff51b198114598666", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -62,7 +62,7 @@ use crate::ty::TyCtxt;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_hir::definitions::DefPathHash;\n-use rustc_hir::{HirId, ItemLocalId};\n+use rustc_hir::HirId;\n use rustc_query_system::dep_graph::FingerprintStyle;\n use rustc_span::symbol::Symbol;\n use std::hash::Hash;\n@@ -280,7 +280,7 @@ impl DepNodeExt for DepNode {\n         let kind = dep_kind_from_label_string(label)?;\n \n         match kind.fingerprint_style(tcx) {\n-            FingerprintStyle::Opaque | FingerprintStyle::HirId => Err(()),\n+            FingerprintStyle::Opaque => Err(()),\n             FingerprintStyle::Unit => Ok(DepNode::new_no_params(tcx, kind)),\n             FingerprintStyle::DefPathHash => {\n                 Ok(DepNode::from_def_path_hash(tcx, def_path_hash, kind))\n@@ -408,7 +408,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for (DefId, DefId) {\n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for HirId {\n     #[inline(always)]\n     fn fingerprint_style() -> FingerprintStyle {\n-        FingerprintStyle::HirId\n+        FingerprintStyle::Opaque\n     }\n \n     // We actually would not need to specialize the implementation of this\n@@ -417,36 +417,10 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for HirId {\n     #[inline(always)]\n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let HirId { owner, local_id } = *self;\n-        let def_path_hash = tcx.def_path_hash(owner.to_def_id());\n-        Fingerprint::new(\n-            // `owner` is local, so is completely defined by the local hash\n-            def_path_hash.local_hash(),\n-            local_id.as_u32().into(),\n-        )\n-    }\n \n-    #[inline(always)]\n-    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n-        let HirId { owner, local_id } = *self;\n-        format!(\"{}.{}\", tcx.def_path_str(owner.to_def_id()), local_id.as_u32())\n-    }\n+        let def_path_hash = tcx.def_path_hash(owner.to_def_id());\n+        let local_id = Fingerprint::from_smaller_hash(local_id.as_u32().into());\n \n-    #[inline(always)]\n-    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        if dep_node.kind.fingerprint_style(tcx) == FingerprintStyle::HirId {\n-            let (local_hash, local_id) = Fingerprint::from(dep_node.hash).as_value();\n-            let def_path_hash = DefPathHash::new(tcx.sess.local_stable_crate_id(), local_hash);\n-            let owner = tcx\n-                .def_path_hash_to_def_id(def_path_hash, &mut || {\n-                    panic!(\"Failed to extract HirId: {:?} {}\", dep_node.kind, dep_node.hash)\n-                })\n-                .expect_local();\n-            let local_id = local_id\n-                .try_into()\n-                .unwrap_or_else(|_| panic!(\"local id should be u32, found {:?}\", local_id));\n-            Some(HirId { owner, local_id: ItemLocalId::from_u32(local_id) })\n-        } else {\n-            None\n-        }\n+        def_path_hash.0.combine(local_id)\n     }\n }"}, {"sha": "2f45222de47280c6d2b4cea1753cefc53c988a6e", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 124, "deletions": 98, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -1,19 +1,20 @@\n use std::cmp;\n \n use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::{Diagnostic, DiagnosticId, LintDiagnosticBuilder, MultiSpan};\n use rustc_hir::HirId;\n+use rustc_index::vec::IndexVec;\n+use rustc_query_system::ich::StableHashingContext;\n use rustc_session::lint::{\n     builtin::{self, FORBIDDEN_LINT_GROUPS},\n-    FutureIncompatibilityReason, Level, Lint, LintId,\n+    FutureIncompatibilityReason, Level, Lint, LintExpectationId, LintId,\n };\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::{DesugaringKind, ExpnKind};\n use rustc_span::{symbol, Span, Symbol, DUMMY_SP};\n \n-use crate::ty::TyCtxt;\n-\n /// How a lint level was set.\n #[derive(Clone, Copy, PartialEq, Eq, HashStable, Debug)]\n pub enum LintLevelSource {\n@@ -22,12 +23,7 @@ pub enum LintLevelSource {\n     Default,\n \n     /// Lint level was set by an attribute.\n-    Node {\n-        name: Symbol,\n-        span: Span,\n-        /// RFC 2383 reason\n-        reason: Option<Symbol>,\n-    },\n+    Node(Symbol, Span, Option<Symbol> /* RFC 2383 reason */),\n \n     /// Lint level was set by a command-line flag.\n     /// The provided `Level` is the level specified on the command line.\n@@ -39,15 +35,15 @@ impl LintLevelSource {\n     pub fn name(&self) -> Symbol {\n         match *self {\n             LintLevelSource::Default => symbol::kw::Default,\n-            LintLevelSource::Node { name, .. } => name,\n+            LintLevelSource::Node(name, _, _) => name,\n             LintLevelSource::CommandLine(name, _) => name,\n         }\n     }\n \n     pub fn span(&self) -> Span {\n         match *self {\n             LintLevelSource::Default => DUMMY_SP,\n-            LintLevelSource::Node { span, .. } => span,\n+            LintLevelSource::Node(_, span, _) => span,\n             LintLevelSource::CommandLine(_, _) => DUMMY_SP,\n         }\n     }\n@@ -56,115 +52,145 @@ impl LintLevelSource {\n /// A tuple of a lint level and its source.\n pub type LevelAndSource = (Level, LintLevelSource);\n \n-/// Return type for the `shallow_lint_levels_on` query.\n-///\n-/// This map represents the set of allowed lints and allowance levels given\n-/// by the attributes for *a single HirId*.\n-#[derive(Default, Debug, HashStable)]\n-pub struct ShallowLintLevelMap {\n+#[derive(Debug, HashStable)]\n+pub struct LintLevelSets {\n+    pub list: IndexVec<LintStackIndex, LintSet>,\n+    pub lint_cap: Level,\n+}\n+\n+rustc_index::newtype_index! {\n+    #[derive(HashStable)]\n+    pub struct LintStackIndex {\n+        const COMMAND_LINE = 0,\n+    }\n+}\n+\n+#[derive(Debug, HashStable)]\n+pub struct LintSet {\n+    // -A,-W,-D flags, a `Symbol` for the flag itself and `Level` for which\n+    // flag.\n     pub specs: FxHashMap<LintId, LevelAndSource>,\n+\n+    pub parent: LintStackIndex,\n }\n \n-/// From an initial level and source, verify the effect of special annotations:\n-/// `warnings` lint level and lint caps.\n-///\n-/// The return of this function is suitable for diagnostics.\n-pub fn reveal_actual_level(\n-    level: Option<Level>,\n-    src: &mut LintLevelSource,\n-    sess: &Session,\n-    lint: LintId,\n-    probe_for_lint_level: impl FnOnce(LintId) -> (Option<Level>, LintLevelSource),\n-) -> Level {\n-    // If `level` is none then we actually assume the default level for this lint.\n-    let mut level = level.unwrap_or_else(|| lint.lint.default_level(sess.edition()));\n-\n-    // If we're about to issue a warning, check at the last minute for any\n-    // directives against the warnings \"lint\". If, for example, there's an\n-    // `allow(warnings)` in scope then we want to respect that instead.\n-    //\n-    // We exempt `FORBIDDEN_LINT_GROUPS` from this because it specifically\n-    // triggers in cases (like #80988) where you have `forbid(warnings)`,\n-    // and so if we turned that into an error, it'd defeat the purpose of the\n-    // future compatibility warning.\n-    if level == Level::Warn && lint != LintId::of(FORBIDDEN_LINT_GROUPS) {\n-        let (warnings_level, warnings_src) = probe_for_lint_level(LintId::of(builtin::WARNINGS));\n-        if let Some(configured_warning_level) = warnings_level {\n-            if configured_warning_level != Level::Warn {\n-                level = configured_warning_level;\n-                *src = warnings_src;\n+impl LintLevelSets {\n+    pub fn new() -> Self {\n+        LintLevelSets { list: IndexVec::new(), lint_cap: Level::Forbid }\n+    }\n+\n+    pub fn get_lint_level(\n+        &self,\n+        lint: &'static Lint,\n+        idx: LintStackIndex,\n+        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n+        sess: &Session,\n+    ) -> LevelAndSource {\n+        let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx, aux);\n+\n+        // If `level` is none then we actually assume the default level for this\n+        // lint.\n+        let mut level = level.unwrap_or_else(|| lint.default_level(sess.edition()));\n+\n+        // If we're about to issue a warning, check at the last minute for any\n+        // directives against the warnings \"lint\". If, for example, there's an\n+        // `allow(warnings)` in scope then we want to respect that instead.\n+        //\n+        // We exempt `FORBIDDEN_LINT_GROUPS` from this because it specifically\n+        // triggers in cases (like #80988) where you have `forbid(warnings)`,\n+        // and so if we turned that into an error, it'd defeat the purpose of the\n+        // future compatibility warning.\n+        if level == Level::Warn && LintId::of(lint) != LintId::of(FORBIDDEN_LINT_GROUPS) {\n+            let (warnings_level, warnings_src) =\n+                self.get_lint_id_level(LintId::of(builtin::WARNINGS), idx, aux);\n+            if let Some(configured_warning_level) = warnings_level {\n+                if configured_warning_level != Level::Warn {\n+                    level = configured_warning_level;\n+                    src = warnings_src;\n+                }\n             }\n         }\n-    }\n \n-    // Ensure that we never exceed the `--cap-lints` argument unless the source is a --force-warn\n-    level = if let LintLevelSource::CommandLine(_, Level::ForceWarn(_)) = src {\n-        level\n-    } else {\n-        cmp::min(level, sess.opts.lint_cap.unwrap_or(Level::Forbid))\n-    };\n+        // Ensure that we never exceed the `--cap-lints` argument\n+        // unless the source is a --force-warn\n+        level = if let LintLevelSource::CommandLine(_, Level::ForceWarn(_)) = src {\n+            level\n+        } else {\n+            cmp::min(level, self.lint_cap)\n+        };\n+\n+        if let Some(driver_level) = sess.driver_lint_caps.get(&LintId::of(lint)) {\n+            // Ensure that we never exceed driver level.\n+            level = cmp::min(*driver_level, level);\n+        }\n \n-    if let Some(driver_level) = sess.driver_lint_caps.get(&lint) {\n-        // Ensure that we never exceed driver level.\n-        level = cmp::min(*driver_level, level);\n+        (level, src)\n     }\n \n-    level\n-}\n-\n-impl ShallowLintLevelMap {\n-    /// Perform a deep probe in the HIR tree looking for the actual level for the lint.\n-    /// This lint level is not usable for diagnostics, it needs to be corrected by\n-    /// `reveal_actual_level` beforehand.\n-    fn probe_for_lint_level(\n+    pub fn get_lint_id_level(\n         &self,\n-        tcx: TyCtxt<'_>,\n         id: LintId,\n-        start: HirId,\n+        mut idx: LintStackIndex,\n+        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n     ) -> (Option<Level>, LintLevelSource) {\n-        if let Some(&(level, src)) = self.specs.get(&id) {\n-            return (Some(level), src);\n+        if let Some(specs) = aux {\n+            if let Some(&(level, src)) = specs.get(&id) {\n+                return (Some(level), src);\n+            }\n         }\n-\n-        for (parent, _) in tcx.hir().parent_iter(start) {\n-            let specs = tcx.shallow_lint_levels_on(parent);\n-            if let Some(&(level, src)) = specs.specs.get(&id) {\n+        loop {\n+            let LintSet { ref specs, parent } = self.list[idx];\n+            if let Some(&(level, src)) = specs.get(&id) {\n                 return (Some(level), src);\n             }\n+            if idx == COMMAND_LINE {\n+                return (None, LintLevelSource::Default);\n+            }\n+            idx = parent;\n         }\n-        (None, LintLevelSource::Default)\n     }\n+}\n+\n+#[derive(Debug)]\n+pub struct LintLevelMap {\n+    /// This is a collection of lint expectations as described in RFC 2383, that\n+    /// can be fulfilled during this compilation session. This means that at least\n+    /// one expected lint is currently registered in the lint store.\n+    ///\n+    /// The [`LintExpectationId`] is stored as a part of the [`Expect`](Level::Expect)\n+    /// lint level.\n+    pub lint_expectations: Vec<(LintExpectationId, LintExpectation)>,\n+    pub sets: LintLevelSets,\n+    pub id_to_set: FxHashMap<HirId, LintStackIndex>,\n+}\n \n-    /// Fetch and return the user-visible lint level for the given lint at the given HirId.\n-    pub fn lint_level_id_at_node(\n+impl LintLevelMap {\n+    /// If the `id` was previously registered with `register_id` when building\n+    /// this `LintLevelMap` this returns the corresponding lint level and source\n+    /// of the lint level for the lint provided.\n+    ///\n+    /// If the `id` was not previously registered, returns `None`. If `None` is\n+    /// returned then the parent of `id` should be acquired and this function\n+    /// should be called again.\n+    pub fn level_and_source(\n         &self,\n-        tcx: TyCtxt<'_>,\n-        lint: LintId,\n+        lint: &'static Lint,\n         id: HirId,\n-    ) -> (Level, LintLevelSource) {\n-        let (level, mut src) = self.probe_for_lint_level(tcx, lint, id);\n-        let level = reveal_actual_level(level, &mut src, tcx.sess, lint, |lint| {\n-            self.probe_for_lint_level(tcx, lint, id)\n-        });\n-        debug!(?id, ?level, ?src);\n-        (level, src)\n+        session: &Session,\n+    ) -> Option<LevelAndSource> {\n+        self.id_to_set.get(&id).map(|idx| self.sets.get_lint_level(lint, *idx, None, session))\n     }\n }\n \n-impl TyCtxt<'_> {\n-    /// Fetch and return the user-visible lint level for the given lint at the given HirId.\n-    pub fn lint_level_at_node(self, lint: &'static Lint, id: HirId) -> (Level, LintLevelSource) {\n-        self.shallow_lint_levels_on(id).lint_level_id_at_node(self, LintId::of(lint), id)\n-    }\n+impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n+    #[inline]\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        let LintLevelMap { ref sets, ref id_to_set, ref lint_expectations } = *self;\n \n-    /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n-    /// It stops at `bound` and just returns it if reached.\n-    pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {\n-        let hir = self.hir();\n-        while id != bound && self.shallow_lint_levels_on(id).specs.is_empty() {\n-            id = hir.get_parent_node(id)\n-        }\n-        id\n+        id_to_set.hash_stable(hcx, hasher);\n+        lint_expectations.hash_stable(hcx, hasher);\n+\n+        hcx.while_hashing_spans(true, |hcx| sets.hash_stable(hcx, hasher))\n     }\n }\n \n@@ -235,11 +261,11 @@ pub fn explain_lint_level_source(\n                 ));\n             }\n         }\n-        LintLevelSource::Node { name: lint_attr_name, span, reason, .. } => {\n+        LintLevelSource::Node(lint_attr_name, src, reason) => {\n             if let Some(rationale) = reason {\n                 err.note(rationale.as_str());\n             }\n-            err.span_note_once(span, \"the lint level is defined here\");\n+            err.span_note_once(src, \"the lint level is defined here\");\n             if lint_attr_name.as_str() != name {\n                 let level_str = level.as_str();\n                 err.note_once(&format!("}, {"sha": "7ea8c9ed3d3132dffca26331c70d7023d6a085c9", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -274,14 +274,10 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query shallow_lint_levels_on(key: HirId) -> rustc_middle::lint::ShallowLintLevelMap {\n+    query lint_levels(_: ()) -> LintLevelMap {\n         arena_cache\n-        desc { |tcx| \"looking up lint levels for `{}`\", key }\n-    }\n-\n-    query lint_expectations(_: ()) -> Vec<(LintExpectationId, LintExpectation)> {\n-        arena_cache\n-        desc { \"computing `#[expect]`ed lints in this crate\" }\n+        eval_always\n+        desc { \"computing the lint levels for items in this crate\" }\n     }\n \n     query parent_module_from_def_id(key: LocalDefId) -> LocalDefId {"}, {"sha": "8c44f4a98df5d33c0728199f3d774dae7ce32e2e", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -4,7 +4,7 @@ use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKind, DepKindStruct};\n use crate::hir::place::Place as HirPlace;\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n-use crate::lint::struct_lint_level;\n+use crate::lint::{struct_lint_level, LintLevelSource};\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::resolve_lifetime;\n use crate::middle::stability;\n@@ -54,7 +54,7 @@ use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{CrateType, OutputFilenames};\n use rustc_session::cstore::CrateStoreDyn;\n use rustc_session::errors::TargetDataLayoutErrorsWrapper;\n-use rustc_session::lint::Lint;\n+use rustc_session::lint::{Level, Lint};\n use rustc_session::Limit;\n use rustc_session::Session;\n use rustc_span::def_id::{DefPathHash, StableCrateId};\n@@ -2813,6 +2813,44 @@ impl<'tcx> TyCtxt<'tcx> {\n         iter.intern_with(|xs| self.intern_bound_variable_kinds(xs))\n     }\n \n+    /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n+    /// It stops at `bound` and just returns it if reached.\n+    pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {\n+        let hir = self.hir();\n+        loop {\n+            if id == bound {\n+                return bound;\n+            }\n+\n+            if hir.attrs(id).iter().any(|attr| Level::from_attr(attr).is_some()) {\n+                return id;\n+            }\n+            let next = hir.get_parent_node(id);\n+            if next == id {\n+                bug!(\"lint traversal reached the root of the crate\");\n+            }\n+            id = next;\n+        }\n+    }\n+\n+    pub fn lint_level_at_node(\n+        self,\n+        lint: &'static Lint,\n+        mut id: hir::HirId,\n+    ) -> (Level, LintLevelSource) {\n+        let sets = self.lint_levels(());\n+        loop {\n+            if let Some(pair) = sets.level_and_source(lint, id, self.sess) {\n+                return pair;\n+            }\n+            let next = self.hir().get_parent_node(id);\n+            if next == id {\n+                bug!(\"lint traversal reached the root of the crate\");\n+            }\n+            id = next;\n+        }\n+    }\n+\n     /// Emit a lint at `span` from a lint struct (some type that implements `DecorateLint`,\n     /// typically generated by `#[derive(LintDiagnostic)]`).\n     pub fn emit_spanned_lint("}, {"sha": "00da260b1dc36f726550082263ace607f2555075", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -1,6 +1,6 @@\n use crate::dep_graph;\n use crate::infer::canonical::{self, Canonical};\n-use crate::lint::LintExpectation;\n+use crate::lint::LintLevelMap;\n use crate::metadata::ModChild;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n@@ -44,14 +44,12 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n-use rustc_hir::hir_id::HirId;\n use rustc_hir::lang_items::{LangItem, LanguageItems};\n use rustc_hir::{Crate, ItemLocalId, TraitCandidate};\n use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::cstore::{CrateDepKind, CrateSource};\n use rustc_session::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLib};\n-use rustc_session::lint::LintExpectationId;\n use rustc_session::utils::NativeLibKind;\n use rustc_session::Limits;\n use rustc_span::symbol::Symbol;"}, {"sha": "49175e97f41711407d452e8f6928d63e26438ad4", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -1,7 +1,6 @@\n //! Defines the set of legal keys that can be used in queries.\n \n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::hir_id::HirId;\n use rustc_middle::infer::canonical::Canonical;\n use rustc_middle::mir;\n use rustc_middle::traits;\n@@ -544,19 +543,3 @@ impl<'tcx> Key for (Ty<'tcx>, ty::ValTree<'tcx>) {\n         DUMMY_SP\n     }\n }\n-\n-impl Key for HirId {\n-    #[inline(always)]\n-    fn query_crate_is_local(&self) -> bool {\n-        true\n-    }\n-\n-    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n-        tcx.hir().span(*self)\n-    }\n-\n-    #[inline(always)]\n-    fn key_as_def_id(&self) -> Option<DefId> {\n-        None\n-    }\n-}"}, {"sha": "342d95ca490ea276a5ecd2dfb3b2bc6aa3b44f1f", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -67,8 +67,6 @@ impl<T: DepContext> HasDepContext for T {\n pub enum FingerprintStyle {\n     /// The fingerprint is actually a DefPathHash.\n     DefPathHash,\n-    /// The fingerprint is actually a HirId.\n-    HirId,\n     /// Query key was `()` or equivalent, so fingerprint is just zero.\n     Unit,\n     /// Some opaque hash.\n@@ -79,9 +77,7 @@ impl FingerprintStyle {\n     #[inline]\n     pub fn reconstructible(self) -> bool {\n         match self {\n-            FingerprintStyle::DefPathHash | FingerprintStyle::Unit | FingerprintStyle::HirId => {\n-                true\n-            }\n+            FingerprintStyle::DefPathHash | FingerprintStyle::Unit => true,\n             FingerprintStyle::Opaque => false,\n         }\n     }"}, {"sha": "9b646060adfd9818153df8ffe07225a224b48db1", "filename": "src/test/ui/feature-gates/feature-gate-non_exhaustive_omitted_patterns_lint.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.rs?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -3,11 +3,9 @@\n #![deny(non_exhaustive_omitted_patterns)]\n //~^ WARNING unknown lint: `non_exhaustive_omitted_patterns`\n //~| WARNING unknown lint: `non_exhaustive_omitted_patterns`\n-//~| WARNING unknown lint: `non_exhaustive_omitted_patterns`\n #![allow(non_exhaustive_omitted_patterns)]\n //~^ WARNING unknown lint: `non_exhaustive_omitted_patterns`\n //~| WARNING unknown lint: `non_exhaustive_omitted_patterns`\n-//~| WARNING unknown lint: `non_exhaustive_omitted_patterns`\n \n fn main() {\n     enum Foo {\n@@ -19,8 +17,6 @@ fn main() {\n     //~| WARNING unknown lint: `non_exhaustive_omitted_patterns`\n     //~| WARNING unknown lint: `non_exhaustive_omitted_patterns`\n     //~| WARNING unknown lint: `non_exhaustive_omitted_patterns`\n-    //~| WARNING unknown lint: `non_exhaustive_omitted_patterns`\n-    //~| WARNING unknown lint: `non_exhaustive_omitted_patterns`\n     match Foo::A {\n         Foo::A => {}\n         Foo::B => {}\n@@ -35,5 +31,4 @@ fn main() {\n     }\n     //~^^^ WARNING unknown lint: `non_exhaustive_omitted_patterns`\n     //~| WARNING unknown lint: `non_exhaustive_omitted_patterns`\n-    //~| WARNING unknown lint: `non_exhaustive_omitted_patterns`\n }"}, {"sha": "3de08e215dada61894269d001e000d7a9670d0fb", "filename": "src/test/ui/feature-gates/feature-gate-non_exhaustive_omitted_patterns_lint.stderr", "status": "modified", "additions": 11, "deletions": 61, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-non_exhaustive_omitted_patterns_lint.stderr?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -10,7 +10,7 @@ LL | #![deny(non_exhaustive_omitted_patterns)]\n    = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n \n warning: unknown lint: `non_exhaustive_omitted_patterns`\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:7:1\n+  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:6:1\n    |\n LL | #![allow(non_exhaustive_omitted_patterns)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -20,7 +20,7 @@ LL | #![allow(non_exhaustive_omitted_patterns)]\n    = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n \n warning: unknown lint: `non_exhaustive_omitted_patterns`\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:17:5\n+  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:15:5\n    |\n LL |     #[allow(non_exhaustive_omitted_patterns)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -30,7 +30,7 @@ LL |     #[allow(non_exhaustive_omitted_patterns)]\n    = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n \n warning: unknown lint: `non_exhaustive_omitted_patterns`\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:17:5\n+  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:15:5\n    |\n LL |     #[allow(non_exhaustive_omitted_patterns)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -40,7 +40,7 @@ LL |     #[allow(non_exhaustive_omitted_patterns)]\n    = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n \n warning: unknown lint: `non_exhaustive_omitted_patterns`\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:33:9\n+  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:29:9\n    |\n LL |         #[warn(non_exhaustive_omitted_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -60,7 +60,7 @@ LL | #![deny(non_exhaustive_omitted_patterns)]\n    = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n \n warning: unknown lint: `non_exhaustive_omitted_patterns`\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:7:1\n+  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:6:1\n    |\n LL | #![allow(non_exhaustive_omitted_patterns)]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -70,7 +70,7 @@ LL | #![allow(non_exhaustive_omitted_patterns)]\n    = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n \n warning: unknown lint: `non_exhaustive_omitted_patterns`\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:17:5\n+  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:15:5\n    |\n LL |     #[allow(non_exhaustive_omitted_patterns)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -80,7 +80,7 @@ LL |     #[allow(non_exhaustive_omitted_patterns)]\n    = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n \n warning: unknown lint: `non_exhaustive_omitted_patterns`\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:17:5\n+  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:15:5\n    |\n LL |     #[allow(non_exhaustive_omitted_patterns)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -90,7 +90,7 @@ LL |     #[allow(non_exhaustive_omitted_patterns)]\n    = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n \n warning: unknown lint: `non_exhaustive_omitted_patterns`\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:33:9\n+  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:29:9\n    |\n LL |         #[warn(non_exhaustive_omitted_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -100,13 +100,13 @@ LL |         #[warn(non_exhaustive_omitted_patterns)]\n    = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n \n error[E0004]: non-exhaustive patterns: `Foo::C` not covered\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:24:11\n+  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:20:11\n    |\n LL |     match Foo::A {\n    |           ^^^^^^ pattern `Foo::C` not covered\n    |\n note: `Foo` defined here\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:14:15\n+  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:12:15\n    |\n LL |     enum Foo {\n    |          ---\n@@ -119,56 +119,6 @@ LL ~         Foo::B => {}\n LL +         Foo::C => todo!()\n    |\n \n-warning: unknown lint: `non_exhaustive_omitted_patterns`\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:3:1\n-   |\n-LL | #![deny(non_exhaustive_omitted_patterns)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: the `non_exhaustive_omitted_patterns` lint is unstable\n-   = note: see issue #89554 <https://github.com/rust-lang/rust/issues/89554> for more information\n-   = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n-\n-warning: unknown lint: `non_exhaustive_omitted_patterns`\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:7:1\n-   |\n-LL | #![allow(non_exhaustive_omitted_patterns)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: the `non_exhaustive_omitted_patterns` lint is unstable\n-   = note: see issue #89554 <https://github.com/rust-lang/rust/issues/89554> for more information\n-   = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n-\n-warning: unknown lint: `non_exhaustive_omitted_patterns`\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:17:5\n-   |\n-LL |     #[allow(non_exhaustive_omitted_patterns)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: the `non_exhaustive_omitted_patterns` lint is unstable\n-   = note: see issue #89554 <https://github.com/rust-lang/rust/issues/89554> for more information\n-   = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n-\n-warning: unknown lint: `non_exhaustive_omitted_patterns`\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:17:5\n-   |\n-LL |     #[allow(non_exhaustive_omitted_patterns)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: the `non_exhaustive_omitted_patterns` lint is unstable\n-   = note: see issue #89554 <https://github.com/rust-lang/rust/issues/89554> for more information\n-   = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n-\n-warning: unknown lint: `non_exhaustive_omitted_patterns`\n-  --> $DIR/feature-gate-non_exhaustive_omitted_patterns_lint.rs:33:9\n-   |\n-LL |         #[warn(non_exhaustive_omitted_patterns)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: the `non_exhaustive_omitted_patterns` lint is unstable\n-   = note: see issue #89554 <https://github.com/rust-lang/rust/issues/89554> for more information\n-   = help: add `#![feature(non_exhaustive_omitted_patterns_lint)]` to the crate attributes to enable\n-\n-error: aborting due to previous error; 15 warnings emitted\n+error: aborting due to previous error; 10 warnings emitted\n \n For more information about this error, try `rustc --explain E0004`."}, {"sha": "06befcbb5117e53fc5ee4bc2df1b533231d2e3c4", "filename": "src/test/ui/lint/rfc-2383-lint-reason/force_warn_expected_lints_fulfilled.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fc43df0333d5862a219f16d294ae38b14b9191d3/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Fforce_warn_expected_lints_fulfilled.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc43df0333d5862a219f16d294ae38b14b9191d3/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Fforce_warn_expected_lints_fulfilled.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Fforce_warn_expected_lints_fulfilled.stderr?ref=fc43df0333d5862a219f16d294ae38b14b9191d3", "patch": "@@ -1,3 +1,11 @@\n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/force_warn_expected_lints_fulfilled.rs:10:5\n+   |\n+LL |     while true {\n+   |     ^^^^^^^^^^ help: use `loop`\n+   |\n+   = note: requested on the command line with `--force-warn while-true`\n+\n warning: unused variable: `x`\n   --> $DIR/force_warn_expected_lints_fulfilled.rs:20:9\n    |\n@@ -28,13 +36,5 @@ LL |     let mut what_does_the_fox_say = \"*ding* *deng* *dung*\";\n    |\n    = note: requested on the command line with `--force-warn unused-mut`\n \n-warning: denote infinite loops with `loop { ... }`\n-  --> $DIR/force_warn_expected_lints_fulfilled.rs:10:5\n-   |\n-LL |     while true {\n-   |     ^^^^^^^^^^ help: use `loop`\n-   |\n-   = note: requested on the command line with `--force-warn while-true`\n-\n warning: 5 warnings emitted\n "}]}