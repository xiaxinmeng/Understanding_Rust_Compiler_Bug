{"sha": "c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyNWRkZjIxZjE4YzNlZWVhZWEyYTRkZmZkNzBkMmY2MTgzMDY4YjU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-08T05:30:39Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-09T18:44:21Z"}, "message": "Merge remote-tracking branch 'origin/master' into gen", "tree": {"sha": "9715e57405ae14bd7877dec129bce733daf72dc1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9715e57405ae14bd7877dec129bce733daf72dc1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "html_url": "https://github.com/rust-lang/rust/commit/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc4ff8f4d169562ff4ae22b94197a191215e6d56", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc4ff8f4d169562ff4ae22b94197a191215e6d56", "html_url": "https://github.com/rust-lang/rust/commit/cc4ff8f4d169562ff4ae22b94197a191215e6d56"}, {"sha": "c5e2051f070c01241f68720a92a0957bcb070597", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5e2051f070c01241f68720a92a0957bcb070597", "html_url": "https://github.com/rust-lang/rust/commit/c5e2051f070c01241f68720a92a0957bcb070597"}], "stats": {"total": 19990, "additions": 17753, "deletions": 2237}, "files": [{"sha": "664b473b2c9d00e9452fe55b55bab6ccc9b15037", "filename": "configure", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/configure", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -437,7 +437,6 @@ opt local-rust 0 \"use an installed rustc rather than downloading a snapshot\"\n opt local-rebuild 0 \"assume local-rust matches the current version, for rebuilds; implies local-rust, and is implied if local-rust already matches the current version\"\n opt llvm-static-stdcpp 0 \"statically link to libstdc++ for LLVM\"\n opt llvm-link-shared 0 \"prefer shared linking to LLVM (llvm-config --link-shared)\"\n-opt llvm-clean-rebuild 0 \"delete LLVM build directory on rebuild\"\n opt rpath 1 \"build rpaths into rustc itself\"\n opt stage0-landing-pads 1 \"enable landing pads during bootstrap with stage0\"\n # This is used by the automation to produce single-target nightlies"}, {"sha": "398b23061eadb787025741e25784083efb8d0978", "filename": "src/Cargo.lock", "status": "modified", "additions": 31, "deletions": 11, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -187,7 +187,7 @@ dependencies = [\n  \"curl 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"docopt 0.8.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"error-chain 0.11.0-rc.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fs2 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -323,7 +323,7 @@ name = \"crates-io\"\n version = \"0.11.0\"\n dependencies = [\n  \"curl 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"error-chain 0.11.0-rc.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -436,6 +436,14 @@ dependencies = [\n  \"backtrace 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"error-chain\"\n+version = \"0.11.0-rc.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"backtrace 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"error_index_generator\"\n version = \"0.0.0\"\n@@ -1132,8 +1140,8 @@ dependencies = [\n  \"lazy_static 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"racer 2.0.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-analysis 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-data 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-analysis 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-vfs 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustfmt-nightly 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1147,23 +1155,25 @@ dependencies = [\n \n [[package]]\n name = \"rls-analysis\"\n-version = \"0.4.5\"\n+version = \"0.6.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"derive-new 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-data 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n name = \"rls-data\"\n-version = \"0.9.0\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"serde_derive 1.0.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1242,6 +1252,13 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_apfloat\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_bitflags 0.0.0\",\n+]\n+\n [[package]]\n name = \"rustc_asan\"\n version = \"0.0.0\"\n@@ -1299,6 +1316,7 @@ dependencies = [\n name = \"rustc_const_math\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rustc_apfloat 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n ]\n@@ -1496,10 +1514,11 @@ name = \"rustc_save_analysis\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rls-data 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rls-data 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_data_structures 0.0.0\",\n  \"rustc_typeck 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -1509,11 +1528,11 @@ dependencies = [\n name = \"rustc_trans\"\n version = \"0.0.0\"\n dependencies = [\n- \"crossbeam 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"num_cpus 1.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"owning_ref 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2145,6 +2164,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum env_logger 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3ddf21e73e016298f5cb37d6ef8e8da8e39f91f9ec8b0df44b7deb16a9f8cd5b\"\n \"checksum error-chain 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9435d864e017c3c6afeac1654189b06cdb491cf2ff73dbf0d73b0f292f42ff8\"\n+\"checksum error-chain 0.11.0-rc.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"38d3a55d9a7a456748f2a3912c0941a5d9a68006eb15b3c3c9836b8420dc102d\"\n \"checksum filetime 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5363ab8e4139b8568a6237db5248646e5a8a2f89bd5ccb02092182b11fd3e922\"\n \"checksum flate2 0.2.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36df0166e856739905cd3d7e0b210fe818592211a008862599845e012d8d304c\"\n \"checksum fnv 1.0.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6cc484842f1e2884faf56f529f960cc12ad8c71ce96cc7abba0a067c98fee344\"\n@@ -2209,8 +2229,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum regex 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1731164734096285ec2a5ec7fea5248ae2f5485b3feeb0115af4fda2183b2d1b\"\n \"checksum regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f9ec002c35e86791825ed294b50008eea9ddfc8def4420124fbc6b08db834957\"\n \"checksum regex-syntax 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ad890a5eef7953f55427c50575c680c42841653abd2b028b68cd223d157f62db\"\n-\"checksum rls-analysis 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0127cfae9c726461facbbbc8327e782adf8afd61f7fcc6adf8ea9ad8fc428ed0\"\n-\"checksum rls-data 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f274ec7f966337dc2601fe9bde060b551d1293c277af782dc65cd7200ca070c0\"\n+\"checksum rls-analysis 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d2cb40c0371765897ae428b5706bb17135705ad4f6d1b8b6afbaabcf8c9b5cff\"\n+\"checksum rls-data 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"11d339f1888e33e74d8032de0f83c40b2bdaaaf04a8cfc03b32186c3481fb534\"\n \"checksum rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"5d7c7046dc6a92f2ae02ed302746db4382e75131b9ce20ce967259f6b5867a6a\"\n \"checksum rls-vfs 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ffd34691a510938bb67fe0444fb363103c73ffb31c121d1e16bc92d8945ea8ff\"\n \"checksum rustc-demangle 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"3058a43ada2c2d0b92b3ae38007a2d0fa5e9db971be260e0171408a4ff471c95\""}, {"sha": "f6ed4ee91b3c5b66b2ead3cbbdfa5e406f705179", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -188,7 +188,7 @@ fn main() {\n             cmd.arg(\"-Zsave-analysis\");\n             cmd.env(\"RUST_SAVE_ANALYSIS_CONFIG\",\n                     \"{\\\"output_file\\\": null,\\\"full_docs\\\": false,\\\"pub_only\\\": true,\\\n-                     \\\"signatures\\\": false,\\\"borrow_data\\\": false}\");\n+                     \\\"distro_crate\\\": true,\\\"signatures\\\": false,\\\"borrow_data\\\": false}\");\n         }\n \n         // Dealing with rpath here is a little special, so let's go into some"}, {"sha": "811c7df5d9978a002e5764b43d03d2ba36ff929f", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -28,6 +28,7 @@ use check;\n use flags::Subcommand;\n use doc;\n use tool;\n+use native;\n \n pub use Compiler;\n \n@@ -256,7 +257,8 @@ impl<'a> Builder<'a> {\n                 compile::StartupObjects, tool::BuildManifest, tool::Rustbook, tool::ErrorIndex,\n                 tool::UnstableBookGen, tool::Tidy, tool::Linkchecker, tool::CargoTest,\n                 tool::Compiletest, tool::RemoteTestServer, tool::RemoteTestClient,\n-                tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc),\n+                tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc,\n+                native::Llvm),\n             Kind::Test => describe!(check::Tidy, check::Bootstrap, check::DefaultCompiletest,\n                 check::HostCompiletest, check::Crate, check::CrateLibrustc, check::Linkcheck,\n                 check::Cargotest, check::Cargo, check::Rls, check::Docs, check::ErrorIndex,"}, {"sha": "c65f5a9fb48bf6a45c8a7e7737adc641fc0f0b08", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 13, "deletions": 67, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1050,11 +1050,8 @@ impl Step for Crate {\n         dylib_path.insert(0, PathBuf::from(&*builder.sysroot_libdir(compiler, target)));\n         cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n-        if target.contains(\"emscripten\") || build.remote_tested(target) {\n-            cargo.arg(\"--no-run\");\n-        }\n-\n         cargo.arg(\"--\");\n+        cargo.args(&build.flags.cmd.test_args());\n \n         if build.config.quiet_tests {\n             cargo.arg(\"--quiet\");\n@@ -1063,75 +1060,24 @@ impl Step for Crate {\n         let _time = util::timeit();\n \n         if target.contains(\"emscripten\") {\n-            build.run(&mut cargo);\n-            krate_emscripten(build, compiler, target, mode);\n+            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                      build.config.nodejs.as_ref().expect(\"nodejs not configured\"));\n         } else if build.remote_tested(target) {\n-            build.run(&mut cargo);\n-            krate_remote(builder, compiler, target, mode);\n-        } else {\n-            cargo.args(&build.flags.cmd.test_args());\n-            try_run(build, &mut cargo);\n-        }\n-    }\n-}\n-\n-fn krate_emscripten(build: &Build,\n-                    compiler: Compiler,\n-                    target: Interned<String>,\n-                    mode: Mode) {\n-    let out_dir = build.cargo_out(compiler, mode, target);\n-    let tests = find_tests(&out_dir.join(\"deps\"), target);\n-\n-    let nodejs = build.config.nodejs.as_ref().expect(\"nodejs not configured\");\n-    for test in tests {\n-        println!(\"running {}\", test.display());\n-        let mut cmd = Command::new(nodejs);\n-        cmd.arg(&test);\n-        if build.config.quiet_tests {\n-            cmd.arg(\"--quiet\");\n-        }\n-        try_run(build, &mut cmd);\n-    }\n-}\n-\n-fn krate_remote(builder: &Builder,\n-                compiler: Compiler,\n-                target: Interned<String>,\n-                mode: Mode) {\n-    let build = builder.build;\n-    let out_dir = build.cargo_out(compiler, mode, target);\n-    let tests = find_tests(&out_dir.join(\"deps\"), target);\n-\n-    let tool = builder.tool_exe(Tool::RemoteTestClient);\n-    for test in tests {\n-        let mut cmd = Command::new(&tool);\n-        cmd.arg(\"run\")\n-           .arg(&test);\n-        if build.config.quiet_tests {\n-            cmd.arg(\"--quiet\");\n+            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n+                      format!(\"{} run\",\n+                              builder.tool_exe(Tool::RemoteTestClient).display()));\n         }\n-        cmd.args(&build.flags.cmd.test_args());\n-        try_run(build, &mut cmd);\n+        try_run(build, &mut cargo);\n     }\n }\n \n-fn find_tests(dir: &Path, target: Interned<String>) -> Vec<PathBuf> {\n-    let mut dst = Vec::new();\n-    for e in t!(dir.read_dir()).map(|e| t!(e)) {\n-        let file_type = t!(e.file_type());\n-        if !file_type.is_file() {\n-            continue\n-        }\n-        let filename = e.file_name().into_string().unwrap();\n-        if (target.contains(\"windows\") && filename.ends_with(\".exe\")) ||\n-           (!target.contains(\"windows\") && !filename.contains(\".\")) ||\n-           (target.contains(\"emscripten\") &&\n-            filename.ends_with(\".js\") &&\n-            !filename.ends_with(\".asm.js\")) {\n-            dst.push(e.path());\n+fn envify(s: &str) -> String {\n+    s.chars().map(|c| {\n+        match c {\n+            '-' => '_',\n+            c => c,\n         }\n-    }\n-    dst\n+    }).flat_map(|c| c.to_uppercase()).collect()\n }\n \n /// Some test suites are run inside emulators or on remote devices, and most"}, {"sha": "5d898cb716dcf68d48b7426e40d9a6e957190b51", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -62,7 +62,6 @@ pub struct Config {\n     pub llvm_targets: Option<String>,\n     pub llvm_experimental_targets: Option<String>,\n     pub llvm_link_jobs: Option<u32>,\n-    pub llvm_clean_rebuild: bool,\n \n     // rust codegen options\n     pub rust_optimize: bool,\n@@ -203,7 +202,6 @@ struct Llvm {\n     targets: Option<String>,\n     experimental_targets: Option<String>,\n     link_jobs: Option<u32>,\n-    clean_rebuild: Option<bool>,\n }\n \n #[derive(Deserialize, Default, Clone)]\n@@ -352,7 +350,6 @@ impl Config {\n             set(&mut config.llvm_release_debuginfo, llvm.release_debuginfo);\n             set(&mut config.llvm_version_check, llvm.version_check);\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n-            set(&mut config.llvm_clean_rebuild, llvm.clean_rebuild);\n             config.llvm_targets = llvm.targets.clone();\n             config.llvm_experimental_targets = llvm.experimental_targets.clone();\n             config.llvm_link_jobs = llvm.link_jobs;\n@@ -477,7 +474,6 @@ impl Config {\n                 (\"LLVM_VERSION_CHECK\", self.llvm_version_check),\n                 (\"LLVM_STATIC_STDCPP\", self.llvm_static_stdcpp),\n                 (\"LLVM_LINK_SHARED\", self.llvm_link_shared),\n-                (\"LLVM_CLEAN_REBUILD\", self.llvm_clean_rebuild),\n                 (\"OPTIMIZE\", self.rust_optimize),\n                 (\"DEBUG_ASSERTIONS\", self.rust_debug_assertions),\n                 (\"DEBUGINFO\", self.rust_debuginfo),"}, {"sha": "9314135050f016f84b487e8405e814b3dd75affc", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -69,11 +69,6 @@\n # controlled by rustbuild's -j parameter.\n #link-jobs = 0\n \n-# Delete LLVM build directory on LLVM rebuild.\n-# This option defaults to `false` for local development, but CI may want to\n-# always perform clean full builds (possibly accelerated by (s)ccache).\n-#clean-rebuild = false\n-\n # =============================================================================\n # General build configuration options\n # =============================================================================\n@@ -208,7 +203,7 @@\n #codegen-units = 1\n \n # Whether or not debug assertions are enabled for the compiler and standard\n-# library\n+# library. Also enables compilation of debug! and trace! logging macros.\n #debug-assertions = false\n \n # Whether or not debuginfo is emitted"}, {"sha": "ee0eca5d482432853ba2ee66e2ff3f6bef067173", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -48,6 +48,10 @@ impl Step for Llvm {\n         run.path(\"src/llvm\")\n     }\n \n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Llvm { target: run.target })\n+    }\n+\n     /// Compile LLVM for `target`.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n@@ -76,9 +80,6 @@ impl Step for Llvm {\n                 return\n             }\n         }\n-        if build.config.llvm_clean_rebuild {\n-            drop(fs::remove_dir_all(&out_dir));\n-        }\n \n         let _folder = build.fold_output(|| \"llvm\");\n         println!(\"Building LLVM for {}\", target);\n@@ -128,6 +129,15 @@ impl Step for Llvm {\n            .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n            .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n+\n+        // This setting makes the LLVM tools link to the dynamic LLVM library,\n+        // which saves both memory during parallel links and overall disk space\n+        // for the tools.  We don't distribute any of those tools, so this is\n+        // just a local concern.  However, it doesn't work well everywhere.\n+        if target.contains(\"linux-gnu\") || target.contains(\"apple-darwin\") {\n+           cfg.define(\"LLVM_LINK_LLVM_DYLIB\", \"ON\");\n+        }\n+\n         if target.contains(\"msvc\") {\n             cfg.define(\"LLVM_USE_CRT_DEBUG\", \"MT\");\n             cfg.define(\"LLVM_USE_CRT_RELEASE\", \"MT\");\n@@ -154,6 +164,14 @@ impl Step for Llvm {\n             let host = build.llvm_out(build.build).join(\"bin/llvm-tblgen\");\n             cfg.define(\"CMAKE_CROSSCOMPILING\", \"True\")\n                .define(\"LLVM_TABLEGEN\", &host);\n+\n+            if target.contains(\"netbsd\") {\n+               cfg.define(\"CMAKE_SYSTEM_NAME\", \"NetBSD\");\n+            } else if target.contains(\"freebsd\") {\n+               cfg.define(\"CMAKE_SYSTEM_NAME\", \"FreeBSD\");\n+            }\n+\n+            cfg.define(\"LLVM_NATIVE_BUILD\", build.llvm_out(build.build).join(\"build\"));\n         }\n \n         let sanitize_cc = |cc: &Path| {"}, {"sha": "8b4c7f2ac317793b7d978feee70c452bdc2c01e0", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -13,7 +13,6 @@\n extern crate filetime;\n \n use std::fs::File;\n-use std::io;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n use std::{fs, env};\n@@ -211,7 +210,7 @@ pub fn native_lib_boilerplate(src_name: &str,\n \n     let out_dir = env::var_os(\"RUSTBUILD_NATIVE_DIR\").unwrap_or(env::var_os(\"OUT_DIR\").unwrap());\n     let out_dir = PathBuf::from(out_dir).join(out_name);\n-    t!(create_dir_racy(&out_dir));\n+    t!(fs::create_dir_all(&out_dir));\n     if link_name.contains('=') {\n         println!(\"cargo:rustc-link-lib={}\", link_name);\n     } else {\n@@ -260,21 +259,3 @@ fn fail(s: &str) -> ! {\n     println!(\"\\n\\n{}\\n\\n\", s);\n     std::process::exit(1);\n }\n-\n-fn create_dir_racy(path: &Path) -> io::Result<()> {\n-    match fs::create_dir(path) {\n-        Ok(()) => return Ok(()),\n-        Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists => return Ok(()),\n-        Err(ref e) if e.kind() == io::ErrorKind::NotFound => {}\n-        Err(e) => return Err(e),\n-    }\n-    match path.parent() {\n-        Some(p) => try!(create_dir_racy(p)),\n-        None => return Err(io::Error::new(io::ErrorKind::Other, \"failed to create whole tree\")),\n-    }\n-    match fs::create_dir(path) {\n-        Ok(()) => Ok(()),\n-        Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists => Ok(()),\n-        Err(e) => Err(e),\n-    }\n-}"}, {"sha": "8343327c33bf2bfead13365b4fb2703c7388acbb", "filename": "src/ci/docker/dist-i686-freebsd/build-toolchain.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2Fbuild-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2Fbuild-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-i686-freebsd%2Fbuild-toolchain.sh?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -13,7 +13,7 @@ set -ex\n \n ARCH=$1\n BINUTILS=2.25.1\n-GCC=5.3.0\n+GCC=6.4.0\n \n hide_output() {\n   set +x\n@@ -86,7 +86,7 @@ rm -rf freebsd\n # Finally, download and build gcc to target FreeBSD\n mkdir gcc\n cd gcc\n-curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n+curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.gz | tar xzf -\n cd gcc-$GCC\n ./contrib/download_prerequisites\n "}, {"sha": "8343327c33bf2bfead13365b4fb2703c7388acbb", "filename": "src/ci/docker/dist-x86_64-freebsd/build-toolchain.sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2Fbuild-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2Fbuild-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-freebsd%2Fbuild-toolchain.sh?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -13,7 +13,7 @@ set -ex\n \n ARCH=$1\n BINUTILS=2.25.1\n-GCC=5.3.0\n+GCC=6.4.0\n \n hide_output() {\n   set +x\n@@ -86,7 +86,7 @@ rm -rf freebsd\n # Finally, download and build gcc to target FreeBSD\n mkdir gcc\n cd gcc\n-curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.bz2 | tar xjf -\n+curl https://ftp.gnu.org/gnu/gcc/gcc-$GCC/gcc-$GCC.tar.gz | tar xzf -\n cd gcc-$GCC\n ./contrib/download_prerequisites\n "}, {"sha": "d3f339bc15f75c0c8ba7f70a621a7d21a49e3e84", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -67,6 +67,13 @@ else\n     args=\"$args --env SCCACHE_DIR=/sccache --volume $HOME/.cache/sccache:/sccache\"\n fi\n \n+# Run containers as privileged as it should give them access to some more\n+# syscalls such as ptrace and whatnot. In the upgrade to LLVM 5.0 it was\n+# discovered that the leak sanitizer apparently needs these syscalls nowadays so\n+# we'll need `--privileged` for at least the `x86_64-gnu` builder, so this just\n+# goes ahead and sets it for all builders.\n+args=\"$args --privileged\"\n+\n exec docker \\\n   run \\\n   --volume \"$root_dir:/checkout:ro\" \\"}, {"sha": "39fb4e44078124f118794ca89d37d5e6da1ebd6b", "filename": "src/ci/run.sh", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -31,7 +31,6 @@ RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-sccache\"\n RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-manage-submodules\"\n RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-locked-deps\"\n RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-cargo-openssl-static\"\n-RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-llvm-clean-rebuild\"\n \n if [ \"$DIST_SRC\" = \"\" ]; then\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-dist-src\""}, {"sha": "6f1a03dae6bcea44976918186f2d554186b3499c", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1 +1 @@\n-Subproject commit 4ee596df22f8ecaa9a0b2ddc0624b0104540dbf7\n+Subproject commit 6f1a03dae6bcea44976918186f2d554186b3499c"}, {"sha": "f570bcb681771d691aa4fdb8dfcfad1939844bf5", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1 +1 @@\n-Subproject commit f8fd6710399a1a557155cb5be4922fe6a6f694c0\n+Subproject commit f570bcb681771d691aa4fdb8dfcfad1939844bf5"}, {"sha": "7f01aaa3ac113a6e22d1b028f4a3d15ba5eb9de7", "filename": "src/etc/platform-intrinsics/powerpc.json", "status": "modified", "additions": 58, "deletions": 2, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -3,8 +3,15 @@\n     \"intrinsic_prefix\": \"_vec_\",\n     \"llvm_prefix\": \"llvm.ppc.altivec.\",\n     \"number_info\": {\n-        \"unsigned\": {},\n-        \"signed\": {}\n+        \"unsigned\": {\n+            \"kind\" : \"u\",\n+            \"data_type_short\": { \"8\": \"b\", \"16\": \"h\", \"32\": \"w\", \"64\": \"d\" }\n+        },\n+        \"signed\": {\n+            \"kind\" : \"s\",\n+            \"data_type_short\": { \"8\": \"b\", \"16\": \"h\", \"32\": \"w\", \"64\": \"d\" }\n+        },\n+        \"float\": {}\n     },\n     \"width_info\": {\n         \"128\": { \"width\": \"\" }\n@@ -16,6 +23,55 @@\n             \"llvm\": \"vperm\",\n             \"ret\": \"s32\",\n             \"args\": [\"0\", \"0\", \"s8\"]\n+        },\n+        {\n+            \"intrinsic\": \"mradds\",\n+            \"width\": [128],\n+            \"llvm\": \"vmhraddshs\",\n+            \"ret\": \"s16\",\n+            \"args\": [\"0\", \"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"cmpb\",\n+            \"width\": [128],\n+            \"llvm\": \"vcmpbfp\",\n+            \"ret\": \"s32\",\n+            \"args\": [\"f32\", \"f32\"]\n+        },\n+        {\n+            \"intrinsic\": \"cmpeq{0.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vcmpequ{0.data_type_short}\",\n+            \"ret\": \"s(8-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"cmpgt{1.kind}{1.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vcmpgt{1.kind}{1.data_type_short}\",\n+            \"ret\": \"s(8-32)\",\n+            \"args\": [\"0u\", \"1\"]\n+        },\n+        {\n+            \"intrinsic\": \"cmpgt{1.kind}{1.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vcmpgt{1.kind}{1.data_type_short}\",\n+            \"ret\": \"s(8-32)\",\n+            \"args\": [\"0\", \"1\"]\n+        },\n+        {\n+            \"intrinsic\": \"max{0.kind}{0.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vmax{0.kind}{0.data_type_short}\",\n+            \"ret\": \"i(8-32)\",\n+            \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"min{0.kind}{0.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vmin{0.kind}{0.data_type_short}\",\n+            \"ret\": \"i(8-32)\",\n+            \"args\": [\"0\", \"0\"]\n         }\n     ]\n }"}, {"sha": "42111301a9fe899f111a54c3b83dec7567ca4717", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -215,6 +215,7 @@ impl Layout {\n     /// of each element in the array.\n     ///\n     /// On arithmetic overflow, returns `None`.\n+    #[inline]\n     pub fn repeat(&self, n: usize) -> Option<(Self, usize)> {\n         let padded_size = match self.size.checked_add(self.padding_needed_for(self.align)) {\n             None => return None,"}, {"sha": "80317cd763b5c8680e6b5d5dc6d51fce0ea87e98", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -273,7 +273,10 @@ impl str {\n         core_str::StrExt::is_char_boundary(self, index)\n     }\n \n-    /// Converts a string slice to a byte slice.\n+    /// Converts a string slice to a byte slice. To convert the byte slice back\n+    /// into a string slice, use the [`str::from_utf8`] function.\n+    ///\n+    /// [`str::from_utf8`]: ./str/fn.from_utf8.html\n     ///\n     /// # Examples\n     ///\n@@ -289,7 +292,11 @@ impl str {\n         core_str::StrExt::as_bytes(self)\n     }\n \n-    /// Converts a mutable string slice to a mutable byte slice.\n+    /// Converts a mutable string slice to a mutable byte slice. To convert the\n+    /// mutable byte slice back into a mutable string slice, use the\n+    /// [`str::from_utf8_mut`] function.\n+    ///\n+    /// [`str::from_utf8_mut`]: ./str/fn.from_utf8_mut.html\n     #[stable(feature = \"str_mut_extras\", since = \"1.20.0\")]\n     #[inline(always)]\n     pub unsafe fn as_bytes_mut(&mut self) -> &mut [u8] {\n@@ -328,11 +335,16 @@ impl str {\n     /// # Examples\n     ///\n     /// ```\n-    /// let v = \"\ud83d\uddfb\u2208\ud83c\udf0f\";\n+    /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    ///\n     /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get(0..4));\n-    /// assert!(v.get(1..).is_none());\n-    /// assert!(v.get(..8).is_none());\n-    /// assert!(v.get(..42).is_none());\n+    ///\n+    /// // indices not on UTF-8 sequence boundaries\n+    /// assert!(v.get_mut(1..).is_none());\n+    /// assert!(v.get_mut(..8).is_none());\n+    ///\n+    /// // out of bounds\n+    /// assert!(v.get_mut(..42).is_none());\n     /// ```\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n@@ -351,9 +363,14 @@ impl str {\n     ///\n     /// ```\n     /// let mut v = String::from(\"\ud83d\uddfb\u2208\ud83c\udf0f\");\n+    ///\n     /// assert_eq!(Some(\"\ud83d\uddfb\"), v.get_mut(0..4).map(|v| &*v));\n+    ///\n+    /// // indices not on UTF-8 sequence boundaries\n     /// assert!(v.get_mut(1..).is_none());\n     /// assert!(v.get_mut(..8).is_none());\n+    ///\n+    /// // out of bounds\n     /// assert!(v.get_mut(..42).is_none());\n     /// ```\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n@@ -563,12 +580,16 @@ impl str {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// let mut s = \"Per Martin-L\u00f6f\".to_string();\n-    ///\n-    /// let (first, last) = s.split_at_mut(3);\n+    /// use std::ascii::AsciiExt;\n     ///\n-    /// assert_eq!(\"Per\", first);\n-    /// assert_eq!(\" Martin-L\u00f6f\", last);\n+    /// let mut s = \"Per Martin-L\u00f6f\".to_string();\n+    /// {\n+    ///     let (first, last) = s.split_at_mut(3);\n+    ///     first.make_ascii_uppercase();\n+    ///     assert_eq!(\"PER\", first);\n+    ///     assert_eq!(\" Martin-L\u00f6f\", last);\n+    /// }\n+    /// assert_eq!(\"PER Martin-L\u00f6f\", s);\n     /// ```\n     #[inline]\n     #[stable(feature = \"str_split_at\", since = \"1.4.0\")]"}, {"sha": "21b5557db99f27325ee83a82ce0f2afba123cd14", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -188,6 +188,34 @@ use ptr;\n \n /// A mutable memory location.\n ///\n+/// # Examples\n+///\n+/// Here you can see how using `Cell<T>` allows to use mutable field inside\n+/// immutable struct (which is also called 'interior mutability').\n+///\n+/// ```\n+/// use std::cell::Cell;\n+///\n+/// struct SomeStruct {\n+///     regular_field: u8,\n+///     special_field: Cell<u8>,\n+/// }\n+///\n+/// let my_struct = SomeStruct {\n+///     regular_field: 0,\n+///     special_field: Cell::new(1),\n+/// };\n+///\n+/// let new_value = 100;\n+///\n+/// // ERROR, because my_struct is immutable\n+/// // my_struct.regular_field = new_value;\n+///\n+/// // WORKS, although `my_struct` is immutable, field `special_field` is mutable because it is Cell\n+/// my_struct.special_field.set(new_value);\n+/// assert_eq!(my_struct.special_field.get(), new_value);\n+/// ```\n+///\n /// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Cell<T> {"}, {"sha": "2472efa14b30746cbdea4d6626894ec52334a20d", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1247,7 +1247,7 @@ pub trait Iterator {\n     /// assert_eq!(vec![2, 4, 6], doubled);\n     /// ```\n     ///\n-    /// Because `collect()` cares about what you're collecting into, you can\n+    /// Because `collect()` only cares about what you're collecting into, you can\n     /// still use a partial type hint, `_`, with the turbofish:\n     ///\n     /// ```"}, {"sha": "ccfeb91aff1474ce8e265f860b4ab2c548ce7b6b", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -147,22 +147,13 @@ pub trait FromIterator<A>: Sized {\n ///\n /// ```\n /// let v = vec![1, 2, 3];\n-///\n /// let mut iter = v.into_iter();\n ///\n-/// let n = iter.next();\n-/// assert_eq!(Some(1), n);\n-///\n-/// let n = iter.next();\n-/// assert_eq!(Some(2), n);\n-///\n-/// let n = iter.next();\n-/// assert_eq!(Some(3), n);\n-///\n-/// let n = iter.next();\n-/// assert_eq!(None, n);\n+/// assert_eq!(Some(1), iter.next());\n+/// assert_eq!(Some(2), iter.next());\n+/// assert_eq!(Some(3), iter.next());\n+/// assert_eq!(None, iter.next());\n /// ```\n-///\n /// Implementing `IntoIterator` for your type:\n ///\n /// ```\n@@ -227,20 +218,12 @@ pub trait IntoIterator {\n     ///\n     /// ```\n     /// let v = vec![1, 2, 3];\n-    ///\n     /// let mut iter = v.into_iter();\n     ///\n-    /// let n = iter.next();\n-    /// assert_eq!(Some(1), n);\n-    ///\n-    /// let n = iter.next();\n-    /// assert_eq!(Some(2), n);\n-    ///\n-    /// let n = iter.next();\n-    /// assert_eq!(Some(3), n);\n-    ///\n-    /// let n = iter.next();\n-    /// assert_eq!(None, n);\n+    /// assert_eq!(Some(1), iter.next());\n+    /// assert_eq!(Some(2), iter.next());\n+    /// assert_eq!(Some(3), iter.next());\n+    /// assert_eq!(None, iter.next());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn into_iter(self) -> Self::IntoIter;"}, {"sha": "c5175287ccfa63cf5ff654583bb4ee454b7391c4", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -131,6 +131,10 @@ macro_rules! int_impl {\n         ///\n         /// Leading and trailing whitespace represent an error.\n         ///\n+        /// # Panics\n+        ///\n+        /// This function panics if `radix` is not in the range from 2 to 36.\n+        ///\n         /// # Examples\n         ///\n         /// Basic usage:"}, {"sha": "2a5b50b7f7f539a0fd201331d6c1e0534aa332f5", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1 +1 @@\n-Subproject commit ec1e5ab1ef8baca57f8776bbebd9343572a87082\n+Subproject commit 2a5b50b7f7f539a0fd201331d6c1e0534aa332f5"}, {"sha": "1bffffd6c9e711834416617ad236917115386154", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 71, "deletions": 8, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -509,14 +509,49 @@ impl TokenTree {\n             Ident(ident) | Lifetime(ident) => TokenNode::Term(Term(ident.name)),\n             Literal(..) | DocComment(..) => TokenNode::Literal(self::Literal(token)),\n \n-            Interpolated(ref nt) => __internal::with_sess(|(sess, _)| {\n-                TokenNode::Group(Delimiter::None, TokenStream(nt.1.force(|| {\n-                    // FIXME(jseyfried): Avoid this pretty-print + reparse hack\n-                    let name = \"<macro expansion>\".to_owned();\n-                    let source = pprust::token_to_string(&token);\n-                    parse_stream_from_source_str(name, source, sess, Some(span))\n-                })))\n-            }),\n+            Interpolated(ref nt) => {\n+                // An `Interpolated` token means that we have a `Nonterminal`\n+                // which is often a parsed AST item. At this point we now need\n+                // to convert the parsed AST to an actual token stream, e.g.\n+                // un-parse it basically.\n+                //\n+                // Unfortunately there's not really a great way to do that in a\n+                // guaranteed lossless fashion right now. The fallback here is\n+                // to just stringify the AST node and reparse it, but this loses\n+                // all span information.\n+                //\n+                // As a result, some AST nodes are annotated with the token\n+                // stream they came from. Attempt to extract these lossless\n+                // token streams before we fall back to the stringification.\n+                let mut tokens = None;\n+\n+                match nt.0 {\n+                    Nonterminal::NtItem(ref item) => {\n+                        tokens = prepend_attrs(&item.attrs, item.tokens.as_ref(), span);\n+                    }\n+                    Nonterminal::NtTraitItem(ref item) => {\n+                        tokens = prepend_attrs(&item.attrs, item.tokens.as_ref(), span);\n+                    }\n+                    Nonterminal::NtImplItem(ref item) => {\n+                        tokens = prepend_attrs(&item.attrs, item.tokens.as_ref(), span);\n+                    }\n+                    _ => {}\n+                }\n+\n+                tokens.map(|tokens| {\n+                    TokenNode::Group(Delimiter::None,\n+                                     TokenStream(tokens.clone()))\n+                }).unwrap_or_else(|| {\n+                    __internal::with_sess(|(sess, _)| {\n+                        TokenNode::Group(Delimiter::None, TokenStream(nt.1.force(|| {\n+                            // FIXME(jseyfried): Avoid this pretty-print + reparse hack\n+                            let name = \"<macro expansion>\".to_owned();\n+                            let source = pprust::token_to_string(&token);\n+                            parse_stream_from_source_str(name, source, sess, Some(span))\n+                        })))\n+                    })\n+                })\n+            }\n \n             OpenDelim(..) | CloseDelim(..) => unreachable!(),\n             Whitespace | Comment | Shebang(..) | Eof => unreachable!(),\n@@ -580,6 +615,34 @@ impl TokenTree {\n     }\n }\n \n+fn prepend_attrs(attrs: &[ast::Attribute],\n+                 tokens: Option<&tokenstream::TokenStream>,\n+                 span: syntax_pos::Span)\n+    -> Option<tokenstream::TokenStream>\n+{\n+    let tokens = match tokens {\n+        Some(tokens) => tokens,\n+        None => return None,\n+    };\n+    if attrs.len() == 0 {\n+        return Some(tokens.clone())\n+    }\n+    let mut builder = tokenstream::TokenStreamBuilder::new();\n+    for attr in attrs {\n+        assert_eq!(attr.style, ast::AttrStyle::Outer,\n+                   \"inner attributes should prevent cached tokens from existing\");\n+        let stream = __internal::with_sess(|(sess, _)| {\n+            // FIXME: Avoid this pretty-print + reparse hack as bove\n+            let name = \"<macro expansion>\".to_owned();\n+            let source = pprust::attr_to_string(attr);\n+            parse_stream_from_source_str(name, source, sess, Some(span))\n+        });\n+        builder.push(stream);\n+    }\n+    builder.push(tokens.clone());\n+    Some(builder.build())\n+}\n+\n /// Permanently unstable internal implementation details of this crate. This\n /// should not be used.\n ///"}, {"sha": "c6f9cb2fceadd3f454121d8aecaa0fa56739cfcd", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -66,7 +66,6 @@ use hir::map::DefPathHash;\n use ich::Fingerprint;\n use ty::{TyCtxt, Instance, InstanceDef};\n use ty::fast_reject::SimplifiedType;\n-use ty::subst::Substs;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use ich::StableHashingContext;\n use std::fmt;\n@@ -104,6 +103,8 @@ macro_rules! define_dep_nodes {\n                 match *self {\n                     $(\n                         DepKind :: $variant => {\n+                            $(return !anon_attr_to_bool!($anon);)*\n+\n                             // tuple args\n                             $({\n                                 return <( $($tuple_arg,)* ) as DepNodeParams>\n@@ -112,6 +113,7 @@ macro_rules! define_dep_nodes {\n \n                             // struct args\n                             $({\n+\n                                 return <( $($struct_arg_ty,)* ) as DepNodeParams>\n                                     ::CAN_RECONSTRUCT_QUERY_KEY;\n                             })*\n@@ -394,6 +396,7 @@ define_dep_nodes!( <'tcx>\n     // Represents different phases in the compiler.\n     [] RegionMaps(DefId),\n     [] Coherence,\n+    [] CoherenceInherentImplOverlapCheck,\n     [] Resolve,\n     [] CoherenceCheckTrait(DefId),\n     [] PrivacyAccessLevels(CrateNum),\n@@ -444,17 +447,17 @@ define_dep_nodes!( <'tcx>\n     [] TypeckBodiesKrate,\n     [] TypeckTables(DefId),\n     [] HasTypeckTables(DefId),\n-    [] ConstEval { def_id: DefId, substs: &'tcx Substs<'tcx> },\n+    [anon] ConstEval,\n     [] SymbolName(DefId),\n     [] InstanceSymbolName { instance: Instance<'tcx> },\n     [] SpecializationGraph(DefId),\n     [] ObjectSafety(DefId),\n \n-    [anon] IsCopy(DefId),\n-    [anon] IsSized(DefId),\n-    [anon] IsFreeze(DefId),\n-    [anon] NeedsDrop(DefId),\n-    [anon] Layout(DefId),\n+    [anon] IsCopy,\n+    [anon] IsSized,\n+    [anon] IsFreeze,\n+    [anon] NeedsDrop,\n+    [anon] Layout,\n \n     // The set of impls for a given trait.\n     [] TraitImpls(DefId),"}, {"sha": "9aa634770df933ea8ae16f13cfd8644fb0f123a3", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -23,6 +23,11 @@ pub struct DepGraphEdges {\n     edges: FxHashSet<(DepNodeIndex, DepNodeIndex)>,\n     task_stack: Vec<OpenTask>,\n     forbidden_edge: Option<EdgeFilter>,\n+\n+    // A set to help assert that no two tasks use the same DepNode. This is a\n+    // temporary measure. Once we load the previous dep-graph as readonly, this\n+    // check will fall out of the graph implementation naturally.\n+    opened_once: FxHashSet<DepNode>,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n@@ -80,6 +85,7 @@ impl DepGraphEdges {\n             edges: FxHashSet(),\n             task_stack: Vec::new(),\n             forbidden_edge,\n+            opened_once: FxHashSet(),\n         }\n     }\n \n@@ -97,6 +103,10 @@ impl DepGraphEdges {\n     }\n \n     pub fn push_task(&mut self, key: DepNode) {\n+        if !self.opened_once.insert(key) {\n+            bug!(\"Re-opened node {:?}\", key)\n+        }\n+\n         self.task_stack.push(OpenTask::Regular {\n             node: key,\n             reads: Vec::new(),"}, {"sha": "c9b5aaf3877c210faf7caa9708d09da426822445", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -2222,7 +2222,7 @@ impl<'a> LoweringContext<'a> {\n                 let next_ident = self.str_to_ident(\"__next\");\n                 let next_pat = self.pat_ident_binding_mode(e.span,\n                                                            next_ident,\n-                                                           hir::BindByValue(hir::MutMutable));\n+                                                           hir::BindingAnnotation::Mutable);\n \n                 // `::std::option::Option::Some(val) => next = val`\n                 let pat_arm = {\n@@ -2246,8 +2246,9 @@ impl<'a> LoweringContext<'a> {\n                 };\n \n                 // `mut iter`\n-                let iter_pat = self.pat_ident_binding_mode(e.span, iter,\n-                                                           hir::BindByValue(hir::MutMutable));\n+                let iter_pat = self.pat_ident_binding_mode(e.span,\n+                                                           iter,\n+                                                           hir::BindingAnnotation::Mutable);\n \n                 // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                 let match_expr = {\n@@ -2534,10 +2535,13 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_binding_mode(&mut self, b: &BindingMode) -> hir::BindingMode {\n+    fn lower_binding_mode(&mut self, b: &BindingMode) -> hir::BindingAnnotation {\n         match *b {\n-            BindingMode::ByRef(m) => hir::BindByRef(self.lower_mutability(m)),\n-            BindingMode::ByValue(m) => hir::BindByValue(self.lower_mutability(m)),\n+            BindingMode::ByValue(Mutability::Immutable) =>\n+                hir::BindingAnnotation::Unannotated,\n+            BindingMode::ByRef(Mutability::Immutable) => hir::BindingAnnotation::Ref,\n+            BindingMode::ByValue(Mutability::Mutable) => hir::BindingAnnotation::Mutable,\n+            BindingMode::ByRef(Mutability::Mutable) => hir::BindingAnnotation::RefMut,\n         }\n     }\n \n@@ -2678,7 +2682,7 @@ impl<'a> LoweringContext<'a> {\n     fn stmt_let(&mut self, sp: Span, mutbl: bool, ident: Name, ex: P<hir::Expr>)\n                 -> (hir::Stmt, NodeId) {\n         let pat = if mutbl {\n-            self.pat_ident_binding_mode(sp, ident, hir::BindByValue(hir::MutMutable))\n+            self.pat_ident_binding_mode(sp, ident, hir::BindingAnnotation::Mutable)\n         } else {\n             self.pat_ident(sp, ident)\n         };\n@@ -2734,10 +2738,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn pat_ident(&mut self, span: Span, name: Name) -> P<hir::Pat> {\n-        self.pat_ident_binding_mode(span, name, hir::BindByValue(hir::MutImmutable))\n+        self.pat_ident_binding_mode(span, name, hir::BindingAnnotation::Unannotated)\n     }\n \n-    fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingMode)\n+    fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingAnnotation)\n                               -> P<hir::Pat> {\n         let id = self.next_id();\n         let parent_def = self.parent_def.unwrap();"}, {"sha": "d2888dcf6aaa4fa1350179641cc9d5077c9253c4", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -192,6 +192,18 @@ impl<'a> FnLikeNode<'a> {\n         }\n     }\n \n+    pub fn unsafety(self) -> ast::Unsafety {\n+        match self.kind() {\n+            FnKind::ItemFn(_, _, unsafety, ..) => {\n+                unsafety\n+            }\n+            FnKind::Method(_, m, ..) => {\n+                m.unsafety\n+            }\n+            _ => ast::Unsafety::Normal\n+        }\n+    }\n+\n     pub fn kind(self) -> FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> FnKind<'a> {\n             FnKind::ItemFn(p.name, p.generics, p.unsafety, p.constness, p.abi, p.vis, p.attrs)"}, {"sha": "cdd5a6e3da7f1a6ff9d6a90abffaf6be1a787bb3", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -18,7 +18,7 @@ use hir;\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, DefIndexAddressSpace,\n                   CRATE_DEF_INDEX};\n use ich::Fingerprint;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::stable_hasher::StableHasher;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n@@ -153,7 +153,7 @@ pub struct Definitions {\n     pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n     macro_def_scopes: FxHashMap<Mark, DefId>,\n     expansions: FxHashMap<DefIndex, Mark>,\n-    keys_created: FxHashSet<DefKey>,\n+    next_disambiguator: FxHashMap<(DefIndex, DefPathData), u32>,\n }\n \n // Unfortunately we have to provide a manual impl of Clone because of the\n@@ -170,7 +170,7 @@ impl Clone for Definitions {\n             node_to_hir_id: self.node_to_hir_id.clone(),\n             macro_def_scopes: self.macro_def_scopes.clone(),\n             expansions: self.expansions.clone(),\n-            keys_created: self.keys_created.clone(),\n+            next_disambiguator: self.next_disambiguator.clone(),\n         }\n     }\n }\n@@ -402,7 +402,7 @@ impl Definitions {\n             node_to_hir_id: IndexVec::new(),\n             macro_def_scopes: FxHashMap(),\n             expansions: FxHashMap(),\n-            keys_created: FxHashSet(),\n+            next_disambiguator: FxHashMap(),\n         }\n     }\n \n@@ -516,21 +516,21 @@ impl Definitions {\n         // The root node must be created with create_root_def()\n         assert!(data != DefPathData::CrateRoot);\n \n-        // Find a unique DefKey. This basically means incrementing the disambiguator\n-        // until we get no match.\n-        let mut key = DefKey {\n+        // Find the next free disambiguator for this key.\n+        let disambiguator = {\n+            let next_disamb = self.next_disambiguator.entry((parent, data.clone())).or_insert(0);\n+            let disambiguator = *next_disamb;\n+            *next_disamb = next_disamb.checked_add(1).expect(\"disambiguator overflow\");\n+            disambiguator\n+        };\n+\n+        let key = DefKey {\n             parent: Some(parent),\n             disambiguated_data: DisambiguatedDefPathData {\n-                data,\n-                disambiguator: 0\n+                data, disambiguator\n             }\n         };\n \n-        while self.keys_created.contains(&key) {\n-            key.disambiguated_data.disambiguator += 1;\n-        }\n-        self.keys_created.insert(key.clone());\n-\n         let parent_hash = self.table.def_path_hash(parent);\n         let def_path_hash = key.compute_stable_hash(parent_hash);\n "}, {"sha": "f4ca536d370bf6249e6b1df937366cb86fcf505d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -555,7 +555,9 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Similar to get_parent, returns the parent node id or id if there is no\n-    /// parent.\n+    /// parent. Note that the parent may be CRATE_NODE_ID, which is not itself\n+    /// present in the map -- so passing the return value of get_parent_node to\n+    /// get may actually panic.\n     /// This function returns the immediate parent in the AST, whereas get_parent\n     /// returns the enclosing item. Note that this might not be the actual parent\n     /// node in the AST - some kinds of nodes are not in the map and these will\n@@ -631,7 +633,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     /// Retrieve the NodeId for `id`'s enclosing method, unless there's a\n-    /// `while` or `loop` before reacing it, as block tail returns are not\n+    /// `while` or `loop` before reaching it, as block tail returns are not\n     /// available in them.\n     ///\n     /// ```"}, {"sha": "10d34e49da49510e927df8c876aac42816cff621", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -10,7 +10,6 @@\n \n // The Rust HIR.\n \n-pub use self::BindingMode::*;\n pub use self::BinOp_::*;\n pub use self::BlockCheckMode::*;\n pub use self::CaptureClause::*;\n@@ -49,7 +48,7 @@ use rustc_data_structures::indexed_vec;\n use std::collections::BTreeMap;\n use std::fmt;\n \n-/// HIR doesn't commit to a concrete storage type and have its own alias for a vector.\n+/// HIR doesn't commit to a concrete storage type and has its own alias for a vector.\n /// It can be `Vec`, `P<[T]>` or potentially `Box<[T]>`, or some other container with similar\n /// behavior. Unlike AST, HIR is mostly a static structure, so we can use an owned slice instead\n /// of `Vec` to avoid keeping extra capacity.\n@@ -76,14 +75,14 @@ pub mod pat_util;\n pub mod print;\n pub mod svh;\n \n-/// A HirId uniquely identifies a node in the HIR of then current crate. It is\n+/// A HirId uniquely identifies a node in the HIR of the current crate. It is\n /// composed of the `owner`, which is the DefIndex of the directly enclosing\n /// hir::Item, hir::TraitItem, or hir::ImplItem (i.e. the closest \"item-like\"),\n /// and the `local_id` which is unique within the given owner.\n ///\n /// This two-level structure makes for more stable values: One can move an item\n /// around within the source code, or add or remove stuff before it, without\n-/// the local_id part of the HirId changing, which is a very useful property\n+/// the local_id part of the HirId changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug,\n@@ -628,10 +627,28 @@ pub struct FieldPat {\n     pub is_shorthand: bool,\n }\n \n+/// Explicit binding annotations given in the HIR for a binding. Note\n+/// that this is not the final binding *mode* that we infer after type\n+/// inference.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub enum BindingMode {\n-    BindByRef(Mutability),\n-    BindByValue(Mutability),\n+pub enum BindingAnnotation {\n+  /// No binding annotation given: this means that the final binding mode\n+  /// will depend on whether we have skipped through a `&` reference\n+  /// when matching. For example, the `x` in `Some(x)` will have binding\n+  /// mode `None`; if you do `let Some(x) = &Some(22)`, it will\n+  /// ultimately be inferred to be by-reference.\n+  ///\n+  /// Note that implicit reference skipping is not implemented yet (#42640).\n+  Unannotated,\n+\n+  /// Annotated with `mut x` -- could be either ref or not, similar to `None`.\n+  Mutable,\n+\n+  /// Annotated as `ref`, like `ref x`\n+  Ref,\n+\n+  /// Annotated as `ref mut x`.\n+  RefMut,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -647,7 +664,7 @@ pub enum PatKind {\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n     /// The `DefId` is for the definition of the variable being bound.\n-    Binding(BindingMode, DefId, Spanned<Name>, Option<P<Pat>>),\n+    Binding(BindingAnnotation, DefId, Spanned<Name>, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`.\n@@ -684,6 +701,16 @@ pub enum Mutability {\n     MutImmutable,\n }\n \n+impl Mutability {\n+    /// Return MutMutable only if both arguments are mutable.\n+    pub fn and(self, other: Self) -> Self {\n+        match self {\n+            MutMutable => other,\n+            MutImmutable => MutImmutable,\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum BinOp_ {\n     /// The `+` operator (addition)\n@@ -892,6 +919,13 @@ impl Decl_ {\n             DeclItem(_) => &[]\n         }\n     }\n+\n+    pub fn is_local(&self) -> bool {\n+        match *self {\n+            Decl_::DeclLocal(_) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n /// represents one arm of a 'match'\n@@ -1686,7 +1720,7 @@ pub struct Item {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Item_ {\n-    /// An`extern crate` item, with optional original crate name,\n+    /// An `extern crate` item, with optional original crate name,\n     ///\n     /// e.g. `extern crate foo` or `extern crate foo_bar as foo`\n     ItemExternCrate(Option<Name>),"}, {"sha": "144cb34ee356e221162cca6eaf8ab36f2fb4f645", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -87,7 +87,7 @@ impl hir::Pat {\n     /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n     /// `match foo() { Some(a) => (), None => () }`\n     pub fn each_binding<F>(&self, mut f: F)\n-        where F: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n+        where F: FnMut(hir::BindingAnnotation, ast::NodeId, Span, &Spanned<ast::Name>),\n     {\n         self.walk(|p| {\n             if let PatKind::Binding(binding_mode, _, ref pth, _) = p.node {\n@@ -130,12 +130,10 @@ impl hir::Pat {\n \n     pub fn simple_name(&self) -> Option<ast::Name> {\n         match self.node {\n-            PatKind::Binding(hir::BindByValue(..), _, ref path1, None) => {\n-                Some(path1.node)\n-            }\n-            _ => {\n-                None\n-            }\n+            PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ref path1, None) |\n+            PatKind::Binding(hir::BindingAnnotation::Mutable, _, ref path1, None) =>\n+                Some(path1.node),\n+            _ => None,\n         }\n     }\n \n@@ -163,16 +161,22 @@ impl hir::Pat {\n     }\n \n     /// Checks if the pattern contains any `ref` or `ref mut` bindings,\n-    /// and if yes whether its containing mutable ones or just immutables ones.\n-    pub fn contains_ref_binding(&self) -> Option<hir::Mutability> {\n+    /// and if yes whether it contains mutable or just immutables ones.\n+    ///\n+    /// FIXME(tschottdorf): this is problematic as the HIR is being scraped,\n+    /// but ref bindings may be implicit after #42640.\n+    pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n         let mut result = None;\n-        self.each_binding(|mode, _, _, _| {\n-            if let hir::BindingMode::BindByRef(m) = mode {\n-                // Pick Mutable as maximum\n-                match result {\n-                    None | Some(hir::MutImmutable) => result = Some(m),\n-                    _ => (),\n+        self.each_binding(|annotation, _, _, _| {\n+            match annotation {\n+                hir::BindingAnnotation::Ref => {\n+                    match result {\n+                        None | Some(hir::MutImmutable) => result = Some(hir::MutImmutable),\n+                        _ => (),\n+                    }\n                 }\n+                hir::BindingAnnotation::RefMut => result = Some(hir::MutMutable),\n+                _ => (),\n             }\n         });\n         result\n@@ -182,9 +186,11 @@ impl hir::Pat {\n impl hir::Arm {\n     /// Checks if the patterns for this arm contain any `ref` or `ref mut`\n     /// bindings, and if yes whether its containing mutable ones or just immutables ones.\n-    pub fn contains_ref_binding(&self) -> Option<hir::Mutability> {\n+    pub fn contains_explicit_ref_binding(&self) -> Option<hir::Mutability> {\n+        // FIXME(tschottdorf): contains_explicit_ref_binding() must be removed\n+        // for #42640.\n         self.pats.iter()\n-                 .filter_map(|pat| pat.contains_ref_binding())\n+                 .filter_map(|pat| pat.contains_explicit_ref_binding())\n                  .max_by_key(|m| match *m {\n                     hir::MutMutable => 1,\n                     hir::MutImmutable => 0,"}, {"sha": "d819fc2f779fe6e3b19918d252b2b9b4d7957bd0", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1655,12 +1655,16 @@ impl<'a> State<'a> {\n             PatKind::Wild => self.s.word(\"_\")?,\n             PatKind::Binding(binding_mode, _, ref path1, ref sub) => {\n                 match binding_mode {\n-                    hir::BindByRef(mutbl) => {\n+                    hir::BindingAnnotation::Ref => {\n                         self.word_nbsp(\"ref\")?;\n-                        self.print_mutability(mutbl)?;\n+                        self.print_mutability(hir::MutImmutable)?;\n                     }\n-                    hir::BindByValue(hir::MutImmutable) => {}\n-                    hir::BindByValue(hir::MutMutable) => {\n+                    hir::BindingAnnotation::RefMut => {\n+                        self.word_nbsp(\"ref\")?;\n+                        self.print_mutability(hir::MutMutable)?;\n+                    }\n+                    hir::BindingAnnotation::Unannotated => {}\n+                    hir::BindingAnnotation::Mutable => {\n                         self.word_nbsp(\"mut\")?;\n                     }\n                 }"}, {"sha": "6790c2ac7decec5e4887ef4a589e97b321a0d5b5", "filename": "src/librustc/ich/impls_const_math.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fich%2Fimpls_const_math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_const_math.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -11,9 +11,9 @@\n //! This module contains `HashStable` implementations for various data types\n //! from `rustc_const_math` in no particular order.\n \n-impl_stable_hash_for!(enum ::rustc_const_math::ConstFloat {\n-    F32(val),\n-    F64(val)\n+impl_stable_hash_for!(struct ::rustc_const_math::ConstFloat {\n+    ty,\n+    bits\n });\n \n impl_stable_hash_for!(enum ::rustc_const_math::ConstInt {"}, {"sha": "ea3f04ff8c2a3c8f507a284a1347482b22bfeca2", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -442,9 +442,11 @@ impl_stable_hash_for!(struct hir::FieldPat {\n     is_shorthand\n });\n \n-impl_stable_hash_for!(enum hir::BindingMode {\n-    BindByRef(mutability),\n-    BindByValue(mutability)\n+impl_stable_hash_for!(enum hir::BindingAnnotation {\n+    Unannotated,\n+    Mutable,\n+    Ref,\n+    RefMut\n });\n \n impl_stable_hash_for!(enum hir::RangeEnd {"}, {"sha": "e277f40a26d9c619d3962f17f7d60cec2158bb52", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -239,8 +239,12 @@ for mir::StatementKind<'tcx> {\n             mir::StatementKind::StorageDead(ref lvalue) => {\n                 lvalue.hash_stable(hcx, hasher);\n             }\n-            mir::StatementKind::EndRegion(ref extents) => {\n-                extents.hash_stable(hcx, hasher);\n+            mir::StatementKind::EndRegion(ref extent) => {\n+                extent.hash_stable(hcx, hasher);\n+            }\n+            mir::StatementKind::Validate(ref op, ref lvalues) => {\n+                op.hash_stable(hcx, hasher);\n+                lvalues.hash_stable(hcx, hasher);\n             }\n             mir::StatementKind::Nop => {}\n             mir::StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n@@ -252,6 +256,23 @@ for mir::StatementKind<'tcx> {\n     }\n }\n \n+impl<'a, 'gcx, 'tcx, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+    for mir::ValidationOperand<'tcx, T>\n+    where T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>)\n+    {\n+        self.lval.hash_stable(hcx, hasher);\n+        self.ty.hash_stable(hcx, hasher);\n+        self.re.hash_stable(hcx, hasher);\n+        self.mutbl.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl_stable_hash_for!(enum mir::ValidationOp { Acquire, Release, Suspend(extent) });\n+\n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::Lvalue<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n@@ -271,10 +292,11 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for mir::L\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, B, V> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n-for mir::Projection<'tcx, B, V>\n+impl<'a, 'gcx, 'tcx, B, V, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::Projection<'tcx, B, V, T>\n     where B: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n-          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+          V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+          T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n@@ -289,17 +311,18 @@ for mir::Projection<'tcx, B, V>\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, V> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n-for mir::ProjectionElem<'tcx, V>\n-    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+impl<'a, 'gcx, 'tcx, V, T> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n+for mir::ProjectionElem<'tcx, V, T>\n+    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+          T: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n             mir::ProjectionElem::Deref => {}\n-            mir::ProjectionElem::Field(field, ty) => {\n+            mir::ProjectionElem::Field(field, ref ty) => {\n                 field.hash_stable(hcx, hasher);\n                 ty.hash_stable(hcx, hasher);\n             }"}, {"sha": "9286d3c73ed67452cdd5a94732fa0d7c72a83141", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -375,7 +375,6 @@ for ty::RegionParameterDef {\n             name,\n             def_id,\n             index,\n-            issue_32330: _,\n             pure_wrt_drop\n         } = *self;\n \n@@ -630,6 +629,7 @@ for ty::TypeckTables<'tcx> {\n             ref node_types,\n             ref node_substs,\n             ref adjustments,\n+            ref pat_binding_modes,\n             ref upvar_capture_map,\n             ref closure_tys,\n             ref closure_kinds,\n@@ -652,6 +652,7 @@ for ty::TypeckTables<'tcx> {\n             ich::hash_stable_nodemap(hcx, hasher, node_types);\n             ich::hash_stable_nodemap(hcx, hasher, node_substs);\n             ich::hash_stable_nodemap(hcx, hasher, adjustments);\n+            ich::hash_stable_nodemap(hcx, hasher, pat_binding_modes);\n             ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n                 let ty::UpvarId {\n                     var_id,"}, {"sha": "2e9109688181527e9c5aef75aac26ec6a9833011", "filename": "src/librustc/infer/error_reporting/anon_anon_conflict.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fanon_anon_conflict.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -77,10 +77,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n             struct_span_err!(self.tcx.sess, span, E0623, \"lifetime mismatch\")\n                 .span_label(ty1.span,\n-                            format!(\"these references must have the same lifetime\"))\n+                            format!(\"these references are not declared with the same lifetime...\"))\n                 .span_label(ty2.span, format!(\"\"))\n                 .span_label(span,\n-                            format!(\"data{}flows{}here\", span_label_var1, span_label_var2))\n+                            format!(\"...but data{}flows{}here\", span_label_var1, span_label_var2))\n                 .emit();\n         } else {\n             return false;"}, {"sha": "8e8576b83e4ed4d238638768cbe61d012d928b0b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 33, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -66,8 +66,7 @@ use hir::map as hir_map;\n use hir::def_id::DefId;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n-use ty::{self, TyCtxt, TypeFoldable};\n-use ty::{Region, Issue32330};\n+use ty::{self, Region, TyCtxt, TypeFoldable};\n use ty::error::TypeError;\n use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n@@ -713,35 +712,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.note_and_explain_type_err(diag, terr, span);\n     }\n \n-    pub fn note_issue_32330(&self,\n-                            diag: &mut DiagnosticBuilder<'tcx>,\n-                            terr: &TypeError<'tcx>)\n-    {\n-        debug!(\"note_issue_32330: terr={:?}\", terr);\n-        match *terr {\n-            TypeError::RegionsInsufficientlyPolymorphic(_, _, Some(box Issue32330 {\n-                fn_def_id, region_name\n-            })) |\n-            TypeError::RegionsOverlyPolymorphic(_, _, Some(box Issue32330 {\n-                fn_def_id, region_name\n-            })) => {\n-                diag.note(\n-                    &format!(\"lifetime parameter `{0}` declared on fn `{1}` \\\n-                              appears only in the return type, \\\n-                              but here is required to be higher-ranked, \\\n-                              which means that `{0}` must appear in both \\\n-                              argument and return types\",\n-                             region_name,\n-                             self.tcx.item_path_str(fn_def_id)));\n-                diag.note(\n-                    &format!(\"this error is the result of a recent bug fix; \\\n-                              for more information, see issue #33685 \\\n-                              <https://github.com/rust-lang/rust/issues/33685>\"));\n-            }\n-            _ => {}\n-        }\n-    }\n-\n     pub fn report_and_explain_type_error(&self,\n                                          trace: TypeTrace<'tcx>,\n                                          terr: &TypeError<'tcx>)\n@@ -761,7 +731,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n         self.note_type_err(&mut diag, &trace.cause, None, Some(trace.values), terr);\n-        self.note_issue_32330(&mut diag, terr);\n         diag\n     }\n \n@@ -934,7 +903,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 format!(\" for lifetime parameter {}in trait containing associated type `{}`\",\n                         br_string(br), type_name)\n             }\n-            infer::EarlyBoundRegion(_, name, _) => {\n+            infer::EarlyBoundRegion(_, name) => {\n                 format!(\" for lifetime parameter `{}`\",\n                         name)\n             }"}, {"sha": "9ecc8b0e66b9bb1b9fea9deb14496f2fa7d2ad88", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 7, "deletions": 49, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -13,9 +13,7 @@\n \n use super::{CombinedSnapshot,\n             InferCtxt,\n-            LateBoundRegion,\n             HigherRankedType,\n-            RegionVariableOrigin,\n             SubregionOrigin,\n             SkolemizationMap};\n use super::combine::CombineFields;\n@@ -29,15 +27,6 @@ use util::nodemap::{FxHashMap, FxHashSet};\n \n pub struct HrMatchResult<U> {\n     pub value: U,\n-\n-    /// Normally, when we do a higher-ranked match operation, we\n-    /// expect all higher-ranked regions to be constrained as part of\n-    /// the match operation. However, in the transition period for\n-    /// #32330, it can happen that we sometimes have unconstrained\n-    /// regions that get instantiated with fresh variables. In that\n-    /// case, we collect the set of unconstrained bound regions here\n-    /// and replace them with fresh variables.\n-    pub unconstrained_regions: Vec<ty::BoundRegion>,\n }\n \n impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n@@ -108,7 +97,6 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n     /// that do not appear in `T`. If that happens, those regions are\n     /// unconstrained, and this routine replaces them with `'static`.\n     pub fn higher_ranked_match<T, U>(&mut self,\n-                                     span: Span,\n                                      a_pair: &Binder<(T, U)>,\n                                      b_match: &T,\n                                      a_is_expected: bool)\n@@ -158,28 +146,16 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // be any region from the sets above, except for other members of\n             // `skol_map`. There should always be a representative if things\n             // are properly well-formed.\n-            let mut unconstrained_regions = vec![];\n             let skol_representatives: FxHashMap<_, _> =\n                 skol_resolution_map\n                 .iter()\n-                .map(|(&skol, &(br, ref regions))| {\n+                .map(|(&skol, &(_, ref regions))| {\n                     let representative =\n                         regions.iter()\n                                .filter(|&&r| !skol_resolution_map.contains_key(r))\n                                .cloned()\n                                .next()\n-                               .unwrap_or_else(|| { // [1]\n-                                   unconstrained_regions.push(br);\n-                                   self.infcx.next_region_var(\n-                                       LateBoundRegion(span, br, HigherRankedType))\n-                               });\n-\n-                    // [1] There should always be a representative,\n-                    // unless the higher-ranked region did not appear\n-                    // in the values being matched. We should reject\n-                    // as ill-formed cases that can lead to this, but\n-                    // right now we sometimes issue warnings (see\n-                    // #32330).\n+                               .expect(\"no representative region\");\n \n                     (skol, representative)\n                 })\n@@ -216,10 +192,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // We are now done with these skolemized variables.\n             self.infcx.pop_skolemized(skol_map, snapshot);\n \n-            Ok(HrMatchResult {\n-                value: a_value,\n-                unconstrained_regions,\n-            })\n+            Ok(HrMatchResult { value: a_value })\n         });\n     }\n \n@@ -657,28 +630,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                        skol_br,\n                        tainted_region);\n \n-                let issue_32330 = if let &ty::ReVar(vid) = tainted_region {\n-                    match self.region_vars.var_origin(vid) {\n-                        RegionVariableOrigin::EarlyBoundRegion(_, _, issue_32330) => {\n-                            issue_32330.map(Box::new)\n-                        }\n-                        _ => None\n-                    }\n-                } else {\n-                    None\n-                };\n-\n-                if overly_polymorphic {\n+                return Err(if overly_polymorphic {\n                     debug!(\"Overly polymorphic!\");\n-                    return Err(TypeError::RegionsOverlyPolymorphic(skol_br,\n-                                                                   tainted_region,\n-                                                                   issue_32330));\n+                    TypeError::RegionsOverlyPolymorphic(skol_br, tainted_region)\n                 } else {\n                     debug!(\"Not as polymorphic!\");\n-                    return Err(TypeError::RegionsInsufficientlyPolymorphic(skol_br,\n-                                                                           tainted_region,\n-                                                                           issue_32330));\n-                }\n+                    TypeError::RegionsInsufficientlyPolymorphic(skol_br, tainted_region)\n+                })\n             }\n         }\n "}, {"sha": "6b60a248267171a91c44d8872a9f6fc2ac5159c4", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -299,7 +299,7 @@ pub enum RegionVariableOrigin {\n     Coercion(Span),\n \n     // Region variables created as the values for early-bound regions\n-    EarlyBoundRegion(Span, ast::Name, Option<ty::Issue32330>),\n+    EarlyBoundRegion(Span, ast::Name),\n \n     // Region variables created for bound regions\n     // in a function or method that is called\n@@ -989,7 +989,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                               span: Span,\n                               def: &ty::RegionParameterDef)\n                               -> ty::Region<'tcx> {\n-        self.next_region_var(EarlyBoundRegion(span, def.name, def.issue_32330))\n+        self.next_region_var(EarlyBoundRegion(span, def.name))\n     }\n \n     /// Create a type inference variable for the given\n@@ -1278,14 +1278,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                            -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>>\n     {\n         let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref(self.tcx), p.ty));\n-        let span = cause.span;\n         let trace = TypeTrace {\n             cause,\n             values: TraitRefs(ExpectedFound::new(true, match_pair.skip_binder().0, match_b))\n         };\n \n         let mut combine = self.combine_fields(trace, param_env);\n-        let result = combine.higher_ranked_match(span, &match_pair, &match_b, true)?;\n+        let result = combine.higher_ranked_match(&match_pair, &match_b, true)?;\n         Ok(InferOk { value: result, obligations: combine.obligations })\n     }\n "}, {"sha": "288390cb5e7c1b616bbf465b5935d839f3afbf6f", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -18,9 +18,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// the rustc crate store interface. This also includes types that\n-// are *mostly* used as a part of that interface, but these should\n-// probably get a better home if someone can find one.\n+//! the rustc crate store interface. This also includes types that\n+//! are *mostly* used as a part of that interface, but these should\n+//! probably get a better home if someone can find one.\n \n use hir::def;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n@@ -50,13 +50,13 @@ pub use self::NativeLibraryKind::*;\n \n // lonely orphan structs and enums looking for a better home\n \n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, Copy)]\n pub struct LinkMeta {\n     pub crate_hash: Svh,\n }\n \n-// Where a crate came from on the local filesystem. One of these three options\n-// must be non-None.\n+/// Where a crate came from on the local filesystem. One of these three options\n+/// must be non-None.\n #[derive(PartialEq, Clone, Debug)]\n pub struct CrateSource {\n     pub dylib: Option<(PathBuf, PathKind)>,\n@@ -120,10 +120,14 @@ pub enum LinkagePreference {\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub enum NativeLibraryKind {\n-    NativeStatic,    // native static library (.a archive)\n-    NativeStaticNobundle, // native static library, which doesn't get bundled into .rlibs\n-    NativeFramework, // macOS-specific\n-    NativeUnknown,   // default way to specify a dynamic library\n+    /// native static library (.a archive)\n+    NativeStatic,\n+    /// native static library, which doesn't get bundled into .rlibs\n+    NativeStaticNobundle,\n+    /// macOS-specific\n+    NativeFramework,\n+    /// default way to specify a dynamic library\n+    NativeUnknown,\n }\n \n #[derive(Clone, Hash, RustcEncodable, RustcDecodable)]\n@@ -161,15 +165,13 @@ pub struct ExternCrate {\n }\n \n pub struct EncodedMetadata {\n-    pub raw_data: Vec<u8>,\n-    pub hashes: EncodedMetadataHashes,\n+    pub raw_data: Vec<u8>\n }\n \n impl EncodedMetadata {\n     pub fn new() -> EncodedMetadata {\n         EncodedMetadata {\n             raw_data: Vec::new(),\n-            hashes: EncodedMetadataHashes::new(),\n         }\n     }\n }\n@@ -294,7 +296,7 @@ pub trait CrateStore {\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n                                  reachable: &NodeSet)\n-                                 -> EncodedMetadata;\n+                                 -> (EncodedMetadata, EncodedMetadataHashes);\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n@@ -424,7 +426,7 @@ impl CrateStore for DummyCrateStore {\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n                                  reachable: &NodeSet)\n-                                 -> EncodedMetadata {\n+                                 -> (EncodedMetadata, EncodedMetadataHashes) {\n         bug!(\"encode_metadata\")\n     }\n     fn metadata_encoding_version(&self) -> &[u8] { bug!(\"metadata_encoding_version\") }"}, {"sha": "d394c0f0c8734c1b3caba9108862254b81535a01", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -22,6 +22,9 @@ use std::mem;\n use std::usize;\n use syntax::ast;\n use syntax::print::pprust::PrintState;\n+\n+use rustc_data_structures::graph::OUTGOING;\n+\n use util::nodemap::NodeMap;\n use hir;\n use hir::intravisit::{self, IdRange};\n@@ -523,12 +526,16 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n                 changed: true\n             };\n \n+            let nodes_po = cfg.graph.nodes_in_postorder(OUTGOING, cfg.entry);\n             let mut temp = vec![0; words_per_id];\n+            let mut num_passes = 0;\n             while propcx.changed {\n+                num_passes += 1;\n                 propcx.changed = false;\n                 propcx.reset(&mut temp);\n-                propcx.walk_cfg(cfg, &mut temp);\n+                propcx.walk_cfg(cfg, &nodes_po, &mut temp);\n             }\n+            debug!(\"finished in {} iterations\", num_passes);\n         }\n \n         debug!(\"Dataflow result for {}:\", self.analysis_name);\n@@ -543,12 +550,15 @@ impl<'a, 'tcx, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, 'tcx, O> {\n impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n     fn walk_cfg(&mut self,\n                 cfg: &cfg::CFG,\n+                nodes_po: &[CFGIndex],\n                 in_out: &mut [usize]) {\n         debug!(\"DataFlowContext::walk_cfg(in_out={}) {}\",\n                bits_to_string(in_out), self.dfcx.analysis_name);\n         assert!(self.dfcx.bits_per_id > 0);\n \n-        cfg.graph.each_node(|node_index, node| {\n+        // Iterate over nodes in reverse postorder\n+        for &node_index in nodes_po.iter().rev() {\n+            let node = cfg.graph.node(node_index);\n             debug!(\"DataFlowContext::walk_cfg idx={:?} id={} begin in_out={}\",\n                    node_index, node.data.id(), bits_to_string(in_out));\n \n@@ -563,8 +573,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n \n             // Propagate state on-exit from node into its successors.\n             self.propagate_bits_into_graph_successors_of(in_out, cfg, node_index);\n-            true // continue to next node\n-        });\n+        }\n     }\n \n     fn reset(&mut self, bits: &mut [usize]) {"}, {"sha": "a525b4e13b78dd2b1cda110cc18da2d678f02e3d", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -13,7 +13,7 @@\n // from live codes are live, and everything else is dead.\n \n use hir::map as hir_map;\n-use hir::{self, PatKind};\n+use hir::{self, Item_, PatKind};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n \n@@ -189,6 +189,22 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         self.struct_has_extern_repr = had_extern_repr;\n         self.inherited_pub_visibility = had_inherited_pub_visibility;\n     }\n+\n+    fn mark_as_used_if_union(&mut self, did: DefId, fields: &hir::HirVec<hir::Field>) {\n+        if let Some(node_id) = self.tcx.hir.as_local_node_id(did) {\n+            if let Some(hir_map::NodeItem(item)) = self.tcx.hir.find(node_id) {\n+                if let Item_::ItemUnion(ref variant, _) = item.node {\n+                    if variant.fields().len() > 1 {\n+                        for field in variant.fields() {\n+                            if fields.iter().find(|x| x.name.node == field.name).is_some() {\n+                                self.live_symbols.insert(field.id);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n@@ -231,6 +247,13 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n             hir::ExprTupField(ref lhs, idx) => {\n                 self.handle_tup_field_access(&lhs, idx.node);\n             }\n+            hir::ExprStruct(_, ref fields, _) => {\n+                if let ty::TypeVariants::TyAdt(ref def, _) = self.tables.expr_ty(expr).sty {\n+                    if def.is_union() {\n+                        self.mark_as_used_if_union(def.did, fields);\n+                    }\n+                }\n+            }\n             _ => ()\n         }\n \n@@ -561,7 +584,6 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n             self.warn_dead_code(field.id, field.span,\n                                 field.name, \"field\");\n         }\n-\n         intravisit::walk_struct_field(self, field);\n     }\n \n@@ -603,6 +625,9 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n     let krate = tcx.hir.krate();\n     let live_symbols = find_live(tcx, access_levels, krate);\n-    let mut visitor = DeadVisitor { tcx: tcx, live_symbols: live_symbols };\n+    let mut visitor = DeadVisitor {\n+        tcx: tcx,\n+        live_symbols: live_symbols,\n+    };\n     intravisit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "1ea5b29b15bab108ef97d4e5d46d69993d452392", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -800,16 +800,19 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"determine_pat_move_mode cmt_discr={:?} pat={:?}\", cmt_discr,\n                pat);\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n-            match pat.node {\n-                PatKind::Binding(hir::BindByRef(..), ..) =>\n-                    mode.lub(BorrowingMatch),\n-                PatKind::Binding(hir::BindByValue(..), ..) => {\n-                    match copy_or_move(&self.mc, self.param_env, &cmt_pat, PatBindingMove) {\n-                        Copy => mode.lub(CopyingMatch),\n-                        Move(..) => mode.lub(MovingMatch),\n+            if let PatKind::Binding(..) = pat.node {\n+                let bm = *self.mc.tables.pat_binding_modes.get(&pat.id)\n+                                                          .expect(\"missing binding mode\");\n+                match bm {\n+                    ty::BindByReference(..) =>\n+                        mode.lub(BorrowingMatch),\n+                    ty::BindByValue(..) => {\n+                        match copy_or_move(&self.mc, self.param_env, &cmt_pat, PatBindingMove) {\n+                            Copy => mode.lub(CopyingMatch),\n+                            Move(..) => mode.lub(MovingMatch),\n+                        }\n                     }\n                 }\n-                _ => {}\n             }\n         }));\n     }\n@@ -822,8 +825,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         let ExprUseVisitor { ref mc, ref mut delegate, param_env } = *self;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n-            if let PatKind::Binding(bmode, def_id, ..) = pat.node {\n+            if let PatKind::Binding(_, def_id, ..) = pat.node {\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n+                let bm = *mc.tables.pat_binding_modes.get(&pat.id).expect(\"missing binding mode\");\n \n                 // pat_ty: the type of the binding being produced.\n                 let pat_ty = return_if_err!(mc.node_ty(pat.id));\n@@ -836,14 +840,14 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 }\n \n                 // It is also a borrow or copy/move of the value being matched.\n-                match bmode {\n-                    hir::BindByRef(m) => {\n+                match bm {\n+                    ty::BindByReference(m) => {\n                         if let ty::TyRef(r, _) = pat_ty.sty {\n                             let bk = ty::BorrowKind::from_mutbl(m);\n                             delegate.borrow(pat.id, pat.span, cmt_pat, r, bk, RefBinding);\n                         }\n                     }\n-                    hir::BindByValue(..) => {\n+                    ty::BindByValue(..) => {\n                         let mode = copy_or_move(mc, param_env, &cmt_pat, PatBindingMove);\n                         debug!(\"walk_pat binding consuming pat\");\n                         delegate.consume_pat(pat, cmt_pat, mode);"}, {"sha": "3abd63fccdb382db9a307150f8f0183613579e39", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -330,11 +330,12 @@ impl MutabilityCategory {\n         ret\n     }\n \n-    fn from_local(tcx: TyCtxt, id: ast::NodeId) -> MutabilityCategory {\n+    fn from_local(tcx: TyCtxt, tables: &ty::TypeckTables, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.hir.get(id) {\n             hir_map::NodeLocal(p) => match p.node {\n-                PatKind::Binding(bind_mode, ..) => {\n-                    if bind_mode == hir::BindByValue(hir::MutMutable) {\n+                PatKind::Binding(..) => {\n+                    let bm = *tables.pat_binding_modes.get(&p.id).expect(\"missing binding mode\");\n+                    if bm == ty::BindByValue(hir::MutMutable) {\n                         McDeclared\n                     } else {\n                         McImmutable\n@@ -475,16 +476,21 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // *being borrowed* is.  But ideally we would put in a more\n         // fundamental fix to this conflated use of the node id.\n         let ret_ty = match pat.node {\n-            PatKind::Binding(hir::BindByRef(_), ..) => {\n-                // a bind-by-ref means that the base_ty will be the type of the ident itself,\n-                // but what we want here is the type of the underlying value being borrowed.\n-                // So peel off one-level, turning the &T into T.\n-                match base_ty.builtin_deref(false, ty::NoPreference) {\n-                    Some(t) => t.ty,\n-                    None => {\n-                        debug!(\"By-ref binding of non-derefable type {:?}\", base_ty);\n-                        return Err(());\n+            PatKind::Binding(..) => {\n+                let bm = *self.tables.pat_binding_modes.get(&pat.id).expect(\"missing binding mode\");\n+                if let ty::BindByReference(_) = bm {\n+                    // a bind-by-ref means that the base_ty will be the type of the ident itself,\n+                    // but what we want here is the type of the underlying value being borrowed.\n+                    // So peel off one-level, turning the &T into T.\n+                    match base_ty.builtin_deref(false, ty::NoPreference) {\n+                        Some(t) => t.ty,\n+                        None => {\n+                            debug!(\"By-ref binding of non-derefable type {:?}\", base_ty);\n+                            return Err(());\n+                        }\n                     }\n+                } else {\n+                    base_ty\n                 }\n             }\n             _ => base_ty,\n@@ -659,7 +665,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 id,\n                 span,\n                 cat: Categorization::Local(vid),\n-                mutbl: MutabilityCategory::from_local(self.tcx, vid),\n+                mutbl: MutabilityCategory::from_local(self.tcx, self.tables, vid),\n                 ty: expr_ty,\n                 note: NoteNone\n             }))\n@@ -717,7 +723,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         let var_ty = self.node_ty(var_id)?;\n \n         // Mutability of original variable itself\n-        let var_mutbl = MutabilityCategory::from_local(self.tcx, var_id);\n+        let var_mutbl = MutabilityCategory::from_local(self.tcx, self.tables, var_id);\n \n         // Construct the upvar. This represents access to the field\n         // from the environment (perhaps we should eventually desugar"}, {"sha": "82e2a2114da5e28d40ec7dc03f8799623e9a20e0", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -459,10 +459,10 @@ impl<'tcx> RegionMaps {\n                                    -> CodeExtent {\n         if scope_a == scope_b { return scope_a; }\n \n-        /// [1] The initial values for `a_buf` and `b_buf` are not used.\n-        /// The `ancestors_of` function will return some prefix that\n-        /// is re-initialized with new values (or else fallback to a\n-        /// heap-allocated vector).\n+        // [1] The initial values for `a_buf` and `b_buf` are not used.\n+        // The `ancestors_of` function will return some prefix that\n+        // is re-initialized with new values (or else fallback to a\n+        // heap-allocated vector).\n         let mut a_buf: [CodeExtent; 32] = [scope_a /* [1] */; 32];\n         let mut a_vec: Vec<CodeExtent> = vec![];\n         let mut b_buf: [CodeExtent; 32] = [scope_b /* [1] */; 32];\n@@ -890,8 +890,32 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     ///        | ( ..., P&, ... )\n     ///        | box P&\n     fn is_binding_pat(pat: &hir::Pat) -> bool {\n+        // Note that the code below looks for *explicit* refs only, that is, it won't\n+        // know about *implicit* refs as introduced in #42640.\n+        //\n+        // This is not a problem. For example, consider\n+        //\n+        //      let (ref x, ref y) = (Foo { .. }, Bar { .. });\n+        //\n+        // Due to the explicit refs on the left hand side, the below code would signal\n+        // that the temporary value on the right hand side should live until the end of\n+        // the enclosing block (as opposed to being dropped after the let is complete).\n+        //\n+        // To create an implicit ref, however, you must have a borrowed value on the RHS\n+        // already, as in this example (which won't compile before #42640):\n+        //\n+        //      let Foo { x, .. } = &Foo { x: ..., ... };\n+        //\n+        // in place of\n+        //\n+        //      let Foo { ref x, .. } = Foo { ... };\n+        //\n+        // In the former case (the implicit ref version), the temporary is created by the\n+        // & expression, and its lifetime would be extended to the end of the block (due\n+        // to a different rule, not the below code).\n         match pat.node {\n-            PatKind::Binding(hir::BindByRef(_), ..) => true,\n+            PatKind::Binding(hir::BindingAnnotation::Ref, ..) |\n+            PatKind::Binding(hir::BindingAnnotation::RefMut, ..) => true,\n \n             PatKind::Struct(_, ref field_pats, _) => {\n                 field_pats.iter().any(|fp| is_binding_pat(&fp.node.pat))"}, {"sha": "13efa94a5c9484ca1d603518f451ab3745c89277", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -153,10 +153,6 @@ pub struct NamedRegionMap {\n     // (b) it DOES appear in the arguments.\n     pub late_bound: NodeSet,\n \n-    // Contains the node-ids for lifetimes that were (incorrectly) categorized\n-    // as late-bound, until #32330 was fixed.\n-    pub issue_32330: NodeMap<ty::Issue32330>,\n-\n     // For each type and trait definition, maps type parameters\n     // to the trait object lifetime defaults computed from them.\n     pub object_lifetime_defaults: NodeMap<Vec<ObjectLifetimeDefault>>,\n@@ -261,7 +257,6 @@ pub fn krate(sess: &Session,\n     let mut map = NamedRegionMap {\n         defs: NodeMap(),\n         late_bound: NodeSet(),\n-        issue_32330: NodeMap(),\n         object_lifetime_defaults: compute_object_lifetime_defaults(sess, hir_map),\n     };\n     sess.track_errors(|| {\n@@ -303,7 +298,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             hir::ItemFn(ref decl, _, _, _, ref generics, _) => {\n-                self.visit_early_late(item.id, None, decl, generics, |this| {\n+                self.visit_early_late(None, decl, generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n             }\n@@ -355,7 +350,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n         match item.node {\n             hir::ForeignItemFn(ref decl, _, ref generics) => {\n-                self.visit_early_late(item.id, None, decl, generics, |this| {\n+                self.visit_early_late(None, decl, generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n                 })\n             }\n@@ -406,7 +401,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         if let hir::TraitItemKind::Method(ref sig, _) = trait_item.node {\n             self.visit_early_late(\n-                trait_item.id,\n                 Some(self.hir_map.get_parent(trait_item.id)),\n                 &sig.decl, &sig.generics,\n                 |this| intravisit::walk_trait_item(this, trait_item))\n@@ -418,7 +412,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n             self.visit_early_late(\n-                impl_item.id,\n                 Some(self.hir_map.get_parent(impl_item.id)),\n                 &sig.decl, &sig.generics,\n                 |this| intravisit::walk_impl_item(this, impl_item))\n@@ -811,18 +804,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// bound lifetimes are resolved by name and associated with a binder id (`binder_id`), so the\n     /// ordering is not important there.\n     fn visit_early_late<F>(&mut self,\n-                           fn_id: ast::NodeId,\n                            parent_id: Option<ast::NodeId>,\n                            decl: &'tcx hir::FnDecl,\n                            generics: &'tcx hir::Generics,\n                            walk: F) where\n         F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n     {\n-        let fn_def_id = self.hir_map.local_def_id(fn_id);\n-        insert_late_bound_lifetimes(self.map,\n-                                    fn_def_id,\n-                                    decl,\n-                                    generics);\n+        insert_late_bound_lifetimes(self.map, decl, generics);\n \n         // Find the start of nested early scopes, e.g. in methods.\n         let mut index = 0;\n@@ -1549,7 +1537,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// not amongst the inputs to a projection.  In other words, `<&'a\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n-                               fn_def_id: DefId,\n                                decl: &hir::FnDecl,\n                                generics: &hir::Generics) {\n     debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n@@ -1607,22 +1594,9 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n         // any `impl Trait` in the return type? early-bound.\n         if appears_in_output.impl_trait { continue; }\n \n-        // does not appear in the inputs, but appears in the return\n-        // type? eventually this will be early-bound, but for now we\n-        // just mark it so we can issue warnings.\n-        let constrained_by_input = constrained_by_input.regions.contains(&name);\n-        let appears_in_output = appears_in_output.regions.contains(&name);\n-        if !constrained_by_input && appears_in_output {\n-            debug!(\"inserting issue_32330 entry for {:?}, {:?} on {:?}\",\n-                   lifetime.lifetime.id,\n-                   name,\n-                   fn_def_id);\n-            map.issue_32330.insert(\n-                lifetime.lifetime.id,\n-                ty::Issue32330 {\n-                    fn_def_id,\n-                    region_name: name,\n-                });\n+        // does not appear in the inputs, but appears in the return type? early-bound.\n+        if !constrained_by_input.regions.contains(&name) &&\n+            appears_in_output.regions.contains(&name) {\n             continue;\n         }\n "}, {"sha": "4063609474bc97a30d003009b5a8fd1332ab7e95", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 91, "deletions": 11, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -25,7 +25,7 @@ use ty::{self, AdtDef, ClosureSubsts, Region, Ty};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use util::ppaux;\n use rustc_back::slice;\n-use hir::InlineAsm;\n+use hir::{self, InlineAsm};\n use std::ascii;\n use std::borrow::{Cow};\n use std::cell::Ref;\n@@ -894,12 +894,18 @@ pub enum StatementKind<'tcx> {\n     /// End the current live range for the storage of the local.\n     StorageDead(Lvalue<'tcx>),\n \n+    /// Execute a piece of inline Assembly.\n     InlineAsm {\n         asm: Box<InlineAsm>,\n         outputs: Vec<Lvalue<'tcx>>,\n         inputs: Vec<Operand<'tcx>>\n     },\n \n+    /// Assert the given lvalues to be valid inhabitants of their type.  These statements are\n+    /// currently only interpreted by miri and only generated when \"-Z mir-emit-validate\" is passed.\n+    /// See <https://internals.rust-lang.org/t/types-as-contracts/5562/73> for more details.\n+    Validate(ValidationOp, Vec<ValidationOperand<'tcx, Lvalue<'tcx>>>),\n+\n     /// Mark one terminating point of an extent (i.e. static region).\n     /// (The starting point(s) arise implicitly from borrows.)\n     EndRegion(CodeExtent),\n@@ -908,13 +914,65 @@ pub enum StatementKind<'tcx> {\n     Nop,\n }\n \n+/// The `ValidationOp` describes what happens with each of the operands of a\n+/// `Validate` statement.\n+#[derive(Copy, Clone, RustcEncodable, RustcDecodable, PartialEq, Eq)]\n+pub enum ValidationOp {\n+    /// Recursively traverse the lvalue following the type and validate that all type\n+    /// invariants are maintained.  Furthermore, acquire exclusive/read-only access to the\n+    /// memory reachable from the lvalue.\n+    Acquire,\n+    /// Recursive traverse the *mutable* part of the type and relinquish all exclusive\n+    /// access.\n+    Release,\n+    /// Recursive traverse the *mutable* part of the type and relinquish all exclusive\n+    /// access *until* the given region ends.  Then, access will be recovered.\n+    Suspend(CodeExtent),\n+}\n+\n+impl Debug for ValidationOp {\n+    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n+        use self::ValidationOp::*;\n+        match *self {\n+            Acquire => write!(fmt, \"Acquire\"),\n+            Release => write!(fmt, \"Release\"),\n+            // (reuse lifetime rendering policy from ppaux.)\n+            Suspend(ref ce) => write!(fmt, \"Suspend({})\", ty::ReScope(*ce)),\n+        }\n+    }\n+}\n+\n+// This is generic so that it can be reused by miri\n+#[derive(Clone, RustcEncodable, RustcDecodable)]\n+pub struct ValidationOperand<'tcx, T> {\n+    pub lval: T,\n+    pub ty: Ty<'tcx>,\n+    pub re: Option<CodeExtent>,\n+    pub mutbl: hir::Mutability,\n+}\n+\n+impl<'tcx, T: Debug> Debug for ValidationOperand<'tcx, T> {\n+    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}: {:?}\", self.lval, self.ty)?;\n+        if let Some(ce) = self.re {\n+            // (reuse lifetime rendering policy from ppaux.)\n+            write!(fmt, \"/{}\", ty::ReScope(ce))?;\n+        }\n+        if let hir::MutImmutable = self.mutbl {\n+            write!(fmt, \" (imm)\")?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl<'tcx> Debug for Statement<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::StatementKind::*;\n         match self.kind {\n             Assign(ref lv, ref rv) => write!(fmt, \"{:?} = {:?}\", lv, rv),\n             // (reuse lifetime rendering policy from ppaux.)\n             EndRegion(ref ce) => write!(fmt, \"EndRegion({})\", ty::ReScope(*ce)),\n+            Validate(ref op, ref lvalues) => write!(fmt, \"Validate({:?}, {:?})\", op, lvalues),\n             StorageLive(ref lv) => write!(fmt, \"StorageLive({:?})\", lv),\n             StorageDead(ref lv) => write!(fmt, \"StorageDead({:?})\", lv),\n             SetDiscriminant{lvalue: ref lv, variant_index: index} => {\n@@ -963,15 +1021,15 @@ impl_stable_hash_for!(struct Static<'tcx> {\n /// shared between `Constant` and `Lvalue`. See the aliases\n /// `LvalueProjection` etc below.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub struct Projection<'tcx, B, V> {\n+pub struct Projection<'tcx, B, V, T> {\n     pub base: B,\n-    pub elem: ProjectionElem<'tcx, V>,\n+    pub elem: ProjectionElem<'tcx, V, T>,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub enum ProjectionElem<'tcx, V> {\n+pub enum ProjectionElem<'tcx, V, T> {\n     Deref,\n-    Field(Field, Ty<'tcx>),\n+    Field(Field, T),\n     Index(V),\n \n     /// These indices are generated by slice patterns. Easiest to explain\n@@ -1008,11 +1066,11 @@ pub enum ProjectionElem<'tcx, V> {\n \n /// Alias for projections as they appear in lvalues, where the base is an lvalue\n /// and the index is an operand.\n-pub type LvalueProjection<'tcx> = Projection<'tcx, Lvalue<'tcx>, Operand<'tcx>>;\n+pub type LvalueProjection<'tcx> = Projection<'tcx, Lvalue<'tcx>, Operand<'tcx>, Ty<'tcx>>;\n \n /// Alias for projections as they appear in lvalues, where the base is an lvalue\n /// and the index is an operand.\n-pub type LvalueElem<'tcx> = ProjectionElem<'tcx, Operand<'tcx>>;\n+pub type LvalueElem<'tcx> = ProjectionElem<'tcx, Operand<'tcx>, Ty<'tcx>>;\n \n newtype_index!(Field, \"field\");\n \n@@ -1606,6 +1664,21 @@ impl<'tcx> TypeFoldable<'tcx> for BasicBlockData<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ValidationOperand<'tcx, Lvalue<'tcx>> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ValidationOperand {\n+            lval: self.lval.fold_with(folder),\n+            ty: self.ty.fold_with(folder),\n+            re: self.re,\n+            mutbl: self.mutbl,\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.lval.visit_with(visitor) || self.ty.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         use mir::StatementKind::*;\n@@ -1630,6 +1703,10 @@ impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n             // trait with a `fn fold_extent`.\n             EndRegion(ref extent) => EndRegion(extent.clone()),\n \n+            Validate(ref op, ref lvals) =>\n+                Validate(op.clone(),\n+                         lvals.iter().map(|operand| operand.fold_with(folder)).collect()),\n+\n             Nop => Nop,\n         };\n         Statement {\n@@ -1655,6 +1732,9 @@ impl<'tcx> TypeFoldable<'tcx> for Statement<'tcx> {\n             // trait with a `fn visit_extent`.\n             EndRegion(ref _extent) => false,\n \n+            Validate(ref _op, ref lvalues) =>\n+                lvalues.iter().any(|ty_and_lvalue| ty_and_lvalue.visit_with(visitor)),\n+\n             Nop => false,\n         }\n     }\n@@ -1857,16 +1937,16 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n     }\n }\n \n-impl<'tcx, B, V> TypeFoldable<'tcx> for Projection<'tcx, B, V>\n-    where B: TypeFoldable<'tcx>, V: TypeFoldable<'tcx>\n+impl<'tcx, B, V, T> TypeFoldable<'tcx> for Projection<'tcx, B, V, T>\n+    where B: TypeFoldable<'tcx>, V: TypeFoldable<'tcx>, T: TypeFoldable<'tcx>\n {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         use mir::ProjectionElem::*;\n \n         let base = self.base.fold_with(folder);\n         let elem = match self.elem {\n             Deref => Deref,\n-            Field(f, ty) => Field(f, ty.fold_with(folder)),\n+            Field(f, ref ty) => Field(f, ty.fold_with(folder)),\n             Index(ref v) => Index(v.fold_with(folder)),\n             ref elem => elem.clone()\n         };\n@@ -1882,7 +1962,7 @@ impl<'tcx, B, V> TypeFoldable<'tcx> for Projection<'tcx, B, V>\n \n         self.base.visit_with(visitor) ||\n             match self.elem {\n-                Field(_, ty) => ty.visit_with(visitor),\n+                Field(_, ref ty) => ty.visit_with(visitor),\n                 Index(ref v) => v.visit_with(visitor),\n                 _ => false\n             }"}, {"sha": "8cc5b6cab116e58b4e38f9dea411241502ed9d26", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -14,7 +14,6 @@ use ty::subst::Substs;\n use ty::{ClosureSubsts, Region, Ty};\n use mir::*;\n use rustc_const_math::ConstUsize;\n-use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n \n // # The MIR Visitor\n@@ -264,9 +263,15 @@ macro_rules! make_mir_visitor {\n \n             fn super_mir(&mut self,\n                          mir: & $($mutability)* Mir<'tcx>) {\n-                for index in 0..mir.basic_blocks().len() {\n-                    let block = BasicBlock::new(index);\n-                    self.visit_basic_block_data(block, &$($mutability)* mir[block]);\n+                // for best performance, we want to use an iterator rather\n+                // than a for-loop, to avoid calling Mir::invalidate for\n+                // each basic block.\n+                macro_rules! basic_blocks {\n+                    (mut) => (mir.basic_blocks_mut().iter_enumerated_mut());\n+                    () => (mir.basic_blocks().iter_enumerated());\n+                };\n+                for (bb, data) in basic_blocks!($($mutability)*) {\n+                    self.visit_basic_block_data(bb, data);\n                 }\n \n                 for scope in &$($mutability)* mir.visibility_scopes {\n@@ -337,6 +342,13 @@ macro_rules! make_mir_visitor {\n                         self.visit_assign(block, lvalue, rvalue, location);\n                     }\n                     StatementKind::EndRegion(_) => {}\n+                    StatementKind::Validate(_, ref $($mutability)* lvalues) => {\n+                        for operand in lvalues {\n+                            self.visit_lvalue(& $($mutability)* operand.lval,\n+                                              LvalueContext::Validate, location);\n+                            self.visit_ty(& $($mutability)* operand.ty, Lookup::Loc(location));\n+                        }\n+                    }\n                     StatementKind::SetDiscriminant{ ref $($mutability)* lvalue, .. } => {\n                         self.visit_lvalue(lvalue, LvalueContext::Store, location);\n                     }\n@@ -807,6 +819,9 @@ pub enum LvalueContext<'tcx> {\n     // Starting and ending a storage live range\n     StorageLive,\n     StorageDead,\n+\n+    // Validation command\n+    Validate,\n }\n \n impl<'tcx> LvalueContext<'tcx> {\n@@ -853,7 +868,8 @@ impl<'tcx> LvalueContext<'tcx> {\n             LvalueContext::Borrow { kind: BorrowKind::Shared, .. } |\n             LvalueContext::Borrow { kind: BorrowKind::Unique, .. } |\n             LvalueContext::Projection(Mutability::Not) | LvalueContext::Consume |\n-            LvalueContext::StorageLive | LvalueContext::StorageDead => false,\n+            LvalueContext::StorageLive | LvalueContext::StorageDead |\n+            LvalueContext::Validate => false,\n         }\n     }\n \n@@ -865,7 +881,8 @@ impl<'tcx> LvalueContext<'tcx> {\n             LvalueContext::Projection(Mutability::Not) | LvalueContext::Consume => true,\n             LvalueContext::Borrow { kind: BorrowKind::Mut, .. } | LvalueContext::Store |\n             LvalueContext::Call | LvalueContext::Projection(Mutability::Mut) |\n-            LvalueContext::Drop | LvalueContext::StorageLive | LvalueContext::StorageDead => false,\n+            LvalueContext::Drop | LvalueContext::StorageLive | LvalueContext::StorageDead |\n+            LvalueContext::Validate => false,\n         }\n     }\n "}, {"sha": "6995f0996774fbbb5dde1570a2d7e58e49e789b7", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1025,6 +1025,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"the directory the MIR is dumped into\"),\n     dump_mir_exclude_pass_number: bool = (false, parse_bool, [UNTRACKED],\n           \"if set, exclude the pass number when dumping MIR (used in tests)\"),\n+    mir_emit_validate: usize = (0, parse_uint, [TRACKED],\n+          \"emit Validate MIR statements, interpreted e.g. by miri (0: do not emit; 1: if function \\\n+           contains unsafe block, only validate arguments; 2: always emit full validation)\"),\n     perf_stats: bool = (false, parse_bool, [UNTRACKED],\n           \"print some performance-related statistics\"),\n     hir_stats: bool = (false, parse_bool, [UNTRACKED],\n@@ -1059,6 +1062,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"choose which RELRO level to use\"),\n     nll: bool = (false, parse_bool, [UNTRACKED],\n                  \"run the non-lexical lifetimes MIR pass\"),\n+    trans_time_graph: bool = (false, parse_bool, [UNTRACKED],\n+        \"generate a graphical HTML report of time spent in trans and LLVM\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -1498,6 +1503,23 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         early_error(error_format, \"Value for codegen units must be a positive nonzero integer\");\n     }\n \n+    // It's possible that we have `codegen_units > 1` but only one item in\n+    // `trans.modules`.  We could theoretically proceed and do LTO in that\n+    // case, but it would be confusing to have the validity of\n+    // `-Z lto -C codegen-units=2` depend on details of the crate being\n+    // compiled, so we complain regardless.\n+    if cg.lto && cg.codegen_units > 1 {\n+        // This case is impossible to handle because LTO expects to be able\n+        // to combine the entire crate and all its dependencies into a\n+        // single compilation unit, but each codegen unit is in a separate\n+        // LLVM context, so they can't easily be combined.\n+        early_error(error_format, \"can't perform LTO when using multiple codegen units\");\n+    }\n+\n+    if cg.lto && debugging_opts.incremental.is_some() {\n+        early_error(error_format, \"can't perform LTO when compiling incrementally\");\n+    }\n+\n     let mut prints = Vec::<PrintRequest>::new();\n     if cg.target_cpu.as_ref().map_or(false, |s| s == \"help\") {\n         prints.push(PrintRequest::TargetCPUs);"}, {"sha": "71f4c8441b2b0562f132015edf5815cd380157cc", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 21, "deletions": 36, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -463,13 +463,19 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             selcx.infcx().report_overflow_error(&obligation, false);\n         }\n         Err(ProjectionCacheEntry::NormalizedTy(ty)) => {\n-            // If we find the value in the cache, then the obligations\n-            // have already been returned from the previous entry (and\n-            // should therefore have been honored).\n+            // If we find the value in the cache, then return it along\n+            // with the obligations that went along with it. Note\n+            // that, when using a fulfillment context, these\n+            // obligations could in principle be ignored: they have\n+            // already been registered when the cache entry was\n+            // created (and hence the new ones will quickly be\n+            // discarded as duplicated). But when doing trait\n+            // evaluation this is not the case, and dropping the trait\n+            // evaluations can causes ICEs (e.g. #43132).\n             debug!(\"opt_normalize_projection_type: \\\n                     found normalized ty `{:?}`\",\n                    ty);\n-            return Some(NormalizedTy { value: ty, obligations: vec![] });\n+            return Some(ty);\n         }\n         Err(ProjectionCacheEntry::Error) => {\n             debug!(\"opt_normalize_projection_type: \\\n@@ -480,9 +486,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n \n     let obligation = Obligation::with_depth(cause.clone(), depth, param_env, projection_ty);\n     match project_type(selcx, &obligation) {\n-        Ok(ProjectedTy::Progress(Progress { ty: projected_ty,\n-                                            mut obligations,\n-                                            cacheable })) => {\n+        Ok(ProjectedTy::Progress(Progress { ty: projected_ty, mut obligations })) => {\n             // if projection succeeded, then what we get out of this\n             // is also non-normalized (consider: it was derived from\n             // an impl, where-clause etc) and hence we must\n@@ -491,12 +495,10 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             debug!(\"opt_normalize_projection_type: \\\n                     projected_ty={:?} \\\n                     depth={} \\\n-                    obligations={:?} \\\n-                    cacheable={:?}\",\n+                    obligations={:?}\",\n                    projected_ty,\n                    depth,\n-                   obligations,\n-                   cacheable);\n+                   obligations);\n \n             let result = if projected_ty.has_projection_types() {\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx,\n@@ -521,8 +523,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                     obligations,\n                 }\n             };\n-            infcx.projection_cache.borrow_mut()\n-                                  .complete(projection_ty, &result, cacheable);\n+            infcx.projection_cache.borrow_mut().complete(projection_ty, &result);\n             Some(result)\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n@@ -533,8 +534,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                 value: projected_ty,\n                 obligations: vec![]\n             };\n-            infcx.projection_cache.borrow_mut()\n-                                  .complete(projection_ty, &result, true);\n+            infcx.projection_cache.borrow_mut().complete(projection_ty, &result);\n             Some(result)\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n@@ -607,15 +607,13 @@ enum ProjectedTy<'tcx> {\n struct Progress<'tcx> {\n     ty: Ty<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n-    cacheable: bool,\n }\n \n impl<'tcx> Progress<'tcx> {\n     fn error<'a,'gcx>(tcx: TyCtxt<'a,'gcx,'tcx>) -> Self {\n         Progress {\n             ty: tcx.types.err,\n             obligations: vec![],\n-            cacheable: true\n         }\n     }\n \n@@ -1286,7 +1284,6 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n             Progress {\n                 ty: ty_match.value,\n                 obligations,\n-                cacheable: ty_match.unconstrained_regions.is_empty(),\n             }\n         }\n         Err(e) => {\n@@ -1330,7 +1327,6 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     Progress {\n         ty: ty.subst(tcx, substs),\n         obligations: nested,\n-        cacheable: true\n     }\n }\n \n@@ -1394,7 +1390,7 @@ enum ProjectionCacheEntry<'tcx> {\n     InProgress,\n     Ambiguous,\n     Error,\n-    NormalizedTy(Ty<'tcx>),\n+    NormalizedTy(NormalizedTy<'tcx>),\n }\n \n // NB: intentionally not Clone\n@@ -1438,22 +1434,11 @@ impl<'tcx> ProjectionCache<'tcx> {\n         Ok(())\n     }\n \n-    /// Indicates that `key` was normalized to `value`. If `cacheable` is false,\n-    /// then this result is sadly not cacheable.\n-    fn complete(&mut self,\n-                key: ty::ProjectionTy<'tcx>,\n-                value: &NormalizedTy<'tcx>,\n-                cacheable: bool) {\n-        let fresh_key = if cacheable {\n-            debug!(\"ProjectionCacheEntry::complete: adding cache entry: key={:?}, value={:?}\",\n-                   key, value);\n-            self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value.value))\n-        } else {\n-            debug!(\"ProjectionCacheEntry::complete: cannot cache: key={:?}, value={:?}\",\n-                   key, value);\n-            !self.map.remove(key)\n-        };\n-\n+    /// Indicates that `key` was normalized to `value`.\n+    fn complete(&mut self, key: ty::ProjectionTy<'tcx>, value: &NormalizedTy<'tcx>) {\n+        debug!(\"ProjectionCacheEntry::complete: adding cache entry: key={:?}, value={:?}\",\n+               key, value);\n+        let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value.clone()));\n         assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n     }\n "}, {"sha": "3db61b76cc55c57e3a7f8ce54672bbe7f75f05ec", "filename": "src/librustc/ty/binding.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Fbinding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Fbinding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fbinding.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use hir::BindingAnnotation::*;\n+use hir::BindingAnnotation;\n+use hir::Mutability;\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum BindingMode {\n+    BindByReference(Mutability),\n+    BindByValue(Mutability),\n+}\n+\n+impl BindingMode {\n+    pub fn convert(ba: BindingAnnotation) -> BindingMode {\n+        match ba {\n+            Unannotated => BindingMode::BindByValue(Mutability::MutImmutable),\n+            Mutable => BindingMode::BindByValue(Mutability::MutMutable),\n+            Ref => BindingMode::BindByReference(Mutability::MutImmutable),\n+            RefMut => BindingMode::BindByReference(Mutability::MutMutable),\n+        }\n+    }\n+}\n+\n+impl_stable_hash_for!(enum self::BindingMode {\n+    BindByReference(mutability),\n+    BindByValue(mutability)\n+});"}, {"sha": "0c79b2f23b94409386da44488079e2f863ed175a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -40,6 +40,7 @@ use ty::layout::{Layout, TargetDataLayout};\n use ty::inhabitedness::DefIdForest;\n use ty::maps;\n use ty::steal::Steal;\n+use ty::BindingMode;\n use util::nodemap::{NodeMap, NodeSet, DefIdSet};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n@@ -223,6 +224,9 @@ pub struct TypeckTables<'tcx> {\n \n     pub adjustments: NodeMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n \n+    // Stores the actual binding mode for all instances of hir::BindingAnnotation.\n+    pub pat_binding_modes: NodeMap<BindingMode>,\n+\n     /// Borrows\n     pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n \n@@ -278,6 +282,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             node_types: FxHashMap(),\n             node_substs: NodeMap(),\n             adjustments: NodeMap(),\n+            pat_binding_modes: NodeMap(),\n             upvar_capture_map: FxHashMap(),\n             generator_sigs: NodeMap(),\n             generator_interiors: NodeMap(),"}, {"sha": "802994ae0948ab452c89afbc75cf6dfff9177315", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -39,8 +39,8 @@ pub enum TypeError<'tcx> {\n     RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n     RegionsNotSame(Region<'tcx>, Region<'tcx>),\n     RegionsNoOverlap(Region<'tcx>, Region<'tcx>),\n-    RegionsInsufficientlyPolymorphic(BoundRegion, Region<'tcx>, Option<Box<ty::Issue32330>>),\n-    RegionsOverlyPolymorphic(BoundRegion, Region<'tcx>, Option<Box<ty::Issue32330>>),\n+    RegionsInsufficientlyPolymorphic(BoundRegion, Region<'tcx>),\n+    RegionsOverlyPolymorphic(BoundRegion, Region<'tcx>),\n     Sorts(ExpectedFound<Ty<'tcx>>),\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n     FloatMismatch(ExpectedFound<ast::FloatTy>),\n@@ -116,13 +116,13 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             RegionsNoOverlap(..) => {\n                 write!(f, \"lifetimes do not intersect\")\n             }\n-            RegionsInsufficientlyPolymorphic(br, _, _) => {\n+            RegionsInsufficientlyPolymorphic(br, _) => {\n                 write!(f,\n                        \"expected bound lifetime parameter{}{}, found concrete lifetime\",\n                        if br.is_named() { \" \" } else { \"\" },\n                        br)\n             }\n-            RegionsOverlyPolymorphic(br, _, _) => {\n+            RegionsOverlyPolymorphic(br, _) => {\n                 write!(f,\n                        \"expected concrete lifetime, found bound lifetime parameter{}{}\",\n                        if br.is_named() { \" \" } else { \"\" },\n@@ -258,15 +258,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 self.note_and_explain_region(db, \"...does not overlap \",\n                                            region2, \"\");\n             }\n-            RegionsInsufficientlyPolymorphic(_, conc_region, _) => {\n+            RegionsInsufficientlyPolymorphic(_, conc_region) => {\n                 self.note_and_explain_region(db, \"concrete lifetime that was found is \",\n                                            conc_region, \"\");\n             }\n-            RegionsOverlyPolymorphic(_, &ty::ReVar(_), _) => {\n+            RegionsOverlyPolymorphic(_, &ty::ReVar(_)) => {\n                 // don't bother to print out the message below for\n                 // inference variables, it's not very illuminating.\n             }\n-            RegionsOverlyPolymorphic(_, conc_region, _) => {\n+            RegionsOverlyPolymorphic(_, conc_region) => {\n                 self.note_and_explain_region(db, \"expected concrete lifetime is \",\n                                            conc_region, \"\");\n             }"}, {"sha": "54e15ed01f074b7d548899e3eede6d9009ca31ff", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -581,14 +581,14 @@ pub struct Struct {\n     pub min_size: Size,\n }\n \n-// Info required to optimize struct layout.\n+/// Info required to optimize struct layout.\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug)]\n enum StructKind {\n-    // A tuple, closure, or univariant which cannot be coerced to unsized.\n+    /// A tuple, closure, or univariant which cannot be coerced to unsized.\n     AlwaysSizedUnivariant,\n-    // A univariant, the last field of which may be coerced to unsized.\n+    /// A univariant, the last field of which may be coerced to unsized.\n     MaybeUnsizedUnivariant,\n-    // A univariant, but part of an enum.\n+    /// A univariant, but part of an enum.\n     EnumVariant,\n }\n \n@@ -1020,7 +1020,7 @@ pub enum Layout {\n     /// TyRawPtr or TyRef with a !Sized pointee.\n     FatPointer {\n         metadata: Primitive,\n-        // If true, the pointer cannot be null.\n+        /// If true, the pointer cannot be null.\n         non_zero: bool\n     },\n \n@@ -1031,8 +1031,8 @@ pub enum Layout {\n         discr: Integer,\n         signed: bool,\n         non_zero: bool,\n-        // Inclusive discriminant range.\n-        // If min > max, it represents min...u64::MAX followed by 0...max.\n+        /// Inclusive discriminant range.\n+        /// If min > max, it represents min...u64::MAX followed by 0...max.\n         // FIXME(eddyb) always use the shortest range, e.g. by finding\n         // the largest space between two consecutive discriminants and\n         // taking everything else as the (shortest) discriminant range.\n@@ -1043,7 +1043,7 @@ pub enum Layout {\n     /// Single-case enums, and structs/tuples.\n     Univariant {\n         variant: Struct,\n-        // If true, the structure is NonZero.\n+        /// If true, the structure is NonZero.\n         // FIXME(eddyb) use a newtype Layout kind for this.\n         non_zero: bool\n     },\n@@ -1084,9 +1084,9 @@ pub enum Layout {\n     StructWrappedNullablePointer {\n         nndiscr: u64,\n         nonnull: Struct,\n-        // N.B. There is a 0 at the start, for LLVM GEP through a pointer.\n+        /// N.B. There is a 0 at the start, for LLVM GEP through a pointer.\n         discrfield: FieldPath,\n-        // Like discrfield, but in source order. For debuginfo.\n+        /// Like discrfield, but in source order. For debuginfo.\n         discrfield_source: FieldPath\n     }\n }\n@@ -1954,11 +1954,11 @@ pub enum SizeSkeleton<'tcx> {\n \n     /// A potentially-fat pointer.\n     Pointer {\n-        // If true, this pointer is never null.\n+        /// If true, this pointer is never null.\n         non_zero: bool,\n-        // The type which determines the unsized metadata, if any,\n-        // of this pointer. Either a type parameter or a projection\n-        // depending on one, with regions erased.\n+        /// The type which determines the unsized metadata, if any,\n+        /// of this pointer. Either a type parameter or a projection\n+        /// depending on one, with regions erased.\n         tail: Ty<'tcx>\n     }\n }"}, {"sha": "88a2ce0ab8a316097c6f3825065e6a192a7c597b", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dep_graph::{DepConstructor, DepNode, DepNodeIndex};\n-use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::def::Def;\n use hir;\n use middle::const_val;\n@@ -942,7 +942,7 @@ define_maps! { <'tcx>\n     /// Checks all types in the krate for overlap in their inherent impls. Reports errors.\n     /// Not meant to be used directly outside of coherence.\n     /// (Defined only for LOCAL_CRATE)\n-    [] crate_inherent_impls_overlap_check: crate_inherent_impls_dep_node(CrateNum) -> (),\n+    [] crate_inherent_impls_overlap_check: inherent_impls_overlap_check_dep_node(CrateNum) -> (),\n \n     /// Results of evaluating const items or constants embedded in\n     /// other items (such as enum variant explicit discriminants).\n@@ -1025,6 +1025,10 @@ fn crate_inherent_impls_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::Coherence\n }\n \n+fn inherent_impls_overlap_check_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n+    DepConstructor::CoherenceInherentImplOverlapCheck\n+}\n+\n fn reachability_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::Reachability\n }\n@@ -1043,10 +1047,9 @@ fn typeck_item_bodies_dep_node<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n     DepConstructor::TypeckBodiesKrate\n }\n \n-fn const_eval_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n+fn const_eval_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>)\n                              -> DepConstructor<'tcx> {\n-    let (def_id, substs) = key.value;\n-    DepConstructor::ConstEval { def_id, substs }\n+    DepConstructor::ConstEval\n }\n \n fn mir_keys<'tcx>(_: CrateNum) -> DepConstructor<'tcx> {\n@@ -1061,32 +1064,22 @@ fn relevant_trait_impls_for<'tcx>((def_id, t): (DefId, SimplifiedType)) -> DepCo\n     DepConstructor::RelevantTraitImpls(def_id, t)\n }\n \n-fn is_copy_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n-        .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n-    DepConstructor::IsCopy(def_id)\n+fn is_copy_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n+    DepConstructor::IsCopy\n }\n \n-fn is_sized_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n-        .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n-    DepConstructor::IsSized(def_id)\n+fn is_sized_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n+    DepConstructor::IsSized\n }\n \n-fn is_freeze_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n-        .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n-    DepConstructor::IsFreeze(def_id)\n+fn is_freeze_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n+    DepConstructor::IsFreeze\n }\n \n-fn needs_drop_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n-        .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n-    DepConstructor::NeedsDrop(def_id)\n+fn needs_drop_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n+    DepConstructor::NeedsDrop\n }\n \n-fn layout_dep_node<'tcx>(key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n-    let def_id = ty::item_path::characteristic_def_id_of_type(key.value)\n-        .unwrap_or(DefId::local(CRATE_DEF_INDEX));\n-    DepConstructor::Layout(def_id)\n+fn layout_dep_node<'tcx>(_: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> DepConstructor<'tcx> {\n+    DepConstructor::Layout\n }"}, {"sha": "3ac189ae0479e3aabf4ebd7f892574df221decbb", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -68,13 +68,15 @@ pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n-pub use self::sty::Issue32330;\n pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n pub use self::sty::RegionKind::*;\n pub use self::sty::TypeVariants::*;\n \n+pub use self::binding::BindingMode;\n+pub use self::binding::BindingMode::*;\n+\n pub use self::context::{TyCtxt, GlobalArenas, tls};\n pub use self::context::{Lift, TypeckTables};\n \n@@ -85,6 +87,7 @@ pub use self::trait_def::TraitDef;\n pub use self::maps::queries;\n \n pub mod adjustment;\n+pub mod binding;\n pub mod cast;\n pub mod error;\n pub mod fast_reject;\n@@ -158,7 +161,7 @@ pub struct ImplHeader<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }\n \n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct AssociatedItem {\n     pub def_id: DefId,\n     pub name: Name,\n@@ -172,7 +175,7 @@ pub struct AssociatedItem {\n     pub method_has_self_argument: bool,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub enum AssociatedKind {\n     Const,\n     Method,\n@@ -679,7 +682,6 @@ pub struct RegionParameterDef {\n     pub name: Name,\n     pub def_id: DefId,\n     pub index: u32,\n-    pub issue_32330: Option<ty::Issue32330>,\n \n     /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n     /// on generic parameter `'a`, asserts data of lifetime `'a`"}, {"sha": "087c41a7883ce712df799b2698babc5e36aaef14", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -377,13 +377,11 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             RegionsNoOverlap(a, b) => {\n                 return tcx.lift(&(a, b)).map(|(a, b)| RegionsNoOverlap(a, b))\n             }\n-            RegionsInsufficientlyPolymorphic(a, b, ref c) => {\n-                let c = c.clone();\n-                return tcx.lift(&b).map(|b| RegionsInsufficientlyPolymorphic(a, b, c))\n+            RegionsInsufficientlyPolymorphic(a, b) => {\n+                return tcx.lift(&b).map(|b| RegionsInsufficientlyPolymorphic(a, b))\n             }\n-            RegionsOverlyPolymorphic(a, b, ref c) => {\n-                let c = c.clone();\n-                return tcx.lift(&b).map(|b| RegionsOverlyPolymorphic(a, b, c))\n+            RegionsOverlyPolymorphic(a, b) => {\n+                return tcx.lift(&b).map(|b| RegionsOverlyPolymorphic(a, b))\n             }\n             IntMismatch(x) => IntMismatch(x),\n             FloatMismatch(x) => FloatMismatch(x),\n@@ -1065,13 +1063,11 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             RegionsNoOverlap(a, b) => {\n                 RegionsNoOverlap(a.fold_with(folder), b.fold_with(folder))\n             },\n-            RegionsInsufficientlyPolymorphic(a, b, ref c) => {\n-                let c = c.clone();\n-                RegionsInsufficientlyPolymorphic(a, b.fold_with(folder), c)\n+            RegionsInsufficientlyPolymorphic(a, b) => {\n+                RegionsInsufficientlyPolymorphic(a, b.fold_with(folder))\n             },\n-            RegionsOverlyPolymorphic(a, b, ref c) => {\n-                let c = c.clone();\n-                RegionsOverlyPolymorphic(a, b.fold_with(folder), c)\n+            RegionsOverlyPolymorphic(a, b) => {\n+                RegionsOverlyPolymorphic(a, b.fold_with(folder))\n             },\n             IntMismatch(x) => IntMismatch(x),\n             FloatMismatch(x) => FloatMismatch(x),\n@@ -1097,8 +1093,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             RegionsNoOverlap(a, b) => {\n                 a.visit_with(visitor) || b.visit_with(visitor)\n             },\n-            RegionsInsufficientlyPolymorphic(_, b, _) |\n-            RegionsOverlyPolymorphic(_, b, _) => {\n+            RegionsInsufficientlyPolymorphic(_, b) |\n+            RegionsOverlyPolymorphic(_, b) => {\n                 b.visit_with(visitor)\n             },\n             Sorts(x) => x.visit_with(visitor),"}, {"sha": "2f3fd5244aeaeeee4dcc6ee335ad000798184995", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -77,20 +77,6 @@ impl BoundRegion {\n     }\n }\n \n-/// When a region changed from late-bound to early-bound when #32330\n-/// was fixed, its `RegionParameterDef` will have one of these\n-/// structures that we can use to give nicer errors.\n-#[derive(Copy, Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash,\n-         RustcEncodable, RustcDecodable)]\n-pub struct Issue32330 {\n-    /// fn where is region declared\n-    pub fn_def_id: DefId,\n-\n-    /// name of region; duplicates the info in BrNamed but convenient\n-    /// to have it here, and this code is only temporary\n-    pub region_name: ast::Name,\n-}\n-\n /// NB: If you change this, you'll probably want to change the corresponding\n /// AST structure in libsyntax/ast.rs as well.\n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]"}, {"sha": "244b7f35968894eed7177907624eb7d714f2b455", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -57,6 +57,32 @@ pub fn time<T, F>(do_it: bool, what: &str, f: F) -> T where\n     let rv = f();\n     let dur = start.elapsed();\n \n+    print_time_passes_entry_internal(what, dur);\n+\n+    TIME_DEPTH.with(|slot| slot.set(old));\n+\n+    rv\n+}\n+\n+pub fn print_time_passes_entry(do_it: bool, what: &str, dur: Duration) {\n+    if !do_it {\n+        return\n+    }\n+\n+    let old = TIME_DEPTH.with(|slot| {\n+        let r = slot.get();\n+        slot.set(r + 1);\n+        r\n+    });\n+\n+    print_time_passes_entry_internal(what, dur);\n+\n+    TIME_DEPTH.with(|slot| slot.set(old));\n+}\n+\n+fn print_time_passes_entry_internal(what: &str, dur: Duration) {\n+    let indentation = TIME_DEPTH.with(|slot| slot.get());\n+\n     let mem_string = match get_resident() {\n         Some(n) => {\n             let mb = n as f64 / 1_000_000.0;\n@@ -65,14 +91,10 @@ pub fn time<T, F>(do_it: bool, what: &str, f: F) -> T where\n         None => \"\".to_owned(),\n     };\n     println!(\"{}time: {}{}\\t{}\",\n-             repeat(\"  \").take(old).collect::<String>(),\n+             repeat(\"  \").take(indentation).collect::<String>(),\n              duration_to_secs_str(dur),\n              mem_string,\n              what);\n-\n-    TIME_DEPTH.with(|slot| slot.set(old));\n-\n-    rv\n }\n \n // Hack up our own formatting for the duration to make it easier for scripts"}, {"sha": "b8f8488e3027357cddebb3a33b9ce3219b141452", "filename": "src/librustc_apfloat/Cargo.toml", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_apfloat%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_apfloat%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2FCargo.toml?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,11 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_apfloat\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_apfloat\"\n+path = \"lib.rs\"\n+\n+[dependencies]\n+rustc_bitflags = { path = \"../librustc_bitflags\" }"}, {"sha": "3545a77c75de64cde2e5573409b254c6b0bf9734", "filename": "src/librustc_apfloat/ieee.rs", "status": "added", "additions": 2733, "deletions": 0, "changes": 2733, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,2733 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {Category, ExpInt, IEK_INF, IEK_NAN, IEK_ZERO};\n+use {Float, FloatConvert, ParseError, Round, Status, StatusAnd};\n+\n+use std::cmp::{self, Ordering};\n+use std::convert::TryFrom;\n+use std::fmt::{self, Write};\n+use std::marker::PhantomData;\n+use std::mem;\n+use std::ops::Neg;\n+\n+#[must_use]\n+pub struct IeeeFloat<S> {\n+    /// Absolute significand value (including the integer bit).\n+    sig: [Limb; 1],\n+\n+    /// The signed unbiased exponent of the value.\n+    exp: ExpInt,\n+\n+    /// What kind of floating point number this is.\n+    category: Category,\n+\n+    /// Sign bit of the number.\n+    sign: bool,\n+\n+    marker: PhantomData<S>,\n+}\n+\n+/// Fundamental unit of big integer arithmetic, but also\n+/// large to store the largest significands by itself.\n+type Limb = u128;\n+const LIMB_BITS: usize = 128;\n+fn limbs_for_bits(bits: usize) -> usize {\n+    (bits + LIMB_BITS - 1) / LIMB_BITS\n+}\n+\n+/// Enum that represents what fraction of the LSB truncated bits of an fp number\n+/// represent.\n+///\n+/// This essentially combines the roles of guard and sticky bits.\n+#[must_use]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum Loss {\n+    // Example of truncated bits:\n+    ExactlyZero, // 000000\n+    LessThanHalf, // 0xxxxx  x's not all zero\n+    ExactlyHalf, // 100000\n+    MoreThanHalf, // 1xxxxx  x's not all zero\n+}\n+\n+/// Represents floating point arithmetic semantics.\n+pub trait Semantics: Sized {\n+    /// Total number of bits in the in-memory format.\n+    const BITS: usize;\n+\n+    /// Number of bits in the significand. This includes the integer bit.\n+    const PRECISION: usize;\n+\n+    /// The largest E such that 2^E is representable; this matches the\n+    /// definition of IEEE 754.\n+    const MAX_EXP: ExpInt;\n+\n+    /// The smallest E such that 2^E is a normalized number; this\n+    /// matches the definition of IEEE 754.\n+    const MIN_EXP: ExpInt = -Self::MAX_EXP + 1;\n+\n+    /// The significand bit that marks NaN as quiet.\n+    const QNAN_BIT: usize = Self::PRECISION - 2;\n+\n+    /// The significand bitpattern to mark a NaN as quiet.\n+    /// NOTE: for X87DoubleExtended we need to set two bits instead of 2.\n+    const QNAN_SIGNIFICAND: Limb = 1 << Self::QNAN_BIT;\n+\n+    fn from_bits(bits: u128) -> IeeeFloat<Self> {\n+        assert!(Self::BITS > Self::PRECISION);\n+\n+        let sign = bits & (1 << (Self::BITS - 1));\n+        let exponent = (bits & !sign) >> (Self::PRECISION - 1);\n+        let mut r = IeeeFloat {\n+            sig: [bits & ((1 << (Self::PRECISION - 1)) - 1)],\n+            // Convert the exponent from its bias representation to a signed integer.\n+            exp: (exponent as ExpInt) - Self::MAX_EXP,\n+            category: Category::Zero,\n+            sign: sign != 0,\n+            marker: PhantomData,\n+        };\n+\n+        if r.exp == Self::MIN_EXP - 1 && r.sig == [0] {\n+            // Exponent, significand meaningless.\n+            r.category = Category::Zero;\n+        } else if r.exp == Self::MAX_EXP + 1 && r.sig == [0] {\n+            // Exponent, significand meaningless.\n+            r.category = Category::Infinity;\n+        } else if r.exp == Self::MAX_EXP + 1 && r.sig != [0] {\n+            // Sign, exponent, significand meaningless.\n+            r.category = Category::NaN;\n+        } else {\n+            r.category = Category::Normal;\n+            if r.exp == Self::MIN_EXP - 1 {\n+                // Denormal.\n+                r.exp = Self::MIN_EXP;\n+            } else {\n+                // Set integer bit.\n+                sig::set_bit(&mut r.sig, Self::PRECISION - 1);\n+            }\n+        }\n+\n+        r\n+    }\n+\n+    fn to_bits(x: IeeeFloat<Self>) -> u128 {\n+        assert!(Self::BITS > Self::PRECISION);\n+\n+        // Split integer bit from significand.\n+        let integer_bit = sig::get_bit(&x.sig, Self::PRECISION - 1);\n+        let mut significand = x.sig[0] & ((1 << (Self::PRECISION - 1)) - 1);\n+        let exponent = match x.category {\n+            Category::Normal => {\n+                if x.exp == Self::MIN_EXP && !integer_bit {\n+                    // Denormal.\n+                    Self::MIN_EXP - 1\n+                } else {\n+                    x.exp\n+                }\n+            }\n+            Category::Zero => {\n+                // FIXME(eddyb) Maybe we should guarantee an invariant instead?\n+                significand = 0;\n+                Self::MIN_EXP - 1\n+            }\n+            Category::Infinity => {\n+                // FIXME(eddyb) Maybe we should guarantee an invariant instead?\n+                significand = 0;\n+                Self::MAX_EXP + 1\n+            }\n+            Category::NaN => Self::MAX_EXP + 1,\n+        };\n+\n+        // Convert the exponent from a signed integer to its bias representation.\n+        let exponent = (exponent + Self::MAX_EXP) as u128;\n+\n+        ((x.sign as u128) << (Self::BITS - 1)) | (exponent << (Self::PRECISION - 1)) | significand\n+    }\n+}\n+\n+impl<S> Copy for IeeeFloat<S> {}\n+impl<S> Clone for IeeeFloat<S> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+macro_rules! ieee_semantics {\n+    ($($name:ident = $sem:ident($bits:tt : $exp_bits:tt)),*) => {\n+        $(pub struct $sem;)*\n+        $(pub type $name = IeeeFloat<$sem>;)*\n+        $(impl Semantics for $sem {\n+            const BITS: usize = $bits;\n+            const PRECISION: usize = ($bits - 1 - $exp_bits) + 1;\n+            const MAX_EXP: ExpInt = (1 << ($exp_bits - 1)) - 1;\n+        })*\n+    }\n+}\n+\n+ieee_semantics! {\n+    Half = HalfS(16:5),\n+    Single = SingleS(32:8),\n+    Double = DoubleS(64:11),\n+    Quad = QuadS(128:15)\n+}\n+\n+pub struct X87DoubleExtendedS;\n+pub type X87DoubleExtended = IeeeFloat<X87DoubleExtendedS>;\n+impl Semantics for X87DoubleExtendedS {\n+    const BITS: usize = 80;\n+    const PRECISION: usize = 64;\n+    const MAX_EXP: ExpInt = (1 << (15 - 1)) - 1;\n+\n+    /// For x87 extended precision, we want to make a NaN, not a\n+    /// pseudo-NaN. Maybe we should expose the ability to make\n+    /// pseudo-NaNs?\n+    const QNAN_SIGNIFICAND: Limb = 0b11 << Self::QNAN_BIT;\n+\n+    /// Integer bit is explicit in this format. Intel hardware (387 and later)\n+    /// does not support these bit patterns:\n+    ///  exponent = all 1's, integer bit 0, significand 0 (\"pseudoinfinity\")\n+    ///  exponent = all 1's, integer bit 0, significand nonzero (\"pseudoNaN\")\n+    ///  exponent = 0, integer bit 1 (\"pseudodenormal\")\n+    ///  exponent!=0 nor all 1's, integer bit 0 (\"unnormal\")\n+    /// At the moment, the first two are treated as NaNs, the second two as Normal.\n+    fn from_bits(bits: u128) -> IeeeFloat<Self> {\n+        let sign = bits & (1 << (Self::BITS - 1));\n+        let exponent = (bits & !sign) >> Self::PRECISION;\n+        let mut r = IeeeFloat {\n+            sig: [bits & ((1 << (Self::PRECISION - 1)) - 1)],\n+            // Convert the exponent from its bias representation to a signed integer.\n+            exp: (exponent as ExpInt) - Self::MAX_EXP,\n+            category: Category::Zero,\n+            sign: sign != 0,\n+            marker: PhantomData,\n+        };\n+\n+        if r.exp == Self::MIN_EXP - 1 && r.sig == [0] {\n+            // Exponent, significand meaningless.\n+            r.category = Category::Zero;\n+        } else if r.exp == Self::MAX_EXP + 1 && r.sig == [1 << (Self::PRECISION - 1)] {\n+            // Exponent, significand meaningless.\n+            r.category = Category::Infinity;\n+        } else if r.exp == Self::MAX_EXP + 1 && r.sig != [1 << (Self::PRECISION - 1)] {\n+            // Sign, exponent, significand meaningless.\n+            r.category = Category::NaN;\n+        } else {\n+            r.category = Category::Normal;\n+            if r.exp == Self::MIN_EXP - 1 {\n+                // Denormal.\n+                r.exp = Self::MIN_EXP;\n+            }\n+        }\n+\n+        r\n+    }\n+\n+    fn to_bits(x: IeeeFloat<Self>) -> u128 {\n+        // Get integer bit from significand.\n+        let integer_bit = sig::get_bit(&x.sig, Self::PRECISION - 1);\n+        let mut significand = x.sig[0] & ((1 << Self::PRECISION) - 1);\n+        let exponent = match x.category {\n+            Category::Normal => {\n+                if x.exp == Self::MIN_EXP && !integer_bit {\n+                    // Denormal.\n+                    Self::MIN_EXP - 1\n+                } else {\n+                    x.exp\n+                }\n+            }\n+            Category::Zero => {\n+                // FIXME(eddyb) Maybe we should guarantee an invariant instead?\n+                significand = 0;\n+                Self::MIN_EXP - 1\n+            }\n+            Category::Infinity => {\n+                // FIXME(eddyb) Maybe we should guarantee an invariant instead?\n+                significand = 1 << (Self::PRECISION - 1);\n+                Self::MAX_EXP + 1\n+            }\n+            Category::NaN => Self::MAX_EXP + 1,\n+        };\n+\n+        // Convert the exponent from a signed integer to its bias representation.\n+        let exponent = (exponent + Self::MAX_EXP) as u128;\n+\n+        ((x.sign as u128) << (Self::BITS - 1)) | (exponent << Self::PRECISION) | significand\n+    }\n+}\n+\n+float_common_impls!(IeeeFloat<S>);\n+\n+impl<S: Semantics> PartialEq for IeeeFloat<S> {\n+    fn eq(&self, rhs: &Self) -> bool {\n+        self.partial_cmp(rhs) == Some(Ordering::Equal)\n+    }\n+}\n+\n+impl<S: Semantics> PartialOrd for IeeeFloat<S> {\n+    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {\n+        match (self.category, rhs.category) {\n+            (Category::NaN, _) |\n+            (_, Category::NaN) => None,\n+\n+            (Category::Infinity, Category::Infinity) => Some((!self.sign).cmp(&(!rhs.sign))),\n+\n+            (Category::Zero, Category::Zero) => Some(Ordering::Equal),\n+\n+            (Category::Infinity, _) |\n+            (Category::Normal, Category::Zero) => Some((!self.sign).cmp(&self.sign)),\n+\n+            (_, Category::Infinity) |\n+            (Category::Zero, Category::Normal) => Some(rhs.sign.cmp(&(!rhs.sign))),\n+\n+            (Category::Normal, Category::Normal) => {\n+                // Two normal numbers. Do they have the same sign?\n+                Some((!self.sign).cmp(&(!rhs.sign)).then_with(|| {\n+                    // Compare absolute values; invert result if negative.\n+                    let result = self.cmp_abs_normal(*rhs);\n+\n+                    if self.sign { result.reverse() } else { result }\n+                }))\n+            }\n+        }\n+    }\n+}\n+\n+impl<S> Neg for IeeeFloat<S> {\n+    type Output = Self;\n+    fn neg(mut self) -> Self {\n+        self.sign = !self.sign;\n+        self\n+    }\n+}\n+\n+/// Prints this value as a decimal string.\n+///\n+/// \\param precision The maximum number of digits of\n+///   precision to output. If there are fewer digits available,\n+///   zero padding will not be used unless the value is\n+///   integral and small enough to be expressed in\n+///   precision digits. 0 means to use the natural\n+///   precision of the number.\n+/// \\param width The maximum number of zeros to\n+///   consider inserting before falling back to scientific\n+///   notation. 0 means to always use scientific notation.\n+///\n+/// \\param alternate Indicate whether to remove the trailing zero in\n+///   fraction part or not. Also setting this parameter to true forces\n+///   producing of output more similar to default printf behavior.\n+///   Specifically the lower e is used as exponent delimiter and exponent\n+///   always contains no less than two digits.\n+///\n+/// Number       precision    width      Result\n+/// ------       ---------    -----      ------\n+/// 1.01E+4              5        2       10100\n+/// 1.01E+4              4        2       1.01E+4\n+/// 1.01E+4              5        1       1.01E+4\n+/// 1.01E-2              5        2       0.0101\n+/// 1.01E-2              4        2       0.0101\n+/// 1.01E-2              4        1       1.01E-2\n+impl<S: Semantics> fmt::Display for IeeeFloat<S> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let width = f.width().unwrap_or(3);\n+        let alternate = f.alternate();\n+\n+        match self.category {\n+            Category::Infinity => {\n+                if self.sign {\n+                    return f.write_str(\"-Inf\");\n+                } else {\n+                    return f.write_str(\"+Inf\");\n+                }\n+            }\n+\n+            Category::NaN => return f.write_str(\"NaN\"),\n+\n+            Category::Zero => {\n+                if self.sign {\n+                    f.write_char('-')?;\n+                }\n+\n+                if width == 0 {\n+                    if alternate {\n+                        f.write_str(\"0.0\")?;\n+                        if let Some(n) = f.precision() {\n+                            for _ in 1..n {\n+                                f.write_char('0')?;\n+                            }\n+                        }\n+                        f.write_str(\"e+00\")?;\n+                    } else {\n+                        f.write_str(\"0.0E+0\")?;\n+                    }\n+                } else {\n+                    f.write_char('0')?;\n+                }\n+                return Ok(());\n+            }\n+\n+            Category::Normal => {}\n+        }\n+\n+        if self.sign {\n+            f.write_char('-')?;\n+        }\n+\n+        // We use enough digits so the number can be round-tripped back to an\n+        // APFloat. The formula comes from \"How to Print Floating-Point Numbers\n+        // Accurately\" by Steele and White.\n+        // FIXME: Using a formula based purely on the precision is conservative;\n+        // we can print fewer digits depending on the actual value being printed.\n+\n+        // precision = 2 + floor(S::PRECISION / lg_2(10))\n+        let precision = f.precision().unwrap_or(2 + S::PRECISION * 59 / 196);\n+\n+        // Decompose the number into an APInt and an exponent.\n+        let mut exp = self.exp - (S::PRECISION as ExpInt - 1);\n+        let mut sig = vec![self.sig[0]];\n+\n+        // Ignore trailing binary zeros.\n+        let trailing_zeros = sig[0].trailing_zeros();\n+        let _: Loss = sig::shift_right(&mut sig, &mut exp, trailing_zeros as usize);\n+\n+        // Change the exponent from 2^e to 10^e.\n+        if exp == 0 {\n+            // Nothing to do.\n+        } else if exp > 0 {\n+            // Just shift left.\n+            let shift = exp as usize;\n+            sig.resize(limbs_for_bits(S::PRECISION + shift), 0);\n+            sig::shift_left(&mut sig, &mut exp, shift);\n+        } else {\n+            // exp < 0\n+            let mut texp = -exp as usize;\n+\n+            // We transform this using the identity:\n+            //   (N)(2^-e) == (N)(5^e)(10^-e)\n+\n+            // Multiply significand by 5^e.\n+            //   N * 5^0101 == N * 5^(1*1) * 5^(0*2) * 5^(1*4) * 5^(0*8)\n+            let mut sig_scratch = vec![];\n+            let mut p5 = vec![];\n+            let mut p5_scratch = vec![];\n+            while texp != 0 {\n+                if p5.is_empty() {\n+                    p5.push(5);\n+                } else {\n+                    p5_scratch.resize(p5.len() * 2, 0);\n+                    let _: Loss =\n+                        sig::mul(&mut p5_scratch, &mut 0, &p5, &p5, p5.len() * 2 * LIMB_BITS);\n+                    while p5_scratch.last() == Some(&0) {\n+                        p5_scratch.pop();\n+                    }\n+                    mem::swap(&mut p5, &mut p5_scratch);\n+                }\n+                if texp & 1 != 0 {\n+                    sig_scratch.resize(sig.len() + p5.len(), 0);\n+                    let _: Loss = sig::mul(\n+                        &mut sig_scratch,\n+                        &mut 0,\n+                        &sig,\n+                        &p5,\n+                        (sig.len() + p5.len()) * LIMB_BITS,\n+                    );\n+                    while sig_scratch.last() == Some(&0) {\n+                        sig_scratch.pop();\n+                    }\n+                    mem::swap(&mut sig, &mut sig_scratch);\n+                }\n+                texp >>= 1;\n+            }\n+        }\n+\n+        // Fill the buffer.\n+        let mut buffer = vec![];\n+\n+        // Ignore digits from the significand until it is no more\n+        // precise than is required for the desired precision.\n+        // 196/59 is a very slight overestimate of lg_2(10).\n+        let required = (precision * 196 + 58) / 59;\n+        let mut discard_digits = sig::omsb(&sig).saturating_sub(required) * 59 / 196;\n+        let mut in_trail = true;\n+        while !sig.is_empty() {\n+            // Perform short division by 10 to extract the rightmost digit.\n+            // rem <- sig % 10\n+            // sig <- sig / 10\n+            let mut rem = 0;\n+            for limb in sig.iter_mut().rev() {\n+                // We don't have an integer doubly wide than Limb,\n+                // so we have to split the divrem on two halves.\n+                const HALF_BITS: usize = LIMB_BITS / 2;\n+                let mut halves = [*limb & ((1 << HALF_BITS) - 1), *limb >> HALF_BITS];\n+                for half in halves.iter_mut().rev() {\n+                    *half |= rem << HALF_BITS;\n+                    rem = *half % 10;\n+                    *half /= 10;\n+                }\n+                *limb = halves[0] | (halves[1] << HALF_BITS);\n+            }\n+            // Reduce the sigificand to avoid wasting time dividing 0's.\n+            while sig.last() == Some(&0) {\n+                sig.pop();\n+            }\n+\n+            let digit = rem;\n+\n+            // Ignore digits we don't need.\n+            if discard_digits > 0 {\n+                discard_digits -= 1;\n+                exp += 1;\n+                continue;\n+            }\n+\n+            // Drop trailing zeros.\n+            if in_trail && digit == 0 {\n+                exp += 1;\n+            } else {\n+                in_trail = false;\n+                buffer.push(b'0' + digit as u8);\n+            }\n+        }\n+\n+        assert!(!buffer.is_empty(), \"no characters in buffer!\");\n+\n+        // Drop down to precision.\n+        // FIXME: don't do more precise calculations above than are required.\n+        if buffer.len() > precision {\n+            // The most significant figures are the last ones in the buffer.\n+            let mut first_sig = buffer.len() - precision;\n+\n+            // Round.\n+            // FIXME: this probably shouldn't use 'round half up'.\n+\n+            // Rounding down is just a truncation, except we also want to drop\n+            // trailing zeros from the new result.\n+            if buffer[first_sig - 1] < b'5' {\n+                while first_sig < buffer.len() && buffer[first_sig] == b'0' {\n+                    first_sig += 1;\n+                }\n+            } else {\n+                // Rounding up requires a decimal add-with-carry. If we continue\n+                // the carry, the newly-introduced zeros will just be truncated.\n+                for x in &mut buffer[first_sig..] {\n+                    if *x == b'9' {\n+                        first_sig += 1;\n+                    } else {\n+                        *x += 1;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            exp += first_sig as ExpInt;\n+            buffer.drain(..first_sig);\n+\n+            // If we carried through, we have exactly one digit of precision.\n+            if buffer.is_empty() {\n+                buffer.push(b'1');\n+            }\n+        }\n+\n+        let digits = buffer.len();\n+\n+        // Check whether we should use scientific notation.\n+        let scientific = if width == 0 {\n+            true\n+        } else {\n+            if exp >= 0 {\n+                // 765e3 --> 765000\n+                //              ^^^\n+                // But we shouldn't make the number look more precise than it is.\n+                exp as usize > width || digits + exp as usize > precision\n+            } else {\n+                // Power of the most significant digit.\n+                let msd = exp + (digits - 1) as ExpInt;\n+                if msd >= 0 {\n+                    // 765e-2 == 7.65\n+                    false\n+                } else {\n+                    // 765e-5 == 0.00765\n+                    //           ^ ^^\n+                    -msd as usize > width\n+                }\n+            }\n+        };\n+\n+        // Scientific formatting is pretty straightforward.\n+        if scientific {\n+            exp += digits as ExpInt - 1;\n+\n+            f.write_char(buffer[digits - 1] as char)?;\n+            f.write_char('.')?;\n+            let truncate_zero = !alternate;\n+            if digits == 1 && truncate_zero {\n+                f.write_char('0')?;\n+            } else {\n+                for &d in buffer[..digits - 1].iter().rev() {\n+                    f.write_char(d as char)?;\n+                }\n+            }\n+            // Fill with zeros up to precision.\n+            if !truncate_zero && precision > digits - 1 {\n+                for _ in 0..precision - digits + 1 {\n+                    f.write_char('0')?;\n+                }\n+            }\n+            // For alternate we use lower 'e'.\n+            f.write_char(if alternate { 'e' } else { 'E' })?;\n+\n+            // Exponent always at least two digits if we do not truncate zeros.\n+            if truncate_zero {\n+                write!(f, \"{:+}\", exp)?;\n+            } else {\n+                write!(f, \"{:+03}\", exp)?;\n+            }\n+\n+            return Ok(());\n+        }\n+\n+        // Non-scientific, positive exponents.\n+        if exp >= 0 {\n+            for &d in buffer.iter().rev() {\n+                f.write_char(d as char)?;\n+            }\n+            for _ in 0..exp {\n+                f.write_char('0')?;\n+            }\n+            return Ok(());\n+        }\n+\n+        // Non-scientific, negative exponents.\n+        let unit_place = -exp as usize;\n+        if unit_place < digits {\n+            for &d in buffer[unit_place..].iter().rev() {\n+                f.write_char(d as char)?;\n+            }\n+            f.write_char('.')?;\n+            for &d in buffer[..unit_place].iter().rev() {\n+                f.write_char(d as char)?;\n+            }\n+        } else {\n+            f.write_str(\"0.\")?;\n+            for _ in digits..unit_place {\n+                f.write_char('0')?;\n+            }\n+            for &d in buffer.iter().rev() {\n+                f.write_char(d as char)?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<S: Semantics> fmt::Debug for IeeeFloat<S> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}({:?} | {}{:?} * 2^{})\",\n+               self, self.category,\n+               if self.sign { \"-\" } else { \"+\" },\n+               self.sig,\n+               self.exp)\n+    }\n+}\n+\n+impl<S: Semantics> Float for IeeeFloat<S> {\n+    const BITS: usize = S::BITS;\n+    const PRECISION: usize = S::PRECISION;\n+    const MAX_EXP: ExpInt = S::MAX_EXP;\n+    const MIN_EXP: ExpInt = S::MIN_EXP;\n+\n+    const ZERO: Self = IeeeFloat {\n+        sig: [0],\n+        exp: S::MIN_EXP - 1,\n+        category: Category::Zero,\n+        sign: false,\n+        marker: PhantomData,\n+    };\n+\n+    const INFINITY: Self = IeeeFloat {\n+        sig: [0],\n+        exp: S::MAX_EXP + 1,\n+        category: Category::Infinity,\n+        sign: false,\n+        marker: PhantomData,\n+    };\n+\n+    // FIXME(eddyb) remove when qnan becomes const fn.\n+    const NAN: Self = IeeeFloat {\n+        sig: [S::QNAN_SIGNIFICAND],\n+        exp: S::MAX_EXP + 1,\n+        category: Category::NaN,\n+        sign: false,\n+        marker: PhantomData,\n+    };\n+\n+    fn qnan(payload: Option<u128>) -> Self {\n+        IeeeFloat {\n+            sig: [\n+                S::QNAN_SIGNIFICAND |\n+                    payload.map_or(0, |payload| {\n+                        // Zero out the excess bits of the significand.\n+                        payload & ((1 << S::QNAN_BIT) - 1)\n+                    }),\n+            ],\n+            exp: S::MAX_EXP + 1,\n+            category: Category::NaN,\n+            sign: false,\n+            marker: PhantomData,\n+        }\n+    }\n+\n+    fn snan(payload: Option<u128>) -> Self {\n+        let mut snan = Self::qnan(payload);\n+\n+        // We always have to clear the QNaN bit to make it an SNaN.\n+        sig::clear_bit(&mut snan.sig, S::QNAN_BIT);\n+\n+        // If there are no bits set in the payload, we have to set\n+        // *something* to make it a NaN instead of an infinity;\n+        // conventionally, this is the next bit down from the QNaN bit.\n+        if snan.sig[0] & !S::QNAN_SIGNIFICAND == 0 {\n+            sig::set_bit(&mut snan.sig, S::QNAN_BIT - 1);\n+        }\n+\n+        snan\n+    }\n+\n+    fn largest() -> Self {\n+        // We want (in interchange format):\n+        //   exponent = 1..10\n+        //   significand = 1..1\n+        IeeeFloat {\n+            sig: [!0 & ((1 << S::PRECISION) - 1)],\n+            exp: S::MAX_EXP,\n+            category: Category::Normal,\n+            sign: false,\n+            marker: PhantomData,\n+        }\n+    }\n+\n+    // We want (in interchange format):\n+    //   exponent = 0..0\n+    //   significand = 0..01\n+    const SMALLEST: Self = IeeeFloat {\n+        sig: [1],\n+        exp: S::MIN_EXP,\n+        category: Category::Normal,\n+        sign: false,\n+        marker: PhantomData,\n+    };\n+\n+    fn smallest_normalized() -> Self {\n+        // We want (in interchange format):\n+        //   exponent = 0..0\n+        //   significand = 10..0\n+        IeeeFloat {\n+            sig: [1 << (S::PRECISION - 1)],\n+            exp: S::MIN_EXP,\n+            category: Category::Normal,\n+            sign: false,\n+            marker: PhantomData,\n+        }\n+    }\n+\n+    fn add_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        let status = match (self.category, rhs.category) {\n+            (Category::Infinity, Category::Infinity) => {\n+                // Differently signed infinities can only be validly\n+                // subtracted.\n+                if self.sign != rhs.sign {\n+                    self = Self::NAN;\n+                    Status::INVALID_OP\n+                } else {\n+                    Status::OK\n+                }\n+            }\n+\n+            // Sign may depend on rounding mode; handled below.\n+            (_, Category::Zero) |\n+            (Category::NaN, _) |\n+            (Category::Infinity, Category::Normal) => Status::OK,\n+\n+            (Category::Zero, _) |\n+            (_, Category::NaN) |\n+            (_, Category::Infinity) => {\n+                self = rhs;\n+                Status::OK\n+            }\n+\n+            // This return code means it was not a simple case.\n+            (Category::Normal, Category::Normal) => {\n+                let loss = sig::add_or_sub(\n+                    &mut self.sig,\n+                    &mut self.exp,\n+                    &mut self.sign,\n+                    &mut [rhs.sig[0]],\n+                    rhs.exp,\n+                    rhs.sign,\n+                );\n+                let status;\n+                self = unpack!(status=, self.normalize(round, loss));\n+\n+                // Can only be zero if we lost no fraction.\n+                assert!(self.category != Category::Zero || loss == Loss::ExactlyZero);\n+\n+                status\n+            }\n+        };\n+\n+        // If two numbers add (exactly) to zero, IEEE 754 decrees it is a\n+        // positive zero unless rounding to minus infinity, except that\n+        // adding two like-signed zeroes gives that zero.\n+        if self.category == Category::Zero &&\n+            (rhs.category != Category::Zero || self.sign != rhs.sign)\n+        {\n+            self.sign = round == Round::TowardNegative;\n+        }\n+\n+        status.and(self)\n+    }\n+\n+    fn mul_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        self.sign ^= rhs.sign;\n+\n+        match (self.category, rhs.category) {\n+            (Category::NaN, _) => {\n+                self.sign = false;\n+                Status::OK.and(self)\n+            }\n+\n+            (_, Category::NaN) => {\n+                self.sign = false;\n+                self.category = Category::NaN;\n+                self.sig = rhs.sig;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Zero, Category::Infinity) |\n+            (Category::Infinity, Category::Zero) => Status::INVALID_OP.and(Self::NAN),\n+\n+            (_, Category::Infinity) |\n+            (Category::Infinity, _) => {\n+                self.category = Category::Infinity;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Zero, _) |\n+            (_, Category::Zero) => {\n+                self.category = Category::Zero;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Normal, Category::Normal) => {\n+                self.exp += rhs.exp;\n+                let mut wide_sig = [0; 2];\n+                let loss = sig::mul(\n+                    &mut wide_sig,\n+                    &mut self.exp,\n+                    &self.sig,\n+                    &rhs.sig,\n+                    S::PRECISION,\n+                );\n+                self.sig = [wide_sig[0]];\n+                let mut status;\n+                self = unpack!(status=, self.normalize(round, loss));\n+                if loss != Loss::ExactlyZero {\n+                    status |= Status::INEXACT;\n+                }\n+                status.and(self)\n+            }\n+        }\n+    }\n+\n+    fn mul_add_r(mut self, multiplicand: Self, addend: Self, round: Round) -> StatusAnd<Self> {\n+        // If and only if all arguments are normal do we need to do an\n+        // extended-precision calculation.\n+        if !self.is_finite_non_zero() || !multiplicand.is_finite_non_zero() || !addend.is_finite() {\n+            let mut status;\n+            self = unpack!(status=, self.mul_r(multiplicand, round));\n+\n+            // FS can only be Status::OK or Status::INVALID_OP. There is no more work\n+            // to do in the latter case. The IEEE-754R standard says it is\n+            // implementation-defined in this case whether, if ADDEND is a\n+            // quiet NaN, we raise invalid op; this implementation does so.\n+            //\n+            // If we need to do the addition we can do so with normal\n+            // precision.\n+            if status == Status::OK {\n+                self = unpack!(status=, self.add_r(addend, round));\n+            }\n+            return status.and(self);\n+        }\n+\n+        // Post-multiplication sign, before addition.\n+        self.sign ^= multiplicand.sign;\n+\n+        // Allocate space for twice as many bits as the original significand, plus one\n+        // extra bit for the addition to overflow into.\n+        assert!(limbs_for_bits(S::PRECISION * 2 + 1) <= 2);\n+        let mut wide_sig = sig::widening_mul(self.sig[0], multiplicand.sig[0]);\n+\n+        let mut loss = Loss::ExactlyZero;\n+        let mut omsb = sig::omsb(&wide_sig);\n+        self.exp += multiplicand.exp;\n+\n+        // Assume the operands involved in the multiplication are single-precision\n+        // FP, and the two multiplicants are:\n+        //     lhs = a23 . a22 ... a0 * 2^e1\n+        //     rhs = b23 . b22 ... b0 * 2^e2\n+        // the result of multiplication is:\n+        //     lhs = c48 c47 c46 . c45 ... c0 * 2^(e1+e2)\n+        // Note that there are three significant bits at the left-hand side of the\n+        // radix point: two for the multiplication, and an overflow bit for the\n+        // addition (that will always be zero at this point). Move the radix point\n+        // toward left by two bits, and adjust exponent accordingly.\n+        self.exp += 2;\n+\n+        if addend.is_non_zero() {\n+            // Normalize our MSB to one below the top bit to allow for overflow.\n+            let ext_precision = 2 * S::PRECISION + 1;\n+            if omsb != ext_precision - 1 {\n+                assert!(ext_precision > omsb);\n+                sig::shift_left(&mut wide_sig, &mut self.exp, (ext_precision - 1) - omsb);\n+            }\n+\n+            // The intermediate result of the multiplication has \"2 * S::PRECISION\"\n+            // signicant bit; adjust the addend to be consistent with mul result.\n+            let mut ext_addend_sig = [addend.sig[0], 0];\n+\n+            // Extend the addend significand to ext_precision - 1. This guarantees\n+            // that the high bit of the significand is zero (same as wide_sig),\n+            // so the addition will overflow (if it does overflow at all) into the top bit.\n+            sig::shift_left(\n+                &mut ext_addend_sig,\n+                &mut 0,\n+                ext_precision - 1 - S::PRECISION,\n+            );\n+            loss = sig::add_or_sub(\n+                &mut wide_sig,\n+                &mut self.exp,\n+                &mut self.sign,\n+                &mut ext_addend_sig,\n+                addend.exp + 1,\n+                addend.sign,\n+            );\n+\n+            omsb = sig::omsb(&wide_sig);\n+        }\n+\n+        // Convert the result having \"2 * S::PRECISION\" significant-bits back to the one\n+        // having \"S::PRECISION\" significant-bits. First, move the radix point from\n+        // poision \"2*S::PRECISION - 1\" to \"S::PRECISION - 1\". The exponent need to be\n+        // adjusted by \"2*S::PRECISION - 1\" - \"S::PRECISION - 1\" = \"S::PRECISION\".\n+        self.exp -= S::PRECISION as ExpInt + 1;\n+\n+        // In case MSB resides at the left-hand side of radix point, shift the\n+        // mantissa right by some amount to make sure the MSB reside right before\n+        // the radix point (i.e. \"MSB . rest-significant-bits\").\n+        if omsb > S::PRECISION {\n+            let bits = omsb - S::PRECISION;\n+            loss = sig::shift_right(&mut wide_sig, &mut self.exp, bits).combine(loss);\n+        }\n+\n+        self.sig[0] = wide_sig[0];\n+\n+        let mut status;\n+        self = unpack!(status=, self.normalize(round, loss));\n+        if loss != Loss::ExactlyZero {\n+            status |= Status::INEXACT;\n+        }\n+\n+        // If two numbers add (exactly) to zero, IEEE 754 decrees it is a\n+        // positive zero unless rounding to minus infinity, except that\n+        // adding two like-signed zeroes gives that zero.\n+        if self.category == Category::Zero && !status.intersects(Status::UNDERFLOW) &&\n+            self.sign != addend.sign\n+        {\n+            self.sign = round == Round::TowardNegative;\n+        }\n+\n+        status.and(self)\n+    }\n+\n+    fn div_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        self.sign ^= rhs.sign;\n+\n+        match (self.category, rhs.category) {\n+            (Category::NaN, _) => {\n+                self.sign = false;\n+                Status::OK.and(self)\n+            }\n+\n+            (_, Category::NaN) => {\n+                self.category = Category::NaN;\n+                self.sig = rhs.sig;\n+                self.sign = false;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Infinity, Category::Infinity) |\n+            (Category::Zero, Category::Zero) => Status::INVALID_OP.and(Self::NAN),\n+\n+            (Category::Infinity, _) |\n+            (Category::Zero, _) => Status::OK.and(self),\n+\n+            (Category::Normal, Category::Infinity) => {\n+                self.category = Category::Zero;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Normal, Category::Zero) => {\n+                self.category = Category::Infinity;\n+                Status::DIV_BY_ZERO.and(self)\n+            }\n+\n+            (Category::Normal, Category::Normal) => {\n+                self.exp -= rhs.exp;\n+                let dividend = self.sig[0];\n+                let loss = sig::div(\n+                    &mut self.sig,\n+                    &mut self.exp,\n+                    &mut [dividend],\n+                    &mut [rhs.sig[0]],\n+                    S::PRECISION,\n+                );\n+                let mut status;\n+                self = unpack!(status=, self.normalize(round, loss));\n+                if loss != Loss::ExactlyZero {\n+                    status |= Status::INEXACT;\n+                }\n+                status.and(self)\n+            }\n+        }\n+    }\n+\n+    fn c_fmod(mut self, rhs: Self) -> StatusAnd<Self> {\n+        match (self.category, rhs.category) {\n+            (Category::NaN, _) |\n+            (Category::Zero, Category::Infinity) |\n+            (Category::Zero, Category::Normal) |\n+            (Category::Normal, Category::Infinity) => Status::OK.and(self),\n+\n+            (_, Category::NaN) => {\n+                self.sign = false;\n+                self.category = Category::NaN;\n+                self.sig = rhs.sig;\n+                Status::OK.and(self)\n+            }\n+\n+            (Category::Infinity, _) |\n+            (_, Category::Zero) => Status::INVALID_OP.and(Self::NAN),\n+\n+            (Category::Normal, Category::Normal) => {\n+                while self.is_finite_non_zero() && rhs.is_finite_non_zero() &&\n+                    self.cmp_abs_normal(rhs) != Ordering::Less\n+                {\n+                    let mut v = rhs.scalbn(self.ilogb() - rhs.ilogb());\n+                    if self.cmp_abs_normal(v) == Ordering::Less {\n+                        v = v.scalbn(-1);\n+                    }\n+                    v.sign = self.sign;\n+\n+                    let status;\n+                    self = unpack!(status=, self - v);\n+                    assert_eq!(status, Status::OK);\n+                }\n+                Status::OK.and(self)\n+            }\n+        }\n+    }\n+\n+    fn round_to_integral(self, round: Round) -> StatusAnd<Self> {\n+        // If the exponent is large enough, we know that this value is already\n+        // integral, and the arithmetic below would potentially cause it to saturate\n+        // to +/-Inf. Bail out early instead.\n+        if self.is_finite_non_zero() && self.exp + 1 >= S::PRECISION as ExpInt {\n+            return Status::OK.and(self);\n+        }\n+\n+        // The algorithm here is quite simple: we add 2^(p-1), where p is the\n+        // precision of our format, and then subtract it back off again. The choice\n+        // of rounding modes for the addition/subtraction determines the rounding mode\n+        // for our integral rounding as well.\n+        // NOTE: When the input value is negative, we do subtraction followed by\n+        // addition instead.\n+        assert!(S::PRECISION <= 128);\n+        let mut status;\n+        let magic_const = unpack!(status=, Self::from_u128(1 << (S::PRECISION - 1)));\n+        let magic_const = magic_const.copy_sign(self);\n+\n+        if status != Status::OK {\n+            return status.and(self);\n+        }\n+\n+        let mut r = self;\n+        r = unpack!(status=, r.add_r(magic_const, round));\n+        if status != Status::OK && status != Status::INEXACT {\n+            return status.and(self);\n+        }\n+\n+        // Restore the input sign to handle 0.0/-0.0 cases correctly.\n+        r.sub_r(magic_const, round).map(|r| r.copy_sign(self))\n+    }\n+\n+    fn next_up(mut self) -> StatusAnd<Self> {\n+        // Compute nextUp(x), handling each float category separately.\n+        match self.category {\n+            Category::Infinity => {\n+                if self.sign {\n+                    // nextUp(-inf) = -largest\n+                    Status::OK.and(-Self::largest())\n+                } else {\n+                    // nextUp(+inf) = +inf\n+                    Status::OK.and(self)\n+                }\n+            }\n+            Category::NaN => {\n+                // IEEE-754R 2008 6.2 Par 2: nextUp(sNaN) = qNaN. Set Invalid flag.\n+                // IEEE-754R 2008 6.2: nextUp(qNaN) = qNaN. Must be identity so we do not\n+                //                     change the payload.\n+                if self.is_signaling() {\n+                    // For consistency, propagate the sign of the sNaN to the qNaN.\n+                    Status::INVALID_OP.and(Self::NAN.copy_sign(self))\n+                } else {\n+                    Status::OK.and(self)\n+                }\n+            }\n+            Category::Zero => {\n+                // nextUp(pm 0) = +smallest\n+                Status::OK.and(Self::SMALLEST)\n+            }\n+            Category::Normal => {\n+                // nextUp(-smallest) = -0\n+                if self.is_smallest() && self.sign {\n+                    return Status::OK.and(-Self::ZERO);\n+                }\n+\n+                // nextUp(largest) == INFINITY\n+                if self.is_largest() && !self.sign {\n+                    return Status::OK.and(Self::INFINITY);\n+                }\n+\n+                // Excluding the integral bit. This allows us to test for binade boundaries.\n+                let sig_mask = (1 << (S::PRECISION - 1)) - 1;\n+\n+                // nextUp(normal) == normal + inc.\n+                if self.sign {\n+                    // If we are negative, we need to decrement the significand.\n+\n+                    // We only cross a binade boundary that requires adjusting the exponent\n+                    // if:\n+                    //   1. exponent != S::MIN_EXP. This implies we are not in the\n+                    //   smallest binade or are dealing with denormals.\n+                    //   2. Our significand excluding the integral bit is all zeros.\n+                    let crossing_binade_boundary = self.exp != S::MIN_EXP &&\n+                        self.sig[0] & sig_mask == 0;\n+\n+                    // Decrement the significand.\n+                    //\n+                    // We always do this since:\n+                    //   1. If we are dealing with a non-binade decrement, by definition we\n+                    //   just decrement the significand.\n+                    //   2. If we are dealing with a normal -> normal binade decrement, since\n+                    //   we have an explicit integral bit the fact that all bits but the\n+                    //   integral bit are zero implies that subtracting one will yield a\n+                    //   significand with 0 integral bit and 1 in all other spots. Thus we\n+                    //   must just adjust the exponent and set the integral bit to 1.\n+                    //   3. If we are dealing with a normal -> denormal binade decrement,\n+                    //   since we set the integral bit to 0 when we represent denormals, we\n+                    //   just decrement the significand.\n+                    sig::decrement(&mut self.sig);\n+\n+                    if crossing_binade_boundary {\n+                        // Our result is a normal number. Do the following:\n+                        // 1. Set the integral bit to 1.\n+                        // 2. Decrement the exponent.\n+                        sig::set_bit(&mut self.sig, S::PRECISION - 1);\n+                        self.exp -= 1;\n+                    }\n+                } else {\n+                    // If we are positive, we need to increment the significand.\n+\n+                    // We only cross a binade boundary that requires adjusting the exponent if\n+                    // the input is not a denormal and all of said input's significand bits\n+                    // are set. If all of said conditions are true: clear the significand, set\n+                    // the integral bit to 1, and increment the exponent. If we have a\n+                    // denormal always increment since moving denormals and the numbers in the\n+                    // smallest normal binade have the same exponent in our representation.\n+                    let crossing_binade_boundary = !self.is_denormal() &&\n+                        self.sig[0] & sig_mask == sig_mask;\n+\n+                    if crossing_binade_boundary {\n+                        self.sig = [0];\n+                        sig::set_bit(&mut self.sig, S::PRECISION - 1);\n+                        assert_ne!(\n+                            self.exp,\n+                            S::MAX_EXP,\n+                            \"We can not increment an exponent beyond the MAX_EXP \\\n+                             allowed by the given floating point semantics.\"\n+                        );\n+                        self.exp += 1;\n+                    } else {\n+                        sig::increment(&mut self.sig);\n+                    }\n+                }\n+                Status::OK.and(self)\n+            }\n+        }\n+    }\n+\n+    fn from_bits(input: u128) -> Self {\n+        // Dispatch to semantics.\n+        S::from_bits(input)\n+    }\n+\n+    fn from_u128_r(input: u128, round: Round) -> StatusAnd<Self> {\n+        IeeeFloat {\n+            sig: [input],\n+            exp: S::PRECISION as ExpInt - 1,\n+            category: Category::Normal,\n+            sign: false,\n+            marker: PhantomData,\n+        }.normalize(round, Loss::ExactlyZero)\n+    }\n+\n+    fn from_str_r(mut s: &str, mut round: Round) -> Result<StatusAnd<Self>, ParseError> {\n+        if s.is_empty() {\n+            return Err(ParseError(\"Invalid string length\"));\n+        }\n+\n+        // Handle special cases.\n+        match s {\n+            \"inf\" | \"INFINITY\" => return Ok(Status::OK.and(Self::INFINITY)),\n+            \"-inf\" | \"-INFINITY\" => return Ok(Status::OK.and(-Self::INFINITY)),\n+            \"nan\" | \"NaN\" => return Ok(Status::OK.and(Self::NAN)),\n+            \"-nan\" | \"-NaN\" => return Ok(Status::OK.and(-Self::NAN)),\n+            _ => {}\n+        }\n+\n+        // Handle a leading minus sign.\n+        let minus = s.starts_with(\"-\");\n+        if minus || s.starts_with(\"+\") {\n+            s = &s[1..];\n+            if s.is_empty() {\n+                return Err(ParseError(\"String has no digits\"));\n+            }\n+        }\n+\n+        // Adjust the rounding mode for the absolute value below.\n+        if minus {\n+            round = -round;\n+        }\n+\n+        let r = if s.starts_with(\"0x\") || s.starts_with(\"0X\") {\n+            s = &s[2..];\n+            if s.is_empty() {\n+                return Err(ParseError(\"Invalid string\"));\n+            }\n+            Self::from_hexadecimal_string(s, round)?\n+        } else {\n+            Self::from_decimal_string(s, round)?\n+        };\n+\n+        Ok(r.map(|r| if minus { -r } else { r }))\n+    }\n+\n+    fn to_bits(self) -> u128 {\n+        // Dispatch to semantics.\n+        S::to_bits(self)\n+    }\n+\n+    fn to_u128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<u128> {\n+        // The result of trying to convert a number too large.\n+        let overflow = if self.sign {\n+            // Negative numbers cannot be represented as unsigned.\n+            0\n+        } else {\n+            // Largest unsigned integer of the given width.\n+            !0 >> (128 - width)\n+        };\n+\n+        *is_exact = false;\n+\n+        match self.category {\n+            Category::NaN => Status::INVALID_OP.and(0),\n+\n+            Category::Infinity => Status::INVALID_OP.and(overflow),\n+\n+            Category::Zero => {\n+                // Negative zero can't be represented as an int.\n+                *is_exact = !self.sign;\n+                Status::OK.and(0)\n+            }\n+\n+            Category::Normal => {\n+                let mut r = 0;\n+\n+                // Step 1: place our absolute value, with any fraction truncated, in\n+                // the destination.\n+                let truncated_bits = if self.exp < 0 {\n+                    // Our absolute value is less than one; truncate everything.\n+                    // For exponent -1 the integer bit represents .5, look at that.\n+                    // For smaller exponents leftmost truncated bit is 0.\n+                    S::PRECISION - 1 + (-self.exp) as usize\n+                } else {\n+                    // We want the most significant (exponent + 1) bits; the rest are\n+                    // truncated.\n+                    let bits = self.exp as usize + 1;\n+\n+                    // Hopelessly large in magnitude?\n+                    if bits > width {\n+                        return Status::INVALID_OP.and(overflow);\n+                    }\n+\n+                    if bits < S::PRECISION {\n+                        // We truncate (S::PRECISION - bits) bits.\n+                        r = self.sig[0] >> (S::PRECISION - bits);\n+                        S::PRECISION - bits\n+                    } else {\n+                        // We want at least as many bits as are available.\n+                        r = self.sig[0] << (bits - S::PRECISION);\n+                        0\n+                    }\n+                };\n+\n+                // Step 2: work out any lost fraction, and increment the absolute\n+                // value if we would round away from zero.\n+                let mut loss = Loss::ExactlyZero;\n+                if truncated_bits > 0 {\n+                    loss = Loss::through_truncation(&self.sig, truncated_bits);\n+                    if loss != Loss::ExactlyZero &&\n+                        self.round_away_from_zero(round, loss, truncated_bits)\n+                    {\n+                        r = r.wrapping_add(1);\n+                        if r == 0 {\n+                            return Status::INVALID_OP.and(overflow); // Overflow.\n+                        }\n+                    }\n+                }\n+\n+                // Step 3: check if we fit in the destination.\n+                if r > overflow {\n+                    return Status::INVALID_OP.and(overflow);\n+                }\n+\n+                if loss == Loss::ExactlyZero {\n+                    *is_exact = true;\n+                    Status::OK.and(r)\n+                } else {\n+                    Status::INEXACT.and(r)\n+                }\n+            }\n+        }\n+    }\n+\n+    fn cmp_abs_normal(self, rhs: Self) -> Ordering {\n+        assert!(self.is_finite_non_zero());\n+        assert!(rhs.is_finite_non_zero());\n+\n+        // If exponents are equal, do an unsigned comparison of the significands.\n+        self.exp.cmp(&rhs.exp).then_with(\n+            || sig::cmp(&self.sig, &rhs.sig),\n+        )\n+    }\n+\n+    fn bitwise_eq(self, rhs: Self) -> bool {\n+        if self.category != rhs.category || self.sign != rhs.sign {\n+            return false;\n+        }\n+\n+        if self.category == Category::Zero || self.category == Category::Infinity {\n+            return true;\n+        }\n+\n+        if self.is_finite_non_zero() && self.exp != rhs.exp {\n+            return false;\n+        }\n+\n+        self.sig == rhs.sig\n+    }\n+\n+    fn is_negative(self) -> bool {\n+        self.sign\n+    }\n+\n+    fn is_denormal(self) -> bool {\n+        self.is_finite_non_zero() && self.exp == S::MIN_EXP &&\n+            !sig::get_bit(&self.sig, S::PRECISION - 1)\n+    }\n+\n+    fn is_signaling(self) -> bool {\n+        // IEEE-754R 2008 6.2.1: A signaling NaN bit string should be encoded with the\n+        // first bit of the trailing significand being 0.\n+        self.is_nan() && !sig::get_bit(&self.sig, S::QNAN_BIT)\n+    }\n+\n+    fn category(self) -> Category {\n+        self.category\n+    }\n+\n+    fn get_exact_inverse(self) -> Option<Self> {\n+        // Special floats and denormals have no exact inverse.\n+        if !self.is_finite_non_zero() {\n+            return None;\n+        }\n+\n+        // Check that the number is a power of two by making sure that only the\n+        // integer bit is set in the significand.\n+        if self.sig != [1 << (S::PRECISION - 1)] {\n+            return None;\n+        }\n+\n+        // Get the inverse.\n+        let mut reciprocal = Self::from_u128(1).value;\n+        let status;\n+        reciprocal = unpack!(status=, reciprocal / self);\n+        if status != Status::OK {\n+            return None;\n+        }\n+\n+        // Avoid multiplication with a denormal, it is not safe on all platforms and\n+        // may be slower than a normal division.\n+        if reciprocal.is_denormal() {\n+            return None;\n+        }\n+\n+        assert!(reciprocal.is_finite_non_zero());\n+        assert_eq!(reciprocal.sig, [1 << (S::PRECISION - 1)]);\n+\n+        Some(reciprocal)\n+    }\n+\n+    fn ilogb(mut self) -> ExpInt {\n+        if self.is_nan() {\n+            return IEK_NAN;\n+        }\n+        if self.is_zero() {\n+            return IEK_ZERO;\n+        }\n+        if self.is_infinite() {\n+            return IEK_INF;\n+        }\n+        if !self.is_denormal() {\n+            return self.exp;\n+        }\n+\n+        let sig_bits = (S::PRECISION - 1) as ExpInt;\n+        self.exp += sig_bits;\n+        self = self.normalize(Round::NearestTiesToEven, Loss::ExactlyZero)\n+            .value;\n+        self.exp - sig_bits\n+    }\n+\n+    fn scalbn_r(mut self, exp: ExpInt, round: Round) -> Self {\n+        // If exp is wildly out-of-scale, simply adding it to self.exp will\n+        // overflow; clamp it to a safe range before adding, but ensure that the range\n+        // is large enough that the clamp does not change the result. The range we\n+        // need to support is the difference between the largest possible exponent and\n+        // the normalized exponent of half the smallest denormal.\n+\n+        let sig_bits = (S::PRECISION - 1) as i32;\n+        let max_change = S::MAX_EXP as i32 - (S::MIN_EXP as i32 - sig_bits) + 1;\n+\n+        // Clamp to one past the range ends to let normalize handle overflow.\n+        let exp_change = cmp::min(cmp::max(exp as i32, (-max_change - 1)), max_change);\n+        self.exp = self.exp.saturating_add(exp_change as ExpInt);\n+        self = self.normalize(round, Loss::ExactlyZero).value;\n+        if self.is_nan() {\n+            sig::set_bit(&mut self.sig, S::QNAN_BIT);\n+        }\n+        self\n+    }\n+\n+    fn frexp_r(mut self, exp: &mut ExpInt, round: Round) -> Self {\n+        *exp = self.ilogb();\n+\n+        // Quiet signalling nans.\n+        if *exp == IEK_NAN {\n+            sig::set_bit(&mut self.sig, S::QNAN_BIT);\n+            return self;\n+        }\n+\n+        if *exp == IEK_INF {\n+            return self;\n+        }\n+\n+        // 1 is added because frexp is defined to return a normalized fraction in\n+        // +/-[0.5, 1.0), rather than the usual +/-[1.0, 2.0).\n+        if *exp == IEK_ZERO {\n+            *exp = 0;\n+        } else {\n+            *exp += 1;\n+        }\n+        self.scalbn_r(-*exp, round)\n+    }\n+}\n+\n+impl<S: Semantics, T: Semantics> FloatConvert<IeeeFloat<T>> for IeeeFloat<S> {\n+    fn convert_r(self, round: Round, loses_info: &mut bool) -> StatusAnd<IeeeFloat<T>> {\n+        let mut r = IeeeFloat {\n+            sig: self.sig,\n+            exp: self.exp,\n+            category: self.category,\n+            sign: self.sign,\n+            marker: PhantomData,\n+        };\n+\n+        // x86 has some unusual NaNs which cannot be represented in any other\n+        // format; note them here.\n+        fn is_x87_double_extended<S: Semantics>() -> bool {\n+            S::QNAN_SIGNIFICAND == X87DoubleExtendedS::QNAN_SIGNIFICAND\n+        }\n+        let x87_special_nan = is_x87_double_extended::<S>() && !is_x87_double_extended::<T>() &&\n+            r.category == Category::NaN &&\n+            (r.sig[0] & S::QNAN_SIGNIFICAND) != S::QNAN_SIGNIFICAND;\n+\n+        // If this is a truncation of a denormal number, and the target semantics\n+        // has larger exponent range than the source semantics (this can happen\n+        // when truncating from PowerPC double-double to double format), the\n+        // right shift could lose result mantissa bits. Adjust exponent instead\n+        // of performing excessive shift.\n+        let mut shift = T::PRECISION as ExpInt - S::PRECISION as ExpInt;\n+        if shift < 0 && r.is_finite_non_zero() {\n+            let mut exp_change = sig::omsb(&r.sig) as ExpInt - S::PRECISION as ExpInt;\n+            if r.exp + exp_change < T::MIN_EXP {\n+                exp_change = T::MIN_EXP - r.exp;\n+            }\n+            if exp_change < shift {\n+                exp_change = shift;\n+            }\n+            if exp_change < 0 {\n+                shift -= exp_change;\n+                r.exp += exp_change;\n+            }\n+        }\n+\n+        // If this is a truncation, perform the shift.\n+        let mut loss = Loss::ExactlyZero;\n+        if shift < 0 && (r.is_finite_non_zero() || r.category == Category::NaN) {\n+            loss = sig::shift_right(&mut r.sig, &mut 0, -shift as usize);\n+        }\n+\n+        // If this is an extension, perform the shift.\n+        if shift > 0 && (r.is_finite_non_zero() || r.category == Category::NaN) {\n+            sig::shift_left(&mut r.sig, &mut 0, shift as usize);\n+        }\n+\n+        let status;\n+        if r.is_finite_non_zero() {\n+            r = unpack!(status=, r.normalize(round, loss));\n+            *loses_info = status != Status::OK;\n+        } else if r.category == Category::NaN {\n+            *loses_info = loss != Loss::ExactlyZero || x87_special_nan;\n+\n+            // For x87 extended precision, we want to make a NaN, not a special NaN if\n+            // the input wasn't special either.\n+            if !x87_special_nan && is_x87_double_extended::<T>() {\n+                sig::set_bit(&mut r.sig, T::PRECISION - 1);\n+            }\n+\n+            // gcc forces the Quiet bit on, which means (float)(double)(float_sNan)\n+            // does not give you back the same bits. This is dubious, and we\n+            // don't currently do it. You're really supposed to get\n+            // an invalid operation signal at runtime, but nobody does that.\n+            status = Status::OK;\n+        } else {\n+            *loses_info = false;\n+            status = Status::OK;\n+        }\n+\n+        status.and(r)\n+    }\n+}\n+\n+impl<S: Semantics> IeeeFloat<S> {\n+    /// Handle positive overflow. We either return infinity or\n+    /// the largest finite number. For negative overflow,\n+    /// negate the `round` argument before calling.\n+    fn overflow_result(round: Round) -> StatusAnd<Self> {\n+        match round {\n+            // Infinity?\n+            Round::NearestTiesToEven | Round::NearestTiesToAway | Round::TowardPositive => {\n+                (Status::OVERFLOW | Status::INEXACT).and(Self::INFINITY)\n+            }\n+            // Otherwise we become the largest finite number.\n+            Round::TowardNegative | Round::TowardZero => Status::INEXACT.and(Self::largest()),\n+        }\n+    }\n+\n+    /// Returns TRUE if, when truncating the current number, with BIT the\n+    /// new LSB, with the given lost fraction and rounding mode, the result\n+    /// would need to be rounded away from zero (i.e., by increasing the\n+    /// signficand). This routine must work for Category::Zero of both signs, and\n+    /// Category::Normal numbers.\n+    fn round_away_from_zero(&self, round: Round, loss: Loss, bit: usize) -> bool {\n+        // NaNs and infinities should not have lost fractions.\n+        assert!(self.is_finite_non_zero() || self.is_zero());\n+\n+        // Current callers never pass this so we don't handle it.\n+        assert_ne!(loss, Loss::ExactlyZero);\n+\n+        match round {\n+            Round::NearestTiesToAway => loss == Loss::ExactlyHalf || loss == Loss::MoreThanHalf,\n+            Round::NearestTiesToEven => {\n+                if loss == Loss::MoreThanHalf {\n+                    return true;\n+                }\n+\n+                // Our zeros don't have a significand to test.\n+                if loss == Loss::ExactlyHalf && self.category != Category::Zero {\n+                    return sig::get_bit(&self.sig, bit);\n+                }\n+\n+                false\n+            }\n+            Round::TowardZero => false,\n+            Round::TowardPositive => !self.sign,\n+            Round::TowardNegative => self.sign,\n+        }\n+    }\n+\n+    fn normalize(mut self, round: Round, mut loss: Loss) -> StatusAnd<Self> {\n+        if !self.is_finite_non_zero() {\n+            return Status::OK.and(self);\n+        }\n+\n+        // Before rounding normalize the exponent of Category::Normal numbers.\n+        let mut omsb = sig::omsb(&self.sig);\n+\n+        if omsb > 0 {\n+            // OMSB is numbered from 1. We want to place it in the integer\n+            // bit numbered PRECISION if possible, with a compensating change in\n+            // the exponent.\n+            let mut final_exp = self.exp.saturating_add(\n+                omsb as ExpInt - S::PRECISION as ExpInt,\n+            );\n+\n+            // If the resulting exponent is too high, overflow according to\n+            // the rounding mode.\n+            if final_exp > S::MAX_EXP {\n+                let round = if self.sign { -round } else { round };\n+                return Self::overflow_result(round).map(|r| r.copy_sign(self));\n+            }\n+\n+            // Subnormal numbers have exponent MIN_EXP, and their MSB\n+            // is forced based on that.\n+            if final_exp < S::MIN_EXP {\n+                final_exp = S::MIN_EXP;\n+            }\n+\n+            // Shifting left is easy as we don't lose precision.\n+            if final_exp < self.exp {\n+                assert_eq!(loss, Loss::ExactlyZero);\n+\n+                let exp_change = (self.exp - final_exp) as usize;\n+                sig::shift_left(&mut self.sig, &mut self.exp, exp_change);\n+\n+                return Status::OK.and(self);\n+            }\n+\n+            // Shift right and capture any new lost fraction.\n+            if final_exp > self.exp {\n+                let exp_change = (final_exp - self.exp) as usize;\n+                loss = sig::shift_right(&mut self.sig, &mut self.exp, exp_change).combine(loss);\n+\n+                // Keep OMSB up-to-date.\n+                omsb = omsb.saturating_sub(exp_change);\n+            }\n+        }\n+\n+        // Now round the number according to round given the lost\n+        // fraction.\n+\n+        // As specified in IEEE 754, since we do not trap we do not report\n+        // underflow for exact results.\n+        if loss == Loss::ExactlyZero {\n+            // Canonicalize zeros.\n+            if omsb == 0 {\n+                self.category = Category::Zero;\n+            }\n+\n+            return Status::OK.and(self);\n+        }\n+\n+        // Increment the significand if we're rounding away from zero.\n+        if self.round_away_from_zero(round, loss, 0) {\n+            if omsb == 0 {\n+                self.exp = S::MIN_EXP;\n+            }\n+\n+            // We should never overflow.\n+            assert_eq!(sig::increment(&mut self.sig), 0);\n+            omsb = sig::omsb(&self.sig);\n+\n+            // Did the significand increment overflow?\n+            if omsb == S::PRECISION + 1 {\n+                // Renormalize by incrementing the exponent and shifting our\n+                // significand right one. However if we already have the\n+                // maximum exponent we overflow to infinity.\n+                if self.exp == S::MAX_EXP {\n+                    self.category = Category::Infinity;\n+\n+                    return (Status::OVERFLOW | Status::INEXACT).and(self);\n+                }\n+\n+                let _: Loss = sig::shift_right(&mut self.sig, &mut self.exp, 1);\n+\n+                return Status::INEXACT.and(self);\n+            }\n+        }\n+\n+        // The normal case - we were and are not denormal, and any\n+        // significand increment above didn't overflow.\n+        if omsb == S::PRECISION {\n+            return Status::INEXACT.and(self);\n+        }\n+\n+        // We have a non-zero denormal.\n+        assert!(omsb < S::PRECISION);\n+\n+        // Canonicalize zeros.\n+        if omsb == 0 {\n+            self.category = Category::Zero;\n+        }\n+\n+        // The Category::Zero case is a denormal that underflowed to zero.\n+        (Status::UNDERFLOW | Status::INEXACT).and(self)\n+    }\n+\n+    fn from_hexadecimal_string(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError> {\n+        let mut r = IeeeFloat {\n+            sig: [0],\n+            exp: 0,\n+            category: Category::Normal,\n+            sign: false,\n+            marker: PhantomData,\n+        };\n+\n+        let mut any_digits = false;\n+        let mut has_exp = false;\n+        let mut bit_pos = LIMB_BITS as isize;\n+        let mut loss = None;\n+\n+        // Without leading or trailing zeros, irrespective of the dot.\n+        let mut first_sig_digit = None;\n+        let mut dot = s.len();\n+\n+        for (p, c) in s.char_indices() {\n+            // Skip leading zeros and any (hexa)decimal point.\n+            if c == '.' {\n+                if dot != s.len() {\n+                    return Err(ParseError(\"String contains multiple dots\"));\n+                }\n+                dot = p;\n+            } else if let Some(hex_value) = c.to_digit(16) {\n+                any_digits = true;\n+\n+                if first_sig_digit.is_none() {\n+                    if hex_value == 0 {\n+                        continue;\n+                    }\n+                    first_sig_digit = Some(p);\n+                }\n+\n+                // Store the number while we have space.\n+                bit_pos -= 4;\n+                if bit_pos >= 0 {\n+                    r.sig[0] |= (hex_value as Limb) << bit_pos;\n+                } else {\n+                    // If zero or one-half (the hexadecimal digit 8) are followed\n+                    // by non-zero, they're a little more than zero or one-half.\n+                    if let Some(ref mut loss) = loss {\n+                        if hex_value != 0 {\n+                            if *loss == Loss::ExactlyZero {\n+                                *loss = Loss::LessThanHalf;\n+                            }\n+                            if *loss == Loss::ExactlyHalf {\n+                                *loss = Loss::MoreThanHalf;\n+                            }\n+                        }\n+                    } else {\n+                        loss = Some(match hex_value {\n+                            0 => Loss::ExactlyZero,\n+                            1...7 => Loss::LessThanHalf,\n+                            8 => Loss::ExactlyHalf,\n+                            9...15 => Loss::MoreThanHalf,\n+                            _ => unreachable!(),\n+                        });\n+                    }\n+                }\n+            } else if c == 'p' || c == 'P' {\n+                if !any_digits {\n+                    return Err(ParseError(\"Significand has no digits\"));\n+                }\n+\n+                if dot == s.len() {\n+                    dot = p;\n+                }\n+\n+                let mut chars = s[p + 1..].chars().peekable();\n+\n+                // Adjust for the given exponent.\n+                let exp_minus = chars.peek() == Some(&'-');\n+                if exp_minus || chars.peek() == Some(&'+') {\n+                    chars.next();\n+                }\n+\n+                for c in chars {\n+                    if let Some(value) = c.to_digit(10) {\n+                        has_exp = true;\n+                        r.exp = r.exp.saturating_mul(10).saturating_add(value as ExpInt);\n+                    } else {\n+                        return Err(ParseError(\"Invalid character in exponent\"));\n+                    }\n+                }\n+                if !has_exp {\n+                    return Err(ParseError(\"Exponent has no digits\"));\n+                }\n+\n+                if exp_minus {\n+                    r.exp = -r.exp;\n+                }\n+\n+                break;\n+            } else {\n+                return Err(ParseError(\"Invalid character in significand\"));\n+            }\n+        }\n+        if !any_digits {\n+            return Err(ParseError(\"Significand has no digits\"));\n+        }\n+\n+        // Hex floats require an exponent but not a hexadecimal point.\n+        if !has_exp {\n+            return Err(ParseError(\"Hex strings require an exponent\"));\n+        }\n+\n+        // Ignore the exponent if we are zero.\n+        let first_sig_digit = match first_sig_digit {\n+            Some(p) => p,\n+            None => return Ok(Status::OK.and(Self::ZERO)),\n+        };\n+\n+        // Calculate the exponent adjustment implicit in the number of\n+        // significant digits and adjust for writing the significand starting\n+        // at the most significant nibble.\n+        let exp_adjustment = if dot > first_sig_digit {\n+            ExpInt::try_from(dot - first_sig_digit).unwrap()\n+        } else {\n+            -ExpInt::try_from(first_sig_digit - dot - 1).unwrap()\n+        };\n+        let exp_adjustment = exp_adjustment\n+            .saturating_mul(4)\n+            .saturating_sub(1)\n+            .saturating_add(S::PRECISION as ExpInt)\n+            .saturating_sub(LIMB_BITS as ExpInt);\n+        r.exp = r.exp.saturating_add(exp_adjustment);\n+\n+        Ok(r.normalize(round, loss.unwrap_or(Loss::ExactlyZero)))\n+    }\n+\n+    fn from_decimal_string(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError> {\n+        // Given a normal decimal floating point number of the form\n+        //\n+        //   dddd.dddd[eE][+-]ddd\n+        //\n+        // where the decimal point and exponent are optional, fill out the\n+        // variables below. Exponent is appropriate if the significand is\n+        // treated as an integer, and normalized_exp if the significand\n+        // is taken to have the decimal point after a single leading\n+        // non-zero digit.\n+        //\n+        // If the value is zero, first_sig_digit is None.\n+\n+        let mut any_digits = false;\n+        let mut dec_exp = 0i32;\n+\n+        // Without leading or trailing zeros, irrespective of the dot.\n+        let mut first_sig_digit = None;\n+        let mut last_sig_digit = 0;\n+        let mut dot = s.len();\n+\n+        for (p, c) in s.char_indices() {\n+            if c == '.' {\n+                if dot != s.len() {\n+                    return Err(ParseError(\"String contains multiple dots\"));\n+                }\n+                dot = p;\n+            } else if let Some(dec_value) = c.to_digit(10) {\n+                any_digits = true;\n+\n+                if dec_value != 0 {\n+                    if first_sig_digit.is_none() {\n+                        first_sig_digit = Some(p);\n+                    }\n+                    last_sig_digit = p;\n+                }\n+            } else if c == 'e' || c == 'E' {\n+                if !any_digits {\n+                    return Err(ParseError(\"Significand has no digits\"));\n+                }\n+\n+                if dot == s.len() {\n+                    dot = p;\n+                }\n+\n+                let mut chars = s[p + 1..].chars().peekable();\n+\n+                // Adjust for the given exponent.\n+                let exp_minus = chars.peek() == Some(&'-');\n+                if exp_minus || chars.peek() == Some(&'+') {\n+                    chars.next();\n+                }\n+\n+                any_digits = false;\n+                for c in chars {\n+                    if let Some(value) = c.to_digit(10) {\n+                        any_digits = true;\n+                        dec_exp = dec_exp.saturating_mul(10).saturating_add(value as i32);\n+                    } else {\n+                        return Err(ParseError(\"Invalid character in exponent\"));\n+                    }\n+                }\n+                if !any_digits {\n+                    return Err(ParseError(\"Exponent has no digits\"));\n+                }\n+\n+                if exp_minus {\n+                    dec_exp = -dec_exp;\n+                }\n+\n+                break;\n+            } else {\n+                return Err(ParseError(\"Invalid character in significand\"));\n+            }\n+        }\n+        if !any_digits {\n+            return Err(ParseError(\"Significand has no digits\"));\n+        }\n+\n+        // Test if we have a zero number allowing for non-zero exponents.\n+        let first_sig_digit = match first_sig_digit {\n+            Some(p) => p,\n+            None => return Ok(Status::OK.and(Self::ZERO)),\n+        };\n+\n+        // Adjust the exponents for any decimal point.\n+        if dot > last_sig_digit {\n+            dec_exp = dec_exp.saturating_add((dot - last_sig_digit - 1) as i32);\n+        } else {\n+            dec_exp = dec_exp.saturating_sub((last_sig_digit - dot) as i32);\n+        }\n+        let significand_digits = last_sig_digit - first_sig_digit + 1 -\n+            (dot > first_sig_digit && dot < last_sig_digit) as usize;\n+        let normalized_exp = dec_exp.saturating_add(significand_digits as i32 - 1);\n+\n+        // Handle the cases where exponents are obviously too large or too\n+        // small. Writing L for log 10 / log 2, a number d.ddddd*10^dec_exp\n+        // definitely overflows if\n+        //\n+        //       (dec_exp - 1) * L >= MAX_EXP\n+        //\n+        // and definitely underflows to zero where\n+        //\n+        //       (dec_exp + 1) * L <= MIN_EXP - PRECISION\n+        //\n+        // With integer arithmetic the tightest bounds for L are\n+        //\n+        //       93/28 < L < 196/59            [ numerator <= 256 ]\n+        //       42039/12655 < L < 28738/8651  [ numerator <= 65536 ]\n+\n+        // Check for MAX_EXP.\n+        if normalized_exp.saturating_sub(1).saturating_mul(42039) >= 12655 * S::MAX_EXP as i32 {\n+            // Overflow and round.\n+            return Ok(Self::overflow_result(round));\n+        }\n+\n+        // Check for MIN_EXP.\n+        if normalized_exp.saturating_add(1).saturating_mul(28738) <=\n+            8651 * (S::MIN_EXP as i32 - S::PRECISION as i32)\n+        {\n+            // Underflow to zero and round.\n+            let r = if round == Round::TowardPositive {\n+                IeeeFloat::SMALLEST\n+            } else {\n+                IeeeFloat::ZERO\n+            };\n+            return Ok((Status::UNDERFLOW | Status::INEXACT).and(r));\n+        }\n+\n+        // A tight upper bound on number of bits required to hold an\n+        // N-digit decimal integer is N * 196 / 59. Allocate enough space\n+        // to hold the full significand, and an extra limb required by\n+        // tcMultiplyPart.\n+        let max_limbs = limbs_for_bits(1 + 196 * significand_digits / 59);\n+        let mut dec_sig = Vec::with_capacity(max_limbs);\n+\n+        // Convert to binary efficiently - we do almost all multiplication\n+        // in a Limb. When this would overflow do we do a single\n+        // bignum multiplication, and then revert again to multiplication\n+        // in a Limb.\n+        let mut chars = s[first_sig_digit..last_sig_digit + 1].chars();\n+        loop {\n+            let mut val = 0;\n+            let mut multiplier = 1;\n+\n+            loop {\n+                let dec_value = match chars.next() {\n+                    Some('.') => continue,\n+                    Some(c) => c.to_digit(10).unwrap(),\n+                    None => break,\n+                };\n+\n+                multiplier *= 10;\n+                val = val * 10 + dec_value as Limb;\n+\n+                // The maximum number that can be multiplied by ten with any\n+                // digit added without overflowing a Limb.\n+                if multiplier > (!0 - 9) / 10 {\n+                    break;\n+                }\n+            }\n+\n+            // If we've consumed no digits, we're done.\n+            if multiplier == 1 {\n+                break;\n+            }\n+\n+            // Multiply out the current limb.\n+            let mut carry = val;\n+            for x in &mut dec_sig {\n+                let [low, mut high] = sig::widening_mul(*x, multiplier);\n+\n+                // Now add carry.\n+                let (low, overflow) = low.overflowing_add(carry);\n+                high += overflow as Limb;\n+\n+                *x = low;\n+                carry = high;\n+            }\n+\n+            // If we had carry, we need another limb (likely but not guaranteed).\n+            if carry > 0 {\n+                dec_sig.push(carry);\n+            }\n+        }\n+\n+        // Calculate pow(5, abs(dec_exp)) into `pow5_full`.\n+        // The *_calc Vec's are reused scratch space, as an optimization.\n+        let (pow5_full, mut pow5_calc, mut sig_calc, mut sig_scratch_calc) = {\n+            let mut power = dec_exp.abs() as usize;\n+\n+            const FIRST_EIGHT_POWERS: [Limb; 8] = [1, 5, 25, 125, 625, 3125, 15625, 78125];\n+\n+            let mut p5_scratch = vec![];\n+            let mut p5 = vec![FIRST_EIGHT_POWERS[4]];\n+\n+            let mut r_scratch = vec![];\n+            let mut r = vec![FIRST_EIGHT_POWERS[power & 7]];\n+            power >>= 3;\n+\n+            while power > 0 {\n+                // Calculate pow(5,pow(2,n+3)).\n+                p5_scratch.resize(p5.len() * 2, 0);\n+                let _: Loss = sig::mul(&mut p5_scratch, &mut 0, &p5, &p5, p5.len() * 2 * LIMB_BITS);\n+                while p5_scratch.last() == Some(&0) {\n+                    p5_scratch.pop();\n+                }\n+                mem::swap(&mut p5, &mut p5_scratch);\n+\n+                if power & 1 != 0 {\n+                    r_scratch.resize(r.len() + p5.len(), 0);\n+                    let _: Loss = sig::mul(\n+                        &mut r_scratch,\n+                        &mut 0,\n+                        &r,\n+                        &p5,\n+                        (r.len() + p5.len()) * LIMB_BITS,\n+                    );\n+                    while r_scratch.last() == Some(&0) {\n+                        r_scratch.pop();\n+                    }\n+                    mem::swap(&mut r, &mut r_scratch);\n+                }\n+\n+                power >>= 1;\n+            }\n+\n+            (r, r_scratch, p5, p5_scratch)\n+        };\n+\n+        // Attempt dec_sig * 10^dec_exp with increasing precision.\n+        let mut attempt = 1;\n+        loop {\n+            let calc_precision = (LIMB_BITS << attempt) - 1;\n+            attempt += 1;\n+\n+            let calc_normal_from_limbs = |sig: &mut Vec<Limb>,\n+                                          limbs: &[Limb]|\n+             -> StatusAnd<ExpInt> {\n+                sig.resize(limbs_for_bits(calc_precision), 0);\n+                let (mut loss, mut exp) = sig::from_limbs(sig, limbs, calc_precision);\n+\n+                // Before rounding normalize the exponent of Category::Normal numbers.\n+                let mut omsb = sig::omsb(sig);\n+\n+                assert_ne!(omsb, 0);\n+\n+                // OMSB is numbered from 1. We want to place it in the integer\n+                // bit numbered PRECISION if possible, with a compensating change in\n+                // the exponent.\n+                let final_exp = exp.saturating_add(omsb as ExpInt - calc_precision as ExpInt);\n+\n+                // Shifting left is easy as we don't lose precision.\n+                if final_exp < exp {\n+                    assert_eq!(loss, Loss::ExactlyZero);\n+\n+                    let exp_change = (exp - final_exp) as usize;\n+                    sig::shift_left(sig, &mut exp, exp_change);\n+\n+                    return Status::OK.and(exp);\n+                }\n+\n+                // Shift right and capture any new lost fraction.\n+                if final_exp > exp {\n+                    let exp_change = (final_exp - exp) as usize;\n+                    loss = sig::shift_right(sig, &mut exp, exp_change).combine(loss);\n+\n+                    // Keep OMSB up-to-date.\n+                    omsb = omsb.saturating_sub(exp_change);\n+                }\n+\n+                assert_eq!(omsb, calc_precision);\n+\n+                // Now round the number according to round given the lost\n+                // fraction.\n+\n+                // As specified in IEEE 754, since we do not trap we do not report\n+                // underflow for exact results.\n+                if loss == Loss::ExactlyZero {\n+                    return Status::OK.and(exp);\n+                }\n+\n+                // Increment the significand if we're rounding away from zero.\n+                if loss == Loss::MoreThanHalf || loss == Loss::ExactlyHalf && sig::get_bit(sig, 0) {\n+                    // We should never overflow.\n+                    assert_eq!(sig::increment(sig), 0);\n+                    omsb = sig::omsb(sig);\n+\n+                    // Did the significand increment overflow?\n+                    if omsb == calc_precision + 1 {\n+                        let _: Loss = sig::shift_right(sig, &mut exp, 1);\n+\n+                        return Status::INEXACT.and(exp);\n+                    }\n+                }\n+\n+                // The normal case - we were and are not denormal, and any\n+                // significand increment above didn't overflow.\n+                Status::INEXACT.and(exp)\n+            };\n+\n+            let status;\n+            let mut exp = unpack!(status=,\n+                calc_normal_from_limbs(&mut sig_calc, &dec_sig));\n+            let pow5_status;\n+            let pow5_exp = unpack!(pow5_status=,\n+                calc_normal_from_limbs(&mut pow5_calc, &pow5_full));\n+\n+            // Add dec_exp, as 10^n = 5^n * 2^n.\n+            exp += dec_exp as ExpInt;\n+\n+            let mut used_bits = S::PRECISION;\n+            let mut truncated_bits = calc_precision - used_bits;\n+\n+            let half_ulp_err1 = (status != Status::OK) as Limb;\n+            let (calc_loss, half_ulp_err2);\n+            if dec_exp >= 0 {\n+                exp += pow5_exp;\n+\n+                sig_scratch_calc.resize(sig_calc.len() + pow5_calc.len(), 0);\n+                calc_loss = sig::mul(\n+                    &mut sig_scratch_calc,\n+                    &mut exp,\n+                    &sig_calc,\n+                    &pow5_calc,\n+                    calc_precision,\n+                );\n+                mem::swap(&mut sig_calc, &mut sig_scratch_calc);\n+\n+                half_ulp_err2 = (pow5_status != Status::OK) as Limb;\n+            } else {\n+                exp -= pow5_exp;\n+\n+                sig_scratch_calc.resize(sig_calc.len(), 0);\n+                calc_loss = sig::div(\n+                    &mut sig_scratch_calc,\n+                    &mut exp,\n+                    &mut sig_calc,\n+                    &mut pow5_calc,\n+                    calc_precision,\n+                );\n+                mem::swap(&mut sig_calc, &mut sig_scratch_calc);\n+\n+                // Denormal numbers have less precision.\n+                if exp < S::MIN_EXP {\n+                    truncated_bits += (S::MIN_EXP - exp) as usize;\n+                    used_bits = calc_precision.saturating_sub(truncated_bits);\n+                }\n+                // Extra half-ulp lost in reciprocal of exponent.\n+                half_ulp_err2 = 2 *\n+                    (pow5_status != Status::OK || calc_loss != Loss::ExactlyZero) as Limb;\n+            }\n+\n+            // Both sig::mul and sig::div return the\n+            // result with the integer bit set.\n+            assert!(sig::get_bit(&sig_calc, calc_precision - 1));\n+\n+            // The error from the true value, in half-ulps, on multiplying two\n+            // floating point numbers, which differ from the value they\n+            // approximate by at most half_ulp_err1 and half_ulp_err2 half-ulps, is strictly less\n+            // than the returned value.\n+            //\n+            // See \"How to Read Floating Point Numbers Accurately\" by William D Clinger.\n+            assert!(\n+                half_ulp_err1 < 2 || half_ulp_err2 < 2 || (half_ulp_err1 + half_ulp_err2 < 8)\n+            );\n+\n+            let inexact = (calc_loss != Loss::ExactlyZero) as Limb;\n+            let half_ulp_err = if half_ulp_err1 + half_ulp_err2 == 0 {\n+                inexact * 2 // <= inexact half-ulps.\n+            } else {\n+                inexact + 2 * (half_ulp_err1 + half_ulp_err2)\n+            };\n+\n+            let ulps_from_boundary = {\n+                let bits = calc_precision - used_bits - 1;\n+\n+                let i = bits / LIMB_BITS;\n+                let limb = sig_calc[i] & (!0 >> (LIMB_BITS - 1 - bits % LIMB_BITS));\n+                let boundary = match round {\n+                    Round::NearestTiesToEven | Round::NearestTiesToAway => 1 << (bits % LIMB_BITS),\n+                    _ => 0,\n+                };\n+                if i == 0 {\n+                    let delta = limb.wrapping_sub(boundary);\n+                    cmp::min(delta, delta.wrapping_neg())\n+                } else if limb == boundary {\n+                    if !sig::is_all_zeros(&sig_calc[1..i]) {\n+                        !0 // A lot.\n+                    } else {\n+                        sig_calc[0]\n+                    }\n+                } else if limb == boundary.wrapping_sub(1) {\n+                    if sig_calc[1..i].iter().any(|&x| x.wrapping_neg() != 1) {\n+                        !0 // A lot.\n+                    } else {\n+                        sig_calc[0].wrapping_neg()\n+                    }\n+                } else {\n+                    !0 // A lot.\n+                }\n+            };\n+\n+            // Are we guaranteed to round correctly if we truncate?\n+            if ulps_from_boundary.saturating_mul(2) >= half_ulp_err {\n+                let mut r = IeeeFloat {\n+                    sig: [0],\n+                    exp,\n+                    category: Category::Normal,\n+                    sign: false,\n+                    marker: PhantomData,\n+                };\n+                sig::extract(&mut r.sig, &sig_calc, used_bits, calc_precision - used_bits);\n+                // If we extracted less bits above we must adjust our exponent\n+                // to compensate for the implicit right shift.\n+                r.exp += (S::PRECISION - used_bits) as ExpInt;\n+                let loss = Loss::through_truncation(&sig_calc, truncated_bits);\n+                return Ok(r.normalize(round, loss));\n+            }\n+        }\n+    }\n+}\n+\n+impl Loss {\n+    /// Combine the effect of two lost fractions.\n+    fn combine(self, less_significant: Loss) -> Loss {\n+        let mut more_significant = self;\n+        if less_significant != Loss::ExactlyZero {\n+            if more_significant == Loss::ExactlyZero {\n+                more_significant = Loss::LessThanHalf;\n+            } else if more_significant == Loss::ExactlyHalf {\n+                more_significant = Loss::MoreThanHalf;\n+            }\n+        }\n+\n+        more_significant\n+    }\n+\n+    /// Return the fraction lost were a bignum truncated losing the least\n+    /// significant `bits` bits.\n+    fn through_truncation(limbs: &[Limb], bits: usize) -> Loss {\n+        if bits == 0 {\n+            return Loss::ExactlyZero;\n+        }\n+\n+        let half_bit = bits - 1;\n+        let half_limb = half_bit / LIMB_BITS;\n+        let (half_limb, rest) = if half_limb < limbs.len() {\n+            (limbs[half_limb], &limbs[..half_limb])\n+        } else {\n+            (0, limbs)\n+        };\n+        let half = 1 << (half_bit % LIMB_BITS);\n+        let has_half = half_limb & half != 0;\n+        let has_rest = half_limb & (half - 1) != 0 || !sig::is_all_zeros(rest);\n+\n+        match (has_half, has_rest) {\n+            (false, false) => Loss::ExactlyZero,\n+            (false, true) => Loss::LessThanHalf,\n+            (true, false) => Loss::ExactlyHalf,\n+            (true, true) => Loss::MoreThanHalf,\n+        }\n+    }\n+}\n+\n+/// Implementation details of IeeeFloat significands, such as big integer arithmetic.\n+/// As a rule of thumb, no functions in this module should dynamically allocate.\n+mod sig {\n+    use std::cmp::Ordering;\n+    use std::mem;\n+    use super::{ExpInt, Limb, LIMB_BITS, limbs_for_bits, Loss};\n+\n+    pub(super) fn is_all_zeros(limbs: &[Limb]) -> bool {\n+        limbs.iter().all(|&l| l == 0)\n+    }\n+\n+    /// One, not zero, based MSB. That is, returns 0 for a zeroed significand.\n+    pub(super) fn omsb(limbs: &[Limb]) -> usize {\n+        for i in (0..limbs.len()).rev() {\n+            if limbs[i] != 0 {\n+                return (i + 1) * LIMB_BITS - limbs[i].leading_zeros() as usize;\n+            }\n+        }\n+\n+        0\n+    }\n+\n+    /// Comparison (unsigned) of two significands.\n+    pub(super) fn cmp(a: &[Limb], b: &[Limb]) -> Ordering {\n+        assert_eq!(a.len(), b.len());\n+        for (a, b) in a.iter().zip(b).rev() {\n+            match a.cmp(b) {\n+                Ordering::Equal => {}\n+                o => return o,\n+            }\n+        }\n+\n+        Ordering::Equal\n+    }\n+\n+    /// Extract the given bit.\n+    pub(super) fn get_bit(limbs: &[Limb], bit: usize) -> bool {\n+        limbs[bit / LIMB_BITS] & (1 << (bit % LIMB_BITS)) != 0\n+    }\n+\n+    /// Set the given bit.\n+    pub(super) fn set_bit(limbs: &mut [Limb], bit: usize) {\n+        limbs[bit / LIMB_BITS] |= 1 << (bit % LIMB_BITS);\n+    }\n+\n+    /// Clear the given bit.\n+    pub(super) fn clear_bit(limbs: &mut [Limb], bit: usize) {\n+        limbs[bit / LIMB_BITS] &= !(1 << (bit % LIMB_BITS));\n+    }\n+\n+    /// Shift `dst` left `bits` bits, subtract `bits` from its exponent.\n+    pub(super) fn shift_left(dst: &mut [Limb], exp: &mut ExpInt, bits: usize) {\n+        if bits > 0 {\n+            // Our exponent should not underflow.\n+            *exp = exp.checked_sub(bits as ExpInt).unwrap();\n+\n+            // Jump is the inter-limb jump; shift is is intra-limb shift.\n+            let jump = bits / LIMB_BITS;\n+            let shift = bits % LIMB_BITS;\n+\n+            for i in (0..dst.len()).rev() {\n+                let mut limb;\n+\n+                if i < jump {\n+                    limb = 0;\n+                } else {\n+                    // dst[i] comes from the two limbs src[i - jump] and, if we have\n+                    // an intra-limb shift, src[i - jump - 1].\n+                    limb = dst[i - jump];\n+                    if shift > 0 {\n+                        limb <<= shift;\n+                        if i >= jump + 1 {\n+                            limb |= dst[i - jump - 1] >> (LIMB_BITS - shift);\n+                        }\n+                    }\n+                }\n+\n+                dst[i] = limb;\n+            }\n+        }\n+    }\n+\n+    /// Shift `dst` right `bits` bits noting lost fraction.\n+    pub(super) fn shift_right(dst: &mut [Limb], exp: &mut ExpInt, bits: usize) -> Loss {\n+        let loss = Loss::through_truncation(dst, bits);\n+\n+        if bits > 0 {\n+            // Our exponent should not overflow.\n+            *exp = exp.checked_add(bits as ExpInt).unwrap();\n+\n+            // Jump is the inter-limb jump; shift is is intra-limb shift.\n+            let jump = bits / LIMB_BITS;\n+            let shift = bits % LIMB_BITS;\n+\n+            // Perform the shift. This leaves the most significant `bits` bits\n+            // of the result at zero.\n+            for i in 0..dst.len() {\n+                let mut limb;\n+\n+                if i + jump >= dst.len() {\n+                    limb = 0;\n+                } else {\n+                    limb = dst[i + jump];\n+                    if shift > 0 {\n+                        limb >>= shift;\n+                        if i + jump + 1 < dst.len() {\n+                            limb |= dst[i + jump + 1] << (LIMB_BITS - shift);\n+                        }\n+                    }\n+                }\n+\n+                dst[i] = limb;\n+            }\n+        }\n+\n+        loss\n+    }\n+\n+    /// Copy the bit vector of width `src_bits` from `src`, starting at bit SRC_LSB,\n+    /// to `dst`, such that the bit SRC_LSB becomes the least significant bit of `dst`.\n+    /// All high bits above `src_bits` in `dst` are zero-filled.\n+    pub(super) fn extract(dst: &mut [Limb], src: &[Limb], src_bits: usize, src_lsb: usize) {\n+        if src_bits == 0 {\n+            return;\n+        }\n+\n+        let dst_limbs = limbs_for_bits(src_bits);\n+        assert!(dst_limbs <= dst.len());\n+\n+        let src = &src[src_lsb / LIMB_BITS..];\n+        dst[..dst_limbs].copy_from_slice(&src[..dst_limbs]);\n+\n+        let shift = src_lsb % LIMB_BITS;\n+        let _: Loss = shift_right(&mut dst[..dst_limbs], &mut 0, shift);\n+\n+        // We now have (dst_limbs * LIMB_BITS - shift) bits from `src`\n+        // in `dst`.  If this is less that src_bits, append the rest, else\n+        // clear the high bits.\n+        let n = dst_limbs * LIMB_BITS - shift;\n+        if n < src_bits {\n+            let mask = (1 << (src_bits - n)) - 1;\n+            dst[dst_limbs - 1] |= (src[dst_limbs] & mask) << n % LIMB_BITS;\n+        } else if n > src_bits && src_bits % LIMB_BITS > 0 {\n+            dst[dst_limbs - 1] &= (1 << (src_bits % LIMB_BITS)) - 1;\n+        }\n+\n+        // Clear high limbs.\n+        for x in &mut dst[dst_limbs..] {\n+            *x = 0;\n+        }\n+    }\n+\n+    /// We want the most significant PRECISION bits of `src`. There may not\n+    /// be that many; extract what we can.\n+    pub(super) fn from_limbs(dst: &mut [Limb], src: &[Limb], precision: usize) -> (Loss, ExpInt) {\n+        let omsb = omsb(src);\n+\n+        if precision <= omsb {\n+            extract(dst, src, precision, omsb - precision);\n+            (\n+                Loss::through_truncation(src, omsb - precision),\n+                omsb as ExpInt - 1,\n+            )\n+        } else {\n+            extract(dst, src, omsb, 0);\n+            (Loss::ExactlyZero, precision as ExpInt - 1)\n+        }\n+    }\n+\n+    /// Increment in-place, return the carry flag.\n+    pub(super) fn increment(dst: &mut [Limb]) -> Limb {\n+        for x in dst {\n+            *x = x.wrapping_add(1);\n+            if *x != 0 {\n+                return 0;\n+            }\n+        }\n+\n+        1\n+    }\n+\n+    /// Decrement in-place, return the borrow flag.\n+    pub(super) fn decrement(dst: &mut [Limb]) -> Limb {\n+        for x in dst {\n+            *x = x.wrapping_sub(1);\n+            if *x != !0 {\n+                return 0;\n+            }\n+        }\n+\n+        1\n+    }\n+\n+    /// `a += b + c` where `c` is zero or one. Returns the carry flag.\n+    pub(super) fn add(a: &mut [Limb], b: &[Limb], mut c: Limb) -> Limb {\n+        assert!(c <= 1);\n+\n+        for (a, &b) in a.iter_mut().zip(b) {\n+            let (r, overflow) = a.overflowing_add(b);\n+            let (r, overflow2) = r.overflowing_add(c);\n+            *a = r;\n+            c = (overflow | overflow2) as Limb;\n+        }\n+\n+        c\n+    }\n+\n+    /// `a -= b + c` where `c` is zero or one. Returns the borrow flag.\n+    pub(super) fn sub(a: &mut [Limb], b: &[Limb], mut c: Limb) -> Limb {\n+        assert!(c <= 1);\n+\n+        for (a, &b) in a.iter_mut().zip(b) {\n+            let (r, overflow) = a.overflowing_sub(b);\n+            let (r, overflow2) = r.overflowing_sub(c);\n+            *a = r;\n+            c = (overflow | overflow2) as Limb;\n+        }\n+\n+        c\n+    }\n+\n+    /// `a += b` or `a -= b`. Does not preserve `b`.\n+    pub(super) fn add_or_sub(\n+        a_sig: &mut [Limb],\n+        a_exp: &mut ExpInt,\n+        a_sign: &mut bool,\n+        b_sig: &mut [Limb],\n+        b_exp: ExpInt,\n+        b_sign: bool,\n+    ) -> Loss {\n+        // Are we bigger exponent-wise than the RHS?\n+        let bits = *a_exp - b_exp;\n+\n+        // Determine if the operation on the absolute values is effectively\n+        // an addition or subtraction.\n+        // Subtraction is more subtle than one might naively expect.\n+        if *a_sign ^ b_sign {\n+            let (reverse, loss);\n+\n+            if bits == 0 {\n+                reverse = cmp(a_sig, b_sig) == Ordering::Less;\n+                loss = Loss::ExactlyZero;\n+            } else if bits > 0 {\n+                loss = shift_right(b_sig, &mut 0, (bits - 1) as usize);\n+                shift_left(a_sig, a_exp, 1);\n+                reverse = false;\n+            } else {\n+                loss = shift_right(a_sig, a_exp, (-bits - 1) as usize);\n+                shift_left(b_sig, &mut 0, 1);\n+                reverse = true;\n+            }\n+\n+            let borrow = (loss != Loss::ExactlyZero) as Limb;\n+            if reverse {\n+                // The code above is intended to ensure that no borrow is necessary.\n+                assert_eq!(sub(b_sig, a_sig, borrow), 0);\n+                a_sig.copy_from_slice(b_sig);\n+                *a_sign = !*a_sign;\n+            } else {\n+                // The code above is intended to ensure that no borrow is necessary.\n+                assert_eq!(sub(a_sig, b_sig, borrow), 0);\n+            }\n+\n+            // Invert the lost fraction - it was on the RHS and subtracted.\n+            match loss {\n+                Loss::LessThanHalf => Loss::MoreThanHalf,\n+                Loss::MoreThanHalf => Loss::LessThanHalf,\n+                _ => loss,\n+            }\n+        } else {\n+            let loss = if bits > 0 {\n+                shift_right(b_sig, &mut 0, bits as usize)\n+            } else {\n+                shift_right(a_sig, a_exp, -bits as usize)\n+            };\n+            // We have a guard bit; generating a carry cannot happen.\n+            assert_eq!(add(a_sig, b_sig, 0), 0);\n+            loss\n+        }\n+    }\n+\n+    /// `[low, high] = a * b`.\n+    ///\n+    /// This cannot overflow, because\n+    ///\n+    /// `(n - 1) * (n - 1) + 2 * (n - 1) == (n - 1) * (n + 1)`\n+    ///\n+    /// which is less than n^2.\n+    pub(super) fn widening_mul(a: Limb, b: Limb) -> [Limb; 2] {\n+        let mut wide = [0, 0];\n+\n+        if a == 0 || b == 0 {\n+            return wide;\n+        }\n+\n+        const HALF_BITS: usize = LIMB_BITS / 2;\n+\n+        let select = |limb, i| (limb >> (i * HALF_BITS)) & ((1 << HALF_BITS) - 1);\n+        for i in 0..2 {\n+            for j in 0..2 {\n+                let mut x = [select(a, i) * select(b, j), 0];\n+                shift_left(&mut x, &mut 0, (i + j) * HALF_BITS);\n+                assert_eq!(add(&mut wide, &x, 0), 0);\n+            }\n+        }\n+\n+        wide\n+    }\n+\n+    /// `dst = a * b` (for normal `a` and `b`). Returns the lost fraction.\n+    pub(super) fn mul<'a>(\n+        dst: &mut [Limb],\n+        exp: &mut ExpInt,\n+        mut a: &'a [Limb],\n+        mut b: &'a [Limb],\n+        precision: usize,\n+    ) -> Loss {\n+        // Put the narrower number on the `a` for less loops below.\n+        if a.len() > b.len() {\n+            mem::swap(&mut a, &mut b);\n+        }\n+\n+        for x in &mut dst[..b.len()] {\n+            *x = 0;\n+        }\n+\n+        for i in 0..a.len() {\n+            let mut carry = 0;\n+            for j in 0..b.len() {\n+                let [low, mut high] = widening_mul(a[i], b[j]);\n+\n+                // Now add carry.\n+                let (low, overflow) = low.overflowing_add(carry);\n+                high += overflow as Limb;\n+\n+                // And now `dst[i + j]`, and store the new low part there.\n+                let (low, overflow) = low.overflowing_add(dst[i + j]);\n+                high += overflow as Limb;\n+\n+                dst[i + j] = low;\n+                carry = high;\n+            }\n+            dst[i + b.len()] = carry;\n+        }\n+\n+        // Assume the operands involved in the multiplication are single-precision\n+        // FP, and the two multiplicants are:\n+        //     a = a23 . a22 ... a0 * 2^e1\n+        //     b = b23 . b22 ... b0 * 2^e2\n+        // the result of multiplication is:\n+        //     dst = c48 c47 c46 . c45 ... c0 * 2^(e1+e2)\n+        // Note that there are three significant bits at the left-hand side of the\n+        // radix point: two for the multiplication, and an overflow bit for the\n+        // addition (that will always be zero at this point). Move the radix point\n+        // toward left by two bits, and adjust exponent accordingly.\n+        *exp += 2;\n+\n+        // Convert the result having \"2 * precision\" significant-bits back to the one\n+        // having \"precision\" significant-bits. First, move the radix point from\n+        // poision \"2*precision - 1\" to \"precision - 1\". The exponent need to be\n+        // adjusted by \"2*precision - 1\" - \"precision - 1\" = \"precision\".\n+        *exp -= precision as ExpInt + 1;\n+\n+        // In case MSB resides at the left-hand side of radix point, shift the\n+        // mantissa right by some amount to make sure the MSB reside right before\n+        // the radix point (i.e. \"MSB . rest-significant-bits\").\n+        //\n+        // Note that the result is not normalized when \"omsb < precision\". So, the\n+        // caller needs to call IeeeFloat::normalize() if normalized value is\n+        // expected.\n+        let omsb = omsb(dst);\n+        if omsb <= precision {\n+            Loss::ExactlyZero\n+        } else {\n+            shift_right(dst, exp, omsb - precision)\n+        }\n+    }\n+\n+    /// `quotient = dividend / divisor`. Returns the lost fraction.\n+    /// Does not preserve `dividend` or `divisor`.\n+    pub(super) fn div(\n+        quotient: &mut [Limb],\n+        exp: &mut ExpInt,\n+        dividend: &mut [Limb],\n+        divisor: &mut [Limb],\n+        precision: usize,\n+    ) -> Loss {\n+        // Zero the quotient before setting bits in it.\n+        for x in &mut quotient[..limbs_for_bits(precision)] {\n+            *x = 0;\n+        }\n+\n+        // Normalize the divisor.\n+        let bits = precision - omsb(divisor);\n+        shift_left(divisor, &mut 0, bits);\n+        *exp += bits as ExpInt;\n+\n+        // Normalize the dividend.\n+        let bits = precision - omsb(dividend);\n+        shift_left(dividend, exp, bits);\n+\n+        // Ensure the dividend >= divisor initially for the loop below.\n+        // Incidentally, this means that the division loop below is\n+        // guaranteed to set the integer bit to one.\n+        if cmp(dividend, divisor) == Ordering::Less {\n+            shift_left(dividend, exp, 1);\n+            assert_ne!(cmp(dividend, divisor), Ordering::Less)\n+        }\n+\n+        // Long division.\n+        for bit in (0..precision).rev() {\n+            if cmp(dividend, divisor) != Ordering::Less {\n+                sub(dividend, divisor, 0);\n+                set_bit(quotient, bit);\n+            }\n+            shift_left(dividend, &mut 0, 1);\n+        }\n+\n+        // Figure out the lost fraction.\n+        match cmp(dividend, divisor) {\n+            Ordering::Greater => Loss::MoreThanHalf,\n+            Ordering::Equal => Loss::ExactlyHalf,\n+            Ordering::Less => {\n+                if is_all_zeros(dividend) {\n+                    Loss::ExactlyZero\n+                } else {\n+                    Loss::LessThanHalf\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "d9dbf787856520f2d508c1fa870898f6f2093325", "filename": "src/librustc_apfloat/lib.rs", "status": "added", "additions": 693, "deletions": 0, "changes": 693, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,693 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Port of LLVM's APFloat software floating-point implementation from the\n+//! following C++ sources (please update commit hash when backporting):\n+//! https://github.com/llvm-mirror/llvm/tree/23efab2bbd424ed13495a420ad8641cb2c6c28f9\n+//! * `include/llvm/ADT/APFloat.h` -> `Float` and `FloatConvert` traits\n+//! * `lib/Support/APFloat.cpp` -> `ieee` and `ppc` modules\n+//! * `unittests/ADT/APFloatTest.cpp` -> `tests` directory\n+//!\n+//! The port contains no unsafe code, global state, or side-effects in general,\n+//! and the only allocations are in the conversion to/from decimal strings.\n+//!\n+//! Most of the API and the testcases are intact in some form or another,\n+//! with some ergonomic changes, such as idiomatic short names, returning\n+//! new values instead of mutating the receiver, and having separate method\n+//! variants that take a non-default rounding mode (with the suffix `_r`).\n+//! Comments have been preserved where possible, only slightly adapted.\n+//!\n+//! Instead of keeping a pointer to a configuration struct and inspecting it\n+//! dynamically on every operation, types (e.g. `ieee::Double`), traits\n+//! (e.g. `ieee::Semantics`) and associated constants are employed for\n+//! increased type safety and performance.\n+//!\n+//! On-heap bigints are replaced everywhere (except in decimal conversion),\n+//! with short arrays of `type Limb = u128` elements (instead of `u64`),\n+//! This allows fitting the largest supported significands in one integer\n+//! (`ieee::Quad` and `ppc::Fallback` use slightly less than 128 bits).\n+//! All of the functions in the `ieee::sig` module operate on slices.\n+//!\n+//! # Note\n+//!\n+//! This API is completely unstable and subject to change.\n+\n+#![crate_name = \"rustc_apfloat\"]\n+#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+      html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n+      html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![deny(warnings)]\n+#![forbid(unsafe_code)]\n+\n+#![feature(const_fn)]\n+#![feature(i128_type)]\n+#![feature(slice_patterns)]\n+#![feature(try_from)]\n+\n+#[macro_use]\n+extern crate rustc_bitflags;\n+\n+use std::cmp::Ordering;\n+use std::fmt;\n+use std::ops::{Neg, Add, Sub, Mul, Div, Rem};\n+use std::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign, BitOrAssign};\n+use std::str::FromStr;\n+\n+bitflags! {\n+    /// IEEE-754R 7: Default exception handling.\n+    ///\n+    /// UNDERFLOW or OVERFLOW are always returned or-ed with INEXACT.\n+    #[must_use]\n+    #[derive(Debug)]\n+    flags Status: u8 {\n+        const OK = 0x00,\n+        const INVALID_OP = 0x01,\n+        const DIV_BY_ZERO = 0x02,\n+        const OVERFLOW = 0x04,\n+        const UNDERFLOW = 0x08,\n+        const INEXACT = 0x10\n+    }\n+}\n+\n+impl BitOrAssign for Status {\n+    fn bitor_assign(&mut self, rhs: Self) {\n+        *self = *self | rhs;\n+    }\n+}\n+\n+#[must_use]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+pub struct StatusAnd<T> {\n+    pub status: Status,\n+    pub value: T,\n+}\n+\n+impl Status {\n+    pub fn and<T>(self, value: T) -> StatusAnd<T> {\n+        StatusAnd {\n+            status: self,\n+            value,\n+        }\n+    }\n+}\n+\n+impl<T> StatusAnd<T> {\n+    fn map<F: FnOnce(T) -> U, U>(self, f: F) -> StatusAnd<U> {\n+        StatusAnd {\n+            status: self.status,\n+            value: f(self.value),\n+        }\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! unpack {\n+    ($status:ident|=, $e:expr) => {\n+        match $e {\n+            $crate::StatusAnd { status, value } => {\n+                $status |= status;\n+                value\n+            }\n+        }\n+    };\n+    ($status:ident=, $e:expr) => {\n+        match $e {\n+            $crate::StatusAnd { status, value } => {\n+                $status = status;\n+                value\n+            }\n+        }\n+    }\n+}\n+\n+/// Category of internally-represented number.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Category {\n+    Infinity,\n+    NaN,\n+    Normal,\n+    Zero,\n+}\n+\n+/// IEEE-754R 4.3: Rounding-direction attributes.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum Round {\n+    NearestTiesToEven,\n+    TowardPositive,\n+    TowardNegative,\n+    TowardZero,\n+    NearestTiesToAway,\n+}\n+\n+impl Neg for Round {\n+    type Output = Round;\n+    fn neg(self) -> Round {\n+        match self {\n+            Round::TowardPositive => Round::TowardNegative,\n+            Round::TowardNegative => Round::TowardPositive,\n+            Round::NearestTiesToEven | Round::TowardZero | Round::NearestTiesToAway => self,\n+        }\n+    }\n+}\n+\n+/// A signed type to represent a floating point number's unbiased exponent.\n+pub type ExpInt = i16;\n+\n+// \\c ilogb error results.\n+pub const IEK_INF: ExpInt = ExpInt::max_value();\n+pub const IEK_NAN: ExpInt = ExpInt::min_value();\n+pub const IEK_ZERO: ExpInt = ExpInt::min_value() + 1;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct ParseError(pub &'static str);\n+\n+/// A self-contained host- and target-independent arbitrary-precision\n+/// floating-point software implementation.\n+///\n+/// `apfloat` uses significand bignum integer arithmetic as provided by functions\n+/// in the `ieee::sig`.\n+///\n+/// Written for clarity rather than speed, in particular with a view to use in\n+/// the front-end of a cross compiler so that target arithmetic can be correctly\n+/// performed on the host. Performance should nonetheless be reasonable,\n+/// particularly for its intended use. It may be useful as a base\n+/// implementation for a run-time library during development of a faster\n+/// target-specific one.\n+///\n+/// All 5 rounding modes in the IEEE-754R draft are handled correctly for all\n+/// implemented operations. Currently implemented operations are add, subtract,\n+/// multiply, divide, fused-multiply-add, conversion-to-float,\n+/// conversion-to-integer and conversion-from-integer. New rounding modes\n+/// (e.g. away from zero) can be added with three or four lines of code.\n+///\n+/// Four formats are built-in: IEEE single precision, double precision,\n+/// quadruple precision, and x87 80-bit extended double (when operating with\n+/// full extended precision). Adding a new format that obeys IEEE semantics\n+/// only requires adding two lines of code: a declaration and definition of the\n+/// format.\n+///\n+/// All operations return the status of that operation as an exception bit-mask,\n+/// so multiple operations can be done consecutively with their results or-ed\n+/// together. The returned status can be useful for compiler diagnostics; e.g.,\n+/// inexact, underflow and overflow can be easily diagnosed on constant folding,\n+/// and compiler optimizers can determine what exceptions would be raised by\n+/// folding operations and optimize, or perhaps not optimize, accordingly.\n+///\n+/// At present, underflow tininess is detected after rounding; it should be\n+/// straight forward to add support for the before-rounding case too.\n+///\n+/// The library reads hexadecimal floating point numbers as per C99, and\n+/// correctly rounds if necessary according to the specified rounding mode.\n+/// Syntax is required to have been validated by the caller.\n+///\n+/// It also reads decimal floating point numbers and correctly rounds according\n+/// to the specified rounding mode.\n+///\n+/// Non-zero finite numbers are represented internally as a sign bit, a 16-bit\n+/// signed exponent, and the significand as an array of integer limbs. After\n+/// normalization of a number of precision P the exponent is within the range of\n+/// the format, and if the number is not denormal the P-th bit of the\n+/// significand is set as an explicit integer bit. For denormals the most\n+/// significant bit is shifted right so that the exponent is maintained at the\n+/// format's minimum, so that the smallest denormal has just the least\n+/// significant bit of the significand set. The sign of zeros and infinities\n+/// is significant; the exponent and significand of such numbers is not stored,\n+/// but has a known implicit (deterministic) value: 0 for the significands, 0\n+/// for zero exponent, all 1 bits for infinity exponent. For NaNs the sign and\n+/// significand are deterministic, although not really meaningful, and preserved\n+/// in non-conversion operations. The exponent is implicitly all 1 bits.\n+///\n+/// `apfloat` does not provide any exception handling beyond default exception\n+/// handling. We represent Signaling NaNs via IEEE-754R 2008 6.2.1 should clause\n+/// by encoding Signaling NaNs with the first bit of its trailing significand as\n+/// 0.\n+///\n+/// Future work\n+/// ===========\n+///\n+/// Some features that may or may not be worth adding:\n+///\n+/// Optional ability to detect underflow tininess before rounding.\n+///\n+/// New formats: x87 in single and double precision mode (IEEE apart from\n+/// extended exponent range) (hard).\n+///\n+/// New operations: sqrt, nexttoward.\n+///\n+pub trait Float\n+    : Copy\n+    + Default\n+    + FromStr<Err = ParseError>\n+    + PartialOrd\n+    + fmt::Display\n+    + Neg<Output = Self>\n+    + AddAssign\n+    + SubAssign\n+    + MulAssign\n+    + DivAssign\n+    + RemAssign\n+    + Add<Output = StatusAnd<Self>>\n+    + Sub<Output = StatusAnd<Self>>\n+    + Mul<Output = StatusAnd<Self>>\n+    + Div<Output = StatusAnd<Self>>\n+    + Rem<Output = StatusAnd<Self>> {\n+    /// Total number of bits in the in-memory format.\n+    const BITS: usize;\n+\n+    /// Number of bits in the significand. This includes the integer bit.\n+    const PRECISION: usize;\n+\n+    /// The largest E such that 2^E is representable; this matches the\n+    /// definition of IEEE 754.\n+    const MAX_EXP: ExpInt;\n+\n+    /// The smallest E such that 2^E is a normalized number; this\n+    /// matches the definition of IEEE 754.\n+    const MIN_EXP: ExpInt;\n+\n+    /// Positive Zero.\n+    const ZERO: Self;\n+\n+    /// Positive Infinity.\n+    const INFINITY: Self;\n+\n+    /// NaN (Not a Number).\n+    // FIXME(eddyb) provide a default when qnan becomes const fn.\n+    const NAN: Self;\n+\n+    /// Factory for QNaN values.\n+    // FIXME(eddyb) should be const fn.\n+    fn qnan(payload: Option<u128>) -> Self;\n+\n+    /// Factory for SNaN values.\n+    // FIXME(eddyb) should be const fn.\n+    fn snan(payload: Option<u128>) -> Self;\n+\n+    /// Largest finite number.\n+    // FIXME(eddyb) should be const (but FloatPair::largest is nontrivial).\n+    fn largest() -> Self;\n+\n+    /// Smallest (by magnitude) finite number.\n+    /// Might be denormalized, which implies a relative loss of precision.\n+    const SMALLEST: Self;\n+\n+    /// Smallest (by magnitude) normalized finite number.\n+    // FIXME(eddyb) should be const (but FloatPair::smallest_normalized is nontrivial).\n+    fn smallest_normalized() -> Self;\n+\n+    // Arithmetic\n+\n+    fn add_r(self, rhs: Self, round: Round) -> StatusAnd<Self>;\n+    fn sub_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        self.add_r(-rhs, round)\n+    }\n+    fn mul_r(self, rhs: Self, round: Round) -> StatusAnd<Self>;\n+    fn mul_add_r(self, multiplicand: Self, addend: Self, round: Round) -> StatusAnd<Self>;\n+    fn mul_add(self, multiplicand: Self, addend: Self) -> StatusAnd<Self> {\n+        self.mul_add_r(multiplicand, addend, Round::NearestTiesToEven)\n+    }\n+    fn div_r(self, rhs: Self, round: Round) -> StatusAnd<Self>;\n+    /// IEEE remainder.\n+    // This is not currently correct in all cases.\n+    fn ieee_rem(self, rhs: Self) -> StatusAnd<Self> {\n+        let mut v = self;\n+\n+        let status;\n+        v = unpack!(status=, v / rhs);\n+        if status == Status::DIV_BY_ZERO {\n+            return status.and(self);\n+        }\n+\n+        assert!(Self::PRECISION < 128);\n+\n+        let status;\n+        let x = unpack!(status=, v.to_i128_r(128, Round::NearestTiesToEven, &mut false));\n+        if status == Status::INVALID_OP {\n+            return status.and(self);\n+        }\n+\n+        let status;\n+        let mut v = unpack!(status=, Self::from_i128(x));\n+        assert_eq!(status, Status::OK); // should always work\n+\n+        let status;\n+        v = unpack!(status=, v * rhs);\n+        assert_eq!(status - Status::INEXACT, Status::OK); // should not overflow or underflow\n+\n+        let status;\n+        v = unpack!(status=, self - v);\n+        assert_eq!(status - Status::INEXACT, Status::OK); // likewise\n+\n+        if v.is_zero() {\n+            status.and(v.copy_sign(self)) // IEEE754 requires this\n+        } else {\n+            status.and(v)\n+        }\n+    }\n+    /// C fmod, or llvm frem.\n+    fn c_fmod(self, rhs: Self) -> StatusAnd<Self>;\n+    fn round_to_integral(self, round: Round) -> StatusAnd<Self>;\n+\n+    /// IEEE-754R 2008 5.3.1: nextUp.\n+    fn next_up(self) -> StatusAnd<Self>;\n+\n+    /// IEEE-754R 2008 5.3.1: nextDown.\n+    ///\n+    /// *NOTE* since nextDown(x) = -nextUp(-x), we only implement nextUp with\n+    /// appropriate sign switching before/after the computation.\n+    fn next_down(self) -> StatusAnd<Self> {\n+        (-self).next_up().map(|r| -r)\n+    }\n+\n+    fn abs(self) -> Self {\n+        if self.is_negative() { -self } else { self }\n+    }\n+    fn copy_sign(self, rhs: Self) -> Self {\n+        if self.is_negative() != rhs.is_negative() {\n+            -self\n+        } else {\n+            self\n+        }\n+    }\n+\n+    // Conversions\n+    fn from_bits(input: u128) -> Self;\n+    fn from_i128_r(input: i128, round: Round) -> StatusAnd<Self> {\n+        if input < 0 {\n+            Self::from_u128_r(-input as u128, -round).map(|r| -r)\n+        } else {\n+            Self::from_u128_r(input as u128, round)\n+        }\n+    }\n+    fn from_i128(input: i128) -> StatusAnd<Self> {\n+        Self::from_i128_r(input, Round::NearestTiesToEven)\n+    }\n+    fn from_u128_r(input: u128, round: Round) -> StatusAnd<Self>;\n+    fn from_u128(input: u128) -> StatusAnd<Self> {\n+        Self::from_u128_r(input, Round::NearestTiesToEven)\n+    }\n+    fn from_str_r(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError>;\n+    fn to_bits(self) -> u128;\n+\n+    /// Convert a floating point number to an integer according to the\n+    /// rounding mode. In case of an invalid operation exception,\n+    /// deterministic values are returned, namely zero for NaNs and the\n+    /// minimal or maximal value respectively for underflow or overflow.\n+    /// If the rounded value is in range but the floating point number is\n+    /// not the exact integer, the C standard doesn't require an inexact\n+    /// exception to be raised. IEEE-854 does require it so we do that.\n+    ///\n+    /// Note that for conversions to integer type the C standard requires\n+    /// round-to-zero to always be used.\n+    ///\n+    /// The *is_exact output tells whether the result is exact, in the sense\n+    /// that converting it back to the original floating point type produces\n+    /// the original value. This is almost equivalent to result==Status::OK,\n+    /// except for negative zeroes.\n+    fn to_i128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<i128> {\n+        let status;\n+        if self.is_negative() {\n+            if self.is_zero() {\n+                // Negative zero can't be represented as an int.\n+                *is_exact = false;\n+            }\n+            let r = unpack!(status=, (-self).to_u128_r(width, -round, is_exact));\n+\n+            // Check for values that don't fit in the signed integer.\n+            if r > (1 << (width - 1)) {\n+                // Return the most negative integer for the given width.\n+                *is_exact = false;\n+                Status::INVALID_OP.and(-1 << (width - 1))\n+            } else {\n+                status.and(r.wrapping_neg() as i128)\n+            }\n+        } else {\n+            // Positive case is simpler, can pretend it's a smaller unsigned\n+            // integer, and `to_u128` will take care of all the edge cases.\n+            self.to_u128_r(width - 1, round, is_exact).map(\n+                |r| r as i128,\n+            )\n+        }\n+    }\n+    fn to_i128(self, width: usize) -> StatusAnd<i128> {\n+        self.to_i128_r(width, Round::TowardZero, &mut true)\n+    }\n+    fn to_u128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<u128>;\n+    fn to_u128(self, width: usize) -> StatusAnd<u128> {\n+        self.to_u128_r(width, Round::TowardZero, &mut true)\n+    }\n+\n+    fn cmp_abs_normal(self, rhs: Self) -> Ordering;\n+\n+    /// Bitwise comparison for equality (QNaNs compare equal, 0!=-0).\n+    fn bitwise_eq(self, rhs: Self) -> bool;\n+\n+    // IEEE-754R 5.7.2 General operations.\n+\n+    /// Implements IEEE minNum semantics. Returns the smaller of the 2 arguments if\n+    /// both are not NaN. If either argument is a NaN, returns the other argument.\n+    fn min(self, other: Self) -> Self {\n+        if self.is_nan() {\n+            other\n+        } else if other.is_nan() {\n+            self\n+        } else if other.partial_cmp(&self) == Some(Ordering::Less) {\n+            other\n+        } else {\n+            self\n+        }\n+    }\n+\n+    /// Implements IEEE maxNum semantics. Returns the larger of the 2 arguments if\n+    /// both are not NaN. If either argument is a NaN, returns the other argument.\n+    fn max(self, other: Self) -> Self {\n+        if self.is_nan() {\n+            other\n+        } else if other.is_nan() {\n+            self\n+        } else if self.partial_cmp(&other) == Some(Ordering::Less) {\n+            other\n+        } else {\n+            self\n+        }\n+    }\n+\n+    /// IEEE-754R isSignMinus: Returns true if and only if the current value is\n+    /// negative.\n+    ///\n+    /// This applies to zeros and NaNs as well.\n+    fn is_negative(self) -> bool;\n+\n+    /// IEEE-754R isNormal: Returns true if and only if the current value is normal.\n+    ///\n+    /// This implies that the current value of the float is not zero, subnormal,\n+    /// infinite, or NaN following the definition of normality from IEEE-754R.\n+    fn is_normal(self) -> bool {\n+        !self.is_denormal() && self.is_finite_non_zero()\n+    }\n+\n+    /// Returns true if and only if the current value is zero, subnormal, or\n+    /// normal.\n+    ///\n+    /// This means that the value is not infinite or NaN.\n+    fn is_finite(self) -> bool {\n+        !self.is_nan() && !self.is_infinite()\n+    }\n+\n+    /// Returns true if and only if the float is plus or minus zero.\n+    fn is_zero(self) -> bool {\n+        self.category() == Category::Zero\n+    }\n+\n+    /// IEEE-754R isSubnormal(): Returns true if and only if the float is a\n+    /// denormal.\n+    fn is_denormal(self) -> bool;\n+\n+    /// IEEE-754R isInfinite(): Returns true if and only if the float is infinity.\n+    fn is_infinite(self) -> bool {\n+        self.category() == Category::Infinity\n+    }\n+\n+    /// Returns true if and only if the float is a quiet or signaling NaN.\n+    fn is_nan(self) -> bool {\n+        self.category() == Category::NaN\n+    }\n+\n+    /// Returns true if and only if the float is a signaling NaN.\n+    fn is_signaling(self) -> bool;\n+\n+    // Simple Queries\n+\n+    fn category(self) -> Category;\n+    fn is_non_zero(self) -> bool {\n+        !self.is_zero()\n+    }\n+    fn is_finite_non_zero(self) -> bool {\n+        self.is_finite() && !self.is_zero()\n+    }\n+    fn is_pos_zero(self) -> bool {\n+        self.is_zero() && !self.is_negative()\n+    }\n+    fn is_neg_zero(self) -> bool {\n+        self.is_zero() && self.is_negative()\n+    }\n+\n+    /// Returns true if and only if the number has the smallest possible non-zero\n+    /// magnitude in the current semantics.\n+    fn is_smallest(self) -> bool {\n+        Self::SMALLEST.copy_sign(self).bitwise_eq(self)\n+    }\n+\n+    /// Returns true if and only if the number has the largest possible finite\n+    /// magnitude in the current semantics.\n+    fn is_largest(self) -> bool {\n+        Self::largest().copy_sign(self).bitwise_eq(self)\n+    }\n+\n+    /// Returns true if and only if the number is an exact integer.\n+    fn is_integer(self) -> bool {\n+        // This could be made more efficient; I'm going for obviously correct.\n+        if !self.is_finite() {\n+            return false;\n+        }\n+        self.round_to_integral(Round::TowardZero).value.bitwise_eq(\n+            self,\n+        )\n+    }\n+\n+    /// If this value has an exact multiplicative inverse, return it.\n+    fn get_exact_inverse(self) -> Option<Self>;\n+\n+    /// Returns the exponent of the internal representation of the Float.\n+    ///\n+    /// Because the radix of Float is 2, this is equivalent to floor(log2(x)).\n+    /// For special Float values, this returns special error codes:\n+    ///\n+    ///   NaN -> \\c IEK_NAN\n+    ///   0   -> \\c IEK_ZERO\n+    ///   Inf -> \\c IEK_INF\n+    ///\n+    fn ilogb(self) -> ExpInt;\n+\n+    /// Returns: self * 2^exp for integral exponents.\n+    fn scalbn_r(self, exp: ExpInt, round: Round) -> Self;\n+    fn scalbn(self, exp: ExpInt) -> Self {\n+        self.scalbn_r(exp, Round::NearestTiesToEven)\n+    }\n+\n+    /// Equivalent of C standard library function.\n+    ///\n+    /// While the C standard says exp is an unspecified value for infinity and nan,\n+    /// this returns INT_MAX for infinities, and INT_MIN for NaNs (see `ilogb`).\n+    fn frexp_r(self, exp: &mut ExpInt, round: Round) -> Self;\n+    fn frexp(self, exp: &mut ExpInt) -> Self {\n+        self.frexp_r(exp, Round::NearestTiesToEven)\n+    }\n+}\n+\n+pub trait FloatConvert<T: Float>: Float {\n+    /// Convert a value of one floating point type to another.\n+    /// The return value corresponds to the IEEE754 exceptions. *loses_info\n+    /// records whether the transformation lost information, i.e. whether\n+    /// converting the result back to the original type will produce the\n+    /// original value (this is almost the same as return value==Status::OK,\n+    /// but there are edge cases where this is not so).\n+    fn convert_r(self, round: Round, loses_info: &mut bool) -> StatusAnd<T>;\n+    fn convert(self, loses_info: &mut bool) -> StatusAnd<T> {\n+        self.convert_r(Round::NearestTiesToEven, loses_info)\n+    }\n+}\n+\n+macro_rules! float_common_impls {\n+    ($ty:ident<$t:tt>) => {\n+        impl<$t> Default for $ty<$t> where Self: Float {\n+            fn default() -> Self {\n+                Self::ZERO\n+            }\n+        }\n+\n+        impl<$t> ::std::str::FromStr for $ty<$t> where Self: Float {\n+            type Err = ParseError;\n+            fn from_str(s: &str) -> Result<Self, ParseError> {\n+                Self::from_str_r(s, Round::NearestTiesToEven).map(|x| x.value)\n+            }\n+        }\n+\n+        // Rounding ties to the nearest even, by default.\n+\n+        impl<$t> ::std::ops::Add for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn add(self, rhs: Self) -> StatusAnd<Self> {\n+                self.add_r(rhs, Round::NearestTiesToEven)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::Sub for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn sub(self, rhs: Self) -> StatusAnd<Self> {\n+                self.sub_r(rhs, Round::NearestTiesToEven)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::Mul for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn mul(self, rhs: Self) -> StatusAnd<Self> {\n+                self.mul_r(rhs, Round::NearestTiesToEven)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::Div for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn div(self, rhs: Self) -> StatusAnd<Self> {\n+                self.div_r(rhs, Round::NearestTiesToEven)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::Rem for $ty<$t> where Self: Float {\n+            type Output = StatusAnd<Self>;\n+            fn rem(self, rhs: Self) -> StatusAnd<Self> {\n+                self.c_fmod(rhs)\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::AddAssign for $ty<$t> where Self: Float {\n+            fn add_assign(&mut self, rhs: Self) {\n+                *self = (*self + rhs).value;\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::SubAssign for $ty<$t> where Self: Float {\n+            fn sub_assign(&mut self, rhs: Self) {\n+                *self = (*self - rhs).value;\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::MulAssign for $ty<$t> where Self: Float {\n+            fn mul_assign(&mut self, rhs: Self) {\n+                *self = (*self * rhs).value;\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::DivAssign for $ty<$t> where Self: Float {\n+            fn div_assign(&mut self, rhs: Self) {\n+                *self = (*self / rhs).value;\n+            }\n+        }\n+\n+        impl<$t> ::std::ops::RemAssign for $ty<$t> where Self: Float {\n+            fn rem_assign(&mut self, rhs: Self) {\n+                *self = (*self % rhs).value;\n+            }\n+        }\n+    }\n+}\n+\n+pub mod ieee;\n+pub mod ppc;"}, {"sha": "dec88eb62cc60ef94eecf6a5517544c35951dd08", "filename": "src/librustc_apfloat/ppc.rs", "status": "added", "additions": 461, "deletions": 0, "changes": 461, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_apfloat%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_apfloat%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fppc.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,461 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {Category, ExpInt, Float, FloatConvert, Round, ParseError, Status, StatusAnd};\n+use ieee;\n+\n+use std::cmp::Ordering;\n+use std::fmt;\n+use std::ops::Neg;\n+\n+#[must_use]\n+#[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]\n+pub struct DoubleFloat<F>(F, F);\n+pub type DoubleDouble = DoubleFloat<ieee::Double>;\n+\n+// These are legacy semantics for the Fallback, inaccrurate implementation of\n+// IBM double-double, if the accurate DoubleDouble doesn't handle the\n+// operation. It's equivalent to having an IEEE number with consecutive 106\n+// bits of mantissa and 11 bits of exponent.\n+//\n+// It's not equivalent to IBM double-double. For example, a legit IBM\n+// double-double, 1 + epsilon:\n+//\n+//   1 + epsilon = 1 + (1 >> 1076)\n+//\n+// is not representable by a consecutive 106 bits of mantissa.\n+//\n+// Currently, these semantics are used in the following way:\n+//\n+//   DoubleDouble -> (Double, Double) ->\n+//   DoubleDouble's Fallback -> IEEE operations\n+//\n+// FIXME: Implement all operations in DoubleDouble, and delete these\n+// semantics.\n+// FIXME(eddyb) This shouldn't need to be `pub`, it's only used in bounds.\n+pub struct FallbackS<F>(F);\n+type Fallback<F> = ieee::IeeeFloat<FallbackS<F>>;\n+impl<F: Float> ieee::Semantics for FallbackS<F> {\n+    // Forbid any conversion to/from bits.\n+    const BITS: usize = 0;\n+    const PRECISION: usize = F::PRECISION * 2;\n+    const MAX_EXP: ExpInt = F::MAX_EXP as ExpInt;\n+    const MIN_EXP: ExpInt = F::MIN_EXP as ExpInt + F::PRECISION as ExpInt;\n+}\n+\n+// Convert number to F. To avoid spurious underflows, we re-\n+// normalize against the F exponent range first, and only *then*\n+// truncate the mantissa. The result of that second conversion\n+// may be inexact, but should never underflow.\n+// FIXME(eddyb) This shouldn't need to be `pub`, it's only used in bounds.\n+pub struct FallbackExtendedS<F>(F);\n+type FallbackExtended<F> = ieee::IeeeFloat<FallbackExtendedS<F>>;\n+impl<F: Float> ieee::Semantics for FallbackExtendedS<F> {\n+    // Forbid any conversion to/from bits.\n+    const BITS: usize = 0;\n+    const PRECISION: usize = Fallback::<F>::PRECISION;\n+    const MAX_EXP: ExpInt = F::MAX_EXP as ExpInt;\n+}\n+\n+impl<F: Float> From<Fallback<F>> for DoubleFloat<F>\n+where\n+    F: FloatConvert<FallbackExtended<F>>,\n+    FallbackExtended<F>: FloatConvert<F>,\n+{\n+    fn from(x: Fallback<F>) -> Self {\n+        let mut status;\n+        let mut loses_info = false;\n+\n+        let extended: FallbackExtended<F> = unpack!(status=, x.convert(&mut loses_info));\n+        assert_eq!((status, loses_info), (Status::OK, false));\n+\n+        let a = unpack!(status=, extended.convert(&mut loses_info));\n+        assert_eq!(status - Status::INEXACT, Status::OK);\n+\n+        // If conversion was exact or resulted in a special case, we're done;\n+        // just set the second double to zero. Otherwise, re-convert back to\n+        // the extended format and compute the difference. This now should\n+        // convert exactly to double.\n+        let b = if a.is_finite_non_zero() && loses_info {\n+            let u: FallbackExtended<F> = unpack!(status=, a.convert(&mut loses_info));\n+            assert_eq!((status, loses_info), (Status::OK, false));\n+            let v = unpack!(status=, extended - u);\n+            assert_eq!(status, Status::OK);\n+            let v = unpack!(status=, v.convert(&mut loses_info));\n+            assert_eq!((status, loses_info), (Status::OK, false));\n+            v\n+        } else {\n+            F::ZERO\n+        };\n+\n+        DoubleFloat(a, b)\n+    }\n+}\n+\n+impl<F: FloatConvert<Self>> From<DoubleFloat<F>> for Fallback<F> {\n+    fn from(DoubleFloat(a, b): DoubleFloat<F>) -> Self {\n+        let mut status;\n+        let mut loses_info = false;\n+\n+        // Get the first F and convert to our format.\n+        let a = unpack!(status=, a.convert(&mut loses_info));\n+        assert_eq!((status, loses_info), (Status::OK, false));\n+\n+        // Unless we have a special case, add in second F.\n+        if a.is_finite_non_zero() {\n+            let b = unpack!(status=, b.convert(&mut loses_info));\n+            assert_eq!((status, loses_info), (Status::OK, false));\n+\n+            (a + b).value\n+        } else {\n+            a\n+        }\n+    }\n+}\n+\n+float_common_impls!(DoubleFloat<F>);\n+\n+impl<F: Float> Neg for DoubleFloat<F> {\n+    type Output = Self;\n+    fn neg(self) -> Self {\n+        if self.1.is_finite_non_zero() {\n+            DoubleFloat(-self.0, -self.1)\n+        } else {\n+            DoubleFloat(-self.0, self.1)\n+        }\n+    }\n+}\n+\n+impl<F: FloatConvert<Fallback<F>>> fmt::Display for DoubleFloat<F> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&Fallback::from(*self), f)\n+    }\n+}\n+\n+impl<F: FloatConvert<Fallback<F>>> Float for DoubleFloat<F>\n+where\n+    Self: From<Fallback<F>>,\n+{\n+    const BITS: usize = F::BITS * 2;\n+    const PRECISION: usize = Fallback::<F>::PRECISION;\n+    const MAX_EXP: ExpInt = Fallback::<F>::MAX_EXP;\n+    const MIN_EXP: ExpInt = Fallback::<F>::MIN_EXP;\n+\n+    const ZERO: Self = DoubleFloat(F::ZERO, F::ZERO);\n+\n+    const INFINITY: Self = DoubleFloat(F::INFINITY, F::ZERO);\n+\n+    // FIXME(eddyb) remove when qnan becomes const fn.\n+    const NAN: Self = DoubleFloat(F::NAN, F::ZERO);\n+\n+    fn qnan(payload: Option<u128>) -> Self {\n+        DoubleFloat(F::qnan(payload), F::ZERO)\n+    }\n+\n+    fn snan(payload: Option<u128>) -> Self {\n+        DoubleFloat(F::snan(payload), F::ZERO)\n+    }\n+\n+    fn largest() -> Self {\n+        let status;\n+        let mut r = DoubleFloat(F::largest(), F::largest());\n+        r.1 = r.1.scalbn(-(F::PRECISION as ExpInt + 1));\n+        r.1 = unpack!(status=, r.1.next_down());\n+        assert_eq!(status, Status::OK);\n+        r\n+    }\n+\n+    const SMALLEST: Self = DoubleFloat(F::SMALLEST, F::ZERO);\n+\n+    fn smallest_normalized() -> Self {\n+        DoubleFloat(\n+            F::smallest_normalized().scalbn(F::PRECISION as ExpInt),\n+            F::ZERO,\n+        )\n+    }\n+\n+    // Implement addition, subtraction, multiplication and division based on:\n+    // \"Software for Doubled-Precision Floating-Point Computations\",\n+    // by Seppo Linnainmaa, ACM TOMS vol 7 no 3, September 1981, pages 272-283.\n+\n+    fn add_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        match (self.category(), rhs.category()) {\n+            (Category::Infinity, Category::Infinity) => {\n+                if self.is_negative() != rhs.is_negative() {\n+                    Status::INVALID_OP.and(Self::NAN.copy_sign(self))\n+                } else {\n+                    Status::OK.and(self)\n+                }\n+            }\n+\n+            (_, Category::Zero) |\n+            (Category::NaN, _) |\n+            (Category::Infinity, Category::Normal) => Status::OK.and(self),\n+\n+            (Category::Zero, _) |\n+            (_, Category::NaN) |\n+            (_, Category::Infinity) => Status::OK.and(rhs),\n+\n+            (Category::Normal, Category::Normal) => {\n+                let mut status = Status::OK;\n+                let (a, aa, c, cc) = (self.0, self.1, rhs.0, rhs.1);\n+                let mut z = a;\n+                z = unpack!(status|=, z.add_r(c, round));\n+                if !z.is_finite() {\n+                    if !z.is_infinite() {\n+                        return status.and(DoubleFloat(z, F::ZERO));\n+                    }\n+                    status = Status::OK;\n+                    let a_cmp_c = a.cmp_abs_normal(c);\n+                    z = cc;\n+                    z = unpack!(status|=, z.add_r(aa, round));\n+                    if a_cmp_c == Ordering::Greater {\n+                        // z = cc + aa + c + a;\n+                        z = unpack!(status|=, z.add_r(c, round));\n+                        z = unpack!(status|=, z.add_r(a, round));\n+                    } else {\n+                        // z = cc + aa + a + c;\n+                        z = unpack!(status|=, z.add_r(a, round));\n+                        z = unpack!(status|=, z.add_r(c, round));\n+                    }\n+                    if !z.is_finite() {\n+                        return status.and(DoubleFloat(z, F::ZERO));\n+                    }\n+                    self.0 = z;\n+                    let mut zz = aa;\n+                    zz = unpack!(status|=, zz.add_r(cc, round));\n+                    if a_cmp_c == Ordering::Greater {\n+                        // self.1 = a - z + c + zz;\n+                        self.1 = a;\n+                        self.1 = unpack!(status|=, self.1.sub_r(z, round));\n+                        self.1 = unpack!(status|=, self.1.add_r(c, round));\n+                        self.1 = unpack!(status|=, self.1.add_r(zz, round));\n+                    } else {\n+                        // self.1 = c - z + a + zz;\n+                        self.1 = c;\n+                        self.1 = unpack!(status|=, self.1.sub_r(z, round));\n+                        self.1 = unpack!(status|=, self.1.add_r(a, round));\n+                        self.1 = unpack!(status|=, self.1.add_r(zz, round));\n+                    }\n+                } else {\n+                    // q = a - z;\n+                    let mut q = a;\n+                    q = unpack!(status|=, q.sub_r(z, round));\n+\n+                    // zz = q + c + (a - (q + z)) + aa + cc;\n+                    // Compute a - (q + z) as -((q + z) - a) to avoid temporary copies.\n+                    let mut zz = q;\n+                    zz = unpack!(status|=, zz.add_r(c, round));\n+                    q = unpack!(status|=, q.add_r(z, round));\n+                    q = unpack!(status|=, q.sub_r(a, round));\n+                    q = -q;\n+                    zz = unpack!(status|=, zz.add_r(q, round));\n+                    zz = unpack!(status|=, zz.add_r(aa, round));\n+                    zz = unpack!(status|=, zz.add_r(cc, round));\n+                    if zz.is_zero() && !zz.is_negative() {\n+                        return Status::OK.and(DoubleFloat(z, F::ZERO));\n+                    }\n+                    self.0 = z;\n+                    self.0 = unpack!(status|=, self.0.add_r(zz, round));\n+                    if !self.0.is_finite() {\n+                        self.1 = F::ZERO;\n+                        return status.and(self);\n+                    }\n+                    self.1 = z;\n+                    self.1 = unpack!(status|=, self.1.sub_r(self.0, round));\n+                    self.1 = unpack!(status|=, self.1.add_r(zz, round));\n+                }\n+                status.and(self)\n+            }\n+        }\n+    }\n+\n+    fn mul_r(mut self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        // Interesting observation: For special categories, finding the lowest\n+        // common ancestor of the following layered graph gives the correct\n+        // return category:\n+        //\n+        //    NaN\n+        //   /   \\\n+        // Zero  Inf\n+        //   \\   /\n+        //   Normal\n+        //\n+        // e.g. NaN * NaN = NaN\n+        //      Zero * Inf = NaN\n+        //      Normal * Zero = Zero\n+        //      Normal * Inf = Inf\n+        match (self.category(), rhs.category()) {\n+            (Category::NaN, _) => Status::OK.and(self),\n+\n+            (_, Category::NaN) => Status::OK.and(rhs),\n+\n+            (Category::Zero, Category::Infinity) |\n+            (Category::Infinity, Category::Zero) => Status::OK.and(Self::NAN),\n+\n+            (Category::Zero, _) |\n+            (Category::Infinity, _) => Status::OK.and(self),\n+\n+            (_, Category::Zero) |\n+            (_, Category::Infinity) => Status::OK.and(rhs),\n+\n+            (Category::Normal, Category::Normal) => {\n+                let mut status = Status::OK;\n+                let (a, b, c, d) = (self.0, self.1, rhs.0, rhs.1);\n+                // t = a * c\n+                let mut t = a;\n+                t = unpack!(status|=, t.mul_r(c, round));\n+                if !t.is_finite_non_zero() {\n+                    return status.and(DoubleFloat(t, F::ZERO));\n+                }\n+\n+                // tau = fmsub(a, c, t), that is -fmadd(-a, c, t).\n+                let mut tau = a;\n+                tau = unpack!(status|=, tau.mul_add_r(c, -t, round));\n+                // v = a * d\n+                let mut v = a;\n+                v = unpack!(status|=, v.mul_r(d, round));\n+                // w = b * c\n+                let mut w = b;\n+                w = unpack!(status|=, w.mul_r(c, round));\n+                v = unpack!(status|=, v.add_r(w, round));\n+                // tau += v + w\n+                tau = unpack!(status|=, tau.add_r(v, round));\n+                // u = t + tau\n+                let mut u = t;\n+                u = unpack!(status|=, u.add_r(tau, round));\n+\n+                self.0 = u;\n+                if !u.is_finite() {\n+                    self.1 = F::ZERO;\n+                } else {\n+                    // self.1 = (t - u) + tau\n+                    t = unpack!(status|=, t.sub_r(u, round));\n+                    t = unpack!(status|=, t.add_r(tau, round));\n+                    self.1 = t;\n+                }\n+                status.and(self)\n+            }\n+        }\n+    }\n+\n+    fn mul_add_r(self, multiplicand: Self, addend: Self, round: Round) -> StatusAnd<Self> {\n+        Fallback::from(self)\n+            .mul_add_r(Fallback::from(multiplicand), Fallback::from(addend), round)\n+            .map(Self::from)\n+    }\n+\n+    fn div_r(self, rhs: Self, round: Round) -> StatusAnd<Self> {\n+        Fallback::from(self).div_r(Fallback::from(rhs), round).map(\n+            Self::from,\n+        )\n+    }\n+\n+    fn c_fmod(self, rhs: Self) -> StatusAnd<Self> {\n+        Fallback::from(self).c_fmod(Fallback::from(rhs)).map(\n+            Self::from,\n+        )\n+    }\n+\n+    fn round_to_integral(self, round: Round) -> StatusAnd<Self> {\n+        Fallback::from(self).round_to_integral(round).map(\n+            Self::from,\n+        )\n+    }\n+\n+    fn next_up(self) -> StatusAnd<Self> {\n+        Fallback::from(self).next_up().map(Self::from)\n+    }\n+\n+    fn from_bits(input: u128) -> Self {\n+        let (a, b) = (input, input >> F::BITS);\n+        DoubleFloat(\n+            F::from_bits(a & ((1 << F::BITS) - 1)),\n+            F::from_bits(b & ((1 << F::BITS) - 1)),\n+        )\n+    }\n+\n+    fn from_u128_r(input: u128, round: Round) -> StatusAnd<Self> {\n+        Fallback::from_u128_r(input, round).map(Self::from)\n+    }\n+\n+    fn from_str_r(s: &str, round: Round) -> Result<StatusAnd<Self>, ParseError> {\n+        Fallback::from_str_r(s, round).map(|r| r.map(Self::from))\n+    }\n+\n+    fn to_bits(self) -> u128 {\n+        self.0.to_bits() | (self.1.to_bits() << F::BITS)\n+    }\n+\n+    fn to_u128_r(self, width: usize, round: Round, is_exact: &mut bool) -> StatusAnd<u128> {\n+        Fallback::from(self).to_u128_r(width, round, is_exact)\n+    }\n+\n+    fn cmp_abs_normal(self, rhs: Self) -> Ordering {\n+        self.0.cmp_abs_normal(rhs.0).then_with(|| {\n+            let result = self.1.cmp_abs_normal(rhs.1);\n+            if result != Ordering::Equal {\n+                let against = self.0.is_negative() ^ self.1.is_negative();\n+                let rhs_against = rhs.0.is_negative() ^ rhs.1.is_negative();\n+                (!against).cmp(&!rhs_against).then_with(|| if against {\n+                    result.reverse()\n+                } else {\n+                    result\n+                })\n+            } else {\n+                result\n+            }\n+        })\n+    }\n+\n+    fn bitwise_eq(self, rhs: Self) -> bool {\n+        self.0.bitwise_eq(rhs.0) && self.1.bitwise_eq(rhs.1)\n+    }\n+\n+    fn is_negative(self) -> bool {\n+        self.0.is_negative()\n+    }\n+\n+    fn is_denormal(self) -> bool {\n+        self.category() == Category::Normal &&\n+            (self.0.is_denormal() || self.0.is_denormal() ||\n+          // (double)(Hi + Lo) == Hi defines a normal number.\n+          !(self.0 + self.1).value.bitwise_eq(self.0))\n+    }\n+\n+    fn is_signaling(self) -> bool {\n+        self.0.is_signaling()\n+    }\n+\n+    fn category(self) -> Category {\n+        self.0.category()\n+    }\n+\n+    fn get_exact_inverse(self) -> Option<Self> {\n+        Fallback::from(self).get_exact_inverse().map(Self::from)\n+    }\n+\n+    fn ilogb(self) -> ExpInt {\n+        self.0.ilogb()\n+    }\n+\n+    fn scalbn_r(self, exp: ExpInt, round: Round) -> Self {\n+        DoubleFloat(self.0.scalbn_r(exp, round), self.1.scalbn_r(exp, round))\n+    }\n+\n+    fn frexp_r(self, exp: &mut ExpInt, round: Round) -> Self {\n+        let a = self.0.frexp_r(exp, round);\n+        let mut b = self.1;\n+        if self.category() == Category::Normal {\n+            b = b.scalbn_r(-*exp, round);\n+        }\n+        DoubleFloat(a, b)\n+    }\n+}"}, {"sha": "aff2076e038332ce77104c44fc8e048663627b14", "filename": "src/librustc_apfloat/tests/ieee.rs", "status": "added", "additions": 6891, "deletions": 0, "changes": 6891, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Ftests%2Fieee.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5"}, {"sha": "145c3ddc869dfc17c5307720a56fa6db4cbc07ab", "filename": "src/librustc_apfloat/tests/ppc.rs", "status": "added", "additions": 655, "deletions": 0, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_apfloat%2Ftests%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_apfloat%2Ftests%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Ftests%2Fppc.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,655 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate rustc_apfloat;\n+\n+use rustc_apfloat::{Category, Float, Round};\n+use rustc_apfloat::ppc::DoubleDouble;\n+\n+use std::cmp::Ordering;\n+\n+#[test]\n+fn ppc_double_double() {\n+    let test = DoubleDouble::ZERO;\n+    let expected = \"0x0p+0\".parse::<DoubleDouble>().unwrap();\n+    assert!(test.is_zero());\n+    assert!(!test.is_negative());\n+    assert!(test.bitwise_eq(expected));\n+    assert_eq!(0, test.to_bits());\n+\n+    let test = -DoubleDouble::ZERO;\n+    let expected = \"-0x0p+0\".parse::<DoubleDouble>().unwrap();\n+    assert!(test.is_zero());\n+    assert!(test.is_negative());\n+    assert!(test.bitwise_eq(expected));\n+    assert_eq!(0x8000000000000000, test.to_bits());\n+\n+    let test = \"1.0\".parse::<DoubleDouble>().unwrap();\n+    assert_eq!(0x3ff0000000000000, test.to_bits());\n+\n+    // LDBL_MAX\n+    let test = \"1.79769313486231580793728971405301e+308\"\n+        .parse::<DoubleDouble>()\n+        .unwrap();\n+    assert_eq!(0x7c8ffffffffffffe_7fefffffffffffff, test.to_bits());\n+\n+    // LDBL_MIN\n+    let test = \"2.00416836000897277799610805135016e-292\"\n+        .parse::<DoubleDouble>()\n+        .unwrap();\n+    assert_eq!(0x0000000000000000_0360000000000000, test.to_bits());\n+}\n+\n+#[test]\n+fn ppc_double_double_add_special() {\n+    let data = [\n+        // (1 + 0) + (-1 + 0) = Category::Zero\n+        (\n+            0x3ff0000000000000,\n+            0xbff0000000000000,\n+            Category::Zero,\n+            Round::NearestTiesToEven,\n+        ),\n+        // LDBL_MAX + (1.1 >> (1023 - 106) + 0)) = Category::Infinity\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x7948000000000000,\n+            Category::Infinity,\n+            Round::NearestTiesToEven,\n+        ),\n+        // FIXME: change the 4th 0x75effffffffffffe to 0x75efffffffffffff when\n+        // DoubleDouble's fallback is gone.\n+        // LDBL_MAX + (1.011111... >> (1023 - 106) + (1.1111111...0 >> (1023 -\n+        // 160))) = Category::Normal\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x75effffffffffffe_7947ffffffffffff,\n+            Category::Normal,\n+            Round::NearestTiesToEven,\n+        ),\n+        // LDBL_MAX + (1.1 >> (1023 - 106) + 0)) = Category::Infinity\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            Category::Infinity,\n+            Round::NearestTiesToEven,\n+        ),\n+        // NaN + (1 + 0) = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0x3ff0000000000000,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        {\n+            let mut a1 = DoubleDouble::from_bits(op1);\n+            let a2 = DoubleDouble::from_bits(op2);\n+            a1 = a1.add_r(a2, round).value;\n+\n+            assert_eq!(expected, a1.category(), \"{:#x} + {:#x}\", op1, op2);\n+        }\n+        {\n+            let a1 = DoubleDouble::from_bits(op1);\n+            let mut a2 = DoubleDouble::from_bits(op2);\n+            a2 = a2.add_r(a1, round).value;\n+\n+            assert_eq!(expected, a2.category(), \"{:#x} + {:#x}\", op2, op1);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_add() {\n+    let data = [\n+        // (1 + 0) + (1e-105 + 0) = (1 + 1e-105)\n+        (\n+            0x3ff0000000000000,\n+            0x3960000000000000,\n+            0x3960000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + 0) + (1e-106 + 0) = (1 + 1e-106)\n+        (\n+            0x3ff0000000000000,\n+            0x3950000000000000,\n+            0x3950000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + 1e-106) + (1e-106 + 0) = (1 + 1e-105)\n+        (\n+            0x3950000000000000_3ff0000000000000,\n+            0x3950000000000000,\n+            0x3960000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + 0) + (epsilon + 0) = (1 + epsilon)\n+        (\n+            0x3ff0000000000000,\n+            0x0000000000000001,\n+            0x0000000000000001_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // FIXME: change 0xf950000000000000 to 0xf940000000000000, when\n+        // DoubleDouble's fallback is gone.\n+        // (DBL_MAX - 1 << (1023 - 105)) + (1 << (1023 - 53) + 0) = DBL_MAX +\n+        // 1.11111... << (1023 - 52)\n+        (\n+            0xf950000000000000_7fefffffffffffff,\n+            0x7c90000000000000,\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            Round::NearestTiesToEven,\n+        ),\n+        // FIXME: change 0xf950000000000000 to 0xf940000000000000, when\n+        // DoubleDouble's fallback is gone.\n+        // (1 << (1023 - 53) + 0) + (DBL_MAX - 1 << (1023 - 105)) = DBL_MAX +\n+        // 1.11111... << (1023 - 52)\n+        (\n+            0x7c90000000000000,\n+            0xf950000000000000_7fefffffffffffff,\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        {\n+            let mut a1 = DoubleDouble::from_bits(op1);\n+            let a2 = DoubleDouble::from_bits(op2);\n+            a1 = a1.add_r(a2, round).value;\n+\n+            assert_eq!(expected, a1.to_bits(), \"{:#x} + {:#x}\", op1, op2);\n+        }\n+        {\n+            let a1 = DoubleDouble::from_bits(op1);\n+            let mut a2 = DoubleDouble::from_bits(op2);\n+            a2 = a2.add_r(a1, round).value;\n+\n+            assert_eq!(expected, a2.to_bits(), \"{:#x} + {:#x}\", op2, op1);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_subtract() {\n+    let data = [\n+        // (1 + 0) - (-1e-105 + 0) = (1 + 1e-105)\n+        (\n+            0x3ff0000000000000,\n+            0xb960000000000000,\n+            0x3960000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + 0) - (-1e-106 + 0) = (1 + 1e-106)\n+        (\n+            0x3ff0000000000000,\n+            0xb950000000000000,\n+            0x3950000000000000_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        let mut a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        a1 = a1.sub_r(a2, round).value;\n+\n+        assert_eq!(expected, a1.to_bits(), \"{:#x} - {:#x}\", op1, op2);\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_multiply_special() {\n+    let data = [\n+        // Category::NaN * Category::NaN = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0x7ff8000000000000,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::NaN * Category::Zero = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::NaN * Category::Infinity = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0x7ff0000000000000,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::NaN * Category::Normal = Category::NaN\n+        (\n+            0x7ff8000000000000,\n+            0x3ff0000000000000,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::Infinity * Category::Infinity = Category::Infinity\n+        (\n+            0x7ff0000000000000,\n+            0x7ff0000000000000,\n+            Category::Infinity,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::Infinity * Category::Zero = Category::NaN\n+        (\n+            0x7ff0000000000000,\n+            0,\n+            Category::NaN,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::Infinity * Category::Normal = Category::Infinity\n+        (\n+            0x7ff0000000000000,\n+            0x3ff0000000000000,\n+            Category::Infinity,\n+            Round::NearestTiesToEven,\n+        ),\n+        // Category::Zero * Category::Zero = Category::Zero\n+        (0, 0, Category::Zero, Round::NearestTiesToEven),\n+        // Category::Zero * Category::Normal = Category::Zero\n+        (\n+            0,\n+            0x3ff0000000000000,\n+            Category::Zero,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        {\n+            let mut a1 = DoubleDouble::from_bits(op1);\n+            let a2 = DoubleDouble::from_bits(op2);\n+            a1 = a1.mul_r(a2, round).value;\n+\n+            assert_eq!(expected, a1.category(), \"{:#x} * {:#x}\", op1, op2);\n+        }\n+        {\n+            let a1 = DoubleDouble::from_bits(op1);\n+            let mut a2 = DoubleDouble::from_bits(op2);\n+            a2 = a2.mul_r(a1, round).value;\n+\n+            assert_eq!(expected, a2.category(), \"{:#x} * {:#x}\", op2, op1);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_multiply() {\n+    let data = [\n+        // 1/3 * 3 = 1.0\n+        (\n+            0x3c75555555555556_3fd5555555555555,\n+            0x4008000000000000,\n+            0x3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + epsilon) * (1 + 0) = Category::Zero\n+        (\n+            0x0000000000000001_3ff0000000000000,\n+            0x3ff0000000000000,\n+            0x0000000000000001_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (1 + epsilon) * (1 + epsilon) = 1 + 2 * epsilon\n+        (\n+            0x0000000000000001_3ff0000000000000,\n+            0x0000000000000001_3ff0000000000000,\n+            0x0000000000000002_3ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // -(1 + epsilon) * (1 + epsilon) = -1\n+        (\n+            0x0000000000000001_bff0000000000000,\n+            0x0000000000000001_3ff0000000000000,\n+            0xbff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (0.5 + 0) * (1 + 2 * epsilon) = 0.5 + epsilon\n+        (\n+            0x3fe0000000000000,\n+            0x0000000000000002_3ff0000000000000,\n+            0x0000000000000001_3fe0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // (0.5 + 0) * (1 + epsilon) = 0.5\n+        (\n+            0x3fe0000000000000,\n+            0x0000000000000001_3ff0000000000000,\n+            0x3fe0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // __LDBL_MAX__ * (1 + 1 << 106) = inf\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x3950000000000000_3ff0000000000000,\n+            0x7ff0000000000000,\n+            Round::NearestTiesToEven,\n+        ),\n+        // __LDBL_MAX__ * (1 + 1 << 107) > __LDBL_MAX__, but not inf, yes =_=|||\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x3940000000000000_3ff0000000000000,\n+            0x7c8fffffffffffff_7fefffffffffffff,\n+            Round::NearestTiesToEven,\n+        ),\n+        // __LDBL_MAX__ * (1 + 1 << 108) = __LDBL_MAX__\n+        (\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            0x3930000000000000_3ff0000000000000,\n+            0x7c8ffffffffffffe_7fefffffffffffff,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        {\n+            let mut a1 = DoubleDouble::from_bits(op1);\n+            let a2 = DoubleDouble::from_bits(op2);\n+            a1 = a1.mul_r(a2, round).value;\n+\n+            assert_eq!(expected, a1.to_bits(), \"{:#x} * {:#x}\", op1, op2);\n+        }\n+        {\n+            let a1 = DoubleDouble::from_bits(op1);\n+            let mut a2 = DoubleDouble::from_bits(op2);\n+            a2 = a2.mul_r(a1, round).value;\n+\n+            assert_eq!(expected, a2.to_bits(), \"{:#x} * {:#x}\", op2, op1);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_divide() {\n+    // FIXME: Only a sanity check for now. Add more edge cases when the\n+    // double-double algorithm is implemented.\n+    let data = [\n+        // 1 / 3 = 1/3\n+        (\n+            0x3ff0000000000000,\n+            0x4008000000000000,\n+            0x3c75555555555556_3fd5555555555555,\n+            Round::NearestTiesToEven,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected, round) in &data {\n+        let mut a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        a1 = a1.div_r(a2, round).value;\n+\n+        assert_eq!(expected, a1.to_bits(), \"{:#x} / {:#x}\", op1, op2);\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_remainder() {\n+    let data = [\n+        // ieee_rem(3.0 + 3.0 << 53, 1.25 + 1.25 << 53) = (0.5 + 0.5 << 53)\n+        (\n+            0x3cb8000000000000_4008000000000000,\n+            0x3ca4000000000000_3ff4000000000000,\n+            0x3c90000000000000_3fe0000000000000,\n+        ),\n+        // ieee_rem(3.0 + 3.0 << 53, 1.75 + 1.75 << 53) = (-0.5 - 0.5 << 53)\n+        (\n+            0x3cb8000000000000_4008000000000000,\n+            0x3cac000000000000_3ffc000000000000,\n+            0xbc90000000000000_bfe0000000000000,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected) in &data {\n+        let a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        let result = a1.ieee_rem(a2).value;\n+\n+        assert_eq!(\n+            expected,\n+            result.to_bits(),\n+            \"ieee_rem({:#x}, {:#x})\",\n+            op1,\n+            op2\n+        );\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_mod() {\n+    let data = [\n+        // mod(3.0 + 3.0 << 53, 1.25 + 1.25 << 53) = (0.5 + 0.5 << 53)\n+        (\n+            0x3cb8000000000000_4008000000000000,\n+            0x3ca4000000000000_3ff4000000000000,\n+            0x3c90000000000000_3fe0000000000000,\n+        ),\n+        // mod(3.0 + 3.0 << 53, 1.75 + 1.75 << 53) = (1.25 + 1.25 << 53)\n+        // 0xbc98000000000000 doesn't seem right, but it's what we currently have.\n+        // FIXME: investigate\n+        (\n+            0x3cb8000000000000_4008000000000000,\n+            0x3cac000000000000_3ffc000000000000,\n+            0xbc98000000000000_3ff4000000000001,\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected) in &data {\n+        let a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        let r = (a1 % a2).value;\n+\n+        assert_eq!(expected, r.to_bits(), \"fmod({:#x}, {:#x})\", op1, op2);\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_fma() {\n+    // Sanity check for now.\n+    let mut a = \"2\".parse::<DoubleDouble>().unwrap();\n+    a = a.mul_add(\n+        \"3\".parse::<DoubleDouble>().unwrap(),\n+        \"4\".parse::<DoubleDouble>().unwrap(),\n+    ).value;\n+    assert_eq!(\n+        Some(Ordering::Equal),\n+        \"10\".parse::<DoubleDouble>().unwrap().partial_cmp(&a)\n+    );\n+}\n+\n+#[test]\n+fn ppc_double_double_round_to_integral() {\n+    {\n+        let a = \"1.5\".parse::<DoubleDouble>().unwrap();\n+        let a = a.round_to_integral(Round::NearestTiesToEven).value;\n+        assert_eq!(\n+            Some(Ordering::Equal),\n+            \"2\".parse::<DoubleDouble>().unwrap().partial_cmp(&a)\n+        );\n+    }\n+    {\n+        let a = \"2.5\".parse::<DoubleDouble>().unwrap();\n+        let a = a.round_to_integral(Round::NearestTiesToEven).value;\n+        assert_eq!(\n+            Some(Ordering::Equal),\n+            \"2\".parse::<DoubleDouble>().unwrap().partial_cmp(&a)\n+        );\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_compare() {\n+    let data = [\n+        // (1 + 0) = (1 + 0)\n+        (\n+            0x3ff0000000000000,\n+            0x3ff0000000000000,\n+            Some(Ordering::Equal),\n+        ),\n+        // (1 + 0) < (1.00...1 + 0)\n+        (0x3ff0000000000000, 0x3ff0000000000001, Some(Ordering::Less)),\n+        // (1.00...1 + 0) > (1 + 0)\n+        (\n+            0x3ff0000000000001,\n+            0x3ff0000000000000,\n+            Some(Ordering::Greater),\n+        ),\n+        // (1 + 0) < (1 + epsilon)\n+        (\n+            0x3ff0000000000000,\n+            0x0000000000000001_3ff0000000000001,\n+            Some(Ordering::Less),\n+        ),\n+        // NaN != NaN\n+        (0x7ff8000000000000, 0x7ff8000000000000, None),\n+        // (1 + 0) != NaN\n+        (0x3ff0000000000000, 0x7ff8000000000000, None),\n+        // Inf = Inf\n+        (\n+            0x7ff0000000000000,\n+            0x7ff0000000000000,\n+            Some(Ordering::Equal),\n+        ),\n+    ];\n+\n+    for &(op1, op2, expected) in &data {\n+        let a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        assert_eq!(\n+            expected,\n+            a1.partial_cmp(&a2),\n+            \"compare({:#x}, {:#x})\",\n+            op1,\n+            op2,\n+        );\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_bitwise_eq() {\n+    let data = [\n+        // (1 + 0) = (1 + 0)\n+        (0x3ff0000000000000, 0x3ff0000000000000, true),\n+        // (1 + 0) != (1.00...1 + 0)\n+        (0x3ff0000000000000, 0x3ff0000000000001, false),\n+        // NaN = NaN\n+        (0x7ff8000000000000, 0x7ff8000000000000, true),\n+        // NaN != NaN with a different bit pattern\n+        (\n+            0x7ff8000000000000,\n+            0x3ff0000000000000_7ff8000000000000,\n+            false,\n+        ),\n+        // Inf = Inf\n+        (0x7ff0000000000000, 0x7ff0000000000000, true),\n+    ];\n+\n+    for &(op1, op2, expected) in &data {\n+        let a1 = DoubleDouble::from_bits(op1);\n+        let a2 = DoubleDouble::from_bits(op2);\n+        assert_eq!(expected, a1.bitwise_eq(a2), \"{:#x} = {:#x}\", op1, op2);\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_change_sign() {\n+    let float = DoubleDouble::from_bits(0xbcb0000000000000_400f000000000000);\n+    {\n+        let actual = float.copy_sign(\"1\".parse::<DoubleDouble>().unwrap());\n+        assert_eq!(0xbcb0000000000000_400f000000000000, actual.to_bits());\n+    }\n+    {\n+        let actual = float.copy_sign(\"-1\".parse::<DoubleDouble>().unwrap());\n+        assert_eq!(0x3cb0000000000000_c00f000000000000, actual.to_bits());\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_factories() {\n+    assert_eq!(0, DoubleDouble::ZERO.to_bits());\n+    assert_eq!(\n+        0x7c8ffffffffffffe_7fefffffffffffff,\n+        DoubleDouble::largest().to_bits()\n+    );\n+    assert_eq!(0x0000000000000001, DoubleDouble::SMALLEST.to_bits());\n+    assert_eq!(\n+        0x0360000000000000,\n+        DoubleDouble::smallest_normalized().to_bits()\n+    );\n+    assert_eq!(\n+        0x0000000000000000_8000000000000000,\n+        (-DoubleDouble::ZERO).to_bits()\n+    );\n+    assert_eq!(\n+        0xfc8ffffffffffffe_ffefffffffffffff,\n+        (-DoubleDouble::largest()).to_bits()\n+    );\n+    assert_eq!(\n+        0x0000000000000000_8000000000000001,\n+        (-DoubleDouble::SMALLEST).to_bits()\n+    );\n+    assert_eq!(\n+        0x0000000000000000_8360000000000000,\n+        (-DoubleDouble::smallest_normalized()).to_bits()\n+    );\n+    assert!(DoubleDouble::SMALLEST.is_smallest());\n+    assert!(DoubleDouble::largest().is_largest());\n+}\n+\n+#[test]\n+fn ppc_double_double_is_denormal() {\n+    assert!(DoubleDouble::SMALLEST.is_denormal());\n+    assert!(!DoubleDouble::largest().is_denormal());\n+    assert!(!DoubleDouble::smallest_normalized().is_denormal());\n+    {\n+        // (4 + 3) is not normalized\n+        let data = 0x4008000000000000_4010000000000000;\n+        assert!(DoubleDouble::from_bits(data).is_denormal());\n+    }\n+}\n+\n+#[test]\n+fn ppc_double_double_exact_inverse() {\n+    assert!(\n+        \"2.0\"\n+            .parse::<DoubleDouble>()\n+            .unwrap()\n+            .get_exact_inverse()\n+            .unwrap()\n+            .bitwise_eq(\"0.5\".parse::<DoubleDouble>().unwrap())\n+    );\n+}\n+\n+#[test]\n+fn ppc_double_double_scalbn() {\n+    // 3.0 + 3.0 << 53\n+    let input = 0x3cb8000000000000_4008000000000000;\n+    let result = DoubleDouble::from_bits(input).scalbn(1);\n+    // 6.0 + 6.0 << 53\n+    assert_eq!(0x3cc8000000000000_4018000000000000, result.to_bits());\n+}\n+\n+#[test]\n+fn ppc_double_double_frexp() {\n+    // 3.0 + 3.0 << 53\n+    let input = 0x3cb8000000000000_4008000000000000;\n+    let mut exp = 0;\n+    // 0.75 + 0.75 << 53\n+    let result = DoubleDouble::from_bits(input).frexp(&mut exp);\n+    assert_eq!(2, exp);\n+    assert_eq!(0x3c98000000000000_3fe8000000000000, result.to_bits());\n+}"}, {"sha": "998183d401500d3cb093a079de726c9afea51358", "filename": "src/librustc_back/target/l4re_base.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use PanicStrategy;\n+use LinkerFlavor;\n+use target::{LinkArgs, TargetOptions};\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    let mut pre_link_args = LinkArgs::new();\n+    pre_link_args.insert(LinkerFlavor::Ld, vec![\n+            \"-nostdlib\".to_string(),\n+    ]);\n+\n+    TargetOptions {\n+        executables: true,\n+        has_elf_tls: false,\n+        exe_allocation_crate: Some(\"alloc_system\".to_string()),\n+        panic_strategy: PanicStrategy::Abort,\n+        linker: \"ld\".to_string(),\n+        pre_link_args: pre_link_args,\n+        target_family: Some(\"unix\".to_string()),\n+        .. Default::default()\n+    }\n+}"}, {"sha": "08b94d5a01cb7c86ef6364278bdfec715e408ce7", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -69,6 +69,7 @@ mod solaris_base;\n mod windows_base;\n mod windows_msvc_base;\n mod thumb_base;\n+mod l4re_base;\n mod fuchsia_base;\n mod redox_base;\n \n@@ -193,6 +194,8 @@ supported_targets! {\n     (\"aarch64-unknown-fuchsia\", aarch64_unknown_fuchsia),\n     (\"x86_64-unknown-fuchsia\", x86_64_unknown_fuchsia),\n \n+    (\"x86_64-unknown-l4re-uclibc\", x86_64_unknown_l4re_uclibc),\n+\n     (\"x86_64-unknown-redox\", x86_64_unknown_redox),\n \n     (\"i386-apple-ios\", i386_apple_ios),"}, {"sha": "b447f8a989db64839287cf83fb20147f1ff45769", "filename": "src/librustc_back/target/x86_64_unknown_l4re_uclibc.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_l4re_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_l4re_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_l4re_uclibc.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use LinkerFlavor;\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::l4re_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+    base.max_atomic_width = Some(64);\n+\n+    Ok(Target {\n+        llvm_target: \"x86_64-unknown-l4re-uclibc\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"l4re\".to_string(),\n+        target_env: \"uclibc\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Ld,\n+        options: base,\n+    })\n+}"}, {"sha": "cf3b7508c02423ffbf32579d4ff8cbb6e8c97dd0", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -111,19 +111,28 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId) {\n     // is not yet stolen.\n     tcx.mir_validated(owner_def_id).borrow();\n \n-    let cfg = cfg::CFG::new(bccx.tcx, &body);\n-    let AnalysisData { all_loans,\n-                       loans: loan_dfcx,\n-                       move_data: flowed_moves } =\n-        build_borrowck_dataflow_data(bccx, &cfg, body_id);\n-\n-    check_loans::check_loans(bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n+    // option dance because you can't capture an uninitialized variable\n+    // by mut-ref.\n+    let mut cfg = None;\n+    if let Some(AnalysisData { all_loans,\n+                               loans: loan_dfcx,\n+                               move_data: flowed_moves }) =\n+        build_borrowck_dataflow_data(bccx, false, body_id,\n+                                     |bccx| {\n+                                         cfg = Some(cfg::CFG::new(bccx.tcx, &body));\n+                                         cfg.as_mut().unwrap()\n+                                     })\n+    {\n+        check_loans::check_loans(bccx, &loan_dfcx, &flowed_moves, &all_loans, body);\n+    }\n }\n \n-fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n-                                          cfg: &cfg::CFG,\n-                                          body_id: hir::BodyId)\n-                                          -> AnalysisData<'a, 'tcx>\n+fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tcx>,\n+                                                 force_analysis: bool,\n+                                                 body_id: hir::BodyId,\n+                                                 get_cfg: F)\n+                                                 -> Option<AnalysisData<'a, 'tcx>>\n+    where F: FnOnce(&mut BorrowckCtxt<'a, 'tcx>) -> &'c cfg::CFG\n {\n     // Check the body of fn items.\n     let tcx = this.tcx;\n@@ -135,6 +144,18 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n     let (all_loans, move_data) =\n         gather_loans::gather_loans_in_fn(this, body_id);\n \n+    if !force_analysis && move_data.is_empty() && all_loans.is_empty() {\n+        // large arrays of data inserted as constants can take a lot of\n+        // time and memory to borrow-check - see issue #36799. However,\n+        // they don't have lvalues, so no borrow-check is actually needed.\n+        // Recognize that case and skip borrow-checking.\n+        debug!(\"skipping loan propagation for {:?} because of no loans\", body_id);\n+        return None;\n+    } else {\n+        debug!(\"propagating loans in {:?}\", body_id);\n+    }\n+\n+    let cfg = get_cfg(this);\n     let mut loan_dfcx =\n         DataFlowContext::new(this.tcx,\n                              \"borrowck\",\n@@ -157,9 +178,9 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n                                                       id_range,\n                                                       this.body);\n \n-    AnalysisData { all_loans: all_loans,\n-                   loans: loan_dfcx,\n-                   move_data:flowed_moves }\n+    Some(AnalysisData { all_loans: all_loans,\n+                        loans: loan_dfcx,\n+                        move_data:flowed_moves })\n }\n \n /// Accessor for introspective clients inspecting `AnalysisData` and\n@@ -177,8 +198,8 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     let body = tcx.hir.body(body_id);\n     let mut bccx = BorrowckCtxt { tcx, tables, region_maps, owner_def_id, body };\n \n-    let dataflow_data = build_borrowck_dataflow_data(&mut bccx, cfg, body_id);\n-    (bccx, dataflow_data)\n+    let dataflow_data = build_borrowck_dataflow_data(&mut bccx, true, body_id, |_| cfg);\n+    (bccx, dataflow_data.unwrap())\n }\n \n // ----------------------------------------------------------------------\n@@ -1072,14 +1093,15 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn local_binding_mode(&self, node_id: ast::NodeId) -> hir::BindingMode {\n+    fn local_binding_mode(&self, node_id: ast::NodeId) -> ty::BindingMode {\n         let pat = match self.tcx.hir.get(node_id) {\n             hir_map::Node::NodeLocal(pat) => pat,\n             node => bug!(\"bad node for local: {:?}\", node)\n         };\n \n         match pat.node {\n-            hir::PatKind::Binding(mode, ..) => mode,\n+            hir::PatKind::Binding(..) =>\n+                *self.tables.pat_binding_modes.get(&pat.id).expect(\"missing binding mode\"),\n             _ => bug!(\"local is not a binding: {:?}\", pat)\n         }\n     }\n@@ -1114,7 +1136,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             Some(ImmutabilityBlame::ClosureEnv(_)) => {}\n             Some(ImmutabilityBlame::ImmLocal(node_id)) => {\n                 let let_span = self.tcx.hir.span(node_id);\n-                if let hir::BindingMode::BindByValue(..) = self.local_binding_mode(node_id) {\n+                if let ty::BindByValue(..) = self.local_binding_mode(node_id) {\n                     if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(let_span) {\n                         let (_, is_implicit_self) = self.local_ty(node_id);\n                         if is_implicit_self && snippet != \"self\" {\n@@ -1131,7 +1153,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             Some(ImmutabilityBlame::LocalDeref(node_id)) => {\n                 let let_span = self.tcx.hir.span(node_id);\n                 match self.local_binding_mode(node_id) {\n-                    hir::BindingMode::BindByRef(..) => {\n+                    ty::BindByReference(..) => {\n                         let snippet = self.tcx.sess.codemap().span_to_snippet(let_span);\n                         if let Ok(snippet) = snippet {\n                             db.span_label(\n@@ -1141,7 +1163,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             );\n                         }\n                     }\n-                    hir::BindingMode::BindByValue(..) => {\n+                    ty::BindByValue(..) => {\n                         if let (Some(local_ty), is_implicit_self) = self.local_ty(node_id) {\n                             if let Some(msg) =\n                                  self.suggest_mut_for_immutable(local_ty, is_implicit_self) {"}, {"sha": "fd80e8320d6a10853b3395d5758df7151524bbf0", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -220,6 +220,15 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         }\n     }\n \n+    /// return true if there are no trackable assignments or moves\n+    /// in this move data - that means that there is nothing that\n+    /// could cause a borrow error.\n+    pub fn is_empty(&self) -> bool {\n+        self.moves.borrow().is_empty() &&\n+            self.path_assignments.borrow().is_empty() &&\n+            self.var_assignments.borrow().is_empty()\n+    }\n+\n     pub fn path_loan_path(&self, index: MovePathIndex) -> Rc<LoanPath<'tcx>> {\n         (*self.paths.borrow())[index.get()].loan_path.clone()\n     }"}, {"sha": "517b4e7f99b4d06d82ca06ebe14c703e3ac88bb4", "filename": "src/librustc_borrowck/diagnostics.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_borrowck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fdiagnostics.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1132,6 +1132,24 @@ fn main() {\n ```\n \"##,\n \n+E0595: r##\"\n+Closures cannot mutate immutable captured variables.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0595\n+let x = 3; // error: closure cannot assign to immutable local variable `x`\n+let mut c = || { x += 1 };\n+```\n+\n+Make the variable binding mutable:\n+\n+```\n+let mut x = 3; // ok!\n+let mut c = || { x += 1 };\n+```\n+\"##,\n+\n E0596: r##\"\n This error occurs because you tried to mutably borrow a non-mutable variable.\n \n@@ -1275,6 +1293,5 @@ register_diagnostics! {\n //    E0385, // {} in an aliasable location\n     E0524, // two closures require unique access to `..` at the same time\n     E0594, // cannot assign to {}\n-    E0595, // closure cannot assign to {}\n     E0598, // lifetime of {} is too short to guarantee its contents can be...\n }"}, {"sha": "060ff503d4e5889cdb61984056459a23e26f0ad6", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -268,7 +268,12 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n-        if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), _, name, None) = p.node {\n+        if let PatKind::Binding(_, _, name, None) = p.node {\n+            let bm = *cx.tables.pat_binding_modes.get(&p.id).expect(\"missing binding mode\");\n+            if bm != ty::BindByValue(hir::MutImmutable) {\n+                // Nothing to check.\n+                return true;\n+            }\n             let pat_ty = cx.tables.pat_ty(p);\n             if let ty::TyAdt(edef, _) = pat_ty.sty {\n                 if edef.is_enum() && edef.variants.iter().any(|variant| {\n@@ -452,8 +457,9 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n                                    pats: &[P<Pat>]) {\n     let mut by_ref_span = None;\n     for pat in pats {\n-        pat.each_binding(|bm, _, span, _path| {\n-            if let hir::BindByRef(..) = bm {\n+        pat.each_binding(|_, id, span, _path| {\n+            let bm = *cx.tables.pat_binding_modes.get(&id).expect(\"missing binding mode\");\n+            if let ty::BindByReference(..) = bm {\n                 by_ref_span = Some(span);\n             }\n         })\n@@ -484,10 +490,16 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n \n     for pat in pats {\n         pat.walk(|p| {\n-            if let PatKind::Binding(hir::BindByValue(..), _, _, ref sub) = p.node {\n-                let pat_ty = cx.tables.node_id_to_type(p.id);\n-                if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n-                    check_move(p, sub.as_ref().map(|p| &**p));\n+            if let PatKind::Binding(_, _, _, ref sub) = p.node {\n+                let bm = *cx.tables.pat_binding_modes.get(&p.id).expect(\"missing binding mode\");\n+                match bm {\n+                    ty::BindByValue(..) => {\n+                        let pat_ty = cx.tables.node_id_to_type(p.id);\n+                        if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n+                            check_move(p, sub.as_ref().map(|p| &**p));\n+                        }\n+                    }\n+                    _ => {}\n                 }\n             }\n             true"}, {"sha": "eb45fd9c0e0a44246c9fd8e558bac1aac050e9cd", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -26,6 +26,7 @@ use rustc::util::nodemap::DefIdMap;\n \n use syntax::abi::Abi;\n use syntax::ast;\n+use syntax::attr;\n use rustc::hir::{self, Expr};\n use syntax_pos::Span;\n \n@@ -560,8 +561,15 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyUint(ast::UintTy::Us) => {\n             Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.uint_type))))\n         },\n-        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(F64(val.to_f64()))),\n-        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(F32(val.to_f32()))),\n+        ty::TyFloat(fty) => {\n+            if let Some(i) = val.to_u128() {\n+                Ok(Float(ConstFloat::from_u128(i, fty)))\n+            } else {\n+                // The value must be negative, go through signed integers.\n+                let i = val.to_u128_unchecked() as i128;\n+                Ok(Float(ConstFloat::from_i128(i, fty)))\n+            }\n+        }\n         ty::TyRawPtr(_) => Err(ErrKind::UnimplementedConstVal(\"casting an address to a raw ptr\")),\n         ty::TyChar => match val {\n             U8(u) => Ok(Char(u as char)),\n@@ -574,30 +582,25 @@ fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               val: ConstFloat,\n                               ty: Ty<'tcx>) -> CastResult<'tcx> {\n+    let int_width = |ty| {\n+        ty::layout::Integer::from_attr(tcx, ty).size().bits() as usize\n+    };\n     match ty.sty {\n-        ty::TyInt(_) | ty::TyUint(_) => {\n-            let i = match val {\n-                F32(f) if f >= 0.0 => U128(f as u128),\n-                F64(f) if f >= 0.0 => U128(f as u128),\n-\n-                F32(f) => I128(f as i128),\n-                F64(f) => I128(f as i128)\n-            };\n-\n-            if let (I128(_), &ty::TyUint(_)) = (i, &ty.sty) {\n-                return Err(CannotCast);\n+        ty::TyInt(ity) => {\n+            if let Some(i) = val.to_i128(int_width(attr::SignedInt(ity))) {\n+                cast_const_int(tcx, I128(i), ty)\n+            } else {\n+                Err(CannotCast)\n+            }\n+        }\n+        ty::TyUint(uty) => {\n+            if let Some(i) = val.to_u128(int_width(attr::UnsignedInt(uty))) {\n+                cast_const_int(tcx, U128(i), ty)\n+            } else {\n+                Err(CannotCast)\n             }\n-\n-            cast_const_int(tcx, i, ty)\n         }\n-        ty::TyFloat(ast::FloatTy::F64) => Ok(Float(F64(match val {\n-            F32(f) => f as f64,\n-            F64(f) => f\n-        }))),\n-        ty::TyFloat(ast::FloatTy::F32) => Ok(Float(F32(match val {\n-            F64(f) => f as f32,\n-            F32(f) => f\n-        }))),\n+        ty::TyFloat(fty) => Ok(Float(val.convert(fty))),\n         _ => Err(CannotCast),\n     }\n }\n@@ -691,11 +694,7 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n \n fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n                      -> Result<ConstFloat, ErrKind<'tcx>> {\n-    let val = match fty {\n-        ast::FloatTy::F32 => num.parse::<f32>().map(F32),\n-        ast::FloatTy::F64 => num.parse::<f64>().map(F64)\n-    };\n-    val.map_err(|_| {\n+    ConstFloat::from_str(num, fty).map_err(|_| {\n         // FIXME(#31407) this is only necessary because float parsing is buggy\n         UnimplementedConstVal(\"could not evaluate float literal (see issue #31407)\")\n     })"}, {"sha": "f37a112a596ac57e3f24fd0fc57ca7fe617fc8b6", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -374,27 +374,31 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Binding(bm, def_id, ref ident, ref sub) => {\n+            PatKind::Binding(_, def_id, ref ident, ref sub) => {\n                 let id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                 let var_ty = self.tables.node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n                     _ => None,\n                 };\n+                let bm = *self.tables.pat_binding_modes.get(&pat.id)\n+                                                       .expect(\"missing binding mode\");\n                 let (mutability, mode) = match bm {\n-                    hir::BindByValue(hir::MutMutable) =>\n+                    ty::BindByValue(hir::MutMutable) =>\n                         (Mutability::Mut, BindingMode::ByValue),\n-                    hir::BindByValue(hir::MutImmutable) =>\n+                    ty::BindByValue(hir::MutImmutable) =>\n                         (Mutability::Not, BindingMode::ByValue),\n-                    hir::BindByRef(hir::MutMutable) =>\n-                        (Mutability::Not, BindingMode::ByRef(region.unwrap(), BorrowKind::Mut)),\n-                    hir::BindByRef(hir::MutImmutable) =>\n-                        (Mutability::Not, BindingMode::ByRef(region.unwrap(), BorrowKind::Shared)),\n+                    ty::BindByReference(hir::MutMutable) =>\n+                        (Mutability::Not, BindingMode::ByRef(\n+                            region.unwrap(), BorrowKind::Mut)),\n+                    ty::BindByReference(hir::MutImmutable) =>\n+                        (Mutability::Not, BindingMode::ByRef(\n+                            region.unwrap(), BorrowKind::Shared)),\n                 };\n \n                 // A ref x pattern is the same node used for x, and as such it has\n                 // x's type, which is &T, where we want T (the type being matched).\n-                if let hir::BindByRef(_) = bm {\n+                if let ty::BindByReference(_) = bm {\n                     if let ty::TyRef(_, mt) = ty.sty {\n                         ty = mt.ty;\n                     } else {"}, {"sha": "41310ede3e085a0928288779615792ea79dd8055", "filename": "src/librustc_const_math/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_const_math%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_const_math%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2FCargo.toml?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -9,5 +9,6 @@ path = \"lib.rs\"\n crate-type = [\"dylib\"]\n \n [dependencies]\n+rustc_apfloat = { path = \"../librustc_apfloat\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }"}, {"sha": "719f6b6a7b3221965447d8370d5ae016e494586b", "filename": "src/librustc_const_math/float.rs", "status": "modified", "additions": 138, "deletions": 66, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_const_math%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_const_math%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ffloat.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -9,102 +9,164 @@\n // except according to those terms.\n \n use std::cmp::Ordering;\n-use std::hash;\n-use std::mem::transmute;\n+use std::num::ParseFloatError;\n+\n+use syntax::ast;\n+\n+use rustc_apfloat::{Float, FloatConvert, Status};\n+use rustc_apfloat::ieee::{Single, Double};\n \n use super::err::*;\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n-pub enum ConstFloat {\n-    F32(f32),\n-    F64(f64)\n+// Note that equality for `ConstFloat` means that the it is the same\n+// constant, not that the rust values are equal. In particular, `NaN\n+// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n+// are considering unequal).\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct ConstFloat {\n+    pub ty: ast::FloatTy,\n+\n+    // This is a bit inefficient but it makes conversions below more\n+    // ergonomic, and all of this will go away once `miri` is merged.\n+    pub bits: u128,\n }\n-pub use self::ConstFloat::*;\n \n impl ConstFloat {\n     /// Description of the type, not the value\n     pub fn description(&self) -> &'static str {\n-        match *self {\n-            F32(_) => \"f32\",\n-            F64(_) => \"f64\",\n-        }\n+        self.ty.ty_to_string()\n     }\n \n     pub fn is_nan(&self) -> bool {\n-        match *self {\n-            F32(f) => f.is_nan(),\n-            F64(f) => f.is_nan(),\n+        match self.ty {\n+            ast::FloatTy::F32 => Single::from_bits(self.bits).is_nan(),\n+            ast::FloatTy::F64 => Double::from_bits(self.bits).is_nan(),\n         }\n     }\n \n     /// Compares the values if they are of the same type\n     pub fn try_cmp(self, rhs: Self) -> Result<Ordering, ConstMathErr> {\n-        match (self, rhs) {\n-            (F64(a), F64(b))  => {\n+        match (self.ty, rhs.ty) {\n+            (ast::FloatTy::F64, ast::FloatTy::F64)  => {\n+                let a = Double::from_bits(self.bits);\n+                let b = Double::from_bits(rhs.bits);\n                 // This is pretty bad but it is the existing behavior.\n-                Ok(if a == b {\n-                    Ordering::Equal\n-                } else if a < b {\n-                    Ordering::Less\n-                } else {\n-                    Ordering::Greater\n-                })\n+                Ok(a.partial_cmp(&b).unwrap_or(Ordering::Greater))\n             }\n \n-            (F32(a), F32(b)) => {\n-                Ok(if a == b {\n-                    Ordering::Equal\n-                } else if a < b {\n-                    Ordering::Less\n-                } else {\n-                    Ordering::Greater\n-                })\n+            (ast::FloatTy::F32, ast::FloatTy::F32) => {\n+                let a = Single::from_bits(self.bits);\n+                let b = Single::from_bits(rhs.bits);\n+                Ok(a.partial_cmp(&b).unwrap_or(Ordering::Greater))\n             }\n \n             _ => Err(CmpBetweenUnequalTypes),\n         }\n     }\n-}\n \n-/// Note that equality for `ConstFloat` means that the it is the same\n-/// constant, not that the rust values are equal. In particular, `NaN\n-/// == NaN` (at least if it's the same NaN; distinct encodings for NaN\n-/// are considering unequal).\n-impl PartialEq for ConstFloat {\n-    fn eq(&self, other: &Self) -> bool {\n-        match (*self, *other) {\n-            (F64(a), F64(b)) => {\n-                unsafe{transmute::<_,u64>(a) == transmute::<_,u64>(b)}\n+    pub fn from_i128(input: i128, ty: ast::FloatTy) -> Self {\n+        let bits = match ty {\n+            ast::FloatTy::F32 => Single::from_i128(input).value.to_bits(),\n+            ast::FloatTy::F64 => Double::from_i128(input).value.to_bits()\n+        };\n+        ConstFloat { bits, ty }\n+    }\n+\n+    pub fn from_u128(input: u128, ty: ast::FloatTy) -> Self {\n+        let bits = match ty {\n+            ast::FloatTy::F32 => Single::from_u128(input).value.to_bits(),\n+            ast::FloatTy::F64 => Double::from_u128(input).value.to_bits()\n+        };\n+        ConstFloat { bits, ty }\n+    }\n+\n+    pub fn from_str(num: &str, ty: ast::FloatTy) -> Result<Self, ParseFloatError> {\n+        let bits = match ty {\n+            ast::FloatTy::F32 => {\n+                let rust_bits = num.parse::<f32>()?.to_bits() as u128;\n+                let apfloat = num.parse::<Single>().unwrap_or_else(|e| {\n+                    panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e);\n+                });\n+                let apfloat_bits = apfloat.to_bits();\n+                assert!(rust_bits == apfloat_bits,\n+                    \"apfloat::ieee::Single gave different result for `{}`: \\\n+                     {}({:#x}) vs Rust's {}({:#x})\",\n+                    num, apfloat, apfloat_bits,\n+                    Single::from_bits(rust_bits), rust_bits);\n+                apfloat_bits\n             }\n-            (F32(a), F32(b)) => {\n-                unsafe{transmute::<_,u32>(a) == transmute::<_,u32>(b)}\n+            ast::FloatTy::F64 => {\n+                let rust_bits = num.parse::<f64>()?.to_bits() as u128;\n+                let apfloat = num.parse::<Double>().unwrap_or_else(|e| {\n+                    panic!(\"apfloat::ieee::Double failed to parse `{}`: {:?}\", num, e);\n+                });\n+                let apfloat_bits = apfloat.to_bits();\n+                assert!(rust_bits == apfloat_bits,\n+                    \"apfloat::ieee::Double gave different result for `{}`: \\\n+                     {}({:#x}) vs Rust's {}({:#x})\",\n+                    num, apfloat, apfloat_bits,\n+                    Double::from_bits(rust_bits), rust_bits);\n+                apfloat_bits\n             }\n-            _ => false\n+        };\n+        Ok(ConstFloat { bits, ty })\n+    }\n+\n+    pub fn to_i128(self, width: usize) -> Option<i128> {\n+        assert!(width <= 128);\n+        let r = match self.ty {\n+            ast::FloatTy::F32 => Single::from_bits(self.bits).to_i128(width),\n+            ast::FloatTy::F64 => Double::from_bits(self.bits).to_i128(width)\n+        };\n+        if r.status.intersects(Status::INVALID_OP) {\n+            None\n+        } else {\n+            Some(r.value)\n         }\n     }\n-}\n \n-impl Eq for ConstFloat {}\n+    pub fn to_u128(self, width: usize) -> Option<u128> {\n+        assert!(width <= 128);\n+        let r = match self.ty {\n+            ast::FloatTy::F32 => Single::from_bits(self.bits).to_u128(width),\n+            ast::FloatTy::F64 => Double::from_bits(self.bits).to_u128(width)\n+        };\n+        if r.status.intersects(Status::INVALID_OP) {\n+            None\n+        } else {\n+            Some(r.value)\n+        }\n+    }\n \n-impl hash::Hash for ConstFloat {\n-    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n-        match *self {\n-            F64(a) => {\n-                unsafe { transmute::<_,u64>(a) }.hash(state)\n+    pub fn convert(self, to: ast::FloatTy) -> Self {\n+        let bits = match (self.ty, to) {\n+            (ast::FloatTy::F32, ast::FloatTy::F32) |\n+            (ast::FloatTy::F64, ast::FloatTy::F64) => return self,\n+\n+            (ast::FloatTy::F32, ast::FloatTy::F64) => {\n+                Double::to_bits(Single::from_bits(self.bits).convert(&mut false).value)\n             }\n-            F32(a) => {\n-                unsafe { transmute::<_,u32>(a) }.hash(state)\n+            (ast::FloatTy::F64, ast::FloatTy::F32) => {\n+                Single::to_bits(Double::from_bits(self.bits).convert(&mut false).value)\n             }\n-        }\n+        };\n+        ConstFloat { bits, ty: to }\n     }\n }\n \n impl ::std::fmt::Display for ConstFloat {\n     fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n-        match *self {\n-            F32(f) => write!(fmt, \"{}f32\", f),\n-            F64(f) => write!(fmt, \"{}f64\", f),\n+        match self.ty {\n+            ast::FloatTy::F32 => write!(fmt, \"{:#}\", Single::from_bits(self.bits))?,\n+            ast::FloatTy::F64 => write!(fmt, \"{:#}\", Double::from_bits(self.bits))?,\n         }\n+        write!(fmt, \"{}\", self.ty)\n+    }\n+}\n+\n+impl ::std::fmt::Debug for ConstFloat {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> Result<(), ::std::fmt::Error> {\n+        ::std::fmt::Display::fmt(self, fmt)\n     }\n }\n \n@@ -113,11 +175,20 @@ macro_rules! derive_binop {\n         impl ::std::ops::$op for ConstFloat {\n             type Output = Result<Self, ConstMathErr>;\n             fn $func(self, rhs: Self) -> Result<Self, ConstMathErr> {\n-                match (self, rhs) {\n-                    (F32(a), F32(b)) => Ok(F32(a.$func(b))),\n-                    (F64(a), F64(b)) => Ok(F64(a.$func(b))),\n-                    _ => Err(UnequalTypes(Op::$op)),\n-                }\n+                let bits = match (self.ty, rhs.ty) {\n+                    (ast::FloatTy::F32, ast::FloatTy::F32) =>{\n+                        let a = Single::from_bits(self.bits);\n+                        let b = Single::from_bits(rhs.bits);\n+                        a.$func(b).value.to_bits()\n+                    }\n+                    (ast::FloatTy::F64, ast::FloatTy::F64) => {\n+                        let a = Double::from_bits(self.bits);\n+                        let b = Double::from_bits(rhs.bits);\n+                        a.$func(b).value.to_bits()\n+                    }\n+                    _ => return Err(UnequalTypes(Op::$op)),\n+                };\n+                Ok(ConstFloat { bits, ty: self.ty })\n             }\n         }\n     }\n@@ -132,9 +203,10 @@ derive_binop!(Rem, rem);\n impl ::std::ops::Neg for ConstFloat {\n     type Output = Self;\n     fn neg(self) -> Self {\n-        match self {\n-            F32(f) => F32(-f),\n-            F64(f) => F64(-f),\n-        }\n+        let bits = match self.ty {\n+            ast::FloatTy::F32 => (-Single::from_bits(self.bits)).to_bits(),\n+            ast::FloatTy::F64 => (-Double::from_bits(self.bits)).to_bits(),\n+        };\n+        ConstFloat { bits, ty: self.ty }\n     }\n }"}, {"sha": "65471416e8007465ed3ad229f2a3fb1a910440e0", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -211,48 +211,6 @@ impl ConstInt {\n         }\n     }\n \n-    pub fn to_f32(self) -> f32 {\n-        match self {\n-            I8(i) => i as f32,\n-            I16(i) => i as f32,\n-            I32(i) => i as f32,\n-            I64(i) => i as f32,\n-            I128(i) => i as f32,\n-            Isize(Is16(i)) => i as f32,\n-            Isize(Is32(i)) => i as f32,\n-            Isize(Is64(i)) => i as f32,\n-            U8(i) => i as f32,\n-            U16(i) => i as f32,\n-            U32(i) => i as f32,\n-            U64(i) => i as f32,\n-            U128(i) => i as f32,\n-            Usize(Us16(i)) => i as f32,\n-            Usize(Us32(i)) => i as f32,\n-            Usize(Us64(i)) => i as f32,\n-        }\n-    }\n-\n-    pub fn to_f64(self) -> f64 {\n-        match self {\n-            I8(i) => i as f64,\n-            I16(i) => i as f64,\n-            I32(i) => i as f64,\n-            I64(i) => i as f64,\n-            I128(i) => i as f64,\n-            Isize(Is16(i)) => i as f64,\n-            Isize(Is32(i)) => i as f64,\n-            Isize(Is64(i)) => i as f64,\n-            U8(i) => i as f64,\n-            U16(i) => i as f64,\n-            U32(i) => i as f64,\n-            U64(i) => i as f64,\n-            U128(i) => i as f64,\n-            Usize(Us16(i)) => i as f64,\n-            Usize(Us32(i)) => i as f64,\n-            Usize(Us64(i)) => i as f64,\n-        }\n-    }\n-\n     pub fn is_negative(&self) -> bool {\n         match *self {\n             I8(v) => v < 0,"}, {"sha": "3947edecb5aff20215fe82888e3e4534b5660ce4", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -26,6 +26,8 @@\n #![feature(i128)]\n #![feature(i128_type)]\n \n+extern crate rustc_apfloat;\n+\n extern crate syntax;\n \n extern crate serialize as rustc_serialize; // used by deriving"}, {"sha": "f74af6ee1632e793f8f6fef0922f9262443e2eb1", "filename": "src/librustc_data_structures/bitslice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_data_structures%2Fbitslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_data_structures%2Fbitslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitslice.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -134,9 +134,11 @@ pub trait BitwiseOperator {\n \n pub struct Union;\n impl BitwiseOperator for Union {\n+    #[inline]\n     fn join(&self, a: usize, b: usize) -> usize { a | b }\n }\n pub struct Subtract;\n impl BitwiseOperator for Subtract {\n+    #[inline]\n     fn join(&self, a: usize, b: usize) -> usize { a & !b }\n }"}, {"sha": "5bd57236e7c28579e485f746da9565f6fbdde472", "filename": "src/librustc_data_structures/fnv.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cc4ff8f4d169562ff4ae22b94197a191215e6d56/src%2Flibrustc_data_structures%2Ffnv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc4ff8f4d169562ff4ae22b94197a191215e6d56/src%2Flibrustc_data_structures%2Ffnv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffnv.rs?ref=cc4ff8f4d169562ff4ae22b94197a191215e6d56", "patch": "@@ -1,66 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::collections::{HashMap, HashSet};\n-use std::default::Default;\n-use std::hash::{Hasher, Hash, BuildHasherDefault};\n-\n-pub type FnvHashMap<K, V> = HashMap<K, V, BuildHasherDefault<FnvHasher>>;\n-pub type FnvHashSet<V> = HashSet<V, BuildHasherDefault<FnvHasher>>;\n-\n-#[allow(non_snake_case)]\n-pub fn FnvHashMap<K: Hash + Eq, V>() -> FnvHashMap<K, V> {\n-    HashMap::default()\n-}\n-\n-#[allow(non_snake_case)]\n-pub fn FnvHashSet<V: Hash + Eq>() -> FnvHashSet<V> {\n-    HashSet::default()\n-}\n-\n-/// A speedy hash algorithm for node ids and def ids. The hashmap in\n-/// liballoc by default uses SipHash which isn't quite as speedy as we\n-/// want. In the compiler we're not really worried about DOS attempts, so we\n-/// just default to a non-cryptographic hash.\n-///\n-/// This uses FNV hashing, as described here:\n-/// http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n-pub struct FnvHasher(u64);\n-\n-impl Default for FnvHasher {\n-    /// Creates a `FnvHasher`, with a 64-bit hex initial value.\n-    #[inline]\n-    fn default() -> FnvHasher {\n-        FnvHasher(0xcbf29ce484222325)\n-    }\n-}\n-\n-impl Hasher for FnvHasher {\n-    #[inline]\n-    fn write(&mut self, bytes: &[u8]) {\n-        let FnvHasher(mut hash) = *self;\n-        for byte in bytes {\n-            hash = hash ^ (*byte as u64);\n-            hash = hash.wrapping_mul(0x100000001b3);\n-        }\n-        *self = FnvHasher(hash);\n-    }\n-\n-    #[inline]\n-    fn finish(&self) -> u64 {\n-        self.0\n-    }\n-}\n-\n-pub fn hash<T: Hash>(v: &T) -> u64 {\n-    let mut state = FnvHasher::default();\n-    v.hash(&mut state);\n-    state.finish()\n-}"}, {"sha": "f562ae0e3b84d2641f9e99a1781b806fcd294dc0", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -308,6 +308,42 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         DepthFirstTraversal::with_start_node(self, start, direction)\n     }\n \n+    pub fn nodes_in_postorder<'a>(&'a self,\n+                                  direction: Direction,\n+                                  entry_node: NodeIndex)\n+                                  -> Vec<NodeIndex>\n+    {\n+        let mut visited = BitVector::new(self.len_nodes());\n+        let mut stack = vec![];\n+        let mut result = Vec::with_capacity(self.len_nodes());\n+        let mut push_node = |stack: &mut Vec<_>, node: NodeIndex| {\n+            if visited.insert(node.0) {\n+                stack.push((node, self.adjacent_edges(node, direction)));\n+            }\n+        };\n+\n+        for node in Some(entry_node).into_iter()\n+            .chain(self.enumerated_nodes().map(|(node, _)| node))\n+        {\n+            push_node(&mut stack, node);\n+            while let Some((node, mut iter)) = stack.pop() {\n+                if let Some((_, child)) = iter.next() {\n+                    let target = child.source_or_target(direction);\n+                    // the current node needs more processing, so\n+                    // add it back to the stack\n+                    stack.push((node, iter));\n+                    // and then push the new node\n+                    push_node(&mut stack, target);\n+                } else {\n+                    result.push(node);\n+                }\n+            }\n+        }\n+\n+        assert_eq!(result.len(), self.len_nodes());\n+        result\n+    }\n+\n     /// Whether or not a node can be reached from itself.\n     pub fn is_node_cyclic(&self, starting_node_index: NodeIndex) -> bool {\n         // This is similar to depth traversal below, but we"}, {"sha": "b6a0d4cff5a38608dbdb7f8d452ad634a078b8ef", "filename": "src/librustc_data_structures/graph/tests.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -175,3 +175,46 @@ fn is_node_cyclic_b() {\n     let graph = create_graph_with_cycle();\n     assert!(graph.is_node_cyclic(NodeIndex(1)));\n }\n+\n+#[test]\n+fn nodes_in_postorder() {\n+    let expected = vec![\n+        (\"A\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n+        (\"B\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n+        (\"C\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n+        (\"D\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n+        (\"E\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n+        (\"F\", vec![\"C\", \"E\", \"D\", \"B\", \"F\", \"A\"])\n+    ];\n+\n+    let graph = create_graph();\n+\n+    for ((idx, node), &(node_name, ref expected))\n+        in graph.enumerated_nodes().zip(&expected)\n+    {\n+        assert_eq!(node.data, node_name);\n+        assert_eq!(expected,\n+                   &graph.nodes_in_postorder(OUTGOING, idx)\n+                   .into_iter().map(|idx| *graph.node_data(idx))\n+                   .collect::<Vec<&str>>());\n+    }\n+\n+    let expected = vec![\n+        (\"A\", vec![\"D\", \"C\", \"B\", \"A\"]),\n+        (\"B\", vec![\"D\", \"C\", \"B\", \"A\"]),\n+        (\"C\", vec![\"B\", \"D\", \"C\", \"A\"]),\n+        (\"D\", vec![\"C\", \"B\", \"D\", \"A\"]),\n+    ];\n+\n+    let graph = create_graph_with_cycle();\n+\n+    for ((idx, node), &(node_name, ref expected))\n+        in graph.enumerated_nodes().zip(&expected)\n+    {\n+        assert_eq!(node.data, node_name);\n+        assert_eq!(expected,\n+                   &graph.nodes_in_postorder(OUTGOING, idx)\n+                   .into_iter().map(|idx| *graph.node_data(idx))\n+                   .collect::<Vec<&str>>());\n+    }\n+}"}, {"sha": "3cb3e088364dea7fe29a167d67f3f6255607fe3d", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -65,7 +65,6 @@ pub mod snapshot_vec;\n pub mod stable_hasher;\n pub mod transitive_relation;\n pub mod unify;\n-pub mod fnv;\n pub mod fx;\n pub mod tuple_slice;\n pub mod veccell;"}, {"sha": "6e8d3494ba5f30654fa2fa22c8242f79e2de7dc7", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 25, "deletions": 58, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -15,8 +15,7 @@ use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_mir as mir;\n use rustc::session::{Session, CompileResult};\n use rustc::session::CompileIncomplete;\n-use rustc::session::config::{self, Input, OutputFilenames, OutputType,\n-                             OutputTypes};\n+use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n use rustc::middle::{self, dependency_format, stability, reachable};\n@@ -26,7 +25,6 @@ use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n use rustc::traits;\n use rustc::util::common::{ErrorReported, time};\n use rustc::util::nodemap::NodeSet;\n-use rustc::util::fs::rename_or_copy_remove;\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n use rustc_incremental::{self, IncrementalHashesMap};\n@@ -208,7 +206,7 @@ pub fn compile_input(sess: &Session,\n                 println!(\"Pre-trans\");\n                 tcx.print_debug_stats();\n             }\n-            let trans = phase_4_translate_to_llvm(tcx, analysis, &incremental_hashes_map,\n+            let trans = phase_4_translate_to_llvm(tcx, analysis, incremental_hashes_map,\n                                                   &outputs);\n \n             if log_enabled!(::log::LogLevel::Info) {\n@@ -231,16 +229,14 @@ pub fn compile_input(sess: &Session,\n         sess.code_stats.borrow().print_type_sizes();\n     }\n \n-    let phase5_result = phase_5_run_llvm_passes(sess, &trans, &outputs);\n+    let (phase5_result, trans) = phase_5_run_llvm_passes(sess, trans);\n \n     controller_entry_point!(after_llvm,\n                             sess,\n                             CompileState::state_after_llvm(input, sess, outdir, output, &trans),\n                             phase5_result);\n     phase5_result?;\n \n-    write::cleanup_llvm(&trans);\n-\n     phase_6_link_output(sess, &trans, &outputs);\n \n     // Now that we won't touch anything in the incremental compilation directory\n@@ -933,25 +929,32 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     passes.push_pass(MIR_CONST, mir::transform::type_check::TypeckMir);\n     passes.push_pass(MIR_CONST, mir::transform::rustc_peek::SanityCheck);\n \n+    // We compute \"constant qualifications\" betwen MIR_CONST and MIR_VALIDATED.\n+\n     // What we need to run borrowck etc.\n     passes.push_pass(MIR_VALIDATED, mir::transform::qualify_consts::QualifyAndPromoteConstants);\n     passes.push_pass(MIR_VALIDATED,\n                      mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));\n     passes.push_pass(MIR_VALIDATED, mir::transform::simplify::SimplifyCfg::new(\"qualify-consts\"));\n     passes.push_pass(MIR_VALIDATED, mir::transform::nll::NLL);\n \n-    // Optimizations begin.\n-    passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n-    passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyCfg::new(\"no-landing-pads\"));\n+    // borrowck runs between MIR_VALIDATED and MIR_OPTIMIZED.\n \n-    // From here on out, regions are gone.\n-    passes.push_pass(MIR_OPTIMIZED, mir::transform::erase_regions::EraseRegions);\n+    // These next passes must be executed together\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::AddCallGuards);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::elaborate_drops::ElaborateDrops);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyCfg::new(\"elaborate-drops\"));\n-\n     // No lifetime analysis based on borrowing can be done from here on out.\n+\n+    // AddValidation needs to run after ElaborateDrops and before EraseRegions.\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::add_validation::AddValidation);\n+\n+    // From here on out, regions are gone.\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::erase_regions::EraseRegions);\n+\n+    // Optimizations begin.\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::inline::Inline);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::instcombine::InstCombine);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::deaggregator::Deaggregator);\n@@ -1059,9 +1062,9 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n /// be discarded.\n pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            analysis: ty::CrateAnalysis,\n-                                           incremental_hashes_map: &IncrementalHashesMap,\n+                                           incremental_hashes_map: IncrementalHashesMap,\n                                            output_filenames: &OutputFilenames)\n-                                           -> trans::CrateTranslation {\n+                                           -> write::OngoingCrateTranslation {\n     let time_passes = tcx.sess.time_passes();\n \n     time(time_passes,\n@@ -1071,63 +1074,27 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let translation =\n         time(time_passes,\n              \"translation\",\n-             move || trans::trans_crate(tcx, analysis, &incremental_hashes_map, output_filenames));\n+             move || trans::trans_crate(tcx, analysis, incremental_hashes_map, output_filenames));\n \n-    time(time_passes,\n-         \"assert dep graph\",\n-         || rustc_incremental::assert_dep_graph(tcx));\n-\n-    time(time_passes,\n-         \"serialize dep graph\",\n-         || rustc_incremental::save_dep_graph(tcx,\n-                                              &incremental_hashes_map,\n-                                              &translation.metadata.hashes,\n-                                              translation.link.crate_hash));\n     translation\n }\n \n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n /// as a side effect.\n pub fn phase_5_run_llvm_passes(sess: &Session,\n-                               trans: &trans::CrateTranslation,\n-                               outputs: &OutputFilenames) -> CompileResult {\n-    if sess.opts.cg.no_integrated_as ||\n-        (sess.target.target.options.no_integrated_as &&\n-         (outputs.outputs.contains_key(&OutputType::Object) ||\n-          outputs.outputs.contains_key(&OutputType::Exe)))\n-    {\n-        let output_types = OutputTypes::new(&[(OutputType::Assembly, None)]);\n-        time(sess.time_passes(),\n-             \"LLVM passes\",\n-             || write::run_passes(sess, trans, &output_types, outputs));\n-\n-        write::run_assembler(sess, outputs);\n-\n-        // HACK the linker expects the object file to be named foo.0.o but\n-        // `run_assembler` produces an object named just foo.o. Rename it if we\n-        // are going to build an executable\n-        if sess.opts.output_types.contains_key(&OutputType::Exe) {\n-            let f = outputs.path(OutputType::Object);\n-            rename_or_copy_remove(&f,\n-                     f.with_file_name(format!(\"{}.0.o\",\n-                                              f.file_stem().unwrap().to_string_lossy()))).unwrap();\n-        }\n+                               trans: write::OngoingCrateTranslation)\n+                               -> (CompileResult, trans::CrateTranslation) {\n+    let trans = trans.join(sess);\n \n-        // Remove assembly source, unless --save-temps was specified\n-        if !sess.opts.cg.save_temps {\n-            fs::remove_file(&outputs.temp_path(OutputType::Assembly, None)).unwrap();\n-        }\n-    } else {\n-        time(sess.time_passes(),\n-             \"LLVM passes\",\n-             || write::run_passes(sess, trans, &sess.opts.output_types, outputs));\n+    if sess.opts.debugging_opts.incremental_info {\n+        write::dump_incremental_data(&trans);\n     }\n \n     time(sess.time_passes(),\n          \"serialize work products\",\n          move || rustc_incremental::save_work_products(sess));\n \n-    sess.compile_status()\n+    (sess.compile_status(), trans)\n }\n \n /// Run the linker on any artifacts that resulted from the LLVM run."}, {"sha": "4c337993468e6803eb82e1e1912254401769573a", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -795,19 +795,23 @@ fn usage(verbose: bool, include_unstable_options: bool) {\n         (option.apply)(&mut options);\n     }\n     let message = format!(\"Usage: rustc [OPTIONS] INPUT\");\n-    let extra_help = if verbose {\n+    let nightly_help = if nightly_options::is_nightly_build() {\n+        \"\\n    -Z help             Print internal options for debugging rustc\"\n+    } else {\n+        \"\"\n+    };\n+    let verbose_help = if verbose {\n         \"\"\n     } else {\n         \"\\n    --help -v           Print the full set of options rustc accepts\"\n     };\n     println!(\"{}\\nAdditional help:\n     -C help             Print codegen options\n     -W help             \\\n-              Print 'lint' options and default settings\n-    -Z help             Print internal \\\n-              options for debugging rustc{}\\n\",\n+              Print 'lint' options and default settings{}{}\\n\",\n              options.usage(&message),\n-             extra_help);\n+             nightly_help,\n+             verbose_help);\n }\n \n fn describe_lints(lint_store: &lint::LintStore, loaded_plugins: bool) {\n@@ -1203,6 +1207,10 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     all_errors.extend_from_slice(&rustc_trans::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_const_eval::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_passes::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_plugin::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&rustc_mir::DIAGNOSTICS);\n+    all_errors.extend_from_slice(&syntax::DIAGNOSTICS);\n \n     Registry::new(&all_errors)\n }"}, {"sha": "5d7c5e2829a373c7e0731bf504aa0ac9b3d21043", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -82,26 +82,27 @@ impl<'a> DiagnosticBuilder<'a> {\n             return;\n         }\n \n-        match self.level {\n+        let is_error = match self.level {\n             Level::Bug |\n             Level::Fatal |\n             Level::PhaseFatal |\n             Level::Error => {\n-                self.handler.bump_err_count();\n+                true\n             }\n \n             Level::Warning |\n             Level::Note |\n             Level::Help |\n             Level::Cancelled => {\n+                false\n             }\n-        }\n+        };\n \n         self.handler.emitter.borrow_mut().emit(&self);\n         self.cancel();\n \n-        if self.level == Level::Error {\n-            self.handler.panic_if_treat_err_as_bug();\n+        if is_error {\n+            self.handler.bump_err_count();\n         }\n \n         // if self.is_fatal() {\n@@ -210,4 +211,3 @@ impl<'a> Drop for DiagnosticBuilder<'a> {\n         }\n     }\n }\n-"}, {"sha": "159d2c7a2df1ce595c3e2b87179de107ee371eca", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -399,7 +399,6 @@ impl Handler {\n \n     pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> FatalError {\n         self.emit(&sp.into(), msg, Fatal);\n-        self.panic_if_treat_err_as_bug();\n         FatalError\n     }\n     pub fn span_fatal_with_code<S: Into<MultiSpan>>(&self,\n@@ -408,12 +407,10 @@ impl Handler {\n                                                     code: &str)\n                                                     -> FatalError {\n         self.emit_with_code(&sp.into(), msg, code, Fatal);\n-        self.panic_if_treat_err_as_bug();\n         FatalError\n     }\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.emit(&sp.into(), msg, Error);\n-        self.panic_if_treat_err_as_bug();\n     }\n     pub fn mut_span_err<'a, S: Into<MultiSpan>>(&'a self,\n                                                 sp: S,\n@@ -425,7 +422,6 @@ impl Handler {\n     }\n     pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n         self.emit_with_code(&sp.into(), msg, code, Error);\n-        self.panic_if_treat_err_as_bug();\n     }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.emit(&sp.into(), msg, Warning);\n@@ -494,6 +490,7 @@ impl Handler {\n     }\n \n     pub fn bump_err_count(&self) {\n+        self.panic_if_treat_err_as_bug();\n         self.err_count.set(self.err_count.get() + 1);\n     }\n "}, {"sha": "339e2bdc15734960534873ae46a39402f11a37f9", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -34,7 +34,7 @@ use super::file_format;\n use super::work_product;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                incremental_hashes_map: &IncrementalHashesMap,\n+                                incremental_hashes_map: IncrementalHashesMap,\n                                 metadata_hashes: &EncodedMetadataHashes,\n                                 svh: Svh) {\n     debug!(\"save_dep_graph()\");\n@@ -51,7 +51,7 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         eprintln!(\"incremental: {} edges in dep-graph\", query.graph.len_edges());\n     }\n \n-    let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n+    let mut hcx = HashContext::new(tcx, &incremental_hashes_map);\n     let preds = Predecessors::new(&query, &mut hcx);\n     let mut current_metadata_hashes = FxHashMap();\n "}, {"sha": "ca30ed4a536e2be1a0c910bb9a6a183a09fe0a9e", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -722,6 +722,46 @@ impl EarlyLintPass for IllegalFloatLiteralPattern {\n     }\n }\n \n+declare_lint! {\n+    pub UNUSED_DOC_COMMENT,\n+    Warn,\n+    \"detects doc comments that aren't used by rustdoc\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnusedDocComment;\n+\n+impl LintPass for UnusedDocComment {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![UNUSED_DOC_COMMENT]\n+    }\n+}\n+\n+impl UnusedDocComment {\n+    fn warn_if_doc<'a, 'tcx,\n+                   I: Iterator<Item=&'a ast::Attribute>,\n+                   C: LintContext<'tcx>>(&self, mut attrs: I, cx: &C) {\n+        if let Some(attr) = attrs.find(|a| a.is_value_str() && a.check_name(\"doc\")) {\n+            cx.struct_span_lint(UNUSED_DOC_COMMENT, attr.span, \"doc comment not used by rustdoc\")\n+              .emit();\n+        }\n+    }\n+}\n+\n+impl EarlyLintPass for UnusedDocComment {\n+    fn check_local(&mut self, cx: &EarlyContext, decl: &ast::Local) {\n+        self.warn_if_doc(decl.attrs.iter(), cx);\n+    }\n+\n+    fn check_arm(&mut self, cx: &EarlyContext, arm: &ast::Arm) {\n+        self.warn_if_doc(arm.attrs.iter(), cx);\n+    }\n+\n+    fn check_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr) {\n+        self.warn_if_doc(expr.attrs.iter(), cx);\n+    }\n+}\n+\n declare_lint! {\n     pub UNCONDITIONAL_RECURSION,\n     Warn,"}, {"sha": "83c00c178a0ba540ce6e3588e2efa05709e63a23", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -111,6 +111,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                        UnusedImportBraces,\n                        AnonymousParameters,\n                        IllegalFloatLiteralPattern,\n+                       UnusedDocComment,\n                        );\n \n     add_early_builtin_with_new!(sess,"}, {"sha": "d7d0dc7cb352b78d93354adbefd3f25cb92eeca4", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -44,9 +44,13 @@ impl UnusedMut {\n \n         let mut mutables = FxHashMap();\n         for p in pats {\n-            p.each_binding(|mode, id, _, path1| {\n+            p.each_binding(|_, id, span, path1| {\n+                let bm = match cx.tables.pat_binding_modes.get(&id) {\n+                    Some(&bm) => bm,\n+                    None => span_bug!(span, \"missing binding mode\"),\n+                };\n                 let name = path1.node;\n-                if let hir::BindByValue(hir::MutMutable) = mode {\n+                if let ty::BindByValue(hir::MutMutable) = bm {\n                     if !name.as_str().starts_with(\"_\") {\n                         match mutables.entry(name) {\n                             Vacant(entry) => {"}, {"sha": "0b24e55541b07269f52f3f41d5e924c834d6cb74", "filename": "src/librustc_llvm/archive_ro.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_llvm%2Farchive_ro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_llvm%2Farchive_ro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Farchive_ro.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -39,14 +39,14 @@ impl ArchiveRO {\n     ///\n     /// If this archive is used with a mutable method, then an error will be\n     /// raised.\n-    pub fn open(dst: &Path) -> Option<ArchiveRO> {\n+    pub fn open(dst: &Path) -> Result<ArchiveRO, String> {\n         return unsafe {\n             let s = path2cstr(dst);\n             let ar = ::LLVMRustOpenArchive(s.as_ptr());\n             if ar.is_null() {\n-                None\n+                Err(::last_error().unwrap_or(\"failed to open archive\".to_string()))\n             } else {\n-                Some(ArchiveRO { ptr: ar })\n+                Ok(ArchiveRO { ptr: ar })\n             }\n         };\n "}, {"sha": "20735af69e3786571d7fb6be8d4354340a609ba6", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -598,7 +598,6 @@ extern \"C\" {\n     // Operations on scalar constants\n     pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool) -> ValueRef;\n     pub fn LLVMConstIntOfArbitraryPrecision(IntTy: TypeRef, Wn: c_uint, Ws: *const u64) -> ValueRef;\n-    pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n     pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n     pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n     pub fn LLVMRustConstInt128Get(ConstantVal: ValueRef, SExt: bool,"}, {"sha": "64cbe638e8d9614c4f0b1f41f8b89a0c1b3884da", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -15,7 +15,8 @@ use schema;\n use rustc::ty::maps::QueryConfig;\n use rustc::middle::cstore::{CrateStore, CrateSource, LibSource, DepKind,\n                             NativeLibrary, MetadataLoader, LinkMeta,\n-                            LinkagePreference, LoadedMacro, EncodedMetadata};\n+                            LinkagePreference, LoadedMacro, EncodedMetadata,\n+                            EncodedMetadataHashes};\n use rustc::hir::def;\n use rustc::middle::lang_items;\n use rustc::session::Session;\n@@ -390,6 +391,7 @@ impl CrateStore for cstore::CStore {\n                 legacy: def.legacy,\n             }),\n             vis: ast::Visibility::Inherited,\n+            tokens: None,\n         })\n     }\n \n@@ -443,7 +445,7 @@ impl CrateStore for cstore::CStore {\n                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n                                  reachable: &NodeSet)\n-                                 -> EncodedMetadata\n+                                 -> (EncodedMetadata, EncodedMetadataHashes)\n     {\n         encoder::encode_metadata(tcx, link_meta, reachable)\n     }"}, {"sha": "1d8feb6b636e5fe6d52b8512155f88173a04de44", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1648,7 +1648,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ImplVisitor<'a, 'tcx> {\n pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  link_meta: &LinkMeta,\n                                  exported_symbols: &NodeSet)\n-                                 -> EncodedMetadata\n+                                 -> (EncodedMetadata, EncodedMetadataHashes)\n {\n     let mut cursor = Cursor::new(vec![]);\n     cursor.write_all(METADATA_HEADER).unwrap();\n@@ -1691,10 +1691,7 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     result[header + 2] = (pos >> 8) as u8;\n     result[header + 3] = (pos >> 0) as u8;\n \n-    EncodedMetadata {\n-        raw_data: result,\n-        hashes: metadata_hashes,\n-    }\n+    (EncodedMetadata { raw_data: result }, metadata_hashes)\n }\n \n pub fn get_repr_options<'a, 'tcx, 'gcx>(tcx: &TyCtxt<'a, 'tcx, 'gcx>, did: DefId) -> ReprOptions {"}, {"sha": "4583d80b83ddce228a8db1f122e33342d2dfa8cc", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -86,7 +86,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let tcx = this.hir.tcx();\n \n                     // Enter the remainder scope, i.e. the bindings' destruction scope.\n-                    this.push_scope(remainder_scope);\n+                    this.push_scope((remainder_scope, source_info));\n                     let_extent_stack.push(remainder_scope);\n \n                     // Declare the bindings, which may create a visibility scope."}, {"sha": "d585672d6da23969ae296b9cdecc80c96eddd571", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -242,7 +242,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::Yield { value } => {\n                 let value = unpack!(block = this.as_operand(block, scope, value));\n                 let resume = this.cfg.start_new_block();\n-                let cleanup = this.generator_drop_cleanup(expr_span);\n+                let cleanup = this.generator_drop_cleanup();\n                 this.cfg.terminate(block, source_info, TerminatorKind::Yield {\n                     value: value,\n                     resume: resume,"}, {"sha": "96df4037d05e8b93d0bc247e0699c6bb21986b4c", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -237,7 +237,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             .collect();\n \n                     let success = this.cfg.start_new_block();\n-                    let cleanup = this.diverge_cleanup(expr_span);\n+                    let cleanup = this.diverge_cleanup();\n                     this.cfg.terminate(block, source_info, TerminatorKind::Call {\n                         func: fun,\n                         args: args,"}, {"sha": "28386fa598ce6c7890ddd6762a44d3e4bb65d369", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -306,7 +306,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     let bool_ty = self.hir.bool_ty();\n                     let eq_result = self.temp(bool_ty, test.span);\n                     let eq_block = self.cfg.start_new_block();\n-                    let cleanup = self.diverge_cleanup(test.span);\n+                    let cleanup = self.diverge_cleanup();\n                     self.cfg.terminate(block, source_info, TerminatorKind::Call {\n                         func: Operand::Constant(box Constant {\n                             span: test.span,"}, {"sha": "2033131c0650ec194851add69d87a5dd005874d3", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 81, "deletions": 52, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -107,6 +107,9 @@ pub struct Scope<'tcx> {\n     /// the extent of this scope within source code.\n     extent: CodeExtent,\n \n+    /// the span of that extent\n+    extent_span: Span,\n+\n     /// Whether there's anything to do for the cleanup path, that is,\n     /// when unwinding through this scope. This includes destructors,\n     /// but not StorageDead statements, which don't get emitted at all\n@@ -116,7 +119,7 @@ pub struct Scope<'tcx> {\n     ///  * pollutting the cleanup MIR with StorageDead creates\n     ///    landing pads even though there's no actual destructors\n     ///  * freeing up stack space has no effect during unwinding\n-    pub(super) needs_cleanup: bool,\n+    needs_cleanup: bool,\n \n     /// set of lvalues to drop when exiting this scope. This starts\n     /// out empty but grows as variables are declared during the\n@@ -231,6 +234,15 @@ impl CachedBlock {\n     }\n }\n \n+impl DropKind {\n+    fn may_panic(&self) -> bool {\n+        match *self {\n+            DropKind::Value { .. } => true,\n+            DropKind::Storage => false\n+        }\n+    }\n+}\n+\n impl<'tcx> Scope<'tcx> {\n     /// Invalidate all the cached blocks in the scope.\n     ///\n@@ -318,7 +330,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_opt_scope(opt_extent={:?}, block={:?})\", opt_extent, block);\n-        if let Some(extent) = opt_extent { self.push_scope(extent.0); }\n+        if let Some(extent) = opt_extent { self.push_scope(extent); }\n         let rv = unpack!(block = f(self));\n         if let Some(extent) = opt_extent {\n             unpack!(block = self.pop_scope(extent, block));\n@@ -337,7 +349,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         where F: FnOnce(&mut Builder<'a, 'gcx, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n-        self.push_scope(extent.0);\n+        self.push_scope(extent);\n         let rv = unpack!(block = f(self));\n         unpack!(block = self.pop_scope(extent, block));\n         debug!(\"in_scope: exiting extent={:?} block={:?}\", extent, block);\n@@ -348,12 +360,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, extent: CodeExtent) {\n+    pub fn push_scope(&mut self, extent: (CodeExtent, SourceInfo)) {\n         debug!(\"push_scope({:?})\", extent);\n         let vis_scope = self.visibility_scope;\n         self.scopes.push(Scope {\n             visibility_scope: vis_scope,\n-            extent: extent,\n+            extent: extent.0,\n+            extent_span: extent.1.span,\n             needs_cleanup: false,\n             drops: vec![],\n             free: None,\n@@ -370,9 +383,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                      mut block: BasicBlock)\n                      -> BlockAnd<()> {\n         debug!(\"pop_scope({:?}, {:?})\", extent, block);\n-        // We need to have `cached_block`s available for all the drops, so we call diverge_cleanup\n-        // to make sure all the `cached_block`s are filled in.\n-        self.diverge_cleanup(extent.1.span);\n+        // If we are emitting a `drop` statement, we need to have the cached\n+        // diverge cleanup pads ready in case that drop panics.\n+        let may_panic =\n+            self.scopes.last().unwrap().drops.iter().any(|s| s.kind.may_panic());\n+        if may_panic {\n+            self.diverge_cleanup();\n+        }\n         let scope = self.scopes.pop().unwrap();\n         assert_eq!(scope.extent, extent.0);\n         unpack!(block = build_scope_drops(&mut self.cfg,\n@@ -404,6 +421,15 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let len = self.scopes.len();\n         assert!(scope_count < len, \"should not use `exit_scope` to pop ALL scopes\");\n         let tmp = self.get_unit_temp();\n+\n+        // If we are emitting a `drop` statement, we need to have the cached\n+        // diverge cleanup pads ready in case that drop panics.\n+        let may_panic = self.scopes[(len - scope_count)..].iter()\n+            .any(|s| s.drops.iter().any(|s| s.kind.may_panic()));\n+        if may_panic {\n+            self.diverge_cleanup();\n+        }\n+\n         {\n         let mut rest = &mut self.scopes[(len - scope_count)..];\n         while let Some((scope, rest_)) = {rest}.split_last_mut() {\n@@ -446,13 +472,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     ///\n     /// This path terminates in GeneratorDrop. Returns the start of the path.\n     /// None indicates there\u2019s no cleanup to do at this point.\n-    pub fn generator_drop_cleanup(&mut self, span: Span) -> Option<BasicBlock> {\n+    pub fn generator_drop_cleanup(&mut self) -> Option<BasicBlock> {\n         if !self.scopes.iter().any(|scope| scope.needs_cleanup) {\n             return None;\n         }\n \n         // Fill in the cache\n-        self.diverge_cleanup_gen(span, true);\n+        self.diverge_cleanup_gen(true);\n \n         let src_info = self.scopes[0].source_info(self.fn_span);\n         let tmp = self.get_unit_temp();\n@@ -715,11 +741,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// This path terminates in Resume. Returns the start of the path.\n     /// See module comment for more details. None indicates there\u2019s no\n     /// cleanup to do at this point.\n-    pub fn diverge_cleanup(&mut self, span: Span) -> Option<BasicBlock> {\n-        self.diverge_cleanup_gen(span, false)\n+    pub fn diverge_cleanup(&mut self) -> Option<BasicBlock> {\n+        self.diverge_cleanup_gen(false)\n     }\n \n-    fn diverge_cleanup_gen(&mut self, span: Span, generator_drop: bool) -> Option<BasicBlock> {\n+    fn diverge_cleanup_gen(&mut self, generator_drop: bool) -> Option<BasicBlock> {\n         if !self.scopes.iter().any(|scope| scope.needs_cleanup) {\n             return None;\n         }\n@@ -756,7 +782,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             target = build_diverge_scope(hir.tcx(),\n                                          cfg,\n                                          &unit_temp,\n-                                         span,\n+                                         scope.extent_span,\n                                          scope,\n                                          target,\n                                          generator_drop);\n@@ -775,7 +801,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n         let source_info = self.source_info(span);\n         let next_target = self.cfg.start_new_block();\n-        let diverge_target = self.diverge_cleanup(span);\n+        let diverge_target = self.diverge_cleanup();\n         self.cfg.terminate(block, source_info,\n                            TerminatorKind::Drop {\n                                location: location,\n@@ -793,7 +819,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                   value: Operand<'tcx>) -> BlockAnd<()> {\n         let source_info = self.source_info(span);\n         let next_target = self.cfg.start_new_block();\n-        let diverge_target = self.diverge_cleanup(span);\n+        let diverge_target = self.diverge_cleanup();\n         self.cfg.terminate(block, source_info,\n                            TerminatorKind::DropAndReplace {\n                                location: location,\n@@ -816,7 +842,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let source_info = self.source_info(span);\n \n         let success_block = self.cfg.start_new_block();\n-        let cleanup = self.diverge_cleanup(span);\n+        let cleanup = self.diverge_cleanup();\n \n         self.cfg.terminate(block, source_info,\n                            TerminatorKind::Assert {\n@@ -839,51 +865,54 @@ fn build_scope_drops<'tcx>(cfg: &mut CFG<'tcx>,\n                            arg_count: usize,\n                            generator_drop: bool)\n                            -> BlockAnd<()> {\n-\n+    debug!(\"build_scope_drops({:?} -> {:?})\", block, scope);\n     let mut iter = scope.drops.iter().rev().peekable();\n     while let Some(drop_data) = iter.next() {\n         let source_info = scope.source_info(drop_data.span);\n-        if let DropKind::Value { .. } = drop_data.kind {\n-            // Try to find the next block with its cached block\n-            // for us to diverge into in case the drop panics.\n-            let on_diverge = iter.peek().iter().filter_map(|dd| {\n-                match dd.kind {\n-                    DropKind::Value { cached_block } => cached_block.get(generator_drop),\n-                    DropKind::Storage => None\n-                }\n-            }).next();\n-            // If there\u2019s no `cached_block`s within current scope,\n-            // we must look for one in the enclosing scope.\n-            let on_diverge = on_diverge.or_else(||{\n-                earlier_scopes.iter().rev().flat_map(|s| s.cached_block(generator_drop)).next()\n-            });\n-            let next = cfg.start_new_block();\n-            cfg.terminate(block, source_info, TerminatorKind::Drop {\n-                location: drop_data.location.clone(),\n-                target: next,\n-                unwind: on_diverge\n-            });\n-            block = next;\n-        }\n         match drop_data.kind {\n-            DropKind::Value { .. } |\n-            DropKind::Storage => {\n-                // We do not need to emit these for generator drops\n-                if generator_drop {\n-                    continue\n-                }\n-\n-                // Only temps and vars need their storage dead.\n-                match drop_data.location {\n-                    Lvalue::Local(index) if index.index() > arg_count => {}\n-                    _ => continue\n-                }\n+            DropKind::Value { .. } => {\n+                // Try to find the next block with its cached block\n+                // for us to diverge into in case the drop panics.\n+                let on_diverge = iter.peek().iter().filter_map(|dd| {\n+                    match dd.kind {\n+                        DropKind::Value {\n+                            cached_block: CachedBlock {\n+                                unwind: None,\n+                                generator_drop: None,\n+                            }\n+                        } => {\n+                            span_bug!(drop_data.span, \"cached block not present?\")\n+                        }\n+                        DropKind::Value { cached_block } => cached_block.get(generator_drop),\n+                        DropKind::Storage => None\n+                    }\n+                }).next();\n+                // If there\u2019s no `cached_block`s within current scope,\n+                // we must look for one in the enclosing scope.\n+                let on_diverge = on_diverge.or_else(|| {\n+                    earlier_scopes.iter().rev().flat_map(|s| s.cached_block(generator_drop)).next()\n+                });\n+                let next = cfg.start_new_block();\n+                cfg.terminate(block, source_info, TerminatorKind::Drop {\n+                    location: drop_data.location.clone(),\n+                    target: next,\n+                    unwind: on_diverge\n+                });\n+                block = next;\n+            }\n+            DropKind::Storage => {}\n+        }\n \n+        // Drop the storage for both value and storage drops.\n+        // Only temps and vars need their storage dead.\n+        match drop_data.location {\n+            Lvalue::Local(index) if index.index() > arg_count => {\n                 cfg.push(block, Statement {\n                     source_info: source_info,\n                     kind: StatementKind::StorageDead(drop_data.location.clone())\n                 });\n             }\n+            _ => continue\n         }\n     }\n     block.unit()"}, {"sha": "24d5aa9e46bf232767ee2d41da9bf17117b03482", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -289,6 +289,7 @@ pub(crate) fn drop_flag_effects_for_location<'a, 'tcx, F>(\n             mir::StatementKind::StorageDead(_) |\n             mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::EndRegion(_) |\n+            mir::StatementKind::Validate(..) |\n             mir::StatementKind::Nop => {}\n         },\n         None => {"}, {"sha": "d5bdc71a705c5da5954ea8eb2f5a9ae1ede27759", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -486,6 +486,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n             mir::StatementKind::StorageDead(_) |\n             mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::EndRegion(_) |\n+            mir::StatementKind::Validate(..) |\n             mir::StatementKind::Nop => {}\n         }\n     }"}, {"sha": "1255209322b0ee4245384f21138bb5cb9e5d8c47", "filename": "src/librustc_mir/dataflow/move_paths/abs_domain.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fabs_domain.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -23,11 +23,14 @@\n \n use rustc::mir::LvalueElem;\n use rustc::mir::{Operand, ProjectionElem};\n+use rustc::ty::Ty;\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct AbstractOperand;\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct AbstractType;\n pub type AbstractElem<'tcx> =\n-    ProjectionElem<'tcx, AbstractOperand>;\n+    ProjectionElem<'tcx, AbstractOperand, AbstractType>;\n \n pub trait Lift {\n     type Abstract;\n@@ -37,14 +40,18 @@ impl<'tcx> Lift for Operand<'tcx> {\n     type Abstract = AbstractOperand;\n     fn lift(&self) -> Self::Abstract { AbstractOperand }\n }\n+impl<'tcx> Lift for Ty<'tcx> {\n+    type Abstract = AbstractType;\n+    fn lift(&self) -> Self::Abstract { AbstractType }\n+}\n impl<'tcx> Lift for LvalueElem<'tcx> {\n     type Abstract = AbstractElem<'tcx>;\n     fn lift(&self) -> Self::Abstract {\n         match *self {\n             ProjectionElem::Deref =>\n                 ProjectionElem::Deref,\n             ProjectionElem::Field(ref f, ty) =>\n-                ProjectionElem::Field(f.clone(), ty.clone()),\n+                ProjectionElem::Field(f.clone(), ty.lift()),\n             ProjectionElem::Index(ref i) =>\n                 ProjectionElem::Index(i.lift()),\n             ProjectionElem::Subslice {from, to} =>"}, {"sha": "f67891d54fda3f568b16ba3863f66f601f78e7e5", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -416,6 +416,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n             }\n             StatementKind::InlineAsm { .. } |\n             StatementKind::EndRegion(_) |\n+            StatementKind::Validate(..) |\n             StatementKind::Nop => {}\n         }\n     }"}, {"sha": "6530b356e33f43f024a75e5fd135e7fcf1158b23", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -122,10 +122,8 @@ On the other hand, static and constant pointers can point either to\n a known numeric address or to the address of a symbol.\n \n ```\n+static MY_STATIC: u32 = 42;\n static MY_STATIC_ADDR: &'static u32 = &MY_STATIC;\n-// ... and also\n-static MY_STATIC_ADDR2: *const u32 = &MY_STATIC;\n-\n const CONST_ADDR: *const u8 = 0x5f3759df as *const u8;\n ```\n \n@@ -160,6 +158,16 @@ Remember: you can't use a function call inside a const's initialization\n expression! However, you can totally use it anywhere else:\n \n ```\n+enum Test {\n+    V1\n+}\n+\n+impl Test {\n+    fn func(&self) -> i32 {\n+        12\n+    }\n+}\n+\n fn main() {\n     const FOO: Test = Test::V1;\n "}, {"sha": "ea8624930e5f5dd05e4d308839062dac4fc29b69", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -57,3 +57,5 @@ pub fn provide(providers: &mut Providers) {\n     shim::provide(providers);\n     transform::provide(providers);\n }\n+\n+__build_diagnostic_array! { librustc_mir, DIAGNOSTICS }"}, {"sha": "52c2eaa7cb6325f2e64a6c012d50efd966778adf", "filename": "src/librustc_mir/transform/add_validation.rs", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_validation.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,390 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass adds validation calls (AcquireValid, ReleaseValid) where appropriate.\n+//! It has to be run really early, before transformations like inlining, because\n+//! introducing these calls *adds* UB -- so, conceptually, this pass is actually part\n+//! of MIR building, and only after this pass we think of the program has having the\n+//! normal MIR semantics.\n+\n+use rustc::ty::{self, TyCtxt, RegionKind};\n+use rustc::hir;\n+use rustc::mir::*;\n+use rustc::mir::transform::{MirPass, MirSource};\n+use rustc::middle::region::CodeExtent;\n+\n+pub struct AddValidation;\n+\n+/// Determine the \"context\" of the lval: Mutability and region.\n+fn lval_context<'a, 'tcx, D>(\n+    lval: &Lvalue<'tcx>,\n+    local_decls: &D,\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>\n+) -> (Option<CodeExtent>, hir::Mutability)\n+    where D: HasLocalDecls<'tcx>\n+{\n+    use rustc::mir::Lvalue::*;\n+\n+    match *lval {\n+        Local { .. } => (None, hir::MutMutable),\n+        Static(_) => (None, hir::MutImmutable),\n+        Projection(ref proj) => {\n+            match proj.elem {\n+                ProjectionElem::Deref => {\n+                    // Computing the inside the recursion makes this quadratic.\n+                    // We don't expect deep paths though.\n+                    let ty = proj.base.ty(local_decls, tcx).to_ty(tcx);\n+                    // A Deref projection may restrict the context, this depends on the type\n+                    // being deref'd.\n+                    let context = match ty.sty {\n+                        ty::TyRef(re, tam) => {\n+                            let re = match re {\n+                                &RegionKind::ReScope(ce) => Some(ce),\n+                                &RegionKind::ReErased =>\n+                                    bug!(\"AddValidation pass must be run before erasing lifetimes\"),\n+                                _ => None\n+                            };\n+                            (re, tam.mutbl)\n+                        }\n+                        ty::TyRawPtr(_) =>\n+                            // There is no guarantee behind even a mutable raw pointer,\n+                            // no write locks are acquired there, so we also don't want to\n+                            // release any.\n+                            (None, hir::MutImmutable),\n+                        ty::TyAdt(adt, _) if adt.is_box() => (None, hir::MutMutable),\n+                        _ => bug!(\"Deref on a non-pointer type {:?}\", ty),\n+                    };\n+                    // \"Intersect\" this restriction with proj.base.\n+                    if let (Some(_), hir::MutImmutable) = context {\n+                        // This is already as restricted as it gets, no need to even recurse\n+                        context\n+                    } else {\n+                        let base_context = lval_context(&proj.base, local_decls, tcx);\n+                        // The region of the outermost Deref is always most restrictive.\n+                        let re = context.0.or(base_context.0);\n+                        let mutbl = context.1.and(base_context.1);\n+                        (re, mutbl)\n+                    }\n+\n+                }\n+                _ => lval_context(&proj.base, local_decls, tcx),\n+            }\n+        }\n+    }\n+}\n+\n+/// Check if this function contains an unsafe block or is an unsafe function.\n+fn fn_contains_unsafe<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource) -> bool {\n+    use rustc::hir::intravisit::{self, Visitor, FnKind};\n+    use rustc::hir::map::blocks::FnLikeNode;\n+    use rustc::hir::map::Node;\n+\n+    /// Decide if this is an unsafe block\n+    fn block_is_unsafe(block: &hir::Block) -> bool {\n+        use rustc::hir::BlockCheckMode::*;\n+\n+        match block.rules {\n+            UnsafeBlock(_) | PushUnsafeBlock(_) => true,\n+            // For PopUnsafeBlock, we don't actually know -- but we will always also check all\n+            // parent blocks, so we can safely declare the PopUnsafeBlock to not be unsafe.\n+            DefaultBlock | PopUnsafeBlock(_) => false,\n+        }\n+    }\n+\n+    /// Decide if this FnLike is a closure\n+    fn fn_is_closure<'a>(fn_like: FnLikeNode<'a>) -> bool {\n+        match fn_like.kind() {\n+            FnKind::Closure(_) => true,\n+            FnKind::Method(..) | FnKind::ItemFn(..) => false,\n+        }\n+    }\n+\n+    let fn_like = match src {\n+        MirSource::Fn(node_id) => {\n+            match FnLikeNode::from_node(tcx.hir.get(node_id)) {\n+                Some(fn_like) => fn_like,\n+                None => return false, // e.g. struct ctor shims -- such auto-generated code cannot\n+                                      // contain unsafe.\n+            }\n+        },\n+        _ => return false, // only functions can have unsafe\n+    };\n+\n+    // Test if the function is marked unsafe.\n+    if fn_like.unsafety() == hir::Unsafety::Unsafe {\n+        return true;\n+    }\n+\n+    // For closures, we need to walk up the parents and see if we are inside an unsafe fn or\n+    // unsafe block.\n+    if fn_is_closure(fn_like) {\n+        let mut cur = fn_like.id();\n+        loop {\n+            // Go further upwards.\n+            cur = tcx.hir.get_parent_node(cur);\n+            let node = tcx.hir.get(cur);\n+            // Check if this is an unsafe function\n+            if let Some(fn_like) = FnLikeNode::from_node(node) {\n+                if !fn_is_closure(fn_like) {\n+                    if fn_like.unsafety() == hir::Unsafety::Unsafe {\n+                        return true;\n+                    }\n+                }\n+            }\n+            // Check if this is an unsafe block, or an item\n+            match node {\n+                Node::NodeExpr(&hir::Expr { node: hir::ExprBlock(ref block), ..}) => {\n+                    if block_is_unsafe(&*block) {\n+                        // Found an unsafe block, we can bail out here.\n+                        return true;\n+                    }\n+                }\n+                Node::NodeItem(..) => {\n+                    // No walking up beyond items.  This makes sure the loop always terminates.\n+                    break;\n+                }\n+                _ => {},\n+            }\n+        }\n+    }\n+\n+    // Visit the entire body of the function and check for unsafe blocks in there\n+    struct FindUnsafe {\n+        found_unsafe: bool,\n+    }\n+    let mut finder = FindUnsafe { found_unsafe: false };\n+    // Run the visitor on the NodeId we got.  Seems like there is no uniform way to do that.\n+    finder.visit_body(tcx.hir.body(fn_like.body()));\n+\n+    impl<'tcx> Visitor<'tcx> for FindUnsafe {\n+        fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+            intravisit::NestedVisitorMap::None\n+        }\n+\n+        fn visit_block(&mut self, b: &'tcx hir::Block) {\n+            if self.found_unsafe { return; } // short-circuit\n+\n+            if block_is_unsafe(b) {\n+                // We found an unsafe block.  We can stop searching.\n+                self.found_unsafe = true;\n+            } else {\n+                // No unsafe block here, go on searching.\n+                intravisit::walk_block(self, b);\n+            }\n+        }\n+    }\n+\n+    finder.found_unsafe\n+}\n+\n+impl MirPass for AddValidation {\n+    fn run_pass<'a, 'tcx>(&self,\n+                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          src: MirSource,\n+                          mir: &mut Mir<'tcx>)\n+    {\n+        let emit_validate = tcx.sess.opts.debugging_opts.mir_emit_validate;\n+        if emit_validate == 0 {\n+            return;\n+        }\n+        let restricted_validation = emit_validate == 1 && fn_contains_unsafe(tcx, src);\n+        let local_decls = mir.local_decls.clone(); // FIXME: Find a way to get rid of this clone.\n+\n+        // Convert an lvalue to a validation operand.\n+        let lval_to_operand = |lval: Lvalue<'tcx>| -> ValidationOperand<'tcx, Lvalue<'tcx>> {\n+            let (re, mutbl) = lval_context(&lval, &local_decls, tcx);\n+            let ty = lval.ty(&local_decls, tcx).to_ty(tcx);\n+            ValidationOperand { lval, ty, re, mutbl }\n+        };\n+\n+        // Emit an Acquire at the beginning of the given block.  If we are in restricted emission\n+        // mode (mir_emit_validate=1), also emit a Release immediately after the Acquire.\n+        let emit_acquire = |block: &mut BasicBlockData<'tcx>, source_info, operands: Vec<_>| {\n+            if operands.len() == 0 {\n+                return; // Nothing to do\n+            }\n+            // Emit the release first, to avoid cloning if we do not emit it\n+            if restricted_validation {\n+                let release_stmt = Statement {\n+                    source_info,\n+                    kind: StatementKind::Validate(ValidationOp::Release, operands.clone()),\n+                };\n+                block.statements.insert(0, release_stmt);\n+            }\n+            // Now, the acquire\n+            let acquire_stmt = Statement {\n+                source_info,\n+                kind: StatementKind::Validate(ValidationOp::Acquire, operands),\n+            };\n+            block.statements.insert(0, acquire_stmt);\n+        };\n+\n+        // PART 1\n+        // Add an AcquireValid at the beginning of the start block.\n+        {\n+            let source_info = SourceInfo {\n+                scope: ARGUMENT_VISIBILITY_SCOPE,\n+                span: mir.span, // FIXME: Consider using just the span covering the function\n+                                // argument declaration.\n+            };\n+            // Gather all arguments, skip return value.\n+            let operands = mir.local_decls.iter_enumerated().skip(1).take(mir.arg_count)\n+                    .map(|(local, _)| lval_to_operand(Lvalue::Local(local))).collect();\n+            emit_acquire(&mut mir.basic_blocks_mut()[START_BLOCK], source_info, operands);\n+        }\n+\n+        // PART 2\n+        // Add ReleaseValid/AcquireValid around function call terminators.  We don't use a visitor\n+        // because we need to access the block that a Call jumps to.\n+        let mut returns : Vec<(SourceInfo, Lvalue<'tcx>, BasicBlock)> = Vec::new();\n+        for block_data in mir.basic_blocks_mut() {\n+            match block_data.terminator {\n+                Some(Terminator { kind: TerminatorKind::Call { ref args, ref destination, .. },\n+                                  source_info }) => {\n+                    // Before the call: Release all arguments *and* the return value.\n+                    // The callee may write into the return value!  Note that this relies\n+                    // on \"release of uninitialized\" to be a NOP.\n+                    if !restricted_validation {\n+                        let release_stmt = Statement {\n+                            source_info,\n+                            kind: StatementKind::Validate(ValidationOp::Release,\n+                                destination.iter().map(|dest| lval_to_operand(dest.0.clone()))\n+                                .chain(\n+                                    args.iter().filter_map(|op| {\n+                                        match op {\n+                                            &Operand::Consume(ref lval) =>\n+                                                Some(lval_to_operand(lval.clone())),\n+                                            &Operand::Constant(..) => { None },\n+                                        }\n+                                    })\n+                                ).collect())\n+                        };\n+                        block_data.statements.push(release_stmt);\n+                    }\n+                    // Remember the return destination for later\n+                    if let &Some(ref destination) = destination {\n+                        returns.push((source_info, destination.0.clone(), destination.1));\n+                    }\n+                }\n+                Some(Terminator { kind: TerminatorKind::Drop { location: ref lval, .. },\n+                                  source_info }) |\n+                Some(Terminator { kind: TerminatorKind::DropAndReplace { location: ref lval, .. },\n+                                  source_info }) => {\n+                    // Before the call: Release all arguments\n+                    if !restricted_validation {\n+                        let release_stmt = Statement {\n+                            source_info,\n+                            kind: StatementKind::Validate(ValidationOp::Release,\n+                                    vec![lval_to_operand(lval.clone())]),\n+                        };\n+                        block_data.statements.push(release_stmt);\n+                    }\n+                    // drop doesn't return anything, so we need no acquire.\n+                }\n+                _ => {\n+                    // Not a block ending in a Call -> ignore.\n+                }\n+            }\n+        }\n+        // Now we go over the returns we collected to acquire the return values.\n+        for (source_info, dest_lval, dest_block) in returns {\n+            emit_acquire(\n+                &mut mir.basic_blocks_mut()[dest_block],\n+                source_info,\n+                vec![lval_to_operand(dest_lval)]\n+            );\n+        }\n+\n+        if restricted_validation {\n+            // No part 3 for us.\n+            return;\n+        }\n+\n+        // PART 3\n+        // Add ReleaseValid/AcquireValid around Ref and Cast.  Again an iterator does not seem very\n+        // suited as we need to add new statements before and after each Ref.\n+        for block_data in mir.basic_blocks_mut() {\n+            // We want to insert statements around Ref commands as we iterate.  To this end, we\n+            // iterate backwards using indices.\n+            for i in (0..block_data.statements.len()).rev() {\n+                match block_data.statements[i].kind {\n+                    // When the borrow of this ref expires, we need to recover validation.\n+                    StatementKind::Assign(_, Rvalue::Ref(_, _, _)) => {\n+                        // Due to a lack of NLL; we can't capture anything directly here.\n+                        // Instead, we have to re-match and clone there.\n+                        let (dest_lval, re, src_lval) = match block_data.statements[i].kind {\n+                            StatementKind::Assign(ref dest_lval,\n+                                                  Rvalue::Ref(re, _, ref src_lval)) => {\n+                                (dest_lval.clone(), re, src_lval.clone())\n+                            },\n+                            _ => bug!(\"We already matched this.\"),\n+                        };\n+                        // So this is a ref, and we got all the data we wanted.\n+                        // Do an acquire of the result -- but only what it points to, so add a Deref\n+                        // projection.\n+                        let dest_lval = Projection { base: dest_lval, elem: ProjectionElem::Deref };\n+                        let dest_lval = Lvalue::Projection(Box::new(dest_lval));\n+                        let acquire_stmt = Statement {\n+                            source_info: block_data.statements[i].source_info,\n+                            kind: StatementKind::Validate(ValidationOp::Acquire,\n+                                    vec![lval_to_operand(dest_lval)]),\n+                        };\n+                        block_data.statements.insert(i+1, acquire_stmt);\n+\n+                        // The source is released until the region of the borrow ends.\n+                        let op = match re {\n+                            &RegionKind::ReScope(ce) => ValidationOp::Suspend(ce),\n+                            &RegionKind::ReErased =>\n+                                bug!(\"AddValidation pass must be run before erasing lifetimes\"),\n+                            _ => ValidationOp::Release,\n+                        };\n+                        let release_stmt = Statement {\n+                            source_info: block_data.statements[i].source_info,\n+                            kind: StatementKind::Validate(op, vec![lval_to_operand(src_lval)]),\n+                        };\n+                        block_data.statements.insert(i, release_stmt);\n+                    }\n+                    // Casts can change what validation does (e.g. unsizing)\n+                    StatementKind::Assign(_, Rvalue::Cast(kind, Operand::Consume(_), _))\n+                        if kind != CastKind::Misc =>\n+                    {\n+                        // Due to a lack of NLL; we can't capture anything directly here.\n+                        // Instead, we have to re-match and clone there.\n+                        let (dest_lval, src_lval) = match block_data.statements[i].kind {\n+                            StatementKind::Assign(ref dest_lval,\n+                                    Rvalue::Cast(_, Operand::Consume(ref src_lval), _)) =>\n+                            {\n+                                (dest_lval.clone(), src_lval.clone())\n+                            },\n+                            _ => bug!(\"We already matched this.\"),\n+                        };\n+\n+                        // Acquire of the result\n+                        let acquire_stmt = Statement {\n+                            source_info: block_data.statements[i].source_info,\n+                            kind: StatementKind::Validate(ValidationOp::Acquire,\n+                                    vec![lval_to_operand(dest_lval)]),\n+                        };\n+                        block_data.statements.insert(i+1, acquire_stmt);\n+\n+                        // Release of the input\n+                        let release_stmt = Statement {\n+                            source_info: block_data.statements[i].source_info,\n+                            kind: StatementKind::Validate(ValidationOp::Release,\n+                                                            vec![lval_to_operand(src_lval)]),\n+                        };\n+                        block_data.statements.insert(i, release_stmt);\n+                    }\n+                    _ => {},\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "f06b88551d11d267967bac3c32f4ba708f7a3b1a", "filename": "src/librustc_mir/transform/clean_end_regions.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fclean_end_regions.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -24,8 +24,8 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc::middle::region::CodeExtent;\n use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::{BasicBlock, Location, Mir, Rvalue, Statement, StatementKind};\n-use rustc::mir::visit::{MutVisitor, Visitor};\n-use rustc::ty::{RegionKind, TyCtxt};\n+use rustc::mir::visit::{MutVisitor, Visitor, Lookup};\n+use rustc::ty::{Ty, RegionKind, TyCtxt};\n \n pub struct CleanEndRegions;\n \n@@ -42,7 +42,9 @@ impl MirPass for CleanEndRegions {\n                           _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _source: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        let mut gather = GatherBorrowedRegions { seen_regions: FxHashSet() };\n+        let mut gather = GatherBorrowedRegions {\n+            seen_regions: FxHashSet()\n+        };\n         gather.visit_mir(mir);\n \n         let mut delete = DeleteTrivialEndRegions { seen_regions: &mut gather.seen_regions };\n@@ -54,13 +56,25 @@ impl<'tcx> Visitor<'tcx> for GatherBorrowedRegions {\n     fn visit_rvalue(&mut self,\n                     rvalue: &Rvalue<'tcx>,\n                     location: Location) {\n+        // Gather regions that are used for borrows\n         if let Rvalue::Ref(r, _, _) = *rvalue {\n             if let RegionKind::ReScope(ce) = *r {\n                 self.seen_regions.insert(ce);\n             }\n         }\n         self.super_rvalue(rvalue, location);\n     }\n+\n+    fn visit_ty(&mut self, ty: &Ty<'tcx>, _: Lookup) {\n+        // Gather regions that occur in types\n+        for re in ty.walk().flat_map(|t| t.regions()) {\n+            match *re {\n+                RegionKind::ReScope(ce) => { self.seen_regions.insert(ce); }\n+                _ => {},\n+            }\n+        }\n+        self.super_ty(ty);\n+    }\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for DeleteTrivialEndRegions<'a> {"}, {"sha": "baf0522896c9c8c8120ff7e1d1531c0a8cd1d7c1", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -11,6 +11,8 @@\n //! This pass erases all early-bound regions from the types occuring in the MIR.\n //! We want to do this once just before trans, so trans does not have to take\n //! care erasing regions all over the place.\n+//! NOTE:  We do NOT erase regions of statements that are relevant for\n+//! \"types-as-contracts\"-validation, namely, AcquireValid, ReleaseValid, and EndRegion.\n \n use rustc::ty::subst::Substs;\n use rustc::ty::{Ty, TyCtxt, ClosureSubsts};\n@@ -20,20 +22,24 @@ use rustc::mir::transform::{MirPass, MirSource};\n \n struct EraseRegionsVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    in_validation_statement: bool,\n }\n \n impl<'a, 'tcx> EraseRegionsVisitor<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Self {\n         EraseRegionsVisitor {\n-            tcx: tcx\n+            tcx: tcx,\n+            in_validation_statement: false,\n         }\n     }\n }\n \n impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: Lookup) {\n-        let old_ty = *ty;\n-        *ty = self.tcx.erase_regions(&old_ty);\n+        if !self.in_validation_statement {\n+            *ty = self.tcx.erase_regions(&{*ty});\n+        }\n+        self.super_ty(ty);\n     }\n \n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, _: Location) {\n@@ -71,10 +77,20 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n                        block: BasicBlock,\n                        statement: &mut Statement<'tcx>,\n                        location: Location) {\n-        if let StatementKind::EndRegion(_) = statement.kind {\n-            statement.kind = StatementKind::Nop;\n+        // Do NOT delete EndRegion if validation statements are emitted.\n+        // Validation needs EndRegion.\n+        if self.tcx.sess.opts.debugging_opts.mir_emit_validate == 0 {\n+            if let StatementKind::EndRegion(_) = statement.kind {\n+                statement.kind = StatementKind::Nop;\n+            }\n         }\n+\n+        self.in_validation_statement = match statement.kind {\n+            StatementKind::Validate(..) => true,\n+            _ => false,\n+        };\n         self.super_statement(block, statement, location);\n+        self.in_validation_statement = false;\n     }\n }\n "}, {"sha": "555bea63c27dd4faccfbf2bcb07e3747558bbd86", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -24,6 +24,7 @@ use syntax::ast;\n use syntax_pos::{DUMMY_SP, Span};\n use transform;\n \n+pub mod add_validation;\n pub mod clean_end_regions;\n pub mod simplify_branches;\n pub mod simplify;"}, {"sha": "4f0d6a51bfdbb1d02c3c0db94b0f572a50305af2", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -910,6 +910,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 StatementKind::StorageDead(_) |\n                 StatementKind::InlineAsm {..} |\n                 StatementKind::EndRegion(_) |\n+                StatementKind::Validate(..) |\n                 StatementKind::Nop => {}\n             }\n         });"}, {"sha": "268e7a4c185b00cd8eae1559064b164619d79e1d", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -161,6 +161,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             mir::StatementKind::StorageDead(_) |\n             mir::StatementKind::InlineAsm { .. } |\n             mir::StatementKind::EndRegion(_) |\n+            mir::StatementKind::Validate(..) |\n             mir::StatementKind::Nop => continue,\n             mir::StatementKind::SetDiscriminant{ .. } =>\n                 span_bug!(stmt.source_info.span,"}, {"sha": "a1d56ccd874a11a228d6a3e47c71ad6a94a8166f", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -105,6 +105,8 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n     }\n \n     pub fn simplify(mut self) {\n+        self.strip_nops();\n+\n         loop {\n             let mut changed = false;\n \n@@ -141,8 +143,6 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n \n             if !changed { break }\n         }\n-\n-        self.strip_nops()\n     }\n \n     // Collapse a goto chain starting from `start`"}, {"sha": "888e5be10dda5b992f9b5f7d4abaa912bf38e4d7", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -432,6 +432,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             }\n             StatementKind::InlineAsm { .. } |\n             StatementKind::EndRegion(_) |\n+            StatementKind::Validate(..) |\n             StatementKind::Nop => {}\n         }\n     }"}, {"sha": "946e9ff4747439b27283ecf6435e8a3919bec239", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -65,6 +65,7 @@ impl<'tcx> Visitor<'tcx> for BlockInfoVisitor {\n \n                 LvalueContext::Inspect |\n                 LvalueContext::Consume |\n+                LvalueContext::Validate |\n \n                 // We consider drops to always be uses of locals.\n                 // Drop eloboration should be run before this analysis otherwise"}, {"sha": "907a258a12dc68063df770b6ab2425a0bd40635e", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -221,7 +221,7 @@ while break {}\n \n To fix this, add a label specifying which loop is being broken out of:\n ```\n-`foo: while break `foo {}\n+'foo: while break 'foo {}\n ```\n \"##\n }"}, {"sha": "ed5ea69d04ea3226d17b5623f90968eda9bf1d7f", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -45,3 +45,5 @@ pub mod loops;\n pub mod mir_stats;\n pub mod no_asm;\n pub mod static_recursion;\n+\n+__build_diagnostic_array! { librustc_passes, DIAGNOSTICS }"}, {"sha": "aff792f10cedb4c51df807b9cc228f08fe467f95", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -126,6 +126,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.record(match statement.kind {\n             StatementKind::Assign(..) => \"StatementKind::Assign\",\n             StatementKind::EndRegion(..) => \"StatementKind::EndRegion\",\n+            StatementKind::Validate(..) => \"StatementKind::Validate\",\n             StatementKind::SetDiscriminant { .. } => \"StatementKind::SetDiscriminant\",\n             StatementKind::StorageLive(..) => \"StatementKind::StorageLive\",\n             StatementKind::StorageDead(..) => \"StatementKind::StorageDead\","}, {"sha": "60074cce2b9a326504f1d3df2287a4caa5f3664b", "filename": "src/librustc_platform_intrinsics/powerpc.rs", "status": "modified", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_platform_intrinsics%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_platform_intrinsics%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Fpowerpc.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -27,6 +27,121 @@ pub fn find(name: &str) -> Option<Intrinsic> {\n             output: &::I32x4,\n             definition: Named(\"llvm.ppc.altivec.vperm\")\n         },\n+        \"_vec_mradds\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 3] = [&::I16x8, &::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vmhraddshs\")\n+        },\n+        \"_vec_cmpb\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::F32x4, &::F32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vcmpbfp\")\n+        },\n+        \"_vec_cmpeqb\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I8x16,\n+            definition: Named(\"llvm.ppc.altivec.vcmpequb\")\n+        },\n+        \"_vec_cmpeqh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vcmpequh\")\n+        },\n+        \"_vec_cmpeqw\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vcmpequw\")\n+        },\n+        \"_vec_cmpgtub\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U8x16]; &INPUTS },\n+            output: &::I8x16,\n+            definition: Named(\"llvm.ppc.altivec.vcmpgtub\")\n+        },\n+        \"_vec_cmpgtuh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vcmpgtuh\")\n+        },\n+        \"_vec_cmpgtuw\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x4, &::U32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vcmpgtuw\")\n+        },\n+        \"_vec_cmpgtsb\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I8x16,\n+            definition: Named(\"llvm.ppc.altivec.vcmpgtsb\")\n+        },\n+        \"_vec_cmpgtsh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vcmpgtsh\")\n+        },\n+        \"_vec_cmpgtsw\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vcmpgtsw\")\n+        },\n+        \"_vec_maxsb\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I8x16,\n+            definition: Named(\"llvm.ppc.altivec.vmaxsb\")\n+        },\n+        \"_vec_maxub\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U8x16]; &INPUTS },\n+            output: &::U8x16,\n+            definition: Named(\"llvm.ppc.altivec.vmaxub\")\n+        },\n+        \"_vec_maxsh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vmaxsh\")\n+        },\n+        \"_vec_maxuh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::U16x8,\n+            definition: Named(\"llvm.ppc.altivec.vmaxuh\")\n+        },\n+        \"_vec_maxsw\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vmaxsw\")\n+        },\n+        \"_vec_maxuw\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x4, &::U32x4]; &INPUTS },\n+            output: &::U32x4,\n+            definition: Named(\"llvm.ppc.altivec.vmaxuw\")\n+        },\n+        \"_vec_minsb\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I8x16, &::I8x16]; &INPUTS },\n+            output: &::I8x16,\n+            definition: Named(\"llvm.ppc.altivec.vminsb\")\n+        },\n+        \"_vec_minub\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U8x16, &::U8x16]; &INPUTS },\n+            output: &::U8x16,\n+            definition: Named(\"llvm.ppc.altivec.vminub\")\n+        },\n+        \"_vec_minsh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vminsh\")\n+        },\n+        \"_vec_minuh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::U16x8,\n+            definition: Named(\"llvm.ppc.altivec.vminuh\")\n+        },\n+        \"_vec_minsw\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vminsw\")\n+        },\n+        \"_vec_minuw\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x4, &::U32x4]; &INPUTS },\n+            output: &::U32x4,\n+            definition: Named(\"llvm.ppc.altivec.vminuw\")\n+        },\n         _ => return None,\n     })\n }"}, {"sha": "e17a3c82b5020af3429e7a8d4a5c7999afcb275d", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -84,3 +84,5 @@ pub mod diagnostics;\n pub mod registry;\n pub mod load;\n pub mod build;\n+\n+__build_diagnostic_array! { librustc_plugin, DIAGNOSTICS }"}, {"sha": "2317e36a0ab89a64a7041d944619fe79f9923e6d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -546,7 +546,7 @@ impl<'a> PathSource<'a> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n pub enum Namespace {\n     TypeNS,\n     ValueNS,\n@@ -898,6 +898,19 @@ impl<'a> ModuleData<'a> {\n         }\n     }\n \n+    fn for_each_child_stable<F: FnMut(Ident, Namespace, &'a NameBinding<'a>)>(&self, mut f: F) {\n+        let resolutions = self.resolutions.borrow();\n+        let mut resolutions = resolutions.iter().map(|(&(ident, ns), &resolution)| {\n+                                                    // Pre-compute keys for sorting\n+                                                    (ident.name.as_str(), ns, ident, resolution)\n+                                                })\n+                                                .collect::<Vec<_>>();\n+        resolutions.sort_unstable_by_key(|&(str, ns, ..)| (str, ns));\n+        for &(_, ns, ident, resolution) in resolutions.iter() {\n+            resolution.borrow().binding.map(|binding| f(ident, ns, binding));\n+        }\n+    }\n+\n     fn def(&self) -> Option<Def> {\n         match self.kind {\n             ModuleKind::Def(def, _) => Some(def),\n@@ -2277,8 +2290,9 @@ impl<'a> Resolver<'a> {\n                                                                       false, pat.span)\n                                       .and_then(LexicalScopeBinding::item);\n                     let resolution = binding.map(NameBinding::def).and_then(|def| {\n+                        let ivmode = BindingMode::ByValue(Mutability::Immutable);\n                         let always_binding = !pat_src.is_refutable() || opt_pat.is_some() ||\n-                                             bmode != BindingMode::ByValue(Mutability::Immutable);\n+                                             bmode != ivmode;\n                         match def {\n                             Def::StructCtor(_, CtorKind::Const) |\n                             Def::VariantCtor(_, CtorKind::Const) |\n@@ -3351,8 +3365,9 @@ impl<'a> Resolver<'a> {\n                         in_module_is_extern)) = worklist.pop() {\n             self.populate_module_if_necessary(in_module);\n \n-            in_module.for_each_child(|ident, ns, name_binding| {\n-\n+            // We have to visit module children in deterministic order to avoid\n+            // instabilities in reported imports (#43552).\n+            in_module.for_each_child_stable(|ident, ns, name_binding| {\n                 // avoid imports entirely\n                 if name_binding.is_import() && !name_binding.is_extern_crate() { return; }\n                 // avoid non-importable candidates as well"}, {"sha": "aa249af363f4180c2e6766acc20d9f72d29cae94", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -11,10 +11,11 @@ crate-type = [\"dylib\"]\n [dependencies]\n log = \"0.3\"\n rustc = { path = \"../librustc\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_typeck = { path = \"../librustc_typeck\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-rls-data = \"0.9\"\n+rls-data = \"0.10\"\n rls-span = \"0.4\"\n # FIXME(#40527) should move rustc serialize out of tree\n rustc-serialize = \"0.3\""}, {"sha": "4740f9a0d5a59662808fc170494908df69e565a2", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -29,6 +29,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::map::Node;\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::fx::FxHashSet;\n \n use std::path::Path;\n \n@@ -74,6 +75,7 @@ pub struct DumpVisitor<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> {\n     // we only write one macro def per unique macro definition, and\n     // one macro use per unique callsite span.\n     // mac_defs: HashSet<Span>,\n+    macro_calls: FxHashSet<Span>,\n }\n \n impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n@@ -89,6 +91,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             span: span_utils.clone(),\n             cur_scope: CRATE_NODE_ID,\n             // mac_defs: HashSet::new(),\n+            macro_calls: FxHashSet(),\n         }\n     }\n \n@@ -557,14 +560,21 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         let (value, fields) =\n             if let ast::ItemKind::Struct(ast::VariantData::Struct(ref fields, _), _) = item.node\n         {\n-            let fields_str = fields.iter()\n-                                   .enumerate()\n-                                   .map(|(i, f)| f.ident.map(|i| i.to_string())\n-                                                  .unwrap_or(i.to_string()))\n-                                   .collect::<Vec<_>>()\n-                                   .join(\", \");\n-            (format!(\"{} {{ {} }}\", name, fields_str),\n-             fields.iter().map(|f| ::id_from_node_id(f.id, &self.save_ctxt)).collect())\n+            let include_priv_fields = !self.save_ctxt.config.pub_only;\n+            let fields_str = fields\n+                .iter()\n+                .enumerate()\n+                .filter_map(|(i, f)| {\n+                     if include_priv_fields || f.vis == ast::Visibility::Public {\n+                         f.ident.map(|i| i.to_string()).or_else(|| Some(i.to_string()))\n+                     } else {\n+                         None\n+                     }\n+                })\n+                .collect::<Vec<_>>()\n+                .join(\", \");\n+            let value = format!(\"{} {{ {} }}\", name, fields_str);\n+            (value, fields.iter().map(|f| ::id_from_node_id(f.id, &self.save_ctxt)).collect())\n         } else {\n             (String::new(), vec![])\n         };\n@@ -972,11 +982,19 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     /// callsite spans to record macro definition and use data, using the\n     /// mac_uses and mac_defs sets to prevent multiples.\n     fn process_macro_use(&mut self, span: Span) {\n+        let source_span = span.source_callsite();\n+        if self.macro_calls.contains(&source_span) {\n+            return;\n+        }\n+        self.macro_calls.insert(source_span);\n+\n         let data = match self.save_ctxt.get_macro_use_data(span) {\n             None => return,\n             Some(data) => data,\n         };\n \n+        self.dumper.macro_use(data);\n+\n         // FIXME write the macro def\n         // let mut hasher = DefaultHasher::new();\n         // data.callee_span.hash(&mut hasher);\n@@ -996,7 +1014,6 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         //         }.lower(self.tcx));\n         //     }\n         // }\n-        self.dumper.macro_use(data);\n     }\n \n     fn process_trait_item(&mut self, trait_item: &'l ast::TraitItem, trait_id: DefId) {"}, {"sha": "30a698e635143d18debdad483330c5b9ce7b1bc6", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -51,7 +51,11 @@ impl<'b> DumpOutput for CallbackOutput<'b> {\n \n impl<'b, W: Write> JsonDumper<WriteOutput<'b, W>> {\n     pub fn new(writer: &'b mut W, config: Config) -> JsonDumper<WriteOutput<'b, W>> {\n-        JsonDumper { output: WriteOutput { output: writer }, config, result: Analysis::new() }\n+        JsonDumper {\n+            output: WriteOutput { output: writer },\n+            config: config.clone(),\n+            result: Analysis::new(config)\n+        }\n     }\n }\n \n@@ -61,8 +65,8 @@ impl<'b> JsonDumper<CallbackOutput<'b>> {\n                          -> JsonDumper<CallbackOutput<'b>> {\n         JsonDumper {\n             output: CallbackOutput { callback: callback },\n-            config,\n-            result: Analysis::new(),\n+            config: config.clone(),\n+            result: Analysis::new(config),\n         }\n     }\n }"}, {"sha": "1dd0df4108fc6dc5708c0079c1ec19d033c7934e", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -23,6 +23,7 @@\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n+extern crate rustc_data_structures;\n extern crate rustc_serialize;\n extern crate rustc_typeck;\n extern crate syntax_pos;"}, {"sha": "e771da2ed4cebfa9a7d9b014cd4fc7b4bfd9a95a", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -398,9 +398,10 @@ impl<'a> SpanUtils<'a> {\n             return false;\n         }\n         // If sub_span is none, filter out generated code.\n-        if sub_span.is_none() {\n-            return true;\n-        }\n+        let sub_span = match sub_span {\n+            Some(ss) => ss,\n+            None => return true,\n+        };\n \n         //If the span comes from a fake filemap, filter it.\n         if !self.sess.codemap().lookup_char_pos(parent.lo).file.is_real_file() {\n@@ -409,7 +410,7 @@ impl<'a> SpanUtils<'a> {\n \n         // Otherwise, a generated span is deemed invalid if it is not a sub-span of the root\n         // callsite. This filters out macro internal variables and most malformed spans.\n-        !parent.source_callsite().contains(parent)\n+        !parent.source_callsite().contains(sub_span)\n     }\n }\n "}, {"sha": "ed9321cc3f3a1197dd97f45703cdfd53ebd50080", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -10,7 +10,7 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n-crossbeam = \"0.2\"\n+num_cpus = \"1.0\"\n flate2 = \"0.2\"\n jobserver = \"0.1.5\"\n log = \"0.3\""}, {"sha": "6e661a5a8c6a4c278d2e15ffe44dea3bfd4ed757", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -37,11 +37,22 @@ use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_TRANSLATED};\n const MODULE: &'static str = \"module\";\n const CFG: &'static str = \"cfg\";\n \n-#[derive(Debug, PartialEq)]\n-enum Disposition { Reused, Translated }\n+#[derive(Debug, PartialEq, Clone, Copy)]\n+pub enum Disposition { Reused, Translated }\n+\n+impl ModuleTranslation {\n+    pub fn disposition(&self) -> (String, Disposition) {\n+        let disposition = match self.source {\n+            ModuleSource::Preexisting(_) => Disposition::Reused,\n+            ModuleSource::Translated(_) => Disposition::Translated,\n+        };\n+\n+        (self.name.clone(), disposition)\n+    }\n+}\n \n pub(crate) fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                              modules: &[ModuleTranslation]) {\n+                                              modules: &[(String, Disposition)]) {\n     let _ignore = tcx.dep_graph.in_ignore();\n \n     if tcx.sess.opts.incremental.is_none() {\n@@ -56,7 +67,7 @@ pub(crate) fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n struct AssertModuleSource<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    modules: &'a [ModuleTranslation],\n+    modules: &'a [(String, Disposition)],\n }\n \n impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n@@ -75,15 +86,15 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         }\n \n         let mname = self.field(attr, MODULE);\n-        let mtrans = self.modules.iter().find(|mtrans| *mtrans.name == *mname.as_str());\n+        let mtrans = self.modules.iter().find(|&&(ref name, _)| name == mname.as_str());\n         let mtrans = match mtrans {\n             Some(m) => m,\n             None => {\n                 debug!(\"module name `{}` not found amongst:\", mname);\n-                for mtrans in self.modules {\n+                for &(ref name, ref disposition) in self.modules {\n                     debug!(\"module named `{}` with disposition {:?}\",\n-                           mtrans.name,\n-                           self.disposition(mtrans));\n+                           name,\n+                           disposition);\n                 }\n \n                 self.tcx.sess.span_err(\n@@ -93,7 +104,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n             }\n         };\n \n-        let mtrans_disposition = self.disposition(mtrans);\n+        let mtrans_disposition = mtrans.1;\n         if disposition != mtrans_disposition {\n             self.tcx.sess.span_err(\n                 attr.span,\n@@ -104,13 +115,6 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         }\n     }\n \n-    fn disposition(&self, mtrans: &ModuleTranslation) -> Disposition {\n-        match mtrans.source {\n-            ModuleSource::Preexisting(_) => Disposition::Reused,\n-            ModuleSource::Translated(_) => Disposition::Translated,\n-        }\n-    }\n-\n     fn field(&self, attr: &ast::Attribute, name: &str) -> ast::Name {\n         for item in attr.meta_item_list().unwrap_or_else(Vec::new) {\n             if item.check_name(name) {"}, {"sha": "6ec40bd689c23eb963a6ee93679d0d710a2d5c33", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -126,7 +126,7 @@ impl<'a> ArchiveBuilder<'a> {\n             Some(ref src) => src,\n             None => return None,\n         };\n-        self.src_archive = Some(ArchiveRO::open(src));\n+        self.src_archive = Some(ArchiveRO::open(src).ok());\n         self.src_archive.as_ref().unwrap().as_ref()\n     }\n \n@@ -186,9 +186,8 @@ impl<'a> ArchiveBuilder<'a> {\n         where F: FnMut(&str) -> bool + 'static\n     {\n         let archive = match ArchiveRO::open(archive) {\n-            Some(ar) => ar,\n-            None => return Err(io::Error::new(io::ErrorKind::Other,\n-                                              \"failed to open archive\")),\n+            Ok(ar) => ar,\n+            Err(e) => return Err(io::Error::new(io::ErrorKind::Other, e)),\n         };\n         self.additions.push(Addition::Archive {\n             archive: archive,"}, {"sha": "3e2d9f5c32e85fa68772d8fd12471d6f0d7c880e", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -12,7 +12,7 @@ use back::link;\n use back::write;\n use back::symbol_export;\n use rustc::session::config;\n-use errors::FatalError;\n+use errors::{FatalError, Handler};\n use llvm;\n use llvm::archive_ro::ArchiveRO;\n use llvm::{ModuleRef, TargetMachineRef, True, False};\n@@ -27,6 +27,7 @@ use flate2::read::DeflateDecoder;\n use std::io::Read;\n use std::ffi::CString;\n use std::path::Path;\n+use std::ptr::read_unaligned;\n \n pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     match crate_type {\n@@ -41,24 +42,24 @@ pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n }\n \n pub fn run(cgcx: &CodegenContext,\n+           diag_handler: &Handler,\n            llmod: ModuleRef,\n            tm: TargetMachineRef,\n            config: &ModuleConfig,\n            temp_no_opt_bc_filename: &Path) -> Result<(), FatalError> {\n-    let handler = cgcx.handler;\n     if cgcx.opts.cg.prefer_dynamic {\n-        handler.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n-            .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n-                   supported with LTO\")\n-            .emit();\n+        diag_handler.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n+                    .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n+                           supported with LTO\")\n+                    .emit();\n         return Err(FatalError)\n     }\n \n     // Make sure we actually can run LTO\n     for crate_type in cgcx.crate_types.iter() {\n         if !crate_type_allows_lto(*crate_type) {\n-            let e = handler.fatal(\"lto can only be run for executables, cdylibs and \\\n-                                   static library outputs\");\n+            let e = diag_handler.fatal(\"lto can only be run for executables, cdylibs and \\\n+                                        static library outputs\");\n             return Err(e)\n         }\n     }\n@@ -116,13 +117,13 @@ pub fn run(cgcx: &CodegenContext,\n                         if res.is_err() {\n                             let msg = format!(\"failed to decompress bc of `{}`\",\n                                               name);\n-                            Err(handler.fatal(&msg))\n+                            Err(diag_handler.fatal(&msg))\n                         } else {\n                             Ok(inflated)\n                         }\n                     } else {\n-                        Err(handler.fatal(&format!(\"Unsupported bytecode format version {}\",\n-                                                   version)))\n+                        Err(diag_handler.fatal(&format!(\"Unsupported bytecode format version {}\",\n+                                                        version)))\n                     }\n                 })?\n             } else {\n@@ -136,7 +137,7 @@ pub fn run(cgcx: &CodegenContext,\n                     if res.is_err() {\n                         let msg = format!(\"failed to decompress bc of `{}`\",\n                                           name);\n-                        Err(handler.fatal(&msg))\n+                        Err(diag_handler.fatal(&msg))\n                     } else {\n                         Ok(inflated)\n                     }\n@@ -152,7 +153,7 @@ pub fn run(cgcx: &CodegenContext,\n                     Ok(())\n                 } else {\n                     let msg = format!(\"failed to load bc of `{}`\", name);\n-                    Err(write::llvm_err(handler, msg))\n+                    Err(write::llvm_err(&diag_handler, msg))\n                 }\n             })?;\n         }\n@@ -223,13 +224,13 @@ fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n fn extract_bytecode_format_version(bc: &[u8]) -> u32 {\n     let pos = link::RLIB_BYTECODE_OBJECT_VERSION_OFFSET;\n     let byte_data = &bc[pos..pos + 4];\n-    let data = unsafe { *(byte_data.as_ptr() as *const u32) };\n+    let data = unsafe { read_unaligned(byte_data.as_ptr() as *const u32) };\n     u32::from_le(data)\n }\n \n fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n     let pos = link::RLIB_BYTECODE_OBJECT_V1_DATASIZE_OFFSET;\n     let byte_data = &bc[pos..pos + 8];\n-    let data = unsafe { *(byte_data.as_ptr() as *const u64) };\n+    let data = unsafe { read_unaligned(byte_data.as_ptr() as *const u64) };\n     u64::from_le(data)\n }"}, {"sha": "0d5fe6c0ae95fa3dffc45dc711098e4e490c6be7", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 938, "deletions": 385, "changes": 1323, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -10,36 +10,42 @@\n \n use back::lto;\n use back::link::{self, get_linker, remove};\n+use back::linker::LinkerInfo;\n use back::symbol_export::ExportedSymbols;\n use rustc_incremental::{save_trans_partition, in_incr_comp_dir};\n+use rustc::middle::cstore::{LinkMeta, EncodedMetadata};\n use rustc::session::config::{self, OutputFilenames, OutputType, OutputTypes, Passes, SomePasses,\n                              AllPasses, Sanitizer};\n use rustc::session::Session;\n+use time_graph::{self, TimeGraph};\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef};\n use llvm::SMDiagnosticRef;\n-use {CrateTranslation, ModuleLlvm, ModuleSource, ModuleTranslation};\n+use {CrateTranslation, ModuleSource, ModuleTranslation, CompiledModule, ModuleKind};\n use rustc::hir::def_id::CrateNum;\n-use rustc::util::common::{time, time_depth, set_time_depth, path2cstr};\n-use rustc::util::fs::link_or_copy;\n+use rustc::util::common::{time, time_depth, set_time_depth, path2cstr, print_time_passes_entry};\n+use rustc::util::fs::{link_or_copy, rename_or_copy_remove};\n use errors::{self, Handler, Level, DiagnosticBuilder, FatalError};\n-use errors::emitter::Emitter;\n+use errors::emitter::{Emitter};\n use syntax::ext::hygiene::Mark;\n use syntax_pos::MultiSpan;\n+use syntax_pos::symbol::Symbol;\n use context::{is_pie_binary, get_reloc_model};\n use jobserver::{Client, Acquired};\n-use crossbeam::{scope, Scope};\n use rustc_demangle;\n \n-use std::cmp;\n use std::ffi::CString;\n+use std::fmt;\n use std::fs;\n use std::io;\n use std::io::Write;\n use std::path::{Path, PathBuf};\n use std::str;\n-use std::sync::mpsc::{channel, Sender};\n+use std::sync::Arc;\n+use std::sync::mpsc::{channel, Sender, Receiver};\n use std::slice;\n+use std::time::Instant;\n+use std::thread;\n use libc::{c_uint, c_void, c_char, size_t};\n \n pub const RELOC_MODEL_ARGS : [(&'static str, llvm::RelocMode); 7] = [\n@@ -190,7 +196,6 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n \n \n /// Module-specific configuration for `optimize_and_codegen`.\n-#[derive(Clone)]\n pub struct ModuleConfig {\n     /// LLVM TargetMachine to use for codegen.\n     tm: TargetMachineRef,\n@@ -229,9 +234,9 @@ pub struct ModuleConfig {\n unsafe impl Send for ModuleConfig { }\n \n impl ModuleConfig {\n-    fn new(tm: TargetMachineRef, passes: Vec<String>) -> ModuleConfig {\n+    fn new(sess: &Session, passes: Vec<String>) -> ModuleConfig {\n         ModuleConfig {\n-            tm: tm,\n+            tm: create_target_machine(sess),\n             passes: passes,\n             opt_level: None,\n             opt_size: None,\n@@ -255,10 +260,10 @@ impl ModuleConfig {\n         }\n     }\n \n-    fn set_flags(&mut self, sess: &Session, trans: &CrateTranslation) {\n+    fn set_flags(&mut self, sess: &Session, no_builtins: bool) {\n         self.no_verify = sess.no_verify();\n         self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n-        self.no_builtins = trans.no_builtins;\n+        self.no_builtins = no_builtins;\n         self.time_passes = sess.time_passes();\n         self.inline_threshold = sess.opts.cg.inline_threshold;\n         self.obj_is_bitcode = sess.target.target.options.obj_is_bitcode;\n@@ -279,20 +284,55 @@ impl ModuleConfig {\n         self.merge_functions = sess.opts.optimize == config::OptLevel::Default ||\n                                sess.opts.optimize == config::OptLevel::Aggressive;\n     }\n+\n+    fn clone(&self, sess: &Session) -> ModuleConfig {\n+        ModuleConfig {\n+            tm: create_target_machine(sess),\n+            passes: self.passes.clone(),\n+            opt_level: self.opt_level,\n+            opt_size: self.opt_size,\n+\n+            emit_no_opt_bc: self.emit_no_opt_bc,\n+            emit_bc: self.emit_bc,\n+            emit_lto_bc: self.emit_lto_bc,\n+            emit_ir: self.emit_ir,\n+            emit_asm: self.emit_asm,\n+            emit_obj: self.emit_obj,\n+            obj_is_bitcode: self.obj_is_bitcode,\n+\n+            no_verify: self.no_verify,\n+            no_prepopulate_passes: self.no_prepopulate_passes,\n+            no_builtins: self.no_builtins,\n+            time_passes: self.time_passes,\n+            vectorize_loop: self.vectorize_loop,\n+            vectorize_slp: self.vectorize_slp,\n+            merge_functions: self.merge_functions,\n+            inline_threshold: self.inline_threshold,\n+        }\n+    }\n+}\n+\n+impl Drop for ModuleConfig {\n+    fn drop(&mut self) {\n+        unsafe {\n+            llvm::LLVMRustDisposeTargetMachine(self.tm);\n+        }\n+    }\n }\n \n /// Additional resources used by optimize_and_codegen (not module specific)\n-pub struct CodegenContext<'a> {\n+#[derive(Clone)]\n+pub struct CodegenContext {\n     // Resouces needed when running LTO\n     pub time_passes: bool,\n     pub lto: bool,\n     pub no_landing_pads: bool,\n-    pub exported_symbols: &'a ExportedSymbols,\n-    pub opts: &'a config::Options,\n+    pub exported_symbols: Arc<ExportedSymbols>,\n+    pub opts: Arc<config::Options>,\n     pub crate_types: Vec<config::CrateType>,\n     pub each_linked_rlib_for_lto: Vec<(CrateNum, PathBuf)>,\n     // Handler to use for diagnostics produced during codegen.\n-    pub handler: &'a Handler,\n+    pub diag_emitter: SharedEmitter,\n     // LLVM passes added by plugins.\n     pub plugin_passes: Vec<String>,\n     // LLVM optimizations for which we want to print remarks.\n@@ -303,17 +343,27 @@ pub struct CodegenContext<'a> {\n     // compiling incrementally\n     pub incr_comp_session_dir: Option<PathBuf>,\n     // Channel back to the main control thread to send messages to\n-    pub tx: Sender<Message>,\n+    coordinator_send: Sender<Message>,\n+    // A reference to the TimeGraph so we can register timings. None means that\n+    // measuring is disabled.\n+    time_graph: Option<TimeGraph>,\n+}\n+\n+impl CodegenContext {\n+    fn create_diag_handler(&self) -> Handler {\n+        Handler::with_emitter(true, false, Box::new(self.diag_emitter.clone()))\n+    }\n }\n \n struct HandlerFreeVars<'a> {\n-    cgcx: &'a CodegenContext<'a>,\n+    cgcx: &'a CodegenContext,\n+    diag_handler: &'a Handler,\n }\n \n-unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<'a>,\n+unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext,\n                                                msg: &'b str,\n                                                cookie: c_uint) {\n-    drop(cgcx.tx.send(Message::InlineAsmError(cookie as u32, msg.to_string())));\n+    cgcx.diag_emitter.inline_asm_error(cookie as u32, msg.to_string());\n }\n \n unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n@@ -328,7 +378,7 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n }\n \n unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_void) {\n-    let HandlerFreeVars { cgcx, .. } = *(user as *const HandlerFreeVars);\n+    let HandlerFreeVars { cgcx, diag_handler, .. } = *(user as *const HandlerFreeVars);\n \n     match llvm::diagnostic::Diagnostic::unpack(info) {\n         llvm::diagnostic::InlineAsm(inline) => {\n@@ -344,7 +394,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n             };\n \n             if enabled {\n-                cgcx.handler.note_without_error(&format!(\"optimization {} for {} at {}:{}:{}: {}\",\n+                diag_handler.note_without_error(&format!(\"optimization {} for {} at {}:{}:{}: {}\",\n                                                 opt.kind.describe(),\n                                                 opt.pass_name,\n                                                 opt.filename,\n@@ -360,25 +410,32 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n \n // Unsafe due to LLVM calls.\n unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n+                               diag_handler: &Handler,\n                                mtrans: ModuleTranslation,\n-                               mllvm: ModuleLlvm,\n                                config: ModuleConfig,\n                                output_names: OutputFilenames)\n-    -> Result<(), FatalError>\n+    -> Result<CompiledModule, FatalError>\n {\n-    let llmod = mllvm.llmod;\n-    let llcx = mllvm.llcx;\n+    let (llmod, llcx) = match mtrans.source {\n+        ModuleSource::Translated(ref llvm) => (llvm.llmod, llvm.llcx),\n+        ModuleSource::Preexisting(_) => {\n+            bug!(\"optimize_and_codegen: called with ModuleSource::Preexisting\")\n+        }\n+    };\n+\n     let tm = config.tm;\n \n     let fv = HandlerFreeVars {\n         cgcx: cgcx,\n+        diag_handler: diag_handler,\n     };\n     let fv = &fv as *const HandlerFreeVars as *mut c_void;\n \n     llvm::LLVMRustSetInlineAsmDiagnosticHandler(llcx, inline_asm_handler, fv);\n     llvm::LLVMContextSetDiagnosticHandler(llcx, diagnostic_handler, fv);\n \n-    let module_name = Some(&mtrans.name[..]);\n+    let module_name = mtrans.name.clone();\n+    let module_name = Some(&module_name[..]);\n \n     if config.emit_no_opt_bc {\n         let out = output_names.temp_path_ext(\"no-opt.bc\", module_name);\n@@ -406,7 +463,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                 llvm::PassKind::Function => fpm,\n                 llvm::PassKind::Module => mpm,\n                 llvm::PassKind::Other => {\n-                    cgcx.handler.err(\"Encountered LLVM pass kind we can't handle\");\n+                    diag_handler.err(\"Encountered LLVM pass kind we can't handle\");\n                     return true\n                 },\n             };\n@@ -426,25 +483,25 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n         for pass in &config.passes {\n             if !addpass(pass) {\n-                cgcx.handler.warn(&format!(\"unknown pass `{}`, ignoring\",\n+                diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\",\n                                            pass));\n             }\n         }\n \n         for pass in &cgcx.plugin_passes {\n             if !addpass(pass) {\n-                cgcx.handler.err(&format!(\"a plugin asked for LLVM pass \\\n+                diag_handler.err(&format!(\"a plugin asked for LLVM pass \\\n                                            `{}` but LLVM does not \\\n                                            recognize it\", pass));\n             }\n         }\n \n-        cgcx.handler.abort_if_errors();\n+        diag_handler.abort_if_errors();\n \n         // Finally, run the actual optimization passes\n-        time(config.time_passes, &format!(\"llvm function passes [{}]\", cgcx.worker), ||\n+        time(config.time_passes, &format!(\"llvm function passes [{}]\", module_name.unwrap()), ||\n              llvm::LLVMRustRunFunctionPassManager(fpm, llmod));\n-        time(config.time_passes, &format!(\"llvm module passes [{}]\", cgcx.worker), ||\n+        time(config.time_passes, &format!(\"llvm module passes [{}]\", module_name.unwrap()), ||\n              llvm::LLVMRunPassManager(mpm, llmod));\n \n         // Deallocate managers that we're now done with\n@@ -456,6 +513,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                 let temp_no_opt_bc_filename =\n                     output_names.temp_path_ext(\"no-opt.lto.bc\", module_name);\n                 lto::run(cgcx,\n+                         diag_handler,\n                          llmod,\n                          tm,\n                          &config,\n@@ -506,7 +564,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         llvm::LLVMWriteBitcodeToFile(llmod, bc_out_c.as_ptr());\n     }\n \n-    time(config.time_passes, &format!(\"codegen passes [{}]\", cgcx.worker),\n+    time(config.time_passes, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n          || -> Result<(), FatalError> {\n         if config.emit_ir {\n             let out = output_names.temp_path(OutputType::LlvmAssembly, module_name);\n@@ -561,7 +619,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                 llmod\n             };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &path,\n+                write_output_file(diag_handler, tm, cpm, llmod, &path,\n                                   llvm::FileType::AssemblyFile)\n             })?;\n             if config.emit_obj {\n@@ -571,7 +629,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n         if write_obj {\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &obj_out,\n+                write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n                                   llvm::FileType::ObjectFile)\n             })?;\n         }\n@@ -582,67 +640,53 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     if copy_bc_to_obj {\n         debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n         if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n-            cgcx.handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n+            diag_handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n         }\n     }\n \n     if rm_bc {\n         debug!(\"removing_bitcode {:?}\", bc_out);\n         if let Err(e) = fs::remove_file(&bc_out) {\n-            cgcx.handler.err(&format!(\"failed to remove bitcode: {}\", e));\n+            diag_handler.err(&format!(\"failed to remove bitcode: {}\", e));\n         }\n     }\n \n-    llvm::LLVMRustDisposeTargetMachine(tm);\n-    Ok(())\n+    Ok(mtrans.into_compiled_module(config.emit_obj, config.emit_bc))\n }\n \n-\n-pub fn cleanup_llvm(trans: &CrateTranslation) {\n-    for module in trans.modules.iter() {\n-        unsafe {\n-            match module.source {\n-                ModuleSource::Translated(llvm) => {\n-                    llvm::LLVMDisposeModule(llvm.llmod);\n-                    llvm::LLVMContextDispose(llvm.llcx);\n-                }\n-                ModuleSource::Preexisting(_) => {\n-                }\n-            }\n-        }\n-    }\n+pub struct CompiledModules {\n+    pub modules: Vec<CompiledModule>,\n+    pub metadata_module: CompiledModule,\n+    pub allocator_module: Option<CompiledModule>,\n }\n \n-pub fn run_passes(sess: &Session,\n-                  trans: &CrateTranslation,\n-                  output_types: &OutputTypes,\n-                  crate_output: &OutputFilenames) {\n-    // It's possible that we have `codegen_units > 1` but only one item in\n-    // `trans.modules`.  We could theoretically proceed and do LTO in that\n-    // case, but it would be confusing to have the validity of\n-    // `-Z lto -C codegen-units=2` depend on details of the crate being\n-    // compiled, so we complain regardless.\n-    if sess.lto() && sess.opts.cg.codegen_units > 1 {\n-        // This case is impossible to handle because LTO expects to be able\n-        // to combine the entire crate and all its dependencies into a\n-        // single compilation unit, but each codegen unit is in a separate\n-        // LLVM context, so they can't easily be combined.\n-        sess.fatal(\"can't perform LTO when using multiple codegen units\");\n-    }\n-\n-    // Sanity check\n-    assert!(trans.modules.len() == sess.opts.cg.codegen_units ||\n-            sess.opts.debugging_opts.incremental.is_some() ||\n-            !sess.opts.output_types.should_trans() ||\n-            sess.opts.debugging_opts.no_trans);\n+fn need_crate_bitcode_for_rlib(sess: &Session) -> bool {\n+    sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n+    sess.opts.output_types.contains_key(&OutputType::Exe)\n+}\n \n-    let tm = create_target_machine(sess);\n+pub fn start_async_translation(sess: &Session,\n+                               crate_output: &OutputFilenames,\n+                               time_graph: Option<TimeGraph>,\n+                               crate_name: Symbol,\n+                               link: LinkMeta,\n+                               metadata: EncodedMetadata,\n+                               exported_symbols: Arc<ExportedSymbols>,\n+                               no_builtins: bool,\n+                               windows_subsystem: Option<String>,\n+                               linker_info: LinkerInfo,\n+                               no_integrated_as: bool)\n+                               -> OngoingCrateTranslation {\n+    let output_types_override = if no_integrated_as {\n+        OutputTypes::new(&[(OutputType::Assembly, None)])\n+    } else {\n+        sess.opts.output_types.clone()\n+    };\n \n     // Figure out what we actually need to build.\n-\n-    let mut modules_config = ModuleConfig::new(tm, sess.opts.cg.passes.clone());\n-    let mut metadata_config = ModuleConfig::new(tm, vec![]);\n-    let mut allocator_config = ModuleConfig::new(tm, vec![]);\n+    let mut modules_config = ModuleConfig::new(sess, sess.opts.cg.passes.clone());\n+    let mut metadata_config = ModuleConfig::new(sess, vec![]);\n+    let mut allocator_config = ModuleConfig::new(sess, vec![]);\n \n     if let Some(ref sanitizer) = sess.opts.debugging_opts.sanitizer {\n         match *sanitizer {\n@@ -679,16 +723,11 @@ pub fn run_passes(sess: &Session,\n     // Emit bitcode files for the crate if we're emitting an rlib.\n     // Whenever an rlib is created, the bitcode is inserted into the\n     // archive in order to allow LTO against it.\n-    let needs_crate_bitcode =\n-            sess.crate_types.borrow().contains(&config::CrateTypeRlib) &&\n-            sess.opts.output_types.contains_key(&OutputType::Exe);\n-    let needs_crate_object =\n-            sess.opts.output_types.contains_key(&OutputType::Exe);\n-    if needs_crate_bitcode {\n+    if need_crate_bitcode_for_rlib(sess) {\n         modules_config.emit_bc = true;\n     }\n \n-    for output_type in output_types.keys() {\n+    for output_type in output_types_override.keys() {\n         match *output_type {\n             OutputType::Bitcode => { modules_config.emit_bc = true; }\n             OutputType::LlvmAssembly => { modules_config.emit_ir = true; }\n@@ -714,76 +753,86 @@ pub fn run_passes(sess: &Session,\n         }\n     }\n \n-    modules_config.set_flags(sess, trans);\n-    metadata_config.set_flags(sess, trans);\n-    allocator_config.set_flags(sess, trans);\n-\n+    modules_config.set_flags(sess, no_builtins);\n+    metadata_config.set_flags(sess, no_builtins);\n+    allocator_config.set_flags(sess, no_builtins);\n \n-    // Populate a buffer with a list of codegen threads.  Items are processed in\n-    // LIFO order, just because it's a tiny bit simpler that way.  (The order\n-    // doesn't actually matter.)\n-    let mut work_items = Vec::with_capacity(1 + trans.modules.len());\n-\n-    {\n-        let work = build_work_item(sess,\n-                                   trans.metadata_module.clone(),\n-                                   metadata_config.clone(),\n-                                   crate_output.clone());\n-        work_items.push(work);\n-    }\n-\n-    if let Some(allocator) = trans.allocator_module.clone() {\n-        let work = build_work_item(sess,\n-                                   allocator,\n-                                   allocator_config.clone(),\n-                                   crate_output.clone());\n-        work_items.push(work);\n-    }\n-\n-    for mtrans in trans.modules.iter() {\n-        let work = build_work_item(sess,\n-                                   mtrans.clone(),\n-                                   modules_config.clone(),\n-                                   crate_output.clone());\n-        work_items.push(work);\n-    }\n-\n-    if sess.opts.debugging_opts.incremental_info {\n-        dump_incremental_data(&trans);\n-    }\n+    // Exclude metadata and allocator modules from time_passes output, since\n+    // they throw off the \"LLVM passes\" measurement.\n+    metadata_config.time_passes = false;\n+    allocator_config.time_passes = false;\n \n     let client = sess.jobserver_from_env.clone().unwrap_or_else(|| {\n         // Pick a \"reasonable maximum\" if we don't otherwise have a jobserver in\n         // our environment, capping out at 32 so we don't take everything down\n         // by hogging the process run queue.\n-        let num_workers = cmp::min(work_items.len() - 1, 32);\n-        Client::new(num_workers).expect(\"failed to create jobserver\")\n-    });\n-    scope(|scope| {\n-        execute_work(sess, work_items, client, &trans.exported_symbols, scope);\n+        Client::new(32).expect(\"failed to create jobserver\")\n     });\n \n-    // If in incr. comp. mode, preserve the `.o` files for potential re-use\n-    for mtrans in trans.modules.iter() {\n+    let (shared_emitter, shared_emitter_main) = SharedEmitter::new();\n+    let (trans_worker_send, trans_worker_receive) = channel();\n+    let (coordinator_send, coordinator_receive) = channel();\n+\n+    let coordinator_thread = start_executing_work(sess,\n+                                                  shared_emitter,\n+                                                  trans_worker_send,\n+                                                  coordinator_send.clone(),\n+                                                  coordinator_receive,\n+                                                  client,\n+                                                  time_graph.clone(),\n+                                                  exported_symbols.clone());\n+    OngoingCrateTranslation {\n+        crate_name,\n+        link,\n+        metadata,\n+        exported_symbols,\n+        no_builtins,\n+        windows_subsystem,\n+        linker_info,\n+        no_integrated_as,\n+\n+        regular_module_config: modules_config,\n+        metadata_module_config: metadata_config,\n+        allocator_module_config: allocator_config,\n+\n+        time_graph,\n+        output_filenames: crate_output.clone(),\n+        coordinator_send,\n+        trans_worker_receive,\n+        shared_emitter_main,\n+        future: coordinator_thread\n+    }\n+}\n+\n+fn copy_module_artifacts_into_incr_comp_cache(sess: &Session,\n+                                              compiled_modules: &CompiledModules,\n+                                              crate_output: &OutputFilenames) {\n+    if sess.opts.incremental.is_none() {\n+        return;\n+    }\n+\n+    for module in compiled_modules.modules.iter() {\n         let mut files = vec![];\n \n-        if modules_config.emit_obj {\n-            let path = crate_output.temp_path(OutputType::Object, Some(&mtrans.name));\n+        if module.emit_obj {\n+            let path = crate_output.temp_path(OutputType::Object, Some(&module.name));\n             files.push((OutputType::Object, path));\n         }\n \n-        if modules_config.emit_bc {\n-            let path = crate_output.temp_path(OutputType::Bitcode, Some(&mtrans.name));\n+        if module.emit_bc {\n+            let path = crate_output.temp_path(OutputType::Bitcode, Some(&module.name));\n             files.push((OutputType::Bitcode, path));\n         }\n \n-        save_trans_partition(sess, &mtrans.name, mtrans.symbol_name_hash, &files);\n+        save_trans_partition(sess, &module.name, module.symbol_name_hash, &files);\n     }\n+}\n \n-    // All codegen is finished.\n-    unsafe {\n-        llvm::LLVMRustDisposeTargetMachine(tm);\n-    }\n+fn produce_final_output_artifacts(sess: &Session,\n+                                  compiled_modules: &CompiledModules,\n+                                  crate_output: &OutputFilenames) {\n+    let mut user_wants_bitcode = false;\n+    let mut user_wants_objects = false;\n \n     // Produce final compile outputs.\n     let copy_gracefully = |from: &Path, to: &Path| {\n@@ -794,10 +843,10 @@ pub fn run_passes(sess: &Session,\n \n     let copy_if_one_unit = |output_type: OutputType,\n                             keep_numbered: bool| {\n-        if trans.modules.len() == 1 {\n+        if compiled_modules.modules.len() == 1 {\n             // 1) Only one codegen unit.  In this case it's no difficulty\n             //    to copy `foo.0.x` to `foo.x`.\n-            let module_name = Some(&trans.modules[0].name[..]);\n+            let module_name = Some(&compiled_modules.modules[0].name[..]);\n             let path = crate_output.temp_path(output_type, module_name);\n             copy_gracefully(&path,\n                             &crate_output.path(output_type));\n@@ -834,9 +883,7 @@ pub fn run_passes(sess: &Session,\n     // Flag to indicate whether the user explicitly requested bitcode.\n     // Otherwise, we produced it only as a temporary output, and will need\n     // to get rid of it.\n-    let mut user_wants_bitcode = false;\n-    let mut user_wants_objects = false;\n-    for output_type in output_types.keys() {\n+    for output_type in crate_output.outputs.keys() {\n         match *output_type {\n             OutputType::Bitcode => {\n                 user_wants_bitcode = true;\n@@ -861,7 +908,6 @@ pub fn run_passes(sess: &Session,\n             OutputType::DepInfo => {}\n         }\n     }\n-    let user_wants_bitcode = user_wants_bitcode;\n \n     // Clean up unwanted temporary files.\n \n@@ -893,33 +939,39 @@ pub fn run_passes(sess: &Session,\n         // If you change how this works, also update back::link::link_rlib,\n         // where .#module-name#.bc files are (maybe) deleted after making an\n         // rlib.\n+        let needs_crate_bitcode = need_crate_bitcode_for_rlib(sess);\n+        let needs_crate_object = crate_output.outputs.contains_key(&OutputType::Exe);\n+\n         let keep_numbered_bitcode = needs_crate_bitcode ||\n                 (user_wants_bitcode && sess.opts.cg.codegen_units > 1);\n \n         let keep_numbered_objects = needs_crate_object ||\n                 (user_wants_objects && sess.opts.cg.codegen_units > 1);\n \n-        for module_name in trans.modules.iter().map(|m| Some(&m.name[..])) {\n-            if modules_config.emit_obj && !keep_numbered_objects {\n+        for module in compiled_modules.modules.iter() {\n+            let module_name = Some(&module.name[..]);\n+\n+            if module.emit_obj && !keep_numbered_objects {\n                 let path = crate_output.temp_path(OutputType::Object, module_name);\n                 remove(sess, &path);\n             }\n \n-            if modules_config.emit_bc && !keep_numbered_bitcode {\n+            if module.emit_bc && !keep_numbered_bitcode {\n                 let path = crate_output.temp_path(OutputType::Bitcode, module_name);\n                 remove(sess, &path);\n             }\n         }\n \n-        if metadata_config.emit_bc && !user_wants_bitcode {\n+        if compiled_modules.metadata_module.emit_bc && !user_wants_bitcode {\n             let path = crate_output.temp_path(OutputType::Bitcode,\n-                                              Some(&trans.metadata_module.name));\n+                                              Some(&compiled_modules.metadata_module.name));\n             remove(sess, &path);\n         }\n-        if allocator_config.emit_bc && !user_wants_bitcode {\n-            if let Some(ref module) = trans.allocator_module {\n+\n+        if let Some(ref allocator_module) = compiled_modules.allocator_module {\n+            if allocator_module.emit_bc && !user_wants_bitcode {\n                 let path = crate_output.temp_path(OutputType::Bitcode,\n-                                                  Some(&module.name));\n+                                                  Some(&allocator_module.name));\n                 remove(sess, &path);\n             }\n         }\n@@ -930,20 +982,13 @@ pub fn run_passes(sess: &Session,\n     //  - #crate#.crate.metadata.o\n     //  - #crate#.bc\n     // These are used in linking steps and will be cleaned up afterward.\n-\n-    // FIXME: time_llvm_passes support - does this use a global context or\n-    // something?\n-    if sess.opts.cg.codegen_units == 1 && sess.time_llvm_passes() {\n-        unsafe { llvm::LLVMRustPrintPassTimings(); }\n-    }\n }\n \n-fn dump_incremental_data(trans: &CrateTranslation) {\n+pub fn dump_incremental_data(trans: &CrateTranslation) {\n     let mut reuse = 0;\n     for mtrans in trans.modules.iter() {\n-        match mtrans.source {\n-            ModuleSource::Preexisting(..) => reuse += 1,\n-            ModuleSource::Translated(..) => (),\n+        if mtrans.pre_existing {\n+            reuse += 1;\n         }\n     }\n     eprintln!(\"incremental: re-using {} out of {} modules\", reuse, trans.modules.len());\n@@ -955,14 +1000,17 @@ struct WorkItem {\n     output_names: OutputFilenames\n }\n \n-fn build_work_item(sess: &Session,\n-                   mtrans: ModuleTranslation,\n+impl fmt::Debug for WorkItem {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"WorkItem({})\", self.mtrans.name)\n+    }\n+}\n+\n+fn build_work_item(mtrans: ModuleTranslation,\n                    config: ModuleConfig,\n                    output_names: OutputFilenames)\n                    -> WorkItem\n {\n-    let mut config = config;\n-    config.tm = create_target_machine(sess);\n     WorkItem {\n         mtrans: mtrans,\n         config: config,\n@@ -971,70 +1019,98 @@ fn build_work_item(sess: &Session,\n }\n \n fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n-    -> Result<(), FatalError>\n+    -> Result<CompiledModule, FatalError>\n {\n-    unsafe {\n-        match work_item.mtrans.source {\n-            ModuleSource::Translated(mllvm) => {\n-                debug!(\"llvm-optimizing {:?}\", work_item.mtrans.name);\n-                optimize_and_codegen(cgcx,\n-                                     work_item.mtrans,\n-                                     mllvm,\n-                                     work_item.config,\n-                                     work_item.output_names)?;\n-            }\n-            ModuleSource::Preexisting(wp) => {\n-                let incr_comp_session_dir = cgcx.incr_comp_session_dir\n-                                                .as_ref()\n-                                                .unwrap();\n-                let name = &work_item.mtrans.name;\n-                for (kind, saved_file) in wp.saved_files {\n-                    let obj_out = work_item.output_names.temp_path(kind, Some(name));\n-                    let source_file = in_incr_comp_dir(&incr_comp_session_dir,\n-                                                       &saved_file);\n-                    debug!(\"copying pre-existing module `{}` from {:?} to {}\",\n-                           work_item.mtrans.name,\n-                           source_file,\n-                           obj_out.display());\n-                    match link_or_copy(&source_file, &obj_out) {\n-                        Ok(_) => { }\n-                        Err(err) => {\n-                            cgcx.handler.err(&format!(\"unable to copy {} to {}: {}\",\n-                                                      source_file.display(),\n-                                                      obj_out.display(),\n-                                                      err));\n-                        }\n-                    }\n+    let diag_handler = cgcx.create_diag_handler();\n+    let module_name = work_item.mtrans.name.clone();\n+\n+    let pre_existing = match work_item.mtrans.source {\n+        ModuleSource::Translated(_) => None,\n+        ModuleSource::Preexisting(ref wp) => Some(wp.clone()),\n+    };\n+\n+    if let Some(wp) = pre_existing {\n+        let incr_comp_session_dir = cgcx.incr_comp_session_dir\n+                                        .as_ref()\n+                                        .unwrap();\n+        let name = &work_item.mtrans.name;\n+        for (kind, saved_file) in wp.saved_files {\n+            let obj_out = work_item.output_names.temp_path(kind, Some(name));\n+            let source_file = in_incr_comp_dir(&incr_comp_session_dir,\n+                                               &saved_file);\n+            debug!(\"copying pre-existing module `{}` from {:?} to {}\",\n+                   work_item.mtrans.name,\n+                   source_file,\n+                   obj_out.display());\n+            match link_or_copy(&source_file, &obj_out) {\n+                Ok(_) => { }\n+                Err(err) => {\n+                    diag_handler.err(&format!(\"unable to copy {} to {}: {}\",\n+                                              source_file.display(),\n+                                              obj_out.display(),\n+                                              err));\n                 }\n             }\n         }\n-    }\n \n-    Ok(())\n+        Ok(CompiledModule {\n+            name: module_name,\n+            kind: ModuleKind::Regular,\n+            pre_existing: true,\n+            symbol_name_hash: work_item.mtrans.symbol_name_hash,\n+            emit_bc: work_item.config.emit_bc,\n+            emit_obj: work_item.config.emit_obj,\n+        })\n+    } else {\n+        debug!(\"llvm-optimizing {:?}\", module_name);\n+\n+        unsafe {\n+            optimize_and_codegen(cgcx,\n+                                 &diag_handler,\n+                                 work_item.mtrans,\n+                                 work_item.config,\n+                                 work_item.output_names)\n+        }\n+    }\n }\n \n-pub enum Message {\n+#[derive(Debug)]\n+enum Message {\n     Token(io::Result<Acquired>),\n-    Diagnostic(Diagnostic),\n-    Done { success: bool },\n-    InlineAsmError(u32, String),\n-    AbortIfErrors,\n+    Done {\n+        result: Result<CompiledModule, ()>,\n+        worker_id: usize,\n+    },\n+    TranslationDone {\n+        llvm_work_item: WorkItem,\n+        cost: u64,\n+        is_last: bool,\n+    },\n+    TranslateItem,\n }\n \n-pub struct Diagnostic {\n+struct Diagnostic {\n     msg: String,\n     code: Option<String>,\n     lvl: Level,\n }\n \n-fn execute_work<'a>(sess: &'a Session,\n-                    mut work_items: Vec<WorkItem>,\n-                    jobserver: Client,\n-                    exported_symbols: &'a ExportedSymbols,\n-                    scope: &Scope<'a>) {\n-    let (tx, rx) = channel();\n-    let tx2 = tx.clone();\n+#[derive(PartialEq, Clone, Copy, Debug)]\n+enum MainThreadWorkerState {\n+    Idle,\n+    Translating,\n+    LLVMing,\n+}\n \n+fn start_executing_work(sess: &Session,\n+                        shared_emitter: SharedEmitter,\n+                        trans_worker_send: Sender<Message>,\n+                        coordinator_send: Sender<Message>,\n+                        coordinator_receive: Receiver<Message>,\n+                        jobserver: Client,\n+                        time_graph: Option<TimeGraph>,\n+                        exported_symbols: Arc<ExportedSymbols>)\n+                        -> thread::JoinHandle<CompiledModules> {\n     // First up, convert our jobserver into a helper thread so we can use normal\n     // mpsc channels to manage our messages and such. Once we've got the helper\n     // thread then request `n-1` tokens because all of our work items are ready\n@@ -1045,27 +1121,144 @@ fn execute_work<'a>(sess: &'a Session,\n     //\n     // After we've requested all these tokens then we'll, when we can, get\n     // tokens on `rx` above which will get managed in the main loop below.\n+    let coordinator_send2 = coordinator_send.clone();\n     let helper = jobserver.into_helper_thread(move |token| {\n-        drop(tx2.send(Message::Token(token)));\n+        drop(coordinator_send2.send(Message::Token(token)));\n     }).expect(\"failed to spawn helper thread\");\n-    for _ in 0..work_items.len() - 1 {\n-        helper.request_token();\n-    }\n+\n+    let mut each_linked_rlib_for_lto = Vec::new();\n+    drop(link::each_linked_rlib(sess, &mut |cnum, path| {\n+        if link::ignored_for_lto(sess, cnum) {\n+            return\n+        }\n+        each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n+    }));\n+\n+    let cgcx = CodegenContext {\n+        crate_types: sess.crate_types.borrow().clone(),\n+        each_linked_rlib_for_lto: each_linked_rlib_for_lto,\n+        lto: sess.lto(),\n+        no_landing_pads: sess.no_landing_pads(),\n+        opts: Arc::new(sess.opts.clone()),\n+        time_passes: sess.time_passes(),\n+        exported_symbols: exported_symbols,\n+        plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n+        remark: sess.opts.cg.remark.clone(),\n+        worker: 0,\n+        incr_comp_session_dir: sess.incr_comp_session_dir_opt().map(|r| r.clone()),\n+        coordinator_send: coordinator_send,\n+        diag_emitter: shared_emitter.clone(),\n+        time_graph,\n+    };\n \n     // This is the \"main loop\" of parallel work happening for parallel codegen.\n     // It's here that we manage parallelism, schedule work, and work with\n     // messages coming from clients.\n     //\n-    // Our channel `rx` created above is a channel of messages coming from our\n-    // various worker threads. This includes the jobserver helper thread above\n-    // as well as the work we'll spawn off here. Each turn of this loop starts\n-    // off by trying to spawn as much work as possible. After we've done that we\n-    // then wait for an event and dispatch accordingly once the event is\n-    // received. We're only done once all our work items have been drained and\n-    // nothing is running, at which point we return back up the stack.\n+    // There are a few environmental pre-conditions that shape how the system\n+    // is set up:\n+    //\n+    // - Error reporting only can happen on the main thread because that's the\n+    //   only place where we have access to the compiler `Session`.\n+    // - LLVM work can be done on any thread.\n+    // - Translation can only happen on the main thread.\n+    // - Each thread doing substantial work most be in possession of a `Token`\n+    //   from the `Jobserver`.\n+    // - The compiler process always holds one `Token`. Any additional `Tokens`\n+    //   have to be requested from the `Jobserver`.\n+    //\n+    // Error Reporting\n+    // ===============\n+    // The error reporting restriction is handled separately from the rest: We\n+    // set up a `SharedEmitter` the holds an open channel to the main thread.\n+    // When an error occurs on any thread, the shared emitter will send the\n+    // error message to the receiver main thread (`SharedEmitterMain`). The\n+    // main thread will periodically query this error message queue and emit\n+    // any error messages it has received. It might even abort compilation if\n+    // has received a fatal error. In this case we rely on all other threads\n+    // being torn down automatically with the main thread.\n+    // Since the main thread will often be busy doing translation work, error\n+    // reporting will be somewhat delayed, since the message queue can only be\n+    // checked in between to work packages.\n+    //\n+    // Work Processing Infrastructure\n+    // ==============================\n+    // The work processing infrastructure knows three major actors:\n+    //\n+    // - the coordinator thread,\n+    // - the main thread, and\n+    // - LLVM worker threads\n+    //\n+    // The coordinator thread is running a message loop. It instructs the main\n+    // thread about what work to do when, and it will spawn off LLVM worker\n+    // threads as open LLVM WorkItems become available.\n+    //\n+    // The job of the main thread is to translate CGUs into LLVM work package\n+    // (since the main thread is the only thread that can do this). The main\n+    // thread will block until it receives a message from the coordinator, upon\n+    // which it will translate one CGU, send it to the coordinator and block\n+    // again. This way the coordinator can control what the main thread is\n+    // doing.\n+    //\n+    // The coordinator keeps a queue of LLVM WorkItems, and when a `Token` is\n+    // available, it will spawn off a new LLVM worker thread and let it process\n+    // that a WorkItem. When a LLVM worker thread is done with its WorkItem,\n+    // it will just shut down, which also frees all resources associated with\n+    // the given LLVM module, and sends a message to the coordinator that the\n+    // has been completed.\n+    //\n+    // Work Scheduling\n+    // ===============\n+    // The scheduler's goal is to minimize the time it takes to complete all\n+    // work there is, however, we also want to keep memory consumption low\n+    // if possible. These two goals are at odds with each other: If memory\n+    // consumption were not an issue, we could just let the main thread produce\n+    // LLVM WorkItems at full speed, assuring maximal utilization of\n+    // Tokens/LLVM worker threads. However, since translation usual is faster\n+    // than LLVM processing, the queue of LLVM WorkItems would fill up and each\n+    // WorkItem potentially holds on to a substantial amount of memory.\n+    //\n+    // So the actual goal is to always produce just enough LLVM WorkItems as\n+    // not to starve our LLVM worker threads. That means, once we have enough\n+    // WorkItems in our queue, we can block the main thread, so it does not\n+    // produce more until we need them.\n     //\n-    // ## Parallelism management\n+    // Doing LLVM Work on the Main Thread\n+    // ----------------------------------\n+    // Since the main thread owns the compiler processes implicit `Token`, it is\n+    // wasteful to keep it blocked without doing any work. Therefore, what we do\n+    // in this case is: We spawn off an additional LLVM worker thread that helps\n+    // reduce the queue. The work it is doing corresponds to the implicit\n+    // `Token`. The coordinator will mark the main thread as being busy with\n+    // LLVM work. (The actual work happens on another OS thread but we just care\n+    // about `Tokens`, not actual threads).\n     //\n+    // When any LLVM worker thread finishes while the main thread is marked as\n+    // \"busy with LLVM work\", we can do a little switcheroo: We give the Token\n+    // of the just finished thread to the LLVM worker thread that is working on\n+    // behalf of the main thread's implicit Token, thus freeing up the main\n+    // thread again. The coordinator can then again decide what the main thread\n+    // should do. This allows the coordinator to make decisions at more points\n+    // in time.\n+    //\n+    // Striking a Balance between Throughput and Memory Consumption\n+    // ------------------------------------------------------------\n+    // Since our two goals, (1) use as many Tokens as possible and (2) keep\n+    // memory consumption as low as possible, are in conflict with each other,\n+    // we have to find a trade off between them. Right now, the goal is to keep\n+    // all workers busy, which means that no worker should find the queue empty\n+    // when it is ready to start.\n+    // How do we do achieve this? Good question :) We actually never know how\n+    // many `Tokens` are potentially available so it's hard to say how much to\n+    // fill up the queue before switching the main thread to LLVM work. Also we\n+    // currently don't have a means to estimate how long a running LLVM worker\n+    // will still be busy with it's current WorkItem. However, we know the\n+    // maximal count of available Tokens that makes sense (=the number of CPU\n+    // cores), so we can take a conservative guess. The heuristic we use here\n+    // is implemented in the `queue_full_enough()` function.\n+    //\n+    // Some Background on Jobservers\n+    // -----------------------------\n     // It's worth also touching on the management of parallelism here. We don't\n     // want to just spawn a thread per work item because while that's optimal\n     // parallelism it may overload a system with too many threads or violate our\n@@ -1078,193 +1271,302 @@ fn execute_work<'a>(sess: &'a Session,\n     // and whenever we're done with that work we release the semaphore. In this\n     // manner we can ensure that the maximum number of parallel workers is\n     // capped at any one point in time.\n-    //\n-    // The jobserver protocol is a little unique, however. We, as a running\n-    // process, already have an ephemeral token assigned to us. We're not going\n-    // to be doing any productive work in this thread though so we're going to\n-    // give this token to a worker thread (there's no actual token to give, this\n-    // is just conceptually). As a result you'll see a few `+1` and `-1`\n-    // instances below, and it's about working with this ephemeral token.\n-    //\n-    // To acquire tokens we have our `helper` thread above which is just in a\n-    // loop acquiring tokens and sending them to us. We then store all tokens\n-    // locally in a `tokens` vector once they're acquired. Currently we don't\n-    // literally send a token to a worker thread to assist with management of\n-    // our \"ephemeral token\".\n-    //\n-    // As a result, our \"spawn as much work as possible\" basically means that we\n-    // fill up the `running` counter up to the limit of the `tokens` list.\n-    // Whenever we get a new token this'll mean a new unit of work is spawned,\n-    // and then whenever a unit of work finishes we relinquish a token, if we\n-    // had one, to maybe get re-acquired later.\n-    //\n-    // Note that there's a race which may mean that we acquire more tokens than\n-    // we originally anticipated. For example let's say we have 2 units of work.\n-    // First we request one token from the helper thread and then we\n-    // immediately spawn one unit of work with our ephemeral token after. We may\n-    // then finish the first piece of work before the token is acquired, but we\n-    // can continue to spawn the second piece of work with our ephemeral token.\n-    // Before that work finishes, however, we may acquire a token. In that case\n-    // we actually wastefully acquired the token, so we relinquish it back to\n-    // the jobserver.\n-    let mut tokens = Vec::new();\n-    let mut running = 0;\n-    while work_items.len() > 0 || running > 0 {\n-\n-        // Spin up what work we can, only doing this while we've got available\n-        // parallelism slots and work left to spawn.\n-        while work_items.len() > 0 && running < tokens.len() + 1 {\n-            let item = work_items.pop().unwrap();\n-            let index = work_items.len();\n-            spawn_work(sess, exported_symbols, scope, tx.clone(), item, index);\n-            running += 1;\n-        }\n-\n-        // Relinquish accidentally acquired extra tokens\n-        tokens.truncate(running.saturating_sub(1));\n-\n-        match rx.recv().unwrap() {\n-            // Save the token locally and the next turn of the loop will use\n-            // this to spawn a new unit of work, or it may get dropped\n-            // immediately if we have no more work to spawn.\n-            Message::Token(token) => {\n-                tokens.push(token.expect(\"failed to acquire jobserver token\"));\n+    return thread::spawn(move || {\n+        // We pretend to be within the top-level LLVM time-passes task here:\n+        set_time_depth(1);\n+\n+        let max_workers = ::num_cpus::get();\n+        let mut worker_id_counter = 0;\n+        let mut free_worker_ids = Vec::new();\n+        let mut get_worker_id = |free_worker_ids: &mut Vec<usize>| {\n+            if let Some(id) = free_worker_ids.pop() {\n+                id\n+            } else {\n+                let id = worker_id_counter;\n+                worker_id_counter += 1;\n+                id\n             }\n+        };\n \n-            // If a thread exits successfully then we drop a token associated\n-            // with that worker and update our `running` count. We may later\n-            // re-acquire a token to continue running more work. We may also not\n-            // actually drop a token here if the worker was running with an\n-            // \"ephemeral token\"\n-            //\n-            // Note that if the thread failed that means it panicked, so we\n-            // abort immediately.\n-            Message::Done { success: true } => {\n-                drop(tokens.pop());\n-                running -= 1;\n+        // This is where we collect codegen units that have gone all the way\n+        // through translation and LLVM.\n+        let mut compiled_modules = vec![];\n+        let mut compiled_metadata_module = None;\n+        let mut compiled_allocator_module = None;\n+\n+        // This flag tracks whether all items have gone through translations\n+        let mut translation_done = false;\n+\n+        // This is the queue of LLVM work items that still need processing.\n+        let mut work_items = Vec::new();\n+\n+        // This are the Jobserver Tokens we currently hold. Does not include\n+        // the implicit Token the compiler process owns no matter what.\n+        let mut tokens = Vec::new();\n+\n+        let mut main_thread_worker_state = MainThreadWorkerState::Idle;\n+        let mut running = 0;\n+\n+        let mut llvm_start_time = None;\n+\n+        // Run the message loop while there's still anything that needs message\n+        // processing:\n+        while !translation_done ||\n+              work_items.len() > 0 ||\n+              running > 0 ||\n+              main_thread_worker_state != MainThreadWorkerState::Idle {\n+\n+            // While there are still CGUs to be translated, the coordinator has\n+            // to decide how to utilize the compiler processes implicit Token:\n+            // For translating more CGU or for running them through LLVM.\n+            if !translation_done {\n+                if main_thread_worker_state == MainThreadWorkerState::Idle {\n+                    if !queue_full_enough(work_items.len(), running, max_workers) {\n+                        // The queue is not full enough, translate more items:\n+                        if let Err(_) = trans_worker_send.send(Message::TranslateItem) {\n+                            panic!(\"Could not send Message::TranslateItem to main thread\")\n+                        }\n+                        main_thread_worker_state = MainThreadWorkerState::Translating;\n+                    } else {\n+                        // The queue is full enough to not let the worker\n+                        // threads starve. Use the implicit Token to do some\n+                        // LLVM work too.\n+                        let (item, _) = work_items.pop()\n+                            .expect(\"queue empty - queue_full_enough() broken?\");\n+                        let cgcx = CodegenContext {\n+                            worker: get_worker_id(&mut free_worker_ids),\n+                            .. cgcx.clone()\n+                        };\n+                        maybe_start_llvm_timer(&item, &mut llvm_start_time);\n+                        main_thread_worker_state = MainThreadWorkerState::LLVMing;\n+                        spawn_work(cgcx, item);\n+                    }\n+                }\n+            } else {\n+                // In this branch, we know that everything has been translated,\n+                // so it's just a matter of determining whether the implicit\n+                // Token is free to use for LLVM work.\n+                match main_thread_worker_state {\n+                    MainThreadWorkerState::Idle => {\n+                        if let Some((item, _)) = work_items.pop() {\n+                            let cgcx = CodegenContext {\n+                                worker: get_worker_id(&mut free_worker_ids),\n+                                .. cgcx.clone()\n+                            };\n+                            maybe_start_llvm_timer(&item, &mut llvm_start_time);\n+                            main_thread_worker_state = MainThreadWorkerState::LLVMing;\n+                            spawn_work(cgcx, item);\n+                        }\n+                    }\n+                    MainThreadWorkerState::Translating => {\n+                        bug!(\"trans worker should not be translating after \\\n+                              translation was already completed\")\n+                    }\n+                    MainThreadWorkerState::LLVMing => {\n+                        // Already making good use of that token\n+                    }\n+                }\n             }\n-            Message::Done { success: false } => {\n-                sess.fatal(\"aborting due to worker thread panic\");\n+\n+            // Spin up what work we can, only doing this while we've got available\n+            // parallelism slots and work left to spawn.\n+            while work_items.len() > 0 && running < tokens.len() {\n+                let (item, _) = work_items.pop().unwrap();\n+\n+                maybe_start_llvm_timer(&item, &mut llvm_start_time);\n+\n+                let cgcx = CodegenContext {\n+                    worker: get_worker_id(&mut free_worker_ids),\n+                    .. cgcx.clone()\n+                };\n+\n+                spawn_work(cgcx, item);\n+                running += 1;\n             }\n \n-            // Our worker wants us to emit an error message, so get ahold of our\n-            // `sess` and print it out\n-            Message::Diagnostic(diag) => {\n-                let handler = sess.diagnostic();\n-                match diag.code {\n-                    Some(ref code) => {\n-                        handler.emit_with_code(&MultiSpan::new(),\n-                                               &diag.msg,\n-                                               &code,\n-                                               diag.lvl);\n+            // Relinquish accidentally acquired extra tokens\n+            tokens.truncate(running);\n+\n+            match coordinator_receive.recv().unwrap() {\n+                // Save the token locally and the next turn of the loop will use\n+                // this to spawn a new unit of work, or it may get dropped\n+                // immediately if we have no more work to spawn.\n+                Message::Token(token) => {\n+                    match token {\n+                        Ok(token) => {\n+                            tokens.push(token);\n+\n+                            if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n+                                // If the main thread token is used for LLVM work\n+                                // at the moment, we turn that thread into a regular\n+                                // LLVM worker thread, so the main thread is free\n+                                // to react to translation demand.\n+                                main_thread_worker_state = MainThreadWorkerState::Idle;\n+                                running += 1;\n+                            }\n+                        }\n+                        Err(e) => {\n+                            let msg = &format!(\"failed to acquire jobserver token: {}\", e);\n+                            shared_emitter.fatal(msg);\n+                            // Exit the coordinator thread\n+                            panic!(\"{}\", msg)\n+                        }\n                     }\n-                    None => {\n-                        handler.emit(&MultiSpan::new(),\n-                                     &diag.msg,\n-                                     diag.lvl);\n+                }\n+\n+                Message::TranslationDone { llvm_work_item, cost, is_last } => {\n+                    // We keep the queue sorted by estimated processing cost,\n+                    // so that more expensive items are processed earlier. This\n+                    // is good for throughput as it gives the main thread more\n+                    // time to fill up the queue and it avoids scheduling\n+                    // expensive items to the end.\n+                    // Note, however, that this is not ideal for memory\n+                    // consumption, as LLVM module sizes are not evenly\n+                    // distributed.\n+                    let insertion_index =\n+                        work_items.binary_search_by_key(&cost, |&(_, cost)| cost);\n+                    let insertion_index = match insertion_index {\n+                        Ok(idx) | Err(idx) => idx\n+                    };\n+                    work_items.insert(insertion_index, (llvm_work_item, cost));\n+\n+                    if is_last {\n+                        // If this is the last, don't request a token because\n+                        // the trans worker thread will be free to handle this\n+                        // immediately.\n+                        translation_done = true;\n+                    } else {\n+                        helper.request_token();\n                     }\n+\n+                    assert_eq!(main_thread_worker_state,\n+                               MainThreadWorkerState::Translating);\n+                    main_thread_worker_state = MainThreadWorkerState::Idle;\n                 }\n-            }\n-            Message::InlineAsmError(cookie, msg) => {\n-                match Mark::from_u32(cookie).expn_info() {\n-                    Some(ei) => sess.span_err(ei.call_site, &msg),\n-                    None     => sess.err(&msg),\n+\n+                // If a thread exits successfully then we drop a token associated\n+                // with that worker and update our `running` count. We may later\n+                // re-acquire a token to continue running more work. We may also not\n+                // actually drop a token here if the worker was running with an\n+                // \"ephemeral token\"\n+                //\n+                // Note that if the thread failed that means it panicked, so we\n+                // abort immediately.\n+                Message::Done { result: Ok(compiled_module), worker_id } => {\n+                    if main_thread_worker_state == MainThreadWorkerState::LLVMing {\n+                        main_thread_worker_state = MainThreadWorkerState::Idle;\n+                    } else {\n+                        running -= 1;\n+                    }\n+\n+                    free_worker_ids.push(worker_id);\n+\n+                    match compiled_module.kind {\n+                        ModuleKind::Regular => {\n+                            compiled_modules.push(compiled_module);\n+                        }\n+                        ModuleKind::Metadata => {\n+                            assert!(compiled_metadata_module.is_none());\n+                            compiled_metadata_module = Some(compiled_module);\n+                        }\n+                        ModuleKind::Allocator => {\n+                            assert!(compiled_allocator_module.is_none());\n+                            compiled_allocator_module = Some(compiled_module);\n+                        }\n+                    }\n+                }\n+                Message::Done { result: Err(()), worker_id: _ } => {\n+                    shared_emitter.fatal(\"aborting due to worker thread panic\");\n+                    // Exit the coordinator thread\n+                    panic!(\"aborting due to worker thread panic\")\n+                }\n+                Message::TranslateItem => {\n+                    bug!(\"the coordinator should not receive translation requests\")\n                 }\n             }\n+        }\n \n-            // Sent to us after a worker sends us a batch of error messages, and\n-            // it's the point at which we check for errors.\n-            Message::AbortIfErrors => sess.diagnostic().abort_if_errors(),\n+        if let Some(llvm_start_time) = llvm_start_time {\n+            let total_llvm_time = Instant::now().duration_since(llvm_start_time);\n+            // This is the top-level timing for all of LLVM, set the time-depth\n+            // to zero.\n+            set_time_depth(0);\n+            print_time_passes_entry(cgcx.time_passes,\n+                                    \"LLVM passes\",\n+                                    total_llvm_time);\n         }\n-    }\n \n-    // Just in case, check this on the way out.\n-    sess.diagnostic().abort_if_errors();\n-}\n+        let compiled_metadata_module = compiled_metadata_module\n+            .expect(\"Metadata module not compiled?\");\n \n-struct SharedEmitter {\n-    tx: Sender<Message>,\n-}\n+        CompiledModules {\n+            modules: compiled_modules,\n+            metadata_module: compiled_metadata_module,\n+            allocator_module: compiled_allocator_module,\n+        }\n+    });\n \n-impl Emitter for SharedEmitter {\n-    fn emit(&mut self, db: &DiagnosticBuilder) {\n-        drop(self.tx.send(Message::Diagnostic(Diagnostic {\n-            msg: db.message(),\n-            code: db.code.clone(),\n-            lvl: db.level,\n-        })));\n-        for child in &db.children {\n-            drop(self.tx.send(Message::Diagnostic(Diagnostic {\n-                msg: child.message(),\n-                code: None,\n-                lvl: child.level,\n-            })));\n+    // A heuristic that determines if we have enough LLVM WorkItems in the\n+    // queue so that the main thread can do LLVM work instead of translation\n+    fn queue_full_enough(items_in_queue: usize,\n+                         workers_running: usize,\n+                         max_workers: usize) -> bool {\n+        // Tune me, plz.\n+        items_in_queue > 0 &&\n+        items_in_queue >= max_workers.saturating_sub(workers_running / 2)\n+    }\n+\n+    fn maybe_start_llvm_timer(work_item: &WorkItem,\n+                              llvm_start_time: &mut Option<Instant>) {\n+        // We keep track of the -Ztime-passes output manually,\n+        // since the closure-based interface does not fit well here.\n+        if work_item.config.time_passes {\n+            if llvm_start_time.is_none() {\n+                *llvm_start_time = Some(Instant::now());\n+            }\n         }\n-        drop(self.tx.send(Message::AbortIfErrors));\n     }\n }\n \n-fn spawn_work<'a>(sess: &'a Session,\n-                  exported_symbols: &'a ExportedSymbols,\n-                  scope: &Scope<'a>,\n-                  tx: Sender<Message>,\n-                  work: WorkItem,\n-                  idx: usize) {\n-    let plugin_passes = sess.plugin_llvm_passes.borrow().clone();\n-    let remark = sess.opts.cg.remark.clone();\n-    let incr_comp_session_dir = sess.incr_comp_session_dir_opt().map(|r| r.clone());\n+pub const TRANS_WORKER_ID: usize = ::std::usize::MAX;\n+pub const TRANS_WORKER_TIMELINE: time_graph::TimelineId =\n+    time_graph::TimelineId(TRANS_WORKER_ID);\n+pub const TRANS_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n+    time_graph::WorkPackageKind(&[\"#DE9597\", \"#FED1D3\", \"#FDC5C7\", \"#B46668\", \"#88494B\"]);\n+const LLVM_WORK_PACKAGE_KIND: time_graph::WorkPackageKind =\n+    time_graph::WorkPackageKind(&[\"#7DB67A\", \"#C6EEC4\", \"#ACDAAA\", \"#579354\", \"#3E6F3C\"]);\n+\n+fn spawn_work(cgcx: CodegenContext, work: WorkItem) {\n     let depth = time_depth();\n-    let lto = sess.lto();\n-    let crate_types = sess.crate_types.borrow().clone();\n-    let mut each_linked_rlib_for_lto = Vec::new();\n-    drop(link::each_linked_rlib(sess, &mut |cnum, path| {\n-        if link::ignored_for_lto(sess, cnum) {\n-            return\n-        }\n-        each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n-    }));\n-    let time_passes = sess.time_passes();\n-    let no_landing_pads = sess.no_landing_pads();\n-    let opts = &sess.opts;\n \n-    scope.spawn(move || {\n+    thread::spawn(move || {\n         set_time_depth(depth);\n \n         // Set up a destructor which will fire off a message that we're done as\n         // we exit.\n         struct Bomb {\n-            tx: Sender<Message>,\n-            success: bool,\n+            coordinator_send: Sender<Message>,\n+            result: Option<CompiledModule>,\n+            worker_id: usize,\n         }\n         impl Drop for Bomb {\n             fn drop(&mut self) {\n-                drop(self.tx.send(Message::Done { success: self.success }));\n+                let result = match self.result.take() {\n+                    Some(compiled_module) => Ok(compiled_module),\n+                    None => Err(())\n+                };\n+\n+                drop(self.coordinator_send.send(Message::Done {\n+                    result,\n+                    worker_id: self.worker_id,\n+                }));\n             }\n         }\n-        let mut bomb = Bomb {\n-            tx: tx.clone(),\n-            success: false,\n-        };\n \n-        // Set up our non-`Send` `CodegenContext` now that we're in a helper\n-        // thread and have all our info available to us.\n-        let emitter = SharedEmitter { tx: tx.clone() };\n-        let diag_handler = Handler::with_emitter(true, false, Box::new(emitter));\n-\n-        let cgcx = CodegenContext {\n-            crate_types: crate_types,\n-            each_linked_rlib_for_lto: each_linked_rlib_for_lto,\n-            lto: lto,\n-            no_landing_pads: no_landing_pads,\n-            opts: opts,\n-            time_passes: time_passes,\n-            exported_symbols: exported_symbols,\n-            handler: &diag_handler,\n-            plugin_passes: plugin_passes,\n-            remark: remark,\n-            worker: idx,\n-            incr_comp_session_dir: incr_comp_session_dir,\n-            tx: tx.clone(),\n+        let mut bomb = Bomb {\n+            coordinator_send: cgcx.coordinator_send.clone(),\n+            result: None,\n+            worker_id: cgcx.worker,\n         };\n \n         // Execute the work itself, and if it finishes successfully then flag\n@@ -1280,8 +1582,13 @@ fn spawn_work<'a>(sess: &'a Session,\n         // we just ignore the result and then send off our message saying that\n         // we're done, which if `execute_work_item` failed is unlikely to be\n         // seen by the main thread, but hey we might as well try anyway.\n-        drop(execute_work_item(&cgcx, work).is_err());\n-        bomb.success = true;\n+        bomb.result = {\n+            let _timing_guard = cgcx.time_graph\n+                                .as_ref()\n+                                .map(|tg| tg.start(time_graph::TimelineId(cgcx.worker),\n+                                                   LLVM_WORK_PACKAGE_KIND));\n+            Some(execute_work_item(&cgcx, work).unwrap())\n+        };\n     });\n }\n \n@@ -1375,3 +1682,249 @@ pub unsafe fn with_llvm_pmb(llmod: ModuleRef,\n     f(builder);\n     llvm::LLVMPassManagerBuilderDispose(builder);\n }\n+\n+\n+enum SharedEmitterMessage {\n+    Diagnostic(Diagnostic),\n+    InlineAsmError(u32, String),\n+    AbortIfErrors,\n+    Fatal(String),\n+}\n+\n+#[derive(Clone)]\n+pub struct SharedEmitter {\n+    sender: Sender<SharedEmitterMessage>,\n+}\n+\n+pub struct SharedEmitterMain {\n+    receiver: Receiver<SharedEmitterMessage>,\n+}\n+\n+impl SharedEmitter {\n+    pub fn new() -> (SharedEmitter, SharedEmitterMain) {\n+        let (sender, receiver) = channel();\n+\n+        (SharedEmitter { sender }, SharedEmitterMain { receiver })\n+    }\n+\n+    fn inline_asm_error(&self, cookie: u32, msg: String) {\n+        drop(self.sender.send(SharedEmitterMessage::InlineAsmError(cookie, msg)));\n+    }\n+\n+    fn fatal(&self, msg: &str) {\n+        drop(self.sender.send(SharedEmitterMessage::Fatal(msg.to_string())));\n+    }\n+}\n+\n+impl Emitter for SharedEmitter {\n+    fn emit(&mut self, db: &DiagnosticBuilder) {\n+        drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n+            msg: db.message(),\n+            code: db.code.clone(),\n+            lvl: db.level,\n+        })));\n+        for child in &db.children {\n+            drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n+                msg: child.message(),\n+                code: None,\n+                lvl: child.level,\n+            })));\n+        }\n+        drop(self.sender.send(SharedEmitterMessage::AbortIfErrors));\n+    }\n+}\n+\n+impl SharedEmitterMain {\n+    pub fn check(&self, sess: &Session, blocking: bool) {\n+        loop {\n+            let message = if blocking {\n+                match self.receiver.recv() {\n+                    Ok(message) => Ok(message),\n+                    Err(_) => Err(()),\n+                }\n+            } else {\n+                match self.receiver.try_recv() {\n+                    Ok(message) => Ok(message),\n+                    Err(_) => Err(()),\n+                }\n+            };\n+\n+            match message {\n+                Ok(SharedEmitterMessage::Diagnostic(diag)) => {\n+                    let handler = sess.diagnostic();\n+                    match diag.code {\n+                        Some(ref code) => {\n+                            handler.emit_with_code(&MultiSpan::new(),\n+                                                   &diag.msg,\n+                                                   &code,\n+                                                   diag.lvl);\n+                        }\n+                        None => {\n+                            handler.emit(&MultiSpan::new(),\n+                                         &diag.msg,\n+                                         diag.lvl);\n+                        }\n+                    }\n+                }\n+                Ok(SharedEmitterMessage::InlineAsmError(cookie, msg)) => {\n+                    match Mark::from_u32(cookie).expn_info() {\n+                        Some(ei) => sess.span_err(ei.call_site, &msg),\n+                        None     => sess.err(&msg),\n+                    }\n+                }\n+                Ok(SharedEmitterMessage::AbortIfErrors) => {\n+                    sess.abort_if_errors();\n+                }\n+                Ok(SharedEmitterMessage::Fatal(msg)) => {\n+                    sess.fatal(&msg);\n+                }\n+                Err(_) => {\n+                    break;\n+                }\n+            }\n+\n+        }\n+    }\n+}\n+\n+pub struct OngoingCrateTranslation {\n+    crate_name: Symbol,\n+    link: LinkMeta,\n+    metadata: EncodedMetadata,\n+    exported_symbols: Arc<ExportedSymbols>,\n+    no_builtins: bool,\n+    windows_subsystem: Option<String>,\n+    linker_info: LinkerInfo,\n+    no_integrated_as: bool,\n+\n+    output_filenames: OutputFilenames,\n+    regular_module_config: ModuleConfig,\n+    metadata_module_config: ModuleConfig,\n+    allocator_module_config: ModuleConfig,\n+\n+    time_graph: Option<TimeGraph>,\n+    coordinator_send: Sender<Message>,\n+    trans_worker_receive: Receiver<Message>,\n+    shared_emitter_main: SharedEmitterMain,\n+    future: thread::JoinHandle<CompiledModules>,\n+}\n+\n+impl OngoingCrateTranslation {\n+    pub fn join(self, sess: &Session) -> CrateTranslation {\n+        self.shared_emitter_main.check(sess, true);\n+        let compiled_modules = match self.future.join() {\n+            Ok(compiled_modules) => compiled_modules,\n+            Err(_) => {\n+                sess.fatal(\"Error during translation/LLVM phase.\");\n+            }\n+        };\n+\n+        sess.abort_if_errors();\n+\n+        if let Some(time_graph) = self.time_graph {\n+            time_graph.dump(&format!(\"{}-timings\", self.crate_name));\n+        }\n+\n+        copy_module_artifacts_into_incr_comp_cache(sess,\n+                                                   &compiled_modules,\n+                                                   &self.output_filenames);\n+        produce_final_output_artifacts(sess,\n+                                       &compiled_modules,\n+                                       &self.output_filenames);\n+\n+        // FIXME: time_llvm_passes support - does this use a global context or\n+        // something?\n+        if sess.opts.cg.codegen_units == 1 && sess.time_llvm_passes() {\n+            unsafe { llvm::LLVMRustPrintPassTimings(); }\n+        }\n+\n+        let trans = CrateTranslation {\n+            crate_name: self.crate_name,\n+            link: self.link,\n+            metadata: self.metadata,\n+            exported_symbols: self.exported_symbols,\n+            no_builtins: self.no_builtins,\n+            windows_subsystem: self.windows_subsystem,\n+            linker_info: self.linker_info,\n+\n+            modules: compiled_modules.modules,\n+            metadata_module: compiled_modules.metadata_module,\n+            allocator_module: compiled_modules.allocator_module,\n+        };\n+\n+        if self.no_integrated_as {\n+            run_assembler(sess,  &self.output_filenames);\n+\n+            // HACK the linker expects the object file to be named foo.0.o but\n+            // `run_assembler` produces an object named just foo.o. Rename it if we\n+            // are going to build an executable\n+            if sess.opts.output_types.contains_key(&OutputType::Exe) {\n+                let f =  self.output_filenames.path(OutputType::Object);\n+                rename_or_copy_remove(&f,\n+                    f.with_file_name(format!(\"{}.0.o\",\n+                                             f.file_stem().unwrap().to_string_lossy()))).unwrap();\n+            }\n+\n+            // Remove assembly source, unless --save-temps was specified\n+            if !sess.opts.cg.save_temps {\n+                fs::remove_file(&self.output_filenames\n+                                     .temp_path(OutputType::Assembly, None)).unwrap();\n+            }\n+        }\n+\n+        trans\n+    }\n+\n+    pub fn submit_translated_module_to_llvm(&self,\n+                                            sess: &Session,\n+                                            mtrans: ModuleTranslation,\n+                                            cost: u64,\n+                                            is_last: bool) {\n+        let module_config = match mtrans.kind {\n+            ModuleKind::Regular => self.regular_module_config.clone(sess),\n+            ModuleKind::Metadata => self.metadata_module_config.clone(sess),\n+            ModuleKind::Allocator => self.allocator_module_config.clone(sess),\n+        };\n+\n+        let llvm_work_item = build_work_item(mtrans,\n+                                             module_config,\n+                                             self.output_filenames.clone());\n+\n+        drop(self.coordinator_send.send(Message::TranslationDone {\n+            llvm_work_item,\n+            cost,\n+            is_last\n+        }));\n+    }\n+\n+    pub fn submit_pre_translated_module_to_llvm(&self,\n+                                                sess: &Session,\n+                                                mtrans: ModuleTranslation,\n+                                                is_last: bool) {\n+        self.wait_for_signal_to_translate_item();\n+        self.check_for_errors(sess);\n+\n+        // These are generally cheap and won't through off scheduling.\n+        let cost = 0;\n+        self.submit_translated_module_to_llvm(sess, mtrans, cost, is_last);\n+    }\n+\n+    pub fn check_for_errors(&self, sess: &Session) {\n+        self.shared_emitter_main.check(sess, false);\n+    }\n+\n+    pub fn wait_for_signal_to_translate_item(&self) {\n+        match self.trans_worker_receive.recv() {\n+            Ok(Message::TranslateItem) => {\n+                // Nothing to do\n+            }\n+            Ok(message) => {\n+                panic!(\"unexpected message: {:?}\", message)\n+            }\n+            Err(_) => {\n+                // One of the LLVM threads must have panicked, fall through so\n+                // error handling can be reached.\n+            }\n+        }\n+    }\n+}"}, {"sha": "e8032529b1fe4c54111becf6b30ecf0a6cc49ae2", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 274, "deletions": 154, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -23,29 +23,30 @@\n //!     but one TypeRef corresponds to many `Ty`s; for instance, tup(int, int,\n //!     int) and rec(x=int, y=int, z=int) will have the same TypeRef.\n \n-use super::CrateTranslation;\n use super::ModuleLlvm;\n use super::ModuleSource;\n use super::ModuleTranslation;\n+use super::ModuleKind;\n \n use assert_module_sources;\n use back::link;\n use back::linker::LinkerInfo;\n use back::symbol_export::{self, ExportedSymbols};\n+use back::write::{self, OngoingCrateTranslation};\n use llvm::{ContextRef, Linkage, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n use metadata;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::lang_items::StartFnLangItem;\n-use rustc::middle::cstore::EncodedMetadata;\n+use rustc::middle::cstore::{EncodedMetadata, EncodedMetadataHashes};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::dep_graph::AssertDepGraphSafe;\n use rustc::middle::cstore::LinkMeta;\n use rustc::hir::map as hir_map;\n-use rustc::util::common::time;\n-use rustc::session::config::{self, NoDebugInfo, OutputFilenames};\n+use rustc::util::common::{time, print_time_passes_entry};\n+use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType};\n use rustc::session::Session;\n-use rustc_incremental::IncrementalHashesMap;\n+use rustc_incremental::{self, IncrementalHashesMap};\n use abi;\n use allocator;\n use mir::lvalue::LvalueRef;\n@@ -68,6 +69,7 @@ use mir;\n use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, CodegenUnit};\n use symbol_names_test;\n+use time_graph;\n use trans_item::{TransItem, DefPathBasedNames};\n use type_::Type;\n use type_of;\n@@ -78,6 +80,7 @@ use libc::c_uint;\n use std::ffi::{CStr, CString};\n use std::str;\n use std::sync::Arc;\n+use std::time::{Instant, Duration};\n use std::i32;\n use syntax_pos::Span;\n use syntax::attr;\n@@ -647,24 +650,30 @@ pub fn set_link_section(ccx: &CrateContext,\n     }\n }\n \n+// check for the #[rustc_error] annotation, which forces an\n+// error in trans. This is used to write compile-fail tests\n+// that actually test that compilation succeeds without\n+// reporting an error.\n+fn check_for_rustc_errors_attr(tcx: TyCtxt) {\n+    if let Some((id, span)) = *tcx.sess.entry_fn.borrow() {\n+        let main_def_id = tcx.hir.local_def_id(id);\n+\n+        if tcx.has_attr(main_def_id, \"rustc_error\") {\n+            tcx.sess.span_fatal(span, \"compilation successful\");\n+        }\n+    }\n+}\n+\n /// Create the `main` function which will initialise the rust runtime and call\n /// users main function.\n-pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n+fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n     let (main_def_id, span) = match *ccx.sess().entry_fn.borrow() {\n         Some((id, span)) => {\n             (ccx.tcx().hir.local_def_id(id), span)\n         }\n         None => return,\n     };\n \n-    // check for the #[rustc_error] annotation, which forces an\n-    // error in trans. This is used to write compile-fail tests\n-    // that actually test that compilation succeeds without\n-    // reporting an error.\n-    if ccx.tcx().has_attr(main_def_id, \"rustc_error\") {\n-        ccx.tcx().sess.span_fatal(span, \"compilation successful\");\n-    }\n-\n     let instance = Instance::mono(ccx.tcx(), main_def_id);\n \n     if !ccx.codegen_unit().contains_item(&TransItem::Fn(instance)) {\n@@ -728,7 +737,8 @@ fn contains_null(s: &str) -> bool {\n fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n                             link_meta: &LinkMeta,\n                             exported_symbols: &NodeSet)\n-                            -> (ContextRef, ModuleRef, EncodedMetadata) {\n+                            -> (ContextRef, ModuleRef,\n+                                EncodedMetadata, EncodedMetadataHashes) {\n     use std::io::Write;\n     use flate2::Compression;\n     use flate2::write::DeflateEncoder;\n@@ -758,15 +768,18 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n     }).max().unwrap();\n \n     if kind == MetadataKind::None {\n-        return (metadata_llcx, metadata_llmod, EncodedMetadata::new());\n+        return (metadata_llcx,\n+                metadata_llmod,\n+                EncodedMetadata::new(),\n+                EncodedMetadataHashes::new());\n     }\n \n     let cstore = &tcx.sess.cstore;\n-    let metadata = cstore.encode_metadata(tcx,\n-                                          &link_meta,\n-                                          exported_symbols);\n+    let (metadata, hashes) = cstore.encode_metadata(tcx,\n+                                                    &link_meta,\n+                                                    exported_symbols);\n     if kind == MetadataKind::Uncompressed {\n-        return (metadata_llcx, metadata_llmod, metadata);\n+        return (metadata_llcx, metadata_llmod, metadata, hashes);\n     }\n \n     assert!(kind == MetadataKind::Compressed);\n@@ -794,7 +807,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n         let directive = CString::new(directive).unwrap();\n         llvm::LLVMSetModuleInlineAsm(metadata_llmod, directive.as_ptr())\n     }\n-    return (metadata_llcx, metadata_llmod, metadata);\n+    return (metadata_llcx, metadata_llmod, metadata, hashes);\n }\n \n // Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n@@ -803,7 +816,7 @@ fn write_metadata<'a, 'gcx>(tcx: TyCtxt<'a, 'gcx, 'gcx>,\n // code references on its own.\n // See #26591, #27438\n fn create_imps(sess: &Session,\n-               llvm_modules: &[ModuleLlvm]) {\n+               llvm_module: &ModuleLlvm) {\n     // The x86 ABI seems to require that leading underscores are added to symbol\n     // names, so we need an extra underscore on 32-bit. There's also a leading\n     // '\\x01' here which disables LLVM's symbol mangling (e.g. no extra\n@@ -814,28 +827,25 @@ fn create_imps(sess: &Session,\n         \"\\x01__imp_\"\n     };\n     unsafe {\n-        for ll in llvm_modules {\n-            let exported: Vec<_> = iter_globals(ll.llmod)\n-                                       .filter(|&val| {\n-                                           llvm::LLVMRustGetLinkage(val) ==\n-                                           llvm::Linkage::ExternalLinkage &&\n-                                           llvm::LLVMIsDeclaration(val) == 0\n-                                       })\n-                                       .collect();\n-\n-            let i8p_ty = Type::i8p_llcx(ll.llcx);\n-            for val in exported {\n-                let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n-                let mut imp_name = prefix.as_bytes().to_vec();\n-                imp_name.extend(name.to_bytes());\n-                let imp_name = CString::new(imp_name).unwrap();\n-                let imp = llvm::LLVMAddGlobal(ll.llmod,\n-                                              i8p_ty.to_ref(),\n-                                              imp_name.as_ptr() as *const _);\n-                let init = llvm::LLVMConstBitCast(val, i8p_ty.to_ref());\n-                llvm::LLVMSetInitializer(imp, init);\n-                llvm::LLVMRustSetLinkage(imp, llvm::Linkage::ExternalLinkage);\n-            }\n+        let exported: Vec<_> = iter_globals(llvm_module.llmod)\n+                                   .filter(|&val| {\n+                                       llvm::LLVMRustGetLinkage(val) ==\n+                                       llvm::Linkage::ExternalLinkage &&\n+                                       llvm::LLVMIsDeclaration(val) == 0\n+                                   })\n+                                   .collect();\n+\n+        let i8p_ty = Type::i8p_llcx(llvm_module.llcx);\n+        for val in exported {\n+            let name = CStr::from_ptr(llvm::LLVMGetValueName(val));\n+            let mut imp_name = prefix.as_bytes().to_vec();\n+            imp_name.extend(name.to_bytes());\n+            let imp_name = CString::new(imp_name).unwrap();\n+            let imp = llvm::LLVMAddGlobal(llvm_module.llmod,\n+                                          i8p_ty.to_ref(),\n+                                          imp_name.as_ptr() as *const _);\n+            llvm::LLVMSetInitializer(imp, consts::ptrcast(val, i8p_ty));\n+            llvm::LLVMRustSetLinkage(imp, llvm::Linkage::ExternalLinkage);\n         }\n     }\n }\n@@ -920,27 +930,26 @@ pub fn find_exported_symbols(tcx: TyCtxt, reachable: &NodeSet) -> NodeSet {\n \n pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              analysis: ty::CrateAnalysis,\n-                             incremental_hashes_map: &IncrementalHashesMap,\n+                             incremental_hashes_map: IncrementalHashesMap,\n                              output_filenames: &OutputFilenames)\n-                             -> CrateTranslation {\n+                             -> OngoingCrateTranslation {\n+    check_for_rustc_errors_attr(tcx);\n+\n     // Be careful with this krate: obviously it gives access to the\n     // entire contents of the krate. So if you push any subtasks of\n     // `TransCrate`, you need to be careful to register \"reads\" of the\n     // particular items that will be processed.\n     let krate = tcx.hir.krate();\n-\n     let ty::CrateAnalysis { reachable, .. } = analysis;\n-\n     let check_overflow = tcx.sess.overflow_checks();\n-\n-    let link_meta = link::build_link_meta(incremental_hashes_map);\n-\n+    let link_meta = link::build_link_meta(&incremental_hashes_map);\n     let exported_symbol_node_ids = find_exported_symbols(tcx, &reachable);\n+\n     let shared_ccx = SharedCrateContext::new(tcx,\n                                              check_overflow,\n                                              output_filenames);\n     // Translate the metadata.\n-    let (metadata_llcx, metadata_llmod, metadata) =\n+    let (metadata_llcx, metadata_llmod, metadata, metadata_incr_hashes) =\n         time(tcx.sess.time_passes(), \"write metadata\", || {\n             write_metadata(tcx, &link_meta, &exported_symbol_node_ids)\n         });\n@@ -952,27 +961,44 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             llcx: metadata_llcx,\n             llmod: metadata_llmod,\n         }),\n+        kind: ModuleKind::Metadata,\n     };\n \n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n+    let time_graph = if tcx.sess.opts.debugging_opts.trans_time_graph {\n+        Some(time_graph::TimeGraph::new())\n+    } else {\n+        None\n+    };\n \n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.debugging_opts.no_trans ||\n        !tcx.sess.opts.output_types.should_trans() {\n         let empty_exported_symbols = ExportedSymbols::empty();\n         let linker_info = LinkerInfo::new(&shared_ccx, &empty_exported_symbols);\n-        return CrateTranslation {\n-            crate_name: tcx.crate_name(LOCAL_CRATE),\n-            modules: vec![],\n-            metadata_module: metadata_module,\n-            allocator_module: None,\n-            link: link_meta,\n-            metadata: metadata,\n-            exported_symbols: empty_exported_symbols,\n-            no_builtins: no_builtins,\n-            linker_info: linker_info,\n-            windows_subsystem: None,\n-        };\n+        let ongoing_translation = write::start_async_translation(\n+            tcx.sess,\n+            output_filenames,\n+            time_graph.clone(),\n+            tcx.crate_name(LOCAL_CRATE),\n+            link_meta,\n+            metadata,\n+            Arc::new(empty_exported_symbols),\n+            no_builtins,\n+            None,\n+            linker_info,\n+            false);\n+\n+        ongoing_translation.submit_pre_translated_module_to_llvm(tcx.sess, metadata_module, true);\n+\n+        assert_and_save_dep_graph(tcx,\n+                                  incremental_hashes_map,\n+                                  metadata_incr_hashes,\n+                                  link_meta);\n+\n+        ongoing_translation.check_for_errors(tcx.sess);\n+\n+        return ongoing_translation;\n     }\n \n     let exported_symbols = Arc::new(ExportedSymbols::compute(tcx,\n@@ -983,12 +1009,110 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (translation_items, codegen_units) =\n         collect_and_partition_translation_items(&shared_ccx, &exported_symbols);\n \n+    assert!(codegen_units.len() <= 1 || !tcx.sess.lto());\n+\n+    let linker_info = LinkerInfo::new(&shared_ccx, &exported_symbols);\n+    let subsystem = attr::first_attr_value_str_by_name(&krate.attrs,\n+                                                       \"windows_subsystem\");\n+    let windows_subsystem = subsystem.map(|subsystem| {\n+        if subsystem != \"windows\" && subsystem != \"console\" {\n+            tcx.sess.fatal(&format!(\"invalid windows subsystem `{}`, only \\\n+                                     `windows` and `console` are allowed\",\n+                                    subsystem));\n+        }\n+        subsystem.to_string()\n+    });\n+\n+    let no_integrated_as = tcx.sess.opts.cg.no_integrated_as ||\n+        (tcx.sess.target.target.options.no_integrated_as &&\n+         (output_filenames.outputs.contains_key(&OutputType::Object) ||\n+          output_filenames.outputs.contains_key(&OutputType::Exe)));\n+\n+    let ongoing_translation = write::start_async_translation(\n+        tcx.sess,\n+        output_filenames,\n+        time_graph.clone(),\n+        tcx.crate_name(LOCAL_CRATE),\n+        link_meta,\n+        metadata,\n+        exported_symbols.clone(),\n+        no_builtins,\n+        windows_subsystem,\n+        linker_info,\n+        no_integrated_as);\n+\n+    // Translate an allocator shim, if any\n+    //\n+    // If LTO is enabled and we've got some previous LLVM module we translated\n+    // above, then we can just translate directly into that LLVM module. If not,\n+    // however, we need to create a separate module and trans into that. Note\n+    // that the separate translation is critical for the standard library where\n+    // the rlib's object file doesn't have allocator functions but the dylib\n+    // links in an object file that has allocator functions. When we're\n+    // compiling a final LTO artifact, though, there's no need to worry about\n+    // this as we're not working with this dual \"rlib/dylib\" functionality.\n+    let allocator_module = if tcx.sess.lto() {\n+        None\n+    } else if let Some(kind) = tcx.sess.allocator_kind.get() {\n+        unsafe {\n+            let (llcx, llmod) =\n+                context::create_context_and_module(tcx.sess, \"allocator\");\n+            let modules = ModuleLlvm {\n+                llmod: llmod,\n+                llcx: llcx,\n+            };\n+            time(tcx.sess.time_passes(), \"write allocator module\", || {\n+                allocator::trans(tcx, &modules, kind)\n+            });\n+\n+            Some(ModuleTranslation {\n+                name: link::ALLOCATOR_MODULE_NAME.to_string(),\n+                symbol_name_hash: 0, // we always rebuild allocator shims\n+                source: ModuleSource::Translated(modules),\n+                kind: ModuleKind::Allocator,\n+            })\n+        }\n+    } else {\n+        None\n+    };\n+\n+    if let Some(allocator_module) = allocator_module {\n+        ongoing_translation.submit_pre_translated_module_to_llvm(tcx.sess, allocator_module, false);\n+    }\n+\n+    let codegen_unit_count = codegen_units.len();\n+    ongoing_translation.submit_pre_translated_module_to_llvm(tcx.sess,\n+                                                             metadata_module,\n+                                                             codegen_unit_count == 0);\n+\n     let translation_items = Arc::new(translation_items);\n \n     let mut all_stats = Stats::default();\n-    let modules: Vec<ModuleTranslation> = codegen_units\n-        .into_iter()\n-        .map(|cgu| {\n+    let mut module_dispositions = tcx.sess.opts.incremental.as_ref().map(|_| Vec::new());\n+\n+    // We sort the codegen units by size. This way we can schedule work for LLVM\n+    // a bit more efficiently. Note that \"size\" is defined rather crudely at the\n+    // moment as it is just the number of TransItems in the CGU, not taking into\n+    // account the size of each TransItem.\n+    let codegen_units = {\n+        let mut codegen_units = codegen_units;\n+        codegen_units.sort_by_key(|cgu| -(cgu.items().len() as isize));\n+        codegen_units\n+    };\n+\n+    let mut total_trans_time = Duration::new(0, 0);\n+\n+    for (cgu_index, cgu) in codegen_units.into_iter().enumerate() {\n+        ongoing_translation.wait_for_signal_to_translate_item();\n+        ongoing_translation.check_for_errors(tcx.sess);\n+\n+        let start_time = Instant::now();\n+\n+        let module = {\n+            let _timing_guard = time_graph\n+                .as_ref()\n+                .map(|time_graph| time_graph.start(write::TRANS_WORKER_TIMELINE,\n+                                                   write::TRANS_WORK_PACKAGE_KIND));\n             let dep_node = cgu.work_product_dep_node();\n             let ((stats, module), _) =\n                 tcx.dep_graph.with_task(dep_node,\n@@ -998,9 +1122,41 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                             exported_symbols.clone())),\n                                         module_translation);\n             all_stats.extend(stats);\n+\n+            if let Some(ref mut module_dispositions) = module_dispositions {\n+                module_dispositions.push(module.disposition());\n+            }\n+\n             module\n-        })\n-        .collect();\n+        };\n+\n+        let time_to_translate = Instant::now().duration_since(start_time);\n+\n+        // We assume that the cost to run LLVM on a CGU is proportional to\n+        // the time we needed for translating it.\n+        let cost = time_to_translate.as_secs() * 1_000_000_000 +\n+                   time_to_translate.subsec_nanos() as u64;\n+\n+        total_trans_time += time_to_translate;\n+\n+        let is_last_cgu = (cgu_index + 1) == codegen_unit_count;\n+\n+        ongoing_translation.submit_translated_module_to_llvm(tcx.sess,\n+                                                             module,\n+                                                             cost,\n+                                                             is_last_cgu);\n+        ongoing_translation.check_for_errors(tcx.sess);\n+    }\n+\n+    // Since the main thread is sometimes blocked during trans, we keep track\n+    // -Ztime-passes output manually.\n+    print_time_passes_entry(tcx.sess.time_passes(),\n+                            \"translate to LLVM IR\",\n+                            total_trans_time);\n+\n+    if let Some(module_dispositions) = module_dispositions {\n+        assert_module_sources::assert_module_sources(tcx, &module_dispositions);\n+    }\n \n     fn module_translation<'a, 'tcx>(\n         scx: AssertDepGraphSafe<&SharedCrateContext<'a, 'tcx>>,\n@@ -1015,7 +1171,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         let cgu_name = String::from(cgu.name());\n         let cgu_id = cgu.work_product_id();\n-        let symbol_name_hash = cgu.compute_symbol_name_hash(scx, &exported_symbols);\n+        let symbol_name_hash = cgu.compute_symbol_name_hash(scx);\n \n         // Check whether there is a previous work-product we can\n         // re-use.  Not only must the file exist, and the inputs not\n@@ -1044,7 +1200,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let module = ModuleTranslation {\n                 name: cgu_name,\n                 symbol_name_hash,\n-                source: ModuleSource::Preexisting(buf.clone())\n+                source: ModuleSource::Preexisting(buf.clone()),\n+                kind: ModuleKind::Regular,\n             };\n             return (Stats::default(), module);\n         }\n@@ -1099,21 +1256,40 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 debuginfo::finalize(&ccx);\n             }\n \n+            let llvm_module = ModuleLlvm {\n+                llcx: ccx.llcx(),\n+                llmod: ccx.llmod(),\n+            };\n+\n+            // In LTO mode we inject the allocator shim into the existing\n+            // module.\n+            if ccx.sess().lto() {\n+                if let Some(kind) = ccx.sess().allocator_kind.get() {\n+                    time(ccx.sess().time_passes(), \"write allocator module\", || {\n+                        unsafe {\n+                            allocator::trans(ccx.tcx(), &llvm_module, kind);\n+                        }\n+                    });\n+                }\n+            }\n+\n+            // Adjust exported symbols for MSVC dllimport\n+            if ccx.sess().target.target.options.is_like_msvc &&\n+               ccx.sess().crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n+                create_imps(ccx.sess(), &llvm_module);\n+            }\n+\n             ModuleTranslation {\n                 name: cgu_name,\n                 symbol_name_hash,\n-                source: ModuleSource::Translated(ModuleLlvm {\n-                    llcx: ccx.llcx(),\n-                    llmod: ccx.llmod(),\n-                })\n+                source: ModuleSource::Translated(llvm_module),\n+                kind: ModuleKind::Regular,\n             }\n         };\n \n         (lcx.into_stats(), module)\n     }\n \n-    assert_module_sources::assert_module_sources(tcx, &modules);\n-\n     symbol_names_test::report_symbol_names(tcx);\n \n     if shared_ccx.sess().trans_stats() {\n@@ -1144,85 +1320,29 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n     }\n \n-    let sess = shared_ccx.sess();\n-\n-    // Get the list of llvm modules we created. We'll do a few wacky\n-    // transforms on them now.\n-\n-    let llvm_modules: Vec<_> =\n-        modules.iter()\n-               .filter_map(|module| match module.source {\n-                   ModuleSource::Translated(llvm) => Some(llvm),\n-                   _ => None,\n-               })\n-               .collect();\n-\n-    if sess.target.target.options.is_like_msvc &&\n-       sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n-        create_imps(sess, &llvm_modules);\n-    }\n-\n-    // Translate an allocator shim, if any\n-    //\n-    // If LTO is enabled and we've got some previous LLVM module we translated\n-    // above, then we can just translate directly into that LLVM module. If not,\n-    // however, we need to create a separate module and trans into that. Note\n-    // that the separate translation is critical for the standard library where\n-    // the rlib's object file doesn't have allocator functions but the dylib\n-    // links in an object file that has allocator functions. When we're\n-    // compiling a final LTO artifact, though, there's no need to worry about\n-    // this as we're not working with this dual \"rlib/dylib\" functionality.\n-    let allocator_module = tcx.sess.allocator_kind.get().and_then(|kind| unsafe {\n-        if sess.lto() && llvm_modules.len() > 0 {\n-            time(tcx.sess.time_passes(), \"write allocator module\", || {\n-                allocator::trans(tcx, &llvm_modules[0], kind)\n-            });\n-            None\n-        } else {\n-            let (llcx, llmod) =\n-                context::create_context_and_module(tcx.sess, \"allocator\");\n-            let modules = ModuleLlvm {\n-                llmod: llmod,\n-                llcx: llcx,\n-            };\n-            time(tcx.sess.time_passes(), \"write allocator module\", || {\n-                allocator::trans(tcx, &modules, kind)\n-            });\n-\n-            Some(ModuleTranslation {\n-                name: link::ALLOCATOR_MODULE_NAME.to_string(),\n-                symbol_name_hash: 0, // we always rebuild allocator shims\n-                source: ModuleSource::Translated(modules),\n-            })\n-        }\n-    });\n-\n-    let linker_info = LinkerInfo::new(&shared_ccx, &exported_symbols);\n+    ongoing_translation.check_for_errors(tcx.sess);\n \n-    let subsystem = attr::first_attr_value_str_by_name(&krate.attrs,\n-                                                       \"windows_subsystem\");\n-    let windows_subsystem = subsystem.map(|subsystem| {\n-        if subsystem != \"windows\" && subsystem != \"console\" {\n-            tcx.sess.fatal(&format!(\"invalid windows subsystem `{}`, only \\\n-                                     `windows` and `console` are allowed\",\n-                                    subsystem));\n-        }\n-        subsystem.to_string()\n-    });\n+    assert_and_save_dep_graph(tcx,\n+                              incremental_hashes_map,\n+                              metadata_incr_hashes,\n+                              link_meta);\n+    ongoing_translation\n+}\n \n-    CrateTranslation {\n-        crate_name: tcx.crate_name(LOCAL_CRATE),\n-        modules: modules,\n-        metadata_module: metadata_module,\n-        allocator_module: allocator_module,\n-        link: link_meta,\n-        metadata: metadata,\n-        exported_symbols: Arc::try_unwrap(exported_symbols)\n-            .expect(\"There's still a reference to exported_symbols?\"),\n-        no_builtins: no_builtins,\n-        linker_info: linker_info,\n-        windows_subsystem: windows_subsystem,\n-    }\n+fn assert_and_save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       incremental_hashes_map: IncrementalHashesMap,\n+                                       metadata_incr_hashes: EncodedMetadataHashes,\n+                                       link_meta: LinkMeta) {\n+    time(tcx.sess.time_passes(),\n+         \"assert dep graph\",\n+         || rustc_incremental::assert_dep_graph(tcx));\n+\n+    time(tcx.sess.time_passes(),\n+         \"serialize dep graph\",\n+         || rustc_incremental::save_dep_graph(tcx,\n+                                              incremental_hashes_map,\n+                                              &metadata_incr_hashes,\n+                                              link_meta.crate_hash));\n }\n \n #[inline(never)] // give this a place in the profiler"}, {"sha": "635741b4d1ac5dd2e9a2ac6adb59fd3032a243ec", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -8,14 +8,50 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use abi::{FnType, ArgType, LayoutExt, Reg, Uniform};\n+use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CrateContext;\n+use llvm::CallConv;\n \n-fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+fn is_homogeneous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+                                     -> Option<Uniform> {\n+    arg.layout.homogeneous_aggregate(ccx).and_then(|unit| {\n+        let size = arg.layout.size(ccx);\n+\n+        // Ensure we have at most four uniquely addressable members.\n+        if size > unit.size.checked_mul(4, ccx).unwrap() {\n+            return None;\n+        }\n+\n+        let valid_unit = match unit.kind {\n+            RegKind::Integer => false,\n+            RegKind::Float => true,\n+            RegKind::Vector => size.bits() == 64 || size.bits() == 128\n+        };\n+\n+        if valid_unit {\n+            Some(Uniform {\n+                unit,\n+                total: size\n+            })\n+        } else {\n+            None\n+        }\n+    })\n+}\n+\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>, vfp: bool) {\n     if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n         return;\n     }\n+\n+    if vfp {\n+        if let Some(uniform) = is_homogeneous_aggregate(ccx, ret) {\n+            ret.cast_to(ccx, uniform);\n+            return;\n+        }\n+    }\n+\n     let size = ret.layout.size(ccx);\n     let bits = size.bits();\n     if bits <= 32 {\n@@ -35,11 +71,19 @@ fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tc\n     ret.make_indirect(ccx);\n }\n \n-fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>, vfp: bool) {\n     if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n         return;\n     }\n+\n+    if vfp {\n+        if let Some(uniform) = is_homogeneous_aggregate(ccx, arg) {\n+            arg.cast_to(ccx, uniform);\n+            return;\n+        }\n+    }\n+\n     let align = arg.layout.align(ccx).abi();\n     let total = arg.layout.size(ccx);\n     arg.cast_to(ccx, Uniform {\n@@ -49,12 +93,18 @@ fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tc\n }\n \n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    // If this is a target with a hard-float ABI, and the function is not explicitly\n+    // `extern \"aapcs\"`, then we must use the VFP registers for homogeneous aggregates.\n+    let vfp = ccx.sess().target.target.llvm_target.ends_with(\"hf\")\n+        && fty.cconv != CallConv::ArmAapcsCallConv\n+        && !fty.variadic;\n+\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret);\n+        classify_ret_ty(ccx, &mut fty.ret, vfp);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg);\n+        classify_arg_ty(ccx, arg, vfp);\n     }\n }"}, {"sha": "184c6f83579302241b0bd6c25c6264f1e1ab4096", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -234,12 +234,6 @@ pub fn C_big_integral(t: Type, u: u128) -> ValueRef {\n     }\n }\n \n-pub fn C_floating_f64(f: f64, t: Type) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMConstReal(t.to_ref(), f)\n-    }\n-}\n-\n pub fn C_nil(ccx: &CrateContext) -> ValueRef {\n     C_struct(ccx, &[], false)\n }\n@@ -383,7 +377,7 @@ pub fn const_to_uint(v: ValueRef) -> u64 {\n     }\n }\n \n-fn is_const_integral(v: ValueRef) -> bool {\n+pub fn is_const_integral(v: ValueRef) -> bool {\n     unsafe {\n         !llvm::LLVMIsAConstantInt(v).is_null()\n     }"}, {"sha": "310cd6fe9559d8942d4af168ee4603b76bec8fa0", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -36,6 +36,12 @@ pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n     }\n }\n \n+pub fn bitcast(val: ValueRef, ty: Type) -> ValueRef {\n+    unsafe {\n+        llvm::LLVMConstBitCast(val, ty.to_ref())\n+    }\n+}\n+\n pub fn addr_of_mut(ccx: &CrateContext,\n                    cv: ValueRef,\n                    align: machine::llalign,"}, {"sha": "5a4a5b95cf90a8abbdffca2c6c35b865945ccedb", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 60, "deletions": 7, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -36,9 +36,9 @@\n \n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n+use std::sync::Arc;\n \n extern crate flate2;\n-extern crate crossbeam;\n extern crate libc;\n extern crate owning_ref;\n #[macro_use] extern crate rustc;\n@@ -54,6 +54,7 @@ extern crate rustc_const_math;\n extern crate rustc_bitflags;\n extern crate rustc_demangle;\n extern crate jobserver;\n+extern crate num_cpus;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -124,13 +125,13 @@ mod mir;\n mod monomorphize;\n mod partitioning;\n mod symbol_names_test;\n+mod time_graph;\n mod trans_item;\n mod tvec;\n mod type_;\n mod type_of;\n mod value;\n \n-#[derive(Clone)]\n pub struct ModuleTranslation {\n     /// The name of the module. When the crate may be saved between\n     /// compilations, incremental compilation requires that name be\n@@ -140,6 +141,58 @@ pub struct ModuleTranslation {\n     pub name: String,\n     pub symbol_name_hash: u64,\n     pub source: ModuleSource,\n+    pub kind: ModuleKind,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum ModuleKind {\n+    Regular,\n+    Metadata,\n+    Allocator,\n+}\n+\n+impl ModuleTranslation {\n+    pub fn into_compiled_module(self, emit_obj: bool, emit_bc: bool) -> CompiledModule {\n+        let pre_existing = match self.source {\n+            ModuleSource::Preexisting(_) => true,\n+            ModuleSource::Translated(_) => false,\n+        };\n+\n+        CompiledModule {\n+            name: self.name.clone(),\n+            kind: self.kind,\n+            symbol_name_hash: self.symbol_name_hash,\n+            pre_existing,\n+            emit_obj,\n+            emit_bc,\n+        }\n+    }\n+}\n+\n+impl Drop for ModuleTranslation {\n+    fn drop(&mut self) {\n+        match self.source {\n+            ModuleSource::Preexisting(_) => {\n+                // Nothing to dispose.\n+            },\n+            ModuleSource::Translated(llvm) => {\n+                unsafe {\n+                    llvm::LLVMDisposeModule(llvm.llmod);\n+                    llvm::LLVMContextDispose(llvm.llcx);\n+                }\n+            },\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct CompiledModule {\n+    pub name: String,\n+    pub kind: ModuleKind,\n+    pub symbol_name_hash: u64,\n+    pub pre_existing: bool,\n+    pub emit_obj: bool,\n+    pub emit_bc: bool,\n }\n \n #[derive(Clone)]\n@@ -151,7 +204,7 @@ pub enum ModuleSource {\n     Translated(ModuleLlvm),\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub struct ModuleLlvm {\n     pub llcx: llvm::ContextRef,\n     pub llmod: llvm::ModuleRef,\n@@ -162,12 +215,12 @@ unsafe impl Sync for ModuleTranslation { }\n \n pub struct CrateTranslation {\n     pub crate_name: Symbol,\n-    pub modules: Vec<ModuleTranslation>,\n-    pub metadata_module: ModuleTranslation,\n-    pub allocator_module: Option<ModuleTranslation>,\n+    pub modules: Vec<CompiledModule>,\n+    pub metadata_module: CompiledModule,\n+    pub allocator_module: Option<CompiledModule>,\n     pub link: rustc::middle::cstore::LinkMeta,\n     pub metadata: rustc::middle::cstore::EncodedMetadata,\n-    pub exported_symbols: back::symbol_export::ExportedSymbols,\n+    pub exported_symbols: Arc<back::symbol_export::ExportedSymbols>,\n     pub no_builtins: bool,\n     pub windows_subsystem: Option<String>,\n     pub linker_info: back::linker::LinkerInfo"}, {"sha": "448feb5259ddd81fe65d33ee0f2b0278e6d5aceb", "filename": "src/librustc_trans/llvm_util.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -80,7 +80,10 @@ const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bm\n \n const HEXAGON_WHITELIST: &'static [&'static str] = &[\"hvx\\0\", \"hvx-double\\0\"];\n \n-const POWERPC_WHITELIST: &'static [&'static str] = &[\"altivec\\0\", \"vsx\\0\"];\n+const POWERPC_WHITELIST: &'static [&'static str] = &[\"altivec\\0\",\n+                                                     \"power8-altivec\\0\", \"power9-altivec\\0\",\n+                                                     \"power8-vector\\0\", \"power9-vector\\0\",\n+                                                     \"vsx\\0\"];\n \n pub fn target_features(sess: &Session) -> Vec<Symbol> {\n     let target_machine = create_target_machine(sess);"}, {"sha": "883808c59091a02d60e45f7308fc41af46d6ce08", "filename": "src/librustc_trans/metadata.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmetadata.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -31,21 +31,21 @@ impl MetadataLoader for LlvmMetadataLoader {\n         // just keeping the archive along while the metadata is in use.\n         let archive = ArchiveRO::open(filename)\n             .map(|ar| OwningRef::new(box ar))\n-            .ok_or_else(|| {\n-                            debug!(\"llvm didn't like `{}`\", filename.display());\n-                            format!(\"failed to read rlib metadata: '{}'\", filename.display())\n-                        })?;\n+            .map_err(|e| {\n+                debug!(\"llvm didn't like `{}`: {}\", filename.display(), e);\n+                format!(\"failed to read rlib metadata in '{}': {}\", filename.display(), e)\n+            })?;\n         let buf: OwningRef<_, [u8]> = archive\n             .try_map(|ar| {\n                 ar.iter()\n                     .filter_map(|s| s.ok())\n                     .find(|sect| sect.name() == Some(METADATA_FILENAME))\n                     .map(|s| s.data())\n                     .ok_or_else(|| {\n-                                    debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n-                                    format!(\"failed to read rlib metadata: '{}'\",\n-                                            filename.display())\n-                                })\n+                        debug!(\"didn't find '{}' in the archive\", METADATA_FILENAME);\n+                        format!(\"failed to read rlib metadata: '{}'\",\n+                                filename.display())\n+                    })\n             })?;\n         Ok(buf.erase_owner())\n     }"}, {"sha": "a17ddabb1a7cdade098131471633a1e615b865bd", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -158,6 +158,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n \n                 LvalueContext::StorageLive |\n                 LvalueContext::StorageDead |\n+                LvalueContext::Validate |\n                 LvalueContext::Inspect |\n                 LvalueContext::Consume => {}\n "}, {"sha": "b43e76df04c3ebec5d03b925de8e7b9490670dcf", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -11,7 +11,6 @@\n use llvm::{self, ValueRef};\n use rustc::middle::const_val::{ConstEvalErr, ConstVal, ErrKind};\n use rustc_const_math::ConstInt::*;\n-use rustc_const_math::ConstFloat::*;\n use rustc_const_math::{ConstInt, ConstMathErr};\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n@@ -27,7 +26,7 @@ use abi::{self, Abi};\n use callee;\n use builder::Builder;\n use common::{self, CrateContext, const_get_elt, val_ty};\n-use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral, C_big_integral};\n+use common::{C_array, C_bool, C_bytes, C_integral, C_big_integral, C_u32, C_u64};\n use common::{C_null, C_struct, C_str_slice, C_undef, C_uint, C_vector, is_undef};\n use common::const_to_opt_u128;\n use consts;\n@@ -37,6 +36,7 @@ use type_::Type;\n use value::Value;\n \n use syntax_pos::Span;\n+use syntax::ast;\n \n use std::fmt;\n use std::ptr;\n@@ -95,8 +95,13 @@ impl<'tcx> Const<'tcx> {\n                              -> Const<'tcx> {\n         let llty = type_of::type_of(ccx, ty);\n         let val = match cv {\n-            ConstVal::Float(F32(v)) => C_floating_f64(v as f64, llty),\n-            ConstVal::Float(F64(v)) => C_floating_f64(v, llty),\n+            ConstVal::Float(v) => {\n+                let bits = match v.ty {\n+                    ast::FloatTy::F32 => C_u32(ccx, v.bits as u32),\n+                    ast::FloatTy::F64 => C_u64(ccx, v.bits as u64)\n+                };\n+                consts::bitcast(bits, llty)\n+            }\n             ConstVal::Bool(v) => C_bool(ccx, v),\n             ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n@@ -222,15 +227,24 @@ struct MirConstContext<'a, 'tcx: 'a> {\n     substs: &'tcx Substs<'tcx>,\n \n     /// Values of locals in a constant or const fn.\n-    locals: IndexVec<mir::Local, Option<Const<'tcx>>>\n+    locals: IndexVec<mir::Local, Option<Result<Const<'tcx>, ConstEvalErr<'tcx>>>>\n }\n \n+fn add_err<'tcx, U, V>(failure: &mut Result<U, ConstEvalErr<'tcx>>,\n+                       value: &Result<V, ConstEvalErr<'tcx>>)\n+{\n+    if let &Err(ref err) = value {\n+        if failure.is_ok() {\n+            *failure = Err(err.clone());\n+        }\n+    }\n+}\n \n impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn new(ccx: &'a CrateContext<'a, 'tcx>,\n            mir: &'a mir::Mir<'tcx>,\n            substs: &'tcx Substs<'tcx>,\n-           args: IndexVec<mir::Local, Const<'tcx>>)\n+           args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n            -> MirConstContext<'a, 'tcx> {\n         let mut context = MirConstContext {\n             ccx: ccx,\n@@ -249,7 +263,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n     fn trans_def(ccx: &'a CrateContext<'a, 'tcx>,\n                  def_id: DefId,\n                  substs: &'tcx Substs<'tcx>,\n-                 args: IndexVec<mir::Local, Const<'tcx>>)\n+                 args: IndexVec<mir::Local, Result<Const<'tcx>, ConstEvalErr<'tcx>>>)\n                  -> Result<Const<'tcx>, ConstEvalErr<'tcx>> {\n         let instance = monomorphize::resolve(ccx.shared(), def_id, substs);\n         let mir = ccx.tcx().instance_mir(instance.def);\n@@ -278,13 +292,13 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::StatementKind::Assign(ref dest, ref rvalue) => {\n                         let ty = dest.ty(self.mir, tcx);\n                         let ty = self.monomorphize(&ty).to_ty(tcx);\n-                        match self.const_rvalue(rvalue, ty, span) {\n-                            Ok(value) => self.store(dest, value, span),\n-                            Err(err) => if failure.is_ok() { failure = Err(err); }\n-                        }\n+                        let value = self.const_rvalue(rvalue, ty, span);\n+                        add_err(&mut failure, &value);\n+                        self.store(dest, value, span);\n                     }\n                     mir::StatementKind::StorageLive(_) |\n                     mir::StatementKind::StorageDead(_) |\n+                    mir::StatementKind::Validate(..) |\n                     mir::StatementKind::EndRegion(_) |\n                     mir::StatementKind::Nop => {}\n                     mir::StatementKind::InlineAsm { .. } |\n@@ -301,9 +315,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                 mir::TerminatorKind::Goto { target } => target,\n                 mir::TerminatorKind::Return => {\n                     failure?;\n-                    return Ok(self.locals[mir::RETURN_POINTER].unwrap_or_else(|| {\n+                    return self.locals[mir::RETURN_POINTER].clone().unwrap_or_else(|| {\n                         span_bug!(span, \"no returned value in constant\");\n-                    }));\n+                    });\n                 }\n \n                 mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, .. } => {\n@@ -345,33 +359,30 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n                     let mut arg_vals = IndexVec::with_capacity(args.len());\n                     for arg in args {\n-                        match self.const_operand(arg, span) {\n-                            Ok(arg) => { arg_vals.push(arg); },\n-                            Err(err) => if failure.is_ok() { failure = Err(err); }\n-                        }\n+                        let arg_val = self.const_operand(arg, span);\n+                        add_err(&mut failure, &arg_val);\n+                        arg_vals.push(arg_val);\n                     }\n                     if let Some((ref dest, target)) = *destination {\n-                        if fn_ty.fn_sig(tcx).abi() == Abi::RustIntrinsic {\n-                            let value = match &tcx.item_name(def_id).as_str()[..] {\n+                        let result = if fn_ty.fn_sig(tcx).abi() == Abi::RustIntrinsic {\n+                            match &tcx.item_name(def_id).as_str()[..] {\n                                 \"size_of\" => {\n                                     let llval = C_uint(self.ccx,\n                                         self.ccx.size_of(substs.type_at(0)));\n-                                    Const::new(llval, tcx.types.usize)\n+                                    Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 \"min_align_of\" => {\n                                     let llval = C_uint(self.ccx,\n                                         self.ccx.align_of(substs.type_at(0)));\n-                                    Const::new(llval, tcx.types.usize)\n+                                    Ok(Const::new(llval, tcx.types.usize))\n                                 }\n                                 _ => span_bug!(span, \"{:?} in constant\", terminator.kind)\n-                            };\n-                            self.store(dest, value, span);\n-                        } else {\n-                            match MirConstContext::trans_def(self.ccx, def_id, substs, arg_vals) {\n-                                Ok(value) => self.store(dest, value, span),\n-                                Err(err) => if failure.is_ok() { failure = Err(err); }\n                             }\n-                        }\n+                        } else {\n+                            MirConstContext::trans_def(self.ccx, def_id, substs, arg_vals)\n+                        };\n+                        add_err(&mut failure, &result);\n+                        self.store(dest, result, span);\n                         target\n                     } else {\n                         span_bug!(span, \"diverging {:?} in constant\", terminator.kind);\n@@ -382,7 +393,10 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         }\n     }\n \n-    fn store(&mut self, dest: &mir::Lvalue<'tcx>, value: Const<'tcx>, span: Span) {\n+    fn store(&mut self,\n+             dest: &mir::Lvalue<'tcx>,\n+             value: Result<Const<'tcx>, ConstEvalErr<'tcx>>,\n+             span: Span) {\n         if let mir::Lvalue::Local(index) = *dest {\n             self.locals[index] = Some(value);\n         } else {\n@@ -395,9 +409,9 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n         let tcx = self.ccx.tcx();\n \n         if let mir::Lvalue::Local(index) = *lvalue {\n-            return Ok(self.locals[index].unwrap_or_else(|| {\n+            return self.locals[index].clone().unwrap_or_else(|| {\n                 span_bug!(span, \"{:?} not initialized\", lvalue)\n-            }).as_lvalue());\n+            }).map(|v| v.as_lvalue());\n         }\n \n         let lvalue = match *lvalue {"}, {"sha": "a23e1a0684bf4c27770058325dde9b9f132a0e77", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -20,7 +20,7 @@ use base;\n use builder::Builder;\n use callee;\n use common::{self, val_ty, C_bool, C_null, C_uint};\n-use common::{C_integral};\n+use common::{C_integral, C_i32};\n use adt;\n use machine;\n use monomorphize;\n@@ -93,12 +93,42 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             mir::Rvalue::Repeat(ref elem, ref count) => {\n+                let dest_ty = dest.ty.to_ty(bcx.tcx());\n+\n+                // No need to inizialize memory of a zero-sized slice\n+                if common::type_is_zero_size(bcx.ccx, dest_ty) {\n+                    return bcx;\n+                }\n+\n                 let tr_elem = self.trans_operand(&bcx, elem);\n                 let size = count.as_u64(bcx.tcx().sess.target.uint_type);\n                 let size = C_uint(bcx.ccx, size);\n                 let base = base::get_dataptr(&bcx, dest.llval);\n+                let align = dest.alignment.to_align();\n+\n+                if let OperandValue::Immediate(v) = tr_elem.val {\n+                    // Use llvm.memset.p0i8.* to initialize all zero arrays\n+                    if common::is_const_integral(v) && common::const_to_uint(v) == 0 {\n+                        let align = align.unwrap_or_else(|| bcx.ccx.align_of(tr_elem.ty));\n+                        let align = C_i32(bcx.ccx, align as i32);\n+                        let ty = type_of::type_of(bcx.ccx, dest_ty);\n+                        let size = machine::llsize_of(bcx.ccx, ty);\n+                        let fill = C_integral(Type::i8(bcx.ccx), 0, false);\n+                        base::call_memset(&bcx, base, fill, size, align, false);\n+                        return bcx;\n+                    }\n+\n+                    // Use llvm.memset.p0i8.* to initialize byte arrays\n+                    if common::val_ty(v) == Type::i8(bcx.ccx) {\n+                        let align = align.unwrap_or_else(|| bcx.ccx.align_of(tr_elem.ty));\n+                        let align = C_i32(bcx.ccx, align as i32);\n+                        base::call_memset(&bcx, base, v, size, align, false);\n+                        return bcx;\n+                    }\n+                }\n+\n                 tvec::slice_for_each(&bcx, base, tr_elem.ty, size, |bcx, llslot, loop_bb| {\n-                    self.store_operand(bcx, llslot, dest.alignment.to_align(), tr_elem);\n+                    self.store_operand(bcx, llslot, align, tr_elem);\n                     bcx.br(loop_bb);\n                 })\n             }"}, {"sha": "52dfc8dc4de5cac1d10f0d408ab504c3dd6cb91b", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -87,6 +87,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 bcx\n             }\n             mir::StatementKind::EndRegion(_) |\n+            mir::StatementKind::Validate(..) |\n             mir::StatementKind::Nop => bcx,\n         }\n     }"}, {"sha": "cff0eca02c60ee4ccaea654f6d436bc8c86721c5", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -174,29 +174,16 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn compute_symbol_name_hash<'a>(&self,\n-                                        scx: &SharedCrateContext<'a, 'tcx>,\n-                                        exported_symbols: &ExportedSymbols)\n+                                        scx: &SharedCrateContext<'a, 'tcx>)\n                                         -> u64 {\n         let mut state = IchHasher::new();\n-        let exported_symbols = exported_symbols.local_exports();\n         let all_items = self.items_in_deterministic_order(scx.tcx());\n-        for (item, _) in all_items {\n+        for (item, (linkage, visibility)) in all_items {\n             let symbol_name = item.symbol_name(scx.tcx());\n             symbol_name.len().hash(&mut state);\n             symbol_name.hash(&mut state);\n-            let exported = match item {\n-                TransItem::Fn(ref instance) => {\n-                    let node_id =\n-                        scx.tcx().hir.as_local_node_id(instance.def_id());\n-                    node_id.map(|node_id| exported_symbols.contains(&node_id))\n-                        .unwrap_or(false)\n-                }\n-                TransItem::Static(node_id) => {\n-                    exported_symbols.contains(&node_id)\n-                }\n-                TransItem::GlobalAsm(..) => true,\n-            };\n-            exported.hash(&mut state);\n+            linkage.hash(&mut state);\n+            visibility.hash(&mut state);\n         }\n         state.finish().to_smaller_hash()\n     }"}, {"sha": "e0ebe8a0933f128407f5ae79c640d7beb8729a50", "filename": "src/librustc_trans/time_graph.rs", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Ftime_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Ftime_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftime_graph.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,181 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashMap;\n+use std::marker::PhantomData;\n+use std::sync::{Arc, Mutex};\n+use std::time::Instant;\n+use std::io::prelude::*;\n+use std::fs::File;\n+\n+const OUTPUT_WIDTH_IN_PX: u64 = 1000;\n+const TIME_LINE_HEIGHT_IN_PX: u64 = 7;\n+const TIME_LINE_HEIGHT_STRIDE_IN_PX: usize = 10;\n+\n+#[derive(Clone)]\n+struct Timing {\n+    start: Instant,\n+    end: Instant,\n+    work_package_kind: WorkPackageKind,\n+}\n+\n+#[derive(Clone, Copy, Hash, Eq, PartialEq, Debug)]\n+pub struct TimelineId(pub usize);\n+\n+#[derive(Clone)]\n+struct PerThread {\n+    timings: Vec<Timing>,\n+    open_work_package: Option<(Instant, WorkPackageKind)>,\n+}\n+\n+#[derive(Clone)]\n+pub struct TimeGraph {\n+    data: Arc<Mutex<HashMap<TimelineId, PerThread>>>,\n+}\n+\n+#[derive(Clone, Copy)]\n+pub struct WorkPackageKind(pub &'static [&'static str]);\n+\n+pub struct RaiiToken {\n+    graph: TimeGraph,\n+    timeline: TimelineId,\n+    // The token must not be Send:\n+    _marker: PhantomData<*const ()>\n+}\n+\n+\n+impl Drop for RaiiToken {\n+    fn drop(&mut self) {\n+        self.graph.end(self.timeline);\n+    }\n+}\n+\n+impl TimeGraph {\n+    pub fn new() -> TimeGraph {\n+        TimeGraph {\n+            data: Arc::new(Mutex::new(HashMap::new()))\n+        }\n+    }\n+\n+    pub fn start(&self,\n+                 timeline: TimelineId,\n+                 work_package_kind: WorkPackageKind) -> RaiiToken {\n+        {\n+            let mut table = self.data.lock().unwrap();\n+\n+            let mut data = table.entry(timeline).or_insert(PerThread {\n+                timings: Vec::new(),\n+                open_work_package: None,\n+            });\n+\n+            assert!(data.open_work_package.is_none());\n+            data.open_work_package = Some((Instant::now(), work_package_kind));\n+        }\n+\n+        RaiiToken {\n+            graph: self.clone(),\n+            timeline,\n+            _marker: PhantomData,\n+        }\n+    }\n+\n+    fn end(&self, timeline: TimelineId) {\n+        let end = Instant::now();\n+\n+        let mut table = self.data.lock().unwrap();\n+        let mut data = table.get_mut(&timeline).unwrap();\n+\n+        if let Some((start, work_package_kind)) = data.open_work_package {\n+            data.timings.push(Timing {\n+                start,\n+                end,\n+                work_package_kind,\n+            });\n+        } else {\n+            bug!(\"end timing without start?\")\n+        }\n+\n+        data.open_work_package = None;\n+    }\n+\n+    pub fn dump(&self, output_filename: &str) {\n+        let table = self.data.lock().unwrap();\n+\n+        for data in table.values() {\n+            assert!(data.open_work_package.is_none());\n+        }\n+\n+        let mut timelines: Vec<PerThread> =\n+            table.values().map(|data| data.clone()).collect();\n+\n+        timelines.sort_by_key(|timeline| timeline.timings[0].start);\n+\n+        let earliest_instant = timelines[0].timings[0].start;\n+        let latest_instant = timelines.iter()\n+                                       .map(|timeline| timeline.timings\n+                                                               .last()\n+                                                               .unwrap()\n+                                                               .end)\n+                                       .max()\n+                                       .unwrap();\n+        let max_distance = distance(earliest_instant, latest_instant);\n+\n+        let mut file = File::create(format!(\"{}.html\", output_filename)).unwrap();\n+\n+        writeln!(file, \"<html>\").unwrap();\n+        writeln!(file, \"<head></head>\").unwrap();\n+        writeln!(file, \"<body>\").unwrap();\n+\n+        let mut color = 0;\n+\n+        for (line_index, timeline) in timelines.iter().enumerate() {\n+            let line_top = line_index * TIME_LINE_HEIGHT_STRIDE_IN_PX;\n+\n+            for span in &timeline.timings {\n+                let start = distance(earliest_instant, span.start);\n+                let end = distance(earliest_instant, span.end);\n+\n+                let start = normalize(start, max_distance, OUTPUT_WIDTH_IN_PX);\n+                let end = normalize(end, max_distance, OUTPUT_WIDTH_IN_PX);\n+\n+                let colors = span.work_package_kind.0;\n+\n+                writeln!(file, \"<div style='position:absolute; \\\n+                                            top:{}px; \\\n+                                            left:{}px; \\\n+                                            width:{}px; \\\n+                                            height:{}px; \\\n+                                            background:{};'></div>\",\n+                    line_top,\n+                    start,\n+                    end - start,\n+                    TIME_LINE_HEIGHT_IN_PX,\n+                    colors[color % colors.len()]\n+                    ).unwrap();\n+\n+                color += 1;\n+            }\n+        }\n+\n+        writeln!(file, \"</body>\").unwrap();\n+        writeln!(file, \"</html>\").unwrap();\n+    }\n+}\n+\n+fn distance(zero: Instant, x: Instant) -> u64 {\n+\n+    let duration = x.duration_since(zero);\n+    (duration.as_secs() * 1_000_000_000 + duration.subsec_nanos() as u64) // / div\n+}\n+\n+fn normalize(distance: u64, max: u64, max_pixels: u64) -> u64 {\n+    (max_pixels * distance) / max\n+}\n+"}, {"sha": "de4d217c73534308e2c449089786c927b45338db", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -30,8 +30,8 @@ pub fn slice_for_each<'a, 'tcx, F>(\n     };\n \n     let body_bcx = bcx.build_sibling_block(\"slice_loop_body\");\n-    let next_bcx = bcx.build_sibling_block(\"slice_loop_next\");\n     let header_bcx = bcx.build_sibling_block(\"slice_loop_header\");\n+    let next_bcx = bcx.build_sibling_block(\"slice_loop_next\");\n \n     let start = if zst {\n         C_uint(bcx.ccx, 0usize)"}, {"sha": "1ec850ad7f3494ab228869167a5f0f52736f81fd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1110,46 +1110,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyBareFn(ref bf) => {\n                 require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n-                let bare_fn_ty = self.ty_of_fn(bf.unsafety, bf.abi, &bf.decl);\n-\n-                // Find any late-bound regions declared in return type that do\n-                // not appear in the arguments. These are not wellformed.\n-                //\n-                // Example:\n-                //\n-                //     for<'a> fn() -> &'a str <-- 'a is bad\n-                //     for<'a> fn(&'a String) -> &'a str <-- 'a is ok\n-                //\n-                // Note that we do this check **here** and not in\n-                // `ty_of_bare_fn` because the latter is also used to make\n-                // the types for fn items, and we do not want to issue a\n-                // warning then. (Once we fix #32330, the regions we are\n-                // checking for here would be considered early bound\n-                // anyway.)\n-                let inputs = bare_fn_ty.inputs();\n-                let late_bound_in_args = tcx.collect_constrained_late_bound_regions(\n-                    &inputs.map_bound(|i| i.to_owned()));\n-                let output = bare_fn_ty.output();\n-                let late_bound_in_ret = tcx.collect_referenced_late_bound_regions(&output);\n-                for br in late_bound_in_ret.difference(&late_bound_in_args) {\n-                    let br_name = match *br {\n-                        ty::BrNamed(_, name) => name,\n-                        _ => {\n-                            span_bug!(\n-                                bf.decl.output.span(),\n-                                \"anonymous bound region {:?} in return but not args\",\n-                                br);\n-                        }\n-                    };\n-                    struct_span_err!(tcx.sess,\n-                                     ast_ty.span,\n-                                     E0581,\n-                                     \"return type references lifetime `{}`, \\\n-                                      which does not appear in the fn input types\",\n-                                     br_name)\n-                        .emit();\n-                }\n-                tcx.mk_fn_ptr(bare_fn_ty)\n+                tcx.mk_fn_ptr(self.ty_of_fn(bf.unsafety, bf.abi, &bf.decl))\n             }\n             hir::TyTraitObject(ref bounds, ref lifetime) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n@@ -1269,23 +1230,56 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     -> ty::PolyFnSig<'tcx> {\n         debug!(\"ty_of_fn\");\n \n+        let tcx = self.tcx();\n         let input_tys: Vec<Ty> =\n             decl.inputs.iter().map(|a| self.ty_of_arg(a, None)).collect();\n \n         let output_ty = match decl.output {\n             hir::Return(ref output) => self.ast_ty_to_ty(output),\n-            hir::DefaultReturn(..) => self.tcx().mk_nil(),\n+            hir::DefaultReturn(..) => tcx.mk_nil(),\n         };\n \n         debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n \n-        ty::Binder(self.tcx().mk_fn_sig(\n+        let bare_fn_ty = ty::Binder(tcx.mk_fn_sig(\n             input_tys.into_iter(),\n             output_ty,\n             decl.variadic,\n             unsafety,\n             abi\n-        ))\n+        ));\n+\n+        // Find any late-bound regions declared in return type that do\n+        // not appear in the arguments. These are not wellformed.\n+        //\n+        // Example:\n+        //     for<'a> fn() -> &'a str <-- 'a is bad\n+        //     for<'a> fn(&'a String) -> &'a str <-- 'a is ok\n+        let inputs = bare_fn_ty.inputs();\n+        let late_bound_in_args = tcx.collect_constrained_late_bound_regions(\n+            &inputs.map_bound(|i| i.to_owned()));\n+        let output = bare_fn_ty.output();\n+        let late_bound_in_ret = tcx.collect_referenced_late_bound_regions(&output);\n+        for br in late_bound_in_ret.difference(&late_bound_in_args) {\n+            let br_name = match *br {\n+                ty::BrNamed(_, name) => name,\n+                _ => {\n+                    span_bug!(\n+                        decl.output.span(),\n+                        \"anonymous bound region {:?} in return but not args\",\n+                        br);\n+                }\n+            };\n+            struct_span_err!(tcx.sess,\n+                             decl.output.span(),\n+                             E0581,\n+                             \"return type references lifetime `{}`, \\\n+                             which does not appear in the fn input types\",\n+                             br_name)\n+                .emit();\n+        }\n+\n+        bare_fn_ty\n     }\n \n     pub fn ty_of_closure(&self,"}, {"sha": "eaff8e7b8ace7d195d54fd472bcff4c59314a4b3", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 61, "deletions": 7, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -113,10 +113,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.demand_eqtype(pat.span, expected, rhs_ty);\n                 common_type\n             }\n-            PatKind::Binding(bm, def_id, _, ref sub) => {\n+            PatKind::Binding(ba, def_id, _, ref sub) => {\n+                // Note the binding mode in the typeck tables. For now, what we store is always\n+                // identical to what could be scraped from the HIR, but this will change with\n+                // default binding modes (#42640).\n+                let bm = ty::BindingMode::convert(ba);\n+                self.inh.tables.borrow_mut().pat_binding_modes.insert(pat.id, bm);\n+\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n-                    hir::BindByRef(mutbl) => {\n+                    ty::BindByReference(mutbl) => {\n                         // if the binding is like\n                         //    ref x | ref const x | ref mut x\n                         // then `x` is assigned a value of type `&M T` where M is the mutability\n@@ -131,7 +137,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.demand_eqtype(pat.span, region_ty, typ);\n                     }\n                     // otherwise the type of x is the expected type T\n-                    hir::BindByValue(_) => {\n+                    ty::BindByValue(_) => {\n                         // As above, `T <: typeof(x)` is required but we\n                         // use equality, see (*) below.\n                         self.demand_eqtype(pat.span, expected, typ);\n@@ -396,11 +402,59 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        match_src: hir::MatchSource) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n-        // Not entirely obvious: if matches may create ref bindings, we\n-        // want to use the *precise* type of the discriminant, *not* some\n-        // supertype, as the \"discriminant type\" (issue #23116).\n+        // Not entirely obvious: if matches may create ref bindings, we want to\n+        // use the *precise* type of the discriminant, *not* some supertype, as\n+        // the \"discriminant type\" (issue #23116).\n+        //\n+        // FIXME(tschottdorf): don't call contains_explicit_ref_binding, which\n+        // is problematic as the HIR is being scraped, but ref bindings may be\n+        // implicit after #42640. We need to make sure that pat_adjustments\n+        // (once introduced) is populated by the time we get here.\n+        //\n+        // arielb1 [writes here in this comment thread][c] that there\n+        // is certainly *some* potential danger, e.g. for an example\n+        // like:\n+        //\n+        // [c]: https://github.com/rust-lang/rust/pull/43399#discussion_r130223956\n+        //\n+        // ```\n+        // let Foo(x) = f()[0];\n+        // ```\n+        //\n+        // Then if the pattern matches by reference, we want to match\n+        // `f()[0]` as a lexpr, so we can't allow it to be\n+        // coerced. But if the pattern matches by value, `f()[0]` is\n+        // still syntactically a lexpr, but we *do* want to allow\n+        // coercions.\n+        //\n+        // However, *likely* we are ok with allowing coercions to\n+        // happen if there are no explicit ref mut patterns - all\n+        // implicit ref mut patterns must occur behind a reference, so\n+        // they will have the \"correct\" variance and lifetime.\n+        //\n+        // This does mean that the following pattern would be legal:\n+        //\n+        // ```\n+        // struct Foo(Bar);\n+        // struct Bar(u32);\n+        // impl Deref for Foo {\n+        //     type Target = Bar;\n+        //     fn deref(&self) -> &Bar { &self.0 }\n+        // }\n+        // impl DerefMut for Foo {\n+        //     fn deref_mut(&mut self) -> &mut Bar { &mut self.0 }\n+        // }\n+        // fn foo(x: &mut Foo) {\n+        //     {\n+        //         let Bar(z): &mut Bar = x;\n+        //         *z = 42;\n+        //     }\n+        //     assert_eq!(foo.0.0, 42);\n+        // }\n+        // ```\n+\n         let contains_ref_bindings = arms.iter()\n-                                        .filter_map(|a| a.contains_ref_binding())\n+                                        .filter_map(|a| a.contains_explicit_ref_binding())\n                                         .max_by_key(|m| match *m {\n                                             hir::MutMutable => 1,\n                                             hir::MutImmutable => 0,"}, {"sha": "e494bc15222229face5d28a98d66a7ad6c1bdb4c", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1046,7 +1046,7 @@ impl<'gcx, 'tcx, 'exprs, E> CoerceMany<'gcx, 'tcx, 'exprs, E>\n     }\n \n     /// Indicates that one of the inputs is a \"forced unit\". This\n-    /// occurs in a case like `if foo { ... };`, where the issing else\n+    /// occurs in a case like `if foo { ... };`, where the missing else\n     /// generates a \"forced unit\". Another example is a `loop { break;\n     /// }`, where the `break` has no argument expression. We treat\n     /// these cases slightly differently for error-reporting"}, {"sha": "b6a5ce0a6ce5adeef49a88d7733fa6a329da2ea0", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -38,6 +38,11 @@ impl<'a, 'gcx, 'tcx> Deref for ConfirmContext<'a, 'gcx, 'tcx> {\n     }\n }\n \n+pub struct ConfirmResult<'tcx> {\n+    pub callee: MethodCallee<'tcx>,\n+    pub illegal_sized_bound: bool,\n+}\n+\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn confirm_method(&self,\n                           span: Span,\n@@ -46,7 +51,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           unadjusted_self_ty: Ty<'tcx>,\n                           pick: probe::Pick<'tcx>,\n                           segment: &hir::PathSegment)\n-                          -> MethodCallee<'tcx> {\n+                          -> ConfirmResult<'tcx> {\n         debug!(\"confirm(unadjusted_self_ty={:?}, pick={:?}, generic_args={:?})\",\n                unadjusted_self_ty,\n                pick,\n@@ -75,7 +80,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                unadjusted_self_ty: Ty<'tcx>,\n                pick: probe::Pick<'tcx>,\n                segment: &hir::PathSegment)\n-               -> MethodCallee<'tcx> {\n+               -> ConfirmResult<'tcx> {\n         // Adjust the self expression the user provided and obtain the adjusted type.\n         let self_ty = self.adjust_self_ty(unadjusted_self_ty, &pick);\n \n@@ -91,12 +96,26 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // Create the final signature for the method, replacing late-bound regions.\n         let (method_sig, method_predicates) = self.instantiate_method_sig(&pick, all_substs);\n \n+        // If there is a `Self: Sized` bound and `Self` is a trait object, it is possible that\n+        // something which derefs to `Self` actually implements the trait and the caller\n+        // wanted to make a static dispatch on it but forgot to import the trait.\n+        // See test `src/test/ui/issue-35976.rs`.\n+        //\n+        // In that case, we'll error anyway, but we'll also re-run the search with all traits\n+        // in scope, and if we find another method which can be used, we'll output an\n+        // appropriate hint suggesting to import the trait.\n+        let illegal_sized_bound = self.predicates_require_illegal_sized_bound(&method_predicates);\n+\n         // Unify the (adjusted) self type with what the method expects.\n         self.unify_receivers(self_ty, method_sig.inputs()[0]);\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n-        let method_ty = self.tcx.mk_fn_ptr(ty::Binder(method_sig));\n-        self.add_obligations(method_ty, all_substs, &method_predicates);\n+        // We won't add these if we encountered an illegal sized bound, so that we can use\n+        // a custom error in that case.\n+        if !illegal_sized_bound {\n+            let method_ty = self.tcx.mk_fn_ptr(ty::Binder(method_sig));\n+            self.add_obligations(method_ty, all_substs, &method_predicates);\n+        }\n \n         // Create the final `MethodCallee`.\n         let callee = MethodCallee {\n@@ -109,7 +128,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             self.convert_lvalue_derefs_to_mutable();\n         }\n \n-        callee\n+        ConfirmResult { callee, illegal_sized_bound }\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -533,6 +552,30 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n \n+    fn predicates_require_illegal_sized_bound(&self,\n+                                              predicates: &ty::InstantiatedPredicates<'tcx>)\n+                                              -> bool {\n+        let sized_def_id = match self.tcx.lang_items.sized_trait() {\n+            Some(def_id) => def_id,\n+            None => return false,\n+        };\n+\n+        traits::elaborate_predicates(self.tcx, predicates.predicates.clone())\n+            .filter_map(|predicate| {\n+                match predicate {\n+                    ty::Predicate::Trait(trait_pred) if trait_pred.def_id() == sized_def_id =>\n+                        Some(trait_pred),\n+                    _ => None,\n+                }\n+            })\n+            .any(|trait_pred| {\n+                match trait_pred.0.self_ty().sty {\n+                    ty::TyDynamic(..) => true,\n+                    _ => false,\n+                }\n+            })\n+    }\n+\n     fn enforce_illegal_method_limitations(&self, pick: &probe::Pick) {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n         match pick.item.container {"}, {"sha": "dd5b0cdda42447233e639ef8e535e12d48efb0e9", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 65, "deletions": 13, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -33,7 +33,7 @@ mod confirm;\n pub mod probe;\n mod suggest;\n \n-use self::probe::IsSuggestion;\n+use self::probe::{IsSuggestion, ProbeScope};\n \n #[derive(Clone, Copy, Debug)]\n pub struct MethodCallee<'tcx> {\n@@ -60,6 +60,10 @@ pub enum MethodError<'tcx> {\n \n     // Found an applicable method, but it is not visible.\n     PrivateMatch(Def),\n+\n+    // Found a `Self: Sized` bound where `Self` is a trait object, also the caller may have\n+    // forgotten to import a trait.\n+    IllegalSizedBound(Vec<DefId>),\n }\n \n // Contains a list of static methods that may apply, a list of unsatisfied trait predicates which\n@@ -106,12 +110,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          -> bool {\n         let mode = probe::Mode::MethodCall;\n         match self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n-                                  self_ty, call_expr_id) {\n+                                  self_ty, call_expr_id, ProbeScope::TraitsInScope) {\n             Ok(..) => true,\n             Err(NoMatch(..)) => false,\n             Err(Ambiguity(..)) => true,\n             Err(ClosureAmbiguity(..)) => true,\n             Err(PrivateMatch(..)) => allow_private,\n+            Err(IllegalSizedBound(..)) => true,\n         }\n     }\n \n@@ -142,10 +147,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                call_expr,\n                self_expr);\n \n-        let mode = probe::Mode::MethodCall;\n-        let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n-        let pick = self.probe_for_name(span, mode, segment.name, IsSuggestion(false),\n-                                       self_ty, call_expr.id)?;\n+        let pick = self.lookup_probe(\n+            span,\n+            segment.name,\n+            self_ty,\n+            call_expr,\n+            ProbeScope::TraitsInScope\n+        )?;\n \n         if let Some(import_id) = pick.import_id {\n             let import_def_id = self.tcx.hir.local_def_id(import_id);\n@@ -155,12 +163,56 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.check_stability(pick.item.def_id, call_expr.id, span);\n \n-        Ok(self.confirm_method(span,\n-                               self_expr,\n-                               call_expr,\n-                               self_ty,\n-                               pick,\n-                               segment))\n+        let result = self.confirm_method(span,\n+                                         self_expr,\n+                                         call_expr,\n+                                         self_ty,\n+                                         pick.clone(),\n+                                         segment);\n+\n+        if result.illegal_sized_bound {\n+            // We probe again, taking all traits into account (not only those in scope).\n+            let candidates =\n+                match self.lookup_probe(span,\n+                                        segment.name,\n+                                        self_ty,\n+                                        call_expr,\n+                                        ProbeScope::AllTraits) {\n+\n+                    // If we find a different result the caller probably forgot to import a trait.\n+                    Ok(ref new_pick) if *new_pick != pick => vec![new_pick.item.container.id()],\n+                    Err(Ambiguity(ref sources)) => {\n+                        sources.iter()\n+                               .filter_map(|source| {\n+                                   match *source {\n+                                       // Note: this cannot come from an inherent impl,\n+                                       // because the first probing succeeded.\n+                                       ImplSource(def) => self.tcx.trait_id_of_impl(def),\n+                                       TraitSource(_) => None,\n+                                   }\n+                               })\n+                               .collect()\n+                    }\n+                    _ => Vec::new(),\n+                };\n+\n+            return Err(IllegalSizedBound(candidates));\n+        }\n+\n+        Ok(result.callee)\n+    }\n+\n+    fn lookup_probe(&self,\n+                    span: Span,\n+                    method_name: ast::Name,\n+                    self_ty: ty::Ty<'tcx>,\n+                    call_expr: &'gcx hir::Expr,\n+                    scope: ProbeScope)\n+                    -> probe::PickResult<'tcx> {\n+        let mode = probe::Mode::MethodCall;\n+        let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n+        self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n+                            self_ty, call_expr.id, scope)\n     }\n \n     /// `lookup_method_in_trait` is used for overloaded operators.\n@@ -299,7 +351,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         -> Result<Def, MethodError<'tcx>> {\n         let mode = probe::Mode::Path;\n         let pick = self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n-                                       self_ty, expr_id)?;\n+                                       self_ty, expr_id, ProbeScope::TraitsInScope)?;\n \n         if let Some(import_id) = pick.import_id {\n             let import_def_id = self.tcx.hir.local_def_id(import_id);"}, {"sha": "587e583cabded659ab0ece11c9add53386e0125b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -106,7 +106,7 @@ enum CandidateKind<'tcx> {\n                          ty::PolyTraitRef<'tcx>),\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, PartialEq, Eq, Clone)]\n pub struct Pick<'tcx> {\n     pub item: ty::AssociatedItem,\n     pub kind: PickKind<'tcx>,\n@@ -130,7 +130,7 @@ pub struct Pick<'tcx> {\n     pub unsize: Option<Ty<'tcx>>,\n }\n \n-#[derive(Clone,Debug)]\n+#[derive(Clone, Debug, PartialEq, Eq)]\n pub enum PickKind<'tcx> {\n     InherentImplPick,\n     ExtensionImplPick(// Impl\n@@ -155,6 +155,15 @@ pub enum Mode {\n     Path,\n }\n \n+#[derive(PartialEq, Eq, Copy, Clone, Debug)]\n+pub enum ProbeScope {\n+    // Assemble candidates coming only from traits in scope.\n+    TraitsInScope,\n+\n+    // Assemble candidates coming from all traits.\n+    AllTraits,\n+}\n+\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// This is used to offer suggestions to users. It returns methods\n     /// that could have been called which have the desired return\n@@ -175,14 +184,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                scope_expr_id);\n         let method_names =\n             self.probe_op(span, mode, LookingFor::ReturnType(return_type), IsSuggestion(true),\n-                          self_ty, scope_expr_id,\n+                          self_ty, scope_expr_id, ProbeScope::TraitsInScope,\n                           |probe_cx| Ok(probe_cx.candidate_method_names()))\n                 .unwrap_or(vec![]);\n         method_names\n             .iter()\n             .flat_map(|&method_name| {\n                 match self.probe_for_name(span, mode, method_name, IsSuggestion(true), self_ty,\n-                                          scope_expr_id) {\n+                                          scope_expr_id, ProbeScope::TraitsInScope) {\n                     Ok(pick) => Some(pick.item),\n                     Err(_) => None,\n                 }\n@@ -196,7 +205,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                           item_name: ast::Name,\n                           is_suggestion: IsSuggestion,\n                           self_ty: Ty<'tcx>,\n-                          scope_expr_id: ast::NodeId)\n+                          scope_expr_id: ast::NodeId,\n+                          scope: ProbeScope)\n                           -> PickResult<'tcx> {\n         debug!(\"probe(self_ty={:?}, item_name={}, scope_expr_id={})\",\n                self_ty,\n@@ -208,6 +218,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       is_suggestion,\n                       self_ty,\n                       scope_expr_id,\n+                      scope,\n                       |probe_cx| probe_cx.pick())\n     }\n \n@@ -218,6 +229,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       is_suggestion: IsSuggestion,\n                       self_ty: Ty<'tcx>,\n                       scope_expr_id: ast::NodeId,\n+                      scope: ProbeScope,\n                       op: OP)\n                       -> Result<R, MethodError<'tcx>>\n         where OP: FnOnce(ProbeContext<'a, 'gcx, 'tcx>) -> Result<R, MethodError<'tcx>>\n@@ -275,8 +287,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let mut probe_cx =\n                 ProbeContext::new(self, span, mode, looking_for,\n                                   steps, opt_simplified_steps);\n+\n             probe_cx.assemble_inherent_candidates();\n-            probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)?;\n+            match scope {\n+                ProbeScope::TraitsInScope =>\n+                    probe_cx.assemble_extension_candidates_for_traits_in_scope(scope_expr_id)?,\n+                ProbeScope::AllTraits =>\n+                    probe_cx.assemble_extension_candidates_for_all_traits()?,\n+            };\n             op(probe_cx)\n         })\n     }"}, {"sha": "53da9e19ee0cdff01d7a698433242e2b80015a35", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 51, "deletions": 26, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -312,10 +312,45 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             MethodError::PrivateMatch(def) => {\n-                let msg = format!(\"{} `{}` is private\", def.kind_name(), item_name);\n-                self.tcx.sess.span_err(span, &msg);\n+                struct_span_err!(self.tcx.sess, span, E0624,\n+                                 \"{} `{}` is private\", def.kind_name(), item_name).emit();\n             }\n+\n+            MethodError::IllegalSizedBound(candidates) => {\n+                let msg = format!(\"the `{}` method cannot be invoked on a trait object\", item_name);\n+                let mut err = self.sess().struct_span_err(span, &msg);\n+                if !candidates.is_empty() {\n+                    let help = format!(\"{an}other candidate{s} {were} found in the following \\\n+                                        trait{s}, perhaps add a `use` for {one_of_them}:\",\n+                                    an = if candidates.len() == 1 {\"an\" } else { \"\" },\n+                                    s = if candidates.len() == 1 { \"\" } else { \"s\" },\n+                                    were = if candidates.len() == 1 { \"was\" } else { \"were\" },\n+                                    one_of_them = if candidates.len() == 1 {\n+                                        \"it\"\n+                                    } else {\n+                                        \"one_of_them\"\n+                                    });\n+                    self.suggest_use_candidates(&mut err, help, candidates);\n+                }\n+                err.emit();\n+            }\n+        }\n+    }\n+\n+    fn suggest_use_candidates(&self,\n+                              err: &mut DiagnosticBuilder,\n+                              mut msg: String,\n+                              candidates: Vec<DefId>) {\n+        let limit = if candidates.len() == 5 { 5 } else { 4 };\n+        for (i, trait_did) in candidates.iter().take(limit).enumerate() {\n+            msg.push_str(&format!(\"\\ncandidate #{}: `use {};`\",\n+                                    i + 1,\n+                                    self.tcx.item_path_str(*trait_did)));\n+        }\n+        if candidates.len() > limit {\n+            msg.push_str(&format!(\"\\nand {} others\", candidates.len() - limit));\n         }\n+        err.note(&msg[..]);\n     }\n \n     fn suggest_traits_to_import(&self,\n@@ -330,30 +365,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             candidates.sort();\n             candidates.dedup();\n             err.help(\"items from traits can only be used if the trait is in scope\");\n-            let mut msg = format!(\"the following {traits_are} implemented but not in scope, \\\n-                                   perhaps add a `use` for {one_of_them}:\",\n-                              traits_are = if candidates.len() == 1 {\n-                                  \"trait is\"\n-                              } else {\n-                                  \"traits are\"\n-                              },\n-                              one_of_them = if candidates.len() == 1 {\n-                                  \"it\"\n-                              } else {\n-                                  \"one of them\"\n-                              });\n-\n-            let limit = if candidates.len() == 5 { 5 } else { 4 };\n-            for (i, trait_did) in candidates.iter().take(limit).enumerate() {\n-                msg.push_str(&format!(\"\\ncandidate #{}: `use {};`\",\n-                                      i + 1,\n-                                      self.tcx.item_path_str(*trait_did)));\n-            }\n-            if candidates.len() > limit {\n-                msg.push_str(&format!(\"\\nand {} others\", candidates.len() - limit));\n-            }\n-            err.note(&msg[..]);\n-\n+            let msg = format!(\"the following {traits_are} implemented but not in scope, \\\n+                               perhaps add a `use` for {one_of_them}:\",\n+                            traits_are = if candidates.len() == 1 {\n+                                \"trait is\"\n+                            } else {\n+                                \"traits are\"\n+                            },\n+                            one_of_them = if candidates.len() == 1 {\n+                                \"it\"\n+                            } else {\n+                                \"one of them\"\n+                            });\n+\n+            self.suggest_use_candidates(err, msg, candidates);\n             return;\n         }\n "}, {"sha": "ed6d0c035de8ce954cd340592c7441c918ad7fa6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 50, "deletions": 12, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1647,7 +1647,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn re_infer(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n                 -> Option<ty::Region<'tcx>> {\n         let v = match def {\n-            Some(def) => infer::EarlyBoundRegion(span, def.name, def.issue_32330),\n+            Some(def) => infer::EarlyBoundRegion(span, def.name),\n             None => infer::MiscVariable(span)\n         };\n         Some(self.next_region_var(v))\n@@ -3008,6 +3008,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                format!(\"did you mean `{}`?\", suggested_field_name));\n                             } else {\n                                 err.span_label(field.span, \"unknown field\");\n+                                let struct_variant_def = def.struct_variant();\n+                                let field_names = self.available_field_names(struct_variant_def);\n+                                if !field_names.is_empty() {\n+                                    err.note(&format!(\"available fields are: {}\",\n+                                                      self.name_series_display(field_names)));\n+                                }\n                             };\n                     }\n                     ty::TyRawPtr(..) => {\n@@ -3031,7 +3037,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Return an hint about the closest match in field names\n     fn suggest_field_name(variant: &'tcx ty::VariantDef,\n                           field: &Spanned<ast::Name>,\n-                          skip : Vec<InternedString>)\n+                          skip: Vec<InternedString>)\n                           -> Option<Symbol> {\n         let name = field.node.as_str();\n         let names = variant.fields.iter().filter_map(|field| {\n@@ -3044,8 +3050,29 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         });\n \n-        // only find fits with at least one matching letter\n-        find_best_match_for_name(names, &name, Some(name.len()))\n+        find_best_match_for_name(names, &name, None)\n+    }\n+\n+    fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n+        let mut available = Vec::new();\n+        for field in variant.fields.iter() {\n+            let (_, def_scope) = self.tcx.adjust(field.name, variant.did, self.body_id);\n+            if field.vis.is_accessible_from(def_scope, self.tcx) {\n+                available.push(field.name);\n+            }\n+        }\n+        available\n+    }\n+\n+    fn name_series_display(&self, names: Vec<ast::Name>) -> String {\n+        // dynamic limit, to never omit just one field\n+        let limit = if names.len() == 6 { 6 } else { 5 };\n+        let mut display = names.iter().take(limit)\n+            .map(|n| format!(\"`{}`\", n)).collect::<Vec<_>>().join(\", \");\n+        if names.len() > limit {\n+            display = format!(\"{} ... and {} others\", display, names.len() - limit);\n+        }\n+        display\n     }\n \n     // Check tuple index expressions\n@@ -3159,13 +3186,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                            format!(\"field does not exist - did you mean `{}`?\", field_name));\n         } else {\n             match ty.sty {\n-                ty::TyAdt(adt, ..) if adt.is_enum() => {\n-                    err.span_label(field.name.span, format!(\"`{}::{}` does not have this field\",\n-                                                             ty, variant.name));\n-                }\n-                _ => {\n-                    err.span_label(field.name.span, format!(\"`{}` does not have this field\", ty));\n+                ty::TyAdt(adt, ..) => {\n+                    if adt.is_enum() {\n+                        err.span_label(field.name.span,\n+                                       format!(\"`{}::{}` does not have this field\",\n+                                               ty, variant.name));\n+                    } else {\n+                        err.span_label(field.name.span,\n+                                       format!(\"`{}` does not have this field\", ty));\n+                    }\n+                    let available_field_names = self.available_field_names(variant);\n+                    if !available_field_names.is_empty() {\n+                        err.note(&format!(\"available fields are: {}\",\n+                                          self.name_series_display(available_field_names)));\n+                    }\n                 }\n+                _ => bug!(\"non-ADT passed to report_unknown_field\")\n             }\n         };\n         err.emit();\n@@ -3975,7 +4011,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     self.check_expr_coercable_to_type(&value, ty);\n                 }\n                 None => {\n-                    struct_span_err!(self.tcx.sess, expr.span, E0624,\n+                    struct_span_err!(self.tcx.sess, expr.span, E0627,\n                                  \"yield statement outside of generator literal\").emit();\n                 }\n             }\n@@ -4059,7 +4095,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   local: &'gcx hir::Local,\n                                   init: &'gcx hir::Expr) -> Ty<'tcx>\n     {\n-        let ref_bindings = local.pat.contains_ref_binding();\n+        // FIXME(tschottdorf): contains_explicit_ref_binding() must be removed\n+        // for #42640.\n+        let ref_bindings = local.pat.contains_explicit_ref_binding();\n \n         let local_ty = self.local_ty(init.span, local.id);\n         if let Some(m) = ref_bindings {"}, {"sha": "3a39800ea912ffb5125c758d29020be573ccc9d7", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1196,9 +1196,13 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             mc.cat_pattern(discr_cmt, root_pat, |sub_cmt, sub_pat| {\n                 match sub_pat.node {\n                     // `ref x` pattern\n-                    PatKind::Binding(hir::BindByRef(mutbl), ..) => {\n-                        self.link_region_from_node_type(sub_pat.span, sub_pat.id,\n-                                                        mutbl, sub_cmt);\n+                    PatKind::Binding(..) => {\n+                        let bm = *mc.tables.pat_binding_modes.get(&sub_pat.id)\n+                                                             .expect(\"missing binding mode\");\n+                        if let ty::BindByReference(mutbl) = bm {\n+                            self.link_region_from_node_type(sub_pat.span, sub_pat.id,\n+                                                            mutbl, sub_cmt);\n+                        }\n                     }\n                     _ => {}\n                 }"}, {"sha": "cf5882bb9bdbd943cfc11fb9aa83e6b8abb572e3", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -89,23 +89,23 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                tcx.item_path_str(tcx.hir.local_def_id(item.id)));\n \n         match item.node {\n-            /// Right now we check that every default trait implementation\n-            /// has an implementation of itself. Basically, a case like:\n-            ///\n-            /// `impl Trait for T {}`\n-            ///\n-            /// has a requirement of `T: Trait` which was required for default\n-            /// method implementations. Although this could be improved now that\n-            /// there's a better infrastructure in place for this, it's being left\n-            /// for a follow-up work.\n-            ///\n-            /// Since there's such a requirement, we need to check *just* positive\n-            /// implementations, otherwise things like:\n-            ///\n-            /// impl !Send for T {}\n-            ///\n-            /// won't be allowed unless there's an *explicit* implementation of `Send`\n-            /// for `T`\n+            // Right now we check that every default trait implementation\n+            // has an implementation of itself. Basically, a case like:\n+            //\n+            // `impl Trait for T {}`\n+            //\n+            // has a requirement of `T: Trait` which was required for default\n+            // method implementations. Although this could be improved now that\n+            // there's a better infrastructure in place for this, it's being left\n+            // for a follow-up work.\n+            //\n+            // Since there's such a requirement, we need to check *just* positive\n+            // implementations, otherwise things like:\n+            //\n+            // impl !Send for T {}\n+            //\n+            // won't be allowed unless there's an *explicit* implementation of `Send`\n+            // for `T`\n             hir::ItemImpl(_, hir::ImplPolarity::Positive, _, _,\n                           ref trait_ref, ref self_ty, _) => {\n                 self.check_impl(item, self_ty, trait_ref);"}, {"sha": "8101e87880cf1845b8078fda658b6be14f622ffc", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -181,6 +181,15 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n+        match p.node {\n+            hir::PatKind::Binding(..) => {\n+                let bm = *self.fcx.tables.borrow().pat_binding_modes.get(&p.id)\n+                                                                    .expect(\"missing binding mode\");\n+                self.tables.pat_binding_modes.insert(p.id, bm);\n+            }\n+            _ => {}\n+        };\n+\n         self.visit_node_id(p.span, p.id);\n         intravisit::walk_pat(self, p);\n     }"}, {"sha": "7c2adce66fb442d865db6d3f8dc1e622e4927de4", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -979,13 +979,11 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n     let regions = early_lifetimes.enumerate().map(|(i, l)| {\n-        let issue_32330 = tcx.named_region_map.issue_32330.get(&l.lifetime.id).cloned();\n         ty::RegionParameterDef {\n             name: l.lifetime.name,\n             index: own_start + i as u32,\n             def_id: tcx.hir.local_def_id(l.lifetime.id),\n             pure_wrt_drop: l.pure_wrt_drop,\n-            issue_32330: issue_32330,\n         }\n     }).collect::<Vec<_>>();\n "}, {"sha": "4c608249ee95a4139e4e38e8bdb546d4d60e2ee5", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 130, "deletions": 23, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -2631,26 +2631,6 @@ struct Bar<S, T> { x: Foo<S, T> }\n ```\n \"##,\n \n-E0569: r##\"\n-If an impl has a generic parameter with the `#[may_dangle]` attribute, then\n-that impl must be declared as an `unsafe impl. For example:\n-\n-```compile_fail,E0569\n-#![feature(generic_param_attrs)]\n-#![feature(dropck_eyepatch)]\n-\n-struct Foo<X>(X);\n-impl<#[may_dangle] X> Drop for Foo<X> {\n-    fn drop(&mut self) { }\n-}\n-```\n-\n-In this example, we are asserting that the destructor for `Foo` will not\n-access any data of type `X`, and require this assertion to be true for\n-overall safety in our program. The compiler does not currently attempt to\n-verify this assertion; therefore we must tag this `impl` as unsafe.\n-\"##,\n-\n E0318: r##\"\n Default impls for a trait must be located in the same crate where the trait was\n defined. For more information see the [opt-in builtin traits RFC][RFC 19].\n@@ -3457,6 +3437,56 @@ impl Foo for i32 {\n ```\n \"##,\n \n+E0436: r##\"\n+The functional record update syntax is only allowed for structs. (Struct-like\n+enum variants don't qualify, for example.)\n+\n+Erroneous code example:\n+\n+```compile_fail,E0436\n+enum PublicationFrequency {\n+    Weekly,\n+    SemiMonthly { days: (u8, u8), annual_special: bool },\n+}\n+\n+fn one_up_competitor(competitor_frequency: PublicationFrequency)\n+                     -> PublicationFrequency {\n+    match competitor_frequency {\n+        PublicationFrequency::Weekly => PublicationFrequency::SemiMonthly {\n+            days: (1, 15), annual_special: false\n+        },\n+        c @ PublicationFrequency::SemiMonthly{ .. } =>\n+            PublicationFrequency::SemiMonthly {\n+                annual_special: true, ..c // error: functional record update\n+                                          //        syntax requires a struct\n+        }\n+    }\n+}\n+```\n+\n+Rewrite the expression without functional record update syntax:\n+\n+```\n+enum PublicationFrequency {\n+    Weekly,\n+    SemiMonthly { days: (u8, u8), annual_special: bool },\n+}\n+\n+fn one_up_competitor(competitor_frequency: PublicationFrequency)\n+                     -> PublicationFrequency {\n+    match competitor_frequency {\n+        PublicationFrequency::Weekly => PublicationFrequency::SemiMonthly {\n+            days: (1, 15), annual_special: false\n+        },\n+        PublicationFrequency::SemiMonthly{ days, .. } =>\n+            PublicationFrequency::SemiMonthly {\n+                days, annual_special: true // ok!\n+        }\n+    }\n+}\n+```\n+\"##,\n+\n E0439: r##\"\n The length of the platform-intrinsic function `simd_shuffle`\n wasn't specified. Erroneous code example:\n@@ -3926,6 +3956,28 @@ See [RFC 1522] for more details.\n [RFC 1522]: https://github.com/rust-lang/rfcs/blob/master/text/1522-conservative-impl-trait.md\n \"##,\n \n+E0569: r##\"\n+If an impl has a generic parameter with the `#[may_dangle]` attribute, then\n+that impl must be declared as an `unsafe impl.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0569\n+#![feature(generic_param_attrs)]\n+#![feature(dropck_eyepatch)]\n+\n+struct Foo<X>(X);\n+impl<#[may_dangle] X> Drop for Foo<X> {\n+    fn drop(&mut self) { }\n+}\n+```\n+\n+In this example, we are asserting that the destructor for `Foo` will not\n+access any data of type `X`, and require this assertion to be true for\n+overall safety in our program. The compiler does not currently attempt to\n+verify this assertion; therefore we must tag this `impl` as unsafe.\n+\"##,\n+\n E0570: r##\"\n The requested ABI is unsupported by the current target.\n \n@@ -4592,6 +4644,62 @@ whose implementation is handled specially by the compiler. In order to fix this\n error, just declare a function.\n \"##,\n \n+E0624: r##\"\n+A private item was used outside of its scope.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0627\n+mod inner {\n+    pub struct Foo;\n+\n+    impl Foo {\n+        fn method(&self) {}\n+    }\n+}\n+\n+let foo = inner::Foo;\n+foo.method(); // error: method `method` is private\n+```\n+\n+Two possibilities are available to solve this issue:\n+\n+1. Only use the item in the scope it has been defined:\n+\n+```\n+mod inner {\n+    pub struct Foo;\n+\n+    impl Foo {\n+        fn method(&self) {}\n+    }\n+\n+    pub fn call_method(foo: &Foo) { // We create a public function.\n+        foo.method(); // Which calls the item.\n+    }\n+}\n+\n+let foo = inner::Foo;\n+inner::call_method(&foo); // And since the function is public, we can call the\n+                          // method through it.\n+```\n+\n+2. Make the item public:\n+\n+```\n+mod inner {\n+    pub struct Foo;\n+\n+    impl Foo {\n+        pub fn method(&self) {} // It's now public.\n+    }\n+}\n+\n+let foo = inner::Foo;\n+foo.method(); // Ok!\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {\n@@ -4655,10 +4763,9 @@ register_diagnostics! {\n //  E0372, // coherence not object safe\n     E0377, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with the same definition\n-    E0436, // functional record update requires a struct\n     E0521, // redundant default implementations of trait\n     E0533, // `{}` does not name a unit variant, unit struct or a constant\n-    E0563, // cannot determine a type for this `impl Trait`: {}\n+//  E0563, // cannot determine a type for this `impl Trait`: {} // removed in 6383de15\n     E0564, // only named lifetimes are allowed in `impl Trait`,\n            // but `{}` was found in the type `{}`\n     E0567, // auto traits can not have type parameters\n@@ -4667,5 +4774,5 @@ register_diagnostics! {\n     E0588, // packed struct cannot transitively contain a `[repr(align)]` struct\n     E0592, // duplicate definitions with name `{}`\n //  E0613, // Removed (merged with E0609)\n-    E0624, // yield statement outside of generator literal\n+    E0627, // yield statement outside of generator literal\n }"}, {"sha": "75ae2f9fe9ad64107307bb31c2e9bfab079dcd99", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1547,6 +1547,8 @@ pub enum PrimitiveType {\n     Array,\n     Tuple,\n     RawPointer,\n+    Reference,\n+    Fn,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Copy, Debug)]\n@@ -1581,6 +1583,8 @@ impl Type {\n             Array(..) | BorrowedRef { type_: box Array(..), .. } => Some(PrimitiveType::Array),\n             Tuple(..) => Some(PrimitiveType::Tuple),\n             RawPointer(..) => Some(PrimitiveType::RawPointer),\n+            BorrowedRef { type_: box Generic(..), .. } => Some(PrimitiveType::Reference),\n+            BareFunction(..) => Some(PrimitiveType::Fn),\n             _ => None,\n         }\n     }\n@@ -1633,6 +1637,8 @@ impl PrimitiveType {\n             \"slice\" => Some(PrimitiveType::Slice),\n             \"tuple\" => Some(PrimitiveType::Tuple),\n             \"pointer\" => Some(PrimitiveType::RawPointer),\n+            \"reference\" => Some(PrimitiveType::Reference),\n+            \"fn\" => Some(PrimitiveType::Fn),\n             _ => None,\n         }\n     }\n@@ -1661,6 +1667,8 @@ impl PrimitiveType {\n             Slice => \"slice\",\n             Tuple => \"tuple\",\n             RawPointer => \"pointer\",\n+            Reference => \"reference\",\n+            Fn => \"fn\",\n         }\n     }\n \n@@ -2556,6 +2564,8 @@ fn build_deref_target_impls(cx: &DocContext,\n             Array => tcx.lang_items.slice_impl(),\n             Tuple => None,\n             RawPointer => tcx.lang_items.const_ptr_impl(),\n+            Reference => None,\n+            Fn => None,\n         };\n         if let Some(did) = did {\n             if !did.is_local() {\n@@ -2777,6 +2787,9 @@ fn resolve_type(cx: &DocContext,\n         Def::SelfTy(..) if path.segments.len() == 1 => {\n             return Generic(keywords::SelfType.name().to_string());\n         }\n+        Def::TyParam(..) if path.segments.len() == 1 => {\n+            return Generic(format!(\"{:#}\", path));\n+        }\n         Def::SelfTy(..) | Def::TyParam(..) | Def::AssociatedTy(..) => true,\n         _ => false,\n     };"}, {"sha": "988890ffedcdd92d0e0cbb15d5e8645d558ce371", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -607,11 +607,9 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n                        decl.generics,\n                        decl.decl)\n             } else {\n-                write!(f, \"{}{}fn{}{}\",\n-                       UnsafetySpace(decl.unsafety),\n-                       AbiSpace(decl.abi),\n-                       decl.generics,\n-                       decl.decl)\n+                write!(f, \"{}{}\", UnsafetySpace(decl.unsafety), AbiSpace(decl.abi))?;\n+                primitive_link(f, PrimitiveType::Fn, \"fn\")?;\n+                write!(f, \"{}{}\", decl.generics, decl.decl)\n             }\n         }\n         clean::Tuple(ref typs) => {\n@@ -665,50 +663,48 @@ fn fmt_type(t: &clean::Type, f: &mut fmt::Formatter, use_absolute: bool) -> fmt:\n                 _ => \"\".to_string(),\n             };\n             let m = MutableSpace(mutability);\n+            let amp = if f.alternate() {\n+                \"&\".to_string()\n+            } else {\n+                \"&amp;\".to_string()\n+            };\n             match **ty {\n                 clean::Slice(ref bt) => { // BorrowedRef{ ... Slice(T) } is &[T]\n                     match **bt {\n                         clean::Generic(_) => {\n                             if f.alternate() {\n                                 primitive_link(f, PrimitiveType::Slice,\n-                                    &format!(\"&{}{}[{:#}]\", lt, m, **bt))\n+                                    &format!(\"{}{}{}[{:#}]\", amp, lt, m, **bt))\n                             } else {\n                                 primitive_link(f, PrimitiveType::Slice,\n-                                    &format!(\"&amp;{}{}[{}]\", lt, m, **bt))\n+                                    &format!(\"{}{}{}[{}]\", amp, lt, m, **bt))\n                             }\n                         }\n                         _ => {\n+                            primitive_link(f, PrimitiveType::Slice,\n+                                           &format!(\"{}{}{}[\", amp, lt, m))?;\n                             if f.alternate() {\n-                                primitive_link(f, PrimitiveType::Slice,\n-                                               &format!(\"&{}{}[\", lt, m))?;\n                                 write!(f, \"{:#}\", **bt)?;\n                             } else {\n-                                primitive_link(f, PrimitiveType::Slice,\n-                                               &format!(\"&amp;{}{}[\", lt, m))?;\n                                 write!(f, \"{}\", **bt)?;\n                             }\n                             primitive_link(f, PrimitiveType::Slice, \"]\")\n                         }\n                     }\n                 }\n                 clean::ResolvedPath { typarams: Some(ref v), .. } if !v.is_empty() => {\n-                    if f.alternate() {\n-                        write!(f, \"&{}{}\", lt, m)?;\n-                    } else {\n-                        write!(f, \"&amp;{}{}\", lt, m)?;\n-                    }\n-                    write!(f, \"(\")?;\n+                    write!(f, \"{}{}{}(\", amp, lt, m)?;\n                     fmt_type(&ty, f, use_absolute)?;\n                     write!(f, \")\")\n                 }\n+                clean::Generic(..) => {\n+                    primitive_link(f, PrimitiveType::Reference,\n+                                   &format!(\"{}{}{}\", amp, lt, m))?;\n+                    fmt_type(&ty, f, use_absolute)\n+                }\n                 _ => {\n-                    if f.alternate() {\n-                        write!(f, \"&{}{}\", lt, m)?;\n-                        fmt_type(&ty, f, use_absolute)\n-                    } else {\n-                        write!(f, \"&amp;{}{}\", lt, m)?;\n-                        fmt_type(&ty, f, use_absolute)\n-                    }\n+                    write!(f, \"{}{}{}\", amp, lt, m)?;\n+                    fmt_type(&ty, f, use_absolute)\n                 }\n             }\n         }"}, {"sha": "fc0adef70baa1da01307f902724ac1e8650132ba", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -2235,6 +2235,13 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 _ => false,\n             };\n             fmt_impl_for_trait_page(&implementor.impl_, w, use_absolute)?;\n+            for it in &implementor.impl_.items {\n+                if let clean::TypedefItem(ref tydef, _) = it.inner {\n+                    write!(w, \"<span class=\\\"where fmt-newline\\\">  \")?;\n+                    assoc_type(w, it, &vec![], Some(&tydef.type_), AssocItemLink::Anchor(None))?;\n+                    write!(w, \";</span>\")?;\n+                }\n+            }\n             writeln!(w, \"</code></li>\")?;\n         }\n     }\n@@ -2962,7 +2969,15 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                     write!(w, \"<code>\")?;\n                     render_assoc_item(w, item, link.anchor(&id), ItemType::Impl)?;\n                     write!(w, \"</code>\")?;\n-                    render_stability_since_raw(w, item.stable_since(), outer_version)?;\n+                    if let Some(l) = (Item { cx, item }).src_href() {\n+                        write!(w, \"</span><span class='out-of-band'>\")?;\n+                        write!(w, \"<div class='ghost'></div>\")?;\n+                        render_stability_since_raw(w, item.stable_since(), outer_version)?;\n+                        write!(w, \"<a class='srclink' href='{}' title='{}'>[src]</a>\",\n+                               l, \"goto source code\")?;\n+                    } else {\n+                        render_stability_since_raw(w, item.stable_since(), outer_version)?;\n+                    }\n                     write!(w, \"</span></h4>\\n\")?;\n                 }\n             }"}, {"sha": "51465bafc42e23f10b4ab947ed366c0163e145df", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -274,9 +274,13 @@ nav.sub {\n \tborder-bottom: 1px solid;\n }\n \n-.docblock h1 { font-size: 1.3em; }\n-.docblock h2 { font-size: 1.15em; }\n-.docblock h3, .docblock h4, .docblock h5 { font-size: 1em; }\n+#main > .docblock h1 { font-size: 1.3em; }\n+#main > .docblock h2 { font-size: 1.15em; }\n+#main > .docblock h3, #main > .docblock h4, #main > .docblock h5 { font-size: 1em; }\n+\n+.docblock h1 { font-size: 1em; }\n+.docblock h2 { font-size: 0.95em; }\n+.docblock h3, .docblock h4, .docblock h5 { font-size: 0.9em; }\n \n .docblock {\n \tmargin-left: 24px;\n@@ -297,6 +301,10 @@ h3.impl > .out-of-band {\n \tfont-size: 21px;\n }\n \n+h4.method > .out-of-band {\n+\tfont-size: 19px;\n+}\n+\n h4 > code, h3 > code, .invisible > code {\n \tposition: inherit;\n }\n@@ -434,10 +442,6 @@ a {\n \ttext-decoration: underline;\n }\n \n-.content span.enum, .content a.enum, .block a.current.enum { color: #5e9766; }\n-.content span.struct, .content a.struct, .block a.current.struct { color: #df3600; }\n-.content span.type, .content a.type, .block a.current.type { color: #e57300; }\n-.content span.macro, .content a.macro, .block a.current.macro { color: #068000; }\n .block a.current.crate { font-weight: 500; }\n \n .search-input {"}, {"sha": "034c5307fc0807836ae9689d4f139d73acbd9097", "filename": "src/librustdoc/html/static/styles/main.css", "status": "modified", "additions": 31, "deletions": 19, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -64,21 +64,6 @@ pre {\n \tbackground-color: #f6fdb0 !important;\n }\n \n-:target { background: #FDFFD3; }\n-.content .highlighted {\n-\tcolor: #000 !important;\n-\tbackground-color: #ccc;\n-}\n-.content .highlighted a, .content .highlighted span { color: #000 !important; }\n-.content .highlighted.trait { background-color: #fece7e; }\n-.content .highlighted.mod { background-color: #afc6e4; }\n-.content .highlighted.enum { background-color: #b4d1b9; }\n-.content .highlighted.struct { background-color: #e7b1a0; }\n-.content .highlighted.fn { background-color: #c6afb3; }\n-.content .highlighted.method { background-color: #c6afb3; }\n-.content .highlighted.tymethod { background-color: #c6afb3; }\n-.content .highlighted.type { background-color: #c6afb3; }\n-\n .docblock h1, .docblock h2, .docblock h3, .docblock h4, .docblock h5 {\n \tborder-bottom-color: #DDD;\n }\n@@ -97,13 +82,42 @@ pre {\n \tborder-bottom-color: #ddd;\n }\n \n-.content span.primitive, .content a.primitive, .block a.current.primitive { color: #39a7bf; }\n+:target { background: #FDFFD3; }\n+.content .highlighted {\n+\tcolor: #000 !important;\n+\tbackground-color: #ccc;\n+}\n+.content .highlighted a, .content .highlighted span { color: #000 !important; }\n+.content .highlighted.trait { background-color: #c7b6ff; }\n+.content .highlighted.mod,\n+.content .highlighted.externcrate { background-color: #afc6e4; }\n+.content .highlighted.enum { background-color: #b4d1b9; }\n+.content .highlighted.struct { background-color: #e7b1a0; }\n+.content .highlighted.union { background-color: #b7bd49; }\n+.content .highlighted.fn,\n+.content .highlighted.method,\n+.content .highlighted.tymethod { background-color: #c6afb3; }\n+.content .highlighted.type { background-color: #ffc891; }\n+.content .highlighted.macro { background-color: #8ce488; }\n+.content .highlighted.constant,\n+.content .highlighted.static { background-color: #c3e0ff; }\n+.content .highlighted.primitive { background-color: #9aecff; }\n+\n+.content span.enum, .content a.enum, .block a.current.enum { color: #508157; }\n+.content span.struct, .content a.struct, .block a.current.struct { color: #df3600; }\n+.content span.type, .content a.type, .block a.current.type { color: #ba5d00; }\n+.content span.macro, .content a.macro, .block a.current.macro { color: #068000; }\n+.content span.union, .content a.union, .block a.current.union { color: #767b27; }\n+.content span.constant, .content a.constant, .block a.current.constant,\n+.content span.static, .content a.static, .block a.current.static { color: #546e8a; }\n+.content span.primitive, .content a.primitive, .block a.current.primitive { color: #2c8093; }\n .content span.externcrate,\n .content span.mod, .content a.mod, .block a.current.mod { color: #4d76ae; }\n+.content span.trait, .content a.trait, .block a.current.trait { color: #7c5af3; }\n .content span.fn, .content a.fn, .block a.current.fn,\n .content span.method, .content a.method, .block a.current.method,\n .content span.tymethod, .content a.tymethod, .block a.current.tymethod,\n-.content .fnname { color: #8c6067; }\n+.content .fnname { color: #9a6e31; }\n \n pre.rust .comment { color: #8E908C; }\n pre.rust .doccomment { color: #4D4D4C; }\n@@ -130,8 +144,6 @@ a.test-arrow {\n \tcolor: #f5f5f5;\n }\n \n-.content span.trait, .content a.trait, .block a.current.trait { color: #7c5af3; }\n-\n .search-input {\n \tcolor: #555;\n \tbox-shadow: 0 0 0 1px #e0e0e0, 0 0 0 2px transparent;"}, {"sha": "80a223c7d74eaae6dcf72231c747749c063afe4b", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 43, "deletions": 14, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -123,13 +123,13 @@ pub struct HashSet<T, S = RandomState> {\n }\n \n impl<T: Hash + Eq> HashSet<T, RandomState> {\n-    /// Creates an empty HashSet.\n+    /// Creates an empty `HashSet`.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let mut set: HashSet<i32> = HashSet::new();\n+    /// let set: HashSet<i32> = HashSet::new();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -146,7 +146,8 @@ impl<T: Hash + Eq> HashSet<T, RandomState> {\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// let mut set: HashSet<i32> = HashSet::with_capacity(10);\n+    /// let set: HashSet<i32> = HashSet::with_capacity(10);\n+    /// assert!(set.capacity() >= 10);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -215,6 +216,17 @@ impl<T, S> HashSet<T, S>\n     /// Returns a reference to the set's [`BuildHasher`].\n     ///\n     /// [`BuildHasher`]: ../../std/hash/trait.BuildHasher.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    /// use std::collections::hash_map::RandomState;\n+    ///\n+    /// let hasher = RandomState::new();\n+    /// let set: HashSet<i32> = HashSet::with_hasher(hasher);\n+    /// let hasher: &RandomState = set.hasher();\n+    /// ```\n     #[stable(feature = \"hashmap_public_hasher\", since = \"1.9.0\")]\n     pub fn hasher(&self) -> &S {\n         self.map.hasher()\n@@ -249,6 +261,7 @@ impl<T, S> HashSet<T, S>\n     /// use std::collections::HashSet;\n     /// let mut set: HashSet<i32> = HashSet::new();\n     /// set.reserve(10);\n+    /// assert!(set.capacity() >= 10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n@@ -312,13 +325,13 @@ impl<T, S> HashSet<T, S>\n     ///     println!(\"{}\", x); // Print 1\n     /// }\n     ///\n-    /// let diff: HashSet<_> = a.difference(&b).cloned().collect();\n-    /// assert_eq!(diff, [1].iter().cloned().collect());\n+    /// let diff: HashSet<_> = a.difference(&b).collect();\n+    /// assert_eq!(diff, [1].iter().collect());\n     ///\n     /// // Note that difference is not symmetric,\n     /// // and `b - a` means something else:\n-    /// let diff: HashSet<_> = b.difference(&a).cloned().collect();\n-    /// assert_eq!(diff, [4].iter().cloned().collect());\n+    /// let diff: HashSet<_> = b.difference(&a).collect();\n+    /// assert_eq!(diff, [4].iter().collect());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n@@ -343,11 +356,11 @@ impl<T, S> HashSet<T, S>\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n-    /// let diff1: HashSet<_> = a.symmetric_difference(&b).cloned().collect();\n-    /// let diff2: HashSet<_> = b.symmetric_difference(&a).cloned().collect();\n+    /// let diff1: HashSet<_> = a.symmetric_difference(&b).collect();\n+    /// let diff2: HashSet<_> = b.symmetric_difference(&a).collect();\n     ///\n     /// assert_eq!(diff1, diff2);\n-    /// assert_eq!(diff1, [1, 4].iter().cloned().collect());\n+    /// assert_eq!(diff1, [1, 4].iter().collect());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self,\n@@ -371,8 +384,8 @@ impl<T, S> HashSet<T, S>\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n-    /// let intersection: HashSet<_> = a.intersection(&b).cloned().collect();\n-    /// assert_eq!(intersection, [2, 3].iter().cloned().collect());\n+    /// let intersection: HashSet<_> = a.intersection(&b).collect();\n+    /// assert_eq!(intersection, [2, 3].iter().collect());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n@@ -397,8 +410,8 @@ impl<T, S> HashSet<T, S>\n     ///     println!(\"{}\", x);\n     /// }\n     ///\n-    /// let union: HashSet<_> = a.union(&b).cloned().collect();\n-    /// assert_eq!(union, [1, 2, 3, 4].iter().cloned().collect());\n+    /// let union: HashSet<_> = a.union(&b).collect();\n+    /// assert_eq!(union, [1, 2, 3, 4].iter().collect());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n@@ -440,6 +453,22 @@ impl<T, S> HashSet<T, S>\n     }\n \n     /// Clears the set, returning all elements in an iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set: HashSet<_> = [1, 2, 3].iter().cloned().collect();\n+    /// assert!(!set.is_empty());\n+    ///\n+    /// // print 1, 2, 3 in an arbitrary order\n+    /// for i in set.drain() {\n+    ///     println!(\"{}\", i);\n+    /// }\n+    ///\n+    /// assert!(set.is_empty());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n     pub fn drain(&mut self) -> Drain<T> {"}, {"sha": "5a813c5c76bcaea3a24f2e1f0e0339f956799995", "filename": "src/libstd/os/solaris/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fos%2Fsolaris%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fos%2Fsolaris%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fsolaris%2Fraw.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -32,7 +32,7 @@ use os::unix::raw::{uid_t, gid_t};\n #[stable(feature = \"raw_ext\", since = \"1.1.0\")] pub type time_t = i64;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n-pub type pthread_t = usize;\n+pub type pthread_t = u32;\n \n #[repr(C)]\n #[derive(Clone)]"}, {"sha": "c90a0c7852737b70066528c617ed707d83bd0df3", "filename": "src/libstd/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -2237,7 +2237,7 @@ impl Path {\n         fs::metadata(self).is_ok()\n     }\n \n-    /// Returns whether the path is pointing at a regular file.\n+    /// Returns whether the path exists on disk and is pointing at a regular file.\n     ///\n     /// This function will traverse symbolic links to query information about the\n     /// destination file. In case of broken symbolic links this will return `false`.\n@@ -2266,7 +2266,7 @@ impl Path {\n         fs::metadata(self).map(|m| m.is_file()).unwrap_or(false)\n     }\n \n-    /// Returns whether the path is pointing at a directory.\n+    /// Returns whether the path exists on disk and is pointing at a directory.\n     ///\n     /// This function will traverse symbolic links to query information about the\n     /// destination file. In case of broken symbolic links this will return `false`."}, {"sha": "7be319d1954ec361104d5fa5f3d493816fea5a38", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -722,3 +722,221 @@ mod prim_isize { }\n ///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_usize { }\n+\n+#[doc(primitive = \"reference\")]\n+//\n+/// References, both shared and mutable.\n+///\n+/// A reference represents a borrow of some owned value. You can get one by using the `&` or `&mut`\n+/// operators on a value, or by using a `ref` or `ref mut` pattern.\n+///\n+/// For those familiar with pointers, a reference is just a pointer that is assumed to not be null.\n+/// In fact, `Option<&T>` has the same memory representation as a nullable pointer, and can be\n+/// passed across FFI boundaries as such.\n+///\n+/// In most cases, references can be used much like the original value. Field access, method\n+/// calling, and indexing work the same (save for mutability rules, of course). In addition, the\n+/// comparison operators transparently defer to the referent's implementation, allowing references\n+/// to be compared the same as owned values.\n+///\n+/// References have a lifetime attached to them, which represents the scope for which the borrow is\n+/// valid. A lifetime is said to \"outlive\" another one if its representative scope is as long or\n+/// longer than the other. The `'static` lifetime is the longest lifetime, which represents the\n+/// total life of the program. For example, string literals have a `'static` lifetime because the\n+/// text data is embedded into the binary of the program, rather than in an allocation that needs\n+/// to be dynamically managed.\n+///\n+/// `&mut T` references can be freely coerced into `&T` references with the same referent type, and\n+/// references with longer lifetimes can be freely coerced into references with shorter ones.\n+///\n+/// For more information on how to use references, see [the book's section on \"References and\n+/// Borrowing\"][book-refs].\n+///\n+/// [book-refs]: ../book/second-edition/ch04-02-references-and-borrowing.html\n+///\n+/// The following traits are implemented for all `&T`, regardless of the type of its referent:\n+///\n+/// * [`Copy`]\n+/// * [`Clone`] \\(Note that this will not defer to `T`'s `Clone` implementation if it exists!)\n+/// * [`Deref`]\n+/// * [`Borrow`]\n+/// * [`Pointer`]\n+///\n+/// [`Copy`]: marker/trait.Copy.html\n+/// [`Clone`]: clone/trait.Clone.html\n+/// [`Deref`]: ops/trait.Deref.html\n+/// [`Borrow`]: borrow/trait.Borrow.html\n+/// [`Pointer`]: fmt/trait.Pointer.html\n+///\n+/// `&mut T` references get all of the above except `Copy` and `Clone` (to prevent creating\n+/// multiple simultaneous mutable borrows), plus the following, regardless of the type of its\n+/// referent:\n+///\n+/// * [`DerefMut`]\n+/// * [`BorrowMut`]\n+///\n+/// [`DerefMut`]: ops/trait.DerefMut.html\n+/// [`BorrowMut`]: borrow/trait.BorrowMut.html\n+///\n+/// The following traits are implemented on `&T` references if the underlying `T` also implements\n+/// that trait:\n+///\n+/// * All the traits in [`std::fmt`] except [`Pointer`] and [`fmt::Write`]\n+/// * [`PartialOrd`]\n+/// * [`Ord`]\n+/// * [`PartialEq`]\n+/// * [`Eq`]\n+/// * [`AsRef`]\n+/// * [`Fn`] \\(in addition, `&T` references get [`FnMut`] and [`FnOnce`] if `T: Fn`)\n+/// * [`Hash`]\n+/// * [`ToSocketAddrs`]\n+///\n+/// [`std::fmt`]: fmt/index.html\n+/// [`fmt::Write`]: fmt/trait.Write.html\n+/// [`PartialOrd`]: cmp/trait.PartialOrd.html\n+/// [`Ord`]: cmp/trait.Ord.html\n+/// [`PartialEq`]: cmp/trait.PartialEq.html\n+/// [`Eq`]: cmp/trait.Eq.html\n+/// [`AsRef`]: convert/trait.AsRef.html\n+/// [`Fn`]: ops/trait.Fn.html\n+/// [`FnMut`]: ops/trait.FnMut.html\n+/// [`FnOnce`]: ops/trait.FnOnce.html\n+/// [`Hash`]: hash/trait.Hash.html\n+/// [`ToSocketAddrs`]: net/trait.ToSocketAddrs.html\n+///\n+/// `&mut T` references get all of the above except `ToSocketAddrs`, plus the following, if `T`\n+/// implements that trait:\n+///\n+/// * [`AsMut`]\n+/// * [`FnMut`] \\(in addition, `&mut T` references get [`FnOnce`] if `T: FnMut`)\n+/// * [`fmt::Write`]\n+/// * [`Iterator`]\n+/// * [`DoubleEndedIterator`]\n+/// * [`ExactSizeIterator`]\n+/// * [`FusedIterator`]\n+/// * [`TrustedLen`]\n+/// * [`Send`] \\(note that `&T` references only get `Send` if `T: Sync`)\n+/// * [`io::Write`]\n+/// * [`Read`]\n+/// * [`Seek`]\n+/// * [`BufRead`]\n+///\n+/// [`AsMut`]: convert/trait.AsMut.html\n+/// [`Iterator`]: iter/trait.Iterator.html\n+/// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n+/// [`ExactSizeIterator`]: iter/trait.ExactSizeIterator.html\n+/// [`FusedIterator`]: iter/trait.FusedIterator.html\n+/// [`TrustedLen`]: iter/trait.TrustedLen.html\n+/// [`Send`]: marker/trait.Send.html\n+/// [`io::Write`]: io/trait.Write.html\n+/// [`Read`]: io/trait.Read.html\n+/// [`Seek`]: io/trait.Seek.html\n+/// [`BufRead`]: io/trait.BufRead.html\n+///\n+/// Note that due to method call deref coercion, simply calling a trait method will act like they\n+/// work on references as well as they do on owned values! The implementations described here are\n+/// meant for generic contexts, where the final type `T` is a type parameter or otherwise not\n+/// locally known.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_ref { }\n+\n+#[doc(primitive = \"fn\")]\n+//\n+/// Function pointers, like `fn(usize) -> bool`.\n+///\n+/// *See also the traits [`Fn`], [`FnMut`], and [`FnOnce`].*\n+///\n+/// [`Fn`]: ops/trait.Fn.html\n+/// [`FnMut`]: ops/trait.FnMut.html\n+/// [`FnOnce`]: ops/trait.FnOnce.html\n+///\n+/// Plain function pointers are obtained by casting either plain functions, or closures that don't\n+/// capture an environment:\n+///\n+/// ```\n+/// fn add_one(x: usize) -> usize {\n+///     x + 1\n+/// }\n+///\n+/// let ptr: fn(usize) -> usize = add_one;\n+/// assert_eq!(ptr(5), 6);\n+///\n+/// let clos: fn(usize) -> usize = |x| x + 5;\n+/// assert_eq!(clos(5), 10);\n+/// ```\n+///\n+/// In addition to varying based on their signature, function pointers come in two flavors: safe\n+/// and unsafe. Plain `fn()` function pointers can only point to safe functions,\n+/// while `unsafe fn()` function pointers can point to safe or unsafe functions.\n+///\n+/// ```\n+/// fn add_one(x: usize) -> usize {\n+///     x + 1\n+/// }\n+///\n+/// unsafe fn add_one_unsafely(x: usize) -> usize {\n+///     x + 1\n+/// }\n+///\n+/// let safe_ptr: fn(usize) -> usize = add_one;\n+///\n+/// //ERROR: mismatched types: expected normal fn, found unsafe fn\n+/// //let bad_ptr: fn(usize) -> usize = add_one_unsafely;\n+///\n+/// let unsafe_ptr: unsafe fn(usize) -> usize = add_one_unsafely;\n+/// let really_safe_ptr: unsafe fn(usize) -> usize = add_one;\n+/// ```\n+///\n+/// On top of that, function pointers can vary based on what ABI they use. This is achieved by\n+/// adding the `extern` keyword to the type name, followed by the ABI in question. For example,\n+/// `fn()` is different from `extern \"C\" fn()`, which itself is different from `extern \"stdcall\"\n+/// fn()`, and so on for the various ABIs that Rust supports.  Non-`extern` functions have an ABI\n+/// of `\"Rust\"`, and `extern` functions without an explicit ABI have an ABI of `\"C\"`. For more\n+/// information, see [the nomicon's section on foreign calling conventions][nomicon-abi].\n+///\n+/// [nomicon-abi]: ../nomicon/ffi.html#foreign-calling-conventions\n+///\n+/// Extern function declarations with the \"C\" or \"cdecl\" ABIs can also be *variadic*, allowing them\n+/// to be called with a variable number of arguments. Normal rust functions, even those with an\n+/// `extern \"ABI\"`, cannot be variadic. For more information, see [the nomicon's section on\n+/// variadic functions][nomicon-variadic].\n+///\n+/// [nomicon-variadic]: ../nomicon/ffi.html#variadic-functions\n+///\n+/// These markers can be combined, so `unsafe extern \"stdcall\" fn()` is a valid type.\n+///\n+/// Like references in rust, function pointers are assumed to not be null, so if you want to pass a\n+/// function pointer over FFI and be able to accomodate null pointers, make your type\n+/// `Option<fn()>` with your required signature.\n+///\n+/// Function pointers implement the following traits:\n+///\n+/// * [`Clone`]\n+/// * [`PartialEq`]\n+/// * [`Eq`]\n+/// * [`PartialOrd`]\n+/// * [`Ord`]\n+/// * [`Hash`]\n+/// * [`Pointer`]\n+/// * [`Debug`]\n+///\n+/// [`Clone`]: clone/trait.Clone.html\n+/// [`PartialEq`]: cmp/trait.PartialEq.html\n+/// [`Eq`]: cmp/trait.Eq.html\n+/// [`PartialOrd`]: cmp/trait.PartialOrd.html\n+/// [`Ord`]: cmp/trait.Ord.html\n+/// [`Hash`]: hash/trait.Hash.html\n+/// [`Pointer`]: fmt/trait.Pointer.html\n+/// [`Debug`]: fmt/trait.Debug.html\n+///\n+/// Due to a temporary restriction in Rust's type system, these traits are only implemented on\n+/// functions that take 12 arguments or less, with the `\"Rust\"` and `\"C\"` ABIs. In the future, this\n+/// may change.\n+///\n+/// In addition, function pointers of *any* signature, ABI, or safety are [`Copy`], and all *safe*\n+/// function pointers implement [`Fn`], [`FnMut`], and [`FnOnce`]. This works because these traits\n+/// are specially known to the compiler.\n+///\n+/// [`Copy`]: marker/trait.Copy.html\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+mod prim_fn { }"}, {"sha": "a872e7eee0609b617caf9ce5dd2b6cf524792714", "filename": "src/libstd/process.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1417,8 +1417,19 @@ mod tests {\n         let output = String::from_utf8(result.stdout).unwrap();\n \n         for (ref k, ref v) in env::vars() {\n-            // don't check android RANDOM variables\n-            if cfg!(target_os = \"android\") && *k == \"RANDOM\" {\n+            // Don't check android RANDOM variable which seems to change\n+            // whenever the shell runs, and our `env_cmd` is indeed running a\n+            // shell which means it'll get a different RANDOM than we probably\n+            // have.\n+            //\n+            // Also skip env vars with `-` in the name on android because, well,\n+            // I'm not sure. It appears though that the `set` command above does\n+            // not print env vars with `-` in the name, so we just skip them\n+            // here as we won't find them in the output. Note that most env vars\n+            // use `_` instead of `-`, but our build system sets a few env vars\n+            // with `-` in the name.\n+            if cfg!(target_os = \"android\") &&\n+               (*k == \"RANDOM\" || k.contains(\"-\")) {\n                 continue\n             }\n "}, {"sha": "c4d99568c55c79a37285e671a532be80a94dca1e", "filename": "src/libstd/sys/redox/ext/io.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fio.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -15,6 +15,7 @@\n use fs;\n use net;\n use sys;\n+use io;\n use sys_common::{self, AsInner, FromInner, IntoInner};\n \n /// Raw file descriptors.\n@@ -109,6 +110,21 @@ impl AsRawFd for net::UdpSocket {\n     }\n }\n \n+#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n+impl AsRawFd for io::Stdin {\n+    fn as_raw_fd(&self) -> RawFd { 0 }\n+}\n+\n+#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n+impl AsRawFd for io::Stdout {\n+    fn as_raw_fd(&self) -> RawFd { 1 }\n+}\n+\n+#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n+impl AsRawFd for io::Stderr {\n+    fn as_raw_fd(&self) -> RawFd { 2 }\n+}\n+\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawFd for net::TcpStream {\n     unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {"}, {"sha": "0c1bf9e9557609d96e54892aa2eaa661d1459397", "filename": "src/libstd/sys/redox/ext/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -33,6 +33,7 @@ pub mod ffi;\n pub mod fs;\n pub mod io;\n pub mod process;\n+pub mod thread;\n \n /// A prelude for conveniently writing platform-specific code.\n ///\n@@ -46,5 +47,7 @@ pub mod prelude {\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::fs::{FileTypeExt, PermissionsExt, OpenOptionsExt, MetadataExt};\n     #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub use super::thread::JoinHandleExt;\n+    #[doc(no_inline)] #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub use super::process::{CommandExt, ExitStatusExt};\n }"}, {"sha": "52be2ccd9f964b43906c8e935018555cba131760", "filename": "src/libstd/sys/redox/ext/thread.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fthread.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Unix-specific extensions to primitives in the `std::thread` module.\n+\n+#![stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n+\n+use sys_common::{AsInner, IntoInner};\n+use thread::JoinHandle;\n+\n+#[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n+#[allow(deprecated)]\n+pub type RawPthread = usize;\n+\n+/// Unix-specific extensions to `std::thread::JoinHandle`\n+#[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n+pub trait JoinHandleExt {\n+    /// Extracts the raw pthread_t without taking ownership\n+    #[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n+    fn as_pthread_t(&self) -> RawPthread;\n+\n+    /// Consumes the thread, returning the raw pthread_t\n+    ///\n+    /// This function **transfers ownership** of the underlying pthread_t to\n+    /// the caller. Callers are then the unique owners of the pthread_t and\n+    /// must either detach or join the pthread_t once it's no longer needed.\n+    #[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n+    fn into_pthread_t(self) -> RawPthread;\n+}\n+\n+#[stable(feature = \"thread_extensions\", since = \"1.9.0\")]\n+impl<T> JoinHandleExt for JoinHandle<T> {\n+    fn as_pthread_t(&self) -> RawPthread {\n+        self.as_inner().id() as RawPthread\n+    }\n+\n+    fn into_pthread_t(self) -> RawPthread {\n+        self.into_inner().into_id() as RawPthread\n+    }\n+}"}, {"sha": "ba7bbdc657fcf90240696b46d5a28b3d8a0b5f77", "filename": "src/libstd/sys/redox/fd.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Ffd.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -57,9 +57,9 @@ impl FileDesc {\n     }\n \n     pub fn set_cloexec(&self) -> io::Result<()> {\n-        let mut flags = cvt(syscall::fcntl(self.fd, syscall::F_GETFL, 0))?;\n+        let mut flags = cvt(syscall::fcntl(self.fd, syscall::F_GETFD, 0))?;\n         flags |= syscall::O_CLOEXEC;\n-        cvt(syscall::fcntl(self.fd, syscall::F_SETFL, flags)).and(Ok(()))\n+        cvt(syscall::fcntl(self.fd, syscall::F_SETFD, flags)).and(Ok(()))\n     }\n \n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {"}, {"sha": "17fa07b99ae39cbf1f3776c5c0d05d5c223d221f", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -272,21 +272,21 @@ impl Command {\n \n         if let Some(fd) = stdio.stderr.fd() {\n             t!(cvt(syscall::dup2(fd, 2, &[])));\n-            let mut flags = t!(cvt(syscall::fcntl(2, syscall::F_GETFL, 0)));\n+            let mut flags = t!(cvt(syscall::fcntl(2, syscall::F_GETFD, 0)));\n             flags &= ! syscall::O_CLOEXEC;\n-            t!(cvt(syscall::fcntl(2, syscall::F_SETFL, flags)));\n+            t!(cvt(syscall::fcntl(2, syscall::F_SETFD, flags)));\n         }\n         if let Some(fd) = stdio.stdout.fd() {\n             t!(cvt(syscall::dup2(fd, 1, &[])));\n-            let mut flags = t!(cvt(syscall::fcntl(1, syscall::F_GETFL, 0)));\n+            let mut flags = t!(cvt(syscall::fcntl(1, syscall::F_GETFD, 0)));\n             flags &= ! syscall::O_CLOEXEC;\n-            t!(cvt(syscall::fcntl(1, syscall::F_SETFL, flags)));\n+            t!(cvt(syscall::fcntl(1, syscall::F_SETFD, flags)));\n         }\n         if let Some(fd) = stdio.stdin.fd() {\n             t!(cvt(syscall::dup2(fd, 0, &[])));\n-            let mut flags = t!(cvt(syscall::fcntl(0, syscall::F_GETFL, 0)));\n+            let mut flags = t!(cvt(syscall::fcntl(0, syscall::F_GETFD, 0)));\n             flags &= ! syscall::O_CLOEXEC;\n-            t!(cvt(syscall::fcntl(0, syscall::F_SETFL, flags)));\n+            t!(cvt(syscall::fcntl(0, syscall::F_SETFD, flags)));\n         }\n \n         if let Some(g) = self.gid {"}, {"sha": "892007df2b7c66c0dc70a4e3e969c3e0929b92be", "filename": "src/libstd/sys/redox/syscall/flag.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fflag.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -20,8 +20,10 @@ pub const EVENT_NONE: usize = 0;\n pub const EVENT_READ: usize = 1;\n pub const EVENT_WRITE: usize = 2;\n \n-pub const F_GETFL: usize = 1;\n-pub const F_SETFL: usize = 2;\n+pub const F_GETFD: usize = 1;\n+pub const F_SETFD: usize = 2;\n+pub const F_GETFL: usize = 3;\n+pub const F_SETFL: usize = 4;\n \n pub const FUTEX_WAIT: usize = 0;\n pub const FUTEX_WAKE: usize = 1;"}, {"sha": "a0323d933d65a9cf9bc47cdccc29c1151151b221", "filename": "src/libstd/sys/unix/ext/io.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -16,7 +16,9 @@ use fs;\n use net;\n use os::raw;\n use sys;\n+use io;\n use sys_common::{self, AsInner, FromInner, IntoInner};\n+use libc;\n \n /// Raw file descriptors.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -104,6 +106,21 @@ impl AsRawFd for net::UdpSocket {\n     fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n }\n \n+#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n+impl AsRawFd for io::Stdin {\n+    fn as_raw_fd(&self) -> RawFd { libc::STDIN_FILENO }\n+}\n+\n+#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n+impl AsRawFd for io::Stdout {\n+    fn as_raw_fd(&self) -> RawFd { libc::STDOUT_FILENO }\n+}\n+\n+#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n+impl AsRawFd for io::Stderr {\n+    fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n+}\n+\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawFd for net::TcpStream {\n     unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {"}, {"sha": "4e6fde5c29de6112827dd541f034a8d79807c45d", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -284,12 +284,7 @@ impl DirEntry {\n         lstat(&self.path())\n     }\n \n-    #[cfg(target_os = \"solaris\")]\n-    pub fn file_type(&self) -> io::Result<FileType> {\n-        stat(&self.path()).map(|m| m.file_type())\n-    }\n-\n-    #[cfg(target_os = \"haiku\")]\n+    #[cfg(any(target_os = \"solaris\", target_os = \"haiku\"))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         lstat(&self.path()).map(|m| m.file_type())\n     }"}, {"sha": "90128dda088a998862d64b48ddc9d64c3a8a69bf", "filename": "src/libstd/sys/windows/ext/io.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fio.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -15,6 +15,7 @@ use os::windows::raw;\n use net;\n use sys_common::{self, AsInner, FromInner, IntoInner};\n use sys;\n+use io;\n use sys::c;\n \n /// Raw HANDLEs.\n@@ -71,6 +72,27 @@ impl AsRawHandle for fs::File {\n     }\n }\n \n+#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n+impl AsRawHandle for io::Stdin {\n+    fn as_raw_handle(&self) -> RawHandle {\n+        unsafe { c::GetStdHandle(c::STD_INPUT_HANDLE) as RawHandle }\n+    }\n+}\n+\n+#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n+impl AsRawHandle for io::Stdout {\n+    fn as_raw_handle(&self) -> RawHandle {\n+        unsafe { c::GetStdHandle(c::STD_OUTPUT_HANDLE) as RawHandle }\n+    }\n+}\n+\n+#[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n+impl AsRawHandle for io::Stderr {\n+    fn as_raw_handle(&self) -> RawHandle {\n+        unsafe { c::GetStdHandle(c::STD_ERROR_HANDLE) as RawHandle }\n+    }\n+}\n+\n #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n impl FromRawHandle for fs::File {\n     unsafe fn from_raw_handle(handle: RawHandle) -> fs::File {"}, {"sha": "1ca39ff9d4a1ce296117d6357987550c38e39d37", "filename": "src/libstd/sys_common/net.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys_common%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fsys_common%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fnet.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -165,16 +165,8 @@ pub fn lookup_host(host: &str) -> io::Result<LookupHost> {\n     init();\n \n     let c_host = CString::new(host)?;\n-    let hints = c::addrinfo {\n-        ai_flags: 0,\n-        ai_family: 0,\n-        ai_socktype: c::SOCK_STREAM,\n-        ai_protocol: 0,\n-        ai_addrlen: 0,\n-        ai_addr: ptr::null_mut(),\n-        ai_canonname: ptr::null_mut(),\n-        ai_next: ptr::null_mut()\n-    };\n+    let mut hints: c::addrinfo = unsafe { mem::zeroed() };\n+    hints.ai_socktype = c::SOCK_STREAM;\n     let mut res = ptr::null_mut();\n     unsafe {\n         match cvt_gai(c::getaddrinfo(c_host.as_ptr(), ptr::null(), &hints, &mut res)) {"}, {"sha": "cbd019c2c0e64acb5665ab6ab090d079b9781d3c", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -820,7 +820,8 @@ pub fn park_timeout(dur: Duration) {\n ///\n /// A `ThreadId` is an opaque object that has a unique value for each thread\n /// that creates one. `ThreadId`s are not guaranteed to correspond to a thread's\n-/// system-designated identifier.\n+/// system-designated identifier. A `ThreadId` can be retrieved from the [`id`]\n+/// method on a [`Thread`].\n ///\n /// # Examples\n ///\n@@ -834,6 +835,9 @@ pub fn park_timeout(dur: Duration) {\n /// let other_thread_id = other_thread.join().unwrap();\n /// assert!(thread::current().id() != other_thread_id);\n /// ```\n+///\n+/// [`id`]: ../../std/thread/struct.Thread.html#method.id\n+/// [`Thread`]: ../../std/thread/struct.Thread.html\n #[stable(feature = \"thread_id\", since = \"1.19.0\")]\n #[derive(Eq, PartialEq, Clone, Copy, Hash, Debug)]\n pub struct ThreadId(u64);\n@@ -896,6 +900,9 @@ struct Inner {\n /// docs of [`Builder`] and [`spawn`] for more details.\n ///\n /// [`Builder`]: ../../std/thread/struct.Builder.html\n+/// [`JoinHandle::thread`]: ../../std/thread/struct.JoinHandle.html#method.thread\n+/// [`JoinHandle`]: ../../std/thread/struct.JoinHandle.html\n+/// [`thread::current`]: ../../std/thread/fn.current.html\n /// [`spawn`]: ../../std/thread/fn.spawn.html\n \n pub struct Thread {"}, {"sha": "cce428cad6df0344fb7dc4f38a8ab544fd94aa8b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -336,6 +336,7 @@ impl Default for Generics {\n             where_clause: WhereClause {\n                 id: DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n+                span: DUMMY_SP,\n             },\n             span: DUMMY_SP,\n         }\n@@ -347,6 +348,7 @@ impl Default for Generics {\n pub struct WhereClause {\n     pub id: NodeId,\n     pub predicates: Vec<WherePredicate>,\n+    pub span: Span,\n }\n \n /// A single predicate in a `where` clause\n@@ -733,6 +735,13 @@ impl Stmt {\n         };\n         self\n     }\n+\n+    pub fn is_item(&self) -> bool {\n+        match self.node {\n+            StmtKind::Local(_) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n impl fmt::Debug for Stmt {\n@@ -1152,6 +1161,8 @@ pub struct TraitItem {\n     pub attrs: Vec<Attribute>,\n     pub node: TraitItemKind,\n     pub span: Span,\n+    /// See `Item::tokens` for what this is\n+    pub tokens: Option<TokenStream>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -1171,6 +1182,8 @@ pub struct ImplItem {\n     pub attrs: Vec<Attribute>,\n     pub node: ImplItemKind,\n     pub span: Span,\n+    /// See `Item::tokens` for what this is\n+    pub tokens: Option<TokenStream>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -1815,6 +1828,15 @@ pub struct Item {\n     pub node: ItemKind,\n     pub vis: Visibility,\n     pub span: Span,\n+\n+    /// Original tokens this item was parsed from. This isn't necessarily\n+    /// available for all items, although over time more and more items should\n+    /// have this be `Some`. Right now this is primarily used for procedural\n+    /// macros, notably custom attributes.\n+    ///\n+    /// Note that the tokens here do not include the outer attributes, but will\n+    /// include inner attributes.\n+    pub tokens: Option<TokenStream>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]"}, {"sha": "bfdcae7641dd52f2af9d07454b55982dcbb79eee", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -561,8 +561,9 @@ impl CodeMapper for CodeMap {\n         sp\n     }\n     fn ensure_filemap_source_present(&self, file_map: Rc<FileMap>) -> bool {\n-        let src = self.file_loader.read_file(Path::new(&file_map.name)).ok();\n-        return file_map.add_external_src(src)\n+        file_map.add_external_src(\n+            || self.file_loader.read_file(Path::new(&file_map.name)).ok()\n+        )\n     }\n }\n "}, {"sha": "6598ecb94448b7bbb15d47e56656151a050c40d2", "filename": "src/libsyntax/diagnostic_list.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fdiagnostic_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fdiagnostic_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic_list.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -42,7 +42,7 @@ The `inline` attribute was malformed.\n \n Erroneous code example:\n \n-```compile_fail,E0534\n+```ignore (compile_fail not working here; see Issue #43707)\n #[inline()] // error: expected one argument\n pub fn something() {}\n \n@@ -80,7 +80,7 @@ An unknown argument was given to the `inline` attribute.\n \n Erroneous code example:\n \n-```compile_fail,E0535\n+```ignore (compile_fail not working here; see Issue #43707)\n #[inline(unknown)] // error: invalid argument\n pub fn something() {}\n \n@@ -190,7 +190,9 @@ A literal was used in an attribute that doesn't support literals.\n \n Erroneous code example:\n \n-```compile_fail,E0565\n+```ignore (compile_fail not working here; see Issue #43707)\n+#![feature(attr_literals)]\n+\n #[inline(\"always\")] // error: unsupported literal\n pub fn something() {}\n ```\n@@ -209,7 +211,7 @@ A file wasn't found for an out-of-line module.\n \n Erroneous code example:\n \n-```compile_fail,E0583\n+```ignore (compile_fail not working here; see Issue #43707)\n mod file_that_doesnt_exist; // error: file not found for module\n \n fn main() {}\n@@ -251,23 +253,33 @@ An inclusive range was used with no end.\n Erroneous code example:\n \n ```compile_fail,E0586\n-let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n-let x = &tmp[1...]; // error: inclusive range was used with no end\n+#![feature(inclusive_range_syntax)]\n+\n+fn main() {\n+    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n+    let x = &tmp[1...]; // error: inclusive range was used with no end\n+}\n ```\n \n An inclusive range needs an end in order to *include* it. If you just need a\n start and no end, use a non-inclusive range (with `..`):\n \n ```\n-let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n-let x = &tmp[1..]; // ok!\n+fn main() {\n+    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n+    let x = &tmp[1..]; // ok!\n+}\n ```\n \n Or put an end to your inclusive range:\n \n ```\n-let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n-let x = &tmp[1...3]; // ok!\n+#![feature(inclusive_range_syntax)]\n+\n+fn main() {\n+    let tmp = vec![0, 1, 2, 3, 4, 4, 3, 3, 2, 1];\n+    let x = &tmp[1...3]; // ok!\n+}\n ```\n \"##,\n "}, {"sha": "855f4cd3557008ad1dca7a0a8a6f2a24cb487922", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -236,6 +236,7 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n             ),\n             vis: ast::Visibility::Public,\n             span: span,\n+            tokens: None,\n         })\n     ]))\n }"}, {"sha": "de0538e38b3ccaffcc194bec70c803149986f466", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -979,7 +979,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             node: node,\n             vis: ast::Visibility::Inherited,\n-            span: span\n+            span: span,\n+            tokens: None,\n         })\n     }\n \n@@ -1147,7 +1148,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             attrs: vec![],\n             node: ast::ItemKind::Use(vp),\n             vis: vis,\n-            span: sp\n+            span: sp,\n+            tokens: None,\n         })\n     }\n "}, {"sha": "16c264e0f941028e4cb59d636d58caed8500f09b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -214,6 +214,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             ident: keywords::Invalid.ident(),\n             id: ast::DUMMY_NODE_ID,\n             vis: ast::Visibility::Public,\n+            tokens: None,\n         })));\n \n         match self.expand(krate_item).make_items().pop().map(P::unwrap) {"}, {"sha": "e3377c1d8deefa05b4428a528a349a03cc653e8a", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -46,15 +46,18 @@ pub fn placeholder(kind: ExpansionKind, id: ast::NodeId) -> Expansion {\n         ExpansionKind::Items => Expansion::Items(SmallVector::one(P(ast::Item {\n             id: id, span: span, ident: ident, vis: vis, attrs: attrs,\n             node: ast::ItemKind::Mac(mac_placeholder()),\n+            tokens: None,\n         }))),\n         ExpansionKind::TraitItems => Expansion::TraitItems(SmallVector::one(ast::TraitItem {\n             id: id, span: span, ident: ident, attrs: attrs,\n             node: ast::TraitItemKind::Macro(mac_placeholder()),\n+            tokens: None,\n         })),\n         ExpansionKind::ImplItems => Expansion::ImplItems(SmallVector::one(ast::ImplItem {\n             id: id, span: span, ident: ident, vis: vis, attrs: attrs,\n             node: ast::ImplItemKind::Macro(mac_placeholder()),\n             defaultness: ast::Defaultness::Final,\n+            tokens: None,\n         })),\n         ExpansionKind::Pat => Expansion::Pat(P(ast::Pat {\n             id: id, span: span, node: ast::PatKind::Mac(mac_placeholder()),"}, {"sha": "8f9f179f08b5dca49b8289cf7eae1c86ac2e5574", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -737,14 +737,15 @@ pub fn noop_fold_generics<T: Folder>(Generics {ty_params, lifetimes, where_claus\n }\n \n pub fn noop_fold_where_clause<T: Folder>(\n-                              WhereClause {id, predicates}: WhereClause,\n+                              WhereClause {id, predicates, span}: WhereClause,\n                               fld: &mut T)\n                               -> WhereClause {\n     WhereClause {\n         id: fld.new_id(id),\n         predicates: predicates.move_map(|predicate| {\n             fld.fold_where_predicate(predicate)\n-        })\n+        }),\n+        span: span,\n     }\n }\n \n@@ -957,7 +958,8 @@ pub fn noop_fold_trait_item<T: Folder>(i: TraitItem, folder: &mut T)\n                 TraitItemKind::Macro(folder.fold_mac(mac))\n             }\n         },\n-        span: folder.new_span(i.span)\n+        span: folder.new_span(i.span),\n+        tokens: i.tokens,\n     })\n }\n \n@@ -980,7 +982,8 @@ pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T)\n             ast::ImplItemKind::Type(ty) => ast::ImplItemKind::Type(folder.fold_ty(ty)),\n             ast::ImplItemKind::Macro(mac) => ast::ImplItemKind::Macro(folder.fold_mac(mac))\n         },\n-        span: folder.new_span(i.span)\n+        span: folder.new_span(i.span),\n+        tokens: i.tokens,\n     })\n }\n \n@@ -1000,6 +1003,7 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, span}: Crate,\n         vis: ast::Visibility::Public,\n         span: span,\n         node: ast::ItemKind::Mod(module),\n+        tokens: None,\n     })).into_iter();\n \n     let (module, attrs, span) = match items.next() {\n@@ -1032,15 +1036,19 @@ pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<It\n }\n \n // fold one item into exactly one item\n-pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}: Item,\n+pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span, tokens}: Item,\n                                         folder: &mut T) -> Item {\n     Item {\n         id: folder.new_id(id),\n         vis: folder.fold_vis(vis),\n         ident: folder.fold_ident(ident),\n         attrs: fold_attrs(attrs, folder),\n         node: folder.fold_item_kind(node),\n-        span: folder.new_span(span)\n+        span: folder.new_span(span),\n+\n+        // FIXME: if this is replaced with a call to `folder.fold_tts` it causes\n+        //        an ICE during resolve... odd!\n+        tokens: tokens,\n     }\n }\n "}, {"sha": "43345b02bf614e65029c888192c048037afed96e", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -148,4 +148,4 @@ pub mod ext {\n #[cfg(test)]\n mod test_snippet;\n \n-// __build_diagnostic_array! { libsyntax, DIAGNOSTICS }\n+__build_diagnostic_array! { libsyntax, DIAGNOSTICS }"}, {"sha": "893bada2670df2799c9918d257a41673496e59ea", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -843,11 +843,18 @@ mod tests {\n     // check the contents of the tt manually:\n     #[test] fn parse_fundecl () {\n         // this test depends on the intern order of \"fn\" and \"i32\"\n-        assert_eq!(string_to_item(\"fn a (b : i32) { b; }\".to_string()),\n+        let item = string_to_item(\"fn a (b : i32) { b; }\".to_string()).map(|m| {\n+            m.map(|mut m| {\n+                m.tokens = None;\n+                m\n+            })\n+        });\n+        assert_eq!(item,\n                   Some(\n                       P(ast::Item{ident:Ident::from_str(\"a\"),\n                             attrs:Vec::new(),\n                             id: ast::DUMMY_NODE_ID,\n+                            tokens: None,\n                             node: ast::ItemKind::Fn(P(ast::FnDecl {\n                                 inputs: vec![ast::Arg{\n                                     ty: P(ast::Ty{id: ast::DUMMY_NODE_ID,\n@@ -860,13 +867,14 @@ mod tests {\n                                     pat: P(ast::Pat {\n                                         id: ast::DUMMY_NODE_ID,\n                                         node: PatKind::Ident(\n-                                            ast::BindingMode::ByValue(ast::Mutability::Immutable),\n-                                                Spanned{\n-                                                    span: sp(6,7),\n-                                                    node: Ident::from_str(\"b\")},\n-                                                None\n-                                                    ),\n-                                            span: sp(6,7)\n+                                            ast::BindingMode::ByValue(\n+                                                ast::Mutability::Immutable),\n+                                            Spanned{\n+                                                span: sp(6,7),\n+                                                node: Ident::from_str(\"b\")},\n+                                            None\n+                                        ),\n+                                        span: sp(6,7)\n                                     }),\n                                         id: ast::DUMMY_NODE_ID\n                                     }],\n@@ -885,6 +893,7 @@ mod tests {\n                                         where_clause: ast::WhereClause {\n                                             id: ast::DUMMY_NODE_ID,\n                                             predicates: Vec::new(),\n+                                            span: syntax_pos::DUMMY_SP,\n                                         },\n                                         span: syntax_pos::DUMMY_SP,\n                                     },"}, {"sha": "5fe3cf0ddac664e3973e6bae717082e42283d31d", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 133, "deletions": 9, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -216,6 +216,30 @@ struct TokenCursorFrame {\n     open_delim: bool,\n     tree_cursor: tokenstream::Cursor,\n     close_delim: bool,\n+    last_token: LastToken,\n+}\n+\n+/// This is used in `TokenCursorFrame` above to track tokens that are consumed\n+/// by the parser, and then that's transitively used to record the tokens that\n+/// each parse AST item is created with.\n+///\n+/// Right now this has two states, either collecting tokens or not collecting\n+/// tokens. If we're collecting tokens we just save everything off into a local\n+/// `Vec`. This should eventually though likely save tokens from the original\n+/// token stream and just use slicing of token streams to avoid creation of a\n+/// whole new vector.\n+///\n+/// The second state is where we're passively not recording tokens, but the last\n+/// token is still tracked for when we want to start recording tokens. This\n+/// \"last token\" means that when we start recording tokens we'll want to ensure\n+/// that this, the first token, is included in the output.\n+///\n+/// You can find some more example usage of this in the `collect_tokens` method\n+/// on the parser.\n+#[derive(Clone)]\n+enum LastToken {\n+    Collecting(Vec<TokenTree>),\n+    Was(Option<TokenTree>),\n }\n \n impl TokenCursorFrame {\n@@ -226,6 +250,7 @@ impl TokenCursorFrame {\n             open_delim: delimited.delim == token::NoDelim,\n             tree_cursor: delimited.stream().into_trees(),\n             close_delim: delimited.delim == token::NoDelim,\n+            last_token: LastToken::Was(None),\n         }\n     }\n }\n@@ -250,6 +275,11 @@ impl TokenCursor {\n                 return TokenAndSpan { tok: token::Eof, sp: syntax_pos::DUMMY_SP }\n             };\n \n+            match self.frame.last_token {\n+                LastToken::Collecting(ref mut v) => v.push(tree.clone()),\n+                LastToken::Was(ref mut t) => *t = Some(tree.clone()),\n+            }\n+\n             match tree {\n                 TokenTree::Token(sp, tok) => return TokenAndSpan { tok: tok, sp: sp },\n                 TokenTree::Delimited(sp, ref delimited) => {\n@@ -1209,7 +1239,20 @@ impl<'a> Parser<'a> {\n     /// Parse the items in a trait declaration\n     pub fn parse_trait_item(&mut self, at_end: &mut bool) -> PResult<'a, TraitItem> {\n         maybe_whole!(self, NtTraitItem, |x| x);\n-        let mut attrs = self.parse_outer_attributes()?;\n+        let attrs = self.parse_outer_attributes()?;\n+        let (mut item, tokens) = self.collect_tokens(|this| {\n+            this.parse_trait_item_(at_end, attrs)\n+        })?;\n+        // See `parse_item` for why this clause is here.\n+        if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+            item.tokens = Some(tokens);\n+        }\n+        Ok(item)\n+    }\n+\n+    fn parse_trait_item_(&mut self,\n+                         at_end: &mut bool,\n+                         mut attrs: Vec<Attribute>) -> PResult<'a, TraitItem> {\n         let lo = self.span;\n \n         let (name, node) = if self.eat_keyword(keywords::Type) {\n@@ -1304,6 +1347,7 @@ impl<'a> Parser<'a> {\n             attrs: attrs,\n             node: node,\n             span: lo.to(self.prev_span),\n+            tokens: None,\n         })\n     }\n \n@@ -2030,14 +2074,14 @@ impl<'a> Parser<'a> {\n                 } else {\n                     Ok(self.mk_expr(span, ExprKind::Tup(es), attrs))\n                 }\n-            },\n+            }\n             token::OpenDelim(token::Brace) => {\n                 return self.parse_block_expr(lo, BlockCheckMode::Default, attrs);\n-            },\n-            token::BinOp(token::Or) |  token::OrOr => {\n+            }\n+            token::BinOp(token::Or) | token::OrOr => {\n                 let lo = self.span;\n                 return self.parse_lambda_expr(lo, CaptureBy::Ref, attrs);\n-            },\n+            }\n             token::OpenDelim(token::Bracket) => {\n                 self.bump();\n \n@@ -2293,7 +2337,6 @@ impl<'a> Parser<'a> {\n     pub fn parse_block_expr(&mut self, lo: Span, blk_mode: BlockCheckMode,\n                             outer_attrs: ThinVec<Attribute>)\n                             -> PResult<'a, P<Expr>> {\n-\n         self.expect(&token::OpenDelim(token::Brace))?;\n \n         let mut attrs = outer_attrs;\n@@ -4266,6 +4309,7 @@ impl<'a> Parser<'a> {\n                 where_clause: WhereClause {\n                     id: ast::DUMMY_NODE_ID,\n                     predicates: Vec::new(),\n+                    span: syntax_pos::DUMMY_SP,\n                 },\n                 span: span_lo.to(self.prev_span),\n             })\n@@ -4333,11 +4377,13 @@ impl<'a> Parser<'a> {\n         let mut where_clause = WhereClause {\n             id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),\n+            span: syntax_pos::DUMMY_SP,\n         };\n \n         if !self.eat_keyword(keywords::Where) {\n             return Ok(where_clause);\n         }\n+        let lo = self.prev_span;\n \n         // This is a temporary future proofing.\n         //\n@@ -4415,6 +4461,7 @@ impl<'a> Parser<'a> {\n             }\n         }\n \n+        where_clause.span = lo.to(self.prev_span);\n         Ok(where_clause)\n     }\n \n@@ -4661,6 +4708,7 @@ impl<'a> Parser<'a> {\n             node: node,\n             vis: vis,\n             span: span,\n+            tokens: None,\n         })\n     }\n \n@@ -4716,8 +4764,21 @@ impl<'a> Parser<'a> {\n     /// Parse an impl item.\n     pub fn parse_impl_item(&mut self, at_end: &mut bool) -> PResult<'a, ImplItem> {\n         maybe_whole!(self, NtImplItem, |x| x);\n+        let attrs = self.parse_outer_attributes()?;\n+        let (mut item, tokens) = self.collect_tokens(|this| {\n+            this.parse_impl_item_(at_end, attrs)\n+        })?;\n \n-        let mut attrs = self.parse_outer_attributes()?;\n+        // See `parse_item` for why this clause is here.\n+        if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+            item.tokens = Some(tokens);\n+        }\n+        Ok(item)\n+    }\n+\n+    fn parse_impl_item_(&mut self,\n+                        at_end: &mut bool,\n+                        mut attrs: Vec<Attribute>) -> PResult<'a, ImplItem> {\n         let lo = self.span;\n         let vis = self.parse_visibility(false)?;\n         let defaultness = self.parse_defaultness()?;\n@@ -4749,7 +4810,8 @@ impl<'a> Parser<'a> {\n             vis: vis,\n             defaultness: defaultness,\n             attrs: attrs,\n-            node: node\n+            node: node,\n+            tokens: None,\n         })\n     }\n \n@@ -6025,9 +6087,71 @@ impl<'a> Parser<'a> {\n         Ok(None)\n     }\n \n+    fn collect_tokens<F, R>(&mut self, f: F) -> PResult<'a, (R, TokenStream)>\n+        where F: FnOnce(&mut Self) -> PResult<'a, R>\n+    {\n+        // Record all tokens we parse when parsing this item.\n+        let mut tokens = Vec::new();\n+        match self.token_cursor.frame.last_token {\n+            LastToken::Collecting(_) => {\n+                panic!(\"cannot collect tokens recursively yet\")\n+            }\n+            LastToken::Was(ref mut last) => tokens.extend(last.take()),\n+        }\n+        self.token_cursor.frame.last_token = LastToken::Collecting(tokens);\n+        let prev = self.token_cursor.stack.len();\n+        let ret = f(self);\n+        let last_token = if self.token_cursor.stack.len() == prev {\n+            &mut self.token_cursor.frame.last_token\n+        } else {\n+            &mut self.token_cursor.stack[prev].last_token\n+        };\n+        let mut tokens = match *last_token {\n+            LastToken::Collecting(ref mut v) => mem::replace(v, Vec::new()),\n+            LastToken::Was(_) => panic!(\"our vector went away?\"),\n+        };\n+\n+        // If we're not at EOF our current token wasn't actually consumed by\n+        // `f`, but it'll still be in our list that we pulled out. In that case\n+        // put it back.\n+        if self.token == token::Eof {\n+            *last_token = LastToken::Was(None);\n+        } else {\n+            *last_token = LastToken::Was(tokens.pop());\n+        }\n+\n+        Ok((ret?, tokens.into_iter().collect()))\n+    }\n+\n     pub fn parse_item(&mut self) -> PResult<'a, Option<P<Item>>> {\n         let attrs = self.parse_outer_attributes()?;\n-        self.parse_item_(attrs, true, false)\n+\n+        let (ret, tokens) = self.collect_tokens(|this| {\n+            this.parse_item_(attrs, true, false)\n+        })?;\n+\n+        // Once we've parsed an item and recorded the tokens we got while\n+        // parsing we may want to store `tokens` into the item we're about to\n+        // return. Note, though, that we specifically didn't capture tokens\n+        // related to outer attributes. The `tokens` field here may later be\n+        // used with procedural macros to convert this item back into a token\n+        // stream, but during expansion we may be removing attributes as we go\n+        // along.\n+        //\n+        // If we've got inner attributes then the `tokens` we've got above holds\n+        // these inner attributes. If an inner attribute is expanded we won't\n+        // actually remove it from the token stream, so we'll just keep yielding\n+        // it (bad!). To work around this case for now we just avoid recording\n+        // `tokens` if we detect any inner attributes. This should help keep\n+        // expansion correct, but we should fix this bug one day!\n+        Ok(ret.map(|item| {\n+            item.map(|mut i| {\n+                if !i.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n+                    i.tokens = Some(tokens);\n+                }\n+                i\n+            })\n+        }))\n     }\n \n     fn parse_path_list_items(&mut self) -> PResult<'a, Vec<ast::PathListItem>> {"}, {"sha": "5832cfcdf36324c50a4876c8549f6315b380314a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1041,6 +1041,7 @@ impl<'a> State<'a> {\n                     where_clause: ast::WhereClause {\n                         id: ast::DUMMY_NODE_ID,\n                         predicates: Vec::new(),\n+                        span: syntax_pos::DUMMY_SP,\n                     },\n                     span: syntax_pos::DUMMY_SP,\n                 };\n@@ -2993,6 +2994,7 @@ impl<'a> State<'a> {\n             where_clause: ast::WhereClause {\n                 id: ast::DUMMY_NODE_ID,\n                 predicates: Vec::new(),\n+                span: syntax_pos::DUMMY_SP,\n             },\n             span: syntax_pos::DUMMY_SP,\n         };"}, {"sha": "d9ed96f293a80625b958153899bb9c2147b7a364", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -60,6 +60,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<Strin\n         ident: ast::Ident::from_str(name),\n         id: ast::DUMMY_NODE_ID,\n         span: DUMMY_SP,\n+        tokens: None,\n     }));\n \n     let span = ignored_span(DUMMY_SP);\n@@ -82,6 +83,7 @@ pub fn maybe_inject_crates_ref(mut krate: ast::Crate, alt_std_name: Option<Strin\n         id: ast::DUMMY_NODE_ID,\n         ident: keywords::Invalid.ident(),\n         span: span,\n+        tokens: None,\n     }));\n \n     krate"}, {"sha": "887479a24724989263ed43b21a98b775c334852b", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -192,7 +192,7 @@ impl fold::Folder for EntryPointCleaner {\n             EntryPointType::MainNamed |\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n-                folded.map(|ast::Item {id, ident, attrs, node, vis, span}| {\n+                folded.map(|ast::Item {id, ident, attrs, node, vis, span, tokens}| {\n                     let allow_str = Symbol::intern(\"allow\");\n                     let dead_code_str = Symbol::intern(\"dead_code\");\n                     let word_vec = vec![attr::mk_list_word_item(dead_code_str)];\n@@ -212,7 +212,8 @@ impl fold::Folder for EntryPointCleaner {\n                             .collect(),\n                         node: node,\n                         vis: vis,\n-                        span: span\n+                        span: span,\n+                        tokens: tokens,\n                     }\n                 }),\n             EntryPointType::None |\n@@ -255,6 +256,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n         node: ast::ItemKind::Mod(reexport_mod),\n         vis: ast::Visibility::Public,\n         span: DUMMY_SP,\n+        tokens: None,\n     })).pop().unwrap();\n \n     (it, sym)\n@@ -465,7 +467,8 @@ fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n         node: vi,\n         attrs: vec![],\n         vis: vis,\n-        span: sp\n+        span: sp,\n+        tokens: None,\n     })\n }\n \n@@ -506,7 +509,8 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n         vis: ast::Visibility::Public,\n-        span: sp\n+        span: sp,\n+        tokens: None,\n     })\n }\n \n@@ -536,6 +540,7 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         node: item_,\n         vis: ast::Visibility::Public,\n         span: DUMMY_SP,\n+        tokens: None,\n     })).pop().unwrap();\n     let reexport = cx.reexport_test_harness_main.map(|s| {\n         // building `use <ident> = __test::main`\n@@ -551,7 +556,8 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n             attrs: vec![],\n             node: ast::ItemKind::Use(P(use_path)),\n             vis: ast::Visibility::Inherited,\n-            span: DUMMY_SP\n+            span: DUMMY_SP,\n+            tokens: None,\n         })).pop().unwrap()\n     });\n "}, {"sha": "3cbc7938bde0c0a46362f679d205d19cf47f5f9d", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -504,6 +504,7 @@ impl<'a> TraitDef<'a> {\n                 defaultness: ast::Defaultness::Final,\n                 attrs: Vec::new(),\n                 node: ast::ImplItemKind::Type(type_def.to_ty(cx, self.span, type_ident, generics)),\n+                tokens: None,\n             }\n         });\n \n@@ -930,6 +931,7 @@ impl<'a> MethodDef<'a> {\n                                                 decl: fn_decl,\n                                             },\n                                             body_block),\n+            tokens: None,\n         }\n     }\n "}, {"sha": "f5ac1743920c11874eabf7164b7458840d868ec2", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -216,6 +216,7 @@ fn mk_generics(lifetimes: Vec<ast::LifetimeDef>, ty_params: Vec<ast::TyParam>, s\n         where_clause: ast::WhereClause {\n             id: ast::DUMMY_NODE_ID,\n             predicates: Vec::new(),\n+            span: span,\n         },\n         span: span,\n     }"}, {"sha": "9734bb867f1d80e0af7a8cdc6b1112d3ba2943f8", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -20,7 +20,7 @@ use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n use syntax::tokenstream;\n \n use std::collections::{HashMap, HashSet};\n@@ -558,8 +558,10 @@ impl<'a, 'b> Context<'a, 'b> {\n         // passed to this function.\n         for (i, e) in self.args.into_iter().enumerate() {\n             let name = self.ecx.ident_of(&format!(\"__arg{}\", i));\n-            let span =\n-                Span { ctxt: e.span.ctxt.apply_mark(self.ecx.current_expansion.mark), ..e.span };\n+            let span = Span {\n+                ctxt: e.span.ctxt.apply_mark(self.ecx.current_expansion.mark),\n+                ..DUMMY_SP\n+            };\n             pats.push(self.ecx.pat_ident(span, name));\n             for ref arg_ty in self.arg_unique_types[i].iter() {\n                 locals.push(Context::format_arg(self.ecx, self.macsp, e.span, arg_ty, name));"}, {"sha": "8b0bb8cb891ee5267bf1a3a39a5089d475f0adfc", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -61,5 +61,6 @@ pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt,\n         })),\n         vis: ast::Visibility::Inherited,\n         span: sp,\n+        tokens: None,\n     })))\n }"}, {"sha": "7006f45455e38830f484b10b97aaa287268d63cf", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -618,8 +618,11 @@ impl FileMap {\n     /// If the hash of the input doesn't match or no input is supplied via None,\n     /// it is interpreted as an error and the corresponding enum variant is set.\n     /// The return value signifies whether some kind of source is present.\n-    pub fn add_external_src(&self, src: Option<String>) -> bool {\n+    pub fn add_external_src<F>(&self, get_src: F) -> bool\n+        where F: FnOnce() -> Option<String>\n+    {\n         if *self.external_src.borrow() == ExternalSource::AbsentOk {\n+            let src = get_src();\n             let mut external_src = self.external_src.borrow_mut();\n             if let Some(src) = src {\n                 let mut hasher: StableHasher<u128> = StableHasher::new();"}, {"sha": "e49f1f28e5f1db904603d9b282e78b8003850ad6", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -326,7 +326,7 @@ fn with_interner<T, F: FnOnce(&mut Interner) -> T>(f: F) -> T {\n /// destroyed. In particular, they must not access string contents. This can\n /// be fixed in the future by just leaking all strings until thread death\n /// somehow.\n-#[derive(Clone, Hash, PartialOrd, Eq, Ord)]\n+#[derive(Clone, Copy, Hash, PartialOrd, Eq, Ord)]\n pub struct InternedString {\n     string: &'static str,\n }"}, {"sha": "bca0881c08c5a35a433f9b61dea2e17e9e8fe178", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -178,23 +178,17 @@ GEN_SUBTARGETS\n \n extern \"C\" bool LLVMRustHasFeature(LLVMTargetMachineRef TM,\n                                    const char *Feature) {\n+#if LLVM_RUSTLLVM\n   TargetMachine *Target = unwrap(TM);\n   const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n   const FeatureBitset &Bits = MCInfo->getFeatureBits();\n-  const llvm::SubtargetFeatureKV *FeatureEntry;\n-\n-#define SUBTARGET(x)                                                           \\\n-  if (MCInfo->isCPUStringValid(x##SubTypeKV[0].Key)) {                         \\\n-    FeatureEntry = x##FeatureKV;                                               \\\n-  } else\n-\n-  GEN_SUBTARGETS { return false; }\n-#undef SUBTARGET\n-\n-  while (strcmp(Feature, FeatureEntry->Key) != 0)\n-    FeatureEntry++;\n+  const ArrayRef<SubtargetFeatureKV> FeatTable = MCInfo->getFeatureTable();\n \n-  return (Bits & FeatureEntry->Value) == FeatureEntry->Value;\n+  for (auto &FeatureEntry : FeatTable)\n+    if (!strcmp(FeatureEntry.Key, Feature))\n+      return (Bits & FeatureEntry.Value) == FeatureEntry.Value;\n+#endif\n+  return false;\n }\n \n enum class LLVMRustCodeModel {"}, {"sha": "569d937c812cbe67f8056f32d1b64a7961be1d5b", "filename": "src/test/codegen/slice-init.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcodegen%2Fslice-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcodegen%2Fslice-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-init.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @zero_sized_elem\n+#[no_mangle]\n+pub fn zero_sized_elem() {\n+    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: call void @llvm.memset.p0i8\n+    let x = [(); 4];\n+    drop(&x);\n+}\n+\n+// CHECK-LABEL: @zero_len_array\n+#[no_mangle]\n+pub fn zero_len_array() {\n+    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: call void @llvm.memset.p0i8\n+    let x = [4; 0];\n+    drop(&x);\n+}\n+\n+// CHECK-LABEL: @byte_array\n+#[no_mangle]\n+pub fn byte_array() {\n+    // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 7, i[[WIDTH]] 4\n+    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    let x = [7u8; 4];\n+    drop(&x);\n+}\n+\n+#[allow(dead_code)]\n+#[derive(Copy, Clone)]\n+enum Init {\n+    Loop,\n+    Memset,\n+}\n+\n+// CHECK-LABEL: @byte_enum_array\n+#[no_mangle]\n+pub fn byte_enum_array() {\n+    // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 {{.*}}, i[[WIDTH]] 4\n+    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    let x = [Init::Memset; 4];\n+    drop(&x);\n+}\n+\n+// CHECK-LABEL: @zeroed_integer_array\n+#[no_mangle]\n+pub fn zeroed_integer_array() {\n+    // CHECK: call void @llvm.memset.p0i8.i[[WIDTH:[0-9]+]](i8* {{.*}}, i8 0, i[[WIDTH]] 16\n+    // CHECK-NOT: br label %slice_loop_header{{.*}}\n+    let x = [0u32; 4];\n+    drop(&x);\n+}\n+\n+// CHECK-LABEL: @nonzero_integer_array\n+#[no_mangle]\n+pub fn nonzero_integer_array() {\n+    // CHECK: br label %slice_loop_header{{.*}}\n+    // CHECK-NOT: call void @llvm.memset.p0i8\n+    let x = [0x1a_2b_3c_4d_u32; 4];\n+    drop(&x);\n+}"}, {"sha": "261564ed51aedf1b27dc8c90e877ca0c4d19f50c", "filename": "src/test/codegen/vec-optimizes-away.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcodegen%2Fvec-optimizes-away.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcodegen%2Fvec-optimizes-away.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fvec-optimizes-away.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//\n+// no-system-llvm\n+// compile-flags: -O\n+#![crate_type=\"lib\"]\n+\n+#[no_mangle]\n+pub fn sum_me() -> i32 {\n+    // CHECK-LABEL: @sum_me\n+    // CHECK-NEXT: {{^.*:$}}\n+    // CHECK-NEXT: ret i32 6\n+    vec![1, 2, 3].iter().sum::<i32>()\n+}"}, {"sha": "65f4b6350c4eed4f578d9d78bc61949360b66a4f", "filename": "src/test/compile-fail-fulldeps/proc-macro/attribute-with-error.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattribute-with-error.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:attribute-with-error.rs\n+\n+#![feature(proc_macro)]\n+\n+extern crate attribute_with_error;\n+\n+use attribute_with_error::foo;\n+\n+#[foo]\n+fn test1() {\n+    let a: i32 = \"foo\";\n+    //~^ ERROR: mismatched types\n+}\n+\n+fn test2() {\n+    #![foo]\n+\n+    // FIXME: should have a type error here and assert it works but it doesn't\n+}\n+\n+trait A {\n+    // FIXME: should have a #[foo] attribute here and assert that it works\n+    fn foo(&self) {\n+        let a: i32 = \"foo\";\n+        //~^ ERROR: mismatched types\n+    }\n+}\n+\n+struct B;\n+\n+impl A for B {\n+    #[foo]\n+    fn foo(&self) {\n+        let a: i32 = \"foo\";\n+        //~^ ERROR: mismatched types\n+    }\n+}\n+\n+#[foo]\n+fn main() {\n+}"}, {"sha": "508f8dac5711939f75f13bfbac6b1b0645378eba", "filename": "src/test/compile-fail-fulldeps/proc-macro/attributes-included.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fattributes-included.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:attributes-included.rs\n+\n+#![feature(proc_macro, rustc_attrs)]\n+\n+extern crate attributes_included;\n+\n+#[attributes_included::bar]\n+#[inline]\n+/// doc\n+#[attributes_included::foo]\n+#[inline]\n+/// doc\n+fn foo() {\n+    let a: i32 = \"foo\"; //~ WARN: unused variable\n+}\n+\n+#[rustc_error]\n+fn main() { //~ ERROR: compilation successful\n+    foo()\n+}"}, {"sha": "85a7a0bf6336f30a6d3b169d5284069d903bd178", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/attribute-with-error.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattribute-with-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattribute-with-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattribute-with-error.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_attribute]\n+pub fn foo(_attr: TokenStream, input: TokenStream) -> TokenStream {\n+    input.into_iter().collect()\n+}"}, {"sha": "a1efbb88a4d2e26dc1e9c1ef274452a259e9cb59", "filename": "src/test/compile-fail-fulldeps/proc-macro/auxiliary/attributes-included.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fproc-macro%2Fauxiliary%2Fattributes-included.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,130 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// force-host\n+// no-prefer-dynamic\n+\n+#![feature(proc_macro)]\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{TokenStream, TokenTree, TokenNode, Delimiter, Literal};\n+\n+#[proc_macro_attribute]\n+pub fn foo(attr: TokenStream, input: TokenStream) -> TokenStream {\n+    assert!(attr.is_empty());\n+    let input = input.into_iter().collect::<Vec<_>>();\n+    {\n+        let mut cursor = &input[..];\n+        assert_inline(&mut cursor);\n+        assert_doc(&mut cursor);\n+        assert_inline(&mut cursor);\n+        assert_doc(&mut cursor);\n+        assert_foo(&mut cursor);\n+        assert!(cursor.is_empty());\n+    }\n+    fold_stream(input.into_iter().collect())\n+}\n+\n+#[proc_macro_attribute]\n+pub fn bar(attr: TokenStream, input: TokenStream) -> TokenStream {\n+    assert!(attr.is_empty());\n+    let input = input.into_iter().collect::<Vec<_>>();\n+    {\n+        let mut cursor = &input[..];\n+        assert_inline(&mut cursor);\n+        assert_doc(&mut cursor);\n+        assert_invoc(&mut cursor);\n+        assert_inline(&mut cursor);\n+        assert_doc(&mut cursor);\n+        assert_foo(&mut cursor);\n+        assert!(cursor.is_empty());\n+    }\n+    input.into_iter().collect()\n+}\n+\n+fn assert_inline(slice: &mut &[TokenTree]) {\n+    match slice[0].kind {\n+        TokenNode::Op('#', _) => {}\n+        _ => panic!(\"expected '#' char\"),\n+    }\n+    match slice[1].kind {\n+        TokenNode::Group(Delimiter::Bracket, _) => {}\n+        _ => panic!(\"expected brackets\"),\n+    }\n+    *slice = &slice[2..];\n+}\n+\n+fn assert_doc(slice: &mut &[TokenTree]) {\n+    match slice[0].kind {\n+        TokenNode::Literal(_) => {}\n+        _ => panic!(\"expected literal doc comment got other\"),\n+    }\n+    *slice = &slice[1..];\n+}\n+\n+fn assert_invoc(slice: &mut &[TokenTree]) {\n+    match slice[0].kind {\n+        TokenNode::Op('#', _) => {}\n+        _ => panic!(\"expected '#' char\"),\n+    }\n+    match slice[1].kind {\n+        TokenNode::Group(Delimiter::Bracket, _) => {}\n+        _ => panic!(\"expected brackets\"),\n+    }\n+    *slice = &slice[2..];\n+}\n+\n+fn assert_foo(slice: &mut &[TokenTree]) {\n+    match slice[0].kind {\n+        TokenNode::Term(ref name) => assert_eq!(name.as_str(), \"fn\"),\n+        _ => panic!(\"expected fn\"),\n+    }\n+    match slice[1].kind {\n+        TokenNode::Term(ref name) => assert_eq!(name.as_str(), \"foo\"),\n+        _ => panic!(\"expected foo\"),\n+    }\n+    match slice[2].kind {\n+        TokenNode::Group(Delimiter::Parenthesis, ref s) => assert!(s.is_empty()),\n+        _ => panic!(\"expected parens\"),\n+    }\n+    match slice[3].kind {\n+        TokenNode::Group(Delimiter::Brace, _) => {}\n+        _ => panic!(\"expected braces\"),\n+    }\n+    *slice = &slice[4..];\n+}\n+\n+fn fold_stream(input: TokenStream) -> TokenStream {\n+    input.into_iter().map(fold_tree).collect()\n+}\n+\n+fn fold_tree(input: TokenTree) -> TokenTree {\n+    TokenTree {\n+        span: input.span,\n+        kind: fold_node(input.kind),\n+    }\n+}\n+\n+fn fold_node(input: TokenNode) -> TokenNode {\n+    match input {\n+        TokenNode::Group(a, b) => TokenNode::Group(a, fold_stream(b)),\n+        TokenNode::Op(a, b) => TokenNode::Op(a, b),\n+        TokenNode::Term(a) => TokenNode::Term(a),\n+        TokenNode::Literal(a) => {\n+            if a.to_string() != \"\\\"foo\\\"\" {\n+                TokenNode::Literal(a)\n+            } else {\n+                TokenNode::Literal(Literal::integer(3))\n+            }\n+        }\n+    }\n+}"}, {"sha": "e8b0915d2b533fa24e339911715073f2b5cc2dd1", "filename": "src/test/compile-fail/E0559.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2FE0559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2FE0559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0559.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -15,5 +15,6 @@ enum Field {\n fn main() {\n     let s = Field::Fool { joke: 0 };\n     //~^ ERROR E0559\n-    //~| NOTE field does not exist - did you mean `x`?\n+    //~| NOTE `Field::Fool` does not have this field\n+    //~| NOTE available fields are: `x`\n }"}, {"sha": "955ef7ca99ceb51df2d73999c0aa3a94b41a81e0", "filename": "src/test/compile-fail/E0560.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2FE0560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2FE0560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0560.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -16,4 +16,5 @@ fn main() {\n     let s = Simba { mother: 1, father: 0 };\n     //~^ ERROR E0560\n     //~| NOTE `Simba` does not have this field\n+    //~| NOTE available fields are: `mother`\n }"}, {"sha": "952e0b31c4ca1458ccf4f0e15da768793dca1aa5", "filename": "src/test/compile-fail/E0624.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2FE0624.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2FE0624.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0624.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod inner {\n+    pub struct Foo;\n+\n+    impl Foo {\n+        fn method(&self) {}\n+    }\n+}\n+\n+fn main() {\n+    let foo = inner::Foo;\n+    foo.method(); //~ ERROR method `method` is private [E0624]\n+}"}, {"sha": "b863e90a3b710d312cf20894cba4104bae3bc3c7", "filename": "src/test/compile-fail/asm-bad-clobber.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fasm-bad-clobber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fasm-bad-clobber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-bad-clobber.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -14,6 +14,7 @@\n // ignore-s390x\n // ignore-emscripten\n // ignore-powerpc\n+// ignore-sparc\n \n #![feature(asm, rustc_attrs)]\n "}, {"sha": "cae41332795dfa37a2302c15731c695acc523ad2", "filename": "src/test/compile-fail/asm-in-bad-modifier.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fasm-in-bad-modifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fasm-in-bad-modifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-in-bad-modifier.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -11,6 +11,7 @@\n // ignore-s390x\n // ignore-emscripten\n // ignore-powerpc\n+// ignore-sparc\n \n #![feature(asm)]\n "}, {"sha": "e634238c6e179954bdac78e298267341703a6bf4", "filename": "src/test/compile-fail/asm-misplaced-option.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-misplaced-option.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -14,6 +14,7 @@\n // ignore-s390x\n // ignore-emscripten\n // ignore-powerpc\n+// ignore-sparc\n \n #![feature(asm, rustc_attrs)]\n "}, {"sha": "546d402252e2701916cd63d29fa712232c47ed7a", "filename": "src/test/compile-fail/asm-out-assign-imm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-out-assign-imm.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -11,6 +11,7 @@\n // ignore-s390x\n // ignore-emscripten\n // ignore-powerpc\n+// ignore-sparc\n \n #![feature(asm)]\n "}, {"sha": "2e843ddac822152404b8300657ec1f6ecf8305cb", "filename": "src/test/compile-fail/asm-out-no-modifier.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fasm-out-no-modifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fasm-out-no-modifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-out-no-modifier.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -11,6 +11,7 @@\n // ignore-s390x\n // ignore-emscripten\n // ignore-powerpc\n+// ignore-sparc\n \n #![feature(asm)]\n "}, {"sha": "c85a097b962c8681702533ecafda095200de0918", "filename": "src/test/compile-fail/asm-out-read-uninit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fasm-out-read-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fasm-out-read-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fasm-out-read-uninit.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -11,6 +11,7 @@\n // ignore-s390x\n // ignore-emscripten\n // ignore-powerpc\n+// ignore-sparc\n \n #![feature(asm)]\n "}, {"sha": "0e822aff01e877771ef084835c72736bec3aeacc", "filename": "src/test/compile-fail/associated-types/cache/project-fn-ret-contravariant.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -43,23 +43,19 @@ fn baz<'a,'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n     (a, b)\n }\n \n-// FIXME(#32330)\n-//#[cfg(transmute)] // one instantiations: BAD\n-//fn baz<'a,'b>(x: &'a u32) -> &'static u32 {\n-//    bar(foo, x) //[transmute] ERROR E0495\n-//}\n+#[cfg(transmute)] // one instantiations: BAD\n+fn baz<'a,'b>(x: &'a u32) -> &'static u32 {\n+   bar(foo, x) //[transmute]~ ERROR E0495\n+}\n \n-// FIXME(#32330)\n-//#[cfg(krisskross)] // two instantiations, mixing and matching: BAD\n-//fn transmute<'a,'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n-//    let a = bar(foo, y); //[krisskross] ERROR E0495\n-//    let b = bar(foo, x); //[krisskross] ERROR E0495\n-//    (a, b)\n-//}\n+#[cfg(krisskross)] // two instantiations, mixing and matching: BAD\n+fn transmute<'a,'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n+   let a = bar(foo, y); //[krisskross]~ ERROR E0495\n+   let b = bar(foo, x); //[krisskross]~ ERROR E0495\n+   (a, b)\n+}\n \n #[rustc_error]\n fn main() { }\n //[ok]~^ ERROR compilation successful\n //[oneuse]~^^ ERROR compilation successful\n-//[transmute]~^^^ ERROR compilation successful\n-//[krisskross]~^^^^ ERROR compilation successful"}, {"sha": "10fe612980d34a114cd374250926afcfb66e39e5", "filename": "src/test/compile-fail/associated-types/cache/project-fn-ret-invariant.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -42,35 +42,29 @@ fn baz<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n     (a, b)\n }\n \n-// FIXME(#32330)\n-//#[cfg(oneuse)] // one instantiation: BAD\n-//fn baz<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n-//    let f = foo; // <-- No consistent type can be inferred for `f` here.\n-//    let a = bar(f, x); //[oneuse] ERROR E0495\n-//    let b = bar(f, y);\n-//    (a, b)\n-//}\n+#[cfg(oneuse)] // one instantiation: BAD\n+fn baz<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+   let f = foo; // <-- No consistent type can be inferred for `f` here.\n+   let a = bar(f, x); //[oneuse]~^ ERROR E0495\n+   let b = bar(f, y);\n+   (a, b)\n+}\n \n-// FIXME(#32330)\n-//#[cfg(transmute)] // one instantiations: BAD\n-//fn baz<'a,'b>(x: Type<'a>) -> Type<'static> {\n-//    // Cannot instantiate `foo` with any lifetime other than `'a`,\n-//    // since it is provided as input.\n-//\n-//    bar(foo, x) //[transmute] ERROR E0495\n-//}\n+#[cfg(transmute)] // one instantiations: BAD\n+fn baz<'a,'b>(x: Type<'a>) -> Type<'static> {\n+   // Cannot instantiate `foo` with any lifetime other than `'a`,\n+   // since it is provided as input.\n \n-// FIXME(#32330)\n-//#[cfg(krisskross)] // two instantiations, mixing and matching: BAD\n-//fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n-//    let a = bar(foo, y); //[krisskross] ERROR E0495\n-//    let b = bar(foo, x); //[krisskross] ERROR E0495\n-//    (a, b)\n-//}\n+   bar(foo, x) //[transmute]~ ERROR E0495\n+}\n+\n+#[cfg(krisskross)] // two instantiations, mixing and matching: BAD\n+fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+   let a = bar(foo, y); //[krisskross]~ ERROR E0495\n+   let b = bar(foo, x); //[krisskross]~ ERROR E0495\n+   (a, b)\n+}\n \n #[rustc_error]\n fn main() { }\n //[ok]~^ ERROR compilation successful\n-//[oneuse]~^^ ERROR compilation successful\n-//[transmute]~^^^ ERROR compilation successful\n-//[krisskross]~^^^^ ERROR compilation successful"}, {"sha": "c88d74d53ce9424cf21d56aef2b13676010ad182", "filename": "src/test/compile-fail/hr-subtype.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fhr-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fhr-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhr-subtype.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -91,9 +91,6 @@ check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n // - if we are covariant, then 'a and 'b can be set to the call-site\n //   intersection;\n // - if we are contravariant, then 'a can be inferred to 'static.\n-//\n-// FIXME(#32330) this is true, but we are not currently impl'ing this\n-// full semantics\n check! { bound_a_b_vs_bound_a: (for<'a,'b> fn(&'a u32, &'b u32),\n                                 for<'a>    fn(&'a u32, &'a u32)) }\n check! { bound_co_a_b_vs_bound_co_a: (for<'a,'b> fn(Co<'a>, Co<'b>),"}, {"sha": "938ccb343d4270099b2524eeecef1cd4ea5d3570", "filename": "src/test/compile-fail/issue-19922.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19922.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -15,5 +15,6 @@ enum Homura {\n fn main() {\n     let homura = Homura::Akemi { kaname: () };\n     //~^ ERROR variant `Homura::Akemi` has no field named `kaname`\n-    //~| NOTE field does not exist - did you mean `madoka`?\n+    //~| NOTE `Homura::Akemi` does not have this field\n+    //~| NOTE available fields are: `madoka`\n }"}, {"sha": "c09e56cbc5bcaeeaf15e7238b45e82bc8cd55e33", "filename": "src/test/compile-fail/issue-35675.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cc4ff8f4d169562ff4ae22b94197a191215e6d56/src%2Ftest%2Fcompile-fail%2Fissue-35675.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc4ff8f4d169562ff4ae22b94197a191215e6d56/src%2Ftest%2Fcompile-fail%2Fissue-35675.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-35675.rs?ref=cc4ff8f4d169562ff4ae22b94197a191215e6d56", "patch": "@@ -1,67 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// these two HELPs are actually in a new line between this line and the `enum Fruit` line\n-enum Fruit { //~ HELP possible candidate is found in another module, you can import it into scope\n-    //~^ HELP possible candidate is found in another module, you can import it into scope\n-    Apple(i64),\n-    Orange(i64),\n-}\n-\n-fn should_return_fruit() -> Apple {\n-    //~^ ERROR cannot find type `Apple` in this scope\n-    //~| NOTE not found in this scope\n-    //~| HELP you can try using the variant's enum\n-    Apple(5)\n-    //~^ ERROR cannot find function `Apple` in this scope\n-    //~| NOTE not found in this scope\n-}\n-\n-fn should_return_fruit_too() -> Fruit::Apple {\n-    //~^ ERROR expected type, found variant `Fruit::Apple`\n-    //~| HELP you can try using the variant's enum\n-    //~| NOTE not a type\n-    Apple(5)\n-    //~^ ERROR cannot find function `Apple` in this scope\n-    //~| NOTE not found in this scope\n-}\n-\n-fn foo() -> Ok {\n-    //~^ ERROR expected type, found variant `Ok`\n-    //~| NOTE not a type\n-    //~| HELP there is an enum variant\n-    //~| HELP there is an enum variant\n-    Ok(())\n-}\n-\n-fn bar() -> Variant3 {\n-    //~^ ERROR cannot find type `Variant3` in this scope\n-    //~| HELP you can try using the variant's enum\n-    //~| NOTE not found in this scope\n-}\n-\n-fn qux() -> Some {\n-    //~^ ERROR expected type, found variant `Some`\n-    //~| NOTE not a type\n-    //~| HELP there is an enum variant\n-    //~| HELP there is an enum variant\n-    Some(1)\n-}\n-\n-fn main() {}\n-\n-mod x {\n-    enum Enum {\n-        Variant1,\n-        Variant2(),\n-        Variant3(usize),\n-        Variant4 {},\n-    }\n-}"}, {"sha": "142092ff41eb33e30ba42dfa866f412b61b7dc8c", "filename": "src/test/compile-fail/issue-40510-1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fissue-40510-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fissue-40510-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-40510-1.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+fn f() {\n+    let mut x: Box<()> = Box::new(());\n+\n+    || {\n+        &mut x\n+    };\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "0fe56584822635607e7c1d2bb3473f497a1031c1", "filename": "src/test/compile-fail/issue-40510-2.rs", "status": "renamed", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fissue-40510-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fissue-40510-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-40510-2.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -9,10 +9,15 @@\n // except according to those terms.\n \n #![feature(rustc_attrs)]\n-#![allow(warnings)]\n+#![allow(unused)]\n \n-#[rustc_error]\n-fn main() { //~ ERROR compilation successful\n-    /// crash\n-    let x = 0;\n+fn f() {\n+    let x: Box<()> = Box::new(());\n+\n+    || {\n+        &x\n+    };\n }\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful", "previous_filename": "src/test/compile-fail/issue-34222.rs"}, {"sha": "afa8f15ee570af35b622c007b8049da3bce9b9c7", "filename": "src/test/compile-fail/issue-40510-3.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fissue-40510-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fissue-40510-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-40510-3.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+fn f() {\n+    let mut x: Vec<()> = Vec::new();\n+\n+    || {\n+        || {\n+            x.push(())\n+        }\n+    };\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "a39c500225b9bfd148dce3ffe48ed6cf97dca349", "filename": "src/test/compile-fail/issue-40510-4.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fissue-40510-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fissue-40510-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-40510-4.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+fn f() {\n+    let x: Vec<()> = Vec::new();\n+\n+    || {\n+        || {\n+            x.len()\n+        }\n+    };\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "d6e091a1472cd903c483bced35d8e527e78bc4ea", "filename": "src/test/compile-fail/numeric-fields.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnumeric-fields.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -13,7 +13,8 @@ struct S(u8, u16);\n fn main() {\n     let s = S{0b1: 10, 0: 11};\n     //~^ ERROR struct `S` has no field named `0b1`\n-    //~| NOTE field does not exist - did you mean `1`?\n+    //~| NOTE `S` does not have this field\n+    //~| NOTE available fields are: `0`, `1`\n     match s {\n         S{0: a, 0x1: b, ..} => {}\n         //~^ ERROR does not have a field named `0x1`"}, {"sha": "b1af142ad0fd230fd6fb6d5d9f660728ee7017dc", "filename": "src/test/compile-fail/struct-fields-too-many.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-fields-too-many.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -18,5 +18,6 @@ fn main() {\n         bar: 0\n         //~^ ERROR struct `BuildData` has no field named `bar`\n         //~| NOTE `BuildData` does not have this field\n+        //~| NOTE available fields are: `foo`\n     };\n }"}, {"sha": "d0752b5f02f06d74f2bd78d98bf8187f164dd7a8", "filename": "src/test/compile-fail/suggest-private-fields.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuggest-private-fields.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -27,7 +27,8 @@ fn main () {\n         //~| NOTE field does not exist - did you mean `a`?\n         bb: 20,\n         //~^ ERROR struct `xc::B` has no field named `bb`\n-        //~| NOTE field does not exist - did you mean `a`?\n+        //~| NOTE `xc::B` does not have this field\n+        //~| NOTE available fields are: `a`\n     };\n     // local crate struct\n     let l = A {"}, {"sha": "124b16f99b1afd50db88ff8525cfd511ce19e786", "filename": "src/test/compile-fail/union/union-fields.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Funion%2Funion-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Funion%2Funion-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-fields.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -20,6 +20,7 @@ fn main() {\n     let u = U { a: 0, b: 1, c: 2 }; //~ ERROR union expressions should have exactly one field\n                                     //~^ ERROR union `U` has no field named `c`\n                                     //~| NOTE `U` does not have this field\n+                                    //~| NOTE available fields are: `a`, `b`\n     let u = U { ..u }; //~ ERROR union expressions should have exactly one field\n                        //~^ ERROR functional record update syntax requires a struct\n "}, {"sha": "a1172bb214d0a1ae7f44a1e01da02d89234b1a51", "filename": "src/test/compile-fail/useless_comment.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fuseless_comment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fcompile-fail%2Fuseless_comment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fuseless_comment.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(unused_doc_comment)]\n+\n+fn foo() {\n+    /// a //~ ERROR doc comment not used by rustdoc\n+    let x = 12;\n+\n+    /// b //~ doc comment not used by rustdoc\n+    match x {\n+        /// c //~ ERROR doc comment not used by rustdoc\n+        1 => {},\n+        _ => {}\n+    }\n+\n+    /// foo //~ ERROR doc comment not used by rustdoc\n+    unsafe {}\n+}\n+\n+fn main() {\n+    foo();\n+}\n\\ No newline at end of file"}, {"sha": "d999ff97551606478161d6e6ff85150cba695ce7", "filename": "src/test/mir-opt/README.md", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2FREADME.md?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -57,13 +57,6 @@ the lines being too long.\n \n compiletest handles dumping the MIR before and after every pass for you.  The\n test writer only has to specify the file names of the dumped files (not the\n-full path to the file) and what lines to expect.  I added an option to rustc\n+full path to the file) and what lines to expect.  There is an option to rustc\n that tells it to dump the mir into some directly (rather then always dumping to\n-the current directory).  \n-\n-Lines match ignoring whitespace, and the prefix \"//\" is removed of course.\n-\n-It also currently strips trailing comments -- partly because the full file path\n-in \"scope comments\" is unpredictable and partly because tidy complains about\n-the lines being too long.\n-\n+the current directory)."}, {"sha": "d3bf7f68785d568d93e28654985d735bd7331d5e", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 13, "deletions": 19, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -47,42 +47,36 @@ fn main() {\n //         StorageDead(_3);\n //         StorageLive(_4);\n //         _4 = std::option::Option<std::boxed::Box<u32>>::None;\n+//         StorageLive(_5);\n //         StorageLive(_6);\n-//         StorageLive(_7);\n-//         _7 = _4;\n-//         replace(_6 <- _7) -> [return: bb6, unwind: bb7];\n+//         _6 = _4;\n+//         replace(_5 <- _6) -> [return: bb1, unwind: bb5];\n //     }\n //     bb1: {\n-//         resume;\n+//         drop(_6) -> [return: bb6, unwind: bb4];\n //     }\n //     bb2: {\n-//         drop(_4) -> bb1;\n+//         resume;\n //     }\n //     bb3: {\n-//         goto -> bb2;\n+//         drop(_4) -> bb2;\n //     }\n //     bb4: {\n-//         drop(_6) -> bb3;\n+//         drop(_5) -> bb3;\n //     }\n //     bb5: {\n-//         goto -> bb4;\n+//         drop(_6) -> bb4;\n //     }\n //     bb6: {\n-//         drop(_7) -> [return: bb8, unwind: bb4];\n+//         StorageDead(_6);\n+//         _0 = ();\n+//         drop(_5) -> [return: bb7, unwind: bb3];\n //     }\n //     bb7: {\n-//         drop(_7) -> bb5;\n+//         StorageDead(_5);\n+//         drop(_4) -> bb8;\n //     }\n //     bb8: {\n-//         StorageDead(_7);\n-//         _0 = ();\n-//         drop(_6) -> [return: bb9, unwind: bb2];\n-//     }\n-//     bb9: {\n-//         StorageDead(_6);\n-//         drop(_4) -> bb10;\n-//     }\n-//     bb10: {\n //         StorageDead(_4);\n //         StorageDead(_2);\n //         StorageDead(_1);"}, {"sha": "81dd1932894fb326e944e6af5c035d9616fe38e4", "filename": "src/test/mir-opt/deaggregator_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdeaggregator_test.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -25,7 +25,7 @@ fn main() {}\n // bb0: {\n //     _2 = _1;\n //     _3 = _2;\n-//     _0 = Baz { x: _3, y: const F32(0), z: const false };\n+//     _0 = Baz { x: _3, y: const 0f32, z: const false };\n //     return;\n // }\n // END rustc.node13.Deaggregator.before.mir\n@@ -34,7 +34,7 @@ fn main() {}\n //     _2 = _1;\n //     _3 = _2;\n //     (_0.0: usize) = _3;\n-//     (_0.1: f32) = const F32(0);\n+//     (_0.1: f32) = const 0f32;\n //     (_0.2: bool) = const false;\n //     return;\n // }"}, {"sha": "bfb1b3b65289034f5e3c435512ce1e60bf188987", "filename": "src/test/mir-opt/end_region_4.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fend_region_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_4.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -32,41 +32,41 @@ fn foo(i: i32) {\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n //     let mut _0: ();\n //     let _1: D;\n-//     let _3: i32;\n-//     let _4: &'6_2rce i32;\n+//     let _2: i32;\n+//     let _3: &'6_2rce i32;\n //     let _7: &'6_4rce i32;\n-//     let mut _5: ();\n-//     let mut _6: i32;\n-//\n+//     let mut _4: ();\n+//     let mut _5: i32;\n+//     let mut _6: ();\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n+//         StorageLive(_2);\n+//         _2 = const 0i32;\n //         StorageLive(_3);\n-//         _3 = const 0i32;\n-//         StorageLive(_4);\n-//         _4 = &'6_2rce _3;\n-//         StorageLive(_6);\n-//         _6 = (*_4);\n-//         _5 = const foo(_6) -> [return: bb2, unwind: bb3];\n+//         _3 = &'6_2rce _2;\n+//         StorageLive(_5);\n+//         _5 = (*_3);\n+//         _4 = const foo(_5) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n-//         resume;\n-//     }\n-//     bb2: {\n-//         StorageDead(_6);\n+//         StorageDead(_5);\n //         StorageLive(_7);\n-//         _7 = &'6_4rce _3;\n+//         _7 = &'6_4rce _2;\n //         _0 = ();\n //         StorageDead(_7);\n //         EndRegion('6_4rce);\n-//         StorageDead(_4);\n-//         EndRegion('6_2rce);\n //         StorageDead(_3);\n+//         EndRegion('6_2rce);\n+//         StorageDead(_2);\n //         drop(_1) -> bb4;\n //     }\n+//     bb2: {\n+//         resume;\n+//     }\n //     bb3: {\n //         EndRegion('6_2rce);\n-//         drop(_1) -> bb1;\n+//         drop(_1) -> bb2;\n //     }\n //     bb4: {\n //         StorageDead(_1);"}, {"sha": "773a348a939770cb61dcbb2b26bdd7b8a2c6f6f3", "filename": "src/test/mir-opt/end_region_5.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fend_region_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_5.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -31,32 +31,31 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _0: ();\n //     let _1: D;\n //     let mut _2: ();\n-//     let mut _3: ();\n-//     let mut _4: [closure@NodeId(18) d: &'19mce D];\n-//     let mut _5: &'19mce D;\n-//\n+//     let mut _3: [closure@NodeId(18) d:&'19mce D];\n+//     let mut _4: &'19mce D;\n+//     let mut _5: ();\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n+//         StorageLive(_3);\n //         StorageLive(_4);\n-//         StorageLive(_5);\n-//         _5 = &'19mce _1;\n-//         _4 = [closure@NodeId(18)] { d: _5 };\n-//         StorageDead(_5);\n-//         _3 = const foo(_4) -> [return: bb2, unwind: bb3];\n+//         _4 = &'19mce _1;\n+//         _3 = [closure@NodeId(18)] { d: _4 };\n+//         StorageDead(_4);\n+//         _2 = const foo(_3) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n-//         resume;\n-//     }\n-//     bb2: {\n-//         StorageDead(_4);\n+//         StorageDead(_3);\n //         EndRegion('19mce);\n //         _0 = ();\n //         drop(_1) -> bb4;\n //     }\n+//     bb2: {\n+//         resume;\n+//     }\n //     bb3: {\n //         EndRegion('19mce);\n-//         drop(_1) -> bb1;\n+//         drop(_1) -> bb2;\n //     }\n //     bb4: {\n //         StorageDead(_1);"}, {"sha": "112c93843e042e4691267ffba357eb661aaf4d8c", "filename": "src/test/mir-opt/end_region_6.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fend_region_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_6.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -27,35 +27,35 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n \n // END RUST SOURCE\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n+// fn main() -> () {\n //     let mut _0: ();\n //     let _1: D;\n //     let mut _2: ();\n-//     let mut _3: ();\n-//     let mut _4: [closure@NodeId(22) d:&'23mce D];\n-//     let mut _5: &'23mce D;\n-//\n+//     let mut _3: [closure@NodeId(22) d:&'23mce D];\n+//     let mut _4: &'23mce D;\n+//     let mut _5: ();\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n+//         StorageLive(_3);\n //         StorageLive(_4);\n-//         StorageLive(_5);\n-//         _5 = &'23mce _1;\n-//         _4 = [closure@NodeId(22)] { d: _5 };\n-//         StorageDead(_5);\n-//         _3 = const foo(_4) -> [return: bb2, unwind: bb3];\n+//         _4 = &'23mce _1;\n+//         _3 = [closure@NodeId(22)] { d: _4 };\n+//         StorageDead(_4);\n+//         _2 = const foo(_3) -> [return: bb1, unwind: bb3];\n //     }\n //     bb1: {\n-//         resume;\n-//     }\n-//     bb2: {\n-//         StorageDead(_4);\n+//         StorageDead(_3);\n //         EndRegion('23mce);\n //         _0 = ();\n //         drop(_1) -> bb4;\n //     }\n+//     bb2: {\n+//         resume;\n+//     }\n //     bb3: {\n //         EndRegion('23mce);\n-//         drop(_1) -> bb1;\n+//         drop(_1) -> bb2;\n //     }\n //     bb4: {\n //         StorageDead(_1);"}, {"sha": "913986ae816a65024890c6230095cf2e0390632b", "filename": "src/test/mir-opt/end_region_7.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fend_region_7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_7.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -31,18 +31,18 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //     let mut _0: ();\n //     let _1: D;\n //     let mut _2: ();\n-//     let mut _3: ();\n-//     let mut _4: [closure@NodeId(22) d:D];\n-//     let mut _5: D;\n+//     let mut _3: [closure@NodeId(22) d:D];\n+//     let mut _4: D;\n+//     let mut _5: ();\n //\n //     bb0: {\n //         StorageLive(_1);\n //         _1 = D::{{constructor}}(const 0i32,);\n+//         StorageLive(_3);\n //         StorageLive(_4);\n-//         StorageLive(_5);\n-//         _5 = _1;\n-//         _4 = [closure@NodeId(22)] { d: _5 };\n-//         drop(_5) -> [return: bb4, unwind: bb3];\n+//         _4 = _1;\n+//         _3 = [closure@NodeId(22)] { d: _4 };\n+//         drop(_4) -> [return: bb4, unwind: bb3];\n //     }\n //     bb1: {\n //         resume;\n@@ -51,17 +51,17 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n //         drop(_1) -> bb1;\n //     }\n //     bb3: {\n-//         drop(_4) -> bb2;\n+//         drop(_3) -> bb2;\n //     }\n //     bb4: {\n-//         StorageDead(_5);\n-//         _3 = const foo(_4) -> [return: bb5, unwind: bb3];\n+//         StorageDead(_4);\n+//         _2 = const foo(_3) -> [return: bb5, unwind: bb3];\n //     }\n //     bb5: {\n-//         drop(_4) -> [return: bb6, unwind: bb2];\n+//         drop(_3) -> [return: bb6, unwind: bb2];\n //     }\n //     bb6: {\n-//         StorageDead(_4);\n+//         StorageDead(_3);\n //         _0 = ();\n //         drop(_1) -> bb7;\n //     }\n@@ -76,16 +76,16 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // fn main::{{closure}}(_1: [closure@NodeId(22) d:D]) -> i32 {\n //     let mut _0: i32;\n //     let _2: &'14_0rce D;\n-//     let mut _3: ();\n-//     let mut _4: i32;\n+//     let mut _3: i32;\n+//     let mut _4: ();\n //\n //     bb0: {\n //         StorageLive(_2);\n //         _2 = &'14_0rce (_1.0: D);\n-//         StorageLive(_4);\n-//         _4 = ((*_2).0: i32);\n-//         _0 = _4;\n-//         StorageDead(_4);\n+//         StorageLive(_3);\n+//         _3 = ((*_2).0: i32);\n+//         _0 = _3;\n+//         StorageDead(_3);\n //         StorageDead(_2);\n //         EndRegion('14_0rce);\n //         drop(_1) -> bb1;"}, {"sha": "dc8f8ea11f51c5d2a263d1702bc32607b87317a2", "filename": "src/test/mir-opt/end_region_8.rs", "status": "modified", "additions": 37, "deletions": 38, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fend_region_8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fend_region_8.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -29,44 +29,43 @@ fn foo<F>(f: F) where F: FnOnce() -> i32 {\n // END RUST SOURCE\n // START rustc.node4.SimplifyCfg-qualify-consts.after.mir\n // fn main() -> () {\n-//     let mut _0: ();\n-//     let _1: D;\n-//     let _3: &'6_1rce D;\n-//     let mut _2: ();\n-//     let mut _4: ();\n-//     let mut _5: [closure@NodeId(22) r:&'6_1rce D];\n-//     let mut _6: &'6_1rce D;\n-//\n-//     bb0: {\n-//         StorageLive(_1);\n-//         _1 = D::{{constructor}}(const 0i32,);\n-//         StorageLive(_3);\n-//         _3 = &'6_1rce _1;\n-//         StorageLive(_5);\n-//         StorageLive(_6);\n-//         _6 = _3;\n-//         _5 = [closure@NodeId(22)] { r: _6 };\n-//         StorageDead(_6);\n-//         _4 = const foo(_5) -> [return: bb2, unwind: bb3];\n-//     }\n-//     bb1: {\n-//         resume;\n-//     }\n-//     bb2: {\n-//         StorageDead(_5);\n-//         _0 = ();\n-//         StorageDead(_3);\n-//         EndRegion('6_1rce);\n-//         drop(_1) -> bb4;\n-//     }\n-//     bb3: {\n-//         EndRegion('6_1rce);\n-//         drop(_1) -> bb1;\n-//     }\n-//     bb4: {\n-//         StorageDead(_1);\n-//         return;\n-//     }\n+//    let mut _0: ();\n+//    let _1: D;\n+//    let _2: &'6_1rce D;\n+//    let mut _3: ();\n+//    let mut _4: [closure@NodeId(22) r:&'6_1rce D];\n+//    let mut _5: &'6_1rce D;\n+//    let mut _6: ();\n+//    bb0: {\n+//        StorageLive(_1);\n+//        _1 = D::{{constructor}}(const 0i32,);\n+//        StorageLive(_2);\n+//        _2 = &'6_1rce _1;\n+//        StorageLive(_4);\n+//        StorageLive(_5);\n+//        _5 = _2;\n+//        _4 = [closure@NodeId(22)] { r: _5 };\n+//        StorageDead(_5);\n+//        _3 = const foo(_4) -> [return: bb1, unwind: bb3];\n+//    }\n+//    bb1: {\n+//        StorageDead(_4);\n+//        _0 = ();\n+//        StorageDead(_2);\n+//        EndRegion('6_1rce);\n+//        drop(_1) -> bb4;\n+//    }\n+//    bb2: {\n+//        resume;\n+//    }\n+//    bb3: {\n+//        EndRegion('6_1rce);\n+//        drop(_1) -> bb2;\n+//    }\n+//    bb4: {\n+//        StorageDead(_1);\n+//        return;\n+//    }\n // }\n // END rustc.node4.SimplifyCfg-qualify-consts.after.mir\n "}, {"sha": "1daa18256dceec73615a4a01263c89dc168e7bac", "filename": "src/test/mir-opt/issue-41110.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fissue-41110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41110.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -34,18 +34,23 @@ impl S {\n \n // END RUST SOURCE\n // START rustc.node4.ElaborateDrops.after.mir\n+//    let mut _0: ();\n+//    let _1: ();\n //    let mut _2: S;\n-//    let mut _3: ();\n+//    let mut _3: S;\n //    let mut _4: S;\n-//    let mut _5: S;\n+//    let mut _5: ();\n //    let mut _6: bool;\n //\n //    bb0: {\n // END rustc.node4.ElaborateDrops.after.mir\n // START rustc.node13.ElaborateDrops.after.mir\n-//    let mut _2: ();\n-//    let mut _4: ();\n-//    let mut _5: S;\n+//    let mut _0: ();\n+//    let _1: S;\n+//    let mut _2: S;\n+//    let mut _3: ();\n+//    let mut _4: S;\n+//    let mut _5: ();\n //    let mut _6: S;\n //    let mut _7: bool;\n //"}, {"sha": "9ac76a5f4ea614fd2af8480ff4b6ad1ffc316286", "filename": "src/test/mir-opt/validate_1.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags: -Z verbose -Z mir-emit-validate=1\n+\n+struct Test(i32);\n+\n+impl Test {\n+    // Make sure we run the pass on a method, not just on bare functions.\n+    fn foo(&self, _x: &mut i32) {}\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    Test(0).foo(&mut x);\n+\n+    // Also test closures\n+    let c = |x: &mut i32| { let y = &*x; *y };\n+    c(&mut x);\n+}\n+\n+// FIXME: Also test code generated inside the closure, make sure it has validation.  Unfortunately,\n+// the interesting lines of code also contain name of the source file, so we cannot test for it.\n+\n+// END RUST SOURCE\n+// START rustc.node12.EraseRegions.after.mir\n+//     bb0: {\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), node: DefIndex(5) => validate_1/8cd878b::{{impl}}[0]::foo[0] }, BrAnon(0)) Test, _2: &ReFree(DefId { krate: CrateNum(0), node: DefIndex(5) => validate_1/8cd878b::{{impl}}[0]::foo[0] }, BrAnon(1)) mut i32]);\n+//         return;\n+//     }\n+// END rustc.node12.EraseRegions.after.mir\n+// START rustc.node23.EraseRegions.after.mir\n+// fn main() -> () {\n+//     bb0: {\n+//         Validate(Suspend(ReScope(Misc(NodeId(34)))), [_1: i32]);\n+//         _6 = &ReErased mut _1;\n+//         Validate(Acquire, [(*_6): i32/ReScope(Misc(NodeId(34)))]);\n+//         Validate(Suspend(ReScope(Misc(NodeId(34)))), [(*_6): i32/ReScope(Misc(NodeId(34)))]);\n+//         _5 = &ReErased mut (*_6);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Misc(NodeId(34)))]);\n+//         Validate(Release, [_2: (), _3: &ReScope(Misc(NodeId(34))) Test, _5: &ReScope(Misc(NodeId(34))) mut i32]);\n+//         _2 = const Test::foo(_3, _5) -> bb1;\n+//     }\n+//\n+//     bb1: {\n+//         Validate(Acquire, [_2: ()]);\n+//         EndRegion(ReScope(Misc(NodeId(34))));\n+//         return;\n+//     }\n+// }\n+// END rustc.node23.EraseRegions.after.mir"}, {"sha": "37ebd720d52da567aecf5f8974d2912d025bbf5e", "filename": "src/test/mir-opt/validate_2.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_2.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags: -Z verbose -Z mir-emit-validate=1\n+\n+fn main() {\n+    let _x : Box<[i32]> = Box::new([1, 2, 3]);\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node4.EraseRegions.after.mir\n+// fn main() -> () {\n+//     bb1: {\n+//         Validate(Release, [_2: std::boxed::Box<[i32; 3]>]);\n+//         _1 = _2 as std::boxed::Box<[i32]> (Unsize);\n+//         Validate(Acquire, [_1: std::boxed::Box<[i32]>]);\n+//     }\n+// }\n+// END rustc.node4.EraseRegions.after.mir"}, {"sha": "9140cf5768f5918db6a91f2f7ba1f2edc2defa62", "filename": "src/test/mir-opt/validate_3.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags: -Z verbose -Z mir-emit-validate=1\n+\n+struct Test {\n+    x: i32\n+}\n+\n+fn foo(_x: &i32) {}\n+\n+fn main() {\n+    // These internal unsafe functions should have no effect on the code generation.\n+    unsafe fn _unused1() {}\n+    fn _unused2(x: *const i32) -> i32 { unsafe { *x }}\n+\n+    let t = Test { x: 0 };\n+    let t = &t;\n+    foo(&t.x);\n+}\n+\n+// END RUST SOURCE\n+// START rustc.node16.EraseRegions.after.mir\n+// fn main() -> () {\n+//     let mut _5: &ReErased i32;\n+//     bb0: {\n+//         Validate(Suspend(ReScope(Misc(NodeId(46)))), [((*_2).0: i32): i32/ReScope(Remainder(BlockRemainder { block: NodeId(18), first_statement_index: 3 })) (imm)]);\n+//         _5 = &ReErased ((*_2).0: i32);\n+//         Validate(Acquire, [(*_5): i32/ReScope(Misc(NodeId(46))) (imm)]);\n+//         Validate(Suspend(ReScope(Misc(NodeId(46)))), [(*_5): i32/ReScope(Misc(NodeId(46))) (imm)]);\n+//         _4 = &ReErased (*_5);\n+//         Validate(Acquire, [(*_4): i32/ReScope(Misc(NodeId(46))) (imm)]);\n+//         Validate(Release, [_3: (), _4: &ReScope(Misc(NodeId(46))) i32]);\n+//         _3 = const foo(_4) -> bb1;\n+//     }\n+//     bb1: {\n+//         EndRegion(ReScope(Misc(NodeId(46))));\n+//         EndRegion(ReScope(Remainder(BlockRemainder { block: NodeId(18), first_statement_index: 3 })));\n+//         return;\n+//     }\n+// }\n+// END rustc.node16.EraseRegions.after.mir"}, {"sha": "591de975740f9fd572883f2156ad82ff75987706", "filename": "src/test/mir-opt/validate_4.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags: -Z verbose -Z mir-emit-validate=1\n+\n+// Make sure unsafe fns and fns with an unsafe block only get restricted validation.\n+\n+unsafe fn write_42(x: *mut i32) -> bool {\n+    let test_closure = |x: *mut i32| *x = 23;\n+    test_closure(x);\n+    *x = 42;\n+    true\n+}\n+\n+fn test(x: &mut i32) {\n+    unsafe { write_42(x) };\n+}\n+\n+fn main() {\n+    test(&mut 0);\n+\n+    let test_closure = unsafe { |x: &mut i32| write_42(x) };\n+    test_closure(&mut 0);\n+}\n+\n+// FIXME: Also test code generated inside the closure, make sure it only does restricted validation\n+// because it is entirely inside an unsafe block.  Unfortunately, the interesting lines of code also\n+// contain name of the source file, so we cannot test for it.\n+\n+// END RUST SOURCE\n+// START rustc.node4.EraseRegions.after.mir\n+// fn write_42(_1: *mut i32) -> bool {\n+//     bb0: {\n+//         Validate(Acquire, [_1: *mut i32]);\n+//         Validate(Release, [_1: *mut i32]);\n+//         return;\n+//     }\n+// }\n+// END rustc.node4.EraseRegions.after.mir\n+// START rustc.node31.EraseRegions.after.mir\n+// fn test(_1: &ReErased mut i32) -> () {\n+//     bb0: {\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), node: DefIndex(4) => validate_4/8cd878b::test[0] }, BrAnon(0)) mut i32]);\n+//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), node: DefIndex(4) => validate_4/8cd878b::test[0] }, BrAnon(0)) mut i32]);\n+//         _3 = const write_42(_4) -> bb1;\n+//     }\n+//     bb1: {\n+//         Validate(Acquire, [_3: bool]);\n+//         Validate(Release, [_3: bool]);\n+//     }\n+// }\n+// END rustc.node31.EraseRegions.after.mir"}, {"sha": "e9919af9fd3a6fec243a75c3979d7002836d6073", "filename": "src/test/mir-opt/validate_5.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+// compile-flags: -Z verbose -Z mir-emit-validate=2\n+\n+// Make sure unsafe fns and fns with an unsafe block only get full validation.\n+\n+unsafe fn write_42(x: *mut i32) -> bool {\n+    *x = 42;\n+    true\n+}\n+\n+fn test(x: &mut i32) {\n+    unsafe { write_42(x) };\n+}\n+\n+fn main() {\n+    test(&mut 0);\n+\n+    let test_closure = unsafe { |x: &mut i32| write_42(x) };\n+    test_closure(&mut 0);\n+}\n+\n+// FIXME: Also test code generated inside the closure, make sure it has validation.  Unfortunately,\n+// the interesting lines of code also contain name of the source file, so we cannot test for it.\n+\n+// END RUST SOURCE\n+// START rustc.node17.EraseRegions.after.mir\n+// fn test(_1: &ReErased mut i32) -> () {\n+//     bb0: {\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), node: DefIndex(4) => validate_5/8cd878b::test[0] }, BrAnon(0)) mut i32]);\n+//         Validate(Release, [_3: bool, _4: *mut i32]);\n+//         _3 = const write_42(_4) -> bb1;\n+//     }\n+// }\n+// END rustc.node17.EraseRegions.after.mir"}, {"sha": "dc46a8a04ef8c4dd9ebb9ca243e7f16c5dee5e4a", "filename": "src/test/run-make/codegen-options-parsing/Makefile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -25,7 +25,7 @@ all:\n \n \t# Should not link dead code...\n \t$(RUSTC) -Z print-link-args dummy.rs 2>&1 | \\\n-\t\tgrep -e '--gc-sections' -e '-dead_strip' -e '/OPT:REF'\n+\t\tgrep -e '--gc-sections' -e '-z[^ ]* [^ ]*\\<ignore\\>' -e '-dead_strip' -e '/OPT:REF'\n \t# ... unless you specifically ask to keep it\n \t$(RUSTC) -Z print-link-args -C link-dead-code dummy.rs 2>&1 | \\\n-\t\t(! grep -e '--gc-sections' -e '-dead_strip' -e '/OPT:REF')\n+\t\t(! grep -e '--gc-sections' -e '-z[^ ]* [^ ]*\\<ignore\\>' -e '-dead_strip' -e '/OPT:REF')"}, {"sha": "7a63871f19e3854460c22b54aac5dbf4f9b51970", "filename": "src/test/run-make/llvm-phase/test.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -54,11 +54,7 @@ impl<'a> CompilerCalls<'a> for JitCalls {\n             state.session.abort_if_errors();\n             let trans = state.trans.unwrap();\n             assert_eq!(trans.modules.len(), 1);\n-            let rs_llmod = match trans.modules[0].source {\n-                ModuleSource::Preexisting(_) => unimplemented!(),\n-                ModuleSource::Translated(llvm) => llvm.llmod,\n-            };\n-            unsafe { rustc_llvm::LLVMDumpModule(rs_llmod) };\n+            println!(\"name of compiled module = {}\", trans.modules[0].name);\n         });\n         cc\n     }"}, {"sha": "82fa3f6a3c5e03d7ea8141c0526186c762be0a20", "filename": "src/test/run-make/print-cfg/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-make%2Fprint-cfg%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-make%2Fprint-cfg%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fprint-cfg%2FMakefile?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -5,7 +5,7 @@ all: default\n \t$(RUSTC) --target x86_64-pc-windows-gnu --print cfg | grep x86_64\n \t$(RUSTC) --target i686-pc-windows-msvc --print cfg | grep msvc\n \t$(RUSTC) --target i686-apple-darwin --print cfg | grep macos\n-\t$(RUSTC) --target i686-unknown-linux-gnu --print cfg | grep sse2\n+\t$(RUSTC) --target i686-unknown-linux-gnu --print cfg | grep gnu\n \n ifdef IS_WINDOWS\n default:"}, {"sha": "d13ba11e96a3941bb0f4e03a5e3a10eab1b47774", "filename": "src/test/run-make/tools.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-make%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-make%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftools.mk?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -82,7 +82,7 @@ ifeq ($(UNAME),Bitrig)\n \tEXTRACXXFLAGS := -lc++ -lc++abi\n else\n ifeq ($(UNAME),SunOS)\n-\tEXTRACFLAGS := -lm -lpthread -lposix4 -lsocket\n+\tEXTRACFLAGS := -lm -lpthread -lposix4 -lsocket -lresolv\n else\n ifeq ($(UNAME),OpenBSD)\n \tEXTRACFLAGS := -lm -lpthread"}, {"sha": "a8fa2d4e0f82b6aa7714429fb54b5fd01c488dc0", "filename": "src/test/run-make/treat-err-as-bug/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-make%2Ftreat-err-as-bug%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-make%2Ftreat-err-as-bug%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftreat-err-as-bug%2FMakefile?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) err.rs -Z treat-err-as-bug 2>&1 \\\n+\t    | grep -q \"panicked at 'encountered error with .-Z treat_err_as_bug'\""}, {"sha": "078495663acc62caa7e775ba73446f8efa900940", "filename": "src/test/run-make/treat-err-as-bug/err.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-make%2Ftreat-err-as-bug%2Ferr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-make%2Ftreat-err-as-bug%2Ferr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Ftreat-err-as-bug%2Ferr.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type=\"rlib\"]\n+\n+pub static C: u32 = 0-1;"}, {"sha": "3d8bf9333fd2a6562863fadc0b06761f0a3a874c", "filename": "src/test/run-pass/conditional-compile-arch.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fconditional-compile-arch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fconditional-compile-arch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-compile-arch.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -39,3 +39,6 @@ pub fn main() { }\n \n #[cfg(target_arch = \"wasm32\")]\n pub fn main() { }\n+\n+#[cfg(target_arch = \"sparc64\")]\n+pub fn main() { }"}, {"sha": "22fbeb2d5d0ed070b9e4f88969e1891d25ddc06a", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -15,7 +15,6 @@\n // memory, which makes for some *confusing* logs. That's why these are here\n // instead of in std.\n \n-#![reexport_test_harness_main = \"test_main\"]\n #![feature(libc, std_misc, duration)]\n \n extern crate libc;"}, {"sha": "dd5c075c39b16cf8752e6d4178cb30ab06dd1e7b", "filename": "src/test/run-pass/foreign-call-no-runtime.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-aarch64\n // ignore-emscripten no threads support\n \n #![feature(libc)]"}, {"sha": "5a743d7b54784357efc748cd72c025f6dfc117b0", "filename": "src/test/run-pass/issue-13304.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fissue-13304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13304.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-aarch64\n // ignore-emscripten\n #![feature(io, process_capture)]\n "}, {"sha": "f86be2d7c9933fae3d7a5cb0e8449b541de2a994", "filename": "src/test/run-pass/issue-16272.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fissue-16272.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fissue-16272.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16272.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-aarch64\n // ignore-emscripten\n \n use std::process::Command;"}, {"sha": "1ee47a69d0c87dde43b489fe3a3771edaa5f64f1", "filename": "src/test/run-pass/issue-20091.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fissue-20091.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fissue-20091.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20091.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-aarch64\n // ignore-emscripten\n #![feature(std_misc, os)]\n "}, {"sha": "64b3b092b89360f0cc033388becd05400a8ba4e8", "filename": "src/test/run-pass/issue-43132.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fissue-43132.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fissue-43132.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-43132.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+\n+fn main() {\n+}\n+\n+fn foo() {\n+    let b = mk::<\n+        Forward<(Box<Future<Error = u32>>,)>,\n+    >();\n+    b.map_err(|_| ()).join();\n+}\n+\n+fn mk<T>() -> T {\n+    loop {}\n+}\n+\n+impl<I: Future<Error = E>, E> Future for (I,) {\n+    type Error = E;\n+}\n+\n+struct Forward<T: Future> {\n+    _a: T,\n+}\n+\n+impl<T: Future> Future for Forward<T>\n+where\n+    T::Error: From<u32>,\n+{\n+    type Error = T::Error;\n+}\n+\n+trait Future {\n+    type Error;\n+\n+    fn map_err<F, E>(self, _: F) -> (Self, F)\n+    where\n+        F: FnOnce(Self::Error) -> E,\n+        Self: Sized,\n+    {\n+        loop {}\n+    }\n+\n+    fn join(self) -> (MaybeDone<Self>, ())\n+    where\n+        Self: Sized,\n+    {\n+        loop {}\n+    }\n+}\n+\n+impl<S: ?Sized + Future> Future for Box<S> {\n+    type Error = S::Error;\n+}\n+\n+enum MaybeDone<A: Future> {\n+    _Done(A::Error),\n+}\n+\n+impl<U, A: Future, F> Future for (A, F)\n+where\n+    F: FnOnce(A::Error) -> U,\n+{\n+    type Error = U;\n+}"}, {"sha": "550c6d6ab67025a8311ec582f590b05e2f01cc38", "filename": "src/test/run-pass/process-spawn-with-unicode-params.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-spawn-with-unicode-params.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -16,7 +16,6 @@\n // non-ASCII characters.  The child process ensures all the strings are\n // intact.\n \n-// ignore-aarch64\n // ignore-emscripten\n \n use std::io::prelude::*;"}, {"sha": "5aa4faa13656527803943c03f4ffa1544a9d8423", "filename": "src/test/run-pass/sigpipe-should-be-ignored.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsigpipe-should-be-ignored.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -11,7 +11,6 @@\n // Be sure that when a SIGPIPE would have been received that the entire process\n // doesn't die in a ball of fire, but rather it's gracefully handled.\n \n-// ignore-aarch64\n // ignore-emscripten\n \n use std::env;"}, {"sha": "c27f83011cb1b4c7f95498589e333a4851eea413", "filename": "src/test/run-pass/sse2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fsse2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Fsse2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsse2.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -7,6 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+// min-llvm-version 4.0\n \n #![feature(cfg_target_feature)]\n "}, {"sha": "de744520cc6beff198ccccb8c7009ea7903c657a", "filename": "src/test/run-pass/union/union-basic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Funion%2Funion-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Frun-pass%2Funion%2Funion-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-basic.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -12,6 +12,7 @@\n \n // FIXME: This test case makes little-endian assumptions.\n // ignore-s390x\n+// ignore-sparc\n \n extern crate union;\n use std::mem::{size_of, align_of, zeroed};"}, {"sha": "1d4ded6e7123a8dfb1e4465ee23d43518b0dcc8f", "filename": "src/test/ui/const-eval/issue-43197.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn)]\n+\n+const fn foo(x: u32) -> u32 {\n+    x\n+}\n+\n+fn main() {\n+    const X: u32 = 0-1;\n+    const Y: u32 = foo(0-1);\n+    println!(\"{} {}\", X, Y);\n+}"}, {"sha": "5ff80060eac7af476547f5ad47a14d344042321e", "filename": "src/test/ui/const-eval/issue-43197.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fissue-43197.stderr?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,28 @@\n+warning: constant evaluation error: attempt to subtract with overflow. This will become a HARD ERROR in the future\n+  --> $DIR/issue-43197.rs:18:20\n+   |\n+18 |     const X: u32 = 0-1;\n+   |                    ^^^\n+   |\n+   = note: #[warn(const_err)] on by default\n+\n+warning: constant evaluation error: attempt to subtract with overflow. This will become a HARD ERROR in the future\n+  --> $DIR/issue-43197.rs:19:20\n+   |\n+19 |     const Y: u32 = foo(0-1);\n+   |                    ^^^^^^^^\n+\n+error[E0080]: constant evaluation error\n+  --> $DIR/issue-43197.rs:18:20\n+   |\n+18 |     const X: u32 = 0-1;\n+   |                    ^^^ attempt to subtract with overflow\n+\n+error[E0080]: constant evaluation error\n+  --> $DIR/issue-43197.rs:19:24\n+   |\n+19 |     const Y: u32 = foo(0-1);\n+   |                        ^^^ attempt to subtract with overflow\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "20bb7d4c91de3ac7e8843e8bab643ddd47208072", "filename": "src/test/ui/did_you_mean/issue-36798_unknown_field.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-36798_unknown_field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-36798_unknown_field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-36798_unknown_field.stderr?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -3,6 +3,8 @@ error[E0609]: no field `zz` on type `Foo`\n    |\n 17 |     f.zz;\n    |       ^^ unknown field\n+   |\n+   = note: available fields are: `bar`\n \n error: aborting due to previous error\n "}, {"sha": "7fe9950801227f1d1509cbcfe976418f92c6808c", "filename": "src/test/ui/did_you_mean/issue-42599_available_fields_note.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod submodule {\n+\n+    #[derive(Default)]\n+    pub struct Demo {\n+        pub favorite_integer: isize,\n+        secret_integer: isize,\n+        pub innocently_misspellable: (),\n+        another_field: bool,\n+        yet_another_field: bool,\n+        always_more_fields: bool,\n+        and_ever: bool,\n+    }\n+\n+    impl Demo {\n+        fn new_with_secret_two() -> Self {\n+            Self { secret_integer: 2, inocently_mispellable: () }\n+        }\n+\n+        fn new_with_secret_three() -> Self {\n+            Self { secret_integer: 3, egregiously_nonexistent_field: () }\n+        }\n+    }\n+\n+}\n+\n+fn main() {\n+    use submodule::Demo;\n+\n+    let demo = Demo::default();\n+    let innocent_field_misaccess = demo.inocently_mispellable;\n+    // note shouldn't suggest private fields\n+    let egregious_field_misaccess = demo.egregiously_nonexistent_field;\n+}"}, {"sha": "e2bb7fbd9a895b1ee34b56c2275edd0dc554419a", "filename": "src/test/ui/did_you_mean/issue-42599_available_fields_note.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42599_available_fields_note.stderr?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,30 @@\n+error[E0560]: struct `submodule::Demo` has no field named `inocently_mispellable`\n+  --> $DIR/issue-42599_available_fields_note.rs:26:39\n+   |\n+26 |             Self { secret_integer: 2, inocently_mispellable: () }\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^ field does not exist - did you mean `innocently_misspellable`?\n+\n+error[E0560]: struct `submodule::Demo` has no field named `egregiously_nonexistent_field`\n+  --> $DIR/issue-42599_available_fields_note.rs:30:39\n+   |\n+30 |             Self { secret_integer: 3, egregiously_nonexistent_field: () }\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `submodule::Demo` does not have this field\n+   |\n+   = note: available fields are: `favorite_integer`, `secret_integer`, `innocently_misspellable`, `another_field`, `yet_another_field` ... and 2 others\n+\n+error[E0609]: no field `inocently_mispellable` on type `submodule::Demo`\n+  --> $DIR/issue-42599_available_fields_note.rs:40:41\n+   |\n+40 |     let innocent_field_misaccess = demo.inocently_mispellable;\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^ did you mean `innocently_misspellable`?\n+\n+error[E0609]: no field `egregiously_nonexistent_field` on type `submodule::Demo`\n+  --> $DIR/issue-42599_available_fields_note.rs:42:42\n+   |\n+42 |     let egregious_field_misaccess = demo.egregiously_nonexistent_field;\n+   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unknown field\n+   |\n+   = note: available fields are: `favorite_integer`, `innocently_misspellable`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "001c1f2eddca1e3ccbeabaf58450b6296547847c", "filename": "src/test/ui/issue-35675.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fissue-35675.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fissue-35675.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-35675.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -33,11 +33,27 @@ fn should_return_fruit_too() -> Fruit::Apple {\n     //~| NOTE not found in this scope\n }\n \n+fn foo() -> Ok {\n+    //~^ ERROR expected type, found variant `Ok`\n+    //~| NOTE not a type\n+    //~| HELP there is an enum variant\n+    //~| HELP there is an enum variant\n+    Ok(())\n+}\n+\n fn bar() -> Variant3 {\n     //~^ ERROR cannot find type `Variant3` in this scope\n     //~| NOTE not found in this scope\n }\n \n+fn qux() -> Some {\n+    //~^ ERROR expected type, found variant `Some`\n+    //~| NOTE not a type\n+    //~| HELP there is an enum variant\n+    //~| HELP there is an enum variant\n+    Some(1)\n+}\n+\n fn main() {}\n \n mod x {"}, {"sha": "ed330f47208ebfd1fdbf6125328989c158ad3724", "filename": "src/test/ui/issue-35675.stderr", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fissue-35675.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fissue-35675.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-35675.stderr?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -38,14 +38,32 @@ help: possible candidate is found in another module, you can import it into scop\n 12 | use Fruit::Apple;\n    |\n \n-error[E0412]: cannot find type `Variant3` in this scope\n+error[E0573]: expected type, found variant `Ok`\n   --> $DIR/issue-35675.rs:36:13\n    |\n-36 | fn bar() -> Variant3 {\n+36 | fn foo() -> Ok {\n+   |             ^^ not a type\n+   |\n+   = help: there is an enum variant `std::prelude::v1::Ok`, try using `std::prelude::v1`?\n+   = help: there is an enum variant `std::result::Result::Ok`, try using `std::result::Result`?\n+\n+error[E0412]: cannot find type `Variant3` in this scope\n+  --> $DIR/issue-35675.rs:44:13\n+   |\n+44 | fn bar() -> Variant3 {\n    |             ^^^^^^^^\n    |             |\n    |             not found in this scope\n    |             help: you can try using the variant's enum: `x::Enum`\n \n-error: aborting due to 5 previous errors\n+error[E0573]: expected type, found variant `Some`\n+  --> $DIR/issue-35675.rs:49:13\n+   |\n+49 | fn qux() -> Some {\n+   |             ^^^^ not a type\n+   |\n+   = help: there is an enum variant `std::prelude::v1::Option::Some`, try using `std::prelude::v1::Option`?\n+   = help: there is an enum variant `std::prelude::v1::Some`, try using `std::prelude::v1`?\n+\n+error: aborting due to 7 previous errors\n "}, {"sha": "169d7b55916706e45a43af982a9e64cca5785abd", "filename": "src/test/ui/issue-35976.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fissue-35976.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fissue-35976.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-35976.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod private {\n+    pub trait Future {\n+        fn wait(&self) where Self: Sized;\n+    }\n+\n+    impl Future for Box<Future> {\n+        fn wait(&self) { }\n+    }\n+}\n+\n+//use private::Future;\n+\n+fn bar(arg: Box<private::Future>) {\n+    arg.wait();\n+    //~^ ERROR the `wait` method cannot be invoked on a trait object\n+    //~| another candidate was found in the following trait, perhaps add a `use` for it:\n+}\n+\n+fn main() {\n+\n+}"}, {"sha": "9fb67449734bc6615ed592cd99f84d27c93d0d2a", "filename": "src/test/ui/issue-35976.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fissue-35976.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fissue-35976.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-35976.stderr?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,11 @@\n+error: the `wait` method cannot be invoked on a trait object\n+  --> $DIR/issue-35976.rs:24:9\n+   |\n+24 |     arg.wait();\n+   |         ^^^^\n+   |\n+   = note: another candidate was found in the following trait, perhaps add a `use` for it:\n+           candidate #1: `use private::Future;`\n+\n+error: aborting due to previous error\n+"}, {"sha": "4c878f3c0dc03f40013e02a81d05c66e17bb6b91", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-2.stderr?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -2,9 +2,9 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ex3-both-anon-regions-2.rs:12:9\n    |\n 11 | fn foo((v, w): (&u8, &u8), x: &u8) {\n-   |                 ---           --- these references must have the same lifetime\n+   |                 ---           --- these references are not declared with the same lifetime...\n 12 |     v = x;\n-   |         ^ data from `x` flows here\n+   |         ^ ...but data from `x` flows here\n \n error: aborting due to previous error\n "}, {"sha": "08506b8befa03ac387c9d674d7b4fe58e59d0f6d", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.stderr?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -2,9 +2,9 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ex3-both-anon-regions-3.rs:12:9\n    |\n 11 | fn foo((v, w): (&u8, &u8), (x, y): (&u8, &u8)) {\n-   |                 ---                 --- these references must have the same lifetime\n+   |                 ---                 --- these references are not declared with the same lifetime...\n 12 |     v = x;\n-   |         ^ data flows here\n+   |         ^ ...but data flows here\n \n error: aborting due to previous error\n "}, {"sha": "9c2630fc811439ea0a07cea2933b54703bd5de0a", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-4.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-4.stderr?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -4,17 +4,17 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ex3-both-anon-regions-4.rs:12:13\n    |\n 11 | fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n-   |                     ---                 --- these references must have the same lifetime\n+   |                     ---                 --- these references are not declared with the same lifetime...\n 12 |     z.push((x,y));\n-   |             ^ data flows into `z` here\n+   |             ^ ...but data flows into `z` here\n \n error[E0623]: lifetime mismatch\n   --> $DIR/ex3-both-anon-regions-4.rs:12:15\n    |\n 11 | fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n-   |                         ---                  --- these references must have the same lifetime\n+   |                         ---                  --- these references are not declared with the same lifetime...\n 12 |     z.push((x,y));\n-   |               ^ data flows into `z` here\n+   |               ^ ...but data flows into `z` here\n \n error: aborting due to 3 previous errors\n "}, {"sha": "a183d1fffc0b68ea13c05db03b0aa7a80ba43390", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.stderr?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -2,9 +2,9 @@ error[E0623]: lifetime mismatch\n   --> $DIR/ex3-both-anon-regions.rs:12:12\n    |\n 11 | fn foo(x: &mut Vec<&u8>, y: &u8) {\n-   |                    ---      --- these references must have the same lifetime\n+   |                    ---      --- these references are not declared with the same lifetime...\n 12 |     x.push(y);\n-   |            ^ data from `y` flows into `x` here\n+   |            ^ ...but data from `y` flows into `x` here\n \n error: aborting due to previous error\n "}, {"sha": "1598a8a40d2f0b8bfd30b1f42629ee6e4c23e1c1", "filename": "src/test/ui/regions-fn-subtyping-return-static.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static.stderr?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -6,8 +6,6 @@ error[E0308]: mismatched types\n    |\n    = note: expected type `fn(&'cx S) -> &'cx S`\n               found type `fn(&'a S) -> &S {bar::<'_>}`\n-   = note: lifetime parameter `'b` declared on fn `bar` appears only in the return type, but here is required to be higher-ranked, which means that `'b` must appear in both argument and return types\n-   = note: this error is the result of a recent bug fix; for more information, see issue #33685 <https://github.com/rust-lang/rust/issues/33685>\n \n error: aborting due to previous error\n "}, {"sha": "021f57e3eee0aa690218bdc4fa636a580e4a5d62", "filename": "src/test/ui/union-fields.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Funion-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Funion-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-fields.rs?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![deny(dead_code)]\n+\n+union U1 {\n+    a: u8, // should not be reported\n+    b: u8, // should not be reported\n+    c: u8, // should be reported\n+}\n+union U2 {\n+    a: u8, // should be reported\n+    b: u8, // should not be reported\n+    c: u8, // should not be reported\n+}\n+union NoDropLike { a: u8 } // should be reported as unused\n+\n+union U {\n+    a: u8, // should not be reported\n+    b: u8, // should not be reported\n+    c: u8, // should be reported\n+}\n+type A = U;\n+\n+fn main() {\n+    let u = U1 { a: 0 };\n+    let _a = unsafe { u.b };\n+\n+    let u = U2 { c: 0 };\n+    let _b = unsafe { u.b };\n+\n+    let _u = NoDropLike { a: 10 };\n+    let u = A { a: 0 };\n+    let _b = unsafe { u.b };\n+}"}, {"sha": "f3a2702d5aefa2266d5333e5069687b1578defe0", "filename": "src/test/ui/union-fields.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Funion-fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5/src%2Ftest%2Fui%2Funion-fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-fields.stderr?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -0,0 +1,32 @@\n+error: field is never used: `c`\n+  --> $DIR/union-fields.rs:16:5\n+   |\n+16 |     c: u8, // should be reported\n+   |     ^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/union-fields.rs:11:9\n+   |\n+11 | #![deny(dead_code)]\n+   |         ^^^^^^^^^\n+\n+error: field is never used: `a`\n+  --> $DIR/union-fields.rs:19:5\n+   |\n+19 |     a: u8, // should be reported\n+   |     ^^^^^\n+\n+error: field is never used: `a`\n+  --> $DIR/union-fields.rs:23:20\n+   |\n+23 | union NoDropLike { a: u8 } // should be reported as unused\n+   |                    ^^^^^\n+\n+error: field is never used: `c`\n+  --> $DIR/union-fields.rs:28:5\n+   |\n+28 |     c: u8, // should be reported\n+   |     ^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "305bc25d5e105e84ffe261655b46cf74570f6e5b", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1 +1 @@\n-Subproject commit 88aa6423a164774d09abc78a24e74e8e665f651b\n+Subproject commit 305bc25d5e105e84ffe261655b46cf74570f6e5b"}, {"sha": "5d4bbd9052fe2af849a7d017b85df98ad002c20f", "filename": "src/tools/rls", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frls?ref=c25ddf21f18c3eeeaea2a4dffd70d2f6183068b5", "patch": "@@ -1 +1 @@\n-Subproject commit 79d659e5699fbf7db5b4819e9a442fb3f550472a\n+Subproject commit 5d4bbd9052fe2af849a7d017b85df98ad002c20f"}]}