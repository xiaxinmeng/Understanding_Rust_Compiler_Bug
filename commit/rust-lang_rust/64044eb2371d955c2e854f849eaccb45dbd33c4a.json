{"sha": "64044eb2371d955c2e854f849eaccb45dbd33c4a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0MDQ0ZWIyMzcxZDk1NWMyZTg1NGY4NDllYWNjYjQ1ZGJkMzNjNGE=", "commit": {"author": {"name": "hyd-dev", "email": "yd-huang@outlook.com", "date": "2021-05-24T16:08:26Z"}, "committer": {"name": "hyd-dev", "email": "yd-huang@outlook.com", "date": "2021-05-24T19:42:25Z"}, "message": "Check whether unwinding is allowed before popping the stack frame", "tree": {"sha": "408f6b6103ec5a0debe272213e3c315b3a1a43f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/408f6b6103ec5a0debe272213e3c315b3a1a43f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64044eb2371d955c2e854f849eaccb45dbd33c4a", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niIsEABYIADMWIQRJ2jPMDdiQ+U4U42Z0+n/VuNoUuAUCYKwBoRUceWQtaHVhbmdA\nb3V0bG9vay5jb20ACgkQdPp/1bjaFLiKfgEAxIVUHl1yYpwkgFw5s0KnXc6yfsUs\nfKG5JONuhjyjmxkBANVXjiIxUotTxHJrQwtXX0kcDqbrAtQzo1p5Smw/F2sJ\n=NtE8\n-----END PGP SIGNATURE-----", "payload": "tree 408f6b6103ec5a0debe272213e3c315b3a1a43f2\nparent ac39f365266fcbfaf8d1fb31ac59feba60950e92\nauthor hyd-dev <yd-huang@outlook.com> 1621872506 +0800\ncommitter hyd-dev <yd-huang@outlook.com> 1621885345 +0800\n\nCheck whether unwinding is allowed before popping the stack frame\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64044eb2371d955c2e854f849eaccb45dbd33c4a", "html_url": "https://github.com/rust-lang/rust/commit/64044eb2371d955c2e854f849eaccb45dbd33c4a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64044eb2371d955c2e854f849eaccb45dbd33c4a/comments", "author": null, "committer": null, "parents": [{"sha": "ac39f365266fcbfaf8d1fb31ac59feba60950e92", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac39f365266fcbfaf8d1fb31ac59feba60950e92", "html_url": "https://github.com/rust-lang/rust/commit/ac39f365266fcbfaf8d1fb31ac59feba60950e92"}], "stats": {"total": 31, "additions": 15, "deletions": 16}, "files": [{"sha": "bb894e5ce0bd03736113aed43cf5ff693fffed8b", "filename": "compiler/rustc_mir/src/interpret/eval_context.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/64044eb2371d955c2e854f849eaccb45dbd33c4a/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64044eb2371d955c2e854f849eaccb45dbd33c4a/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Feval_context.rs?ref=64044eb2371d955c2e854f849eaccb45dbd33c4a", "patch": "@@ -798,26 +798,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             throw_ub_format!(\"unwinding past the topmost frame of the stack\");\n         }\n \n-        let frame =\n-            self.stack_mut().pop().expect(\"tried to pop a stack frame, but there were none\");\n-\n-        if !unwinding {\n-            // Copy the return value to the caller's stack frame.\n-            if let Some(ref return_place) = frame.return_place {\n-                let op = self.access_local(&frame, mir::RETURN_PLACE, None)?;\n-                self.copy_op_transmute(&op, return_place)?;\n-                trace!(\"{:?}\", self.dump_place(**return_place));\n-            } else {\n-                throw_ub!(Unreachable);\n-            }\n-        }\n-\n-        // Now where do we jump next?\n+        // Where do we jump next?\n \n         // Usually we want to clean up (deallocate locals), but in a few rare cases we don't.\n         // In that case, we return early. We also avoid validation in that case,\n         // because this is CTFE and the final value will be thoroughly validated anyway.\n-        let (cleanup, next_block) = match (frame.return_to_block, unwinding) {\n+        let (cleanup, next_block) = match (self.frame().return_to_block, unwinding) {\n             (StackPopCleanup::Goto { ret, .. }, false) => (true, Some(ret)),\n             (StackPopCleanup::Goto { unwind, .. }, true) => (\n                 true,\n@@ -832,6 +818,19 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             (StackPopCleanup::None { cleanup, .. }, _) => (cleanup, None),\n         };\n \n+        let frame = self.stack_mut().pop().unwrap();\n+\n+        if !unwinding {\n+            // Copy the return value to the caller's stack frame.\n+            if let Some(ref return_place) = frame.return_place {\n+                let op = self.access_local(&frame, mir::RETURN_PLACE, None)?;\n+                self.copy_op_transmute(&op, return_place)?;\n+                trace!(\"{:?}\", self.dump_place(**return_place));\n+            } else {\n+                throw_ub!(Unreachable);\n+            }\n+        }\n+\n         if !cleanup {\n             assert!(self.stack().is_empty(), \"only the topmost frame should ever be leaked\");\n             assert!(next_block.is_none(), \"tried to skip cleanup when we have a next block!\");"}]}