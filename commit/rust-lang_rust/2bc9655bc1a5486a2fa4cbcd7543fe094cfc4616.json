{"sha": "2bc9655bc1a5486a2fa4cbcd7543fe094cfc4616", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiYzk2NTViYzFhNTQ4NmEyZmE0Y2JjZDc1NDNmZTA5NGNmYzQ2MTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-07T23:20:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-07T23:20:16Z"}, "message": "auto merge of #4803 : alexcrichton/rust/fix-unused-imports, r=graydon\n\nThe first commit message has most of the comments, but this pull request basically fixes a lot of issues surrounding the `unused_imports` warning/deny attribute.\r\n\r\nBefore this patch there were these problems:\r\n\r\n1. Unused imports from `prelude.rs` were warned about with dummy spans, leading to a large number of confusing warnings.\r\n2. Unused imports from `intrinsic.rs` were warned about with the file `<intrinsic>` which couldn't be forced to go away\r\n3. Methods used from imported traites (like `io::WriterUtil`) resulted in an unused warning of the import even though it was used.\r\n4. If one `use` statement imported N modules, M of which weren't used, M warning statements were issued.\r\n5. If a glob import statement was used, each public export of the target module which wasn't used had a warning issued.\r\n\r\nThis patch deals with all these cases by doing:\r\n\r\n1. Ignore unused imports from `prelude.rs` (indicated by a dummy span of 0)\r\n2. Ignore unused imports from `intrinsic.rs` (test on the imported module name, is there a better way?)\r\n3. Track when imported modules are used as candidates for methods, and just assume they're used. This may not end up being the actual case, but in theory not warning about an unused thing is worse than warning about a used thing.\r\n4. Only issue one warning statement\r\n5. Only issue one warning statement.\r\n\r\nThis is the first time I've edited the compiler itself, and I tried to keep up with the style around, but I may have missed something here or there...", "tree": {"sha": "01a9fc787f5cc25cfa8196a32cb7a9c91bbe93f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01a9fc787f5cc25cfa8196a32cb7a9c91bbe93f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2bc9655bc1a5486a2fa4cbcd7543fe094cfc4616", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2bc9655bc1a5486a2fa4cbcd7543fe094cfc4616", "html_url": "https://github.com/rust-lang/rust/commit/2bc9655bc1a5486a2fa4cbcd7543fe094cfc4616", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2bc9655bc1a5486a2fa4cbcd7543fe094cfc4616/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42727658304b04babff6dd384637398c17331bbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/42727658304b04babff6dd384637398c17331bbe", "html_url": "https://github.com/rust-lang/rust/commit/42727658304b04babff6dd384637398c17331bbe"}, {"sha": "b368cb234126d1ada88ad5214102c68898eeffc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b368cb234126d1ada88ad5214102c68898eeffc7", "html_url": "https://github.com/rust-lang/rust/commit/b368cb234126d1ada88ad5214102c68898eeffc7"}], "stats": {"total": 110, "additions": 82, "deletions": 28}, "files": [{"sha": "e332a71b57c864859da65c1575df8ab5d61de7bf", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 58, "deletions": 20, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/2bc9655bc1a5486a2fa4cbcd7543fe094cfc4616/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bc9655bc1a5486a2fa4cbcd7543fe094cfc4616/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=2bc9655bc1a5486a2fa4cbcd7543fe094cfc4616", "patch": "@@ -392,17 +392,19 @@ pub struct ImportResolution {\n     /// The type that this `use` directive names, if there is one.\n     mut type_target: Option<Target>,\n \n-    mut used: bool,\n+    /// There exists one state per import statement\n+    state: @mut ImportState,\n }\n \n-pub fn ImportResolution(privacy: Privacy, span: span) -> ImportResolution {\n+pub fn ImportResolution(privacy: Privacy, span: span,\n+                        state: @mut ImportState) -> ImportResolution {\n     ImportResolution {\n         privacy: privacy,\n         span: span,\n         outstanding_references: 0,\n         value_target: None,\n         type_target: None,\n-        used: false\n+        state: state,\n     }\n }\n \n@@ -415,6 +417,15 @@ pub impl ImportResolution {\n     }\n }\n \n+pub struct ImportState {\n+    used: bool,\n+    warned: bool\n+}\n+\n+pub fn ImportState() -> ImportState {\n+    ImportState{ used: false, warned: false }\n+}\n+\n /// The link from a module up to its nearest parent node.\n pub enum ParentLink {\n     NoParentLink,\n@@ -1415,6 +1426,7 @@ pub impl Resolver {\n \n                     // Build up the import directives.\n                     let module_ = self.get_module_from_parent(parent);\n+                    let state = @mut ImportState();\n                     match view_path.node {\n                         view_path_simple(binding, full_path, ns, _) => {\n                             let ns = match ns {\n@@ -1430,7 +1442,8 @@ pub impl Resolver {\n                                                         module_,\n                                                         module_path,\n                                                         subclass,\n-                                                        view_path.span);\n+                                                        view_path.span,\n+                                                        state);\n                         }\n                         view_path_list(_, ref source_idents, _) => {\n                             for (*source_idents).each |source_ident| {\n@@ -1442,15 +1455,17 @@ pub impl Resolver {\n                                                             module_,\n                                                             module_path,\n                                                             subclass,\n-                                                            view_path.span);\n+                                                            view_path.span,\n+                                                            state);\n                             }\n                         }\n                         view_path_glob(_, _) => {\n                             self.build_import_directive(privacy,\n                                                         module_,\n                                                         module_path,\n                                                         @GlobImport,\n-                                                        view_path.span);\n+                                                        view_path.span,\n+                                                        state);\n                         }\n                     }\n                 }\n@@ -1573,7 +1588,8 @@ pub impl Resolver {\n                     // avoid creating cycles in the\n                     // module graph.\n \n-                    let resolution = @ImportResolution(Public, dummy_sp());\n+                    let resolution = @ImportResolution(Public, dummy_sp(),\n+                                                       @mut ImportState());\n                     resolution.outstanding_references = 0;\n \n                     match existing_module.parent_link {\n@@ -1826,7 +1842,8 @@ pub impl Resolver {\n                               module_: @Module,\n                               module_path: @DVec<ident>,\n                               subclass: @ImportDirectiveSubclass,\n-                              span: span) {\n+                              span: span,\n+                              state: @mut ImportState) {\n         let directive = @ImportDirective(privacy, module_path,\n                                          subclass, span);\n         module_.imports.push(directive);\n@@ -1850,7 +1867,14 @@ pub impl Resolver {\n                     }\n                     None => {\n                         debug!(\"(building import directive) creating new\");\n-                        let resolution = @ImportResolution(privacy, span);\n+                        let resolution = @ImportResolution(privacy, span,\n+                                                           state);\n+                        let name = self.idents_to_str(module_path.get());\n+                        // Don't warn about unused intrinsics because they're\n+                        // automatically appended to all files\n+                        if name == ~\"intrinsic::rusti\" {\n+                            resolution.state.warned = true;\n+                        }\n                         resolution.outstanding_references = 1;\n                         module_.import_resolutions.insert(target, resolution);\n                     }\n@@ -2183,7 +2207,7 @@ pub impl Resolver {\n                                     return UnboundResult;\n                                 }\n                                 Some(target) => {\n-                                    import_resolution.used = true;\n+                                    import_resolution.state.used = true;\n                                     return BoundResult(target.target_module,\n                                                     target.bindings);\n                                 }\n@@ -2352,7 +2376,7 @@ pub impl Resolver {\n                                     module_result = UnboundResult;\n                                 }\n                                 Some(target) => {\n-                                    import_resolution.used = true;\n+                                    import_resolution.state.used = true;\n                                     module_result = BoundResult\n                                         (target.target_module,\n                                          target.bindings);\n@@ -2419,6 +2443,7 @@ pub impl Resolver {\n         // everything it can to the list of import resolutions of the module\n         // node.\n         debug!(\"(resolving glob import) resolving %? glob import\", privacy);\n+        let state = @mut ImportState();\n \n         // We must bail out if the node has unresolved imports of any kind\n         // (including globs).\n@@ -2445,7 +2470,8 @@ pub impl Resolver {\n                     // Simple: just copy the old import resolution.\n                     let new_import_resolution =\n                         @ImportResolution(privacy,\n-                                          target_import_resolution.span);\n+                                          target_import_resolution.span,\n+                                          state);\n                     new_import_resolution.value_target =\n                         copy target_import_resolution.value_target;\n                     new_import_resolution.type_target =\n@@ -2486,7 +2512,8 @@ pub impl Resolver {\n             match module_.import_resolutions.find(&ident) {\n                 None => {\n                     // Create a new import resolution from this child.\n-                    dest_import_resolution = @ImportResolution(privacy, span);\n+                    dest_import_resolution = @ImportResolution(privacy, span,\n+                                                               state);\n                     module_.import_resolutions.insert\n                         (ident, dest_import_resolution);\n                 }\n@@ -2713,7 +2740,7 @@ pub impl Resolver {\n                                namespace);\n                     }\n                     Some(target) => {\n-                        import_resolution.used = true;\n+                        import_resolution.state.used = true;\n                         return Success(copy target);\n                     }\n                 }\n@@ -2962,7 +2989,7 @@ pub impl Resolver {\n                     Some(target) => {\n                         debug!(\"(resolving name in module) resolved to \\\n                                 import\");\n-                        import_resolution.used = true;\n+                        import_resolution.state.used = true;\n                         return Success(copy target);\n                     }\n                 }\n@@ -4560,7 +4587,7 @@ pub impl Resolver {\n                                     namespace)) {\n                             (Some(def), Some(Public)) => {\n                                 // Found it.\n-                                import_resolution.used = true;\n+                                import_resolution.state.used = true;\n                                 return ImportNameDefinition(def);\n                             }\n                             (Some(_), _) | (None, _) => {\n@@ -5034,9 +5061,13 @@ pub impl Resolver {\n                             Some(def) => {\n                                 match def {\n                                     def_ty(trait_def_id) => {\n-                                        self.\n+                                        let added = self.\n                                         add_trait_info_if_containing_method(\n                                         found_traits, trait_def_id, name);\n+                                        if added {\n+                                            import_resolution.state.used =\n+                                                true;\n+                                        }\n                                     }\n                                     _ => {\n                                         // Continue.\n@@ -5069,7 +5100,7 @@ pub impl Resolver {\n \n     fn add_trait_info_if_containing_method(found_traits: @DVec<def_id>,\n                                            trait_def_id: def_id,\n-                                           name: ident) {\n+                                           name: ident) -> bool {\n \n         debug!(\"(adding trait info if containing method) trying trait %d:%d \\\n                 for method '%s'\",\n@@ -5085,9 +5116,10 @@ pub impl Resolver {\n                        trait_def_id.node,\n                        self.session.str_of(name));\n                 (*found_traits).push(trait_def_id);\n+                true\n             }\n             Some(_) | None => {\n-                // Continue.\n+                false\n             }\n         }\n     }\n@@ -5204,7 +5236,13 @@ pub impl Resolver {\n \n     fn check_for_unused_imports_in_module(module_: @Module) {\n         for module_.import_resolutions.each_value_ref |&import_resolution| {\n-            if !import_resolution.used {\n+            // Ignore dummy spans for things like automatically injected\n+            // imports for the prelude, and also don't warn about the same\n+            // import statement being unused more than once.\n+            if !import_resolution.state.used &&\n+                    !import_resolution.state.warned &&\n+                    import_resolution.span != dummy_sp() {\n+                import_resolution.state.warned = true;\n                 match self.unused_import_lint_level {\n                     warn => {\n                         self.session.span_warn(import_resolution.span,"}, {"sha": "6dcdb413f88a2308846175560bcf07bfc64c9d82", "filename": "src/test/compile-fail/unused-imports-warn.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2bc9655bc1a5486a2fa4cbcd7543fe094cfc4616/src%2Ftest%2Fcompile-fail%2Funused-imports-warn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2bc9655bc1a5486a2fa4cbcd7543fe094cfc4616/src%2Ftest%2Fcompile-fail%2Funused-imports-warn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-imports-warn.rs?ref=2bc9655bc1a5486a2fa4cbcd7543fe094cfc4616", "patch": "@@ -8,23 +8,39 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:unused import\n-// compile-flags:-W unused-imports\n+// compile-flags: -D unused-imports\n+\n use cal = bar::c::cc;\n \n+use core::either::Right;        //~ ERROR unused import\n+\n+use core::util::*;              // shouldn't get errors for not using\n+                                // everything imported\n+\n+// Should only get one error instead of two errors here\n+use core::option::{Some, None}; //~ ERROR unused import\n+\n+use core::io::ReaderUtil;       //~ ERROR unused import\n+// Be sure that if we just bring some methods into scope that they're also\n+// counted as being used.\n+use core::io::WriterUtil;\n+\n mod foo {\n-    pub type point = {x: int, y: int};\n-    pub type square = {p: point, h: uint, w: uint};\n+    pub struct Point{x: int, y: int}\n+    pub struct Square{p: Point, h: uint, w: uint}\n }\n \n mod bar {\n     pub mod c {\n-        use foo::point;\n-        use foo::square;\n-        pub fn cc(p: point) -> str { return 2 * (p.x + p.y); }\n+        use foo::Point;\n+        use foo::Square; //~ ERROR unused import\n+        pub fn cc(p: Point) -> int { return 2 * (p.x + p.y); }\n     }\n }\n \n fn main() {\n-    cal({x:3, y:9});\n+    cal(foo::Point{x:3, y:9});\n+    let a = 3;\n+    ignore(a);\n+    io::stdout().write_str(~\"a\");\n }"}]}