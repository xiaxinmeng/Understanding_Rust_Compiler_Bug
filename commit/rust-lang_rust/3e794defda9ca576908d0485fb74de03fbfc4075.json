{"sha": "3e794defda9ca576908d0485fb74de03fbfc4075", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlNzk0ZGVmZGE5Y2E1NzY5MDhkMDQ4NWZiNzRkZTAzZmJmYzQwNzU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-21T20:21:03Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-21T20:21:03Z"}, "message": "Rollup merge of #22592 - nikomatsakis:deprecate-bracket-bracket, r=aturon\n\n r? @aturon", "tree": {"sha": "255706f90a015d6656ae745fcf0f4efc504e50de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/255706f90a015d6656ae745fcf0f4efc504e50de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e794defda9ca576908d0485fb74de03fbfc4075", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e794defda9ca576908d0485fb74de03fbfc4075", "html_url": "https://github.com/rust-lang/rust/commit/3e794defda9ca576908d0485fb74de03fbfc4075", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e794defda9ca576908d0485fb74de03fbfc4075/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98ec45ee0b5f38f06b4ac5adfb9aff198f157bdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/98ec45ee0b5f38f06b4ac5adfb9aff198f157bdd", "html_url": "https://github.com/rust-lang/rust/commit/98ec45ee0b5f38f06b4ac5adfb9aff198f157bdd"}, {"sha": "68e5bb3f2caa34753edb7f921c0bcf1efd63cf88", "url": "https://api.github.com/repos/rust-lang/rust/commits/68e5bb3f2caa34753edb7f921c0bcf1efd63cf88", "html_url": "https://github.com/rust-lang/rust/commit/68e5bb3f2caa34753edb7f921c0bcf1efd63cf88"}], "stats": {"total": 1464, "additions": 732, "deletions": 732}, "files": [{"sha": "4e329897e1ab21958e6dd520aabdaea04b3b34ff", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -784,7 +784,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // wrapped description\n-        row.push_str(&desc_rows.connect(&desc_sep[..])[]);\n+        row.push_str(&desc_rows.connect(&desc_sep[..]));\n \n         row\n     });"}, {"sha": "1db993fdafd271cfc3c921bd9f2e203ed1a6fe0a", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -588,7 +588,7 @@ impl LintPass for RawPointerDerive {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        if !attr::contains_name(&item.attrs[], \"automatically_derived\") {\n+        if !attr::contains_name(&item.attrs, \"automatically_derived\") {\n             return\n         }\n         let did = match item.node {\n@@ -652,7 +652,7 @@ impl LintPass for UnusedAttributes {\n \n         if !attr::is_used(attr) {\n             cx.span_lint(UNUSED_ATTRIBUTES, attr.span, \"unused attribute\");\n-            if KNOWN_ATTRIBUTES.contains(&(&attr.name()[], AttributeType::CrateLevel)) {\n+            if KNOWN_ATTRIBUTES.contains(&(&attr.name(), AttributeType::CrateLevel)) {\n                 let msg = match attr.node.style {\n                     ast::AttrOuter => \"crate-level attribute should be an inner \\\n                                        attribute: add an exclamation mark: #![foo]\",\n@@ -732,7 +732,7 @@ impl LintPass for UnusedResults {\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {\n                     if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n-                        warned |= check_must_use(cx, &it.attrs[], s.span);\n+                        warned |= check_must_use(cx, &it.attrs, s.span);\n                     }\n                 } else {\n                     let attrs = csearch::get_item_attrs(&cx.sess().cstore, did);\n@@ -1093,7 +1093,7 @@ impl UnusedParens {\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n                              &format!(\"unnecessary parentheses around {}\",\n-                                     msg)[])\n+                                     msg))\n             }\n         }\n \n@@ -1235,7 +1235,7 @@ impl LintPass for NonShorthandFieldPatterns {\n                     if ident.node.as_str() == fieldpat.node.ident.as_str() {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n                                      &format!(\"the `{}:` in this pattern is redundant and can \\\n-                                              be removed\", ident.node.as_str())[])\n+                                              be removed\", ident.node.as_str()))\n                     }\n                 }\n             }\n@@ -1383,7 +1383,7 @@ impl LintPass for UnusedMut {\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         if let ast::ExprMatch(_, ref arms, _) = e.node {\n             for a in arms {\n-                self.check_unused_mut_pat(cx, &a.pats[])\n+                self.check_unused_mut_pat(cx, &a.pats)\n             }\n         }\n     }\n@@ -1504,7 +1504,7 @@ impl MissingDoc {\n         });\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS, sp,\n-                &format!(\"missing documentation for {}\", desc)[]);\n+                &format!(\"missing documentation for {}\", desc));\n         }\n     }\n }\n@@ -1540,7 +1540,7 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n-        self.check_missing_docs_attrs(cx, None, &krate.attrs[],\n+        self.check_missing_docs_attrs(cx, None, &krate.attrs,\n                                      krate.span, \"crate\");\n     }\n \n@@ -1554,7 +1554,7 @@ impl LintPass for MissingDoc {\n             ast::ItemTy(..) => \"a type alias\",\n             _ => return\n         };\n-        self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs[],\n+        self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs,\n                                      it.span, desc);\n     }\n \n@@ -1567,13 +1567,13 @@ impl LintPass for MissingDoc {\n \n             // Otherwise, doc according to privacy. This will also check\n             // doc for default methods defined on traits.\n-            self.check_missing_docs_attrs(cx, Some(m.id), &m.attrs[],\n+            self.check_missing_docs_attrs(cx, Some(m.id), &m.attrs,\n                                           m.span, \"a method\");\n         }\n     }\n \n     fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n-        self.check_missing_docs_attrs(cx, Some(tm.id), &tm.attrs[],\n+        self.check_missing_docs_attrs(cx, Some(tm.id), &tm.attrs,\n                                      tm.span, \"a type method\");\n     }\n \n@@ -1583,14 +1583,14 @@ impl LintPass for MissingDoc {\n                 let cur_struct_def = *self.struct_def_stack.last()\n                     .expect(\"empty struct_def_stack\");\n                 self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n-                                              &sf.node.attrs[], sf.span,\n+                                              &sf.node.attrs, sf.span,\n                                               \"a struct field\")\n             }\n         }\n     }\n \n     fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs[],\n+        self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs,\n                                      v.span, \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;"}, {"sha": "d344ee8c881c5ab4fa796f64f80f9ae2264ffcb2", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -105,7 +105,7 @@ impl LintStore {\n     }\n \n     pub fn get_lints<'t>(&'t self) -> &'t [(&'static Lint, bool)] {\n-        &self.lints[]\n+        &self.lints\n     }\n \n     pub fn get_lint_groups<'t>(&'t self) -> Vec<(&'static str, Vec<LintId>, bool)> {\n@@ -276,7 +276,7 @@ impl LintStore {\n                              .collect::<Vec<()>>();\n                         }\n                         None => sess.err(&format!(\"unknown {} flag: {}\",\n-                                                 level.as_str(), lint_name)[]),\n+                                                 level.as_str(), lint_name)),\n                     }\n                 }\n             }\n@@ -527,7 +527,7 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                     self.tcx.sess.span_err(span,\n                                            &format!(\"{}({}) overruled by outer forbid({})\",\n                                                    level.as_str(), lint_name,\n-                                                   lint_name)[]);\n+                                                   lint_name));\n                 } else if now != level {\n                     let src = self.lints.get_level_source(lint_id).1;\n                     self.level_stack.push((lint_id, (now, src)));\n@@ -562,15 +562,15 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     fn visit_item(&mut self, it: &ast::Item) {\n-        self.with_lint_attrs(&it.attrs[], |cx| {\n+        self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, it);\n             cx.visit_ids(|v| v.visit_item(it));\n             visit::walk_item(cx, it);\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &ast::ForeignItem) {\n-        self.with_lint_attrs(&it.attrs[], |cx| {\n+        self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_foreign_item, it);\n             visit::walk_foreign_item(cx, it);\n         })\n@@ -595,7 +595,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n                 body: &'v ast::Block, span: Span, id: ast::NodeId) {\n         match fk {\n             visit::FkMethod(_, _, m) => {\n-                self.with_lint_attrs(&m.attrs[], |cx| {\n+                self.with_lint_attrs(&m.attrs, |cx| {\n                     run_lints!(cx, check_fn, fk, decl, body, span, id);\n                     cx.visit_ids(|v| {\n                         v.visit_fn(fk, decl, body, span, id);\n@@ -611,7 +611,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_ty_method(&mut self, t: &ast::TypeMethod) {\n-        self.with_lint_attrs(&t.attrs[], |cx| {\n+        self.with_lint_attrs(&t.attrs, |cx| {\n             run_lints!(cx, check_ty_method, t);\n             visit::walk_ty_method(cx, t);\n         })\n@@ -628,14 +628,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_struct_field(&mut self, s: &ast::StructField) {\n-        self.with_lint_attrs(&s.node.attrs[], |cx| {\n+        self.with_lint_attrs(&s.node.attrs, |cx| {\n             run_lints!(cx, check_struct_field, s);\n             visit::walk_struct_field(cx, s);\n         })\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n-        self.with_lint_attrs(&v.node.attrs[], |cx| {\n+        self.with_lint_attrs(&v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, v, g);\n             visit::walk_variant(cx, v, g);\n             run_lints!(cx, check_variant_post, v, g);\n@@ -779,7 +779,7 @@ pub fn check_crate(tcx: &ty::ctxt,\n     let mut cx = Context::new(tcx, krate, exported_items);\n \n     // Visit the whole crate.\n-    cx.with_lint_attrs(&krate.attrs[], |cx| {\n+    cx.with_lint_attrs(&krate.attrs, |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             v.visited_outermost = true;"}, {"sha": "4c123b55e8e5034f51b8ec7d5af440fd953d112c", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -61,7 +61,7 @@ fn dump_crates(cstore: &CStore) {\n }\n \n fn should_link(i: &ast::Item) -> bool {\n-    !attr::contains_name(&i.attrs[], \"no_link\")\n+    !attr::contains_name(&i.attrs, \"no_link\")\n }\n \n struct CrateInfo {\n@@ -85,7 +85,7 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     for c in s.chars() {\n         if c.is_alphanumeric() { continue }\n         if c == '_' || c == '-' { continue }\n-        err(&format!(\"invalid character `{}` in crate name: `{}`\", c, s)[]);\n+        err(&format!(\"invalid character `{}` in crate name: `{}`\", c, s));\n     }\n     match sess {\n         Some(sess) => sess.abort_if_errors(),\n@@ -210,8 +210,8 @@ impl<'a> CrateReader<'a> {\n                 match self.extract_crate_info(i) {\n                     Some(info) => {\n                         let (cnum, _, _) = self.resolve_crate(&None,\n-                                                              &info.ident[],\n-                                                              &info.name[],\n+                                                              &info.ident,\n+                                                              &info.name,\n                                                               None,\n                                                               i.span,\n                                                               PathKind::Crate);\n@@ -268,7 +268,7 @@ impl<'a> CrateReader<'a> {\n                                     } else {\n                                         self.sess.span_err(m.span,\n                                             &format!(\"unknown kind: `{}`\",\n-                                                    k)[]);\n+                                                    k));\n                                         cstore::NativeUnknown\n                                     }\n                                 }\n@@ -413,7 +413,7 @@ impl<'a> CrateReader<'a> {\n                     hash: hash.map(|a| &*a),\n                     filesearch: self.sess.target_filesearch(kind),\n                     target: &self.sess.target.target,\n-                    triple: &self.sess.opts.target_triple[],\n+                    triple: &self.sess.opts.target_triple,\n                     root: root,\n                     rejected_via_hash: vec!(),\n                     rejected_via_triple: vec!(),\n@@ -440,8 +440,8 @@ impl<'a> CrateReader<'a> {\n         decoder::get_crate_deps(cdata).iter().map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, _, _) = self.resolve_crate(root,\n-                                                   &dep.name[],\n-                                                   &dep.name[],\n+                                                   &dep.name,\n+                                                   &dep.name,\n                                                    Some(&dep.hash),\n                                                    span,\n                                                    PathKind::Dependency);\n@@ -450,7 +450,7 @@ impl<'a> CrateReader<'a> {\n     }\n \n     fn read_extension_crate(&mut self, span: Span, info: &CrateInfo) -> ExtensionCrate {\n-        let target_triple = &self.sess.opts.target_triple[];\n+        let target_triple = &self.sess.opts.target_triple[..];\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n         let mut target_only = false;\n@@ -493,8 +493,8 @@ impl<'a> CrateReader<'a> {\n                                                           PathKind::Crate).is_none();\n         let metadata = if register {\n             // Register crate now to avoid double-reading metadata\n-            let (_, cmd, _) = self.register_crate(&None, &info.ident[],\n-                                &info.name[], span, library);\n+            let (_, cmd, _) = self.register_crate(&None, &info.ident,\n+                                &info.name, span, library);\n             PMDSource::Registered(cmd)\n         } else {\n             // Not registering the crate; just hold on to the metadata"}, {"sha": "38e15af2056bec11d74dc57e681c5b5c6e61a6ec", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -92,7 +92,7 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    let mut r = vec![ast_map::PathMod(token::intern(&cdata.name[]))];\n+    let mut r = vec![ast_map::PathMod(token::intern(&cdata.name))];\n     r.push_all(&path);\n     r\n }\n@@ -391,7 +391,7 @@ pub fn is_staged_api(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n     let cdata = cstore.get_crate_data(def.krate);\n     let attrs = decoder::get_crate_attributes(cdata.data());\n     for attr in &attrs {\n-        if &attr.name()[] == \"staged_api\" {\n+        if &attr.name()[..] == \"staged_api\" {\n             match attr.node.value.node { ast::MetaWord(_) => return true, _ => (/*pass*/) }\n         }\n     }"}, {"sha": "f883c8a1bb9189eb6bf1d9a3900eef3b042aa9f5", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -1225,7 +1225,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n         let name = docstr(depdoc, tag_crate_dep_crate_name);\n-        let hash = Svh::new(&docstr(depdoc, tag_crate_dep_hash)[]);\n+        let hash = Svh::new(&docstr(depdoc, tag_crate_dep_hash));\n         deps.push(CrateDep {\n             cnum: crate_num,\n             name: name,"}, {"sha": "0ee29bc61f8cbacf874531095209552b19430941", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -94,7 +94,7 @@ fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Ident) {\n }\n \n pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_str(tag_def_id, &def_to_string(id)[]);\n+    rbml_w.wr_tagged_str(tag_def_id, &def_to_string(id));\n }\n \n #[derive(Clone)]\n@@ -273,7 +273,7 @@ fn encode_symbol(ecx: &EncodeContext,\n         }\n         None => {\n             ecx.diag.handler().bug(\n-                &format!(\"encode_symbol: id not found {}\", id)[]);\n+                &format!(\"encode_symbol: id not found {}\", id));\n         }\n     }\n     rbml_w.end_tag();\n@@ -341,8 +341,8 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_name(rbml_w, variant.node.name.name);\n         encode_parent_item(rbml_w, local_def(id));\n         encode_visibility(rbml_w, variant.node.vis);\n-        encode_attributes(rbml_w, &variant.node.attrs[]);\n-        encode_repr_attrs(rbml_w, ecx, &variant.node.attrs[]);\n+        encode_attributes(rbml_w, &variant.node.attrs);\n+        encode_repr_attrs(rbml_w, ecx, &variant.node.attrs);\n \n         let stab = stability::lookup(ecx.tcx, ast_util::local_def(variant.node.id));\n         encode_stability(rbml_w, stab);\n@@ -394,12 +394,12 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n     rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    rbml_w.wr_str(&def_to_string(method_def_id)[]);\n+    rbml_w.wr_str(&def_to_string(method_def_id));\n     rbml_w.end_tag();\n     rbml_w.start_tag(tag_items_data_item_reexport_name);\n     rbml_w.wr_str(&format!(\"{}::{}\",\n                           exp.name,\n-                          token::get_name(method_name))[]);\n+                          token::get_name(method_name)));\n     rbml_w.end_tag();\n     rbml_w.end_tag();\n }\n@@ -537,7 +537,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n                 rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                rbml_w.wr_str(&def_to_string(exp.def_id)[]);\n+                rbml_w.wr_str(&def_to_string(exp.def_id));\n                 rbml_w.end_tag();\n                 rbml_w.start_tag(tag_items_data_item_reexport_name);\n                 rbml_w.wr_str(exp.name.as_str());\n@@ -570,13 +570,13 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     // Encode info about all the module children.\n     for item in &md.items {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(&def_to_string(local_def(item.id))[]);\n+        rbml_w.wr_str(&def_to_string(local_def(item.id)));\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(&def_to_string(local_def(\n-                        auxiliary_node_id))[]);\n+                        auxiliary_node_id)));\n             rbml_w.end_tag();\n             true\n         });\n@@ -588,7 +588,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    did, ecx.tcx.map.node_to_string(did));\n \n             rbml_w.start_tag(tag_mod_impl);\n-            rbml_w.wr_str(&def_to_string(local_def(did))[]);\n+            rbml_w.wr_str(&def_to_string(local_def(did)));\n             rbml_w.end_tag();\n         }\n     }\n@@ -623,7 +623,7 @@ fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n         ast::Public => 'y',\n         ast::Inherited => 'i',\n     };\n-    rbml_w.wr_str(&ch.to_string()[]);\n+    rbml_w.wr_str(&ch.to_string());\n     rbml_w.end_tag();\n }\n \n@@ -783,7 +783,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n \n         rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n-                             &def_to_string(param.def_id)[]);\n+                             &def_to_string(param.def_id));\n \n         rbml_w.wr_tagged_u64(tag_region_param_def_space,\n                              param.space.to_uint() as u64);\n@@ -858,10 +858,10 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n     match ast_item_opt {\n         Some(&ast::MethodImplItem(ref ast_method)) => {\n-            encode_attributes(rbml_w, &ast_method.attrs[]);\n+            encode_attributes(rbml_w, &ast_method.attrs);\n             let scheme = ty::lookup_item_type(ecx.tcx, m.def_id);\n             let any_types = !scheme.generics.types.is_empty();\n-            if any_types || is_default_impl || should_inline(&ast_method.attrs[]) {\n+            if any_types || is_default_impl || should_inline(&ast_method.attrs) {\n                 encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n                                                                ast_item_opt.unwrap()));\n             }\n@@ -906,7 +906,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     match typedef_opt {\n         None => {}\n         Some(typedef) => {\n-            encode_attributes(rbml_w, &typedef.attrs[]);\n+            encode_attributes(rbml_w, &typedef.attrs);\n             encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx,\n                                                          typedef.id));\n         }\n@@ -1040,7 +1040,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n-        encode_attributes(rbml_w, &item.attrs[]);\n+        encode_attributes(rbml_w, &item.attrs);\n         rbml_w.end_tag();\n       }\n       ast::ItemConst(_, _) => {\n@@ -1066,8 +1066,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n-        encode_attributes(rbml_w, &item.attrs[]);\n-        if tps_len > 0 || should_inline(&item.attrs[]) {\n+        encode_attributes(rbml_w, &item.attrs);\n+        if tps_len > 0 || should_inline(&item.attrs) {\n             encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         }\n         if tps_len == 0 {\n@@ -1083,7 +1083,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_info_for_mod(ecx,\n                             rbml_w,\n                             m,\n-                            &item.attrs[],\n+                            &item.attrs,\n                             item.id,\n                             path,\n                             item.ident,\n@@ -1100,7 +1100,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode all the items in this module.\n         for foreign_item in &fm.items {\n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(&def_to_string(local_def(foreign_item.id))[]);\n+            rbml_w.wr_str(&def_to_string(local_def(foreign_item.id)));\n             rbml_w.end_tag();\n         }\n         encode_visibility(rbml_w, vis);\n@@ -1128,8 +1128,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, &item.attrs[]);\n-        encode_repr_attrs(rbml_w, ecx, &item.attrs[]);\n+        encode_attributes(rbml_w, &item.attrs);\n+        encode_repr_attrs(rbml_w, ecx, &item.attrs);\n         for v in &enum_definition.variants {\n             encode_variant_id(rbml_w, local_def(v.node.id));\n         }\n@@ -1146,7 +1146,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_enum_variant_info(ecx,\n                                  rbml_w,\n                                  item.id,\n-                                 &(*enum_definition).variants[],\n+                                 &(*enum_definition).variants,\n                                  index);\n       }\n       ast::ItemStruct(ref struct_def, _) => {\n@@ -1172,11 +1172,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, &item.attrs[]);\n+        encode_attributes(rbml_w, &item.attrs);\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n         encode_visibility(rbml_w, vis);\n-        encode_repr_attrs(rbml_w, ecx, &item.attrs[]);\n+        encode_repr_attrs(rbml_w, ecx, &item.attrs);\n \n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n@@ -1213,7 +1213,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(rbml_w, 'i');\n         encode_bounds_and_type_for_item(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, &item.attrs[]);\n+        encode_attributes(rbml_w, &item.attrs);\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n         match ty.node {\n@@ -1319,7 +1319,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_generics(rbml_w, ecx, &trait_def.generics, &trait_predicates, tag_item_generics);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, &item.attrs[]);\n+        encode_attributes(rbml_w, &item.attrs);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         for &method_def_id in &*ty::trait_item_def_ids(tcx, def_id) {\n@@ -1337,7 +1337,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             rbml_w.end_tag();\n \n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(&def_to_string(method_def_id.def_id())[]);\n+            rbml_w.wr_str(&def_to_string(method_def_id.def_id()));\n             rbml_w.end_tag();\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1426,14 +1426,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             };\n             match trait_item {\n                 &ast::RequiredMethod(ref m) => {\n-                    encode_attributes(rbml_w, &m.attrs[]);\n+                    encode_attributes(rbml_w, &m.attrs);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'r');\n                     encode_method_argument_names(rbml_w, &*m.decl);\n                 }\n \n                 &ast::ProvidedMethod(ref m) => {\n-                    encode_attributes(rbml_w, &m.attrs[]);\n+                    encode_attributes(rbml_w, &m.attrs);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'p');\n                     encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n@@ -1442,7 +1442,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                 &ast::TypeTraitItem(ref associated_type) => {\n                     encode_attributes(rbml_w,\n-                                      &associated_type.attrs[]);\n+                                      &associated_type.attrs);\n                     encode_item_sort(rbml_w, 't');\n                 }\n             }\n@@ -1867,10 +1867,10 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n         rbml_w.start_tag(tag_macro_def);\n \n         encode_name(rbml_w, def.ident.name);\n-        encode_attributes(rbml_w, &def.attrs[]);\n+        encode_attributes(rbml_w, &def.attrs);\n \n         rbml_w.start_tag(tag_macro_def_body);\n-        rbml_w.wr_str(&pprust::tts_to_string(&def.body[])[]);\n+        rbml_w.wr_str(&pprust::tts_to_string(&def.body));\n         rbml_w.end_tag();\n \n         rbml_w.end_tag();\n@@ -1887,7 +1887,7 @@ fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &ast::Crate) {\n         fn visit_struct_field(&mut self, field: &ast::StructField) {\n             self.rbml_w.start_tag(tag_struct_field);\n             self.rbml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n-            encode_attributes(self.rbml_w, &field.node.attrs[]);\n+            encode_attributes(self.rbml_w, &field.node.attrs);\n             self.rbml_w.end_tag();\n         }\n     }\n@@ -1959,13 +1959,13 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in &krate.module.items {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(&def_to_string(local_def(item.id))[]);\n+        rbml_w.wr_str(&def_to_string(local_def(item.id)));\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n             rbml_w.wr_str(&def_to_string(local_def(\n-                        auxiliary_node_id))[]);\n+                        auxiliary_node_id)));\n             rbml_w.end_tag();\n             true\n         });\n@@ -2132,17 +2132,17 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n \n     let mut rbml_w = writer::Encoder::new(wr);\n \n-    encode_crate_name(&mut rbml_w, &ecx.link_meta.crate_name[]);\n+    encode_crate_name(&mut rbml_w, &ecx.link_meta.crate_name);\n     encode_crate_triple(&mut rbml_w,\n                         &tcx.sess\n                            .opts\n                            .target_triple\n-                           []);\n+                           );\n     encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n     encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n \n     let mut i = rbml_w.writer.tell().unwrap();\n-    encode_attributes(&mut rbml_w, &krate.attrs[]);\n+    encode_attributes(&mut rbml_w, &krate.attrs);\n     stats.attr_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     i = rbml_w.writer.tell().unwrap();"}, {"sha": "fbc3e76cf934b2e073d18c9bfee730d52bbcfc1f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -329,7 +329,7 @@ impl<'a> Context<'a> {\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     &format!(\"crate `{}`, path #{}, triple {}: {}\",\n-                            self.ident, i+1, got, path.display())[]);\n+                            self.ident, i+1, got, path.display()));\n             }\n         }\n         if self.rejected_via_hash.len() > 0 {\n@@ -339,15 +339,15 @@ impl<'a> Context<'a> {\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                     &format!(\"crate `{}` path #{}: {}\",\n-                            self.ident, i+1, path.display())[]);\n+                            self.ident, i+1, path.display()));\n             }\n             match self.root {\n                 &None => {}\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n                         self.sess.fileline_note(self.span,\n                             &format!(\"crate `{}` path #{}: {}\",\n-                                    r.ident, i+1, path.display())[]);\n+                                    r.ident, i+1, path.display()));\n                     }\n                 }\n             }\n@@ -359,7 +359,7 @@ impl<'a> Context<'a> {\n             for (i, &CrateMismatch { ref path, .. }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n                                         &format!(\"crate `{}` path #{}: {}\",\n-                                                 self.ident, i+1, path.display())[]);\n+                                                 self.ident, i+1, path.display()));\n             }\n         }\n         self.sess.abort_if_errors();\n@@ -472,26 +472,26 @@ impl<'a> Context<'a> {\n             _ => {\n                 self.sess.span_err(self.span,\n                     &format!(\"multiple matching crates for `{}`\",\n-                            self.crate_name)[]);\n+                            self.crate_name));\n                 self.sess.note(\"candidates:\");\n                 for lib in &libraries {\n                     match lib.dylib {\n                         Some((ref p, _)) => {\n                             self.sess.note(&format!(\"path: {}\",\n-                                                   p.display())[]);\n+                                                   p.display()));\n                         }\n                         None => {}\n                     }\n                     match lib.rlib {\n                         Some((ref p, _)) => {\n                             self.sess.note(&format!(\"path: {}\",\n-                                                    p.display())[]);\n+                                                    p.display()));\n                         }\n                         None => {}\n                     }\n                     let data = lib.metadata.as_slice();\n                     let name = decoder::get_crate_name(data);\n-                    note_crate_name(self.sess.diagnostic(), &name[]);\n+                    note_crate_name(self.sess.diagnostic(), &name);\n                 }\n                 None\n             }\n@@ -545,19 +545,19 @@ impl<'a> Context<'a> {\n                                    &format!(\"multiple {} candidates for `{}` \\\n                                             found\",\n                                            flavor,\n-                                           self.crate_name)[]);\n+                                           self.crate_name));\n                 self.sess.span_note(self.span,\n                                     &format!(r\"candidate #1: {}\",\n                                             ret.as_ref().unwrap().0\n-                                               .display())[]);\n+                                               .display()));\n                 error = 1;\n                 ret = None;\n             }\n             if error > 0 {\n                 error += 1;\n                 self.sess.span_note(self.span,\n                                     &format!(r\"candidate #{}: {}\", error,\n-                                            lib.display())[]);\n+                                            lib.display()));\n                 continue\n             }\n             *slot = Some(metadata);\n@@ -630,14 +630,14 @@ impl<'a> Context<'a> {\n             let locs = locs.iter().map(|l| Path::new(&l[..])).filter(|loc| {\n                 if !loc.exists() {\n                     sess.err(&format!(\"extern location for {} does not exist: {}\",\n-                                     self.crate_name, loc.display())[]);\n+                                     self.crate_name, loc.display()));\n                     return false;\n                 }\n                 let file = match loc.filename_str() {\n                     Some(file) => file,\n                     None => {\n                         sess.err(&format!(\"extern location for {} is not a file: {}\",\n-                                         self.crate_name, loc.display())[]);\n+                                         self.crate_name, loc.display()));\n                         return false;\n                     }\n                 };\n@@ -651,7 +651,7 @@ impl<'a> Context<'a> {\n                     }\n                 }\n                 sess.err(&format!(\"extern location for {} is of an unknown type: {}\",\n-                                 self.crate_name, loc.display())[]);\n+                                 self.crate_name, loc.display()));\n                 false\n             });\n \n@@ -686,7 +686,7 @@ impl<'a> Context<'a> {\n }\n \n pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n-    diag.handler().note(&format!(\"crate name: {}\", name)[]);\n+    diag.handler().note(&format!(\"crate name: {}\", name));\n }\n \n impl ArchiveMetadata {"}, {"sha": "d25dc4f58a5dfa6181472a12ff73c75237c69155", "filename": "src/librustc/metadata/macro_import.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmacro_import.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -78,15 +78,15 @@ impl<'a, 'v> Visitor<'v> for MacroLoader<'a> {\n \n         for attr in &item.attrs {\n             let mut used = true;\n-            match &attr.name()[] {\n+            match &attr.name()[..] {\n                 \"phase\" => {\n                     self.sess.span_err(attr.span, \"#[phase] is deprecated\");\n                 }\n                 \"plugin\" => {\n                     self.sess.span_err(attr.span, \"#[plugin] on `extern crate` is deprecated\");\n                     self.sess.span_help(attr.span, &format!(\"use a crate attribute instead, \\\n                                                             i.e. #![plugin({})]\",\n-                                                            item.ident.as_str())[]);\n+                                                            item.ident.as_str()));\n                 }\n                 \"macro_use\" => {\n                     let names = attr.meta_item_list();"}, {"sha": "4a45b7fbfdcc743b48ae28d2522279a2cb46f0f2", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -305,7 +305,7 @@ fn parse_bound_region_<F>(st: &mut PState, conv: &mut F) -> ty::BoundRegion wher\n         }\n         '[' => {\n             let def = parse_def_(st, RegionParameter, conv);\n-            let ident = token::str_to_ident(&parse_str(st, ']')[]);\n+            let ident = token::str_to_ident(&parse_str(st, ']'));\n             ty::BrNamed(def, ident.name)\n         }\n         'f' => {\n@@ -344,7 +344,7 @@ fn parse_region_<F>(st: &mut PState, conv: &mut F) -> ty::Region where\n         assert_eq!(next(st), '|');\n         let index = parse_u32(st);\n         assert_eq!(next(st), '|');\n-        let nm = token::str_to_ident(&parse_str(st, ']')[]);\n+        let nm = token::str_to_ident(&parse_str(st, ']'));\n         ty::ReEarlyBound(node_id, space, index, nm.name)\n       }\n       'f' => {\n@@ -485,7 +485,7 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         assert_eq!(next(st), '|');\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n-        let name = token::intern(&parse_str(st, ']')[]);\n+        let name = token::intern(&parse_str(st, ']'));\n         return ty::mk_param(tcx, space, index, name);\n       }\n       '~' => return ty::mk_uniq(tcx, parse_ty_(st, conv)),"}, {"sha": "d699ba40e822045bf4ac34ff6b13a86bfc93198e", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -48,7 +48,7 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n                 None => {\n                     tcx.sess.span_bug(ast_ty.span,\n                                       &format!(\"unbound path {}\",\n-                                              path.repr(tcx))[])\n+                                              path.repr(tcx)))\n                 }\n                 Some(&d) => d\n             };"}, {"sha": "eb723830d383c8d6da97b8902170f3a59b53328f", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -1852,7 +1852,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n             None => {\n                 dcx.tcx.sess.bug(\n                     &format!(\"unknown tag found in side tables: {:x}\",\n-                            tag)[]);\n+                            tag));\n             }\n             Some(value) => {\n                 let val_doc = entry_doc.get(c::tag_table_val as uint);\n@@ -1937,7 +1937,7 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     _ => {\n                         dcx.tcx.sess.bug(\n                             &format!(\"unknown tag found in side tables: {:x}\",\n-                                    tag)[]);\n+                                    tag));\n                     }\n                 }\n             }"}, {"sha": "d95dfb6feaec40eed64bbec4b21dbe1985d7bcca", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -327,7 +327,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let mut cond_exit = discr_exit;\n                 for arm in arms {\n                     cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n-                    let pats_exit = self.pats_any(&arm.pats[],\n+                    let pats_exit = self.pats_any(&arm.pats,\n                                                   cond_exit);            // 3\n                     let guard_exit = self.opt_expr(&arm.guard,\n                                                    pats_exit);           // 4\n@@ -582,14 +582,14 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n                             &format!(\"no loop scope for id {}\",\n-                                    loop_id)[]);\n+                                    loop_id));\n                     }\n \n                     r => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n                             &format!(\"bad entry `{:?}` in def_map for label\",\n-                                    r)[]);\n+                                    r));\n                     }\n                 }\n             }"}, {"sha": "14c6ff01e0e66d9384732a159c0eda97647052bb", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -54,7 +54,7 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n }\n \n impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(&self.name[]).ok().unwrap() }\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(&self.name[..]).ok().unwrap() }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n         dot::Id::new(format!(\"N{}\", i.node_id())).ok().unwrap()\n@@ -92,7 +92,7 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             let s = replace_newline_with_backslash_l(s);\n             label.push_str(&format!(\"exiting scope_{} {}\",\n                                    i,\n-                                   &s[..])[]);\n+                                   &s[..]));\n         }\n         dot::LabelText::EscStr(label.into_cow())\n     }"}, {"sha": "f1c8ad947642fab284d991ebc1893d3dae1fec61", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -176,7 +176,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         };\n \n         self.tcx.sess.span_err(e.span, &format!(\"mutable statics are not allowed \\\n-                                                 to have {}\", suffix)[]);\n+                                                 to have {}\", suffix));\n     }\n \n     fn check_static_type(&self, e: &ast::Expr) {\n@@ -382,7 +382,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             if v.mode != Mode::Var {\n                 v.tcx.sess.span_err(e.span,\n                                     &format!(\"{}s are not allowed to have destructors\",\n-                                             v.msg())[]);\n+                                             v.msg()));\n             }\n         }\n         _ => {}"}, {"sha": "7bd64a4f487d60414863d6456ad65cd330d6f676", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -163,7 +163,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 // First, check legality of move bindings.\n                 check_legality_of_move_bindings(cx,\n                                                 arm.guard.is_some(),\n-                                                &arm.pats[]);\n+                                                &arm.pats);\n \n                 // Second, if there is a guard on each arm, make sure it isn't\n                 // assigning or borrowing anything mutably.\n@@ -1101,7 +1101,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                             &format!(\"binding pattern {} is not an \\\n                                      identifier: {:?}\",\n                                     p.id,\n-                                    p.node)[]);\n+                                    p.node));\n                     }\n                 }\n             }"}, {"sha": "cf33cd71365789ccd6b62d32b5c28ff225662dcf", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -554,7 +554,7 @@ fn bits_to_string(words: &[uint]) -> String {\n         let mut v = word;\n         for _ in 0..usize::BYTES {\n             result.push(sep);\n-            result.push_str(&format!(\"{:02x}\", v & 0xFF)[]);\n+            result.push_str(&format!(\"{:02x}\", v & 0xFF));\n             v >>= 8;\n             sep = '-';\n         }"}, {"sha": "40e7610582f9c7454846a43c3bb06fec1aaebb54", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -118,7 +118,7 @@ fn calculate_type(sess: &session::Session,\n                 let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n                 if src.rlib.is_some() { return }\n                 sess.err(&format!(\"dependency `{}` not found in rlib format\",\n-                                 data.name)[]);\n+                                 data.name));\n             });\n             return Vec::new();\n         }\n@@ -197,7 +197,7 @@ fn calculate_type(sess: &session::Session,\n                                  match kind {\n                                      cstore::RequireStatic => \"rlib\",\n                                      cstore::RequireDynamic => \"dylib\",\n-                                 })[]);\n+                                 }));\n             }\n         }\n     }\n@@ -222,7 +222,7 @@ fn add_library(sess: &session::Session,\n                 let data = sess.cstore.get_crate_data(cnum);\n                 sess.err(&format!(\"cannot satisfy dependencies so `{}` only \\\n                                   shows up once\",\n-                                 data.name)[]);\n+                                 data.name));\n                 sess.help(\"having upstream crates all available in one format \\\n                            will likely make this go away\");\n             }"}, {"sha": "625093e3c5dea50bb8c976a39cbbbec3fa5962db", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -841,7 +841,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n                                 &format!(\"bad overloaded deref type {}\",\n-                                    method_ty.repr(self.tcx()))[])\n+                                    method_ty.repr(self.tcx())))\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,"}, {"sha": "99cb2a0978e7eeb1668c1680504f13c364544c8a", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -433,7 +433,7 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n             &format!(\"{}: bot and var types should have been handled ({},{})\",\n                     this.tag(),\n                     a.repr(this.infcx().tcx),\n-                    b.repr(this.infcx().tcx))[]);\n+                    b.repr(this.infcx().tcx)));\n       }\n \n       (&ty::ty_err, _) | (_, &ty::ty_err) => {\n@@ -818,7 +818,7 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     self.span,\n                     &format!(\"Encountered early bound region when generalizing: {}\",\n-                            r.repr(self.tcx()))[]);\n+                            r.repr(self.tcx())));\n             }\n \n             // Always make a fresh region variable for skolemized regions;"}, {"sha": "110c7bf41e559136aa7e7f5059c45e5e140c44ee", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\n                         \"consider adding an explicit lifetime bound `{}: {}`...\",\n                         bound_kind.user_string(self.tcx),\n-                        sub.user_string(self.tcx))[]);\n+                        sub.user_string(self.tcx)));\n             }\n \n             ty::ReStatic => {\n@@ -460,7 +460,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     &format!(\n                         \"consider adding an explicit lifetime bound `{}: 'static`...\",\n-                        bound_kind.user_string(self.tcx))[]);\n+                        bound_kind.user_string(self.tcx)));\n             }\n \n             _ => {\n@@ -472,10 +472,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     origin.span(),\n                     &format!(\n                         \"consider adding an explicit lifetime bound for `{}`\",\n-                        bound_kind.user_string(self.tcx))[]);\n+                        bound_kind.user_string(self.tcx)));\n                 note_and_explain_region(\n                     self.tcx,\n-                    &format!(\"{} must be valid for \", labeled_user_string)[],\n+                    &format!(\"{} must be valid for \", labeled_user_string),\n                     sub,\n                     \"...\");\n             }\n@@ -525,7 +525,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"...but `{}` is only valid for \",\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n-                                .to_string())[],\n+                                .to_string()),\n                     sup,\n                     \"\");\n             }\n@@ -568,7 +568,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\"captured variable `{}` does not \\\n                             outlive the enclosing closure\",\n                             ty::local_var_name_str(self.tcx,\n-                                                   id).to_string())[]);\n+                                                   id).to_string()));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"captured variable is valid for \",\n@@ -610,7 +610,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"the type `{}` does not fulfill the \\\n                              required lifetime\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)));\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -636,7 +636,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"the type `{}` (provided as the value of \\\n                              a type parameter) is not valid at this point\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)));\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -713,7 +713,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"type of expression contains references \\\n                              that are not valid during the expression: `{}`\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"type is only valid for \",\n@@ -752,7 +752,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"in type `{}`, reference has a longer lifetime \\\n                              than the data it references\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)));\n                 note_and_explain_region(\n                     self.tcx,\n                     \"the pointer is valid for \",\n@@ -988,7 +988,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 names.push(lt_name);\n             }\n             names.sort();\n-            let name = token::str_to_ident(&names[0][]).name;\n+            let name = token::str_to_ident(&names[0]).name;\n             return (name_to_dummy_lifetime(name), Kept);\n         }\n         return (self.life_giver.give_lifetime(), Fresh);\n@@ -1240,7 +1240,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                                 .sess\n                                 .fatal(&format!(\n                                         \"unbound path {}\",\n-                                        pprust::path_to_string(path))[])\n+                                        pprust::path_to_string(path)))\n                         }\n                         Some(&d) => d\n                     };\n@@ -1479,7 +1479,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             var_origin.span(),\n             &format!(\"cannot infer an appropriate lifetime{} \\\n                     due to conflicting requirements\",\n-                    var_description)[]);\n+                    var_description));\n     }\n \n     fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n@@ -1527,7 +1527,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n                             &format!(\"...so that {} ({})\",\n-                                    desc, values_str)[]);\n+                                    desc, values_str));\n                     }\n                     None => {\n                         // Really should avoid printing this error at\n@@ -1536,7 +1536,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         // doing right now. - nmatsakis\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n-                            &format!(\"...so that {}\", desc)[]);\n+                            &format!(\"...so that {}\", desc));\n                     }\n                 }\n             }\n@@ -1552,7 +1552,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     &format!(\n                         \"...so that closure can access `{}`\",\n                         ty::local_var_name_str(self.tcx, upvar_id.var_id)\n-                            .to_string())[])\n+                            .to_string()))\n             }\n             infer::InfStackClosure(span) => {\n                 self.tcx.sess.span_note(\n@@ -1577,7 +1577,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                             does not outlive the enclosing closure\",\n                             ty::local_var_name_str(\n                                 self.tcx,\n-                                id).to_string())[]);\n+                                id).to_string()));\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note(\n@@ -1626,7 +1626,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"...so type `{}` of expression is valid during the \\\n                              expression\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)));\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 self.tcx.sess.span_note(\n@@ -1638,28 +1638,28 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     span,\n                     &format!(\"...so that the reference type `{}` \\\n                              does not outlive the data it points at\",\n-                            self.ty_to_string(ty))[]);\n+                            self.ty_to_string(ty)));\n             }\n             infer::RelateParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     &format!(\"...so that the type `{}` \\\n                              will meet its required lifetime bounds\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)));\n             }\n             infer::RelateDefaultParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     &format!(\"...so that type parameter \\\n                              instantiated with `{}`, \\\n                              will meet its declared lifetime bounds\",\n-                            self.ty_to_string(t))[]);\n+                            self.ty_to_string(t)));\n             }\n             infer::RelateRegionParamBound(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n                     &format!(\"...so that the declared lifetime parameter bounds \\\n-                                are satisfied\")[]);\n+                                are satisfied\"));\n             }\n             infer::SafeDestructor(span) => {\n                 self.tcx.sess.span_note(\n@@ -1717,15 +1717,15 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n         Some(node) => match node {\n             ast_map::NodeItem(item) => match item.node {\n                 ast::ItemFn(_, _, _, ref gen, _) => {\n-                    taken.push_all(&gen.lifetimes[]);\n+                    taken.push_all(&gen.lifetimes);\n                     None\n                 },\n                 _ => None\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match *ii {\n                     ast::MethodImplItem(ref m) => {\n-                        taken.push_all(&m.pe_generics().lifetimes[]);\n+                        taken.push_all(&m.pe_generics().lifetimes);\n                         Some(m.id)\n                     }\n                     ast::TypeImplItem(_) => None,\n@@ -1784,7 +1784,7 @@ impl LifeGiver {\n         let mut lifetime;\n         loop {\n             let mut s = String::from_str(\"'\");\n-            s.push_str(&num_to_string(self.counter.get())[]);\n+            s.push_str(&num_to_string(self.counter.get()));\n             if !self.taken.contains(&s) {\n                 lifetime = name_to_dummy_lifetime(\n                                     token::str_to_ident(&s[..]).name);"}, {"sha": "b0b9a80589d0d62a78a261ade7d9cbc8118edec4", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -189,7 +189,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n                 span,\n                 &format!(\"region {:?} is not associated with \\\n                          any bound region from A!\",\n-                        r0)[])\n+                        r0))\n         }\n     }\n \n@@ -322,7 +322,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             }\n             infcx.tcx.sess.span_bug(\n                 span,\n-                &format!(\"could not find original bound region for {:?}\", r)[]);\n+                &format!(\"could not find original bound region for {:?}\", r));\n         }\n \n         fn fresh_bound_variable(infcx: &InferCtxt, debruijn: ty::DebruijnIndex) -> ty::Region {\n@@ -339,7 +339,7 @@ fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n             r => {\n                 combiner.infcx().tcx.sess.span_bug(\n                     combiner.trace().origin.span(),\n-                    &format!(\"found non-region-vid: {:?}\", r)[]);\n+                    &format!(\"found non-region-vid: {:?}\", r));\n             }\n         }).collect()\n }"}, {"sha": "835964828d419c468785a2722902c113086febdb", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -999,7 +999,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n                 self.tcx.sess.span_err(sp, &format!(\"{}{}\",\n                     mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                    error_str)[]);\n+                    error_str));\n \n                 if let Some(err) = err {\n                     ty::note_and_explain_type_err(self.tcx, err)"}, {"sha": "5959b4a7c507a46420893aa508a91e9e5899fd67", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -473,7 +473,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 origin.span(),\n                 &format!(\"cannot relate bound region: {} <= {}\",\n                         sub.repr(self.tcx),\n-                        sup.repr(self.tcx))[]);\n+                        sup.repr(self.tcx)));\n           }\n           (_, ReStatic) => {\n             // all regions are subregions of static, so we can ignore this\n@@ -733,7 +733,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             self.tcx.sess.bug(\n                 &format!(\"cannot relate bound region: LUB({}, {})\",\n                         a.repr(self.tcx),\n-                        b.repr(self.tcx))[]);\n+                        b.repr(self.tcx)));\n           }\n \n           (ReStatic, _) | (_, ReStatic) => {\n@@ -750,7 +750,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 &format!(\"lub_concrete_regions invoked with \\\n                          non-concrete regions: {:?}, {:?}\",\n                         a,\n-                        b)[]);\n+                        b));\n           }\n \n           (ReFree(ref fr), ReScope(s_id)) |\n@@ -834,7 +834,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n               self.tcx.sess.bug(\n                   &format!(\"cannot relate bound region: GLB({}, {})\",\n                           a.repr(self.tcx),\n-                          b.repr(self.tcx))[]);\n+                          b.repr(self.tcx)));\n             }\n \n             (ReStatic, r) | (r, ReStatic) => {\n@@ -854,7 +854,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     &format!(\"glb_concrete_regions invoked with \\\n                              non-concrete regions: {:?}, {:?}\",\n                             a,\n-                            b)[]);\n+                            b));\n             }\n \n             (ReFree(ref fr), ReScope(s_id)) |\n@@ -1417,7 +1417,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                     for var {:?}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n                     lower_bounds.repr(self.tcx),\n-                    upper_bounds.repr(self.tcx))[]);\n+                    upper_bounds.repr(self.tcx)));\n     }\n \n     fn collect_error_for_contracting_node(\n@@ -1461,7 +1461,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             &format!(\"collect_error_for_contracting_node() could not find error \\\n                      for var {:?}, upper_bounds={}\",\n                     node_idx,\n-                    upper_bounds.repr(self.tcx))[]);\n+                    upper_bounds.repr(self.tcx)));\n     }\n \n     fn collect_concrete_regions(&self,"}, {"sha": "547696c0c4c2f243b409b6aecdb765b25226409a", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n                 ty::ty_infer(_) => {\n                     self.infcx.tcx.sess.bug(\n                         &format!(\"Unexpected type in full type resolver: {}\",\n-                                t.repr(self.infcx.tcx))[]);\n+                                t.repr(self.infcx.tcx)));\n                 }\n                 _ => {\n                     ty_fold::super_fold_ty(self, t)"}, {"sha": "145fccd7972bb5bcbf927d27d391abc5f4d41c97", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -325,7 +325,7 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n             self.tcx\n                 .sess\n                 .span_bug(span, &format!(\"no variable registered for id {}\",\n-                                        node_id)[]);\n+                                        node_id));\n           }\n         }\n     }\n@@ -585,7 +585,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.ir.tcx.sess.span_bug(\n                 span,\n                 &format!(\"no live node registered for node {}\",\n-                        node_id)[]);\n+                        node_id));\n           }\n         }\n     }"}, {"sha": "d1fba421bbe58eeb9649b9ac594c3dc66bd5939c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -624,7 +624,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                           span,\n                           &format!(\"Upvar of non-closure {} - {}\",\n                                   fn_node_id,\n-                                  ty.repr(self.tcx()))[]);\n+                                  ty.repr(self.tcx())));\n                   }\n               }\n           }"}, {"sha": "7774314b6e08848ce58dd2611bbead69b066071a", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -50,7 +50,7 @@ fn generics_require_inlining(generics: &ast::Generics) -> bool {\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n fn item_might_be_inlined(item: &ast::Item) -> bool {\n-    if attributes_specify_inlining(&item.attrs[]) {\n+    if attributes_specify_inlining(&item.attrs) {\n         return true\n     }\n \n@@ -65,7 +65,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n \n fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n-    if attributes_specify_inlining(&method.attrs[]) ||\n+    if attributes_specify_inlining(&method.attrs) ||\n         generics_require_inlining(method.pe_generics()) {\n         return true\n     }\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     ast::MethodImplItem(ref method) => {\n                         if generics_require_inlining(method.pe_generics()) ||\n                                 attributes_specify_inlining(\n-                                    &method.attrs[]) {\n+                                    &method.attrs) {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 None => {\n                     self.tcx.sess.bug(&format!(\"found unmapped ID in worklist: \\\n                                                {}\",\n-                                              search_item)[])\n+                                              search_item))\n                 }\n             }\n         }\n@@ -342,7 +342,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     .bug(&format!(\"found unexpected thingy in worklist: {}\",\n                                  self.tcx\n                                      .map\n-                                     .node_to_string(search_item))[])\n+                                     .node_to_string(search_item)))\n             }\n         }\n     }"}, {"sha": "cfa5e5fce387930a2a71a6ef89c2dc3b3fdd1824", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -181,7 +181,7 @@ impl Index {\n     pub fn new(krate: &Crate) -> Index {\n         let mut staged_api = false;\n         for attr in &krate.attrs {\n-            if &attr.name()[] == \"staged_api\" {\n+            if &attr.name()[..] == \"staged_api\" {\n                 match attr.node.value.node {\n                     ast::MetaWord(_) => {\n                         attr::mark_used(attr);"}, {"sha": "684b28d03739e3fe28b84a524b120e4b48a32d3a", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -639,7 +639,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                                      (space={:?}, index={})\",\n                                     region_name.as_str(),\n                                     self.root_ty.repr(self.tcx()),\n-                                    space, i)[]);\n+                                    space, i));\n                             }\n                         }\n                 }\n@@ -696,7 +696,7 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n                             p.space,\n                             p.idx,\n                             self.root_ty.repr(self.tcx()),\n-                            self.substs.repr(self.tcx()))[]);\n+                            self.substs.repr(self.tcx())));\n             }\n         };\n "}, {"sha": "6d3b910e720a71dc67dd32e33e382542d9b179fb", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -198,7 +198,7 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::ty_err => {\n             tcx.sess.bug(\n                 &format!(\"ty_is_local invoked on unexpected type: {}\",\n-                        ty.repr(tcx))[])\n+                        ty.repr(tcx)))\n         }\n     }\n }"}, {"sha": "d2b5b460d142002b174a88910a9972944f3f7316", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -422,5 +422,5 @@ pub fn suggest_new_overflow_limit(tcx: &ty::ctxt, span: Span) {\n         span,\n         &format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-            suggested_limit)[]);\n+            suggested_limit));\n }"}, {"sha": "c1066aa899eaea4fe4f7e34ea89b319a443c4e8f", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -227,7 +227,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn pending_obligations(&self) -> &[PredicateObligation<'tcx>] {\n-        &self.predicates[]\n+        &self.predicates\n     }\n \n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it"}, {"sha": "085758b44b5c7a0ee39188fdd5a6561caa563999", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -1575,7 +1575,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n-                        self_ty.repr(self.tcx()))[]);\n+                        self_ty.repr(self.tcx())));\n             }\n         };\n \n@@ -1727,7 +1727,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n                     &format!(\"builtin bound for {} was ambig\",\n-                            obligation.repr(self.tcx()))[]);\n+                            obligation.repr(self.tcx())));\n             }\n         }\n     }\n@@ -1995,7 +1995,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\"Impl {} was matchable against {} but now is not\",\n                             impl_def_id.repr(self.tcx()),\n-                            obligation.repr(self.tcx()))[]);\n+                            obligation.repr(self.tcx())));\n             }\n         }\n     }"}, {"sha": "0cdb8f828c14d811d8952ca48d0e0b3c1361bb95", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -2295,7 +2295,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             _ => {\n                 cx.sess.bug(&format!(\"ParameterEnvironment::from_item(): \\\n                                      `{}` is not an item\",\n-                                    cx.map.node_to_string(id))[])\n+                                    cx.map.node_to_string(id)))\n             }\n         }\n     }\n@@ -2737,7 +2737,7 @@ impl FlagComputation {\n     fn add_fn_sig(&mut self, fn_sig: &PolyFnSig) {\n         let mut computation = FlagComputation::new();\n \n-        computation.add_tys(&fn_sig.0.inputs[]);\n+        computation.add_tys(&fn_sig.0.inputs);\n \n         if let ty::FnConverging(output) = fn_sig.0.output {\n             computation.add_ty(output);\n@@ -3177,7 +3177,7 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         ty_str => mk_mach_uint(cx, ast::TyU8),\n         ty_open(ty) => sequence_element_type(cx, ty),\n         _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n-                                 ty_to_string(cx, ty))[]),\n+                                 ty_to_string(cx, ty))),\n     }\n }\n \n@@ -3538,7 +3538,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 let variants = substd_enum_variants(cx, did, substs);\n                 let mut res =\n                     TypeContents::union(&variants[..], |variant| {\n-                        TypeContents::union(&variant.args[],\n+                        TypeContents::union(&variant.args,\n                                             |arg_ty| {\n                             tc_ty(cx, *arg_ty, cache)\n                         })\n@@ -4121,7 +4121,7 @@ pub fn close_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_open(ty) => mk_rptr(cx, cx.mk_region(ReStatic), mt {ty: ty, mutbl:ast::MutImmutable}),\n         _ => cx.sess.bug(&format!(\"Trying to close a non-open type {}\",\n-                                 ty_to_string(cx, ty))[])\n+                                 ty_to_string(cx, ty)))\n     }\n }\n \n@@ -4222,7 +4222,7 @@ pub fn node_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n         Some(ty) => ty.clone(),\n         None => cx.sess.bug(\n             &format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n-                    cx.map.node_to_string(id))[])\n+                    cx.map.node_to_string(id)))\n     }\n }\n \n@@ -4231,7 +4231,7 @@ pub fn node_id_to_type<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n        Some(ty) => ty,\n        None => cx.sess.bug(\n            &format!(\"node_id_to_type: no type for node `{}`\",\n-                   cx.map.node_to_string(id))[])\n+                   cx.map.node_to_string(id)))\n     }\n }\n \n@@ -4305,7 +4305,7 @@ pub fn ty_region(tcx: &ctxt,\n             tcx.sess.span_bug(\n                 span,\n                 &format!(\"ty_region() invoked on an inappropriate ty: {:?}\",\n-                        s)[]);\n+                        s));\n         }\n     }\n }\n@@ -4370,11 +4370,11 @@ pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n         Some(f) => {\n             cx.sess.bug(&format!(\"Node id {} is not an expr: {:?}\",\n                                 id,\n-                                f)[]);\n+                                f));\n         }\n         None => {\n             cx.sess.bug(&format!(\"Node id {} is not present \\\n-                                in the node map\", id)[]);\n+                                in the node map\", id));\n         }\n     }\n }\n@@ -4390,14 +4390,14 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n                     cx.sess.bug(\n                         &format!(\"Variable id {} maps to {:?}, not local\",\n                                 id,\n-                                pat)[]);\n+                                pat));\n                 }\n             }\n         }\n         r => {\n             cx.sess.bug(&format!(\"Variable id {} maps to {:?}, not local\",\n                                 id,\n-                                r)[]);\n+                                r));\n         }\n     }\n }\n@@ -4428,7 +4428,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                             cx.sess.bug(\n                                 &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n                                          {:?}\",\n-                                        b)[]);\n+                                        b));\n                         }\n                     }\n                 }\n@@ -4459,7 +4459,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                                                 {}\",\n                                                 i,\n                                                 ty_to_string(cx, adjusted_ty))\n-                                        []);\n+                                        );\n                                 }\n                             }\n                         }\n@@ -4522,7 +4522,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n             }\n             _ => cx.sess.span_bug(span,\n                                   &format!(\"UnsizeLength with bad sty: {:?}\",\n-                                          ty_to_string(cx, ty))[])\n+                                          ty_to_string(cx, ty)))\n         },\n         &UnsizeStruct(box ref k, tp_index) => match ty.sty {\n             ty_struct(did, substs) => {\n@@ -4534,7 +4534,7 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n             }\n             _ => cx.sess.span_bug(span,\n                                   &format!(\"UnsizeStruct with bad sty: {:?}\",\n-                                          ty_to_string(cx, ty))[])\n+                                          ty_to_string(cx, ty)))\n         },\n         &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n             mk_trait(cx, principal.clone(), bounds.clone())\n@@ -4547,7 +4547,7 @@ pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n         Some(&def) => def,\n         None => {\n             tcx.sess.span_bug(expr.span, &format!(\n-                \"no def-map entry for expr {}\", expr.id)[]);\n+                \"no def-map entry for expr {}\", expr.id));\n         }\n     }\n }\n@@ -4639,7 +4639,7 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                         expr.span,\n                         &format!(\"uncategorized def for expr {}: {:?}\",\n                                 expr.id,\n-                                def)[]);\n+                                def));\n                 }\n             }\n         }\n@@ -4767,7 +4767,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n         token::get_name(name),\n         fields.iter()\n               .map(|f| token::get_name(f.name).to_string())\n-              .collect::<Vec<String>>())[]);\n+              .collect::<Vec<String>>()));\n }\n \n pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n@@ -5019,14 +5019,14 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                     _ => {\n                         cx.sess.bug(&format!(\"provided_trait_methods: `{:?}` is \\\n                                              not a trait\",\n-                                            id)[])\n+                                            id))\n                     }\n                 }\n             }\n             _ => {\n                 cx.sess.bug(&format!(\"provided_trait_methods: `{:?}` is not a \\\n                                      trait\",\n-                                    id)[])\n+                                    id))\n             }\n         }\n     } else {\n@@ -5262,7 +5262,7 @@ impl<'tcx> VariantInfo<'tcx> {\n                 };\n             },\n             ast::StructVariantKind(ref struct_def) => {\n-                let fields: &[StructField] = &struct_def.fields[];\n+                let fields: &[StructField] = &struct_def.fields;\n \n                 assert!(fields.len() > 0);\n \n@@ -5624,7 +5624,7 @@ pub fn get_attrs<'tcx>(tcx: &'tcx ctxt, did: DefId)\n                        -> CowVec<'tcx, ast::Attribute> {\n     if is_local(did) {\n         let item = tcx.map.expect_item(did.node);\n-        Cow::Borrowed(&item.attrs[])\n+        Cow::Borrowed(&item.attrs)\n     } else {\n         Cow::Owned(csearch::get_item_attrs(&tcx.sess.cstore, did))\n     }\n@@ -5686,7 +5686,7 @@ pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n             _ => {\n                 cx.sess.bug(\n                     &format!(\"ID not mapped to struct fields: {}\",\n-                            cx.map.node_to_string(did.node))[]);\n+                            cx.map.node_to_string(did.node)));\n             }\n         }\n     } else {\n@@ -5719,7 +5719,7 @@ pub fn struct_fields<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId, substs: &Substs<'tc\n pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n     v.iter().enumerate().map(|(i, &f)| {\n        field {\n-            name: token::intern(&i.to_string()[]),\n+            name: token::intern(&i.to_string()),\n             mt: mt {\n                 ty: f,\n                 mutbl: MutImmutable"}, {"sha": "efc12d00b10c60145b43fc222069523169b7a015", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -311,19 +311,19 @@ macro_rules! options {\n                     match (value, opt_type_desc) {\n                         (Some(..), None) => {\n                             early_error(&format!(\"{} option `{}` takes no \\\n-                                                 value\", $outputname, key)[])\n+                                                 value\", $outputname, key))\n                         }\n                         (None, Some(type_desc)) => {\n                             early_error(&format!(\"{0} option `{1}` requires \\\n                                                  {2} ({3} {1}=<value>)\",\n                                                 $outputname, key,\n-                                                type_desc, $prefix)[])\n+                                                type_desc, $prefix))\n                         }\n                         (Some(value), Some(type_desc)) => {\n                             early_error(&format!(\"incorrect value `{}` for {} \\\n                                                  option `{}` - {} was expected\",\n                                                  value, $outputname,\n-                                                 key, type_desc)[])\n+                                                 key, type_desc))\n                         }\n                         (None, None) => unreachable!()\n                     }\n@@ -333,7 +333,7 @@ macro_rules! options {\n             }\n             if !found {\n                 early_error(&format!(\"unknown {} option: `{}`\",\n-                                    $outputname, key)[]);\n+                                    $outputname, key));\n             }\n         }\n         return op;\n@@ -590,10 +590,10 @@ pub fn default_lib_output() -> CrateType {\n pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     use syntax::parse::token::intern_and_get_ident as intern;\n \n-    let end = &sess.target.target.target_endian[];\n-    let arch = &sess.target.target.arch[];\n-    let wordsz = &sess.target.target.target_pointer_width[];\n-    let os = &sess.target.target.target_os[];\n+    let end = &sess.target.target.target_endian;\n+    let arch = &sess.target.target.arch;\n+    let wordsz = &sess.target.target.target_pointer_width;\n+    let os = &sess.target.target.target_os;\n \n     let fam = match sess.target.target.options.is_like_windows {\n         true  => InternedString::new(\"windows\"),\n@@ -634,18 +634,18 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n }\n \n pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n-    let target = match Target::search(&opts.target_triple[]) {\n+    let target = match Target::search(&opts.target_triple) {\n         Ok(t) => t,\n         Err(e) => {\n             sp.handler().fatal(&format!(\"Error loading target specification: {}\", e));\n     }\n     };\n \n-    let (int_type, uint_type) = match &target.target_pointer_width[] {\n+    let (int_type, uint_type) = match &target.target_pointer_width[..] {\n         \"32\" => (ast::TyI32, ast::TyU32),\n         \"64\" => (ast::TyI64, ast::TyU64),\n         w    => sp.handler().fatal(&format!(\"target specification was invalid: unrecognized \\\n-                                             target-pointer-width {}\", w)[])\n+                                             target-pointer-width {}\", w))\n     };\n \n     Config {\n@@ -863,7 +863,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     \"dep-info\" => OutputTypeDepInfo,\n                     _ => {\n                         early_error(&format!(\"unknown emission type: `{}`\",\n-                                            part)[])\n+                                            part))\n                     }\n                 };\n                 output_types.push(output_type)\n@@ -955,7 +955,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             (_, s) => {\n                 early_error(&format!(\"unknown library kind `{}`, expected \\\n                                      one of dylib, framework, or static\",\n-                                    s)[]);\n+                                    s));\n             }\n         };\n         (name.to_string(), kind)\n@@ -991,7 +991,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         Some(arg) => {\n             early_error(&format!(\"argument for --color must be auto, always \\\n                                  or never (instead was `{}`)\",\n-                                arg)[])\n+                                arg))\n         }\n     };\n \n@@ -1111,7 +1111,7 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts(&[\"--test\".to_string()], &optgroups()[]) {\n+            &match getopts(&[\"--test\".to_string()], &optgroups()) {\n               Ok(m) => m,\n               Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n@@ -1128,7 +1128,7 @@ mod test {\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             &match getopts(&[\"--test\".to_string(), \"--cfg=test\".to_string()],\n-                           &optgroups()[]) {\n+                           &optgroups()) {\n               Ok(m) => m,\n               Err(f) => {\n                 panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n@@ -1148,7 +1148,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string()\n-            ], &optgroups()[]).unwrap();\n+            ], &optgroups()).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1159,7 +1159,7 @@ mod test {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string(),\n                 \"-Dwarnings\".to_string()\n-            ], &optgroups()[]).unwrap();\n+            ], &optgroups()).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1169,7 +1169,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Adead_code\".to_string()\n-            ], &optgroups()[]).unwrap();\n+            ], &optgroups()).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);"}, {"sha": "932a96e9b9ebd7df28572fd289f76fe55fdcb6a1", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -186,7 +186,7 @@ impl Session {\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp,\n-                      &format!(\"impossible case reached: {}\", msg)[]);\n+                      &format!(\"impossible case reached: {}\", msg));\n     }\n     pub fn verbose(&self) -> bool { self.opts.debugging_opts.verbose }\n     pub fn time_passes(&self) -> bool { self.opts.debugging_opts.time_passes }\n@@ -228,7 +228,7 @@ impl Session {\n     }\n     pub fn target_filesearch(&self, kind: PathKind) -> filesearch::FileSearch {\n         filesearch::FileSearch::new(self.sysroot(),\n-                                    &self.opts.target_triple[],\n+                                    &self.opts.target_triple,\n                                     &self.opts.search_paths,\n                                     kind)\n     }"}, {"sha": "1a7f32f54772c3a9149f8dc72474a657a73a822e", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -58,12 +58,12 @@ pub fn note_and_explain_region(cx: &ctxt,\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n             span,\n-            &format!(\"{}{}{}\", prefix, *str, suffix)[]);\n+            &format!(\"{}{}{}\", prefix, *str, suffix));\n         Some(span)\n       }\n       (ref str, None) => {\n         cx.sess.note(\n-            &format!(\"{}{}{}\", prefix, *str, suffix)[]);\n+            &format!(\"{}{}{}\", prefix, *str, suffix));\n         None\n       }\n     }\n@@ -274,7 +274,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         };\n \n         if abi != abi::Rust {\n-            s.push_str(&format!(\"extern {} \", abi.to_string())[]);\n+            s.push_str(&format!(\"extern {} \", abi.to_string()));\n         };\n \n         s.push_str(\"fn\");\n@@ -330,7 +330,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             ty::FnConverging(t) => {\n                 if !ty::type_is_nil(t) {\n                    s.push_str(\" -> \");\n-                   s.push_str(&ty_to_string(cx, t)[]);\n+                   s.push_str(&ty_to_string(cx, t));\n                 }\n             }\n             ty::FnDiverging => {\n@@ -367,7 +367,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_rptr(r, ref tm) => {\n             let mut buf = region_ptr_to_string(cx, *r);\n-            buf.push_str(&mt_to_string(cx, tm)[]);\n+            buf.push_str(&mt_to_string(cx, tm));\n             buf\n         }\n         ty_open(typ) =>\n@@ -561,7 +561,7 @@ pub fn parameterized<'tcx,GG>(cx: &ctxt<'tcx>,\n                 } else if strs[0].starts_with(\"(\") && strs[0].ends_with(\")\") {\n                     &strs[0][1 .. strs[0].len() - 1] // Remove '(' and ')'\n                 } else {\n-                    &strs[0][]\n+                    &strs[0][..]\n                 },\n                 tail)\n     } else if strs.len() > 0 {"}, {"sha": "6bf745315eace71965a8d3ea4b47e71a07557b02", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -73,19 +73,19 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n         Ok(prog) => {\n             let o = prog.wait_with_output().unwrap();\n             if !o.status.success() {\n-                handler.err(&format!(\"{:?} failed with: {}\", cmd, o.status)[]);\n+                handler.err(&format!(\"{:?} failed with: {}\", cmd, o.status));\n                 handler.note(&format!(\"stdout ---\\n{}\",\n-                                  str::from_utf8(&o.output[]).unwrap())[]);\n+                                  str::from_utf8(&o.output).unwrap()));\n                 handler.note(&format!(\"stderr ---\\n{}\",\n-                                  str::from_utf8(&o.error[]).unwrap())\n-                             []);\n+                                  str::from_utf8(&o.error).unwrap())\n+                             );\n                 handler.abort_if_errors();\n             }\n             o\n         },\n         Err(e) => {\n             handler.err(&format!(\"could not exec `{}`: {}\", &ar[..],\n-                             e)[]);\n+                             e));\n             handler.abort_if_errors();\n             panic!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }\n@@ -110,7 +110,7 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n     }\n     handler.fatal(&format!(\"could not find native static library `{}`, \\\n                            perhaps an -L flag is missing?\",\n-                          name)[]);\n+                          name));\n }\n \n impl<'a> Archive<'a> {\n@@ -142,7 +142,7 @@ impl<'a> Archive<'a> {\n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<String> {\n         let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, &[&self.dst]);\n-        let output = str::from_utf8(&output.output[]).unwrap();\n+        let output = str::from_utf8(&output.output).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n         output.lines_any().map(|s| s.to_string()).collect()\n@@ -174,9 +174,9 @@ impl<'a> ArchiveBuilder<'a> {\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) -> old_io::IoResult<()> {\n         let location = find_library(name,\n-                                    &self.archive.slib_prefix[],\n-                                    &self.archive.slib_suffix[],\n-                                    &self.archive.lib_search_paths[],\n+                                    &self.archive.slib_prefix,\n+                                    &self.archive.slib_suffix,\n+                                    &self.archive.lib_search_paths,\n                                     self.archive.handler);\n         self.add_archive(&location, name, |_| false)\n     }"}, {"sha": "3f2dcee5110951faae02c1ea3481141d5799004a", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -49,7 +49,7 @@ pub fn get_rpath_flags<F, G>(config: RPathConfig<F, G>) -> Vec<String> where\n fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     let mut ret = Vec::new();\n     for rpath in rpaths {\n-        ret.push(format!(\"-Wl,-rpath,{}\", &(*rpath)[]));\n+        ret.push(format!(\"-Wl,-rpath,{}\", &(*rpath)));\n     }\n     return ret;\n }"}, {"sha": "2fc43ab26b58ef328699c5a295df5386f79f982f", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -64,7 +64,7 @@ impl Svh {\n     }\n \n     pub fn as_str<'a>(&'a self) -> &'a str {\n-        &self.hash[]\n+        &self.hash\n     }\n \n     pub fn calculate(metadata: &Vec<String>, krate: &ast::Crate) -> Svh {\n@@ -329,7 +329,7 @@ mod svh_visitor {\n             // macro invocations, namely macro_rules definitions,\n             // *can* appear as items, even in the expanded crate AST.\n \n-            if &macro_name(mac)[] == \"macro_rules\" {\n+            if &macro_name(mac)[..] == \"macro_rules\" {\n                 // Pretty-printing definition to a string strips out\n                 // surface artifacts (currently), such as the span\n                 // information, yielding a content-based hash.\n@@ -356,7 +356,7 @@ mod svh_visitor {\n             fn macro_name(mac: &Mac) -> token::InternedString {\n                 match &mac.node {\n                     &MacInvocTT(ref path, ref _tts, ref _stx_ctxt) => {\n-                        let s = &path.segments[];\n+                        let s = &path.segments;\n                         assert_eq!(s.len(), 1);\n                         content(s[0].identifier)\n                     }"}, {"sha": "b04c07977c369be1dfb38233a13ef98d5fa1305f", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -239,7 +239,7 @@ impl Target {\n                      .and_then(|os| os.map(|s| s.to_string())) {\n                 Some(val) => val,\n                 None =>\n-                    handler.fatal(&format!(\"Field {} in target specification is required\", name)[])\n+                    handler.fatal(&format!(\"Field {} in target specification is required\", name))\n             }\n         };\n "}, {"sha": "23ca5b636815b0ae8512de888a10f3bd1a25947f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -466,23 +466,23 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         new_loan.span,\n                         &format!(\"cannot borrow `{}`{} as mutable \\\n                                 more than once at a time\",\n-                                nl, new_loan_msg)[])\n+                                nl, new_loan_msg))\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         &format!(\"closure requires unique access to `{}` \\\n                                 but {} is already borrowed{}\",\n-                                nl, ol_pronoun, old_loan_msg)[]);\n+                                nl, ol_pronoun, old_loan_msg));\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n                         &format!(\"cannot borrow `{}`{} as {} because \\\n                                 previous closure requires unique access\",\n-                                nl, new_loan_msg, new_loan.kind.to_user_str())[]);\n+                                nl, new_loan_msg, new_loan.kind.to_user_str()));\n                 }\n \n                 (_, _) => {\n@@ -495,7 +495,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                 new_loan.kind.to_user_str(),\n                                 ol_pronoun,\n                                 old_loan.kind.to_user_str(),\n-                                old_loan_msg)[]);\n+                                old_loan_msg));\n                 }\n             }\n \n@@ -504,7 +504,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.span_note(\n                         span,\n                         &format!(\"borrow occurs due to use of `{}` in closure\",\n-                                nl)[]);\n+                                nl));\n                 }\n                 _ => { }\n             }\n@@ -553,7 +553,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             self.bccx.span_note(\n                 old_loan.span,\n-                &format!(\"{}; {}\", borrow_summary, rule_summary)[]);\n+                &format!(\"{}; {}\", borrow_summary, rule_summary));\n \n             let old_loan_span = self.tcx().map.span(old_loan.kill_scope.node_id());\n             self.bccx.span_end_note(old_loan_span,\n@@ -623,13 +623,13 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 self.bccx.span_err(\n                     span,\n                     &format!(\"cannot use `{}` because it was mutably borrowed\",\n-                            &self.bccx.loan_path_to_string(copy_path)[])\n-                    []);\n+                            &self.bccx.loan_path_to_string(copy_path))\n+                    );\n                 self.bccx.span_note(\n                     loan_span,\n                     &format!(\"borrow of `{}` occurs here\",\n-                            &self.bccx.loan_path_to_string(&*loan_path)[])\n-                    []);\n+                            &self.bccx.loan_path_to_string(&*loan_path))\n+                    );\n             }\n         }\n     }\n@@ -648,20 +648,20 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 let err_message = match move_kind {\n                     move_data::Captured =>\n                         format!(\"cannot move `{}` into closure because it is borrowed\",\n-                                &self.bccx.loan_path_to_string(move_path)[]),\n+                                &self.bccx.loan_path_to_string(move_path)),\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat =>\n                         format!(\"cannot move out of `{}` because it is borrowed\",\n-                                &self.bccx.loan_path_to_string(move_path)[])\n+                                &self.bccx.loan_path_to_string(move_path))\n                 };\n \n                 self.bccx.span_err(span, &err_message[..]);\n                 self.bccx.span_note(\n                     loan_span,\n                     &format!(\"borrow of `{}` occurs here\",\n-                            &self.bccx.loan_path_to_string(&*loan_path)[])\n-                    []);\n+                            &self.bccx.loan_path_to_string(&*loan_path))\n+                    );\n             }\n         }\n     }\n@@ -842,7 +842,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                     self.bccx.span_err(\n                         assignment_span,\n                         &format!(\"cannot assign to {}\",\n-                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n+                                self.bccx.cmt_to_string(&*assignee_cmt)));\n                     self.bccx.span_help(\n                         self.tcx().map.span(upvar_id.closure_expr_id),\n                         \"consider changing this closure to take self by mutable reference\");\n@@ -851,7 +851,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         assignment_span,\n                         &format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n+                                self.bccx.cmt_to_string(&*assignee_cmt)));\n                 }\n             }\n             _ => match opt_loan_path(&assignee_cmt) {\n@@ -861,14 +861,14 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                         &format!(\"cannot assign to {} {} `{}`\",\n                                 assignee_cmt.mutbl.to_user_str(),\n                                 self.bccx.cmt_to_string(&*assignee_cmt),\n-                                self.bccx.loan_path_to_string(&*lp))[]);\n+                                self.bccx.loan_path_to_string(&*lp)));\n                 }\n                 None => {\n                     self.bccx.span_err(\n                         assignment_span,\n                         &format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n+                                self.bccx.cmt_to_string(&*assignee_cmt)));\n                 }\n             }\n         }\n@@ -988,10 +988,10 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n         self.bccx.span_err(\n             span,\n             &format!(\"cannot assign to `{}` because it is borrowed\",\n-                    self.bccx.loan_path_to_string(loan_path))[]);\n+                    self.bccx.loan_path_to_string(loan_path)));\n         self.bccx.span_note(\n             loan.span,\n             &format!(\"borrow of `{}` occurs here\",\n-                    self.bccx.loan_path_to_string(loan_path))[]);\n+                    self.bccx.loan_path_to_string(loan_path)));\n     }\n }"}, {"sha": "41ccee4f8fbf0bd21b5449c01519dd56c7468922", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -123,12 +123,12 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         let attrs : &[ast::Attribute];\n         attrs = match tcx.map.find(id) {\n             Some(ast_map::NodeItem(ref item)) =>\n-                &item.attrs[],\n+                &item.attrs,\n             Some(ast_map::NodeImplItem(&ast::MethodImplItem(ref m))) =>\n-                &m.attrs[],\n+                &m.attrs,\n             Some(ast_map::NodeTraitItem(&ast::ProvidedMethod(ref m))) =>\n-                &m.attrs[],\n-            _ => &[][],\n+                &m.attrs,\n+            _ => &[],\n         };\n \n         let span_err =\n@@ -144,7 +144,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, mpi) in vec_rc.iter().enumerate() {\n             let render = || this.path_loan_path(*mpi).user_string(tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render())[]);\n+                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render()));\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n@@ -156,7 +156,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, f) in vec_rc.iter().enumerate() {\n             let render = || f.loan_path_user_string(this, tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render())[]);\n+                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render()));\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());"}, {"sha": "333aef81390bfe892370c5770ee50a121f55ffc7", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -307,7 +307,7 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n                             &format!(\"invalid borrow lifetime: {:?}\",\n-                                    loan_region)[]);\n+                                    loan_region));\n                     }\n                 };\n                 debug!(\"loan_scope = {:?}\", loan_scope);"}, {"sha": "53761eb14713def82f45a671a5a2dc45a3f6daab", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -121,7 +121,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_static_item => {\n             bccx.span_err(move_from.span,\n                           &format!(\"cannot move out of {}\",\n-                                  move_from.descriptive_string(bccx.tcx))[]);\n+                                  move_from.descriptive_string(bccx.tcx)));\n         }\n \n         mc::cat_interior(ref b, mc::InteriorElement(Kind::Index, _)) => {\n@@ -130,7 +130,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                 bccx.span_err(move_from.span,\n                               &format!(\"cannot move out of type `{}`, \\\n                                         a non-copy fixed-size array\",\n-                                       b.ty.user_string(bccx.tcx))[]);\n+                                       b.ty.user_string(bccx.tcx)));\n             }\n         }\n \n@@ -143,7 +143,7 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                         move_from.span,\n                         &format!(\"cannot move out of type `{}`, \\\n                                  which defines the `Drop` trait\",\n-                                b.ty.user_string(bccx.tcx))[]);\n+                                b.ty.user_string(bccx.tcx)));\n                 },\n                 _ => {\n                     bccx.span_bug(move_from.span, \"this path should not cause illegal move\")\n@@ -170,10 +170,10 @@ fn note_move_destination(bccx: &BorrowckCtxt,\n             &format!(\"to prevent the move, \\\n                      use `ref {0}` or `ref mut {0}` to capture value by \\\n                      reference\",\n-                    pat_name)[]);\n+                    pat_name));\n     } else {\n         bccx.span_note(move_to_span,\n                        &format!(\"and here (use `ref {0}` or `ref mut {0}`)\",\n-                               pat_name)[]);\n+                               pat_name));\n     }\n }"}, {"sha": "dfd98881ace86afc38a1b2f38cc29ad9fd6d638c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -524,7 +524,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report(&self, err: BckError<'tcx>) {\n         self.span_err(\n             err.span,\n-            &self.bckerr_to_string(&err)[]);\n+            &self.bckerr_to_string(&err));\n         self.note_and_explain_bckerr(err);\n     }\n \n@@ -546,7 +546,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     use_span,\n                     &format!(\"{} of possibly uninitialized variable: `{}`\",\n                             verb,\n-                            self.loan_path_to_string(lp))[]);\n+                            self.loan_path_to_string(lp)));\n                 (self.loan_path_to_string(moved_lp),\n                  String::new())\n             }\n@@ -588,7 +588,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     &format!(\"{} of {}moved value: `{}`\",\n                             verb,\n                             msg,\n-                            nl)[]);\n+                            nl));\n                 (ol, moved_lp_msg)\n             }\n         };\n@@ -607,7 +607,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         self.tcx.sess.bug(&format!(\"MoveExpr({}) maps to \\\n                                                    {:?}, not Expr\",\n                                                   the_move.id,\n-                                                  r)[])\n+                                                  r))\n                     }\n                 };\n                 let (suggestion, _) =\n@@ -618,7 +618,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion)[]);\n+                            suggestion));\n             }\n \n             move_data::MovePat => {\n@@ -629,7 +629,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                              which is moved by default\",\n                             ol,\n                             moved_lp_msg,\n-                            pat_ty.user_string(self.tcx))[]);\n+                            pat_ty.user_string(self.tcx)));\n                 self.tcx.sess.span_help(span,\n                     \"use `ref` to override\");\n             }\n@@ -645,7 +645,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         self.tcx.sess.bug(&format!(\"Captured({}) maps to \\\n                                                    {:?}, not Expr\",\n                                                   the_move.id,\n-                                                  r)[])\n+                                                  r))\n                     }\n                 };\n                 let (suggestion, help) =\n@@ -661,7 +661,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion)[]);\n+                            suggestion));\n                 self.tcx.sess.span_help(expr_span, help);\n             }\n         }\n@@ -704,7 +704,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         self.tcx.sess.span_err(\n             span,\n             &format!(\"re-assignment of immutable variable `{}`\",\n-                    self.loan_path_to_string(lp))[]);\n+                    self.loan_path_to_string(lp)));\n         self.tcx.sess.span_note(assign.span, \"prior assignment occurs here\");\n     }\n \n@@ -825,7 +825,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 self.tcx.sess.span_err(\n                     span,\n                     &format!(\"{} in an aliasable location\",\n-                             prefix)[]);\n+                             prefix));\n             }\n             mc::AliasableClosure(id) => {\n                 self.tcx.sess.span_err(span,\n@@ -847,12 +847,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             mc::AliasableStaticMut(..) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    &format!(\"{} in a static location\", prefix)[]);\n+                    &format!(\"{} in a static location\", prefix));\n             }\n             mc::AliasableBorrowed => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    &format!(\"{} in a `&` reference\", prefix)[]);\n+                    &format!(\"{} in a `&` reference\", prefix));\n             }\n         }\n \n@@ -920,12 +920,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 note_and_explain_region(\n                     self.tcx,\n                     &format!(\"{} would have to be valid for \",\n-                            descr)[],\n+                            descr),\n                     loan_scope,\n                     \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    &format!(\"...but {} is only valid for \", descr)[],\n+                    &format!(\"...but {} is only valid for \", descr),\n                     ptr_scope,\n                     \"\");\n             }\n@@ -945,7 +945,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_loan_path_to_string(&**lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(&ty::item_path_str(self.tcx, variant_def_id)[]);\n+                out.push_str(&ty::item_path_str(self.tcx, variant_def_id));\n                 out.push(')');\n             }\n \n@@ -959,7 +959,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push('.');\n-                        out.push_str(&idx.to_string()[]);\n+                        out.push_str(&idx.to_string());\n                     }\n                 }\n             }\n@@ -991,7 +991,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 out.push(':');\n-                out.push_str(&ty::item_path_str(self.tcx, variant_def_id)[]);\n+                out.push_str(&ty::item_path_str(self.tcx, variant_def_id));\n                 out.push(')');\n             }\n "}, {"sha": "4465000d8d81e1298111ca0129d58034aa96e98b", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n             if seen_one { sets.push_str(\" \"); } else { seen_one = true; }\n             sets.push_str(variant.short_name());\n             sets.push_str(\": \");\n-            sets.push_str(&self.dataflow_for_variant(e, n, variant)[]);\n+            sets.push_str(&self.dataflow_for_variant(e, n, variant));\n         }\n         sets\n     }"}, {"sha": "b12f05d7c50f75b527322f2a4af9c7b9d41101eb", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -77,10 +77,10 @@ pub fn compile_input(sess: Session,\n             let outputs = build_output_filenames(input,\n                                                  outdir,\n                                                  output,\n-                                                 &krate.attrs[],\n+                                                 &krate.attrs,\n                                                  &sess);\n             let id = link::find_crate_name(Some(&sess),\n-                                           &krate.attrs[],\n+                                           &krate.attrs,\n                                            input);\n             let expanded_crate\n                 = match phase_2_configure_and_expand(&sess,\n@@ -378,9 +378,9 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let time_passes = sess.time_passes();\n \n     *sess.crate_types.borrow_mut() =\n-        collect_crate_types(sess, &krate.attrs[]);\n+        collect_crate_types(sess, &krate.attrs);\n     *sess.crate_metadata.borrow_mut() =\n-        collect_crate_metadata(sess, &krate.attrs[]);\n+        collect_crate_metadata(sess, &krate.attrs);\n \n     time(time_passes, \"recursion limit\", (), |_| {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n@@ -724,7 +724,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             write::run_passes(sess,\n                               trans,\n-                              &sess.opts.output_types[],\n+                              &sess.opts.output_types,\n                               outputs));\n     }\n \n@@ -745,7 +745,7 @@ pub fn phase_6_link_output(sess: &Session,\n          link::link_binary(sess,\n                            trans,\n                            outputs,\n-                           &trans.link.crate_name[]));\n+                           &trans.link.crate_name));\n \n     env::set_var(\"PATH\", &old_path);\n }\n@@ -799,7 +799,7 @@ fn write_out_deps(sess: &Session,\n         // write Makefile-compatible dependency rules\n         let files: Vec<String> = sess.codemap().files.borrow()\n                                    .iter().filter(|fmap| fmap.is_real_file())\n-                                   .map(|fmap| escape_dep_filename(&fmap.name[]))\n+                                   .map(|fmap| escape_dep_filename(&fmap.name))\n                                    .collect();\n         let mut file = try!(old_io::File::create(&deps_filename));\n         for path in &out_filenames {\n@@ -813,7 +813,7 @@ fn write_out_deps(sess: &Session,\n         Ok(()) => {}\n         Err(e) => {\n             sess.fatal(&format!(\"error writing dependencies to `{}`: {}\",\n-                               deps_filename.display(), e)[]);\n+                               deps_filename.display(), e));\n         }\n     }\n }\n@@ -884,7 +884,7 @@ pub fn collect_crate_types(session: &Session,\n         if !res {\n             session.warn(&format!(\"dropping unsupported crate type `{}` \\\n                                    for target `{}`\",\n-                                 *crate_type, session.opts.target_triple)[]);\n+                                 *crate_type, session.opts.target_triple));\n         }\n \n         res"}, {"sha": "0fbfeb831850f2d7dc9e4e37cb081899ac5c4029", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -124,7 +124,7 @@ pub fn run_compiler<'a>(args: &[String],\n     let sopts = config::build_session_options(&matches);\n \n     let (odir, ofile) = make_output(&matches);\n-    let (input, input_file_path) = match make_input(&matches.free[]) {\n+    let (input, input_file_path) = match make_input(&matches.free) {\n         Some((input, input_file_path)) => callbacks.some_input(input, input_file_path),\n         None => match callbacks.no_input(&matches, &sopts, &odir, &ofile, &descriptions) {\n             Some((input, input_file_path)) => (input, input_file_path),\n@@ -166,7 +166,7 @@ fn make_output(matches: &getopts::Matches) -> (Option<Path>, Option<Path>) {\n // Extract input (string or file and optional path) from matches.\n fn make_input(free_matches: &[String]) -> Option<(Input, Option<Path>)> {\n     if free_matches.len() == 1 {\n-        let ifile = &free_matches[0][];\n+        let ifile = &free_matches[0][..];\n         if ifile == \"-\" {\n             let contents = old_io::stdin().read_to_end().unwrap();\n             let src = String::from_utf8(contents).unwrap();\n@@ -277,7 +277,7 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                         println!(\"{}\", description);\n                     }\n                     None => {\n-                        early_error(&format!(\"no extended information for {}\", code)[]);\n+                        early_error(&format!(\"no extended information for {}\", code));\n                     }\n                 }\n                 return Compilation::Stop;\n@@ -680,7 +680,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     }\n \n     let matches =\n-        match getopts::getopts(&args[..], &config::optgroups()[]) {\n+        match getopts::getopts(&args[..], &config::optgroups()) {\n             Ok(m) => m,\n             Err(f_stable_attempt) => {\n                 // redo option parsing, including unstable options this time,\n@@ -813,7 +813,7 @@ pub fn monitor<F:FnOnce()+Send+'static>(f: F) {\n                     Err(e) => {\n                         emitter.emit(None,\n                                      &format!(\"failed to read internal \\\n-                                              stderr: {}\", e)[],\n+                                              stderr: {}\", e),\n                                      None,\n                                      diagnostic::Error)\n                     }"}, {"sha": "3f9fdd28e4405acaa10ed21cfdf7c311623670d4", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -312,7 +312,7 @@ impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n                 try!(pp::word(&mut s.s,\n                               &ppaux::ty_to_string(\n                                   tcx,\n-                                  ty::expr_ty(tcx, expr))[]));\n+                                  ty::expr_ty(tcx, expr))));\n                 s.pclose()\n             }\n             _ => Ok(())\n@@ -602,15 +602,15 @@ pub fn pretty_print_input(sess: Session,\n             debug!(\"pretty printing flow graph for {:?}\", opt_uii);\n             let uii = opt_uii.unwrap_or_else(|| {\n                 sess.fatal(&format!(\"`pretty flowgraph=..` needs NodeId (int) or\n-                                     unique path suffix (b::c::d)\")[])\n+                                     unique path suffix (b::c::d)\"))\n \n             });\n             let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n             let nodeid = uii.to_one_node_id(\"--pretty\", &sess, &ast_map);\n \n             let node = ast_map.find(nodeid).unwrap_or_else(|| {\n                 sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\",\n-                                   nodeid)[])\n+                                   nodeid))\n             });\n \n             let code = blocks::Code::from_node(node);"}, {"sha": "eae02e0bf66c4768f78123b2e5f4c5c4125ab1bf", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -712,7 +712,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                              method_id,\n                                              None,\n                                              &format!(\"method `{}`\",\n-                                                     string)[]));\n+                                                     string)));\n     }\n \n     // Checks that a path is in scope.\n@@ -727,7 +727,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 self.ensure_public(span,\n                                    def,\n                                    Some(origdid),\n-                                   &format!(\"{} `{}`\", tyname, name)[])\n+                                   &format!(\"{} `{}`\", tyname, name))\n             };\n \n             match self.last_private_map[path_id] {"}, {"sha": "3b3106af818b3ea1688298c53b440bdc0da4f141", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -220,14 +220,14 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     self.resolve_error(sp,\n                         &format!(\"duplicate definition of {} `{}`\",\n                              namespace_error_to_string(duplicate_type),\n-                             token::get_name(name))[]);\n+                             token::get_name(name)));\n                     {\n                         let r = child.span_for_namespace(ns);\n                         if let Some(sp) = r {\n                             self.session.span_note(sp,\n                                  &format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_string(duplicate_type),\n-                                      token::get_name(name))[]);\n+                                      token::get_name(name)));\n                         }\n                     }\n                 }\n@@ -307,8 +307,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     ViewPathSimple(binding, ref full_path) => {\n                         let source_name =\n                             full_path.segments.last().unwrap().identifier.name;\n-                        if &token::get_name(source_name)[] == \"mod\" ||\n-                           &token::get_name(source_name)[] == \"self\" {\n+                        if &token::get_name(source_name)[..] == \"mod\" ||\n+                           &token::get_name(source_name)[..] == \"self\" {\n                             self.resolve_error(view_path.span,\n                                 \"`self` imports are only allowed within a { } list\");\n                         }\n@@ -1192,7 +1192,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 debug!(\"(building import directive) building import \\\n                         directive: {}::{}\",\n                        self.names_to_string(&module_.imports.borrow().last().unwrap().\n-                                                             module_path[]),\n+                                                             module_path),\n                        token::get_name(target));\n \n                 let mut import_resolutions = module_.import_resolutions"}, {"sha": "062ea885bf40a578a9f763c693c9acd80c5bdbb8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -1068,7 +1068,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     };\n                     let msg = format!(\"unresolved import `{}`{}\",\n                                       self.import_path_to_string(\n-                                          &import_directive.module_path[],\n+                                          &import_directive.module_path,\n                                           import_directive.subclass),\n                                       help);\n                     self.resolve_error(span, &msg[..]);\n@@ -2247,7 +2247,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               true) {\n                 Failed(Some((span, msg))) =>\n                     self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                     msg)[]),\n+                                                     msg)),\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n                     // We couldn't see through the higher scope because of an\n@@ -2603,7 +2603,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match def_like {\n             DlDef(d @ DefUpvar(..)) => {\n                 self.session.span_bug(span,\n-                    &format!(\"unexpected {:?} in bindings\", d)[])\n+                    &format!(\"unexpected {:?} in bindings\", d))\n             }\n             DlDef(d @ DefLocal(_)) => {\n                 let node_id = d.def_id().node;\n@@ -2931,7 +2931,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 self.resolve_struct(item.id,\n                                     generics,\n-                                    &struct_def.fields[]);\n+                                    &struct_def.fields);\n             }\n \n             ItemMod(ref module_) => {\n@@ -3019,7 +3019,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                     parameter in this type \\\n                                                     parameter list\",\n                                                    token::get_name(\n-                                                       name))[])\n+                                                       name)))\n                     }\n                     seen_bindings.insert(name);\n \n@@ -3204,14 +3204,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.resolve_error(trait_reference.path.span,\n                                            &format!(\"`{}` is not a trait\",\n                                                    self.path_names_to_string(\n-                                                       &trait_reference.path))[]);\n+                                                       &trait_reference.path)));\n \n                         // If it's a typedef, give a note\n                         if let DefTy(..) = def {\n                             self.session.span_note(\n                                 trait_reference.path.span,\n                                 &format!(\"`type` aliases cannot be used for traits\")\n-                                []);\n+                                );\n                         }\n                     }\n                 }\n@@ -3408,7 +3408,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 self.resolve_error(span,\n                                     &format!(\"method `{}` is not a member of trait `{}`\",\n                                             token::get_name(name),\n-                                            path_str)[]);\n+                                            path_str));\n             }\n         }\n     }\n@@ -3477,7 +3477,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         &format!(\"variable `{}` from pattern #1 is \\\n                                   not bound in pattern #{}\",\n                                 token::get_name(key),\n-                                i + 1)[]);\n+                                i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n@@ -3486,7 +3486,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             &format!(\"variable `{}` is bound with different \\\n                                       mode in pattern #{} than in pattern #1\",\n                                     token::get_name(key),\n-                                    i + 1)[]);\n+                                    i + 1));\n                     }\n                   }\n                 }\n@@ -3499,7 +3499,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         &format!(\"variable `{}` from pattern {}{} is \\\n                                   not bound in pattern {}1\",\n                                 token::get_name(key),\n-                                \"#\", i + 1, \"#\")[]);\n+                                \"#\", i + 1, \"#\"));\n                 }\n             }\n         }\n@@ -3698,7 +3698,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 &format!(\"declaration of `{}` shadows an enum \\\n                                          variant or unit-like struct in \\\n                                          scope\",\n-                                        token::get_name(renamed))[]);\n+                                        token::get_name(renamed)));\n                         }\n                         FoundConst(ref def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n@@ -3750,7 +3750,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                             list\",\n                                                            token::get_ident(\n                                                                ident))\n-                                                   [])\n+                                                   )\n                             } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n@@ -3759,7 +3759,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     &format!(\"identifier `{}` is bound \\\n                                              more than once in the same \\\n                                              pattern\",\n-                                            token::get_ident(ident))[]);\n+                                            token::get_ident(ident)));\n                             }\n                             // Else, not bound in the same pattern: do\n                             // nothing.\n@@ -3883,7 +3883,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match err {\n                     Some((span, msg)) => {\n                         self.resolve_error(span, &format!(\"failed to resolve: {}\",\n-                                                         msg)[]);\n+                                                         msg));\n                     }\n                     None => ()\n                 }\n@@ -4093,7 +4093,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                 msg)[]);\n+                                                 msg));\n                 return None;\n             }\n             Indeterminate => panic!(\"indeterminate unexpected\"),\n@@ -4152,7 +4152,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                 msg)[]);\n+                                                 msg));\n                 return None;\n             }\n \n@@ -4193,7 +4193,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n             TypeNS => {\n                 let name = ident.name;\n-                self.search_ribs(&self.type_ribs[], name, span)\n+                self.search_ribs(&self.type_ribs, name, span)\n             }\n         };\n \n@@ -4248,7 +4248,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match err {\n                     Some((span, msg)) =>\n                         self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                         msg)[]),\n+                                                         msg)),\n                     None => ()\n                 }\n \n@@ -4410,7 +4410,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             values[smallest] != usize::MAX &&\n             values[smallest] < name.len() + 2 &&\n             values[smallest] <= max_distance &&\n-            name != &maybes[smallest][] {\n+            name != &maybes[smallest][..] {\n \n             Some(maybes[smallest].to_string())\n \n@@ -4502,7 +4502,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     false // Stop advancing\n                                 });\n \n-                                if method_scope && &token::get_name(self.self_name)[]\n+                                if method_scope && &token::get_name(self.self_name)[..]\n                                                                    == path_name {\n                                         self.resolve_error(\n                                             expr.span,\n@@ -4592,7 +4592,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         self.resolve_error(\n                             expr.span,\n                             &format!(\"use of undeclared label `{}`\",\n-                                    token::get_ident(label))[])\n+                                    token::get_ident(label)))\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n@@ -4731,7 +4731,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                   then {:?}\",\n                                  node_id,\n                                  *entry.get(),\n-                                 def)[]);\n+                                 def));\n             },\n             Vacant(entry) => { entry.insert(def); },\n         }\n@@ -4747,7 +4747,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 self.resolve_error(pat.span,\n                                    &format!(\"cannot use `ref` binding mode \\\n                                             with {}\",\n-                                           descr)[]);\n+                                           descr));\n             }\n         }\n     }\n@@ -4783,7 +4783,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             return \"???\".to_string();\n         }\n         self.names_to_string(&names.into_iter().rev()\n-                                  .collect::<Vec<ast::Name>>()[])\n+                                  .collect::<Vec<ast::Name>>())\n     }\n \n     #[allow(dead_code)]   // useful for debugging"}, {"sha": "ea5001aa814b49ab5dab7f8be7c047e8f6456498", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -191,17 +191,17 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    symbol_hasher.input_str(&link_meta.crate_name[]);\n+    symbol_hasher.input_str(&link_meta.crate_name);\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     for meta in &*tcx.sess.crate_metadata.borrow() {\n         symbol_hasher.input_str(&meta[..]);\n     }\n     symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input_str(&encoder::encoded_ty(tcx, t)[]);\n+    symbol_hasher.input_str(&encoder::encoded_ty(tcx, t));\n     // Prefix with 'h' so that it never blends into adjacent digits\n     let mut hash = String::from_str(\"h\");\n-    hash.push_str(&truncated_hash_result(symbol_hasher)[]);\n+    hash.push_str(&truncated_hash_result(symbol_hasher));\n     hash\n }\n \n@@ -288,7 +288,7 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(path: PI,\n \n     fn push(n: &mut String, s: &str) {\n         let sani = sanitize(s);\n-        n.push_str(&format!(\"{}{}\", sani.len(), sani)[]);\n+        n.push_str(&format!(\"{}{}\", sani.len(), sani));\n     }\n \n     // First, connect each component with <len, name> pairs.\n@@ -361,7 +361,7 @@ pub fn remove(sess: &Session, path: &Path) {\n         Err(e) => {\n             sess.err(&format!(\"failed to remove {}: {}\",\n                              path.display(),\n-                             e)[]);\n+                             e));\n         }\n     }\n }\n@@ -376,7 +376,7 @@ pub fn link_binary(sess: &Session,\n     for &crate_type in &*sess.crate_types.borrow() {\n         if invalid_output_for_target(sess, crate_type) {\n             sess.bug(&format!(\"invalid output type `{:?}` for target os `{}`\",\n-                             crate_type, sess.opts.target_triple)[]);\n+                             crate_type, sess.opts.target_triple));\n         }\n         let out_file = link_binary_output(sess, trans, crate_type, outputs,\n                                           crate_name);\n@@ -441,8 +441,8 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeDylib => {\n-            let (prefix, suffix) = (&sess.target.target.options.dll_prefix[],\n-                                    &sess.target.target.options.dll_suffix[]);\n+            let (prefix, suffix) = (&sess.target.target.options.dll_prefix,\n+                                    &sess.target.target.options.dll_suffix);\n             out_filename.with_filename(format!(\"{}{}{}\",\n                                                prefix,\n                                                libname,\n@@ -452,7 +452,7 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.a\", libname))\n         }\n         config::CrateTypeExecutable => {\n-            let suffix = &sess.target.target.options.exe_suffix[];\n+            let suffix = &sess.target.target.options.exe_suffix;\n             out_filename.with_filename(format!(\"{}{}\", libname, suffix))\n         }\n     }\n@@ -481,12 +481,12 @@ fn link_binary_output(sess: &Session,\n     if !out_is_writeable {\n         sess.fatal(&format!(\"output file {} is not writeable -- check its \\\n                             permissions.\",\n-                           out_filename.display())[]);\n+                           out_filename.display()));\n     }\n     else if !obj_is_writeable {\n         sess.fatal(&format!(\"object file {} is not writeable -- check its \\\n                             permissions.\",\n-                           obj_filename.display())[]);\n+                           obj_filename.display()));\n     }\n \n     match crate_type {\n@@ -588,12 +588,12 @@ fn link_rlib<'a>(sess: &'a Session,\n             // the same filename for metadata (stomping over one another)\n             let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n-            match fs::File::create(&metadata).write_all(&trans.metadata[]) {\n+            match fs::File::create(&metadata).write_all(&trans.metadata) {\n                 Ok(..) => {}\n                 Err(e) => {\n                     sess.err(&format!(\"failed to write {}: {}\",\n                                      metadata.display(),\n-                                     e)[]);\n+                                     e));\n                     sess.abort_if_errors();\n                 }\n             }\n@@ -611,25 +611,25 @@ fn link_rlib<'a>(sess: &'a Session,\n                 // was exactly 16 bytes.\n                 let bc_filename = obj_filename.with_extension(&format!(\"{}.bc\", i));\n                 let bc_deflated_filename = obj_filename.with_extension(\n-                    &format!(\"{}.bytecode.deflate\", i)[]);\n+                    &format!(\"{}.bytecode.deflate\", i));\n \n                 let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n                     Ok(buffer) => buffer,\n                     Err(e) => sess.fatal(&format!(\"failed to read bytecode: {}\",\n-                                                 e)[])\n+                                                 e))\n                 };\n \n                 let bc_data_deflated = match flate::deflate_bytes(&bc_data[..]) {\n                     Some(compressed) => compressed,\n                     None => sess.fatal(&format!(\"failed to compress bytecode from {}\",\n-                                               bc_filename.display())[])\n+                                               bc_filename.display()))\n                 };\n \n                 let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n                     Ok(file) => file,\n                     Err(e) => {\n                         sess.fatal(&format!(\"failed to create compressed bytecode \\\n-                                            file: {}\", e)[])\n+                                            file: {}\", e))\n                     }\n                 };\n \n@@ -638,7 +638,7 @@ fn link_rlib<'a>(sess: &'a Session,\n                     Ok(()) => {}\n                     Err(e) => {\n                         sess.err(&format!(\"failed to write compressed bytecode: \\\n-                                          {}\", e)[]);\n+                                          {}\", e));\n                         sess.abort_if_errors()\n                     }\n                 };\n@@ -729,7 +729,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n                 sess.err(&format!(\"could not find rlib for: `{}`\",\n-                                 name)[]);\n+                                 name));\n                 continue\n             }\n         };\n@@ -755,7 +755,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n             cstore::NativeUnknown => \"library\",\n             cstore::NativeFramework => \"framework\",\n         };\n-        sess.note(&format!(\"{}: {}\", name, *lib)[]);\n+        sess.note(&format!(\"{}: {}\", name, *lib));\n     }\n }\n \n@@ -771,10 +771,10 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     let pname = get_cc_prog(sess);\n     let mut cmd = Command::new(&pname[..]);\n \n-    cmd.args(&sess.target.target.options.pre_link_args[]);\n+    cmd.args(&sess.target.target.options.pre_link_args);\n     link_args(&mut cmd, sess, dylib, tmpdir.path(),\n               trans, obj_filename, out_filename);\n-    cmd.args(&sess.target.target.options.post_link_args[]);\n+    cmd.args(&sess.target.target.options.post_link_args);\n     if !sess.target.target.options.no_compiler_rt {\n         cmd.arg(\"-lcompiler-rt\");\n     }\n@@ -794,10 +794,10 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n             if !prog.status.success() {\n                 sess.err(&format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status)[]);\n-                sess.note(&format!(\"{:?}\", &cmd)[]);\n+                                 prog.status));\n+                sess.note(&format!(\"{:?}\", &cmd));\n                 let mut output = prog.error.clone();\n-                output.push_all(&prog.output[]);\n+                output.push_all(&prog.output);\n                 sess.note(str::from_utf8(&output[..]).unwrap());\n                 sess.abort_if_errors();\n             }\n@@ -807,7 +807,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         Err(e) => {\n             sess.err(&format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e)[]);\n+                             e));\n             sess.abort_if_errors();\n         }\n     }\n@@ -819,7 +819,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         match Command::new(\"dsymutil\").arg(out_filename).output() {\n             Ok(..) => {}\n             Err(e) => {\n-                sess.err(&format!(\"failed to run dsymutil: {}\", e)[]);\n+                sess.err(&format!(\"failed to run dsymutil: {}\", e));\n                 sess.abort_if_errors();\n             }\n         }\n@@ -1005,7 +1005,7 @@ fn link_args(cmd: &mut Command,\n     // addl_lib_search_paths\n     if sess.opts.cg.rpath {\n         let sysroot = sess.sysroot();\n-        let target_triple = &sess.opts.target_triple[];\n+        let target_triple = &sess.opts.target_triple;\n         let get_install_prefix_lib_path = || {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n             let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n@@ -1022,13 +1022,13 @@ fn link_args(cmd: &mut Command,\n             get_install_prefix_lib_path: get_install_prefix_lib_path,\n             realpath: ::util::fs::realpath\n         };\n-        cmd.args(&rpath::get_rpath_flags(rpath_config)[]);\n+        cmd.args(&rpath::get_rpath_flags(rpath_config));\n     }\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n     let empty = Vec::new();\n-    cmd.args(&sess.opts.cg.link_args.as_ref().unwrap_or(&empty)[]);\n+    cmd.args(&sess.opts.cg.link_args.as_ref().unwrap_or(&empty));\n     cmd.args(&used_link_args[..]);\n }\n \n@@ -1189,7 +1189,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n             let name = cratepath.filename_str().unwrap();\n             let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n             time(sess.time_passes(),\n-                 &format!(\"altering {}.rlib\", name)[],\n+                 &format!(\"altering {}.rlib\", name),\n                  (), |()| {\n                 let dst = tmpdir.join(cratepath.filename().unwrap());\n                 match fs::copy(&cratepath, &dst) {\n@@ -1198,7 +1198,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                         sess.err(&format!(\"failed to copy {} to {}: {}\",\n                                          cratepath.display(),\n                                          dst.display(),\n-                                         e)[]);\n+                                         e));\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1210,7 +1210,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     Err(e) => {\n                         sess.err(&format!(\"failed to chmod {} when preparing \\\n                                           for LTO: {}\", dst.display(),\n-                                         e)[]);\n+                                         e));\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1224,9 +1224,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     maybe_ar_prog: sess.opts.cg.ar.clone()\n                 };\n                 let mut archive = Archive::open(config);\n-                archive.remove_file(&format!(\"{}.o\", name)[]);\n+                archive.remove_file(&format!(\"{}.o\", name));\n                 let files = archive.files();\n-                if files.iter().any(|s| s[].ends_with(\".o\")) {\n+                if files.iter().any(|s| s.ends_with(\".o\")) {\n                     cmd.arg(dst);\n                 }\n             });"}, {"sha": "9507da2febbdb235f04b87a961eecd8722e06b32", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -54,7 +54,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             Some(p) => p,\n             None => {\n                 sess.fatal(&format!(\"could not find rlib for: `{}`\",\n-                                   name)[]);\n+                                   name));\n             }\n         };\n \n@@ -68,15 +68,15 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                                   (),\n                                   |_| {\n                                       archive.read(&format!(\"{}.{}.bytecode.deflate\",\n-                                                           file, i)[])\n+                                                           file, i))\n                                   });\n             let bc_encoded = match bc_encoded {\n                 Some(data) => data,\n                 None => {\n                     if i == 0 {\n                         // No bitcode was found at all.\n                         sess.fatal(&format!(\"missing compressed bytecode in {}\",\n-                                           path.display())[]);\n+                                           path.display()));\n                     }\n                     // No more bitcode files to read.\n                     break;\n@@ -99,12 +99,12 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                             Some(inflated) => inflated,\n                             None => {\n                                 sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n-                                                   name)[])\n+                                                   name))\n                             }\n                         }\n                     } else {\n                         sess.fatal(&format!(\"Unsupported bytecode format version {}\",\n-                                           version)[])\n+                                           version))\n                     }\n                 })\n             } else {\n@@ -115,7 +115,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                         Some(bc) => bc,\n                         None => {\n                             sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n-                                               name)[])\n+                                               name))\n                         }\n                     }\n                 })\n@@ -124,7 +124,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             let ptr = bc_decoded.as_ptr();\n             debug!(\"linking {}, part {}\", name, i);\n             time(sess.time_passes(),\n-                 &format!(\"ll link {}.{}\", name, i)[],\n+                 &format!(\"ll link {}.{}\", name, i),\n                  (),\n                  |()| unsafe {\n                 if !llvm::LLVMRustLinkInExternalBitcode(llmod,"}, {"sha": "a1fc63778ce8af858a5bda6b5a935b2c7fa81571", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -54,7 +54,7 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n             libc::free(cstr as *mut _);\n             handler.fatal(&format!(\"{}: {}\",\n                                   &msg[..],\n-                                  &err[..])[]);\n+                                  &err[..]));\n         }\n     }\n }\n@@ -104,13 +104,13 @@ impl SharedEmitter {\n             match diag.code {\n                 Some(ref code) => {\n                     handler.emit_with_code(None,\n-                                           &diag.msg[],\n+                                           &diag.msg,\n                                            &code[..],\n                                            diag.lvl);\n                 },\n                 None => {\n                     handler.emit(None,\n-                                 &diag.msg[],\n+                                 &diag.msg,\n                                  diag.lvl);\n                 },\n             }\n@@ -166,7 +166,7 @@ fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n         Some(ref s) => &s[..],\n-        None => &sess.target.target.options.relocation_model[]\n+        None => &sess.target.target.options.relocation_model[..],\n     };\n     let reloc_model = match reloc_model_arg {\n         \"pic\" => llvm::RelocPIC,\n@@ -177,7 +177,7 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n             sess.err(&format!(\"{:?} is not a valid relocation mode\",\n                              sess.opts\n                                  .cg\n-                                 .relocation_model)[]);\n+                                 .relocation_model));\n             sess.abort_if_errors();\n             unreachable!();\n         }\n@@ -199,7 +199,7 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n \n     let code_model_arg = match sess.opts.cg.code_model {\n         Some(ref s) => &s[..],\n-        None => &sess.target.target.options.code_model[]\n+        None => &sess.target.target.options.code_model[..],\n     };\n \n     let code_model = match code_model_arg {\n@@ -212,13 +212,13 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n             sess.err(&format!(\"{:?} is not a valid code model\",\n                              sess.opts\n                                  .cg\n-                                 .code_model)[]);\n+                                 .code_model));\n             sess.abort_if_errors();\n             unreachable!();\n         }\n     };\n \n-    let triple = &sess.target.target.llvm_target[];\n+    let triple = &sess.target.target.llvm_target;\n \n     let tm = unsafe {\n         let triple = CString::new(triple.as_bytes()).unwrap();\n@@ -526,14 +526,14 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n \n         if config.emit_asm {\n-            let path = output_names.with_extension(&format!(\"{}.s\", name_extra)[]);\n+            let path = output_names.with_extension(&format!(\"{}.s\", name_extra));\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFileType);\n             });\n         }\n \n         if config.emit_obj {\n-            let path = output_names.with_extension(&format!(\"{}.o\", name_extra)[]);\n+            let path = output_names.with_extension(&format!(\"{}.o\", name_extra));\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFileType);\n             });\n@@ -647,7 +647,7 @@ pub fn run_passes(sess: &Session,\n \n     // Process the work items, optionally using worker threads.\n     if sess.opts.cg.codegen_units == 1 {\n-        run_work_singlethreaded(sess, &trans.reachable[], work_items);\n+        run_work_singlethreaded(sess, &trans.reachable, work_items);\n     } else {\n         run_work_multithreaded(sess, work_items, sess.opts.cg.codegen_units);\n     }\n@@ -679,7 +679,7 @@ pub fn run_passes(sess: &Session,\n                 // 2) Multiple codegen units, with `-o some_name`.  We have\n                 //    no good solution for this case, so warn the user.\n                 sess.warn(&format!(\"ignoring -o because multiple .{} files were produced\",\n-                                  ext)[]);\n+                                  ext));\n             } else {\n                 // 3) Multiple codegen units, but no `-o some_name`.  We\n                 //    just leave the `foo.0.x` files in place.\n@@ -713,18 +713,18 @@ pub fn run_passes(sess: &Session,\n         let pname = get_cc_prog(sess);\n         let mut cmd = Command::new(&pname[..]);\n \n-        cmd.args(&sess.target.target.options.pre_link_args[]);\n+        cmd.args(&sess.target.target.options.pre_link_args);\n         cmd.arg(\"-nostdlib\");\n \n         for index in 0..trans.modules.len() {\n-            cmd.arg(crate_output.with_extension(&format!(\"{}.o\", index)[]));\n+            cmd.arg(crate_output.with_extension(&format!(\"{}.o\", index)));\n         }\n \n         cmd.arg(\"-r\")\n            .arg(\"-o\")\n            .arg(windows_output_path.as_ref().unwrap_or(output_path));\n \n-        cmd.args(&sess.target.target.options.post_link_args[]);\n+        cmd.args(&sess.target.target.options.post_link_args);\n \n         if sess.opts.debugging_opts.print_link_args {\n             println!(\"{:?}\", &cmd);\n@@ -737,14 +737,14 @@ pub fn run_passes(sess: &Session,\n             Ok(status) => {\n                 if !status.success() {\n                     sess.err(&format!(\"linking of {} with `{:?}` failed\",\n-                                     output_path.display(), cmd)[]);\n+                                     output_path.display(), cmd));\n                     sess.abort_if_errors();\n                 }\n             },\n             Err(e) => {\n                 sess.err(&format!(\"could not exec the linker `{}`: {}\",\n                                  pname,\n-                                 e)[]);\n+                                 e));\n                 sess.abort_if_errors();\n             },\n         }\n@@ -971,18 +971,18 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n             if !prog.status.success() {\n                 sess.err(&format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status)[]);\n-                sess.note(&format!(\"{:?}\", &cmd)[]);\n+                                 prog.status));\n+                sess.note(&format!(\"{:?}\", &cmd));\n                 let mut note = prog.error.clone();\n-                note.push_all(&prog.output[]);\n+                note.push_all(&prog.output);\n                 sess.note(str::from_utf8(&note[..]).unwrap());\n                 sess.abort_if_errors();\n             }\n         },\n         Err(e) => {\n             sess.err(&format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e)[]);\n+                             e));\n             sess.abort_if_errors();\n         }\n     }\n@@ -1018,7 +1018,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         if sess.target.target.arch == \"aarch64\" { add(\"-fast-isel=0\"); }\n \n         for arg in &sess.opts.cg.llvm_args {\n-            add(&(*arg)[]);\n+            add(&(*arg));\n         }\n     }\n "}, {"sha": "28dcbe3ae86b27477e9f9cfc4497c82165e25cf1", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -94,7 +94,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         // dump info about all the external crates referenced from this crate\n         self.sess.cstore.iter_crate_data(|n, cmd| {\n-            self.fmt.external_crate_str(krate.span, &cmd.name[], n);\n+            self.fmt.external_crate_str(krate.span, &cmd.name, n);\n         });\n         self.fmt.recorder.record(\"end_external_crates\\n\");\n     }\n@@ -216,7 +216,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n         if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n             self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                  ref_id)[]);\n+                                  ref_id));\n         }\n         let def = (*self.analysis.ty_cx.def_map.borrow())[ref_id];\n         match def {\n@@ -229,7 +229,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let def_map = self.analysis.ty_cx.def_map.borrow();\n         if !def_map.contains_key(&ref_id) {\n             self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n-                                             ref_id)[]);\n+                                             ref_id));\n         }\n         let def = (*def_map)[ref_id];\n         match def {\n@@ -258,7 +258,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefMethod(..) |\n             def::DefPrimTy(_) => {\n                 self.sess.span_bug(span, &format!(\"lookup_def_kind for unexpected item: {:?}\",\n-                                                 def)[]);\n+                                                 def));\n             },\n         }\n     }\n@@ -279,7 +279,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                     span_utils.span_for_last_ident(p.span),\n                                     id,\n                                     qualname,\n-                                    &path_to_string(p)[],\n+                                    &path_to_string(p),\n                                     &typ[..]);\n             }\n             self.collected_paths.clear();\n@@ -302,7 +302,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     match item.node {\n                         ast::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from_str(\"<\");\n-                            result.push_str(&ty_to_string(&**ty)[]);\n+                            result.push_str(&ty_to_string(&**ty));\n \n                             match ty::trait_of_item(&self.analysis.ty_cx,\n                                                     ast_util::local_def(method.id)) {\n@@ -319,7 +319,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         _ => {\n                             self.sess.span_bug(method.span,\n                                                &format!(\"Container {} for method {} not an impl?\",\n-                                                       impl_id.node, method.id)[]);\n+                                                       impl_id.node, method.id));\n                         },\n                     }\n                 },\n@@ -329,7 +329,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                            \"Container {} for method {} is not a node item {:?}\",\n                                            impl_id.node,\n                                            method.id,\n-                                           self.analysis.ty_cx.map.get(impl_id.node))[]);\n+                                           self.analysis.ty_cx.map.get(impl_id.node)));\n                 },\n             },\n             None => match ty::trait_of_item(&self.analysis.ty_cx,\n@@ -343,14 +343,14 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         _ => {\n                             self.sess.span_bug(method.span,\n                                                &format!(\"Could not find container {} for method {}\",\n-                                                       def_id.node, method.id)[]);\n+                                                       def_id.node, method.id));\n                         }\n                     }\n                 },\n                 None => {\n                     self.sess.span_bug(method.span,\n                                        &format!(\"Could not find container for method {}\",\n-                                               method.id)[]);\n+                                               method.id));\n                 },\n             },\n         };\n@@ -442,7 +442,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                          scope_id),\n                     None => self.sess.span_bug(field.span,\n                                                &format!(\"Could not find sub-span for field {}\",\n-                                                       qualname)[]),\n+                                                       qualname)),\n                 }\n             },\n             _ => (),\n@@ -528,7 +528,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             &get_ident(item.ident),\n                             &qualname[..],\n                             &value[..],\n-                            &ty_to_string(&*typ)[],\n+                            &ty_to_string(&*typ),\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -551,7 +551,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             &get_ident(item.ident),\n                             &qualname[..],\n                             \"\",\n-                            &ty_to_string(&*typ)[],\n+                            &ty_to_string(&*typ),\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -603,7 +603,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                 &val[..]),\n             None => self.sess.span_bug(item.span,\n                                        &format!(\"Could not find subspan for enum {}\",\n-                                               enum_name)[]),\n+                                               enum_name)),\n         }\n         for variant in &enum_definition.variants {\n             let name = get_ident(variant.node.name);\n@@ -872,7 +872,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                     &format!(\"Unexpected def kind while looking \\\n                                               up path in `{}`: `{:?}`\",\n                                              self.span.snippet(span),\n-                                             *def)[]),\n+                                             *def)),\n         }\n         // modules or types in the path prefix\n         match *def {\n@@ -1007,7 +1007,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     None => {\n                         self.sess.span_bug(p.span,\n                                            &format!(\"Could not find struct_def for `{}`\",\n-                                                   self.span.snippet(p.span))[]);\n+                                                   self.span.snippet(p.span)));\n                     }\n                 };\n                 for &Spanned { node: ref field, span } in fields {\n@@ -1255,7 +1255,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     None => {\n                         self.sess.span_bug(method_type.span,\n                                            &format!(\"Could not find trait for method {}\",\n-                                                   method_type.id)[]);\n+                                                   method_type.id));\n                     },\n                 };\n \n@@ -1362,7 +1362,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                         }\n                     }\n                     _ => self.sess.span_bug(ex.span,\n-                                            &format!(\"Expected struct type, found {:?}\", ty)[]),\n+                                            &format!(\"Expected struct type, found {:?}\", ty)),\n                 }\n             },\n             ast::ExprTupField(ref sub_ex, idx) => {\n@@ -1391,7 +1391,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     ty::ty_tup(_) => {}\n                     _ => self.sess.span_bug(ex.span,\n                                             &format!(\"Expected struct or tuple \\\n-                                                      type, found {:?}\", ty)[]),\n+                                                      type, found {:?}\", ty)),\n                 }\n             },\n             ast::ExprClosure(_, ref decl, ref body) => {\n@@ -1400,7 +1400,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 }\n \n                 let mut id = String::from_str(\"$\");\n-                id.push_str(&ex.id.to_string()[]);\n+                id.push_str(&ex.id.to_string());\n                 self.process_formals(&decl.inputs, &id[..]);\n \n                 // walk arg and return types\n@@ -1448,7 +1448,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n                                    &format!(\"def_map has no key for {} in visit_arm\",\n-                                           id)[]);\n+                                           id));\n             }\n             let def = &(*def_map)[id];\n             match *def {\n@@ -1463,7 +1463,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     self.fmt.variable_str(p.span,\n                                           Some(p.span),\n                                           id,\n-                                          &path_to_string(p)[],\n+                                          &path_to_string(p),\n                                           &value[..],\n                                           \"\")\n                 }\n@@ -1519,7 +1519,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             self.fmt.variable_str(p.span,\n                                   sub_span,\n                                   id,\n-                                  &path_to_string(p)[],\n+                                  &path_to_string(p),\n                                   &value[..],\n                                   &typ[..]);\n         }\n@@ -1540,7 +1540,7 @@ pub fn process_crate(sess: &Session,\n     }\n \n     assert!(analysis.glob_map.is_some());\n-    let cratename = match attr::find_crate_name(&krate.attrs[]) {\n+    let cratename = match attr::find_crate_name(&krate.attrs) {\n         Some(name) => name.to_string(),\n         None => {\n             info!(\"Could not find crate name, using 'unknown_crate'\");\n@@ -1561,7 +1561,7 @@ pub fn process_crate(sess: &Session,\n \n     match fs::mkdir_recursive(&root_path, old_io::USER_RWX) {\n         Err(e) => sess.err(&format!(\"Could not create directory {}: {}\",\n-                           root_path.display(), e)[]),\n+                           root_path.display(), e)),\n         _ => (),\n     }\n \n@@ -1578,7 +1578,7 @@ pub fn process_crate(sess: &Session,\n         Ok(f) => box f,\n         Err(e) => {\n             let disp = root_path.display();\n-            sess.fatal(&format!(\"Could not open {}: {}\", disp, e)[]);\n+            sess.fatal(&format!(\"Could not open {}: {}\", disp, e));\n         }\n     };\n     root_path.pop();"}, {"sha": "937f2d07677aa790141757ee034ee08135735f5f", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -162,7 +162,7 @@ impl<'a> FmtStrs<'a> {\n         if values.len() != fields.len() {\n             self.span.sess.span_bug(span, &format!(\n                 \"Mismatch between length of fields for '{}', expected '{}', found '{}'\",\n-                kind, fields.len(), values.len())[]);\n+                kind, fields.len(), values.len()));\n         }\n \n         let values = values.iter().map(|s| {\n@@ -191,7 +191,7 @@ impl<'a> FmtStrs<'a> {\n         if needs_span {\n             self.span.sess.span_bug(span, &format!(\n                 \"Called record_without_span for '{}' which does requires a span\",\n-                label)[]);\n+                label));\n         }\n         assert!(!dump_spans);\n \n@@ -268,7 +268,7 @@ impl<'a> FmtStrs<'a> {\n         // variable def's node id\n         let mut qualname = String::from_str(name);\n         qualname.push_str(\"$\");\n-        qualname.push_str(&id.to_string()[]);\n+        qualname.push_str(&id.to_string());\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,"}, {"sha": "a5bebaa257ca0ca80b192afa37223ab1e6289279", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -219,7 +219,7 @@ impl<'a> SpanUtils<'a> {\n             let loc = self.sess.codemap().lookup_char_pos(span.lo);\n             self.sess.span_bug(span,\n                 &format!(\"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                        self.snippet(span), loc.file.name, loc.line)[]);\n+                        self.snippet(span), loc.file.name, loc.line));\n         }\n         if result.is_none() && prev.tok.is_ident() && bracket_count == 0 {\n             return self.make_sub_span(span, Some(prev.sp));\n@@ -245,7 +245,7 @@ impl<'a> SpanUtils<'a> {\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n                     self.sess.span_bug(span, &format!(\n                         \"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                         self.snippet(span), loc.file.name, loc.line)[]);\n+                         self.snippet(span), loc.file.name, loc.line));\n                 }\n                 return result\n             }"}, {"sha": "1a24b3fabf898c8de62de4cd0fb3a591de07847a", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -444,7 +444,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n-        e(&br.pats[]).map(|pats| {\n+        e(&br.pats).map(|pats| {\n             let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n@@ -825,7 +825,7 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n         let did = langcall(cx,\n                            None,\n                            &format!(\"comparison of `{}`\",\n-                                   cx.ty_to_string(rhs_t))[],\n+                                   cx.ty_to_string(rhs_t)),\n                            StrEqFnLangItem);\n         let t = ty::mk_str_slice(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), ast::MutImmutable);\n         // The comparison function gets the slices by value, so we have to make copies here. Even\n@@ -1375,21 +1375,21 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n                                  \"__llmatch\");\n                 trmode = TrByCopy(alloca_no_lifetime(bcx,\n                                          llvariable_ty,\n-                                         &bcx.ident(ident)[]));\n+                                         &bcx.ident(ident)));\n             }\n             ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n-                                 &bcx.ident(ident)[]);\n+                                 &bcx.ident(ident));\n                 trmode = TrByMove;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty,\n-                                 &bcx.ident(ident)[]);\n+                                 &bcx.ident(ident));\n                 trmode = TrByRef;\n             }\n         };\n@@ -1610,7 +1610,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding.\n-    let llval = alloc_ty(bcx, var_ty, &bcx.ident(*ident)[]);\n+    let llval = alloc_ty(bcx, var_ty, &bcx.ident(*ident));\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n@@ -1648,7 +1648,7 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     if bcx.sess().asm_comments() {\n         add_comment(bcx, &format!(\"bind_irrefutable_pat(pat={})\",\n-                                 pat.repr(bcx.tcx()))[]);\n+                                 pat.repr(bcx.tcx())));\n     }\n \n     let _indenter = indenter();"}, {"sha": "903de940207702062ecce6312bf7a1318688979c", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -177,7 +177,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         ty::ty_enum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n-            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id)[].get(0)\n+            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id).get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n@@ -210,7 +210,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 cx.sess().bug(&format!(\"non-C-like enum {} with specified \\\n                                       discriminants\",\n                                       ty::item_path_str(cx.tcx(),\n-                                                        def_id))[]);\n+                                                        def_id)));\n             }\n \n             if cases.len() == 1 {\n@@ -228,7 +228,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let mut discr = 0;\n                 while discr < 2 {\n                     if cases[1 - discr].is_zerolen(cx, t) {\n-                        let st = mk_struct(cx, &cases[discr].tys[],\n+                        let st = mk_struct(cx, &cases[discr].tys,\n                                            false, t);\n                         match cases[discr].find_ptr(cx) {\n                             Some(ref df) if df.len() == 1 && st.fields.len() == 1 => {\n@@ -318,7 +318,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n-                ftys.push_all(&c.tys[]);\n+                ftys.push_all(&c.tys);\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n                 mk_struct(cx, &ftys[..], false, t)\n             }).collect();\n@@ -328,7 +328,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             General(ity, fields, dtor)\n         }\n         _ => cx.sess().bug(&format!(\"adt::represent_type called on non-ADT type: {}\",\n-                           ty_to_string(cx.tcx(), t))[])\n+                           ty_to_string(cx.tcx(), t)))\n     }\n }\n \n@@ -414,7 +414,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n impl<'tcx> Case<'tcx> {\n     fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>) -> bool {\n-        mk_struct(cx, &self.tys[], false, scapegoat).size == 0\n+        mk_struct(cx, &self.tys, false, scapegoat).size == 0\n     }\n \n     fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<DiscrField> {\n@@ -504,7 +504,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             return ity;\n         }\n         attr::ReprExtern => {\n-            attempts = match &cx.sess().target.target.arch[] {\n+            attempts = match &cx.sess().target.target.arch[..] {\n                 // WARNING: the ARM EABI has two variants; the one corresponding to `at_least_32`\n                 // appears to be used on Linux and NetBSD, but some systems may use the variant\n                 // corresponding to `choose_shortest`.  However, we don't run on those yet...?\n@@ -624,7 +624,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     match *r {\n         CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n-            llty.set_struct_body(&struct_llfields(cx, st, false, false)[],\n+            llty.set_struct_body(&struct_llfields(cx, st, false, false),\n                                  st.packed)\n     }\n }\n@@ -640,7 +640,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, &struct_llfields(cx, st, sizing, dst)[],\n+                    Type::struct_(cx, &struct_llfields(cx, st, sizing, dst),\n                                   st.packed)\n                 }\n                 Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n@@ -965,7 +965,7 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n             for (discr, case) in cases.iter().enumerate() {\n                 let mut variant_cx = fcx.new_temp_block(\n-                    &format!(\"enum-variant-iter-{}\", &discr.to_string())[]\n+                    &format!(\"enum-variant-iter-{}\", &discr.to_string())\n                 );\n                 let rhs_val = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n                 AddCase(llswitch, rhs_val, variant_cx.llbb);\n@@ -1070,7 +1070,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             if discr == nndiscr {\n                 C_struct(ccx, &build_const_struct(ccx,\n                                                  nonnull,\n-                                                 vals)[],\n+                                                 vals),\n                          false)\n             } else {\n                 let vals = nonnull.fields.iter().map(|&ty| {\n@@ -1080,7 +1080,7 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n                 }).collect::<Vec<ValueRef>>();\n                 C_struct(ccx, &build_const_struct(ccx,\n                                                  nonnull,\n-                                                 &vals[..])[],\n+                                                 &vals[..]),\n                          false)\n             }\n         }"}, {"sha": "9c0aa9f69576ee09e163615d02614eec9edcf5df", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -365,7 +365,7 @@ fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         Err(s) => {\n             bcx.sess().fatal(&format!(\"allocation of `{}` {}\",\n                                      bcx.ty_to_string(info_ty),\n-                                     s)[]);\n+                                     s));\n         }\n     }\n }\n@@ -444,7 +444,7 @@ pub fn set_llvm_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: Val\n \n     for attr in attrs {\n         let mut used = true;\n-        match &attr.name()[] {\n+        match &attr.name()[..] {\n             \"no_stack_check\" => unset_split_stack(llfn),\n             \"no_split_stack\" => {\n                 unset_split_stack(llfn);\n@@ -486,7 +486,7 @@ pub fn unset_split_stack(f: ValueRef) {\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n     if ccx.all_llvm_symbols().borrow().contains(&sym) {\n-        ccx.sess().bug(&format!(\"duplicate LLVM symbol: {}\", sym)[]);\n+        ccx.sess().bug(&format!(\"duplicate LLVM symbol: {}\", sym));\n     }\n     ccx.all_llvm_symbols().borrow_mut().insert(sym);\n }\n@@ -541,7 +541,7 @@ pub fn bin_op_to_icmp_predicate(ccx: &CrateContext, op: ast::BinOp_, signed: boo\n         ast::BiGe => if signed { llvm::IntSGE } else { llvm::IntUGE },\n         op => {\n             ccx.sess().bug(&format!(\"comparison_op_to_icmp_predicate: expected \\\n-                                     comparison operator, found {:?}\", op)[]);\n+                                     comparison operator, found {:?}\", op));\n         }\n     }\n }\n@@ -557,7 +557,7 @@ pub fn bin_op_to_fcmp_predicate(ccx: &CrateContext, op: ast::BinOp_)\n         ast::BiGe => llvm::RealOGE,\n         op => {\n             ccx.sess().bug(&format!(\"comparison_op_to_fcmp_predicate: expected \\\n-                                     comparison operator, found {:?}\", op)[]);\n+                                     comparison operator, found {:?}\", op));\n         }\n     }\n }\n@@ -735,8 +735,8 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                       let variant_cx =\n                           fcx.new_temp_block(\n                               &format!(\"enum-iter-variant-{}\",\n-                                      &variant.disr_val.to_string()[])\n-                              []);\n+                                      &variant.disr_val.to_string())\n+                              );\n                       match adt::trans_case(cx, &*repr, variant.disr_val) {\n                           _match::SingleResult(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n@@ -761,7 +761,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n       }\n       _ => {\n           cx.sess().unimpl(&format!(\"type in iter_structural_ty: {}\",\n-                                   ty_to_string(cx.tcx(), t))[])\n+                                   ty_to_string(cx.tcx(), t)))\n       }\n     }\n     return cx;\n@@ -843,7 +843,7 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n         }\n         _ => {\n             cx.sess().bug(&format!(\"fail-if-zero on unexpected type: {}\",\n-                                  ty_to_string(cx.tcx(), rhs_t))[]);\n+                                  ty_to_string(cx.tcx(), rhs_t)));\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n@@ -1116,7 +1116,7 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n-    let key = match &ccx.sess().target.target.target_pointer_width[] {\n+    let key = match &ccx.sess().target.target.target_pointer_width[..] {\n         \"32\" => \"llvm.memcpy.p0i8.p0i8.i32\",\n         \"64\" => \"llvm.memcpy.p0i8.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memcpy: {}\", tws),\n@@ -1163,7 +1163,7 @@ fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n \n     let llty = type_of::type_of(ccx, ty);\n \n-    let intrinsic_key = match &ccx.sess().target.target.target_pointer_width[] {\n+    let intrinsic_key = match &ccx.sess().target.target.target_pointer_width[..] {\n         \"32\" => \"llvm.memset.p0i8.i32\",\n         \"64\" => \"llvm.memset.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memset: {}\", tws),\n@@ -1833,14 +1833,14 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         closure::ClosureEnv::NotClosure => {\n             copy_args_to_allocas(bcx,\n                                  arg_scope,\n-                                 &decl.inputs[],\n+                                 &decl.inputs,\n                                  arg_datums)\n         }\n         closure::ClosureEnv::Closure(_) => {\n             copy_closure_args_to_allocas(\n                 bcx,\n                 arg_scope,\n-                &decl.inputs[],\n+                &decl.inputs,\n                 arg_datums,\n                 &monomorphized_arg_types[..])\n         }\n@@ -1964,7 +1964,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         _ => ccx.sess().bug(\n             &format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n-                     ctor_ty.repr(tcx))[])\n+                     ctor_ty.repr(tcx)))\n     };\n \n     // Get location to store the result. If the user does not care about\n@@ -2042,7 +2042,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         _ => ccx.sess().bug(\n             &format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n-                    ty_to_string(ccx.tcx(), ctor_ty))[])\n+                    ty_to_string(ccx.tcx(), ctor_ty)))\n     };\n \n     let (arena, fcx): (TypedArena<_>, FunctionContext);\n@@ -2143,7 +2143,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n                             *lvlsrc.unwrap(), Some(sp),\n                             &format!(\"enum variant is more than three times larger \\\n                                      ({} bytes) than the next largest (ignoring padding)\",\n-                                    largest)[]);\n+                                    largest));\n \n         ccx.sess().span_note(enum_def.variants[largest_index].span,\n                              \"this variant is the largest\");\n@@ -2261,7 +2261,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     match item.node {\n       ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n         if !generics.is_type_parameterized() {\n-            let trans_everywhere = attr::requests_inline(&item.attrs[]);\n+            let trans_everywhere = attr::requests_inline(&item.attrs);\n             // Ignore `trans_everywhere` for cross-crate inlined items\n             // (`from_external`).  `trans_item` will be called once for each\n             // compilation unit that references the item, so it will still get\n@@ -2273,7 +2273,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                     foreign::trans_rust_fn_with_foreign_abi(ccx,\n                                                             &**decl,\n                                                             &**body,\n-                                                            &item.attrs[],\n+                                                            &item.attrs,\n                                                             llfn,\n                                                             empty_substs,\n                                                             item.id,\n@@ -2285,7 +2285,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                              llfn,\n                              empty_substs,\n                              item.id,\n-                             &item.attrs[]);\n+                             &item.attrs);\n                 }\n                 update_linkage(ccx,\n                                llfn,\n@@ -2332,7 +2332,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n \n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n-          if attr::contains_name(&item.attrs[], \"static_assert\") {\n+          if attr::contains_name(&item.attrs, \"static_assert\") {\n               if m == ast::MutMutable {\n                   ccx.sess().span_fatal(expr.span,\n                                         \"cannot have static_assert on a mutable \\\n@@ -2746,7 +2746,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n-            let sym = || exported_name(ccx, id, ty, &i.attrs[]);\n+            let sym = || exported_name(ccx, id, ty, &i.attrs);\n \n             let v = match i.node {\n                 ast::ItemStatic(_, _, ref expr) => {\n@@ -2773,13 +2773,13 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         if contains_null(&sym[..]) {\n                             ccx.sess().fatal(\n                                 &format!(\"Illegal null byte in export_name \\\n-                                         value: `{}`\", sym)[]);\n+                                         value: `{}`\", sym));\n                         }\n                         let buf = CString::new(sym.clone()).unwrap();\n                         let g = llvm::LLVMAddGlobal(ccx.llmod(), llty,\n                                                     buf.as_ptr());\n \n-                        if attr::contains_name(&i.attrs[],\n+                        if attr::contains_name(&i.attrs,\n                                                \"thread_local\") {\n                             llvm::set_thread_local(g, true);\n                         }\n@@ -2798,19 +2798,19 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                                                    sym,\n                                                                    i.id)\n                     };\n-                    set_llvm_fn_attrs(ccx, &i.attrs[], llfn);\n+                    set_llvm_fn_attrs(ccx, &i.attrs, llfn);\n                     llfn\n                 }\n \n                 _ => panic!(\"get_item_val: weird result in table\")\n             };\n \n-            match attr::first_attr_value_str_by_name(&i.attrs[],\n+            match attr::first_attr_value_str_by_name(&i.attrs,\n                                                      \"link_section\") {\n                 Some(sect) => {\n                     if contains_null(&sect) {\n                         ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\",\n-                                                 &sect)[]);\n+                                                 &sect));\n                     }\n                     unsafe {\n                         let buf = CString::new(sect.as_bytes()).unwrap();\n@@ -2876,7 +2876,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n-                                    &enm.attrs[]);\n+                                    &enm.attrs);\n \n             llfn = match enm.node {\n                 ast::ItemEnum(_, _) => {\n@@ -2903,7 +2903,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n-                                    &struct_item.attrs[]);\n+                                    &struct_item.attrs);\n             let llfn = register_fn(ccx, struct_item.span,\n                                    sym, ctor_id, ty);\n             set_inline_hint(llfn);\n@@ -2912,7 +2912,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n \n         ref variant => {\n             ccx.sess().bug(&format!(\"get_item_val(): unexpected variant: {:?}\",\n-                                   variant)[])\n+                                   variant))\n         }\n     };\n \n@@ -2933,10 +2933,10 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n                    m: &ast::Method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx(), id);\n \n-    let sym = exported_name(ccx, id, mty, &m.attrs[]);\n+    let sym = exported_name(ccx, id, mty, &m.attrs);\n \n     let llfn = register_fn(ccx, m.span, sym, id, mty);\n-    set_llvm_fn_attrs(ccx, &m.attrs[], llfn);\n+    set_llvm_fn_attrs(ccx, &m.attrs, llfn);\n     llfn\n }\n \n@@ -3104,7 +3104,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     let link_meta = link::build_link_meta(&tcx.sess, krate, name);\n \n     let codegen_units = tcx.sess.opts.cg.codegen_units;\n-    let shared_ccx = SharedCrateContext::new(&link_meta.crate_name[],\n+    let shared_ccx = SharedCrateContext::new(&link_meta.crate_name,\n                                              codegen_units,\n                                              tcx,\n                                              export_map,\n@@ -3206,7 +3206,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         llmod: shared_ccx.metadata_llmod(),\n     };\n     let formats = shared_ccx.tcx().dependency_formats.borrow().clone();\n-    let no_builtins = attr::contains_name(&krate.attrs[], \"no_builtins\");\n+    let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n     let translation = CrateTranslation {\n         modules: modules,"}, {"sha": "0ff5264c00f0f8346ebd9d3180affdf7787c9216", "filename": "src/librustc_trans/trans/cabi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -109,7 +109,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    match &ccx.sess().target.target.arch[] {\n+    match &ccx.sess().target.target.arch[..] {\n         \"x86\" => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n         \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n             cabi_x86_win64::compute_abi_info(ccx, atys, rty, ret_def)\n@@ -128,6 +128,6 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         \"mips\" => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n         \"powerpc\" => cabi_powerpc::compute_abi_info(ccx, atys, rty, ret_def),\n         a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a)\n-                              []),\n+                              ),\n     }\n }"}, {"sha": "1cc8f62045df8dac6ed2f5d9416035c7dba0872f", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -118,7 +118,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                     expr.span,\n                     &format!(\"type of callee is neither bare-fn nor closure: \\\n                              {}\",\n-                            bcx.ty_to_string(datum.ty))[]);\n+                            bcx.ty_to_string(datum.ty)));\n             }\n         }\n     }\n@@ -215,7 +215,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     &format!(\"cannot translate def {:?} \\\n-                             to a callable thing!\", def)[]);\n+                             to a callable thing!\", def));\n             }\n         }\n     }\n@@ -298,7 +298,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n             _ => {\n                 tcx.sess.bug(&format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                           bare_fn_ty.repr(tcx))[]);\n+                                           bare_fn_ty.repr(tcx)));\n             }\n         };\n     let sig = ty::erase_late_bound_regions(tcx, sig);"}, {"sha": "a3705a67cdc5a4e37f30dbff6bf3e5bdb5b86a3b", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -513,7 +513,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n \n         self.ccx.sess().bug(\n             &format!(\"no cleanup scope {} found\",\n-                    self.ccx.tcx().map.node_to_string(cleanup_scope))[]);\n+                    self.ccx.tcx().map.node_to_string(cleanup_scope)));\n     }\n \n     /// Schedules a cleanup to occur in the top-most scope, which must be a temporary scope.\n@@ -695,7 +695,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                     LoopExit(id, _) => {\n                         self.ccx.sess().bug(&format!(\n                                 \"cannot exit from scope {}, \\\n-                                not in scope\", id)[]);\n+                                not in scope\", id));\n                     }\n                 }\n             }\n@@ -1135,7 +1135,7 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n         }\n         None => {\n             tcx.sess.bug(&format!(\"no temporary scope available for expr {}\",\n-                                 id)[])\n+                                 id))\n         }\n     }\n }"}, {"sha": "60725bf9b2a290ae023dd53fb8a869fea4670536", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -278,7 +278,7 @@ pub fn gensym_name(name: &str) -> PathElem {\n     let num = token::gensym(name).usize();\n     // use one colon which will get translated to a period by the mangler, and\n     // we're guaranteed that `num` is globally unique for this crate.\n-    PathName(token::gensym(&format!(\"{}:{}\", name, num)[]))\n+    PathName(token::gensym(&format!(\"{}:{}\", name, num)))\n }\n \n #[derive(Copy)]\n@@ -606,7 +606,7 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n             Some(v) => v.clone(),\n             None => {\n                 self.tcx().sess.bug(&format!(\n-                    \"no def associated with node id {}\", nid)[]);\n+                    \"no def associated with node id {}\", nid));\n             }\n         }\n     }\n@@ -1011,7 +1011,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 span,\n                 &format!(\"Encountered error `{}` selecting `{}` during trans\",\n                         e.repr(tcx),\n-                        trait_ref.repr(tcx))[])\n+                        trait_ref.repr(tcx)))\n         }\n     };\n \n@@ -1104,7 +1104,7 @@ pub fn drain_fulfillment_cx<'a,'tcx,T>(span: Span,\n                 infcx.tcx.sess.span_bug(\n                     span,\n                     &format!(\"Encountered errors `{}` fulfilling during trans\",\n-                            errors.repr(infcx.tcx))[]);\n+                            errors.repr(infcx.tcx)));\n             }\n         }\n     }\n@@ -1144,7 +1144,7 @@ pub fn node_id_substs<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     if substs.types.any(|t| ty::type_needs_infer(*t)) {\n             tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n-                                 node, substs.repr(tcx))[]);\n+                                 node, substs.repr(tcx)));\n         }\n \n         monomorphize::apply_param_substs(tcx,"}, {"sha": "3c0024712b23acc9110302be1bf9c88e90b4f1ad", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -54,7 +54,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n                 _ => cx.sess().span_bug(lit.span,\n                         &format!(\"integer literal has type {} (expected int \\\n                                  or uint)\",\n-                                ty_to_string(cx.tcx(), lit_int_ty))[])\n+                                ty_to_string(cx.tcx(), lit_int_ty)))\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n@@ -152,7 +152,7 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         None => {\n             cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n-                                   ty_to_string(cx.tcx(), ty))[])\n+                                   ty_to_string(cx.tcx(), ty)))\n         }\n     }\n }\n@@ -174,7 +174,7 @@ pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     } else {\n         ccx.sess().span_bug(ref_expr.span,\n                             &format!(\"get_const_val given non-constant item {}\",\n-                                     item.repr(ccx.tcx()))[]);\n+                                     item.repr(ccx.tcx())));\n     }\n }\n \n@@ -301,15 +301,15 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             }\n                             None => {\n                                 cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n-                                                       ty_to_string(cx.tcx(), ty))[])\n+                                                       ty_to_string(cx.tcx(), ty)))\n                             }\n                         }\n                     }\n                     opt_autoref\n                 }\n                 Some(autoref) => {\n                     cx.sess().span_bug(e.span,\n-                        &format!(\"unimplemented const first autoref {:?}\", autoref)[])\n+                        &format!(\"unimplemented const first autoref {:?}\", autoref))\n                 }\n             };\n             match second_autoref {\n@@ -333,7 +333,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n                 Some(autoref) => {\n                     cx.sess().span_bug(e.span,\n-                        &format!(\"unimplemented const second autoref {:?}\", autoref)[])\n+                        &format!(\"unimplemented const second autoref {:?}\", autoref))\n                 }\n             }\n         }\n@@ -351,7 +351,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         cx.sess().bug(&format!(\"const {} of type {} has size {} instead of {}\",\n                          e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety_adjusted),\n-                         csize, tsize)[]);\n+                         csize, tsize));\n     }\n     (llconst, ety_adjusted)\n }\n@@ -485,7 +485,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       _ => cx.sess().span_bug(base.span,\n                                               &format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt))[])\n+                                                      ty_to_string(cx.tcx(), bt)))\n                   },\n                   ty::ty_rptr(_, mt) => match mt.ty.sty {\n                       ty::ty_vec(_, Some(u)) => {\n@@ -494,12 +494,12 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       _ => cx.sess().span_bug(base.span,\n                                               &format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt))[])\n+                                                      ty_to_string(cx.tcx(), bt)))\n                   },\n                   _ => cx.sess().span_bug(base.span,\n                                           &format!(\"index-expr base must be a vector \\\n                                                    or string type, found {}\",\n-                                                  ty_to_string(cx.tcx(), bt))[])\n+                                                  ty_to_string(cx.tcx(), bt)))\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;"}, {"sha": "3586a9dda20675bbc89752d0a45f6cd9d6d24750", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -378,7 +378,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                                           .target\n                                           .target\n                                           .data_layout\n-                                          []);\n+                                          );\n \n             let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod))\n@@ -731,7 +731,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     /// currently conservatively bounded to 1 << 47 as that is enough to cover the current usable\n     /// address space on 64-bit ARMv8 and x86_64.\n     pub fn obj_size_bound(&self) -> u64 {\n-        match &self.sess().target.target.target_pointer_width[] {\n+        match &self.sess().target.target.target_pointer_width[..] {\n             \"32\" => 1 << 31,\n             \"64\" => 1 << 47,\n             _ => unreachable!() // error handled by config::build_target_config\n@@ -741,7 +741,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {\n         self.sess().fatal(\n             &format!(\"the type `{}` is too big for the current architecture\",\n-                    obj.repr(self.tcx()))[])\n+                    obj.repr(self.tcx())))\n     }\n }\n "}, {"sha": "6860cda8241c9011489874b7cae1094a4b27355b", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -41,7 +41,7 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     debug!(\"trans_stmt({})\", s.repr(cx.tcx()));\n \n     if cx.sess().asm_comments() {\n-        add_span_comment(cx, s.span, &s.repr(cx.tcx())[]);\n+        add_span_comment(cx, s.span, &s.repr(cx.tcx()));\n     }\n \n     let mut bcx = cx;\n@@ -310,7 +310,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n                     bcx.tcx().sess.bug(&format!(\"{:?} in def-map for label\",\n-                                               r)[])\n+                                               r))\n                 }\n             }\n         }\n@@ -375,7 +375,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let v_str = C_str_slice(ccx, fail_str);\n     let loc = bcx.sess().codemap().lookup_char_pos(call_info.span.lo);\n-    let filename = token::intern_and_get_ident(&loc.file.name[]);\n+    let filename = token::intern_and_get_ident(&loc.file.name);\n     let filename = C_str_slice(ccx, filename);\n     let line = C_uint(ccx, loc.line);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n@@ -402,7 +402,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Extract the file/line from the span\n     let loc = bcx.sess().codemap().lookup_char_pos(call_info.span.lo);\n-    let filename = token::intern_and_get_ident(&loc.file.name[]);\n+    let filename = token::intern_and_get_ident(&loc.file.name);\n \n     // Invoke the lang item\n     let filename = C_str_slice(ccx,  filename);"}, {"sha": "96211832c1cc921556c14eda4b6bd715e137098f", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -557,7 +557,7 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n             }\n             _ => bcx.tcx().sess.bug(\n                 &format!(\"Unexpected unsized type in get_element: {}\",\n-                        bcx.ty_to_string(self.ty))[])\n+                        bcx.ty_to_string(self.ty)))\n         };\n         Datum {\n             val: val,"}, {"sha": "b5cba9b67406cee1c6c7f04ab16a05840b3fed2a", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -286,7 +286,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                        metadata: DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n             cx.sess().bug(&format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n-                                   ppaux::ty_to_string(cx.tcx(), type_))[]);\n+                                   ppaux::ty_to_string(cx.tcx(), type_)));\n         }\n     }\n \n@@ -299,7 +299,7 @@ impl<'tcx> TypeMap<'tcx> {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n             cx.sess().bug(&format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                                  &unique_type_id_str[..])[]);\n+                                  &unique_type_id_str[..]));\n         }\n     }\n \n@@ -412,7 +412,7 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::ty_vec(inner_type, optional_length) => {\n                 match optional_length {\n                     Some(len) => {\n-                        unique_type_id.push_str(&format!(\"[{}]\", len)[]);\n+                        unique_type_id.push_str(&format!(\"[{}]\", len));\n                     }\n                     None => {\n                         unique_type_id.push_str(\"[]\");\n@@ -481,8 +481,8 @@ impl<'tcx> TypeMap<'tcx> {\n             },\n             _ => {\n                 cx.sess().bug(&format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n-                                      &ppaux::ty_to_string(cx.tcx(), type_)[],\n-                                      type_.sty)[])\n+                                      &ppaux::ty_to_string(cx.tcx(), type_),\n+                                      type_.sty))\n             }\n         };\n \n@@ -525,7 +525,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n             output.push_str(crate_hash.as_str());\n             output.push_str(\"/\");\n-            output.push_str(&format!(\"{:x}\", def_id.node)[]);\n+            output.push_str(&format!(\"{:x}\", def_id.node));\n \n             // Maybe check that there is no self type here.\n \n@@ -600,7 +600,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                               -> UniqueTypeId {\n         let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n         let enum_variant_type_id = format!(\"{}::{}\",\n-                                           &self.get_unique_type_id_as_string(enum_type_id)[],\n+                                           &self.get_unique_type_id_as_string(enum_type_id),\n                                            variant_name);\n         let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n         UniqueTypeId(interner_key)\n@@ -783,19 +783,19 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                          create_global_var_metadata() -\n                                          Captured var-id refers to \\\n                                          unexpected ast_item variant: {:?}\",\n-                                        var_item)[])\n+                                        var_item))\n                 }\n             }\n         },\n         _ => cx.sess().bug(&format!(\"debuginfo::create_global_var_metadata() \\\n                                     - Captured var-id refers to unexpected \\\n                                     ast_map variant: {:?}\",\n-                                   var_item)[])\n+                                   var_item))\n     };\n \n     let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n         let loc = span_start(cx, span);\n-        (file_metadata(cx, &loc.file.name[]), loc.line as c_uint)\n+        (file_metadata(cx, &loc.file.name), loc.line as c_uint)\n     } else {\n         (UNKNOWN_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n     };\n@@ -847,7 +847,7 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             None => {\n                 bcx.sess().span_bug(span,\n                     &format!(\"no entry in lllocals table for {}\",\n-                            node_id)[]);\n+                            node_id));\n             }\n         };\n \n@@ -903,7 +903,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 \"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {:?}\",\n-                                 ast_item)[]);\n+                                 ast_item));\n                 }\n             }\n         }\n@@ -913,7 +913,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                         &format!(\"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {:?}\",\n-                                ast_item)[]);\n+                                ast_item));\n         }\n     };\n \n@@ -1025,7 +1025,7 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             None => {\n                 bcx.sess().span_bug(span,\n                     &format!(\"no entry in lllocals table for {}\",\n-                            node_id)[]);\n+                            node_id));\n             }\n         };\n \n@@ -1319,7 +1319,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     cx.sess()\n                       .bug(&format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {:?}\",\n-                                    fnitem)[])\n+                                    fnitem))\n                 }\n             }\n         }\n@@ -1330,7 +1330,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         _ => cx.sess().bug(&format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {:?}\",\n-                                   fnitem)[])\n+                                   fnitem))\n     };\n \n     // This can be the case for functions inlined from another crate\n@@ -1339,7 +1339,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, &loc.file.name[]);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n \n     let function_type_metadata = unsafe {\n         let fn_signature = get_function_signature(cx,\n@@ -1751,7 +1751,7 @@ fn scope_metadata(fcx: &FunctionContext,\n \n             fcx.ccx.sess().span_bug(error_reporting_span,\n                 &format!(\"debuginfo: Could not find scope info for node {:?}\",\n-                        node)[]);\n+                        node));\n         }\n     }\n }\n@@ -1947,7 +1947,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                         cx.sess().bug(&format!(\"Forward declaration of potentially recursive type \\\n                                               '{}' was not found in TypeMap!\",\n                                               ppaux::ty_to_string(cx.tcx(), unfinished_type))\n-                                      []);\n+                                      );\n                     }\n                 }\n \n@@ -2370,7 +2370,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     .iter()\n                                     .map(|&t| type_of::type_of(cx, t))\n                                     .collect::<Vec<_>>()\n-                                    [],\n+                                    ,\n                       struct_def.packed);\n     // Could do some consistency checks here: size, align, field count, discr type\n \n@@ -2437,7 +2437,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n     let loc = span_start(cx, definition_span);\n-    let file_metadata = file_metadata(cx, &loc.file.name[]);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n \n     let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n \n@@ -2624,7 +2624,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                                         Please use a rustc built with anewer \\\n                                         version of LLVM.\",\n                                        llvm_version_major,\n-                                       llvm_version_minor)[]);\n+                                       llvm_version_minor));\n             } else {\n                 cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n                                Already completed forward declaration re-encountered.\");\n@@ -2786,7 +2786,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     assert!(member_descriptions.len() == member_llvm_types.len());\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, &loc.file.name[]);\n+    let file_metadata = file_metadata(cx, &loc.file.name);\n \n     let metadata = composite_type_metadata(cx,\n                                            slice_llvm_type,\n@@ -2865,7 +2865,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n             cx.sess().bug(&format!(\"debuginfo: Unexpected trait-object type in \\\n                                    trait_pointer_metadata(): {}\",\n-                                   &pp_type_name[..])[]);\n+                                   &pp_type_name[..]));\n         }\n     };\n \n@@ -3005,7 +3005,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n         _ => {\n             cx.sess().bug(&format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n-                                  sty)[])\n+                                  sty))\n         }\n     };\n \n@@ -3248,7 +3248,7 @@ fn create_scope_map(cx: &CrateContext,\n     {\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n-        let file_metadata = file_metadata(cx, &loc.file.name[]);\n+        let file_metadata = file_metadata(cx, &loc.file.name);\n         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n         let scope_metadata = unsafe {\n@@ -3370,7 +3370,7 @@ fn create_scope_map(cx: &CrateContext,\n                     if need_new_scope {\n                         // Create a new lexical scope and push it onto the stack\n                         let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n-                        let file_metadata = file_metadata(cx, &loc.file.name[]);\n+                        let file_metadata = file_metadata(cx, &loc.file.name);\n                         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                         let scope_metadata = unsafe {\n@@ -3832,7 +3832,7 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_projection(..) |\n         ty::ty_param(_) => {\n             cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t))[]);\n+                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)));\n         }\n     }\n \n@@ -3915,21 +3915,21 @@ impl NamespaceTreeNode {\n                 None => {}\n             }\n             let string = token::get_name(node.name);\n-            output.push_str(&format!(\"{}\", string.len())[]);\n+            output.push_str(&format!(\"{}\", string.len()));\n             output.push_str(&string);\n         }\n \n         let mut name = String::from_str(\"_ZN\");\n         fill_nested(self, &mut name);\n-        name.push_str(&format!(\"{}\", item_name.len())[]);\n+        name.push_str(&format!(\"{}\", item_name.len()));\n         name.push_str(item_name);\n         name.push('E');\n         name\n     }\n }\n \n fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n-    &cx.link_meta().crate_name[]\n+    &cx.link_meta().crate_name\n }\n \n fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n@@ -4005,7 +4005,7 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n             None => {\n                 cx.sess().bug(&format!(\"debuginfo::namespace_for_item(): \\\n                                        path too short for {:?}\",\n-                                      def_id)[]);\n+                                      def_id));\n             }\n         }\n     })"}, {"sha": "78992959a6f2288f39c5c734988d0561baa041c6", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -308,7 +308,7 @@ pub fn unsized_info<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n                 unsized_info(ccx, k, id, ty_substs[tp_index], param_substs, identity)\n             }\n             _ => ccx.sess().bug(&format!(\"UnsizeStruct with bad sty: {}\",\n-                                         unadjusted_ty.repr(ccx.tcx()))[])\n+                                         unadjusted_ty.repr(ccx.tcx())))\n         },\n         &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n             // Note that we preserve binding levels here:\n@@ -524,7 +524,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let unboxed_ty = match datum_ty.sty {\n             ty::ty_uniq(t) => t,\n             _ => bcx.sess().bug(&format!(\"Expected ty_uniq, found {}\",\n-                                        bcx.ty_to_string(datum_ty))[])\n+                                        bcx.ty_to_string(datum_ty)))\n         };\n         let result_ty = ty::mk_uniq(tcx, ty::unsize_ty(tcx, unboxed_ty, k, expr.span));\n \n@@ -696,7 +696,7 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 &format!(\"trans_rvalue_datum_unadjusted reached \\\n                          fall-through case: {:?}\",\n-                        expr.node)[]);\n+                        expr.node));\n         }\n     }\n }\n@@ -1020,7 +1020,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 &format!(\"trans_rvalue_stmt_unadjusted reached \\\n                          fall-through case: {:?}\",\n-                        expr.node)[]);\n+                        expr.node));\n         }\n     }\n }\n@@ -1216,7 +1216,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 expr.span,\n                 &format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n                          case: {:?}\",\n-                        expr.node)[]);\n+                        expr.node));\n         }\n     }\n }\n@@ -1266,7 +1266,7 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(ref_expr.span, &format!(\n                 \"Non-DPS def {:?} referened by {}\",\n-                def, bcx.node_id_to_string(ref_expr.id))[]);\n+                def, bcx.node_id_to_string(ref_expr.id)));\n         }\n     }\n }\n@@ -1295,7 +1295,7 @@ pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             ccx.tcx().sess.span_bug(ref_expr.span, &format!(\n                     \"trans_def_fn_unadjusted invoked on: {:?} for {}\",\n                     def,\n-                    ref_expr.repr(ccx.tcx()))[]);\n+                    ref_expr.repr(ccx.tcx())));\n         }\n     }\n }\n@@ -1315,7 +1315,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 None => {\n                     bcx.sess().bug(&format!(\n                         \"trans_local_var: no llval for upvar {} found\",\n-                        nid)[]);\n+                        nid));\n                 }\n             }\n         }\n@@ -1325,7 +1325,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 None => {\n                     bcx.sess().bug(&format!(\n                         \"trans_local_var: no datum for local/arg {} found\",\n-                        nid)[]);\n+                        nid));\n                 }\n             };\n             debug!(\"take_local(nid={}, v={}, ty={})\",\n@@ -1335,7 +1335,7 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.sess().unimpl(&format!(\n                 \"unsupported def type in trans_local_var: {:?}\",\n-                def)[]);\n+                def));\n         }\n     }\n }\n@@ -1358,7 +1358,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n         }\n \n         ty::ty_tup(ref v) => {\n-            op(0, &tup_fields(&v[..])[])\n+            op(0, &tup_fields(&v[..]))\n         }\n \n         ty::ty_enum(_, substs) => {\n@@ -1368,7 +1368,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n                     tcx.sess.bug(&format!(\n                         \"cannot get field types from the enum type {} \\\n                          without a node ID\",\n-                        ty.repr(tcx))[]);\n+                        ty.repr(tcx)));\n                 }\n                 Some(node_id) => {\n                     let def = tcx.def_map.borrow()[node_id].clone();\n@@ -1392,7 +1392,7 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n         _ => {\n             tcx.sess.bug(&format!(\n                 \"cannot get field types from the type {}\",\n-                ty.repr(tcx))[]);\n+                ty.repr(tcx)));\n         }\n     }\n }\n@@ -2097,7 +2097,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                             t_in.repr(bcx.tcx()),\n                                             k_in,\n                                             t_out.repr(bcx.tcx()),\n-                                            k_out)[])\n+                                            k_out))\n                 }\n             }\n         }\n@@ -2106,7 +2106,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                     t_in.repr(bcx.tcx()),\n                                     k_in,\n                                     t_out.repr(bcx.tcx()),\n-                                    k_out)[])\n+                                    k_out))\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n@@ -2272,7 +2272,7 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n                 &format!(\"deref invoked on expr of illegal type {}\",\n-                        datum.ty.repr(bcx.tcx()))[]);\n+                        datum.ty.repr(bcx.tcx())));\n         }\n     };\n "}, {"sha": "efae76c5ef41c76027b149666d001858e9f058ae", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -111,7 +111,7 @@ pub fn register_static(ccx: &CrateContext,\n     let llty = type_of::type_of(ccx, ty);\n \n     let ident = link_name(foreign_item);\n-    match attr::first_attr_value_str_by_name(&foreign_item.attrs[],\n+    match attr::first_attr_value_str_by_name(&foreign_item.attrs,\n                                              \"linkage\") {\n         // If this is a static with a linkage specified, then we need to handle\n         // it a little specially. The typesystem prevents things like &T and\n@@ -240,11 +240,11 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n     let llsig = foreign_signature(ccx, &fn_sig, &passed_arg_tys[..]);\n     let fn_type = cabi::compute_abi_info(ccx,\n-                                         &llsig.llarg_tys[],\n+                                         &llsig.llarg_tys,\n                                          llsig.llret_ty,\n                                          llsig.ret_def);\n \n-    let arg_tys: &[cabi::ArgType] = &fn_type.arg_tys[];\n+    let arg_tys: &[cabi::ArgType] = &fn_type.arg_tys;\n \n     let mut llargs_foreign = Vec::new();\n \n@@ -439,7 +439,7 @@ fn gate_simd_ffi(tcx: &ty::ctxt, decl: &ast::FnDecl, ty: &ty::BareFnTy) {\n                 tcx.sess.span_err(ast_ty.span,\n                               &format!(\"use of SIMD type `{}` in FFI is highly experimental and \\\n                                         may result in invalid code\",\n-                                       pprust::ty_to_string(ast_ty))[]);\n+                                       pprust::ty_to_string(ast_ty)));\n                 tcx.sess.span_help(ast_ty.span,\n                                    \"add #![feature(simd_ffi)] to the crate attributes to enable\");\n             }\n@@ -603,7 +603,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 ccx.sess().bug(&format!(\"build_rust_fn: extern fn {} has ty {}, \\\n                                         expected a bare fn ty\",\n                                        ccx.tcx().map.path_to_string(id),\n-                                       t.repr(tcx))[]);\n+                                       t.repr(tcx)));\n             }\n         };\n \n@@ -868,9 +868,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n // the massive simplifications that have occurred.\n \n pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n-    match attr::first_attr_value_str_by_name(&i.attrs[], \"link_name\") {\n+    match attr::first_attr_value_str_by_name(&i.attrs, \"link_name\") {\n         Some(ln) => ln.clone(),\n-        None => match weak_lang_items::link_name(&i.attrs[]) {\n+        None => match weak_lang_items::link_name(&i.attrs) {\n             Some(name) => name,\n             None => token::get_ident(i.ident),\n         }\n@@ -913,7 +913,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n     let llsig = foreign_signature(ccx, &fn_sig, &fn_sig.inputs);\n     let fn_ty = cabi::compute_abi_info(ccx,\n-                                       &llsig.llarg_tys[],\n+                                       &llsig.llarg_tys,\n                                        llsig.llret_ty,\n                                        llsig.ret_def);\n     debug!(\"foreign_types_for_fn_ty(\\\n@@ -922,7 +922,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n            ty.repr(ccx.tcx()),\n-           ccx.tn().types_to_str(&llsig.llarg_tys[]),\n+           ccx.tn().types_to_str(&llsig.llarg_tys),\n            ccx.tn().type_to_string(llsig.llret_ty),\n            ccx.tn().types_to_str(&fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>()),\n            ccx.tn().type_to_string(fn_ty.ret_ty.ty),"}, {"sha": "20956bf795b8537ed94987d632ad1bc0fe04f108", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -243,7 +243,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             sig.inputs[0]\n         }\n         _ => bcx.sess().bug(&format!(\"Expected function type, found {}\",\n-                                    bcx.ty_to_string(fty))[])\n+                                    bcx.ty_to_string(fty)))\n     };\n \n     let (struct_data, info) = if type_is_sized(bcx.tcx(), t) {\n@@ -370,7 +370,7 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n              C_uint(bcx.ccx(), unit_align))\n         }\n         _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\",\n-                                    bcx.ty_to_string(t))[])\n+                                    bcx.ty_to_string(t)))\n     }\n }\n \n@@ -443,7 +443,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         bcx.sess().warn(&format!(\"Ignoring drop flag in destructor for {}\\\n                                                  because the struct is unsized. See issue\\\n                                                  #16758\",\n-                                                bcx.ty_to_string(t))[]);\n+                                                bcx.ty_to_string(t)));\n                         trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                     }\n                 }\n@@ -521,7 +521,7 @@ pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     note_unique_llvm_symbol(ccx, name);\n \n     let ty_name = token::intern_and_get_ident(\n-        &ppaux::ty_to_string(ccx.tcx(), t)[]);\n+        &ppaux::ty_to_string(ccx.tcx(), t));\n     let ty_name = C_str_slice(ccx, ty_name);\n \n     debug!(\"--- declare_tydesc {}\", ppaux::ty_to_string(ccx.tcx(), t));\n@@ -540,7 +540,7 @@ fn declare_generic_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n     let fn_nm = mangle_internal_name_by_type_and_seq(\n         ccx,\n         t,\n-        &format!(\"glue_{}\", name)[]);\n+        &format!(\"glue_{}\", name));\n     let llfn = decl_cdecl_fn(ccx, &fn_nm[..], llfnty, ty::mk_nil(ccx.tcx()));\n     note_unique_llvm_symbol(ccx, fn_nm.clone());\n     return (fn_nm, llfn);"}, {"sha": "993c9eae45bf6326f016693dea46bb25dfe043ec", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -36,7 +36,7 @@ use syntax::parse::token;\n use util::ppaux::{Repr, ty_to_string};\n \n pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n-    let name = match &token::get_ident(item.ident)[] {\n+    let name = match &token::get_ident(item.ident)[..] {\n         \"sqrtf32\" => \"llvm.sqrt.f32\",\n         \"sqrtf64\" => \"llvm.sqrt.f64\",\n         \"powif32\" => \"llvm.powi.f32\","}, {"sha": "65d8f8ec3614d071d3e7d0e5d5ae67223c97d3f1", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -79,7 +79,7 @@ pub fn trans_impl(ccx: &CrateContext,\n         match *impl_item {\n             ast::MethodImplItem(ref method) => {\n                 if method.pe_generics().ty_params.len() == 0 {\n-                    let trans_everywhere = attr::requests_inline(&method.attrs[]);\n+                    let trans_everywhere = attr::requests_inline(&method.attrs);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, method.id);\n                         let empty_substs = tcx.mk_substs(Substs::trans_empty());\n@@ -305,7 +305,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n         _ => {\n             tcx.sess.bug(&format!(\"static call to invalid vtable: {}\",\n-                                 vtbl.repr(tcx))[]);\n+                                 vtbl.repr(tcx)));\n         }\n     }\n }\n@@ -393,7 +393,7 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableParam(..) => {\n             bcx.sess().bug(\n                 &format!(\"resolved vtable bad vtable {} in trans\",\n-                        vtable.repr(bcx.tcx()))[]);\n+                        vtable.repr(bcx.tcx())));\n         }\n     }\n }\n@@ -749,7 +749,7 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 tcx.sess.bug(\n                     &format!(\"resolved vtable for {} to bad vtable {} in trans\",\n                             trait_ref.repr(tcx),\n-                            vtable.repr(tcx))[]);\n+                            vtable.repr(tcx)));\n             }\n         }\n     });"}, {"sha": "5ab1ec2a69eda56f5aef11c173feae75c06871d2", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -177,7 +177,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   ..\n               } => {\n                   let d = mk_lldecl(abi);\n-                  let needs_body = setup_lldecl(d, &i.attrs[]);\n+                  let needs_body = setup_lldecl(d, &i.attrs);\n                   if needs_body {\n                       if abi != abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n@@ -220,7 +220,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             match *ii {\n                 ast::MethodImplItem(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, &mth.attrs[]);\n+                    let needs_body = setup_lldecl(d, &mth.attrs);\n                     if needs_body {\n                         trans_fn(ccx,\n                                  mth.pe_fn_decl(),\n@@ -241,7 +241,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             match *method {\n                 ast::ProvidedMethod(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, &mth.attrs[]);\n+                    let needs_body = setup_lldecl(d, &mth.attrs);\n                     if needs_body {\n                         trans_fn(ccx, mth.pe_fn_decl(), mth.pe_body(), d,\n                                  psubsts, mth.id, &[]);\n@@ -250,15 +250,15 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 }\n                 _ => {\n                     ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n-                                           map_node)[])\n+                                           map_node))\n                 }\n             }\n         }\n         ast_map::NodeStructCtor(struct_def) => {\n             let d = mk_lldecl(abi::Rust);\n             set_inline_hint(d);\n             base::trans_tuple_struct(ccx,\n-                                     &struct_def.fields[],\n+                                     &struct_def.fields,\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                                 didn't have a ctor id\"),\n                                      psubsts,\n@@ -276,7 +276,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast_map::NodePat(..) |\n         ast_map::NodeLocal(..) => {\n             ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n-                                   map_node)[])\n+                                   map_node))\n         }\n     };\n "}, {"sha": "0c69a7132a77be8b9855dc1b5b4a7c578445a0e5", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -109,7 +109,7 @@ impl Type {\n     }\n \n     pub fn int(ccx: &CrateContext) -> Type {\n-        match &ccx.tcx().sess.target.target.target_pointer_width[] {\n+        match &ccx.tcx().sess.target.target.target_pointer_width[..] {\n             \"32\" => Type::i32(ccx),\n             \"64\" => Type::i64(ccx),\n             tws => panic!(\"Unsupported target word size for int: {}\", tws),"}, {"sha": "b53ea79804c08f3815ab27ad53087c118cbf983b", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -185,7 +185,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     let llsizingty = match t.sty {\n         _ if !lltype_is_sized(cx.tcx(), t) => {\n             cx.sess().bug(&format!(\"trying to take the sizing type of {}, an unsized type\",\n-                                  ppaux::ty_to_string(cx.tcx(), t))[])\n+                                  ppaux::ty_to_string(cx.tcx(), t)))\n         }\n \n         ty::ty_bool => Type::bool(cx),\n@@ -238,7 +238,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n         ty::ty_projection(..) | ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n             cx.sess().bug(&format!(\"fictitious type {} in sizing_type_of()\",\n-                                  ppaux::ty_to_string(cx.tcx(), t))[])\n+                                  ppaux::ty_to_string(cx.tcx(), t)))\n         }\n         ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => panic!(\"unreachable\")\n     };\n@@ -418,7 +418,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           }\n           ty::ty_trait(..) => Type::opaque_trait(cx),\n           _ => cx.sess().bug(&format!(\"ty_open with sized type: {}\",\n-                                     ppaux::ty_to_string(cx.tcx(), t))[])\n+                                     ppaux::ty_to_string(cx.tcx(), t)))\n       },\n \n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),"}, {"sha": "afdc414c163ce17f103959f242164d0e688d96fe", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -195,7 +195,7 @@ pub fn opt_ast_region_to_region<'tcx>(\n                                     help_name\n                                 } else {\n                                     format!(\"one of {}'s {} elided lifetimes\", help_name, n)\n-                                })[]);\n+                                })[..]);\n \n                                 if len == 2 && i == 0 {\n                                     m.push_str(\" or \");\n@@ -876,7 +876,7 @@ pub fn ast_ty_to_builtin_ty<'tcx>(\n                         .sess\n                         .span_bug(ast_ty.span,\n                                   &format!(\"unbound path {}\",\n-                                          path.repr(this.tcx()))[])\n+                                          path.repr(this.tcx())))\n                 }\n                 Some(&d) => d\n             };\n@@ -898,7 +898,7 @@ pub fn ast_ty_to_builtin_ty<'tcx>(\n                             this.tcx().sess.span_bug(\n                                 path.span,\n                                 &format!(\"converting `Box` to `{}`\",\n-                                        ty.repr(this.tcx()))[]);\n+                                        ty.repr(this.tcx())));\n                         }\n                     }\n                 }\n@@ -1206,7 +1206,7 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                         tcx.sess\n                            .span_bug(ast_ty.span,\n                                      &format!(\"unbound path {}\",\n-                                             path.repr(tcx))[])\n+                                             path.repr(tcx)))\n                     }\n                     Some(&d) => d\n                 };\n@@ -1419,7 +1419,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     let input_params = if self_ty.is_some() {\n         &decl.inputs[1..]\n     } else {\n-        &decl.inputs[]\n+        &decl.inputs[..]\n     };\n     let input_tys = input_params.iter().map(|a| ty_of_arg(this, &rb, a, None));\n     let input_pats: Vec<String> = input_params.iter()"}, {"sha": "998a4504088a330394d69157cf5ec74687b9f2af", "filename": "src/librustc_typeck/check/implicator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n             ty::ty_open(_) => {\n                 self.tcx().sess.bug(\n                     &format!(\"Unexpected type encountered while doing wf check: {}\",\n-                            ty.repr(self.tcx()))[]);\n+                            ty.repr(self.tcx())));\n             }\n         }\n     }"}, {"sha": "53976df75d6160e5530a3c481c703afeb5e47cf1", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -331,7 +331,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 self.tcx().sess.span_bug(\n                     self.span,\n                     &format!(\"self-type `{}` for ObjectPick never dereferenced to an object\",\n-                            self_ty.repr(self.tcx()))[])\n+                            self_ty.repr(self.tcx())))\n             }\n         }\n     }\n@@ -386,7 +386,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     &format!(\n                         \"{} was a subtype of {} but now is not?\",\n                         self_ty.repr(self.tcx()),\n-                        method_self_ty.repr(self.tcx()))[]);\n+                        method_self_ty.repr(self.tcx())));\n             }\n         }\n     }"}, {"sha": "ed86925bd57daed348e6ba4e28baec299c40aaa4", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -272,7 +272,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                 span,\n                                 &format!(\n                                     \"trait method is &self but first arg is: {}\",\n-                                    transformed_self_ty.repr(fcx.tcx()))[]);\n+                                    transformed_self_ty.repr(fcx.tcx())));\n                         }\n                     }\n                 }\n@@ -282,7 +282,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         span,\n                         &format!(\n                             \"unexpected explicit self type in operator method: {:?}\",\n-                            method_ty.explicit_self)[]);\n+                            method_ty.explicit_self));\n                 }\n             }\n         }"}, {"sha": "1cc4fe37fbdddf59928799b287752c412457d9db", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -878,15 +878,15 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"pick_method(self_ty={})\", self.infcx().ty_to_string(self_ty));\n \n         debug!(\"searching inherent candidates\");\n-        match self.consider_candidates(self_ty, &self.inherent_candidates[]) {\n+        match self.consider_candidates(self_ty, &self.inherent_candidates) {\n             None => {}\n             Some(pick) => {\n                 return Some(pick);\n             }\n         }\n \n         debug!(\"searching extension candidates\");\n-        self.consider_candidates(self_ty, &self.extension_candidates[])\n+        self.consider_candidates(self_ty, &self.extension_candidates)\n     }\n \n     fn consider_candidates(&self,"}, {"sha": "f5a03f0721a65be59544993b9412d16caa22f532", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -71,7 +71,7 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if is_field {\n                 cx.sess.span_note(span,\n                     &format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                            function stored in the `{0}` field\", method_ustring)[]);\n+                            function stored in the `{0}` field\", method_ustring));\n             }\n \n             if static_sources.len() > 0 {"}, {"sha": "cab91b93133f85e7042929fa45cbffb1259f60db", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -615,7 +615,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     let tcx = ccx.tcx;\n     let err_count_on_creation = tcx.sess.err_count();\n \n-    let arg_tys = &fn_sig.inputs[];\n+    let arg_tys = &fn_sig.inputs;\n     let ret_ty = fn_sig.output;\n \n     debug!(\"check_fn(arg_tys={}, ret_ty={}, fn_id={})\",\n@@ -713,7 +713,7 @@ pub fn check_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n       ast::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n-                            &enum_definition.variants[],\n+                            &enum_definition.variants,\n                             it.id);\n       }\n       ast::ItemFn(ref decl, _, _, _, ref body) => {\n@@ -1334,7 +1334,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx().sess.span_bug(\n                     span,\n                     &format!(\"no type for local variable {}\",\n-                            nid)[]);\n+                            nid));\n             }\n         }\n     }\n@@ -1707,7 +1707,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(&format!(\"no type for expr in fcx {}\",\n-                                            self.tag())[]);\n+                                            self.tag()));\n             }\n         }\n     }\n@@ -1739,7 +1739,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\"no type for node {}: {} in fcx {}\",\n                             id, self.tcx().map.node_to_string(id),\n-                            self.tag())[]);\n+                            self.tag()));\n             }\n         }\n     }\n@@ -2275,7 +2275,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         if arg_types.len() == 1 {\"\"} else {\"s\"},\n                         args.len(),\n                         if args.len() == 1 {\" was\"} else {\"s were\"});\n-                    expected_arg_tys = &[][];\n+                    expected_arg_tys = &[];\n                     err_args(fcx.tcx(), args.len())\n                 } else {\n                     expected_arg_tys = match expected_arg_tys.get(0) {\n@@ -2292,7 +2292,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 span_err!(tcx.sess, sp, E0059,\n                     \"cannot use call notation; the first type parameter \\\n                      for the function trait is neither a tuple nor unit\");\n-                expected_arg_tys = &[][];\n+                expected_arg_tys = &[];\n                 err_args(fcx.tcx(), args.len())\n             }\n         }\n@@ -2309,7 +2309,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 if expected_arg_count == 1 {\"\"} else {\"s\"},\n                 supplied_arg_count,\n                 if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n-            expected_arg_tys = &[][];\n+            expected_arg_tys = &[];\n             err_args(fcx.tcx(), supplied_arg_count)\n         }\n     } else {\n@@ -2319,7 +2319,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if expected_arg_count == 1 {\"\"} else {\"s\"},\n             supplied_arg_count,\n             if supplied_arg_count == 1 {\" was\"} else {\"s were\"});\n-        expected_arg_tys = &[][];\n+        expected_arg_tys = &[];\n         err_args(fcx.tcx(), supplied_arg_count)\n     };\n \n@@ -2809,7 +2809,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n         let args = match rhs {\n             Some(rhs) => slice::ref_slice(rhs),\n-            None => &[][]\n+            None => &[][..]\n         };\n         match method {\n             Some(method) => {\n@@ -4584,7 +4584,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n \n     let hint = *ty::lookup_repr_hints(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n-        [].get(0).unwrap_or(&attr::ReprAny);\n+        .get(0).unwrap_or(&attr::ReprAny);\n \n     if hint != attr::ReprAny && vs.len() <= 1 {\n         if vs.len() == 1 {"}, {"sha": "f6ac1ddee497694ac39c4be6d7edbd6af4a7d9e0", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -188,7 +188,7 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n         }\n         _ => {\n             tcx.sess.bug(&format!(\"unexpected def in region_of_def: {:?}\",\n-                                 def)[])\n+                                 def))\n         }\n     }\n }\n@@ -288,7 +288,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             Some(f) => f,\n             None => {\n                 self.tcx().sess.bug(\n-                    &format!(\"No fn-sig entry for id={}\", id)[]);\n+                    &format!(\"No fn-sig entry for id={}\", id));\n             }\n         };\n \n@@ -1013,7 +1013,7 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                         rcx.tcx().sess.span_bug(\n                             deref_expr.span,\n                             &format!(\"bad overloaded deref type {}\",\n-                                     method.ty.repr(rcx.tcx()))[])\n+                                     method.ty.repr(rcx.tcx())))\n                     }\n                 };\n \n@@ -1417,7 +1417,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                     rcx.tcx().sess.span_bug(\n                         span,\n                         &format!(\"Illegal upvar id: {}\",\n-                                upvar_id.repr(rcx.tcx()))[]);\n+                                upvar_id.repr(rcx.tcx())));\n                 }\n             }\n         }\n@@ -1562,7 +1562,7 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n         GenericKind::Param(..) => { }\n         GenericKind::Projection(ref projection_ty) => {\n             param_bounds.push_all(\n-                &projection_bounds(rcx, origin.span(), projection_ty)[]);\n+                &projection_bounds(rcx, origin.span(), projection_ty));\n         }\n     }\n "}, {"sha": "b0ded25af1700d0440e2d5ef442812946103a8be", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -393,7 +393,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         self.tcx().sess.span_err(\n             span,\n             &format!(\"parameter `{}` is never used\",\n-                     param_name.user_string(self.tcx()))[]);\n+                     param_name.user_string(self.tcx())));\n \n         match suggested_marker_id {\n             Some(def_id) => {"}, {"sha": "7215ab01b02dec250d1e7b22509b6a10dc9be742", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -86,7 +86,7 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n             inference_context.tcx.sess.span_bug(\n                 span,\n                 &format!(\"coherence encountered unexpected type searching for base type: {}\",\n-                        ty.repr(inference_context.tcx))[]);\n+                        ty.repr(inference_context.tcx)));\n         }\n     }\n }"}, {"sha": "bb5566ab131ec1c7559a2af6c708f6307cf1b8ab", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -899,7 +899,7 @@ fn get_trait_def<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n         _ => {\n             tcx.sess.bug(&format!(\"get_trait_def({}): not an item\",\n-                                  trait_id.node)[])\n+                                  trait_id.node))\n         }\n     }\n }\n@@ -925,7 +925,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n-                &format!(\"trait_def_of_item invoked on {:?}\", s)[]);\n+                &format!(\"trait_def_of_item invoked on {:?}\", s));\n         }\n     };\n \n@@ -1025,7 +1025,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Ite\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n-                &format!(\"trait_def_of_item invoked on {:?}\", s)[]);\n+                &format!(\"trait_def_of_item invoked on {:?}\", s));\n         }\n     };\n \n@@ -1284,8 +1284,8 @@ fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                           -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n-                &generics.lifetimes[],\n-                &generics.ty_params[],\n+                &generics.lifetimes,\n+                &generics.ty_params,\n                 &generics.where_clause,\n                 ty::Generics::empty())\n }\n@@ -1314,8 +1314,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     let mut generics =\n         ty_generics(ccx,\n                     subst::TypeSpace,\n-                    &ast_generics.lifetimes[],\n-                    &ast_generics.ty_params[],\n+                    &ast_generics.lifetimes,\n+                    &ast_generics.ty_params,\n                     &ast_generics.where_clause,\n                     ty::Generics::empty());\n \n@@ -1360,7 +1360,7 @@ fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     ty_generics(ccx,\n                 subst::FnSpace,\n                 &early_lifetimes[..],\n-                &generics.ty_params[],\n+                &generics.ty_params,\n                 &generics.where_clause,\n                 base_generics)\n }\n@@ -1557,7 +1557,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     let param_ty = ty::ParamTy::new(space, index, param.ident.name);\n     let bounds = compute_bounds(ccx,\n                                 param_ty.to_ty(ccx.tcx),\n-                                &param.bounds[],\n+                                &param.bounds,\n                                 SizedByDefault::Yes,\n                                 param.span);\n     let default = match param.default {\n@@ -1733,7 +1733,7 @@ fn check_bounds_compatible<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n         ty::each_bound_trait_and_supertraits(\n             ccx.tcx,\n-            &param_bounds.trait_bounds[],\n+            &param_bounds.trait_bounds,\n             |trait_ref| {\n                 let trait_def = ccx.get_trait_def(trait_ref.def_id());\n                 if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {"}, {"sha": "78f13b37a8238012127ec66826562a994b3d0d42", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -253,7 +253,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                               &format!(\"main has a non-function type: found \\\n                                        `{}`\",\n                                       ppaux::ty_to_string(tcx,\n-                                                       main_t))[]);\n+                                                       main_t)));\n         }\n     }\n }\n@@ -304,7 +304,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             tcx.sess.span_bug(start_span,\n                               &format!(\"start has a non-function type: found \\\n                                        `{}`\",\n-                                      ppaux::ty_to_string(tcx, start_t))[]);\n+                                      ppaux::ty_to_string(tcx, start_t)));\n         }\n     }\n }"}, {"sha": "cd4406b770dbfbe4b113fa70975096189dafb6b5", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -595,7 +595,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                 let trait_def = ty::lookup_trait_def(tcx, did);\n                 let predicates = ty::predicates(tcx, ty::mk_self_type(tcx), &trait_def.bounds);\n                 self.add_constraints_from_predicates(&trait_def.generics,\n-                                                     &predicates[],\n+                                                     &predicates,\n                                                      self.covariant);\n \n                 let trait_items = ty::trait_items(tcx, did);\n@@ -652,7 +652,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             None => {\n                 self.tcx().sess.bug(&format!(\n                         \"no inferred index entry for {}\",\n-                        self.tcx().map.node_to_string(param_id))[]);\n+                        self.tcx().map.node_to_string(param_id)));\n             }\n         }\n     }\n@@ -941,7 +941,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\"unexpected type encountered in \\\n                             variance inference: {}\",\n-                            ty.repr(self.tcx()))[]);\n+                            ty.repr(self.tcx())));\n             }\n         }\n     }\n@@ -1071,7 +1071,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     .sess\n                     .bug(&format!(\"unexpected region encountered in variance \\\n                                   inference: {}\",\n-                                 region.repr(self.tcx()))[]);\n+                                 region.repr(self.tcx())));\n             }\n         }\n     }"}, {"sha": "19c34aff9a81eaffbb3ac6314381f5adf79d2f02", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -2169,7 +2169,7 @@ impl Clean<Vec<Item>> for doctree::Import {\n         // forcefully don't inline if this is not public or if the\n         // #[doc(no_inline)] attribute is present.\n         let denied = self.vis != ast::Public || self.attrs.iter().any(|a| {\n-            &a.name()[] == \"doc\" && match a.meta_item_list() {\n+            &a.name()[..] == \"doc\" && match a.meta_item_list() {\n                 Some(l) => attr::contains_name(l, \"no_inline\"),\n                 None => false,\n             }"}, {"sha": "b88e5065b4f9c82b77f2801a82529010b039e446", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -142,7 +142,7 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n \n             // keywords are also included in the identifier set\n             token::Ident(ident, _is_mod_sep) => {\n-                match &token::get_ident(ident)[] {\n+                match &token::get_ident(ident)[..] {\n                     \"ref\" | \"mut\" => \"kw-2\",\n \n                     \"self\" => \"self\","}, {"sha": "9181682d176d64c09a8c760aa8a63d2d840c9f1e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -253,7 +253,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     let please_inline = item.attrs.iter().any(|item| {\n                         match item.meta_item_list() {\n                             Some(list) => {\n-                                list.iter().any(|i| &i.name()[] == \"inline\")\n+                                list.iter().any(|i| &i.name()[..] == \"inline\")\n                             }\n                             None => false,\n                         }"}, {"sha": "009bfef86230f76add03dc90a0232912a67969b6", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -113,7 +113,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                         Some(('=', _)) => None,\n                         Some(('+', operand)) => {\n                             Some(token::intern_and_get_ident(&format!(\n-                                        \"={}\", operand)[]))\n+                                        \"={}\", operand)))\n                         }\n                         _ => {\n                             cx.span_err(span, \"output operand constraint lacks '=' or '+'\");"}, {"sha": "2ef90f04f7527d214cf07b779a1a453ec0041f61", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -83,15 +83,15 @@ pub enum Annotatable {\n impl Annotatable {\n     pub fn attrs(&self) -> &[ast::Attribute] {\n         match *self {\n-            Annotatable::Item(ref i) => &i.attrs[],\n+            Annotatable::Item(ref i) => &i.attrs,\n             Annotatable::TraitItem(ref i) => match *i {\n-                ast::TraitItem::RequiredMethod(ref tm) => &tm.attrs[],\n-                ast::TraitItem::ProvidedMethod(ref m) => &m.attrs[],\n-                ast::TraitItem::TypeTraitItem(ref at) => &at.attrs[],\n+                ast::TraitItem::RequiredMethod(ref tm) => &tm.attrs,\n+                ast::TraitItem::ProvidedMethod(ref m) => &m.attrs,\n+                ast::TraitItem::TypeTraitItem(ref at) => &at.attrs,\n             },\n             Annotatable::ImplItem(ref i) => match *i {\n-                ast::ImplItem::MethodImplItem(ref m) => &m.attrs[],\n-                ast::ImplItem::TypeImplItem(ref t) => &t.attrs[],\n+                ast::ImplItem::MethodImplItem(ref m) => &m.attrs,\n+                ast::ImplItem::TypeImplItem(ref t) => &t.attrs,\n             }\n         }\n     }\n@@ -639,7 +639,7 @@ impl<'a> ExtCtxt<'a> {\n     pub fn mod_pop(&mut self) { self.mod_path.pop().unwrap(); }\n     pub fn mod_path(&self) -> Vec<ast::Ident> {\n         let mut v = Vec::new();\n-        v.push(token::str_to_ident(&self.ecfg.crate_name[]));\n+        v.push(token::str_to_ident(&self.ecfg.crate_name));\n         v.extend(self.mod_path.iter().cloned());\n         return v;\n     }\n@@ -648,7 +648,7 @@ impl<'a> ExtCtxt<'a> {\n         if self.recursion_count > self.ecfg.recursion_limit {\n             self.span_fatal(ei.call_site,\n                             &format!(\"recursion limit reached while expanding the macro `{}`\",\n-                                    ei.callee.name)[]);\n+                                    ei.callee.name));\n         }\n \n         let mut call_site = ei.call_site;\n@@ -773,7 +773,7 @@ pub fn check_zero_tts(cx: &ExtCtxt,\n                       tts: &[ast::TokenTree],\n                       name: &str) {\n     if tts.len() != 0 {\n-        cx.span_err(sp, &format!(\"{} takes no arguments\", name)[]);\n+        cx.span_err(sp, &format!(\"{} takes no arguments\", name));\n     }\n }\n \n@@ -786,12 +786,12 @@ pub fn get_single_str_from_tts(cx: &mut ExtCtxt,\n                                -> Option<String> {\n     let mut p = cx.new_parser_from_tts(tts);\n     if p.token == token::Eof {\n-        cx.span_err(sp, &format!(\"{} takes 1 argument\", name)[]);\n+        cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n         return None\n     }\n     let ret = cx.expander().fold_expr(p.parse_expr());\n     if p.token != token::Eof {\n-        cx.span_err(sp, &format!(\"{} takes 1 argument\", name)[]);\n+        cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n     }\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| {\n         s.to_string()"}, {"sha": "8923290d655c81812071a3fb04da62324b3839d5", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -762,7 +762,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         let expr_file = self.expr_str(span,\n-                                      token::intern_and_get_ident(&loc.file.name[]));\n+                                      token::intern_and_get_ident(&loc.file.name));\n         let expr_line = self.expr_usize(span, loc.line);\n         let expr_file_line_tuple = self.expr_tuple(span, vec!(expr_file, expr_line));\n         let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);"}, {"sha": "84f786e9780f0425bbdc089827060c50d0e31ad6", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -40,14 +40,14 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                     ast::LitInt(i, ast::UnsignedIntLit(_)) |\n                     ast::LitInt(i, ast::SignedIntLit(_, ast::Plus)) |\n                     ast::LitInt(i, ast::UnsuffixedIntLit(ast::Plus)) => {\n-                        accumulator.push_str(&format!(\"{}\", i)[]);\n+                        accumulator.push_str(&format!(\"{}\", i));\n                     }\n                     ast::LitInt(i, ast::SignedIntLit(_, ast::Minus)) |\n                     ast::LitInt(i, ast::UnsuffixedIntLit(ast::Minus)) => {\n-                        accumulator.push_str(&format!(\"-{}\", i)[]);\n+                        accumulator.push_str(&format!(\"-{}\", i));\n                     }\n                     ast::LitBool(b) => {\n-                        accumulator.push_str(&format!(\"{}\", b)[]);\n+                        accumulator.push_str(&format!(\"{}\", b));\n                     }\n                     ast::LitByte(..) |\n                     ast::LitBinary(..) => {"}, {"sha": "5f460264216a1567182a5c8b63f3d6bb44623455", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -81,11 +81,11 @@ fn cs_clone(\n         EnumNonMatchingCollapsed (..) => {\n             cx.span_bug(trait_span,\n                         &format!(\"non-matching enum variants in \\\n-                                 `derive({})`\", name)[])\n+                                 `derive({})`\", name))\n         }\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span,\n-                        &format!(\"static method in `derive({})`\", name)[])\n+                        &format!(\"static method in `derive({})`\", name))\n         }\n     }\n \n@@ -102,7 +102,7 @@ fn cs_clone(\n                 None => {\n                     cx.span_bug(trait_span,\n                                 &format!(\"unnamed field in normal struct in \\\n-                                         `derive({})`\", name)[])\n+                                         `derive({})`\", name))\n                 }\n             };\n             cx.field_imm(field.span, ident, subcall(field))"}, {"sha": "f27bbc338e5704b05f89bb5573d3834c1ca01695", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -204,7 +204,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n             } else {\n                 let fields = fields.iter().enumerate().map(|(i, &span)| {\n                     getarg(cx, span,\n-                           token::intern_and_get_ident(&format!(\"_field{}\", i)[]),\n+                           token::intern_and_get_ident(&format!(\"_field{}\", i)),\n                            i)\n                 }).collect();\n "}, {"sha": "8038074cee14fbe3473da0f0ce5997bbb6a9b800", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -191,7 +191,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 let name = match name {\n                     Some(id) => token::get_ident(id),\n                     None => {\n-                        token::intern_and_get_ident(&format!(\"_field{}\", i)[])\n+                        token::intern_and_get_ident(&format!(\"_field{}\", i))\n                     }\n                 };\n                 let enc = cx.expr_method_call(span, self_.clone(),"}, {"sha": "36bd8d39a83631af78f184b09e9a4b770f5ec721", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -363,7 +363,7 @@ impl<'a> TraitDef<'a> {\n         // generated implementations are linted\n         let mut attrs = newitem.attrs.clone();\n         attrs.extend(item.attrs.iter().filter(|a| {\n-            match &a.name()[] {\n+            match &a.name()[..] {\n                 \"allow\" | \"warn\" | \"deny\" | \"forbid\" => true,\n                 _ => false,\n             }\n@@ -671,7 +671,7 @@ impl<'a> MethodDef<'a> {\n \n         for (i, ty) in self.args.iter().enumerate() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n-            let ident = cx.ident_of(&format!(\"__arg_{}\", i)[]);\n+            let ident = cx.ident_of(&format!(\"__arg_{}\", i));\n             arg_tys.push((ident, ast_ty));\n \n             let arg_expr = cx.expr_ident(trait_.span, ident);\n@@ -778,7 +778,7 @@ impl<'a> MethodDef<'a> {\n                                              struct_path,\n                                              struct_def,\n                                              &format!(\"__self_{}\",\n-                                                     i)[],\n+                                                     i),\n                                              ast::MutImmutable);\n             patterns.push(pat);\n             raw_fields.push(ident_expr);\n@@ -971,7 +971,7 @@ impl<'a> MethodDef<'a> {\n                 let mut subpats = Vec::with_capacity(self_arg_names.len());\n                 let mut self_pats_idents = Vec::with_capacity(self_arg_names.len() - 1);\n                 let first_self_pat_idents = {\n-                    let (p, idents) = mk_self_pat(cx, &self_arg_names[0][]);\n+                    let (p, idents) = mk_self_pat(cx, &self_arg_names[0]);\n                     subpats.push(p);\n                     idents\n                 };\n@@ -1289,7 +1289,7 @@ impl<'a> TraitDef<'a> {\n                     cx.span_bug(sp, \"a struct with named and unnamed fields in `derive`\");\n                 }\n             };\n-            let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i)[]);\n+            let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n             paths.push(codemap::Spanned{span: sp, node: ident});\n             let val = cx.expr(\n                 sp, ast::ExprParen(cx.expr_deref(sp, cx.expr_path(cx.path_ident(sp,ident)))));\n@@ -1335,7 +1335,7 @@ impl<'a> TraitDef<'a> {\n                 let mut ident_expr = Vec::new();\n                 for (i, va) in variant_args.iter().enumerate() {\n                     let sp = self.set_expn_info(cx, va.ty.span);\n-                    let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i)[]);\n+                    let ident = cx.ident_of(&format!(\"{}_{}\", prefix, i));\n                     let path1 = codemap::Spanned{span: sp, node: ident};\n                     paths.push(path1);\n                     let expr_path = cx.expr_path(cx.path_ident(sp, ident));\n@@ -1378,15 +1378,15 @@ pub fn cs_fold<F>(use_foldl: bool,\n                       field.span,\n                       old,\n                       field.self_.clone(),\n-                      &field.other[])\n+                      &field.other)\n                 })\n             } else {\n                 all_fields.iter().rev().fold(base, |old, field| {\n                     f(cx,\n                       field.span,\n                       old,\n                       field.self_.clone(),\n-                      &field.other[])\n+                      &field.other)\n                 })\n             }\n         },"}, {"sha": "eee780f457c9f053049e67f174f093c9016b5477", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -157,7 +157,7 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n                                 cx.span_err(titem.span,\n                                             &format!(\"unknown `derive` \\\n                                                      trait: `{}`\",\n-                                                    *tname)[]);\n+                                                    *tname));\n                             }\n                         };\n                     }"}, {"sha": "93f8ee5042bb1674e7843180e51bbc5832c827d7", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -83,7 +83,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n         None => {\n             token::intern_and_get_ident(&format!(\"environment variable `{}` \\\n                                                  not defined\",\n-                                                var)[])\n+                                                var))\n         }\n         Some(second) => {\n             match expr_to_string(cx, second, \"expected string literal\") {"}, {"sha": "a2f9dc6b5f82b95addc9dc8557b0d2ae9241653d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -389,7 +389,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                     fld.cx.span_err(\n                         pth.span,\n                         &format!(\"macro undefined: '{}!'\",\n-                                &extnamestr)[]);\n+                                &extnamestr));\n \n                     // let compilation continue\n                     None\n@@ -426,7 +426,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                                     pth.span,\n                                     &format!(\"non-expression macro in expression position: {}\",\n                                             &extnamestr[..]\n-                                            )[]);\n+                                            ));\n                                 return None;\n                             }\n                         };\n@@ -436,7 +436,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n                         fld.cx.span_err(\n                             pth.span,\n                             &format!(\"'{}' is not a tt-style macro\",\n-                                    &extnamestr)[]);\n+                                    &extnamestr));\n                         None\n                     }\n                 }\n@@ -608,7 +608,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n             None => {\n                 fld.cx.span_err(path_span,\n                                 &format!(\"macro undefined: '{}!'\",\n-                                        extnamestr)[]);\n+                                        extnamestr));\n                 // let compilation continue\n                 return SmallVector::zero();\n             }\n@@ -618,10 +618,9 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     if it.ident.name != parse::token::special_idents::invalid.name {\n                         fld.cx\n                             .span_err(path_span,\n-                                      &format!(\"macro {}! expects no ident argument, \\\n-                                        given '{}'\",\n-                                      extnamestr,\n-                                      token::get_ident(it.ident))[]);\n+                                      &format!(\"macro {}! expects no ident argument, given '{}'\",\n+                                               extnamestr,\n+                                               token::get_ident(it.ident)));\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -640,7 +639,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n                                         &format!(\"macro {}! expects an ident argument\",\n-                                                &extnamestr)[]);\n+                                                &extnamestr));\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -659,7 +658,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     if it.ident.name == parse::token::special_idents::invalid.name {\n                         fld.cx.span_err(path_span,\n                                         &format!(\"macro_rules! expects an ident argument\")\n-                                        []);\n+                                        );\n                         return SmallVector::zero();\n                     }\n                     fld.cx.bt_push(ExpnInfo {\n@@ -691,7 +690,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                 _ => {\n                     fld.cx.span_err(it.span,\n                                     &format!(\"{}! is not legal in item position\",\n-                                            &extnamestr)[]);\n+                                            &extnamestr));\n                     return SmallVector::zero();\n                 }\n             }\n@@ -710,7 +709,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n         None => {\n             fld.cx.span_err(path_span,\n                             &format!(\"non-item macro in item position: {}\",\n-                                    &extnamestr)[]);\n+                                    &extnamestr));\n             return SmallVector::zero();\n         }\n     };\n@@ -954,7 +953,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n             None => {\n                 fld.cx.span_err(pth.span,\n                                 &format!(\"macro undefined: '{}!'\",\n-                                        extnamestr)[]);\n+                                        extnamestr));\n                 // let compilation continue\n                 return DummyResult::raw_pat(span);\n             }\n@@ -983,7 +982,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                                 &format!(\n                                     \"non-pattern macro in pattern position: {}\",\n                                     &extnamestr\n-                                    )[]\n+                                    )\n                             );\n                             return DummyResult::raw_pat(span);\n                         }\n@@ -995,7 +994,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                 _ => {\n                     fld.cx.span_err(span,\n                                     &format!(\"{}! is not legal in pattern position\",\n-                                            &extnamestr)[]);\n+                                            &extnamestr));\n                     return DummyResult::raw_pat(span);\n                 }\n             }\n@@ -1981,7 +1980,7 @@ foo_module!();\n         // the xx binding should bind all of the xx varrefs:\n         for (idx,v) in varrefs.iter().filter(|p| {\n             p.segments.len() == 1\n-            && \"xx\" == &token::get_ident(p.segments[0].identifier)[]\n+            && \"xx\" == &token::get_ident(p.segments[0].identifier)\n         }).enumerate() {\n             if mtwt::resolve(v.segments[0].identifier) != resolved_binding {\n                 println!(\"uh oh, xx binding didn't match xx varref:\");"}, {"sha": "1c2374e31f13037820596790264e98aeea593981", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -113,7 +113,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 _ => {\n                     ecx.span_err(p.span,\n                                  &format!(\"expected ident for named argument, found `{}`\",\n-                                         p.this_token_to_string())[]);\n+                                         p.this_token_to_string()));\n                     return None;\n                 }\n             };\n@@ -127,7 +127,7 @@ fn parse_args(ecx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n                 Some(prev) => {\n                     ecx.span_err(e.span,\n                                  &format!(\"duplicate argument named `{}`\",\n-                                         name)[]);\n+                                         name));\n                     ecx.parse_sess.span_diagnostic.span_note(prev.span, \"previously here\");\n                     continue\n                 }\n@@ -281,19 +281,19 @@ impl<'a, 'b> Context<'a, 'b> {\n                                   &format!(\"argument redeclared with type `{}` when \\\n                                            it was previously `{}`\",\n                                           *ty,\n-                                          *cur)[]);\n+                                          *cur));\n             }\n             (&Known(ref cur), _) => {\n                 self.ecx.span_err(sp,\n                                   &format!(\"argument used to format with `{}` was \\\n                                            attempted to not be used for formatting\",\n-                                           *cur)[]);\n+                                           *cur));\n             }\n             (_, &Known(ref ty)) => {\n                 self.ecx.span_err(sp,\n                                   &format!(\"argument previously used as a format \\\n                                            argument attempted to be used as `{}`\",\n-                                           *ty)[]);\n+                                           *ty));\n             }\n             (_, _) => {\n                 self.ecx.span_err(sp, \"argument declared with multiple formats\");\n@@ -337,7 +337,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Translate the accumulated string literals to a literal expression\n     fn trans_literal_string(&mut self) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n-        let s = token::intern_and_get_ident(&self.literal[]);\n+        let s = token::intern_and_get_ident(&self.literal);\n         self.literal.clear();\n         self.ecx.expr_str(sp, s)\n     }\n@@ -494,7 +494,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 None => continue // error already generated\n             };\n \n-            let name = self.ecx.ident_of(&format!(\"__arg{}\", i)[]);\n+            let name = self.ecx.ident_of(&format!(\"__arg{}\", i));\n             pats.push(self.ecx.pat_ident(e.span, name));\n             locals.push(Context::format_arg(self.ecx, e.span, arg_ty,\n                                             self.ecx.expr_ident(e.span, name)));\n@@ -511,7 +511,7 @@ impl<'a, 'b> Context<'a, 'b> {\n             };\n \n             let lname = self.ecx.ident_of(&format!(\"__arg{}\",\n-                                                  *name)[]);\n+                                                  *name));\n             pats.push(self.ecx.pat_ident(e.span, lname));\n             names[self.name_positions[*name]] =\n                 Some(Context::format_arg(self.ecx, e.span, arg_ty,\n@@ -600,7 +600,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     _ => {\n                         ecx.span_err(sp,\n                                      &format!(\"unknown format trait `{}`\",\n-                                             *tyname)[]);\n+                                             *tyname));\n                         \"Dummy\"\n                     }\n                 }\n@@ -694,7 +694,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt, sp: Span,\n     }\n     if !parser.errors.is_empty() {\n         cx.ecx.span_err(cx.fmtsp, &format!(\"invalid format string: {}\",\n-                                          parser.errors.remove(0))[]);\n+                                          parser.errors.remove(0)));\n         return DummyResult::raw_expr(sp);\n     }\n     if !cx.literal.is_empty() {"}, {"sha": "554529b5cb23cc4a805d1d9f69cce55372ac905a", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -466,7 +466,7 @@ pub fn expand_quote_stmt(cx: &mut ExtCtxt,\n }\n \n fn ids_ext(strs: Vec<String> ) -> Vec<ast::Ident> {\n-    strs.iter().map(|str| str_to_ident(&(*str)[])).collect()\n+    strs.iter().map(|str| str_to_ident(&(*str))).collect()\n }\n \n fn id_ext(str: &str) -> ast::Ident {"}, {"sha": "ac82effeaeacdbdaf4043b268c3b6e11b4cf1ec4", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -57,7 +57,7 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let topmost = cx.original_span_in_file();\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n-    let filename = token::intern_and_get_ident(&loc.file.name[]);\n+    let filename = token::intern_and_get_ident(&loc.file.name);\n     base::MacExpr::new(cx.expr_str(topmost, filename))\n }\n "}, {"sha": "ce513bc91f5a998fda321bb638b4a68bbd0d926c", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -153,7 +153,7 @@ pub fn count_names(ms: &[TokenTree]) -> usize {\n                 seq.num_captures\n             }\n             &TtDelimited(_, ref delim) => {\n-                count_names(&delim.tts[])\n+                count_names(&delim.tts)\n             }\n             &TtToken(_, MatchNt(..)) => {\n                 1"}, {"sha": "a0e2b4dbf5a70bae65ede6b0efb4c520ac2a8f1e", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -94,7 +94,7 @@ impl<'a> ParserAttr for Parser<'a> {\n             }\n             _ => {\n                 let token_str = self.this_token_to_string();\n-                self.fatal(&format!(\"expected `#`, found `{}`\", token_str)[]);\n+                self.fatal(&format!(\"expected `#`, found `{}`\", token_str));\n             }\n         };\n "}, {"sha": "83d2bb0cc70a9b542572ab7ddd6f86a16e80f68c", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -1109,7 +1109,7 @@ impl<'a> StringReader<'a> {\n                 // expansion purposes. See #12512 for the gory details of why\n                 // this is necessary.\n                 let ident = self.with_str_from(start, |lifetime_name| {\n-                    str_to_ident(&format!(\"'{}\", lifetime_name)[])\n+                    str_to_ident(&format!(\"'{}\", lifetime_name))\n                 });\n \n                 // Conjure up a \"keyword checking ident\" to make sure that"}, {"sha": "f826e43528bd83ebf45d56e7ae6d581aa3cd3192", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -254,7 +254,7 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n         Ok(bytes) => bytes,\n         Err(e) => {\n             err(&format!(\"couldn't read {:?}: {}\",\n-                        path.display(), e)[]);\n+                        path.display(), e));\n             unreachable!()\n         }\n     };\n@@ -264,7 +264,7 @@ pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n                                      path.as_str().unwrap().to_string())\n         }\n         None => {\n-            err(&format!(\"{:?} is not UTF-8 encoded\", path.display())[])\n+            err(&format!(\"{:?} is not UTF-8 encoded\", path.display()))\n         }\n     }\n     unreachable!()\n@@ -827,19 +827,19 @@ mod test {\n              ast::TtDelimited(_, ref macro_delimed)]\n             if name_macro_rules.as_str() == \"macro_rules\"\n             && name_zip.as_str() == \"zip\" => {\n-                match &macro_delimed.tts[] {\n+                match &macro_delimed.tts {\n                     [ast::TtDelimited(_, ref first_delimed),\n                      ast::TtToken(_, token::FatArrow),\n                      ast::TtDelimited(_, ref second_delimed)]\n                     if macro_delimed.delim == token::Paren => {\n-                        match &first_delimed.tts[] {\n+                        match &first_delimed.tts {\n                             [ast::TtToken(_, token::Dollar),\n                              ast::TtToken(_, token::Ident(name, token::Plain))]\n                             if first_delimed.delim == token::Paren\n                             && name.as_str() == \"a\" => {},\n                             _ => panic!(\"value 3: {:?}\", **first_delimed),\n                         }\n-                        match &second_delimed.tts[] {\n+                        match &second_delimed.tts {\n                             [ast::TtToken(_, token::Dollar),\n                              ast::TtToken(_, token::Ident(name, token::Plain))]\n                             if second_delimed.delim == token::Paren\n@@ -1207,7 +1207,7 @@ mod test {\n \n         let source = \"/// doc comment\\r\\n/// line 2\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name.clone(), source, Vec::new(), &sess).unwrap();\n-        let docs = item.attrs.iter().filter(|a| &a.name()[] == \"doc\")\n+        let docs = item.attrs.iter().filter(|a| &a.name() == \"doc\")\n                     .map(|a| a.value_str().unwrap().to_string()).collect::<Vec<_>>();\n         let b: &[_] = &[\"/// doc comment\".to_string(), \"/// line 2\".to_string()];\n         assert_eq!(&docs[..], b);"}, {"sha": "e6bcb8ac745675b0c4a8ec2320db2311805f6dfb", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -106,16 +106,16 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n               desc: &str,\n               error: bool) {\n         if error {\n-            self.span_err(sp, &format!(\"obsolete syntax: {}\", kind_str)[]);\n+            self.span_err(sp, &format!(\"obsolete syntax: {}\", kind_str));\n         } else {\n-            self.span_warn(sp, &format!(\"obsolete syntax: {}\", kind_str)[]);\n+            self.span_warn(sp, &format!(\"obsolete syntax: {}\", kind_str));\n         }\n \n         if !self.obsolete_set.contains(&kind) {\n             self.sess\n                 .span_diagnostic\n                 .handler()\n-                .note(&format!(\"{}\", desc)[]);\n+                .note(&format!(\"{}\", desc));\n             self.obsolete_set.insert(kind);\n         }\n     }"}, {"sha": "88c349371592c4cacce0d33d5a3816c88a27a404", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -2562,7 +2562,8 @@ impl<'a> Parser<'a> {\n                     let index = self.mk_index(e, ix);\n                     e = self.mk_expr(lo, hi, index);\n \n-                    self.obsolete(span, ObsoleteSyntax::EmptyIndex);\n+                    let obsolete_span = mk_sp(bracket_pos, hi);\n+                    self.obsolete(obsolete_span, ObsoleteSyntax::EmptyIndex);\n                 } else {\n                     let ix = self.parse_expr();\n                     hi = self.span.hi;\n@@ -5190,7 +5191,7 @@ impl<'a> Parser<'a> {\n                     -> (ast::Item_, Vec<ast::Attribute> ) {\n         let mut prefix = Path::new(self.sess.span_diagnostic.cm.span_to_filename(self.span));\n         prefix.pop();\n-        let mod_path = Path::new(\".\").join_many(&self.mod_path_stack[]);\n+        let mod_path = Path::new(\".\").join_many(&self.mod_path_stack);\n         let dir_path = prefix.join(&mod_path);\n         let mod_string = token::get_ident(id);\n         let (file_path, owns_directory) = match ::attr::first_attr_value_str_by_name("}, {"sha": "2797ef084d9caf36185d985b3bd46ed437f9b755", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -652,47 +652,47 @@ impl BytesContainer for InternedString {\n \n impl fmt::Debug for InternedString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.string[], f)\n+        fmt::Debug::fmt(&self.string, f)\n     }\n }\n \n impl fmt::Display for InternedString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.string[], f)\n+        fmt::Display::fmt(&self.string, f)\n     }\n }\n \n impl<'a> PartialEq<&'a str> for InternedString {\n     #[inline(always)]\n     fn eq(&self, other: & &'a str) -> bool {\n-        PartialEq::eq(&self.string[], *other)\n+        PartialEq::eq(&self.string[..], *other)\n     }\n     #[inline(always)]\n     fn ne(&self, other: & &'a str) -> bool {\n-        PartialEq::ne(&self.string[], *other)\n+        PartialEq::ne(&self.string[..], *other)\n     }\n }\n \n impl<'a> PartialEq<InternedString > for &'a str {\n     #[inline(always)]\n     fn eq(&self, other: &InternedString) -> bool {\n-        PartialEq::eq(*self, &other.string[])\n+        PartialEq::eq(*self, &other.string[..])\n     }\n     #[inline(always)]\n     fn ne(&self, other: &InternedString) -> bool {\n-        PartialEq::ne(*self, &other.string[])\n+        PartialEq::ne(*self, &other.string[..])\n     }\n }\n \n impl Decodable for InternedString {\n     fn decode<D: Decoder>(d: &mut D) -> Result<InternedString, D::Error> {\n-        Ok(get_name(get_ident_interner().intern(&try!(d.read_str())[])))\n+        Ok(get_name(get_ident_interner().intern(&try!(d.read_str())[..])))\n     }\n }\n \n impl Encodable for InternedString {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(&self.string[])\n+        s.emit_str(&self.string)\n     }\n }\n "}, {"sha": "5b3fde8535b3df4dfd1a8a189a722047e0d8e02b", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -139,7 +139,7 @@ pub fn buf_str(toks: &[Token],\n         }\n         s.push_str(&format!(\"{}={}\",\n                            szs[i],\n-                           tok_str(&toks[i]))[]);\n+                           tok_str(&toks[i])));\n         i += 1;\n         i %= n;\n     }"}, {"sha": "92e7f4d287091ca283829cb283c15bc7d1844f89", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -2342,7 +2342,7 @@ impl<'a> State<'a> {\n \n         // HACK(eddyb) ignore the separately printed self argument.\n         let args = if first {\n-            &decl.inputs[]\n+            &decl.inputs[..]\n         } else {\n             &decl.inputs[1..]\n         };"}, {"sha": "ac7cdb1b4130703ba30b7150a4eb25331b6cc7e8", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -38,7 +38,7 @@ pub fn maybe_inject_prelude(krate: ast::Crate) -> ast::Crate {\n }\n \n pub fn use_std(krate: &ast::Crate) -> bool {\n-    !attr::contains_name(&krate.attrs[], \"no_std\")\n+    !attr::contains_name(&krate.attrs, \"no_std\")\n }\n \n fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n@@ -88,14 +88,14 @@ impl fold::Folder for PreludeInjector {\n         // only add `use std::prelude::*;` if there wasn't a\n         // `#![no_implicit_prelude]` at the crate level.\n         // fold_mod() will insert glob path.\n-        if !no_prelude(&krate.attrs[]) {\n+        if !no_prelude(&krate.attrs) {\n             krate.module = self.fold_mod(krate.module);\n         }\n         krate\n     }\n \n     fn fold_item(&mut self, item: P<ast::Item>) -> SmallVector<P<ast::Item>> {\n-        if !no_prelude(&item.attrs[]) {\n+        if !no_prelude(&item.attrs) {\n             // only recur if there wasn't `#![no_implicit_prelude]`\n             // on this item, i.e. this means that the prelude is not\n             // implicitly imported though the whole subtree"}, {"sha": "5bada41badfd8077b4980f4bb79deb6c6fc4066a", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e794defda9ca576908d0485fb74de03fbfc4075/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=3e794defda9ca576908d0485fb74de03fbfc4075", "patch": "@@ -73,14 +73,14 @@ pub fn modify_for_testing(sess: &ParseSess,\n     // We generate the test harness when building in the 'test'\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n-    let should_test = attr::contains_name(&krate.config[], \"test\");\n+    let should_test = attr::contains_name(&krate.config, \"test\");\n \n     // Check for #[reexport_test_harness_main = \"some_name\"] which\n     // creates a `use some_name = __test::main;`. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n-        attr::first_attr_value_str_by_name(&krate.attrs[],\n+        attr::first_attr_value_str_by_name(&krate.attrs,\n                                            \"reexport_test_harness_main\");\n \n     if should_test {\n@@ -306,7 +306,7 @@ enum HasTestSignature {\n \n \n fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n-    let has_test_attr = attr::contains_name(&i.attrs[], \"test\");\n+    let has_test_attr = attr::contains_name(&i.attrs, \"test\");\n \n     fn has_test_signature(i: &ast::Item) -> HasTestSignature {\n         match &i.node {\n@@ -342,7 +342,7 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n }\n \n fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n-    let has_bench_attr = attr::contains_name(&i.attrs[], \"bench\");\n+    let has_bench_attr = attr::contains_name(&i.attrs, \"bench\");\n \n     fn has_test_signature(i: &ast::Item) -> bool {\n         match i.node {\n@@ -562,7 +562,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n }\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n-    match attr::find_crate_name(&krate.attrs[]) {\n+    match attr::find_crate_name(&krate.attrs) {\n         Some(ref s) if \"test\" == &s[..] => true,\n         _ => false\n     }"}]}