{"sha": "b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YmJmM2E4OGRkOTY1MjIyYzhlMDZlZTExM2FhM2EzNzMwZTM3Mzk=", "commit": {"author": {"name": "Sean Patrick Santos", "email": "SeanPatrickSantos@gmail.com", "date": "2015-05-03T05:30:59Z"}, "committer": {"name": "Sean Patrick Santos", "email": "SeanPatrickSantos@gmail.com", "date": "2015-05-14T00:10:01Z"}, "message": "Fix ICE that occurs when an associated const is ambiguous.\n\nAlso change several error messages to refer to \"items\" rather than\n\"methods\", since associated items that require resolution during type\nchecking are not always methods.", "tree": {"sha": "558f42720dfaec5aa8c6d2bd79b3fdc3437535e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/558f42720dfaec5aa8c6d2bd79b3fdc3437535e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "html_url": "https://github.com/rust-lang/rust/commit/b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/comments", "author": {"login": "quantheory", "id": 1740206, "node_id": "MDQ6VXNlcjE3NDAyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1740206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/quantheory", "html_url": "https://github.com/quantheory", "followers_url": "https://api.github.com/users/quantheory/followers", "following_url": "https://api.github.com/users/quantheory/following{/other_user}", "gists_url": "https://api.github.com/users/quantheory/gists{/gist_id}", "starred_url": "https://api.github.com/users/quantheory/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/quantheory/subscriptions", "organizations_url": "https://api.github.com/users/quantheory/orgs", "repos_url": "https://api.github.com/users/quantheory/repos", "events_url": "https://api.github.com/users/quantheory/events{/privacy}", "received_events_url": "https://api.github.com/users/quantheory/received_events", "type": "User", "site_admin": false}, "committer": {"login": "quantheory", "id": 1740206, "node_id": "MDQ6VXNlcjE3NDAyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1740206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/quantheory", "html_url": "https://github.com/quantheory", "followers_url": "https://api.github.com/users/quantheory/followers", "following_url": "https://api.github.com/users/quantheory/following{/other_user}", "gists_url": "https://api.github.com/users/quantheory/gists{/gist_id}", "starred_url": "https://api.github.com/users/quantheory/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/quantheory/subscriptions", "organizations_url": "https://api.github.com/users/quantheory/orgs", "repos_url": "https://api.github.com/users/quantheory/repos", "events_url": "https://api.github.com/users/quantheory/events{/privacy}", "received_events_url": "https://api.github.com/users/quantheory/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4774d5d9a112563b86e8294f6fb76dcee6577d25", "url": "https://api.github.com/repos/rust-lang/rust/commits/4774d5d9a112563b86e8294f6fb76dcee6577d25", "html_url": "https://github.com/rust-lang/rust/commit/4774d5d9a112563b86e8294f6fb76dcee6577d25"}], "stats": {"total": 330, "additions": 182, "deletions": 148}, "files": [{"sha": "90df0b853a083bca91097986ed2b8229e85bd9ce", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -16,12 +16,10 @@ use middle::def;\n use middle::privacy::{AllPublic, DependsOn, LastPrivate, LastMod};\n use middle::subst;\n use middle::traits;\n-use middle::ty::*;\n-use middle::ty;\n+use middle::ty::{self, AsPredicate, ToPolyTraitRef};\n use middle::infer;\n use util::ppaux::Repr;\n \n-use std::rc::Rc;\n use syntax::ast::DefId;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -39,7 +37,7 @@ pub enum MethodError {\n     // Did not find an applicable method, but we did find various\n     // static methods that may apply, as well as a list of\n     // not-in-scope traits which may work.\n-    NoMatch(Vec<CandidateSource>, Vec<ast::DefId>),\n+    NoMatch(Vec<CandidateSource>, Vec<ast::DefId>, probe::Mode),\n \n     // Multiple methods might apply.\n     Ambiguity(Vec<CandidateSource>),\n@@ -62,7 +60,7 @@ type ItemIndex = usize; // just for doc purposes\n pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         span: Span,\n                         method_name: ast::Name,\n-                        self_ty: Ty<'tcx>,\n+                        self_ty: ty::Ty<'tcx>,\n                         call_expr_id: ast::NodeId)\n                         -> bool\n {\n@@ -92,11 +90,11 @@ pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         span: Span,\n                         method_name: ast::Name,\n-                        self_ty: Ty<'tcx>,\n-                        supplied_method_types: Vec<Ty<'tcx>>,\n+                        self_ty: ty::Ty<'tcx>,\n+                        supplied_method_types: Vec<ty::Ty<'tcx>>,\n                         call_expr: &'tcx ast::Expr,\n                         self_expr: &'tcx ast::Expr)\n-                        -> Result<MethodCallee<'tcx>, MethodError>\n+                        -> Result<ty::MethodCallee<'tcx>, MethodError>\n {\n     debug!(\"lookup(method_name={}, self_ty={}, call_expr={}, self_expr={})\",\n            method_name.repr(fcx.tcx()),\n@@ -115,9 +113,9 @@ pub fn lookup_in_trait<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                  self_expr: Option<&ast::Expr>,\n                                  m_name: ast::Name,\n                                  trait_def_id: DefId,\n-                                 self_ty: Ty<'tcx>,\n-                                 opt_input_types: Option<Vec<Ty<'tcx>>>)\n-                                 -> Option<MethodCallee<'tcx>>\n+                                 self_ty: ty::Ty<'tcx>,\n+                                 opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n+                                 -> Option<ty::MethodCallee<'tcx>>\n {\n     lookup_in_trait_adjusted(fcx, span, self_expr, m_name, trait_def_id,\n                              0, false, self_ty, opt_input_types)\n@@ -139,9 +137,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                           trait_def_id: DefId,\n                                           autoderefs: usize,\n                                           unsize: bool,\n-                                          self_ty: Ty<'tcx>,\n-                                          opt_input_types: Option<Vec<Ty<'tcx>>>)\n-                                          -> Option<MethodCallee<'tcx>>\n+                                          self_ty: ty::Ty<'tcx>,\n+                                          opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n+                                          -> Option<ty::MethodCallee<'tcx>>\n {\n     debug!(\"lookup_in_trait_adjusted(self_ty={}, self_expr={}, m_name={}, trait_def_id={})\",\n            self_ty.repr(fcx.tcx()),\n@@ -186,7 +184,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Trait must have a method named `m_name` and it should not have\n     // type parameters or early-bound regions.\n     let tcx = fcx.tcx();\n-    let (method_num, method_ty) = trait_method(tcx, trait_def_id, m_name).unwrap();\n+    let (method_num, method_ty) = trait_item(tcx, trait_def_id, m_name)\n+            .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n+            .unwrap();\n     assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n     assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n \n@@ -288,10 +288,10 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n \n-    let callee = MethodCallee {\n-        origin: MethodTypeParam(MethodParam{trait_ref: trait_ref.clone(),\n-                                            method_num: method_num,\n-                                            impl_def_id: None}),\n+    let callee = ty::MethodCallee {\n+        origin: ty::MethodTypeParam(ty::MethodParam{trait_ref: trait_ref.clone(),\n+                                                    method_num: method_num,\n+                                                    impl_def_id: None}),\n         ty: fty,\n         substs: trait_ref.substs.clone()\n     };\n@@ -304,7 +304,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               span: Span,\n                               method_name: ast::Name,\n-                              self_ty: Ty<'tcx>,\n+                              self_ty: ty::Ty<'tcx>,\n                               expr_id: ast::NodeId)\n                               -> Result<(def::Def, LastPrivate), MethodError>\n {\n@@ -322,41 +322,40 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         _ => def::FromTrait(pick.item.container().id())\n     };\n     let def_result = match pick.item {\n-        ImplOrTraitItem::MethodTraitItem(..) => def::DefMethod(def_id, provenance),\n-        ImplOrTraitItem::ConstTraitItem(..) => def::DefAssociatedConst(def_id, provenance),\n-        ImplOrTraitItem::TypeTraitItem(..) => {\n+        ty::ImplOrTraitItem::MethodTraitItem(..) => def::DefMethod(def_id, provenance),\n+        ty::ImplOrTraitItem::ConstTraitItem(..) => def::DefAssociatedConst(def_id, provenance),\n+        ty::ImplOrTraitItem::TypeTraitItem(..) => {\n             fcx.tcx().sess.span_bug(span, \"resolve_ufcs: probe picked associated type\");\n         }\n     };\n     Ok((def_result, lp))\n }\n \n \n-/// Find method with name `method_name` defined in `trait_def_id` and return it, along with its\n-/// index (or `None`, if no such method).\n-fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                      trait_def_id: ast::DefId,\n-                      method_name: ast::Name)\n-                      -> Option<(usize, Rc<ty::Method<'tcx>>)>\n+/// Find item with name `item_name` defined in `trait_def_id` and return it, along with its\n+/// index (or `None`, if no such item).\n+fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                    trait_def_id: ast::DefId,\n+                    item_name: ast::Name)\n+                    -> Option<(usize, ty::ImplOrTraitItem<'tcx>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n     trait_items\n         .iter()\n         .enumerate()\n-        .find(|&(_, ref item)| item.name() == method_name)\n-        .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n+        .find(|&(_, ref item)| item.name() == item_name)\n+        .map(|(num, item)| (num, (*item).clone()))\n }\n \n-fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                     impl_def_id: ast::DefId,\n-                     method_name: ast::Name)\n-                     -> Option<Rc<ty::Method<'tcx>>>\n+fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                   impl_def_id: ast::DefId,\n+                   item_name: ast::Name)\n+                   -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n     let impl_items = tcx.impl_items.borrow();\n     let impl_items = impl_items.get(&impl_def_id).unwrap();\n     impl_items\n         .iter()\n         .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n-        .find(|m| m.name() == method_name)\n-        .and_then(|item| item.as_opt_method())\n+        .find(|m| m.name() == item_name)\n }"}, {"sha": "2eca855d5960b08bfaff09be483c57cf402f9047", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -136,7 +136,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let steps = if mode == Mode::MethodCall {\n         match create_steps(fcx, span, self_ty) {\n             Some(steps) => steps,\n-            None => return Err(MethodError::NoMatch(Vec::new(), Vec::new())),\n+            None => return Err(MethodError::NoMatch(Vec::new(), Vec::new(), mode)),\n         }\n     } else {\n         vec![CandidateStep {\n@@ -866,7 +866,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     }\n                 }\n             }).collect(),\n-            Some(Err(MethodError::NoMatch(_, others))) => {\n+            Some(Err(MethodError::NoMatch(_, others, _))) => {\n                 assert!(others.is_empty());\n                 vec![]\n             }\n@@ -877,7 +877,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             None => vec![],\n         };\n \n-        Err(MethodError::NoMatch(static_candidates, out_of_scope_traits))\n+        Err(MethodError::NoMatch(static_candidates, out_of_scope_traits, self.mode))\n     }\n \n     fn pick_core(&mut self) -> Option<PickResult<'tcx>> {"}, {"sha": "93239df60e16499b15536c39c252f514ffc0631d", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Give useful errors and suggestions to users when a method can't be\n+//! Give useful errors and suggestions to users when an item can't be\n //! found or is otherwise invalid.\n \n use CrateCtxt;\n@@ -27,12 +27,13 @@ use syntax::print::pprust;\n use std::cell;\n use std::cmp::Ordering;\n \n-use super::{MethodError, CandidateSource, impl_method, trait_method};\n+use super::{MethodError, CandidateSource, impl_item, trait_item};\n+use super::probe::Mode;\n \n pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               span: Span,\n                               rcvr_ty: Ty<'tcx>,\n-                              method_name: ast::Name,\n+                              item_name: ast::Name,\n                               rcvr_expr: Option<&ast::Expr>,\n                               error: MethodError)\n {\n@@ -42,28 +43,30 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     match error {\n-        MethodError::NoMatch(static_sources, out_of_scope_traits) => {\n+        MethodError::NoMatch(static_sources, out_of_scope_traits, mode) => {\n             let cx = fcx.tcx();\n-            let method_ustring = method_name.user_string(cx);\n+            let item_ustring = item_name.user_string(cx);\n \n             fcx.type_error_message(\n                 span,\n                 |actual| {\n-                    format!(\"type `{}` does not implement any \\\n-                             method in scope named `{}`\",\n-                            actual,\n-                            method_ustring)\n+                    format!(\"no {} named `{}` found for type `{}` \\\n+                             in the current scope\",\n+                            if mode == Mode::MethodCall { \"method\" }\n+                            else { \"associated item\" },\n+                            item_ustring,\n+                            actual)\n                 },\n                 rcvr_ty,\n                 None);\n \n-            // If the method has the name of a field, give a help note\n+            // If the item has the name of a field, give a help note\n             if let (&ty::ty_struct(did, _), Some(_)) = (&rcvr_ty.sty, rcvr_expr) {\n                 let fields = ty::lookup_struct_fields(cx, did);\n-                if fields.iter().any(|f| f.name == method_name) {\n+                if fields.iter().any(|f| f.name == item_name) {\n                     cx.sess.span_note(span,\n                         &format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                                 function stored in the `{0}` field\", method_ustring));\n+                                 function stored in the `{0}` field\", item_ustring));\n                 }\n             }\n \n@@ -72,25 +75,25 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     span,\n                     \"found defined static methods, maybe a `self` is missing?\");\n \n-                report_candidates(fcx, span, method_name, static_sources);\n+                report_candidates(fcx, span, item_name, static_sources);\n             }\n \n-            suggest_traits_to_import(fcx, span, rcvr_ty, method_name,\n+            suggest_traits_to_import(fcx, span, rcvr_ty, item_name,\n                                      rcvr_expr, out_of_scope_traits)\n         }\n \n         MethodError::Ambiguity(sources) => {\n             span_err!(fcx.sess(), span, E0034,\n-                      \"multiple applicable methods in scope\");\n+                      \"multiple applicable items in scope\");\n \n-            report_candidates(fcx, span, method_name, sources);\n+            report_candidates(fcx, span, item_name, sources);\n         }\n \n         MethodError::ClosureAmbiguity(trait_def_id) => {\n             let msg = format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n                                invoked on this closure as we have not yet inferred what \\\n                                kind of closure it is\",\n-                               method_name.user_string(fcx.tcx()),\n+                               item_name.user_string(fcx.tcx()),\n                                ty::item_path_str(fcx.tcx(), trait_def_id));\n             let msg = if let Some(callee) = rcvr_expr {\n                 format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n@@ -104,19 +107,19 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     fn report_candidates(fcx: &FnCtxt,\n                          span: Span,\n-                         method_name: ast::Name,\n+                         item_name: ast::Name,\n                          mut sources: Vec<CandidateSource>) {\n         sources.sort();\n         sources.dedup();\n \n         for (idx, source) in sources.iter().enumerate() {\n             match *source {\n                 CandidateSource::ImplSource(impl_did) => {\n-                    // Provide the best span we can. Use the method, if local to crate, else\n-                    // the impl, if local to crate (method may be defaulted), else the call site.\n-                    let method = impl_method(fcx.tcx(), impl_did, method_name).unwrap();\n+                    // Provide the best span we can. Use the item, if local to crate, else\n+                    // the impl, if local to crate (item may be defaulted), else the call site.\n+                    let item = impl_item(fcx.tcx(), impl_did, item_name).unwrap();\n                     let impl_span = fcx.tcx().map.def_id_span(impl_did, span);\n-                    let method_span = fcx.tcx().map.def_id_span(method.def_id, impl_span);\n+                    let item_span = fcx.tcx().map.def_id_span(item.def_id(), impl_span);\n \n                     let impl_ty = check::impl_self_ty(fcx, span, impl_did).ty;\n \n@@ -127,16 +130,16 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                                      trait_ref.def_id)),\n                     };\n \n-                    span_note!(fcx.sess(), method_span,\n+                    span_note!(fcx.sess(), item_span,\n                                \"candidate #{} is defined in an impl{} for the type `{}`\",\n                                idx + 1,\n                                insertion,\n                                impl_ty.user_string(fcx.tcx()));\n                 }\n                 CandidateSource::TraitSource(trait_did) => {\n-                    let (_, method) = trait_method(fcx.tcx(), trait_did, method_name).unwrap();\n-                    let method_span = fcx.tcx().map.def_id_span(method.def_id, span);\n-                    span_note!(fcx.sess(), method_span,\n+                    let (_, item) = trait_item(fcx.tcx(), trait_did, item_name).unwrap();\n+                    let item_span = fcx.tcx().map.def_id_span(item.def_id(), span);\n+                    span_note!(fcx.sess(), item_span,\n                                \"candidate #{} is defined in the trait `{}`\",\n                                idx + 1,\n                                ty::item_path_str(fcx.tcx(), trait_did));\n@@ -152,19 +155,19 @@ pub type AllTraitsVec = Vec<TraitInfo>;\n fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       span: Span,\n                                       rcvr_ty: Ty<'tcx>,\n-                                      method_name: ast::Name,\n+                                      item_name: ast::Name,\n                                       rcvr_expr: Option<&ast::Expr>,\n                                       valid_out_of_scope_traits: Vec<ast::DefId>)\n {\n     let tcx = fcx.tcx();\n-    let method_ustring = method_name.user_string(tcx);\n+    let item_ustring = item_name.user_string(tcx);\n \n     if !valid_out_of_scope_traits.is_empty() {\n         let mut candidates = valid_out_of_scope_traits;\n         candidates.sort();\n         candidates.dedup();\n         let msg = format!(\n-            \"methods from traits can only be called if the trait is in scope; \\\n+            \"items from traits can only be used if the trait is in scope; \\\n              the following {traits_are} implemented but not in scope, \\\n              perhaps add a `use` for {one_of_them}:\",\n             traits_are = if candidates.len() == 1 {\"trait is\"} else {\"traits are\"},\n@@ -185,7 +188,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let type_is_local = type_derefs_to_local(fcx, span, rcvr_ty, rcvr_expr);\n \n     // there's no implemented traits, so lets suggest some traits to\n-    // implement, by finding ones that have the method name, and are\n+    // implement, by finding ones that have the item name, and are\n     // legal to implement.\n     let mut candidates = all_traits(fcx.ccx)\n         .filter(|info| {\n@@ -196,7 +199,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // implementing a trait would be legal but is rejected\n             // here).\n             (type_is_local || ast_util::is_local(info.def_id))\n-                && trait_method(tcx, info.def_id, method_name).is_some()\n+                && trait_item(tcx, info.def_id, item_name).is_some()\n         })\n         .collect::<Vec<_>>();\n \n@@ -209,12 +212,12 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // of a type parameter: suggest adding a trait bound rather\n         // than implementing.\n         let msg = format!(\n-            \"methods from traits can only be called if the trait is implemented and in scope; \\\n-             the following {traits_define} a method `{name}`, \\\n+            \"items from traits can only be used if the trait is implemented and in scope; \\\n+             the following {traits_define} an item `{name}`, \\\n              perhaps you need to implement {one_of_them}:\",\n             traits_define = if candidates.len() == 1 {\"trait defines\"} else {\"traits define\"},\n             one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"},\n-            name = method_ustring);\n+            name = item_ustring);\n \n         fcx.sess().fileline_help(span, &msg[..]);\n "}, {"sha": "22292a6da9dfffe5d6221d313687975f5bcdd082", "filename": "src/test/compile-fail/associated-const-ambiguity-report.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fassociated-const-ambiguity-report.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fassociated-const-ambiguity-report.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-ambiguity-report.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const ID: i32;\n+}\n+\n+trait Bar {\n+    const ID: i32;\n+}\n+\n+impl Foo for i32 {\n+    const ID: i32 = 1;\n+}\n+\n+impl Bar for i32 {\n+    const ID: i32 = 3;\n+}\n+\n+const X: i32 = <i32>::ID; //~ ERROR E0034\n+\n+fn main() {\n+    assert_eq!(1, X);\n+}"}, {"sha": "f0f0bdfb38ee35edda402d516f065fe0d5fd2501", "filename": "src/test/compile-fail/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -15,11 +15,11 @@ fn main() {\n     // vectors to slices then automatically create a self reference.\n \n     let mut a = vec!(0);\n-    a.test_mut(); //~ ERROR does not implement any method in scope named `test_mut`\n-    a.test(); //~ ERROR does not implement any method in scope named `test`\n+    a.test_mut(); //~ ERROR no method named `test_mut` found\n+    a.test(); //~ ERROR no method named `test` found\n \n-    ([1]).test(); //~ ERROR does not implement any method in scope named `test`\n-    (&[1]).test(); //~ ERROR does not implement any method in scope named `test`\n+    ([1]).test(); //~ ERROR no method named `test` found\n+    (&[1]).test(); //~ ERROR no method named `test` found\n }\n \n trait MyIter {"}, {"sha": "af83b0ecbf22c59ac88f4c0c4fec2178f6fc8446", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -60,5 +60,5 @@ fn cat(in_x : usize, in_y : isize, in_name: String) -> cat {\n \n fn main() {\n   let nyan: Box<noisy> = box cat(0, 2, \"nyan\".to_string()) as Box<noisy>;\n-  nyan.eat(); //~ ERROR does not implement any method in scope named `eat`\n+  nyan.eat(); //~ ERROR no method named `eat` found\n }"}, {"sha": "087b8c14e35750af413ccdc1b38050114252d279", "filename": "src/test/compile-fail/coherence_inherent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -38,7 +38,7 @@ mod NoImport {\n     use Lib::TheStruct;\n \n     fn call_the_fn(s: &TheStruct) {\n-        s.the_fn(); //~ ERROR does not implement any method in scope named `the_fn`\n+        s.the_fn(); //~ ERROR no method named `the_fn` found\n     }\n }\n "}, {"sha": "442c4c89de4e1ad99ba01d8d4fb4ae1bc30eb413", "filename": "src/test/compile-fail/coherence_inherent_cc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -30,7 +30,7 @@ mod NoImport {\n     use coherence_inherent_cc_lib::TheStruct;\n \n     fn call_the_fn(s: &TheStruct) {\n-        s.the_fn(); //~ ERROR does not implement any method in scope named `the_fn`\n+        s.the_fn(); //~ ERROR no method named `the_fn` found\n     }\n }\n "}, {"sha": "70633c92e6433ce9b525fbdf9c6227f7ea72f7cd", "filename": "src/test/compile-fail/copy-a-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -26,6 +26,6 @@ fn foo(i:isize) -> foo {\n fn main() {\n     let x = foo(10);\n     let _y = x.clone();\n-    //~^ ERROR does not implement any method in scope\n+    //~^ ERROR no method named `clone` found\n     println!(\"{:?}\", x);\n }"}, {"sha": "ed91e935407b966a7200e92e8f773fbc47072d9e", "filename": "src/test/compile-fail/issue-10465.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-10465.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-10465.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10465.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -24,7 +24,7 @@ pub mod b {\n         use b::B;\n \n         fn foo(b: &B) {\n-            b.foo(); //~ ERROR: does not implement any method in scope named\n+            b.foo(); //~ ERROR: no method named `foo` found\n         }\n     }\n "}, {"sha": "f5d158d64e19fa0a776a78d61568b76431290587", "filename": "src/test/compile-fail/issue-13853.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -31,7 +31,7 @@ impl Node for Stuff {\n }\n \n fn iterate<N: Node, G: Graph<N>>(graph: &G) {\n-    for node in graph.iter() { //~ ERROR does not implement any method in scope named\n+    for node in graph.iter() { //~ ERROR no method named `iter` found\n         node.zomg();  //~ error: the type of this value must be known in this context\n     }\n }"}, {"sha": "43e9ca5fa6e7aa5b2bca45ff533377fb2134fee3", "filename": "src/test/compile-fail/issue-18343.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -14,6 +14,6 @@ struct Obj<F> where F: FnMut() -> u32 {\n \n fn main() {\n     let o = Obj { closure: || 42 };\n-    o.closure(); //~ ERROR does not implement any method in scope named `closure`\n+    o.closure(); //~ ERROR no method named `closure` found\n     //~^ NOTE use `(s.closure)(...)` if you meant to call the function stored in the `closure` field\n }"}, {"sha": "e4d132c86415ac013a8a4947ab75a4b708dcf997", "filename": "src/test/compile-fail/issue-1871.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-1871.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-1871.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1871.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -14,7 +14,7 @@ fn main() {\n   let f = 42;\n \n   let _g = if f < 5 {\n-      f.honk() //~ ERROR does not implement any method in scope named `honk`\n+      f.honk() //~ ERROR no method named `honk` found\n   }\n   else {\n       ()"}, {"sha": "58a95e9da2bf36f534a7789a939fbb43938560db", "filename": "src/test/compile-fail/issue-19521.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-19521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-19521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19521.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -11,5 +11,5 @@\n #![feature(unboxed_closures)]\n \n fn main() {\n-    \"\".homura()(); //~ ERROR does not implement any method\n+    \"\".homura()(); //~ ERROR no method named `homura` found\n }"}, {"sha": "88ae0f835d0d724b69676800bd8199ca607618de", "filename": "src/test/compile-fail/issue-19692.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -11,7 +11,7 @@\n struct Homura;\n \n fn akemi(homura: Homura) {\n-    let Some(ref madoka) = Some(homura.kaname()); //~ ERROR does not implement any method\n+    let Some(ref madoka) = Some(homura.kaname()); //~ ERROR no method named `kaname` found\n     madoka.clone(); //~ ERROR the type of this value must be known in this context\n }\n "}, {"sha": "bb170ef7d003662d004fc358fb86d9ea0ed9778a", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -22,5 +22,5 @@ impl<A> vec_monad<A> for Vec<A> {\n }\n fn main() {\n     [\"hi\"].bind(|x| [x] );\n-    //~^ ERROR type `[&str; 1]` does not implement any method in scope named `bind`\n+    //~^ ERROR no method named `bind` found for type `[&str; 1]` in the current scope\n }"}, {"sha": "631bcb7bd9eb9202f73f8f18595c314fd7421a1b", "filename": "src/test/compile-fail/issue-2823.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -20,5 +20,5 @@ impl Drop for C {\n \n fn main() {\n     let c = C{ x: 2};\n-    let _d = c.clone(); //~ ERROR does not implement any method in scope\n+    let _d = c.clone(); //~ ERROR no method named `clone` found\n }"}, {"sha": "29c1c584eed247aab1fea4511e1aec47d10a9039", "filename": "src/test/compile-fail/issue-3563.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -11,7 +11,7 @@\n trait A {\n     fn a(&self) {\n         || self.b()\n-        //~^ ERROR type `&Self` does not implement any method in scope named `b`\n+        //~^ ERROR no method named `b` found for type `&Self` in the current scope\n         //~| ERROR mismatched types\n         //~| expected `()`\n         //~| found closure"}, {"sha": "325f05841f4084468377cac538d51d4e6192b15e", "filename": "src/test/compile-fail/issue-3702-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-3702-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-3702-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3702-2.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -23,7 +23,7 @@ trait Add {\n impl Add for isize {\n     fn to_int(&self) -> isize { *self }\n     fn add_dynamic(&self, other: &Add) -> isize {\n-        self.to_int() + other.to_int() //~ ERROR multiple applicable methods in scope\n+        self.to_int() + other.to_int() //~ ERROR multiple applicable items in scope\n     }\n }\n "}, {"sha": "ad56b125b087fdeba3d1acce166f4ab776fed67e", "filename": "src/test/compile-fail/issue-3707.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-3707.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-3707.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3707.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -17,7 +17,7 @@ impl Obj {\n         return 1+1 == 2\n     }\n     pub fn chirp(&self) {\n-        self.boom(); //~ ERROR `&Obj` does not implement any method in scope named `boom`\n+        self.boom(); //~ ERROR no method named `boom` found for type `&Obj` in the current scope\n     }\n }\n "}, {"sha": "da32408e199249a400013283b282e565a81e563f", "filename": "src/test/compile-fail/issue-5153.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: type `&Foo` does not implement any method in scope named `foo`\n-\n trait Foo {\n     fn foo(self: Box<Self>);\n }\n@@ -20,4 +18,5 @@ impl Foo for isize {\n \n fn main() {\n     (&5 as &Foo).foo();\n+    //~^ ERROR: no method named `foo` found for type `&Foo` in the current scope\n }"}, {"sha": "6c7196527efdbd73db01cf703c57bc6d9a41282d", "filename": "src/test/compile-fail/issue-7575.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -71,15 +71,15 @@ impl ManyImplTrait for Myisize {}\n \n fn no_param_bound(u: usize, m: Myisize) -> usize {\n     u.f8(42) + u.f9(342) + m.fff(42)\n-            //~^ ERROR type `usize` does not implement any method in scope named `f9`\n+            //~^ ERROR no method named `f9` found for type `usize` in the current scope\n             //~^^ NOTE found defined static methods, maybe a `self` is missing?\n-            //~^^^ ERROR type `Myisize` does not implement any method in scope named `fff`\n+            //~^^^ ERROR no method named `fff` found for type `Myisize` in the current scope\n             //~^^^^ NOTE found defined static methods, maybe a `self` is missing?\n }\n \n fn param_bound<T: ManyImplTrait>(t: T) -> bool {\n     t.is_str()\n-    //~^ ERROR type `T` does not implement any method in scope named `is_str`\n+    //~^ ERROR no method named `is_str` found for type `T` in the current scope\n     //~^^ NOTE found defined static methods, maybe a `self` is missing?\n }\n "}, {"sha": "003329a2d7de22375e6de76df345ac4b697b0e9f", "filename": "src/test/compile-fail/issue-7950.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-7950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fissue-7950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7950.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -13,5 +13,5 @@\n struct Foo;\n \n fn main() {\n-    Foo::bar(); //~ ERROR type `Foo` does not implement any method in scope named `bar`\n+    Foo::bar(); //~ ERROR no associated item named `bar` found for type `Foo` in the current scope\n }"}, {"sha": "34aa1c75872f36142734dc503cbcb17fb6070844", "filename": "src/test/compile-fail/macro-backtrace-invalid-internals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fmacro-backtrace-invalid-internals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fmacro-backtrace-invalid-internals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-backtrace-invalid-internals.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -12,7 +12,7 @@\n \n macro_rules! fake_method_stmt { //~ NOTE in expansion of\n      () => {\n-          1.fake() //~ ERROR does not implement any method\n+          1.fake() //~ ERROR no method named `fake` found\n      }\n }\n \n@@ -30,7 +30,7 @@ macro_rules! fake_anon_field_stmt { //~ NOTE in expansion of\n \n macro_rules! fake_method_expr { //~ NOTE in expansion of\n      () => {\n-          1.fake() //~ ERROR does not implement any method\n+          1.fake() //~ ERROR no method named `fake` found\n      }\n }\n "}, {"sha": "3434cf96fce9463c15822e240ff5fd61a73d1a88", "filename": "src/test/compile-fail/method-call-err-msg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fmethod-call-err-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fmethod-call-err-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-call-err-msg.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -25,6 +25,6 @@ fn main() {\n \n     let y = Foo;\n     y.zero()\n-     .take()    //~ ERROR type `Foo` does not implement any method in scope named `take`\n+     .take()    //~ ERROR no method named `take` found for type `Foo` in the current scope\n      .one(0);\n }"}, {"sha": "e6f3c8ab3170e6176a247d195f96892feff2e4a2", "filename": "src/test/compile-fail/method-suggestion-no-duplication.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fmethod-suggestion-no-duplication.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fmethod-suggestion-no-duplication.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-suggestion-no-duplication.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -16,7 +16,7 @@ fn foo<F>(f: F) where F: FnMut(Foo) {}\n \n fn main() {\n     foo(|s| s.is_empty());\n-    //~^ ERROR does not implement any method\n+    //~^ ERROR no method named `is_empty` found\n     //~^^ HELP #1: `core::slice::SliceExt`\n     //~^^^ HELP #2: `core::str::StrExt`\n }"}, {"sha": "08c848a09ab09c14e800c77c5000f334e79911a9", "filename": "src/test/compile-fail/no-method-suggested-traits.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -33,45 +33,45 @@ fn main() {\n \n     1u32.method();\n     //~^ HELP following traits are implemented but not in scope, perhaps add a `use` for one of them\n-    //~^^ ERROR does not implement\n+    //~^^ ERROR no method named\n     //~^^^ HELP `foo::Bar`\n     //~^^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     std::rc::Rc::new(&mut Box::new(&1u32)).method();\n     //~^ HELP following traits are implemented but not in scope, perhaps add a `use` for one of them\n-    //~^^ ERROR does not implement\n+    //~^^ ERROR no method named\n     //~^^^ HELP `foo::Bar`\n     //~^^^^ HELP `no_method_suggested_traits::foo::PubPub`\n \n     'a'.method();\n-    //~^ ERROR does not implement\n+    //~^ ERROR no method named\n     //~^^ HELP the following trait is implemented but not in scope, perhaps add a `use` for it:\n     //~^^^ HELP `foo::Bar`\n     std::rc::Rc::new(&mut Box::new(&'a')).method();\n-    //~^ ERROR does not implement\n+    //~^ ERROR no method named\n     //~^^ HELP the following trait is implemented but not in scope, perhaps add a `use` for it:\n     //~^^^ HELP `foo::Bar`\n \n     1i32.method();\n-    //~^ ERROR does not implement\n+    //~^ ERROR no method named\n     //~^^ HELP the following trait is implemented but not in scope, perhaps add a `use` for it:\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     std::rc::Rc::new(&mut Box::new(&1i32)).method();\n-    //~^ ERROR does not implement\n+    //~^ ERROR no method named\n     //~^^ HELP the following trait is implemented but not in scope, perhaps add a `use` for it:\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n \n     Foo.method();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following traits define a method `method`, perhaps you need to implement one of them\n+    //~^ ERROR no method named\n+    //~^^ HELP following traits define an item `method`, perhaps you need to implement one of them\n     //~^^^ HELP `foo::Bar`\n     //~^^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     //~^^^^^ HELP `no_method_suggested_traits::reexport::Reexported`\n     //~^^^^^^ HELP `no_method_suggested_traits::bar::PubPriv`\n     //~^^^^^^^ HELP `no_method_suggested_traits::qux::PrivPub`\n     //~^^^^^^^^ HELP `no_method_suggested_traits::quz::PrivPriv`\n     std::rc::Rc::new(&mut Box::new(&Foo)).method();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following traits define a method `method`, perhaps you need to implement one of them\n+    //~^ ERROR no method named\n+    //~^^ HELP following traits define an item `method`, perhaps you need to implement one of them\n     //~^^^ HELP `foo::Bar`\n     //~^^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     //~^^^^^ HELP `no_method_suggested_traits::reexport::Reexported`\n@@ -80,55 +80,55 @@ fn main() {\n     //~^^^^^^^^ HELP `no_method_suggested_traits::quz::PrivPriv`\n \n     1u64.method2();\n-    //~^ ERROR does not implement\n-    //~^^ HELP the following trait defines a method `method2`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP the following trait defines an item `method2`, perhaps you need to implement it\n     //~^^^ HELP `foo::Bar`\n     std::rc::Rc::new(&mut Box::new(&1u64)).method2();\n-    //~^ ERROR does not implement\n-    //~^^ HELP the following trait defines a method `method2`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP the following trait defines an item `method2`, perhaps you need to implement it\n     //~^^^ HELP `foo::Bar`\n \n     no_method_suggested_traits::Foo.method2();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method2`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method2`, perhaps you need to implement it\n     //~^^^ HELP `foo::Bar`\n     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Foo)).method2();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method2`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method2`, perhaps you need to implement it\n     //~^^^ HELP `foo::Bar`\n     no_method_suggested_traits::Bar::X.method2();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method2`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method2`, perhaps you need to implement it\n     //~^^^ HELP `foo::Bar`\n     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Bar::X)).method2();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method2`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method2`, perhaps you need to implement it\n     //~^^^ HELP `foo::Bar`\n \n     Foo.method3();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method3`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method3`, perhaps you need to implement it\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     std::rc::Rc::new(&mut Box::new(&Foo)).method3();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method3`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method3`, perhaps you need to implement it\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     Bar::X.method3();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method3`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method3`, perhaps you need to implement it\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     std::rc::Rc::new(&mut Box::new(&Bar::X)).method3();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method3`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method3`, perhaps you need to implement it\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n \n     // should have no help:\n-    1_usize.method3(); //~ ERROR does not implement\n-    std::rc::Rc::new(&mut Box::new(&1_usize)).method3(); //~ ERROR does not implement\n-    no_method_suggested_traits::Foo.method3();  //~ ERROR does not implement\n+    1_usize.method3(); //~ ERROR no method named\n+    std::rc::Rc::new(&mut Box::new(&1_usize)).method3(); //~ ERROR no method named\n+    no_method_suggested_traits::Foo.method3();  //~ ERROR no method named\n     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Foo)).method3();\n-    //~^ ERROR does not implement\n-    no_method_suggested_traits::Bar::X.method3();  //~ ERROR does not implement\n+    //~^ ERROR no method named\n+    no_method_suggested_traits::Bar::X.method3();  //~ ERROR no method named\n     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Bar::X)).method3();\n-    //~^ ERROR does not implement\n+    //~^ ERROR no method named\n }"}, {"sha": "fd245f38a0c92240d5bc1d98308fd5f7091e5e04", "filename": "src/test/compile-fail/non-copyable-void.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -15,6 +15,6 @@ fn main() {\n     let y : *const libc::c_void = x as *const libc::c_void;\n     unsafe {\n         let _z = (*y).clone();\n-        //~^ ERROR does not implement any method in scope\n+        //~^ ERROR no method named `clone` found\n     }\n }"}, {"sha": "f5712b0c957ba40363b0a36902a50de54900f989", "filename": "src/test/compile-fail/noncopyable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -41,6 +41,6 @@ fn foo(i:isize) -> foo {\n \n fn main() {\n     let x = foo(10);\n-    let _y = x.clone(); //~ ERROR does not implement any method in scope\n+    let _y = x.clone(); //~ ERROR no method named `clone` found\n     println!(\"{:?}\", x);\n }"}, {"sha": "98c14cee942ed5fbf610eb9864f272f790c0028f", "filename": "src/test/compile-fail/object-pointer-types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -19,19 +19,19 @@ trait Foo {\n fn borrowed_receiver(x: &Foo) {\n     x.borrowed();\n     x.borrowed_mut(); // See [1]\n-    x.owned(); //~ ERROR does not implement any method\n+    x.owned(); //~ ERROR no method named `owned` found\n }\n \n fn borrowed_mut_receiver(x: &mut Foo) {\n     x.borrowed();\n     x.borrowed_mut();\n-    x.owned(); //~ ERROR does not implement any method\n+    x.owned(); //~ ERROR no method named `owned` found\n }\n \n fn owned_receiver(x: Box<Foo>) {\n     x.borrowed();\n     x.borrowed_mut(); // See [1]\n-    x.managed();  //~ ERROR does not implement any method\n+    x.managed();  //~ ERROR no method named `managed` found\n     x.owned();\n }\n "}, {"sha": "e682d3c81e793c39bd74acf9b64acd800bf937cf", "filename": "src/test/compile-fail/trait-impl-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -22,5 +22,5 @@ impl T for i32 {}\n \n fn main() {\n     let x = &42i32;\n-    x.foo(); //~ERROR: type `&i32` does not implement any method in scope named `foo`\n+    x.foo(); //~ERROR: no method named `foo` found for type `&i32` in the current scope\n }"}, {"sha": "1c133fbfcdbbf896d902ba7c3408c0a85036b9a1", "filename": "src/test/compile-fail/unboxed-closures-static-call-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -14,5 +14,5 @@ fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n \n fn main() {\n     let mut_ = to_fn_mut(|x| x);\n-    mut_.call((0, )); //~ ERROR does not implement any method in scope named `call`\n+    mut_.call((0, )); //~ ERROR no method named `call` found\n }"}, {"sha": "c44718c4fc9c231aa052d792ba204fcd5897a026", "filename": "src/test/compile-fail/unique-object-noncopyable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -31,5 +31,5 @@ impl Foo for Bar {\n fn main() {\n     let x = box Bar { x: 10 };\n     let y: Box<Foo> = x as Box<Foo>;\n-    let _z = y.clone(); //~ ERROR does not implement any method in scope\n+    let _z = y.clone(); //~ ERROR no method named `clone` found\n }"}, {"sha": "d971940db38f5af20cced487fa34dec81d825cf8", "filename": "src/test/compile-fail/unique-pinned-nocopy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4bbf3a88dd965222c8e06ee113aa3a3730e3739/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs?ref=b4bbf3a88dd965222c8e06ee113aa3a3730e3739", "patch": "@@ -20,6 +20,6 @@ impl Drop for r {\n fn main() {\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let i = Box::new(r { b: true });\n-    let _j = i.clone(); //~ ERROR not implement\n+    let _j = i.clone(); //~ ERROR no method named `clone` found\n     println!(\"{:?}\", i);\n }"}]}