{"sha": "669359530ec3dcfa5c1cc8d9afd80813a246f09b", "node_id": "C_kwDOAAsO6NoAKDY2OTM1OTUzMGVjM2RjZmE1YzFjYzhkOWFmZDgwODEzYTI0NmYwOWI", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2021-10-11T14:56:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-11T14:56:08Z"}, "message": "Add missing cast and change some bitcasts to casts to avoid a gimple verification failure (#100)", "tree": {"sha": "a4672577e7e6b45af5c0253463abf436bd3135b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4672577e7e6b45af5c0253463abf436bd3135b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/669359530ec3dcfa5c1cc8d9afd80813a246f09b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhZFCICRBK7hj4Ov3rIwAAnOoIAHqfmuxkEuNt+m+pZQGrRxNS\nqLvidchOcQIxnowYKoYq0C6p8YD0K0vWudPf8OXxT3FxKxO9/YeE0p5fIUZXcmIy\nmvsif2WYQzYtUMRVrLr4pY9XoYJljBplQaxTXpLMvhb7DUunylwOhRkboD+AYav2\nmDxx2OoiUycSsqoJYkQfuRU7odyd3nf4ge6X+2zTBuJKKvwz33WIirYut8R+zCy7\nq5Em0H6QFL3pzj4fpOvRF9jQfTi4T5qhNJGTIP0EcNeWHXCvj8/0r7DeGA84wm+8\n+HvpYfWfVDj6/XCFw2eZunTlawLhAmcO3HOLCX0jLRsonvGTnJGdcZYj9W6KqHg=\n=KKDQ\n-----END PGP SIGNATURE-----\n", "payload": "tree a4672577e7e6b45af5c0253463abf436bd3135b5\nparent cd4810de42c57b64b74dae09c530a4c3a41f87b9\nauthor antoyo <antoyo@users.noreply.github.com> 1633964168 -0400\ncommitter GitHub <noreply@github.com> 1633964168 -0400\n\nAdd missing cast and change some bitcasts to casts to avoid a gimple verification failure (#100)\n\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/669359530ec3dcfa5c1cc8d9afd80813a246f09b", "html_url": "https://github.com/rust-lang/rust/commit/669359530ec3dcfa5c1cc8d9afd80813a246f09b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/669359530ec3dcfa5c1cc8d9afd80813a246f09b/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd4810de42c57b64b74dae09c530a4c3a41f87b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd4810de42c57b64b74dae09c530a4c3a41f87b9", "html_url": "https://github.com/rust-lang/rust/commit/cd4810de42c57b64b74dae09c530a4c3a41f87b9"}], "stats": {"total": 58, "additions": 35, "deletions": 23}, "files": [{"sha": "1fcfb5f6e20a108661fce85ecbc8fa36ab5d7820", "filename": "Readme.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/669359530ec3dcfa5c1cc8d9afd80813a246f09b/Readme.md", "raw_url": "https://github.com/rust-lang/rust/raw/669359530ec3dcfa5c1cc8d9afd80813a246f09b/Readme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Readme.md?ref=669359530ec3dcfa5c1cc8d9afd80813a246f09b", "patch": "@@ -111,6 +111,8 @@ Or add a breakpoint to `add_error` in gdb and print the line number using:\n p loc->m_line\n ```\n \n+To get the `rustc` command to run in `gdb`, add the `--verbose` flag to `cargo build`.\n+\n ### How to use a custom-build rustc\n \n  * Build the stage2 compiler (`rustup toolchain link debug-current build/x86_64-unknown-linux-gnu/stage2`)."}, {"sha": "6cbce3c76dd24a680153a5327e20ed84f46d4deb", "filename": "src/back/write.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/669359530ec3dcfa5c1cc8d9afd80813a246f09b/src%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669359530ec3dcfa5c1cc8d9afd80813a246f09b/src%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fback%2Fwrite.rs?ref=669359530ec3dcfa5c1cc8d9afd80813a246f09b", "patch": "@@ -1,4 +1,4 @@\n-use std::fs;\n+use std::{env, fs};\n \n use gccjit::OutputKind;\n use rustc_codegen_ssa::{CompiledModule, ModuleCodegen};\n@@ -42,17 +42,17 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<GccCodegenBackend>, _diag_han\n                 let _timer = cgcx\n                     .prof\n                     .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &module.name[..]);\n-                match &*module.name {\n-                    \"std_example.7rcbfp3g-cgu.15\" => {\n-                        println!(\"Dumping reproducer {}\", module.name);\n-                        let _ = fs::create_dir(\"/tmp/reproducers\");\n-                        // FIXME(antoyo): segfault in dump_reproducer_to_file() might be caused by\n-                        // transmuting an rvalue to an lvalue.\n-                        // Segfault is actually in gcc::jit::reproducer::get_identifier_as_lvalue\n-                        context.dump_reproducer_to_file(&format!(\"/tmp/reproducers/{}.c\", module.name));\n-                        println!(\"Dumped reproducer {}\", module.name);\n-                    },\n-                    _ => (),\n+                if env::var(\"CG_GCCJIT_DUMP_MODULE_NAMES\").as_deref() == Ok(\"1\") {\n+                    println!(\"Module {}\", module.name);\n+                }\n+                if env::var(\"CG_GCCJIT_DUMP_MODULE\").as_deref() == Ok(&module.name) {\n+                    println!(\"Dumping reproducer {}\", module.name);\n+                    let _ = fs::create_dir(\"/tmp/reproducers\");\n+                    // FIXME(antoyo): segfault in dump_reproducer_to_file() might be caused by\n+                    // transmuting an rvalue to an lvalue.\n+                    // Segfault is actually in gcc::jit::reproducer::get_identifier_as_lvalue\n+                    context.dump_reproducer_to_file(&format!(\"/tmp/reproducers/{}.c\", module.name));\n+                    println!(\"Dumped reproducer {}\", module.name);\n                 }\n                 context.compile_to_file(OutputKind::ObjectFile, obj_out.to_str().expect(\"path to str\"));\n             }"}, {"sha": "1034eb75991eecbbbfc8f0c8d4fc549c78e3ceee", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/669359530ec3dcfa5c1cc8d9afd80813a246f09b/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/669359530ec3dcfa5c1cc8d9afd80813a246f09b/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=669359530ec3dcfa5c1cc8d9afd80813a246f09b", "patch": "@@ -525,7 +525,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         let value =\n             if result_type.is_signed(self.cx) {\n-                self.context.new_bitcast(None, value, typ)\n+                self.context.new_cast(None, value, typ)\n             }\n             else {\n                 value\n@@ -689,7 +689,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 },\n             };\n \n-        self.context.new_bitcast(None, result, result_type)\n+        self.context.new_cast(None, result, result_type)\n     }\n \n     fn count_leading_zeroes(&self, width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n@@ -740,6 +740,11 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 let not_low = self.context.new_unary_op(None, UnaryOp::LogicalNegate, self.u64_type, low);\n                 let not_low_and_not_high = not_low & not_high;\n                 let index = not_high + not_low_and_not_high;\n+                // NOTE: the following cast is necessary to avoid a GIMPLE verification failure in\n+                // gcc.\n+                // TODO(antoyo): do the correct verification in libgccjit to avoid an error at the\n+                // compilation stage.\n+                let index = self.context.new_cast(None, index, self.i32_type);\n \n                 let res = self.context.new_array_access(None, result, index);\n \n@@ -763,7 +768,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let arg =\n             if result_type.is_signed(self.cx) {\n                 let new_type = result_type.to_unsigned(self.cx);\n-                self.context.new_bitcast(None, arg, new_type)\n+                self.context.new_cast(None, arg, new_type)\n             }\n             else {\n                 arg\n@@ -815,10 +820,15 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 let not_high = self.context.new_unary_op(None, UnaryOp::LogicalNegate, self.u64_type, high);\n                 let not_low_and_not_high = not_low & not_high;\n                 let index = not_low + not_low_and_not_high;\n+                // NOTE: the following cast is necessary to avoid a GIMPLE verification failure in\n+                // gcc.\n+                // TODO(antoyo): do the correct verification in libgccjit to avoid an error at the\n+                // compilation stage.\n+                let index = self.context.new_cast(None, index, self.i32_type);\n \n                 let res = self.context.new_array_access(None, result, index);\n \n-                return self.context.new_bitcast(None, res, result_type);\n+                return self.context.new_cast(None, res, result_type);\n             }\n             else {\n                 unimplemented!(\"count_trailing_zeroes for {:?}\", arg_type);\n@@ -832,7 +842,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 arg\n             };\n         let res = self.context.new_call(None, count_trailing_zeroes, &[arg]);\n-        self.context.new_bitcast(None, res, result_type)\n+        self.context.new_cast(None, res, result_type)\n     }\n \n     fn int_width(&self, typ: Type<'gcc>) -> i64 {\n@@ -846,7 +856,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n         let value =\n             if result_type.is_signed(self.cx) {\n-                self.context.new_bitcast(None, value, value_type)\n+                self.context.new_cast(None, value, value_type)\n             }\n             else {\n                 value\n@@ -862,7 +872,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             let low = self.context.new_cast(None, value, self.cx.ulonglong_type);\n             let low = self.context.new_call(None, popcount, &[low]);\n             let res = high + low;\n-            return self.context.new_bitcast(None, res, result_type);\n+            return self.context.new_cast(None, res, result_type);\n         }\n \n         // First step.\n@@ -887,7 +897,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u8(&self.cx) {\n-            return self.context.new_bitcast(None, value, result_type);\n+            return self.context.new_cast(None, value, result_type);\n         }\n \n         // Fourth step.\n@@ -898,7 +908,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u16(&self.cx) {\n-            return self.context.new_bitcast(None, value, result_type);\n+            return self.context.new_cast(None, value, result_type);\n         }\n \n         // Fifth step.\n@@ -909,7 +919,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u32(&self.cx) {\n-            return self.context.new_bitcast(None, value, result_type);\n+            return self.context.new_cast(None, value, result_type);\n         }\n \n         // Sixth step.\n@@ -919,7 +929,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let right = shifted & mask;\n         let value = left + right;\n \n-        self.context.new_bitcast(None, value, result_type)\n+        self.context.new_cast(None, value, result_type)\n     }\n \n     // Algorithm from: https://blog.regehr.org/archives/1063"}]}