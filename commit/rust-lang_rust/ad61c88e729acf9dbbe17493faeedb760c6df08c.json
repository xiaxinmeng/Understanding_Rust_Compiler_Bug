{"sha": "ad61c88e729acf9dbbe17493faeedb760c6df08c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNjFjODhlNzI5YWNmOWRiYmUxNzQ5M2ZhZWVkYjc2MGM2ZGYwOGM=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2019-10-27T22:33:25Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2019-11-03T14:03:21Z"}, "message": "Make SEH exceptions use a rust_panic type instead of unsigned __int64*", "tree": {"sha": "23b2d2f985ad3edd337566337ac4be4e3a14cd68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23b2d2f985ad3edd337566337ac4be4e3a14cd68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad61c88e729acf9dbbe17493faeedb760c6df08c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad61c88e729acf9dbbe17493faeedb760c6df08c", "html_url": "https://github.com/rust-lang/rust/commit/ad61c88e729acf9dbbe17493faeedb760c6df08c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad61c88e729acf9dbbe17493faeedb760c6df08c/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83d6bf49296dd2c365ee3989d114a99db9ca3577", "url": "https://api.github.com/repos/rust-lang/rust/commits/83d6bf49296dd2c365ee3989d114a99db9ca3577", "html_url": "https://github.com/rust-lang/rust/commit/83d6bf49296dd2c365ee3989d114a99db9ca3577"}], "stats": {"total": 216, "additions": 62, "deletions": 154}, "files": [{"sha": "d2a0ef7b1dde1cce1e738918638c68266305e0cd", "filename": "src/libpanic_unwind/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad61c88e729acf9dbbe17493faeedb760c6df08c/src%2Flibpanic_unwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad61c88e729acf9dbbe17493faeedb760c6df08c/src%2Flibpanic_unwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Flib.rs?ref=ad61c88e729acf9dbbe17493faeedb760c6df08c", "patch": "@@ -61,7 +61,6 @@ cfg_if::cfg_if! {\n }\n \n mod dwarf;\n-mod windows;\n \n // Entry point for catching an exception, implemented using the `try` intrinsic\n // in the compiler."}, {"sha": "9e76b92a7d74f74347a0bb0eaabf9feef3dfb109", "filename": "src/libpanic_unwind/seh.rs", "status": "modified", "additions": 46, "deletions": 49, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/ad61c88e729acf9dbbe17493faeedb760c6df08c/src%2Flibpanic_unwind%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad61c88e729acf9dbbe17493faeedb760c6df08c/src%2Flibpanic_unwind%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fseh.rs?ref=ad61c88e729acf9dbbe17493faeedb760c6df08c", "patch": "@@ -51,9 +51,7 @@ use alloc::boxed::Box;\n use core::any::Any;\n use core::mem;\n use core::raw;\n-\n-use crate::windows as c;\n-use libc::{c_int, c_uint};\n+use libc::{c_int, c_uint, c_void};\n \n // First up, a whole bunch of type definitions. There's a few platform-specific\n // oddities here, and a lot that's just blatantly copied from LLVM. The purpose\n@@ -76,18 +74,19 @@ use libc::{c_int, c_uint};\n // sort of operation. For example, if you compile this C++ code on MSVC and emit\n // the LLVM IR:\n //\n-//      #include <stdin.h>\n+//      #include <stdint.h>\n+//\n+//      struct rust_panic {\n+//          uint64_t x[2];\n+//      }\n //\n //      void foo() {\n-//          uint64_t a[2] = {0, 1};\n+//          rust_panic a = {0, 1};\n //          throw a;\n //      }\n //\n // That's essentially what we're trying to emulate. Most of the constant values\n-// below were just copied from LLVM, I'm at least not 100% sure what's going on\n-// everywhere. For example the `.PA_K\\0` and `.PEA_K\\0` strings below (stuck in\n-// the names of a few of these) I'm not actually sure what they do, but it seems\n-// to mirror what LLVM does!\n+// below were just copied from LLVM,\n //\n // In any case, these structures are all constructed in a similar manner, and\n // it's just somewhat verbose for us.\n@@ -98,10 +97,9 @@ use libc::{c_int, c_uint};\n #[macro_use]\n mod imp {\n     pub type ptr_t = *mut u8;\n-    pub const OFFSET: i32 = 4;\n \n+    #[cfg(bootstrap)]\n     pub const NAME1: [u8; 7] = [b'.', b'P', b'A', b'_', b'K', 0, 0];\n-    pub const NAME2: [u8; 7] = [b'.', b'P', b'A', b'X', 0, 0, 0];\n \n     macro_rules! ptr {\n         (0) => (core::ptr::null_mut());\n@@ -113,10 +111,9 @@ mod imp {\n #[macro_use]\n mod imp {\n     pub type ptr_t = u32;\n-    pub const OFFSET: i32 = 8;\n \n+    #[cfg(bootstrap)]\n     pub const NAME1: [u8; 7] = [b'.', b'P', b'E', b'A', b'_', b'K', 0];\n-    pub const NAME2: [u8; 7] = [b'.', b'P', b'E', b'A', b'X', 0, 0];\n \n     extern \"C\" {\n         pub static __ImageBase: u8;\n@@ -141,7 +138,7 @@ pub struct _ThrowInfo {\n #[repr(C)]\n pub struct _CatchableTypeArray {\n     pub nCatchableTypes: c_int,\n-    pub arrayOfCatchableTypes: [imp::ptr_t; 2],\n+    pub arrayOfCatchableTypes: [imp::ptr_t; 1],\n }\n \n #[repr(C)]\n@@ -164,9 +161,19 @@ pub struct _PMD {\n pub struct _TypeDescriptor {\n     pub pVFTable: *const u8,\n     pub spare: *mut u8,\n+    #[cfg(bootstrap)]\n     pub name: [u8; 7],\n+    #[cfg(not(bootstrap))]\n+    pub name: [u8; 11],\n }\n \n+// Note that we intentionally ignore name mangling rules here: we don't want C++\n+// to be able to catch Rust panics by simply declaring a `struct rust_panic`.\n+#[cfg(bootstrap)]\n+use imp::NAME1 as TYPE_NAME;\n+#[cfg(not(bootstrap))]\n+const TYPE_NAME: [u8; 11] = *b\"rust_panic\\0\";\n+\n static mut THROW_INFO: _ThrowInfo = _ThrowInfo {\n     attributes: 0,\n     pnfnUnwind: ptr!(0),\n@@ -175,31 +182,22 @@ static mut THROW_INFO: _ThrowInfo = _ThrowInfo {\n };\n \n static mut CATCHABLE_TYPE_ARRAY: _CatchableTypeArray = _CatchableTypeArray {\n-    nCatchableTypes: 2,\n-    arrayOfCatchableTypes: [ptr!(0), ptr!(0)],\n+    nCatchableTypes: 1,\n+    arrayOfCatchableTypes: [ptr!(0)],\n };\n \n-static mut CATCHABLE_TYPE1: _CatchableType = _CatchableType {\n-    properties: 1,\n+static mut CATCHABLE_TYPE: _CatchableType = _CatchableType {\n+    properties: 0,\n     pType: ptr!(0),\n     thisDisplacement: _PMD {\n         mdisp: 0,\n         pdisp: -1,\n         vdisp: 0,\n     },\n-    sizeOrOffset: imp::OFFSET,\n-    copy_function: ptr!(0),\n-};\n-\n-static mut CATCHABLE_TYPE2: _CatchableType = _CatchableType {\n-    properties: 1,\n-    pType: ptr!(0),\n-    thisDisplacement: _PMD {\n-        mdisp: 0,\n-        pdisp: -1,\n-        vdisp: 0,\n-    },\n-    sizeOrOffset: imp::OFFSET,\n+    #[cfg(bootstrap)]\n+    sizeOrOffset: mem::size_of::<*mut u64>() as c_int,\n+    #[cfg(not(bootstrap))]\n+    sizeOrOffset: mem::size_of::<[u64; 2]>() as c_int,\n     copy_function: ptr!(0),\n };\n \n@@ -221,16 +219,10 @@ extern \"C\" {\n //\n // Again, I'm not entirely sure what this is describing, it just seems to work.\n #[cfg_attr(not(test), lang = \"msvc_try_filter\")]\n-static mut TYPE_DESCRIPTOR1: _TypeDescriptor = _TypeDescriptor {\n+static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n     pVFTable: unsafe { &TYPE_INFO_VTABLE } as *const _ as *const _,\n     spare: core::ptr::null_mut(),\n-    name: imp::NAME1,\n-};\n-\n-static mut TYPE_DESCRIPTOR2: _TypeDescriptor = _TypeDescriptor {\n-    pVFTable: unsafe { &TYPE_INFO_VTABLE } as *const _ as *const _,\n-    spare: core::ptr::null_mut(),\n-    name: imp::NAME2,\n+    name: TYPE_NAME,\n };\n \n pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n@@ -246,6 +238,11 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     let ptrs = mem::transmute::<_, raw::TraitObject>(data);\n     let mut ptrs = [ptrs.data as u64, ptrs.vtable as u64];\n     let mut ptrs_ptr = ptrs.as_mut_ptr();\n+    let throw_ptr = if cfg!(bootstrap) {\n+        &mut ptrs_ptr as *mut _ as *mut _\n+    } else {\n+        ptrs_ptr as *mut _\n+    };\n \n     // This... may seems surprising, and justifiably so. On 32-bit MSVC the\n     // pointers between these structure are just that, pointers. On 64-bit MSVC,\n@@ -270,17 +267,17 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     atomic_store(&mut THROW_INFO.pCatchableTypeArray as *mut _ as *mut u32,\n                  ptr!(&CATCHABLE_TYPE_ARRAY as *const _) as u32);\n     atomic_store(&mut CATCHABLE_TYPE_ARRAY.arrayOfCatchableTypes[0] as *mut _ as *mut u32,\n-                 ptr!(&CATCHABLE_TYPE1 as *const _) as u32);\n-    atomic_store(&mut CATCHABLE_TYPE_ARRAY.arrayOfCatchableTypes[1] as *mut _ as *mut u32,\n-                 ptr!(&CATCHABLE_TYPE2 as *const _) as u32);\n-    atomic_store(&mut CATCHABLE_TYPE1.pType as *mut _ as *mut u32,\n-                 ptr!(&TYPE_DESCRIPTOR1 as *const _) as u32);\n-    atomic_store(&mut CATCHABLE_TYPE2.pType as *mut _ as *mut u32,\n-                 ptr!(&TYPE_DESCRIPTOR2 as *const _) as u32);\n+                 ptr!(&CATCHABLE_TYPE as *const _) as u32);\n+    atomic_store(&mut CATCHABLE_TYPE.pType as *mut _ as *mut u32,\n+                 ptr!(&TYPE_DESCRIPTOR as *const _) as u32);\n+\n+    extern \"system\" {\n+        #[unwind(allowed)]\n+        pub fn _CxxThrowException(pExceptionObject: *mut c_void, pThrowInfo: *mut u8) -> !;\n+    }\n \n-    c::_CxxThrowException(&mut ptrs_ptr as *mut _ as *mut _,\n-                          &mut THROW_INFO as *mut _ as *mut _);\n-    u32::max_value()\n+    _CxxThrowException(throw_ptr,\n+                       &mut THROW_INFO as *mut _ as *mut _);\n }\n \n pub fn payload() -> [u64; 2] {"}, {"sha": "3257a9d25a51ab9f325fa7af08c9abafaf38df18", "filename": "src/libpanic_unwind/windows.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/83d6bf49296dd2c365ee3989d114a99db9ca3577/src%2Flibpanic_unwind%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83d6bf49296dd2c365ee3989d114a99db9ca3577/src%2Flibpanic_unwind%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fwindows.rs?ref=83d6bf49296dd2c365ee3989d114a99db9ca3577", "patch": "@@ -1,86 +0,0 @@\n-#![allow(nonstandard_style)]\n-#![allow(dead_code)]\n-#![cfg(windows)]\n-\n-use libc::{c_long, c_ulong, c_void};\n-\n-pub type DWORD = c_ulong;\n-pub type LONG = c_long;\n-pub type ULONG_PTR = usize;\n-pub type LPVOID = *mut c_void;\n-\n-pub const EXCEPTION_MAXIMUM_PARAMETERS: usize = 15;\n-pub const EXCEPTION_NONCONTINUABLE: DWORD = 0x1;   // Noncontinuable exception\n-pub const EXCEPTION_UNWINDING: DWORD = 0x2;        // Unwind is in progress\n-pub const EXCEPTION_EXIT_UNWIND: DWORD = 0x4;      // Exit unwind is in progress\n-pub const EXCEPTION_TARGET_UNWIND: DWORD = 0x20;   // Target unwind in progress\n-pub const EXCEPTION_COLLIDED_UNWIND: DWORD = 0x40; // Collided exception handler call\n-pub const EXCEPTION_UNWIND: DWORD = EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND |\n-                                    EXCEPTION_TARGET_UNWIND |\n-                                    EXCEPTION_COLLIDED_UNWIND;\n-\n-#[repr(C)]\n-pub struct EXCEPTION_RECORD {\n-    pub ExceptionCode: DWORD,\n-    pub ExceptionFlags: DWORD,\n-    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-    pub ExceptionAddress: LPVOID,\n-    pub NumberParameters: DWORD,\n-    pub ExceptionInformation: [LPVOID; EXCEPTION_MAXIMUM_PARAMETERS],\n-}\n-\n-#[repr(C)]\n-pub struct EXCEPTION_POINTERS {\n-    pub ExceptionRecord: *mut EXCEPTION_RECORD,\n-    pub ContextRecord: *mut CONTEXT,\n-}\n-\n-pub enum UNWIND_HISTORY_TABLE {}\n-\n-#[repr(C)]\n-pub struct RUNTIME_FUNCTION {\n-    pub BeginAddress: DWORD,\n-    pub EndAddress: DWORD,\n-    pub UnwindData: DWORD,\n-}\n-\n-pub enum CONTEXT {}\n-\n-#[repr(C)]\n-pub struct DISPATCHER_CONTEXT {\n-    pub ControlPc: LPVOID,\n-    pub ImageBase: LPVOID,\n-    pub FunctionEntry: *const RUNTIME_FUNCTION,\n-    pub EstablisherFrame: LPVOID,\n-    pub TargetIp: LPVOID,\n-    pub ContextRecord: *const CONTEXT,\n-    pub LanguageHandler: LPVOID,\n-    pub HandlerData: *const u8,\n-    pub HistoryTable: *const UNWIND_HISTORY_TABLE,\n-}\n-\n-#[repr(C)]\n-pub enum EXCEPTION_DISPOSITION {\n-    ExceptionContinueExecution,\n-    ExceptionContinueSearch,\n-    ExceptionNestedException,\n-    ExceptionCollidedUnwind,\n-}\n-pub use self::EXCEPTION_DISPOSITION::*;\n-\n-extern \"system\" {\n-    #[unwind(allowed)]\n-    pub fn RaiseException(dwExceptionCode: DWORD,\n-                          dwExceptionFlags: DWORD,\n-                          nNumberOfArguments: DWORD,\n-                          lpArguments: *const ULONG_PTR);\n-    #[unwind(allowed)]\n-    pub fn RtlUnwindEx(TargetFrame: LPVOID,\n-                       TargetIp: LPVOID,\n-                       ExceptionRecord: *const EXCEPTION_RECORD,\n-                       ReturnValue: LPVOID,\n-                       OriginalContext: *const CONTEXT,\n-                       HistoryTable: *const UNWIND_HISTORY_TABLE);\n-    #[unwind(allowed)]\n-    pub fn _CxxThrowException(pExceptionObject: *mut c_void, pThrowInfo: *mut u8);\n-}"}, {"sha": "efebac5575939567b8b37eab5d8a78b6669773fb", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ad61c88e729acf9dbbe17493faeedb760c6df08c/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad61c88e729acf9dbbe17493faeedb760c6df08c/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=ad61c88e729acf9dbbe17493faeedb760c6df08c", "patch": "@@ -849,7 +849,7 @@ fn codegen_msvc_try(\n         // We're generating an IR snippet that looks like:\n         //\n         //   declare i32 @rust_try(%func, %data, %ptr) {\n-        //      %slot = alloca i64*\n+        //      %slot = alloca [2 x i64]\n         //      invoke %func(%data) to label %normal unwind label %catchswitch\n         //\n         //   normal:\n@@ -873,21 +873,25 @@ fn codegen_msvc_try(\n         //\n         //      #include <stdint.h>\n         //\n+        //      struct rust_panic {\n+        //          uint64_t x[2];\n+        //      }\n+        //\n         //      int bar(void (*foo)(void), uint64_t *ret) {\n         //          try {\n         //              foo();\n         //              return 0;\n-        //          } catch(uint64_t a[2]) {\n-        //              ret[0] = a[0];\n-        //              ret[1] = a[1];\n+        //          } catch(rust_panic a) {\n+        //              ret[0] = a.x[0];\n+        //              ret[1] = a.x[1];\n         //              return 1;\n         //          }\n         //      }\n         //\n         // More information can be found in libstd's seh.rs implementation.\n-        let i64p = bx.type_ptr_to(bx.type_i64());\n-        let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n-        let slot = bx.alloca(i64p, ptr_align);\n+        let i64_2 = bx.type_array(bx.type_i64(), 2);\n+        let i64_align = bx.tcx().data_layout.i64_align.abi;\n+        let slot = bx.alloca(i64_2, i64_align);\n         bx.invoke(func, &[data], normal.llbb(), catchswitch.llbb(), None);\n \n         normal.ret(bx.const_i32(0));\n@@ -900,17 +904,10 @@ fn codegen_msvc_try(\n             None => bug!(\"msvc_try_filter not defined\"),\n         };\n         let funclet = catchpad.catch_pad(cs, &[tydesc, bx.const_i32(0), slot]);\n-        let addr = catchpad.load(slot, ptr_align);\n \n-        let i64_align = bx.tcx().data_layout.i64_align.abi;\n-        let arg1 = catchpad.load(addr, i64_align);\n-        let val1 = bx.const_i32(1);\n-        let gep1 = catchpad.inbounds_gep(addr, &[val1]);\n-        let arg2 = catchpad.load(gep1, i64_align);\n-        let local_ptr = catchpad.bitcast(local_ptr, i64p);\n-        let gep2 = catchpad.inbounds_gep(local_ptr, &[val1]);\n-        catchpad.store(arg1, local_ptr, i64_align);\n-        catchpad.store(arg2, gep2, i64_align);\n+        let payload = catchpad.load(slot, i64_align);\n+        let local_ptr = catchpad.bitcast(local_ptr, bx.type_ptr_to(i64_2));\n+        catchpad.store(payload, local_ptr, i64_align);\n         catchpad.catch_ret(&funclet, caught.llbb());\n \n         caught.ret(bx.const_i32(1));"}, {"sha": "b0fd65f88e7de9588ca35a263ecd4d5810fb2b8d", "filename": "src/test/run-make-fulldeps/foreign-exceptions/foo.cpp", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad61c88e729acf9dbbe17493faeedb760c6df08c/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/ad61c88e729acf9dbbe17493faeedb760c6df08c/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-exceptions%2Ffoo.cpp?ref=ad61c88e729acf9dbbe17493faeedb760c6df08c", "patch": "@@ -8,6 +8,7 @@ void println(const char* s) {\n }\n \n struct exception {};\n+struct rust_panic {};\n \n struct drop_check {\n     bool* ok;\n@@ -45,7 +46,7 @@ extern \"C\" {\n         x.ok = NULL;\n         try {\n             cb();\n-        } catch (exception e) {\n+        } catch (rust_panic e) {\n             assert(false && \"shouldn't be able to catch a rust panic\");\n         } catch (...) {\n             println(\"caught foreign exception in catch (...)\");"}]}