{"sha": "845009d0718d07415d774c930f6cbe32509d03b8", "node_id": "C_kwDOAAsO6NoAKDg0NTAwOWQwNzE4ZDA3NDE1ZDc3NGM5MzBmNmNiZTMyNTA5ZDAzYjg", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-25T14:18:44Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-03T17:14:29Z"}, "message": "Only fetch HIR for naked functions that have the attribute.", "tree": {"sha": "6a185ee36eaa631e0e0cd2ecb96838b22d463769", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a185ee36eaa631e0e0cd2ecb96838b22d463769"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/845009d0718d07415d774c930f6cbe32509d03b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/845009d0718d07415d774c930f6cbe32509d03b8", "html_url": "https://github.com/rust-lang/rust/commit/845009d0718d07415d774c930f6cbe32509d03b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/845009d0718d07415d774c930f6cbe32509d03b8/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "792bc5a0102d0973d42183a2b267850bb905236f", "url": "https://api.github.com/repos/rust-lang/rust/commits/792bc5a0102d0973d42183a2b267850bb905236f", "html_url": "https://github.com/rust-lang/rust/commit/792bc5a0102d0973d42183a2b267850bb905236f"}], "stats": {"total": 94, "additions": 41, "deletions": 53}, "files": [{"sha": "296b6ed5d99a69b5e5153a134d578d9218f12a47", "filename": "compiler/rustc_passes/src/naked_functions.rs", "status": "modified", "additions": 41, "deletions": 53, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/845009d0718d07415d774c930f6cbe32509d03b8/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/845009d0718d07415d774c930f6cbe32509d03b8/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fnaked_functions.rs?ref=845009d0718d07415d774c930f6cbe32509d03b8", "patch": "@@ -1,83 +1,71 @@\n //! Checks validity of naked functions.\n \n-use rustc_ast::{Attribute, InlineAsmOptions};\n+use rustc_ast::InlineAsmOptions;\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::intravisit::{FnKind, Visitor};\n-use rustc_hir::{ExprKind, HirId, InlineAsmOperand, StmtKind};\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{ExprKind, InlineAsmOperand, StmtKind};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::lint::builtin::UNDEFINED_NAKED_FUNCTION_ABI;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n \n-fn check_mod_naked_functions(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n-    tcx.hir().visit_item_likes_in_module(module_def_id, &mut CheckNakedFunctions { tcx });\n-}\n-\n pub(crate) fn provide(providers: &mut Providers) {\n     *providers = Providers { check_mod_naked_functions, ..*providers };\n }\n \n-struct CheckNakedFunctions<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for CheckNakedFunctions<'tcx> {\n-    fn visit_fn(\n-        &mut self,\n-        fk: FnKind<'_>,\n-        _fd: &'tcx hir::FnDecl<'tcx>,\n-        body_id: hir::BodyId,\n-        span: Span,\n-        hir_id: HirId,\n-    ) {\n-        let ident_span;\n-        let fn_header;\n-\n-        match fk {\n-            FnKind::Closure => {\n-                // Closures with a naked attribute are rejected during attribute\n-                // check. Don't validate them any further.\n-                return;\n-            }\n-            FnKind::ItemFn(ident, _, ref header, ..) => {\n-                ident_span = ident.span;\n-                fn_header = header;\n-            }\n-\n-            FnKind::Method(ident, ref sig, ..) => {\n-                ident_span = ident.span;\n-                fn_header = &sig.header;\n-            }\n+fn check_mod_naked_functions(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n+    let items = tcx.hir_module_items(module_def_id);\n+    for def_id in items.definitions() {\n+        if !matches!(tcx.def_kind(def_id), DefKind::Fn | DefKind::AssocFn) {\n+            continue;\n         }\n \n-        let attrs = self.tcx.hir().attrs(hir_id);\n-        let naked = attrs.iter().any(|attr| attr.has_name(sym::naked));\n-        if naked {\n-            let body = self.tcx.hir().body(body_id);\n-            check_abi(self.tcx, hir_id, fn_header.abi, ident_span);\n-            check_no_patterns(self.tcx, body.params);\n-            check_no_parameters_use(self.tcx, body);\n-            check_asm(self.tcx, body, span);\n-            check_inline(self.tcx, attrs);\n+        let naked = tcx.has_attr(def_id.to_def_id(), sym::naked);\n+        if !naked {\n+            continue;\n         }\n+\n+        let (fn_header, body_id) = match tcx.hir().get_by_def_id(def_id) {\n+            hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(sig, _, body_id), .. })\n+            | hir::Node::TraitItem(hir::TraitItem {\n+                kind: hir::TraitItemKind::Fn(sig, hir::TraitFn::Provided(body_id)),\n+                ..\n+            })\n+            | hir::Node::ImplItem(hir::ImplItem {\n+                kind: hir::ImplItemKind::Fn(sig, body_id),\n+                ..\n+            }) => (sig.header, *body_id),\n+            _ => continue,\n+        };\n+\n+        let body = tcx.hir().body(body_id);\n+        check_abi(tcx, def_id, fn_header.abi);\n+        check_no_patterns(tcx, body.params);\n+        check_no_parameters_use(tcx, body);\n+        check_asm(tcx, def_id, body);\n+        check_inline(tcx, def_id);\n     }\n }\n \n /// Check that the function isn't inlined.\n-fn check_inline(tcx: TyCtxt<'_>, attrs: &[Attribute]) {\n-    for attr in attrs.iter().filter(|attr| attr.has_name(sym::inline)) {\n+fn check_inline(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n+    let attrs = tcx.get_attrs(def_id.to_def_id(), sym::inline);\n+    for attr in attrs {\n         tcx.sess.struct_span_err(attr.span, \"naked functions cannot be inlined\").emit();\n     }\n }\n \n /// Checks that function uses non-Rust ABI.\n-fn check_abi(tcx: TyCtxt<'_>, hir_id: HirId, abi: Abi, fn_ident_span: Span) {\n+fn check_abi(tcx: TyCtxt<'_>, def_id: LocalDefId, abi: Abi) {\n     if abi == Abi::Rust {\n-        tcx.struct_span_lint_hir(UNDEFINED_NAKED_FUNCTION_ABI, hir_id, fn_ident_span, |lint| {\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        let span = tcx.def_span(def_id);\n+        tcx.struct_span_lint_hir(UNDEFINED_NAKED_FUNCTION_ABI, hir_id, span, |lint| {\n             lint.build(\"Rust ABI is unsupported in naked functions\").emit();\n         });\n     }\n@@ -141,15 +129,15 @@ impl<'tcx> Visitor<'tcx> for CheckParameters<'tcx> {\n }\n \n /// Checks that function body contains a single inline assembly block.\n-fn check_asm<'tcx>(tcx: TyCtxt<'tcx>, body: &'tcx hir::Body<'tcx>, fn_span: Span) {\n+fn check_asm<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &'tcx hir::Body<'tcx>) {\n     let mut this = CheckInlineAssembly { tcx, items: Vec::new() };\n     this.visit_body(body);\n     if let [(ItemKind::Asm | ItemKind::Err, _)] = this.items[..] {\n         // Ok.\n     } else {\n         let mut diag = struct_span_err!(\n             tcx.sess,\n-            fn_span,\n+            tcx.def_span(def_id),\n             E0787,\n             \"naked functions must contain a single asm block\"\n         );"}]}