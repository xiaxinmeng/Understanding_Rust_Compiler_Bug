{"sha": "7d12767dc590e544d500d034f466a7b2d0d82d57", "node_id": "C_kwDOAAsO6NoAKDdkMTI3NjdkYzU5MGU1NDRkNTAwZDAzNGY0NjZhN2IyZDBkODJkNTc", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-05-08T23:13:11Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2021-12-06T20:05:22Z"}, "message": "Use preorder indices for data structures\n\nThis largely avoids remapping from and to the 'real' indices, with the exception\nof predecessor lookup and the final merge back, and is conceptually better.", "tree": {"sha": "89192910e26234a052422139e9d3ca0cf42127a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89192910e26234a052422139e9d3ca0cf42127a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d12767dc590e544d500d034f466a7b2d0d82d57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d12767dc590e544d500d034f466a7b2d0d82d57", "html_url": "https://github.com/rust-lang/rust/commit/7d12767dc590e544d500d034f466a7b2d0d82d57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d12767dc590e544d500d034f466a7b2d0d82d57/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92186cb5c9228f64c7f7c832a0b61aa05e14802d", "url": "https://api.github.com/repos/rust-lang/rust/commits/92186cb5c9228f64c7f7c832a0b61aa05e14802d", "html_url": "https://github.com/rust-lang/rust/commit/92186cb5c9228f64c7f7c832a0b61aa05e14802d"}], "stats": {"total": 91, "additions": 38, "deletions": 53}, "files": [{"sha": "b819b7f419ad9f03d553414ddca61e2585d3d672", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 38, "deletions": 53, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/7d12767dc590e544d500d034f466a7b2d0d82d57/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d12767dc590e544d500d034f466a7b2d0d82d57/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=7d12767dc590e544d500d034f466a7b2d0d82d57", "patch": "@@ -34,60 +34,53 @@ fn dominators_given_rpo<G: ControlFlowGraph>(graph: G, rpo: &[G::Node]) -> Domin\n     }\n \n     let mut visited = BitSet::new_empty(graph.num_nodes());\n-    let mut parent: IndexVec<G::Node, Option<G::Node>> =\n-        IndexVec::from_elem_n(None, graph.num_nodes());\n-    let mut pre_order_index: IndexVec<G::Node, Option<usize>> =\n-        IndexVec::from_elem_n(None, graph.num_nodes());\n-    let mut pre_order_nodes = Vec::with_capacity(rpo.len());\n+    let mut parent: IndexVec<usize, Option<usize>> = IndexVec::from_elem_n(None, rpo.len());\n \n-    let mut stack = vec![PreOrderFrame {\n-        node: graph.start_node(),\n-        iter: graph.successors(graph.start_node()),\n-    }];\n+    let mut stack = vec![PreOrderFrame { node: 0, iter: graph.successors(graph.start_node()) }];\n     visited.insert(graph.start_node());\n-    let mut idx = 0;\n-    pre_order_index[graph.start_node()] = Some(0);\n-    idx += 1;\n-    pre_order_nodes.push(graph.start_node());\n+    let mut pre_order_to_real = Vec::with_capacity(rpo.len());\n+    let mut real_to_pre_order: IndexVec<G::Node, Option<usize>> =\n+        IndexVec::from_elem_n(None, graph.num_nodes());\n+    pre_order_to_real.push(graph.start_node());\n+    real_to_pre_order[graph.start_node()] = Some(0);\n+    let mut idx = 1;\n \n     'recurse: while let Some(frame) = stack.last_mut() {\n         while let Some(successor) = frame.iter.next() {\n             if visited.insert(successor) {\n-                parent[successor] = Some(frame.node);\n-                pre_order_index[successor] = Some(idx);\n-                pre_order_nodes.push(successor);\n-                idx += 1;\n+                parent[idx] = Some(frame.node);\n+                pre_order_to_real.push(successor);\n+                real_to_pre_order[successor] = Some(idx);\n \n-                stack.push(PreOrderFrame { node: successor, iter: graph.successors(successor) });\n+                stack.push(PreOrderFrame { node: idx, iter: graph.successors(successor) });\n+                idx += 1;\n                 continue 'recurse;\n             }\n         }\n         stack.pop();\n     }\n \n-    let mut idom = IndexVec::from_elem_n(graph.start_node(), graph.num_nodes());\n-    let mut semi = IndexVec::from_fn_n(std::convert::identity, graph.num_nodes());\n+    let mut idom = IndexVec::from_elem_n(0, pre_order_to_real.len());\n+    let mut semi = IndexVec::from_fn_n(std::convert::identity, pre_order_to_real.len());\n     let mut label = semi.clone();\n-    let mut bucket = IndexVec::from_elem_n(vec![], graph.num_nodes());\n+    let mut bucket = IndexVec::from_elem_n(vec![], pre_order_to_real.len());\n     let mut lastlinked = None;\n \n-    for &w in pre_order_nodes[1..].iter().rev() {\n-        // Optimization: process buckets just once. We need not explicitly empty\n-        // the bucket here, but mem::take is pretty cheap.\n+    for w in (1..pre_order_to_real.len()).rev() {\n+        // Optimization: process buckets just once, at the start of the\n+        // iteration. Do not explicitly empty the bucket (even though it will\n+        // not be used again), to save some instructions.\n         let z = parent[w].unwrap();\n-        for v in std::mem::take(&mut bucket[z]) {\n-            let y = eval(&pre_order_index, &mut parent, lastlinked, &semi, &mut label, v);\n-            idom[v] = if pre_order_index[semi[y]] < pre_order_index[z] { y } else { z };\n+        for &v in bucket[z].iter() {\n+            let y = eval(&mut parent, lastlinked, &semi, &mut label, v);\n+            idom[v] = if semi[y] < z { y } else { z };\n         }\n \n         semi[w] = w;\n-        for v in graph.predecessors(w) {\n-            let x = eval(&pre_order_index, &mut parent, lastlinked, &semi, &mut label, v);\n-            semi[w] = if pre_order_index[semi[w]].unwrap() < pre_order_index[semi[x]].unwrap() {\n-                semi[w]\n-            } else {\n-                semi[x]\n-            };\n+        for v in graph.predecessors(pre_order_to_real[w]) {\n+            let v = real_to_pre_order[v].unwrap();\n+            let x = eval(&mut parent, lastlinked, &semi, &mut label, v);\n+            semi[w] = std::cmp::min(semi[w], semi[x]);\n         }\n         // semi[w] is now semidominator(w).\n \n@@ -103,59 +96,51 @@ fn dominators_given_rpo<G: ControlFlowGraph>(graph: G, rpo: &[G::Node]) -> Domin\n         // processed elements; lastlinked represents the divider.\n         lastlinked = Some(w);\n     }\n-    for &w in pre_order_nodes.iter().skip(1) {\n+    for w in 1..pre_order_to_real.len() {\n         if idom[w] != semi[w] {\n             idom[w] = idom[idom[w]];\n         }\n     }\n \n     let mut immediate_dominators = IndexVec::from_elem_n(None, graph.num_nodes());\n-    for (node, idom_slot) in immediate_dominators.iter_enumerated_mut() {\n-        if pre_order_index[node].is_some() {\n-            *idom_slot = Some(idom[node]);\n-        }\n+    for (idx, node) in pre_order_to_real.iter().enumerate() {\n+        immediate_dominators[*node] = Some(pre_order_to_real[idom[idx]]);\n     }\n \n     Dominators { post_order_rank, immediate_dominators }\n }\n \n fn eval<N: Idx>(\n-    pre_order_index: &IndexVec<N, Option<usize>>,\n     ancestor: &mut IndexVec<N, Option<N>>,\n     lastlinked: Option<N>,\n     semi: &IndexVec<N, N>,\n     label: &mut IndexVec<N, N>,\n     node: N,\n ) -> N {\n-    if is_processed(pre_order_index, node, lastlinked) {\n-        compress(pre_order_index, ancestor, lastlinked, semi, label, node);\n+    if is_processed(node, lastlinked) {\n+        compress(ancestor, lastlinked, semi, label, node);\n         label[node]\n     } else {\n         node\n     }\n }\n \n-fn is_processed<N: Idx>(\n-    pre_order_index: &IndexVec<N, Option<usize>>,\n-    v: N,\n-    lastlinked: Option<N>,\n-) -> bool {\n-    if let Some(ll) = lastlinked { pre_order_index[v] >= pre_order_index[ll] } else { false }\n+fn is_processed<N: Idx>(v: N, lastlinked: Option<N>) -> bool {\n+    if let Some(ll) = lastlinked { v >= ll } else { false }\n }\n \n fn compress<N: Idx>(\n-    pre_order_index: &IndexVec<N, Option<usize>>,\n     ancestor: &mut IndexVec<N, Option<N>>,\n     lastlinked: Option<N>,\n     semi: &IndexVec<N, N>,\n     label: &mut IndexVec<N, N>,\n     v: N,\n ) {\n-    assert!(is_processed(pre_order_index, v, lastlinked));\n+    assert!(is_processed(v, lastlinked));\n     let u = ancestor[v].unwrap();\n-    if is_processed(pre_order_index, u, lastlinked) {\n-        compress(pre_order_index, ancestor, lastlinked, semi, label, u);\n-        if pre_order_index[semi[label[u]]] < pre_order_index[semi[label[v]]] {\n+    if is_processed(u, lastlinked) {\n+        compress(ancestor, lastlinked, semi, label, u);\n+        if semi[label[u]] < semi[label[v]] {\n             label[v] = label[u];\n         }\n         ancestor[v] = ancestor[u];"}]}