{"sha": "561ce442def02aba880b091d8d5e6a150855869e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MWNlNDQyZGVmMDJhYmE4ODBiMDkxZDhkNWU2YTE1MDg1NTg2OWU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-02-20T10:39:04Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-02-21T16:32:17Z"}, "message": "restore the actual leak-check", "tree": {"sha": "7fdb47aac660d73c61a0806d517732e75746cd18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fdb47aac660d73c61a0806d517732e75746cd18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/561ce442def02aba880b091d8d5e6a150855869e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/561ce442def02aba880b091d8d5e6a150855869e", "html_url": "https://github.com/rust-lang/rust/commit/561ce442def02aba880b091d8d5e6a150855869e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/561ce442def02aba880b091d8d5e6a150855869e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c94ea0bf13f280c4d9606a027237d4d14befee9", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c94ea0bf13f280c4d9606a027237d4d14befee9", "html_url": "https://github.com/rust-lang/rust/commit/0c94ea0bf13f280c4d9606a027237d4d14befee9"}], "stats": {"total": 291, "additions": 277, "deletions": 14}, "files": [{"sha": "7c83fe7fd69467c6eb68e971cacc55356973aff5", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/561ce442def02aba880b091d8d5e6a150855869e/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561ce442def02aba880b091d8d5e6a150855869e/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=561ce442def02aba880b091d8d5e6a150855869e", "patch": "@@ -113,21 +113,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         (result, map)\n     }\n \n-    /// Searches region constraints created since `snapshot` that\n-    /// affect one of the placeholders in `placeholder_map`, returning\n-    /// an error if any of the placeholders are related to another\n-    /// placeholder or would have to escape into some parent universe\n-    /// that cannot name them.\n-    ///\n-    /// This is a temporary backwards compatibility measure to try and\n-    /// retain the older (arguably incorrect) behavior of the\n-    /// compiler.\n+    /// See `infer::region_constraints::RegionConstraintCollector::leak_check`.\n     pub fn leak_check(\n         &self,\n-        _overly_polymorphic: bool,\n-        _placeholder_map: &PlaceholderMap<'tcx>,\n-        _snapshot: &CombinedSnapshot<'_, 'tcx>,\n+        overly_polymorphic: bool,\n+        placeholder_map: &PlaceholderMap<'tcx>,\n+        snapshot: &CombinedSnapshot<'_, 'tcx>,\n     ) -> RelateResult<'tcx, ()> {\n-        Ok(())\n+        self.borrow_region_constraints()\n+            .leak_check(self.tcx, overly_polymorphic, placeholder_map, snapshot)\n     }\n }"}, {"sha": "4056b9e2d83bc3a14b5b47b558bdc1b15d841931", "filename": "src/librustc/infer/region_constraints/leak_check.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/561ce442def02aba880b091d8d5e6a150855869e/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561ce442def02aba880b091d8d5e6a150855869e/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=561ce442def02aba880b091d8d5e6a150855869e", "patch": "@@ -0,0 +1,162 @@\n+use super::*;\n+use crate::infer::{CombinedSnapshot, PlaceholderMap};\n+use crate::ty::error::TypeError;\n+use crate::ty::relate::RelateResult;\n+\n+impl<'tcx> RegionConstraintCollector<'tcx> {\n+    /// Searches region constraints created since `snapshot` that\n+    /// affect one of the placeholders in `placeholder_map`, returning\n+    /// an error if any of the placeholders are related to another\n+    /// placeholder or would have to escape into some parent universe\n+    /// that cannot name them.\n+    ///\n+    /// This is a temporary backwards compatibility measure to try and\n+    /// retain the older (arguably incorrect) behavior of the\n+    /// compiler.\n+    ///\n+    /// NB. The use of snapshot here is mostly an efficiency thing --\n+    /// we could search *all* region constraints, but that'd be a\n+    /// bigger set and the data structures are not setup for that. If\n+    /// we wind up keeping some form of this check long term, it would\n+    /// probably be better to remove the snapshot parameter and to\n+    /// refactor the constraint set.\n+    pub fn leak_check(\n+        &mut self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        overly_polymorphic: bool,\n+        placeholder_map: &PlaceholderMap<'tcx>,\n+        _snapshot: &CombinedSnapshot<'_, 'tcx>,\n+    ) -> RelateResult<'tcx, ()> {\n+        debug!(\"leak_check(placeholders={:?})\", placeholder_map);\n+\n+        assert!(self.in_snapshot());\n+\n+        // Go through each placeholder that we created.\n+        for (_, &placeholder_region) in placeholder_map {\n+            // Find the universe this placeholder inhabits.\n+            let placeholder = match placeholder_region {\n+                ty::RePlaceholder(p) => p,\n+                _ => bug!(\n+                    \"leak_check: expected placeholder found {:?}\",\n+                    placeholder_region,\n+                ),\n+            };\n+\n+            // Find all regions that are related to this placeholder\n+            // in some way. This means any region that either outlives\n+            // or is outlived by a placeholder.\n+            let mut taint_set = TaintSet::new(\n+                TaintDirections::both(),\n+                placeholder_region,\n+            );\n+            taint_set.fixed_point(tcx, &self.undo_log, &self.data.verifys);\n+            let tainted_regions = taint_set.into_set();\n+\n+            // Report an error if two placeholders in the same universe\n+            // are related to one another, or if a placeholder is related\n+            // to something from a parent universe.\n+            for &tainted_region in &tainted_regions {\n+                if let ty::RePlaceholder(_) = tainted_region {\n+                    // Two placeholders cannot be related:\n+                    if tainted_region == placeholder_region {\n+                        continue;\n+                    }\n+                } else if self.universe(tainted_region).can_name(placeholder.universe) {\n+                    continue;\n+                }\n+\n+                return Err(if overly_polymorphic {\n+                    debug!(\"Overly polymorphic!\");\n+                    TypeError::RegionsOverlyPolymorphic(placeholder.name, tainted_region)\n+                } else {\n+                    debug!(\"Not as polymorphic!\");\n+                    TypeError::RegionsInsufficientlyPolymorphic(placeholder.name, tainted_region)\n+                });\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct TaintSet<'tcx> {\n+    directions: TaintDirections,\n+    regions: FxHashSet<ty::Region<'tcx>>,\n+}\n+\n+impl<'tcx> TaintSet<'tcx> {\n+    fn new(directions: TaintDirections, initial_region: ty::Region<'tcx>) -> Self {\n+        let mut regions = FxHashSet::default();\n+        regions.insert(initial_region);\n+        TaintSet {\n+            directions: directions,\n+            regions: regions,\n+        }\n+    }\n+\n+    fn fixed_point(\n+        &mut self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        undo_log: &[UndoLog<'tcx>],\n+        verifys: &[Verify<'tcx>],\n+    ) {\n+        let mut prev_len = 0;\n+        while prev_len < self.len() {\n+            debug!(\n+                \"tainted: prev_len = {:?} new_len = {:?}\",\n+                prev_len,\n+                self.len()\n+            );\n+\n+            prev_len = self.len();\n+\n+            for undo_entry in undo_log {\n+                match undo_entry {\n+                    &AddConstraint(Constraint::VarSubVar(a, b)) => {\n+                        self.add_edge(tcx.mk_region(ReVar(a)), tcx.mk_region(ReVar(b)));\n+                    }\n+                    &AddConstraint(Constraint::RegSubVar(a, b)) => {\n+                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n+                    }\n+                    &AddConstraint(Constraint::VarSubReg(a, b)) => {\n+                        self.add_edge(tcx.mk_region(ReVar(a)), b);\n+                    }\n+                    &AddConstraint(Constraint::RegSubReg(a, b)) => {\n+                        self.add_edge(a, b);\n+                    }\n+                    &AddGiven(a, b) => {\n+                        self.add_edge(a, tcx.mk_region(ReVar(b)));\n+                    }\n+                    &AddVerify(i) => span_bug!(\n+                        verifys[i].origin.span(),\n+                        \"we never add verifications while doing higher-ranked things\",\n+                    ),\n+                    &Purged | &AddCombination(..) | &AddVar(..) => {}\n+                }\n+            }\n+        }\n+    }\n+\n+    fn into_set(self) -> FxHashSet<ty::Region<'tcx>> {\n+        self.regions\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.regions.len()\n+    }\n+\n+    fn add_edge(&mut self, source: ty::Region<'tcx>, target: ty::Region<'tcx>) {\n+        if self.directions.incoming {\n+            if self.regions.contains(&target) {\n+                self.regions.insert(source);\n+            }\n+        }\n+\n+        if self.directions.outgoing {\n+            if self.regions.contains(&source) {\n+                self.regions.insert(target);\n+            }\n+        }\n+    }\n+}"}, {"sha": "8389f0ab1aa79ec374545989347cecf95a53f2ef", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/561ce442def02aba880b091d8d5e6a150855869e/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561ce442def02aba880b091d8d5e6a150855869e/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=561ce442def02aba880b091d8d5e6a150855869e", "patch": "@@ -17,6 +17,8 @@ use crate::ty::{Region, RegionVid};\n use std::collections::BTreeMap;\n use std::{cmp, fmt, mem, u32};\n \n+mod leak_check;\n+\n #[derive(Default)]\n pub struct RegionConstraintCollector<'tcx> {\n     /// For each `RegionVid`, the corresponding `RegionVariableOrigin`."}, {"sha": "f58e5e4fb69f6a52f78a0b3248c6375b13924181", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/561ce442def02aba880b091d8d5e6a150855869e/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561ce442def02aba880b091d8d5e6a150855869e/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=561ce442def02aba880b091d8d5e6a150855869e", "patch": "@@ -1,5 +1,5 @@\n use crate::hir::def_id::DefId;\n-use crate::ty::{self, Region, Ty, TyCtxt};\n+use crate::ty::{self, BoundRegion, Region, Ty, TyCtxt};\n use std::borrow::Cow;\n use std::fmt;\n use rustc_target::spec::abi;\n@@ -27,6 +27,8 @@ pub enum TypeError<'tcx> {\n     ArgCount,\n \n     RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n+    RegionsInsufficientlyPolymorphic(BoundRegion, Region<'tcx>),\n+    RegionsOverlyPolymorphic(BoundRegion, Region<'tcx>),\n     RegionsPlaceholderMismatch,\n \n     Sorts(ExpectedFound<Ty<'tcx>>),\n@@ -101,6 +103,18 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             RegionsDoesNotOutlive(..) => {\n                 write!(f, \"lifetime mismatch\")\n             }\n+            RegionsInsufficientlyPolymorphic(br, _) => {\n+                write!(f,\n+                       \"expected bound lifetime parameter{}{}, found concrete lifetime\",\n+                       if br.is_named() { \" \" } else { \"\" },\n+                       br)\n+            }\n+            RegionsOverlyPolymorphic(br, _) => {\n+                write!(f,\n+                       \"expected concrete lifetime, found bound lifetime parameter{}{}\",\n+                       if br.is_named() { \" \" } else { \"\" },\n+                       br)\n+            }\n             RegionsPlaceholderMismatch => {\n                 write!(f, \"one type is more general than the other\")\n             }"}, {"sha": "f9173836cc627080f37d67b5444e33cc53bdf80b", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/561ce442def02aba880b091d8d5e6a150855869e/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561ce442def02aba880b091d8d5e6a150855869e/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=561ce442def02aba880b091d8d5e6a150855869e", "patch": "@@ -434,6 +434,12 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             RegionsDoesNotOutlive(a, b) => {\n                 return tcx.lift(&(a, b)).map(|(a, b)| RegionsDoesNotOutlive(a, b))\n             }\n+            RegionsInsufficientlyPolymorphic(a, b) => {\n+                return tcx.lift(&b).map(|b| RegionsInsufficientlyPolymorphic(a, b))\n+            }\n+            RegionsOverlyPolymorphic(a, b) => {\n+                return tcx.lift(&b).map(|b| RegionsOverlyPolymorphic(a, b))\n+            }\n             RegionsPlaceholderMismatch => RegionsPlaceholderMismatch,\n             IntMismatch(x) => IntMismatch(x),\n             FloatMismatch(x) => FloatMismatch(x),\n@@ -1021,6 +1027,8 @@ EnumTypeFoldableImpl! {\n         (ty::error::TypeError::FixedArraySize)(x),\n         (ty::error::TypeError::ArgCount),\n         (ty::error::TypeError::RegionsDoesNotOutlive)(a, b),\n+        (ty::error::TypeError::RegionsInsufficientlyPolymorphic)(a, b),\n+        (ty::error::TypeError::RegionsOverlyPolymorphic)(a, b),\n         (ty::error::TypeError::RegionsPlaceholderMismatch),\n         (ty::error::TypeError::IntMismatch)(x),\n         (ty::error::TypeError::FloatMismatch)(x),"}, {"sha": "2c8590554580719201b873c12e6a9afdbeb89d39", "filename": "src/test/ui/hrtb/issue-46989.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/561ce442def02aba880b091d8d5e6a150855869e/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561ce442def02aba880b091d8d5e6a150855869e/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-46989.rs?ref=561ce442def02aba880b091d8d5e6a150855869e", "patch": "@@ -0,0 +1,42 @@\n+// Regression test for #46989:\n+//\n+// In the move to universes, this test started passing.\n+// It is not necessarily WRONG to do so, but it was a bit\n+// surprising. The reason that it passed is that when we were\n+// asked to prove that\n+//\n+//     for<'a> fn(&'a i32): Foo\n+//\n+// we were able to use the impl below to prove\n+//\n+//     fn(&'empty i32): Foo\n+//\n+// and then we were able to prove that\n+//\n+//     fn(&'empty i32) = for<'a> fn(&'a i32)\n+//\n+// This last fact is somewhat surprising, but essentially \"falls out\"\n+// from handling variance correctly. In particular, consider the subtyping\n+// relations. First:\n+//\n+//     fn(&'empty i32) <: for<'a> fn(&'a i32)\n+//\n+// This holds because -- intuitively -- a fn that takes a reference but doesn't use\n+// it can be given a reference with any lifetime. Similarly, the opposite direction:\n+//\n+//     for<'a> fn(&'a i32) <: fn(&'empty i32)\n+//\n+// holds because 'a can be instantiated to 'empty.\n+\n+trait Foo {\n+\n+}\n+\n+impl<A> Foo for fn(A) { }\n+\n+fn assert_foo<T: Foo>() {}\n+\n+fn main() {\n+    assert_foo::<fn(&i32)>();\n+    //~^ ERROR the trait bound `for<'r> fn(&'r i32): Foo` is not satisfied\n+}"}, {"sha": "4bcaef3616bd599f6812b7fef5000a422c1a282d", "filename": "src/test/ui/hrtb/issue-57639.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/561ce442def02aba880b091d8d5e6a150855869e/src%2Ftest%2Fui%2Fhrtb%2Fissue-57639.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561ce442def02aba880b091d8d5e6a150855869e/src%2Ftest%2Fui%2Fhrtb%2Fissue-57639.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-57639.rs?ref=561ce442def02aba880b091d8d5e6a150855869e", "patch": "@@ -0,0 +1,29 @@\n+// Regression test for #57639:\n+//\n+// In the move to universes, this test stopped working. The problem\n+// was that when the trait solver was asked to prove `for<'a> T::Item:\n+// Foo<'a>` as part of WF checking, it wound up \"eagerly committing\"\n+// to the where clause, which says that `T::Item: Foo<'a>`, but it\n+// should instead have been using the bound found in the trait\n+// declaration. Pre-universe, this used to work out ok because we got\n+// \"eager errors\" due to the leak check.\n+//\n+// See [this comment on GitHub][c] for more details.\n+//\n+// run-pass\n+//\n+// [c]: https://github.com/rust-lang/rust/issues/57639#issuecomment-455685861\n+\n+trait Foo<'a> {}\n+\n+trait Bar {\n+    type Item: for<'a> Foo<'a>;\n+}\n+\n+fn foo<'a, T>(_: T)\n+where\n+    T: Bar,\n+    T::Item: Foo<'a>,\n+{}\n+\n+fn main() { }"}, {"sha": "7ca6914d2ea96fdec7ab1ff9a080f71114ab2940", "filename": "src/test/ui/hrtb/issue-58451.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/561ce442def02aba880b091d8d5e6a150855869e/src%2Ftest%2Fui%2Fhrtb%2Fissue-58451.rs", "raw_url": "https://github.com/rust-lang/rust/raw/561ce442def02aba880b091d8d5e6a150855869e/src%2Ftest%2Fui%2Fhrtb%2Fissue-58451.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-58451.rs?ref=561ce442def02aba880b091d8d5e6a150855869e", "patch": "@@ -0,0 +1,13 @@\n+// Regression test for #58451:\n+//\n+// Error reporting here encountered an ICE in the shift to universes.\n+\n+fn f<I>(i: I)\n+where\n+    I: IntoIterator,\n+    I::Item: for<'a> Into<&'a ()>,\n+{}\n+\n+fn main() {\n+    f(&[f()]);\n+}"}]}