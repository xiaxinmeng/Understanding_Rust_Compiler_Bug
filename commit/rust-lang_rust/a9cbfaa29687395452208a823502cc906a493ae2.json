{"sha": "a9cbfaa29687395452208a823502cc906a493ae2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5Y2JmYWEyOTY4NzM5NTQ1MjIwOGE4MjM1MDJjYzkwNmE0OTNhZTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-14T21:29:09Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-20T20:09:42Z"}, "message": "rewrite to use a custom folder", "tree": {"sha": "d7d8f9aeb28678d3a071e8bc361f4e361df98529", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7d8f9aeb28678d3a071e8bc361f4e361df98529"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9cbfaa29687395452208a823502cc906a493ae2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9cbfaa29687395452208a823502cc906a493ae2", "html_url": "https://github.com/rust-lang/rust/commit/a9cbfaa29687395452208a823502cc906a493ae2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9cbfaa29687395452208a823502cc906a493ae2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75af15ee6ca0c12b699a17984b033363cd25e9c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/75af15ee6ca0c12b699a17984b033363cd25e9c3", "html_url": "https://github.com/rust-lang/rust/commit/75af15ee6ca0c12b699a17984b033363cd25e9c3"}], "stats": {"total": 92, "additions": 50, "deletions": 42}, "files": [{"sha": "6a4f4072f53dcf952025ecb482e204db6c122cfa", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 50, "deletions": 42, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a9cbfaa29687395452208a823502cc906a493ae2/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9cbfaa29687395452208a823502cc906a493ae2/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=a9cbfaa29687395452208a823502cc906a493ae2", "patch": "@@ -14,8 +14,8 @@ use infer::outlives::free_region_map::FreeRegionRelations;\n use rustc_data_structures::fx::FxHashMap;\n use syntax::ast;\n use traits::{self, PredicateObligation};\n-use ty::{self, Ty};\n-use ty::fold::{BottomUpFolder, TypeFoldable};\n+use ty::{self, Ty, TyCtxt};\n+use ty::fold::{BottomUpFolder, TypeFoldable, TypeFolder};\n use ty::outlives::Component;\n use ty::subst::{Kind, UnpackedKind, Substs};\n use util::nodemap::DefIdMap;\n@@ -458,55 +458,63 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // Convert the type from the function into a type valid outside\n         // the function, by replacing invalid regions with 'static,\n         // after producing an error for each of them.\n-        let definition_ty = gcx.fold_regions(&instantiated_ty, &mut false, |r, _| {\n-            match *r {\n-                // 'static and early-bound regions are valid.\n-                ty::ReStatic | ty::ReEmpty => r,\n-\n-                // All other regions, we map them appropriately to their adjusted\n-                // indices, erroring if we find any lifetimes that were not mapped\n-                // into the new set.\n-                _ => if let Some(UnpackedKind::Lifetime(r1)) = map.get(&r.into())\n-                                                                  .map(|k| k.unpack()) {\n-                    r1\n-                } else {\n-                    // No mapping was found. This means that\n-                    // it is either a disallowed lifetime,\n-                    // which will be caught by regionck, or it\n-                    // is a region in a non-upvar closure\n-                    // generic, which is explicitly\n-                    // allowed. If that surprises you, read\n-                    // on.\n-                    //\n-                    // The case of closure is a somewhat\n-                    // subtle (read: hacky) consideration. The\n-                    // problem is that our closure types\n-                    // currently include all the lifetime\n-                    // parameters declared on the enclosing\n-                    // function, even if they are unused by\n-                    // the closure itself. We can't readily\n-                    // filter them out, so here we replace\n-                    // those values with `'empty`. This can't\n-                    // really make a difference to the rest of\n-                    // the compiler; those regions are ignored\n-                    // for the outlives relation, and hence\n-                    // don't affect trait selection or auto\n-                    // traits, and they are erased during\n-                    // trans.\n-                    gcx.types.re_empty\n-                },\n-            }\n-        });\n-\n+        let definition_ty = instantiated_ty.fold_with(&mut ReverseMapper { tcx: self.tcx, map });\n         debug!(\n             \"infer_anon_definition_from_instantiation: definition_ty={:?}\",\n             definition_ty\n         );\n \n+        // We can unwrap here because our reverse mapper always\n+        // produces things with 'gcx lifetime, though the type folder\n+        // obscures that.\n+        let definition_ty = gcx.lift(&definition_ty).unwrap();\n+\n         definition_ty\n     }\n }\n \n+struct ReverseMapper<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    map: FxHashMap<Kind<'tcx>, Kind<'gcx>>\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for ReverseMapper<'cx, 'gcx, 'tcx> {\n+    fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        // ignore bound regions that appear in the type (e.g., this\n+        // would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n+        if let ty::ReLateBound(..) = *r {\n+            return r;\n+        }\n+\n+        match self.map.get(&r.into()).map(|k| k.unpack()) {\n+            Some(UnpackedKind::Lifetime(r1)) => r1,\n+            Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n+            None => {\n+                // No mapping was found. This means that it is either a\n+                // disallowed lifetime, which will be caught by regionck,\n+                // or it is a region in a non-upvar closure generic, which\n+                // is explicitly allowed. If that surprises you, read on.\n+                //\n+                // The case of closure is a somewhat subtle (read: hacky)\n+                // consideration. The problem is that our closure types\n+                // currently include all the lifetime parameters declared\n+                // on the enclosing function, even if they are unused by\n+                // the closure itself. We can't readily filter them out,\n+                // so here we replace those values with `'empty`. This\n+                // can't really make a difference to the rest of the\n+                // compiler; those regions are ignored for the outlives\n+                // relation, and hence don't affect trait selection or\n+                // auto traits, and they are erased during trans.\n+                self.tcx.types.re_empty\n+            }\n+        }\n+    }\n+}\n+\n struct Instantiator<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     parent_def_id: DefId,"}]}