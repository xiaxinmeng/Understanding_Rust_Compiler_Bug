{"sha": "b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ZmE5ZDNiZTEwZTk1MmZiY2FmMTRmMzA5OGFlYmYxM2RlZGQ3ZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-08T17:25:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-08T17:25:15Z"}, "message": "auto merge of #7015 : huonw/rust/each-fn-kill, r=thestinger\n\nContinuation of #6995/#6999.", "tree": {"sha": "f99d1c8374844ccf7a3368110d3e33c0e51f18bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f99d1c8374844ccf7a3368110d3e33c0e51f18bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "html_url": "https://github.com/rust-lang/rust/commit/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2ec8e71cec0373616953f8188cf7c4953269af0", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2ec8e71cec0373616953f8188cf7c4953269af0", "html_url": "https://github.com/rust-lang/rust/commit/e2ec8e71cec0373616953f8188cf7c4953269af0"}, {"sha": "98ba91f81bea38d8fc8bd5bc0cb44ac3e173a53c", "url": "https://api.github.com/repos/rust-lang/rust/commits/98ba91f81bea38d8fc8bd5bc0cb44ac3e173a53c", "html_url": "https://github.com/rust-lang/rust/commit/98ba91f81bea38d8fc8bd5bc0cb44ac3e173a53c"}], "stats": {"total": 1401, "additions": 449, "deletions": 952}, "files": [{"sha": "892908dc0a0d8ed4f2db4529463ce2ec2d0903ce", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -351,10 +351,11 @@ a single large vector of floats. Each task needs the full vector to perform its\n # use std::vec;\n # use std::uint;\n # use std::rand;\n+# use std::iterator::IteratorUtil;\n use extra::arc::ARC;\n \n fn pnorm(nums: &~[float], p: uint) -> float {\n-    (vec::foldl(0.0, *nums, |a,b| a+(*b).pow(p as float) )).pow(1f / (p as float))\n+    nums.iter().fold(0.0, |a,b| a+(*b).pow(p as float) ).pow(1f / (p as float))\n }\n \n fn main() {"}, {"sha": "f86ab2c909313432cccaa1f7b069a54160b4ae23", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -10,14 +10,9 @@\n \n use core::prelude::*;\n \n-use core::comm;\n-use core::io;\n-use core::libc::c_int;\n use core::os;\n use core::run;\n use core::str;\n-use core::task;\n-use core::vec;\n \n #[cfg(target_os = \"win32\")]\n fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n@@ -74,4 +69,3 @@ pub fn run(lib_path: &str,\n         err: str::from_bytes(output.error)\n     }\n }\n-"}, {"sha": "1015373d7ce9e960ec1a765b858f5e864d0d313d", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -22,6 +22,7 @@ use procsrv;\n use util;\n use util::logv;\n \n+use core::iterator::IteratorUtil;\n use core::io;\n use core::os;\n use core::str;\n@@ -780,7 +781,7 @@ fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n                      Some(~\"\"));\n \n     let mut exitcode : int = 0;\n-    for str::each_char(exitcode_out) |c| {\n+    for exitcode_out.iter().advance |c| {\n         if !c.is_digit() { break; }\n         exitcode = exitcode * 10 + match c {\n             '0' .. '9' => c as int - ('0' as int),"}, {"sha": "7fac125243eb0ffded8b56b3ee759f037e309344", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -20,6 +20,7 @@ Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::managed;\n use core::old_iter;\n use core::vec;\n@@ -110,7 +111,7 @@ pub fn from_elem<T>(data: T) -> @mut DList<T> {\n \n /// Creates a new dlist from a vector of elements, maintaining the same order\n pub fn from_vec<T:Copy>(vec: &[T]) -> @mut DList<T> {\n-    do vec::foldl(DList(), vec) |list,data| {\n+    do vec.iter().fold(DList()) |list,data| {\n         list.push(*data); // Iterating left-to-right -- add newly to the tail.\n         list\n     }"}, {"sha": "160827327150163b358cddd7906b517b998c4184", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -414,6 +414,7 @@ mod test {\n \n     use super::{FileInput, pathify, input_vec, input_vec_state};\n \n+    use core::iterator::IteratorUtil;\n     use core::io;\n     use core::str;\n     use core::uint;\n@@ -455,7 +456,7 @@ mod test {\n \n         let fi = FileInput::from_vec(copy filenames);\n \n-        for \"012\".each_chari |line, c| {\n+        for \"012\".iter().enumerate().advance |(line, c)| {\n             assert_eq!(fi.read_byte(), c as int);\n             assert_eq!(fi.state().line_num, line);\n             assert_eq!(fi.state().line_num_file, 0);"}, {"sha": "0fde03b69cbf56f05da07454d03e445aa36f06c4", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -16,8 +16,6 @@ Simple compression\n \n #[allow(missing_doc)];\n \n-use core::prelude::*;\n-\n use core::libc::{c_void, size_t, c_int};\n use core::libc;\n use core::vec;\n@@ -87,6 +85,7 @@ mod tests {\n     use super::*;\n     use core::rand;\n     use core::rand::RngUtil;\n+    use core::prelude::*;\n \n     #[test]\n     #[allow(non_implicitly_copyable_typarams)]"}, {"sha": "c0f619c1b858d9d89c014a6f6cf75c240c02ab55", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -654,7 +654,6 @@ mod test {\n     use core::int;\n     use core::io::BytesWriter;\n     use core::result;\n-    use core::sys;\n     use core::task;\n \n     #[test]"}, {"sha": "fc1597ffed4456947aef9052bf38381c79b0d0ae", "filename": "src/libextra/json.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -18,6 +18,7 @@\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::char;\n use core::float;\n use core::hashmap::HashMap;\n@@ -58,7 +59,7 @@ pub struct Error {\n \n fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n-    for str::each_char(s) |c| {\n+    for s.iter().advance |c| {\n         match c {\n           '\"' => escaped += \"\\\\\\\"\",\n           '\\\\' => escaped += \"\\\\\\\\\",\n@@ -913,7 +914,8 @@ impl serialize::Decoder for Decoder {\n \n     fn read_char(&mut self) -> char {\n         let mut v = ~[];\n-        for str::each_char(self.read_str()) |c| { v.push(c) }\n+        let s = self.read_str();\n+        for s.iter().advance |c| { v.push(c) }\n         if v.len() != 1 { fail!(\"string must have one character\") }\n         v[0]\n     }"}, {"sha": "0d0b5ea00f0d2b8a69e18697be2183b7e92fc96d", "filename": "src/libextra/list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flist.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -12,7 +12,7 @@\n \n use core::prelude::*;\n \n-use core::vec;\n+use core::iterator::IteratorUtil;\n \n #[deriving(Eq)]\n pub enum List<T> {\n@@ -28,7 +28,7 @@ pub enum MutList<T> {\n \n /// Create a list from a vector\n pub fn from_vec<T:Copy>(v: &[T]) -> @List<T> {\n-    vec::foldr(v, @Nil::<T>, |h, t| @Cons(*h, t))\n+    v.rev_iter().fold(@Nil::<T>, |t, h| @Cons(*h, t))\n }\n \n /**"}, {"sha": "f26019d928208014496fc591b7cd18da8b7209b3", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -14,6 +14,7 @@\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::cmp::Eq;\n use core::io::{Reader, ReaderUtil};\n use core::io;\n@@ -358,7 +359,7 @@ pub fn query_to_str(query: &Query) -> ~str {\n \n // returns the scheme and the rest of the url, or a parsing error\n pub fn get_scheme(rawurl: &str) -> Result<(~str, ~str), ~str> {\n-    for str::each_chari(rawurl) |i,c| {\n+    for rawurl.iter().enumerate().advance |(i,c)| {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' => loop,\n           '0' .. '9' | '+' | '-' | '.' => {\n@@ -418,7 +419,7 @@ fn get_authority(rawurl: &str) ->\n     let mut colon_count = 0;\n     let mut (pos, begin, end) = (0, 2, len);\n \n-    for str::each_chari(rawurl) |i,c| {\n+    for rawurl.iter().enumerate().advance |(i,c)| {\n         if i < 2 { loop; } // ignore the leading //\n \n         // deal with input class first\n@@ -562,7 +563,7 @@ fn get_path(rawurl: &str, authority: bool) ->\n     Result<(~str, ~str), ~str> {\n     let len = str::len(rawurl);\n     let mut end = len;\n-    for str::each_chari(rawurl) |i,c| {\n+    for rawurl.iter().enumerate().advance |(i,c)| {\n         match c {\n           'A' .. 'Z' | 'a' .. 'z' | '0' .. '9' | '&' |'\\'' | '(' | ')' | '.'\n           | '@' | ':' | '%' | '/' | '+' | '!' | '*' | ',' | ';' | '='"}, {"sha": "1411079d52f0dafdb2dd6236595594c8ef0731be", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -19,7 +19,7 @@ A BigInt is a combination of BigUint and Sign.\n #[allow(missing_doc)];\n \n use core::prelude::*;\n-\n+use core::iterator::IteratorUtil;\n use core::cmp::{Eq, Ord, TotalEq, TotalOrd, Ordering, Less, Equal, Greater};\n use core::int;\n use core::num::{IntConvertible, Zero, One, ToStrRadix, FromStrRadix, Orderable};\n@@ -129,12 +129,9 @@ impl TotalOrd for BigUint {\n         if s_len < o_len { return Less; }\n         if s_len > o_len { return Greater;  }\n \n-        for self.data.eachi_reverse |i, elm| {\n-            match (*elm, other.data[i]) {\n-                (l, r) if l < r => return Less,\n-                (l, r) if l > r => return Greater,\n-                _               => loop\n-            };\n+        for self.data.rev_iter().zip(other.data.rev_iter()).advance |(&self_i, &other_i)| {\n+            cond!((self_i < other_i) { return Less; }\n+                  (self_i > other_i) { return Greater; })\n         }\n         return Equal;\n     }\n@@ -421,7 +418,7 @@ impl Integer for BigUint {\n             let bn = *b.data.last();\n             let mut d = ~[];\n             let mut carry = 0;\n-            for an.each_reverse |elt| {\n+            for an.rev_iter().advance |elt| {\n                 let ai = BigDigit::to_uint(carry, *elt);\n                 let di = ai / (bn as uint);\n                 assert!(di < BigDigit::base);\n@@ -648,7 +645,7 @@ impl BigUint {\n \n         let mut borrow = 0;\n         let mut shifted = ~[];\n-        for self.data.each_reverse |elem| {\n+        for self.data.rev_iter().advance |elem| {\n             shifted = ~[(*elem >> n_bits) | borrow] + shifted;\n             borrow = *elem << (BigDigit::bits - n_bits);\n         }"}, {"sha": "23b7cdc09974780cc5fee860b3e272ac52e71232", "filename": "src/libextra/par.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::cast;\n use core::ptr;\n use core::sys;\n@@ -122,25 +123,24 @@ pub fn alli<A:Copy + Owned>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(uint, &A) -> bool) -> bool\n {\n-    do vec::all(map_slices(xs, || {\n+    let mapped = map_slices(xs, || {\n         let f = fn_factory();\n         let result: ~fn(uint, &[A]) -> bool = |base, slice| {\n-            vec::alli(slice, |i, x| {\n-                f(i + base, x)\n-            })\n+            slice.iter().enumerate().all(|(i, x)| f(i + base, x))\n         };\n         result\n-    })) |x| { *x }\n+    });\n+    mapped.iter().all(|&x| x)\n }\n \n /// Returns true if the function holds for any elements in the vector.\n pub fn any<A:Copy + Owned>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(&A) -> bool) -> bool {\n-    do vec::any(map_slices(xs, || {\n+    let mapped = map_slices(xs, || {\n         let f = fn_factory();\n-        let result: ~fn(uint, &[A]) -> bool =\n-            |_, slice| vec::any(slice, |x| f(x));\n+        let result: ~fn(uint, &[A]) -> bool = |_, slice| slice.iter().any(f);\n         result\n-    })) |x| { *x }\n+    });\n+    mapped.iter().any(|&x| x)\n }"}, {"sha": "26d1e28e12252b3fd021c91046f24433aa9832b5", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -929,11 +929,8 @@ mod test_tim_sort {\n     use core::prelude::*;\n \n     use sort::tim_sort;\n-\n-    use core::local_data;\n     use core::rand::RngUtil;\n     use core::rand;\n-    use core::uint;\n     use core::vec;\n \n     struct CVal {"}, {"sha": "0cc1ee9a1d716eff180460ad8007301ddc12c384", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -12,6 +12,7 @@\n \n use core::prelude::*;\n \n+use core::iterator::*;\n use core::vec;\n use core::f64;\n use core::cmp;\n@@ -36,17 +37,17 @@ pub trait Stats {\n \n impl<'self> Stats for &'self [f64] {\n     fn sum(self) -> f64 {\n-        vec::foldl(0.0, self, |p,q| p + *q)\n+        self.iter().fold(0.0, |p,q| p + *q)\n     }\n \n     fn min(self) -> f64 {\n         assert!(self.len() != 0);\n-        vec::foldl(self[0], self, |p,q| cmp::min(p, *q))\n+        self.iter().fold(self[0], |p,q| cmp::min(p, *q))\n     }\n \n     fn max(self) -> f64 {\n         assert!(self.len() != 0);\n-        vec::foldl(self[0], self, |p,q| cmp::max(p, *q))\n+        self.iter().fold(self[0], |p,q| cmp::max(p, *q))\n     }\n \n     fn mean(self) -> f64 {"}, {"sha": "83c0bb516b4362452b5dc9f17152102180dcafdd", "filename": "src/libextra/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstd.rc?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -148,4 +148,3 @@ pub mod extra {\n     pub use serialize;\n     pub use test;\n }\n-"}, {"sha": "8bbe0afa704e115a4a45fa75c4ddc34a2a4ff36c", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -731,7 +731,6 @@ mod tests {\n     use core::cast;\n     use core::cell::Cell;\n     use core::comm;\n-    use core::ptr;\n     use core::result;\n     use core::task;\n     use core::vec;"}, {"sha": "98c5783807239cfbc700ae0d40a6145f33b99958", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -34,7 +34,6 @@ mod tests {\n     use core::prelude::*;\n \n     use tempfile::mkdtemp;\n-    use tempfile;\n \n     use core::os;\n     use core::str;"}, {"sha": "dd3e4f48c634b924dc731b5120ab78cb61525cf3", "filename": "src/libextra/time.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -16,6 +16,7 @@ use core::i32;\n use core::int;\n use core::io;\n use core::str;\n+use core::iterator::IteratorUtil;\n \n static NSEC_PER_SEC: i32 = 1_000_000_000_i32;\n \n@@ -261,7 +262,7 @@ impl Tm {\n priv fn do_strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n     fn match_str(s: &str, pos: uint, needle: &str) -> bool {\n         let mut i = pos;\n-        for str::each(needle) |ch| {\n+        for needle.bytes_iter().advance |ch| {\n             if s[i] != ch {\n                 return false;\n             }"}, {"sha": "9db3d48a3b810b3def04da640dbf488ead3afa77", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -1034,8 +1034,6 @@ mod test_set {\n \n     use super::*;\n \n-    use core::vec;\n-\n     #[test]\n     fn test_clear() {\n         let mut s = TreeSet::new();"}, {"sha": "2522f149bf40a574e3336de37a77dc282e1cc9ae", "filename": "src/libextra/uv_ll.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibextra%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_ll.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -1234,7 +1234,6 @@ mod test {\n \n     use core::comm::{SharedChan, stream, GenericChan, GenericPort};\n     use core::libc;\n-    use core::result;\n     use core::str;\n     use core::sys;\n     use core::task;"}, {"sha": "29e7ba0e62f7d47a1b78c4e8972fee7d39ee35d7", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -22,6 +22,7 @@ use middle::trans::common::CrateContext;\n use middle::ty;\n use util::ppaux;\n \n+use core::iterator::IteratorUtil;\n use core::char;\n use core::hash::Streaming;\n use core::hash;\n@@ -636,7 +637,7 @@ pub fn get_symbol_hash(ccx: @CrateContext, t: ty::t) -> @str {\n // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n pub fn sanitize(s: &str) -> ~str {\n     let mut result = ~\"\";\n-    for str::each_char(s) |c| {\n+    for s.iter().advance |c| {\n         match c {\n             // Escape these with $ sequences\n             '@' => result += \"$SP$\","}, {"sha": "5d0de5356299c090fdb4b91bc6a1ec18e098116e", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -22,7 +22,6 @@ use syntax::codemap::{dummy_sp, span, ExpandedFrom, CallInfo, NameAndSpan};\n use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n use syntax::fold;\n-use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n "}, {"sha": "98f8efb72c80f79d21cdd242ea5c39aaca42c9a3", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -19,6 +19,7 @@ use middle::typeck::method_map;\n use middle::moves;\n use util::ppaux::ty_to_str;\n \n+use core::iterator::IteratorUtil;\n use core::uint;\n use core::vec;\n use extra::sort;\n@@ -242,7 +243,7 @@ pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n                 not_useful\n               }\n               ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n-                let max_len = do m.foldr(0) |r, max_len| {\n+                let max_len = do m.rev_iter().fold(0) |max_len, r| {\n                   match r[0].node {\n                     pat_vec(ref before, _, ref after) => {\n                       uint::max(before.len() + after.len(), max_len)"}, {"sha": "45447d3993c5bf9f9e360618d19ada72d36a6344", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -18,6 +18,7 @@ use middle;\n use syntax::{ast, ast_map, ast_util, visit};\n use syntax::ast::*;\n \n+use core::iterator::IteratorUtil;\n use core::float;\n use core::hashmap::{HashMap, HashSet};\n use core::vec;\n@@ -72,7 +73,7 @@ pub fn join(a: constness, b: constness) -> constness {\n }\n \n pub fn join_all(cs: &[constness]) -> constness {\n-    vec::foldl(integral_const, cs, |a, b| join(a, *b))\n+    cs.iter().fold(integral_const, |a, b| join(a, *b))\n }\n \n pub fn classify(e: @expr,"}, {"sha": "8a9a67db8027154e16e75f191b4de3a16c378fc3", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -110,6 +110,7 @@ use middle::ty;\n use middle::typeck;\n use middle::moves;\n \n+use core::iterator::IteratorUtil;\n use core::cast::transmute;\n use core::hashmap::HashMap;\n use core::io;\n@@ -923,7 +924,7 @@ impl Liveness {\n     pub fn propagate_through_block(&self, blk: &blk, succ: LiveNode)\n                                    -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.node.expr, succ);\n-        do blk.node.stmts.foldr(succ) |stmt, succ| {\n+        do blk.node.stmts.rev_iter().fold(succ) |succ, stmt| {\n             self.propagate_through_stmt(*stmt, succ)\n         }\n     }\n@@ -977,7 +978,7 @@ impl Liveness {\n \n     pub fn propagate_through_exprs(&self, exprs: &[@expr], succ: LiveNode)\n                                    -> LiveNode {\n-        do exprs.foldr(succ) |expr, succ| {\n+        do exprs.rev_iter().fold(succ) |succ, expr| {\n             self.propagate_through_expr(*expr, succ)\n         }\n     }\n@@ -1021,7 +1022,7 @@ impl Liveness {\n                  // the construction of a closure itself is not important,\n                  // but we have to consider the closed over variables.\n                  let caps = self.ir.captures(expr);\n-                 do caps.foldr(succ) |cap, succ| {\n+                 do caps.rev_iter().fold(succ) |succ, cap| {\n                      self.init_from_succ(cap.ln, succ);\n                      let var = self.variable(cap.var_nid, expr.span);\n                      self.acc(cap.ln, var, ACC_READ | ACC_USE);\n@@ -1159,7 +1160,7 @@ impl Liveness {\n \n           expr_struct(_, ref fields, with_expr) => {\n             let succ = self.propagate_through_opt_expr(with_expr, succ);\n-            do (*fields).foldr(succ) |field, succ| {\n+            do fields.rev_iter().fold(succ) |succ, field| {\n                 self.propagate_through_expr(field.node.expr, succ)\n             }\n           }\n@@ -1215,10 +1216,10 @@ impl Liveness {\n           }\n \n           expr_inline_asm(ref ia) =>{\n-            let succ = do ia.inputs.foldr(succ) |&(_, expr), succ| {\n+            let succ = do ia.inputs.rev_iter().fold(succ) |succ, &(_, expr)| {\n                 self.propagate_through_expr(expr, succ)\n             };\n-            do ia.outputs.foldr(succ) |&(_, expr), succ| {\n+            do ia.outputs.rev_iter().fold(succ) |succ, &(_, expr)| {\n                 self.propagate_through_expr(expr, succ)\n             }\n           }"}, {"sha": "49db0ee7bd30af73891c106678c270dbc1b0b801", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -172,6 +172,7 @@ use middle::trans::type_of;\n use middle::ty;\n use util::common::indenter;\n \n+use core::iterator::IteratorUtil;\n use core::hashmap::HashMap;\n use core::vec;\n use syntax::ast;\n@@ -798,7 +799,7 @@ pub fn enter_region<'r>(bcx: block,\n pub fn get_options(bcx: block, m: &[@Match], col: uint) -> ~[Opt] {\n     let ccx = bcx.ccx();\n     fn add_to_set(tcx: ty::ctxt, set: &mut ~[Opt], val: Opt) {\n-        if set.any(|l| opt_eq(tcx, l, &val)) {return;}\n+        if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n \n@@ -965,7 +966,7 @@ pub fn collect_record_or_struct_fields(bcx: block,\n     fn extend(idents: &mut ~[ast::ident], field_pats: &[ast::field_pat]) {\n         for field_pats.each |field_pat| {\n             let field_ident = field_pat.ident;\n-            if !vec::any(*idents, |x| *x == field_ident) {\n+            if !idents.iter().any(|x| *x == field_ident) {\n                 idents.push(field_ident);\n             }\n         }\n@@ -976,11 +977,11 @@ pub fn pats_require_rooting(bcx: block,\n                             m: &[@Match],\n                             col: uint)\n                          -> bool {\n-    vec::any(m, |br| {\n+    do m.iter().any |br| {\n         let pat_id = br.pats[col].id;\n         let key = root_map_key {id: pat_id, derefs: 0u };\n         bcx.ccx().maps.root_map.contains_key(&key)\n-    })\n+    }\n }\n \n pub fn root_pats_as_necessary(mut bcx: block,\n@@ -1005,12 +1006,12 @@ pub fn root_pats_as_necessary(mut bcx: block,\n // matches may be wildcards like _ or identifiers).\n macro_rules! any_pat (\n     ($m:expr, $pattern:pat) => (\n-        vec::any($m, |br| {\n+        do ($m).iter().any |br| {\n             match br.pats[col].node {\n                 $pattern => true,\n                 _ => false\n             }\n-        })\n+        }\n     )\n )\n \n@@ -1031,7 +1032,7 @@ pub fn any_tup_pat(m: &[@Match], col: uint) -> bool {\n }\n \n pub fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n-    vec::any(m, |br| {\n+    do m.iter().any |br| {\n         let pat = br.pats[col];\n         match pat.node {\n             ast::pat_enum(_, Some(_)) => {\n@@ -1043,7 +1044,7 @@ pub fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n             }\n             _ => false\n         }\n-    })\n+    }\n }\n \n pub type mk_fail = @fn() -> BasicBlockRef;"}, {"sha": "8e1b165f408969c4b4fdaf5eeb4636e8fb5422ca", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -44,6 +44,7 @@\n  *   taken to it, implementing them for Rust seems difficult.\n  */\n \n+use core::iterator::IteratorUtil;\n use core::container::Map;\n use core::libc::c_ulonglong;\n use core::option::{Option, Some, None};\n@@ -176,7 +177,7 @@ fn represent_type_uncached(cx: @CrateContext, t: ty::t) -> Repr {\n             // Since there's at least one\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n-            if !cases.alli(|i,c| c.discr == (i as int)) {\n+            if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as int)) {\n                 cx.sess.bug(fmt!(\"non-C-like enum %s with specified \\\n                                   discriminants\",\n                                  ty::item_path_str(cx.tcx, def_id)))"}, {"sha": "f368255030bd28942244300a58023887d78624f3", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -64,6 +64,7 @@ use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, ty_to_str};\n \n+use core::iterator::IteratorUtil;\n use core::hash;\n use core::hashmap::{HashMap, HashSet};\n use core::int;\n@@ -1275,7 +1276,7 @@ pub fn trans_block_cleanups_(bcx: block,\n         bcx.ccx().sess.opts.debugging_opts & session::no_landing_pads != 0;\n     if bcx.unreachable && !no_lpads { return bcx; }\n     let mut bcx = bcx;\n-    for cleanups.each_reverse |cu| {\n+    for cleanups.rev_iter().advance |cu| {\n         match *cu {\n             clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) => {\n                 // Some types don't need to be cleaned up during"}, {"sha": "d59635ccd762fe16b214180bdfc2d282e623fd58", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -17,9 +17,9 @@ use middle::trans::cabi::{ABIInfo, FnType, LLVMType};\n use middle::trans::common::{T_i8, T_i16, T_i32, T_i64};\n use middle::trans::common::{T_array, T_ptr, T_void};\n \n+use core::iterator::IteratorUtil;\n use core::option::{Option, None, Some};\n use core::uint;\n-use core::vec;\n \n fn align_up_to(off: uint, a: uint) -> uint {\n     return (off + a - 1u) / a * a;\n@@ -43,9 +43,8 @@ fn ty_align(ty: TypeRef) -> uint {\n                 if llvm::LLVMIsPackedStruct(ty) == True {\n                     1\n                 } else {\n-                    do vec::foldl(1, struct_tys(ty)) |a, t| {\n-                        uint::max(a, ty_align(*t))\n-                    }\n+                    let str_tys = struct_tys(ty);\n+                    str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n                 }\n             }\n             Array => {\n@@ -68,13 +67,11 @@ fn ty_size(ty: TypeRef) -> uint {\n             Double => 8,\n             Struct => {\n                 if llvm::LLVMIsPackedStruct(ty) == True {\n-                    do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                        s + ty_size(*t)\n-                    }\n+                    let str_tys = struct_tys(ty);\n+                    str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n                 } else {\n-                    let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                        align(s, *t) + ty_size(*t)\n-                    };\n+                    let str_tys = struct_tys(ty);\n+                    let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n                     align(size, ty)\n                 }\n             }"}, {"sha": "5ef5c4c35b1036fe523534b8615d70bb6573f2c7", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::libc::c_uint;\n use core::ptr;\n use core::uint;\n@@ -56,9 +57,8 @@ fn ty_align(ty: TypeRef) -> uint {\n               if llvm::LLVMIsPackedStruct(ty) == True {\n                 1\n               } else {\n-                do vec::foldl(1, struct_tys(ty)) |a, t| {\n-                    uint::max(a, ty_align(*t))\n-                }\n+                let str_tys = struct_tys(ty);\n+                str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n               }\n             }\n             Array => {\n@@ -81,13 +81,11 @@ fn ty_size(ty: TypeRef) -> uint {\n             Double => 8,\n             Struct => {\n                 if llvm::LLVMIsPackedStruct(ty) == True {\n-                    do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                        s + ty_size(*t)\n-                    }\n+                    let str_tys = struct_tys(ty);\n+                    str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n                 } else {\n-                    let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                        align(s, *t) + ty_size(*t)\n-                    };\n+                    let str_tys = struct_tys(ty);\n+                    let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n                     align(size, ty)\n                 }\n             }"}, {"sha": "eb2d7e619eb75cab50849883fe787d448eaffb06", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -19,6 +19,7 @@ use lib::llvm::True;\n use middle::trans::common::*;\n use middle::trans::cabi::*;\n \n+use core::iterator::IteratorUtil;\n use core::libc::c_uint;\n use core::option;\n use core::option::Option;\n@@ -80,9 +81,8 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n                   if llvm::LLVMIsPackedStruct(ty) == True {\n                     1\n                   } else {\n-                    do vec::foldl(1, struct_tys(ty)) |a, t| {\n-                      uint::max(a, ty_align(*t))\n-                    }\n+                    let str_tys = struct_tys(ty);\n+                    str_tys.iter().fold(1, |a, t| uint::max(a, ty_align(*t)))\n                   }\n                 }\n                 Array => {\n@@ -104,16 +104,14 @@ fn classify_ty(ty: TypeRef) -> ~[x86_64_reg_class] {\n                 Float => 4,\n                 Double => 8,\n                 Struct => {\n-                  if llvm::LLVMIsPackedStruct(ty) == True {\n-                    do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                      s + ty_size(*t)\n+                    if llvm::LLVMIsPackedStruct(ty) == True {\n+                        let str_tys = struct_tys(ty);\n+                        str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n+                    } else {\n+                        let str_tys = struct_tys(ty);\n+                        let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n+                        align(size, ty)\n                     }\n-                  } else {\n-                    let size = do vec::foldl(0, struct_tys(ty)) |s, t| {\n-                      align(s, *t) + ty_size(*t)\n-                    };\n-                    align(size, ty)\n-                  }\n                 }\n                 Array => {\n                   let len = llvm::LLVMGetArrayLength(ty) as uint;"}, {"sha": "df5000a543cb8878072f4800c373a71ee2958b82", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -53,7 +53,6 @@ use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt};\n use syntax::codemap::span;\n use syntax::parse::token;\n-use syntax::parse::token::ident_interner;\n use syntax::{ast, ast_map};\n use syntax::abi::{X86, X86_64, Arm, Mips};\n "}, {"sha": "5f475f1bb9d822ab197d06703314332d3f2e9374", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -29,7 +29,6 @@ use core::str;\n use core::sys;\n use core::vec;\n use syntax::codemap::span;\n-use syntax::parse::token::ident_interner;\n use syntax::{ast, codemap, ast_util, ast_map};\n \n static LLVMDebugVersion: int = (9 << 16);"}, {"sha": "169cd294b43c4324d837e0d7b889c74942f22cd7", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -32,6 +32,7 @@ use middle::ty::{FnSig};\n use middle::typeck;\n use util::ppaux::{Repr,ty_to_str};\n \n+use core::iterator::IteratorUtil;\n use core::vec;\n use syntax::ast;\n use syntax::ast_map;\n@@ -75,7 +76,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let param_uses = type_use::type_uses_for(ccx, fn_id, substs.len());\n     let hash_id = make_mono_id(ccx, fn_id, substs, vtables, impl_did_opt,\n                                Some(param_uses));\n-    if vec::any(hash_id.params,\n+    if hash_id.params.iter().any(\n                 |p| match *p { mono_precise(_, _) => false, _ => true }) {\n         must_cast = true;\n     }"}, {"sha": "e8501904c6f25549d278cda4b04f7005c015eba3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -27,6 +27,7 @@ use util::ppaux::{Repr, UserString};\n use util::common::{indenter};\n use util::enum_set::{EnumSet, CLike};\n \n+use core::iterator::IteratorUtil;\n use core::cast;\n use core::cmp;\n use core::hashmap::{HashMap, HashSet};\n@@ -2355,8 +2356,8 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n \n           ty_struct(did, ref substs) => {\n               seen.push(did);\n-              let r = vec::any(struct_fields(cx, did, substs),\n-                               |f| type_requires(cx, seen, r_ty, f.mt.ty));\n+              let fields = struct_fields(cx, did, substs);\n+              let r = fields.iter().any(|f| type_requires(cx, seen, r_ty, f.mt.ty));\n               seen.pop();\n             r\n           }\n@@ -2372,12 +2373,12 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_enum(did, ref substs) => {\n                 seen.push(did);\n                 let vs = enum_variants(cx, did);\n-                let r = vec::len(*vs) > 0u && vec::all(*vs, |variant| {\n-                    vec::any(variant.args, |aty| {\n+                let r = vec::len(*vs) > 0u && do vs.iter().all |variant| {\n+                    do variant.args.iter().any |aty| {\n                         let sty = subst(cx, substs, *aty);\n                         type_requires(cx, seen, r_ty, sty)\n-                    })\n-                });\n+                    }\n+                };\n                 seen.pop();\n                 r\n             }\n@@ -2519,11 +2520,12 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_param(_) => result = false,\n       ty_opaque_closure_ptr(_) => result = true,\n       ty_struct(did, ref substs) => {\n-        result = vec::all(lookup_struct_fields(cx, did), |f| {\n+        let fields = lookup_struct_fields(cx, did);\n+        result = do fields.iter().all |f| {\n             let fty = ty::lookup_item_type(cx, f.id);\n             let sty = subst(cx, substs, fty.ty);\n             type_is_pod(cx, sty)\n-        });\n+        };\n       }\n \n       ty_estr(vstore_slice(*)) | ty_evec(_, vstore_slice(*)) => {\n@@ -2569,7 +2571,7 @@ pub fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n             if variants.len() == 0 {\n                 false\n             } else {\n-                variants.all(|v| v.args.len() == 0)\n+                variants.iter().all(|v| v.args.len() == 0)\n             }\n         }\n         _ => false"}, {"sha": "9eb5f8159545efc270fa7bef855a5f920cc4c2c0", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -3065,7 +3065,7 @@ pub fn check_simd(tcx: ty::ctxt, sp: span, id: ast::node_id) {\n                 return;\n             }\n             let e = ty::lookup_field_type(tcx, did, fields[0].id, substs);\n-            if !vec::all(fields,\n+            if !fields.iter().all(\n                          |f| ty::lookup_field_type(tcx, did, f.id, substs) == e) {\n                 tcx.sess.span_err(sp, \"SIMD vector should be homogeneous\");\n                 return;"}, {"sha": "0d26e4c6ef1e608569470ce2de94b89485ae4257", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -36,8 +36,6 @@ extern mod std(name = \"std\", vers = \"0.7-pre\");\n \n // For bootstrapping purposes.\n #[cfg(stage0)]\n-pub use core::str;\n-#[cfg(stage0)]\n pub use core::unstable;\n \n use core::prelude::*;"}, {"sha": "24ade927be247099ee6bded303be92becae14346", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -24,9 +24,9 @@ use fold::Fold;\n use fold;\n use pass::Pass;\n \n+use core::iterator::IteratorUtil;\n use core::str;\n use core::util;\n-use core::vec;\n \n pub fn mk_pass() -> Pass {\n     Pass {\n@@ -150,7 +150,7 @@ pub fn paragraphs(s: &str) -> ~[~str] {\n     for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n     let mut whitespace_lines = 0;\n     let mut accum = ~\"\";\n-    let paras = do vec::foldl(~[], lines) |paras, line| {\n+    let paras = do lines.iter().fold(~[]) |paras, line| {\n         let mut res = paras;\n \n         if str::is_whitespace(*line) {"}, {"sha": "2f00cd0bbcefb3ce93e2cc2a34a462f2dd245900", "filename": "src/librustdoc/doc.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustdoc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustdoc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoc.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -14,6 +14,7 @@ use core::prelude::*;\n \n use doc;\n \n+use core::iterator::IteratorUtil;\n use core::vec;\n \n pub type AstId = int;\n@@ -174,7 +175,7 @@ pub struct IndexEntry {\n \n impl Doc {\n     pub fn CrateDoc(&self) -> CrateDoc {\n-        vec::foldl(None, self.pages, |_m, page| {\n+        self.pages.iter().fold(None, |_m, page| {\n             match copy *page {\n               doc::CratePage(doc) => Some(doc),\n               _ => None"}, {"sha": "31adb0f3b8d27144b597b6cbf02c15bde539d561", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -10,7 +10,7 @@\n \n use core::prelude::*;\n \n-use core::vec;\n+use core::iterator::IteratorUtil;\n \n use astsrv;\n use doc;\n@@ -30,7 +30,7 @@ pub fn run_passes(\n     passes: ~[Pass]\n ) -> doc::Doc {\n     let mut passno = 0;\n-    do vec::foldl(doc, passes) |doc, pass| {\n+    do passes.iter().fold(doc) |doc, pass| {\n         debug!(\"pass #%d\", passno);\n         passno += 1;\n         do time(copy pass.name) {"}, {"sha": "b6753f385dfc1944540612a836065ebb8025352d", "filename": "src/librustdoc/unindent_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibrustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Funindent_pass.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -21,9 +21,9 @@ middle of a line, and each of the following lines is indented.\n \n use core::prelude::*;\n \n+use core::iterator::IteratorUtil;\n use core::str;\n use core::uint;\n-use core::vec;\n use pass::Pass;\n use text_pass;\n \n@@ -36,7 +36,7 @@ fn unindent(s: &str) -> ~str {\n     for str::each_line_any(s) |line| { lines.push(line.to_owned()); }\n     let mut saw_first_line = false;\n     let mut saw_second_line = false;\n-    let min_indent = do vec::foldl(uint::max_value, lines)\n+    let min_indent = do lines.iter().fold(uint::max_value)\n         |min_indent, line| {\n \n         // After we see the first non-whitespace line, look at"}, {"sha": "a118e445fe20544f76a581f9f1919e029117fb60", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -286,8 +286,6 @@ pub mod raw {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use prelude::*;\n-\n     use uint;\n \n     #[test]"}, {"sha": "4886588bb9422af6f95ab79ecf0ab84e1a951fb1", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -42,7 +42,6 @@ much easier to implement.\n \n use cmp::Ord;\n use option::{Option, Some, None};\n-use vec::OwnedVector;\n use num::{One, Zero};\n use ops::{Add, Mul};\n "}, {"sha": "8803844fdd01107ae92e104f8ce3fb7c2cabad32", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -18,7 +18,6 @@ implementing the `Iterator` trait.\n */\n \n use cmp;\n-use iter;\n use iter::{FromIter, Times};\n use num::{Zero, One};\n use option::{Option, Some, None};\n@@ -326,7 +325,7 @@ pub trait IteratorUtil<A> {\n     /// assert!(a.iter().all(|&x| *x > 0));\n     /// assert!(!a.iter().all(|&x| *x > 2));\n     /// ~~~\n-    fn all(&mut self, f: &fn(&A) -> bool) -> bool;\n+    fn all(&mut self, f: &fn(A) -> bool) -> bool;\n \n     /// Tests whether any element of an iterator satisfies the specified\n     /// predicate.\n@@ -341,7 +340,7 @@ pub trait IteratorUtil<A> {\n     /// assert!(it.any(|&x| *x == 3));\n     /// assert!(!it.any(|&x| *x == 3));\n     /// ~~~\n-    fn any(&mut self, f: &fn(&A) -> bool) -> bool;\n+    fn any(&mut self, f: &fn(A) -> bool) -> bool;\n }\n \n /// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n@@ -462,14 +461,14 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     fn count(&mut self) -> uint { self.fold(0, |cnt, _x| cnt + 1) }\n \n     #[inline(always)]\n-    fn all(&mut self, f: &fn(&A) -> bool) -> bool {\n-        for self.advance |x| { if !f(&x) { return false; } }\n+    fn all(&mut self, f: &fn(A) -> bool) -> bool {\n+        for self.advance |x| { if !f(x) { return false; } }\n         return true;\n     }\n \n     #[inline(always)]\n-    fn any(&mut self, f: &fn(&A) -> bool) -> bool {\n-        for self.advance |x| { if f(&x) { return true; } }\n+    fn any(&mut self, f: &fn(A) -> bool) -> bool {\n+        for self.advance |x| { if f(x) { return true; } }\n         return false;\n     }\n }\n@@ -1080,18 +1079,18 @@ mod tests {\n     #[test]\n     fn test_all() {\n         let v = ~&[1, 2, 3, 4, 5];\n-        assert!(v.iter().all(|&x| *x < 10));\n+        assert!(v.iter().all(|&x| x < 10));\n         assert!(!v.iter().all(|&x| x.is_even()));\n-        assert!(!v.iter().all(|&x| *x > 100));\n+        assert!(!v.iter().all(|&x| x > 100));\n         assert!(v.slice(0, 0).iter().all(|_| fail!()));\n     }\n \n     #[test]\n     fn test_any() {\n         let v = ~&[1, 2, 3, 4, 5];\n-        assert!(v.iter().any(|&x| *x < 10));\n+        assert!(v.iter().any(|&x| x < 10));\n         assert!(v.iter().any(|&x| x.is_even()));\n-        assert!(!v.iter().any(|&x| *x > 100));\n+        assert!(!v.iter().any(|&x| x > 100));\n         assert!(!v.slice(0, 0).iter().any(|_| fail!()));\n     }\n }"}, {"sha": "e2cbf716dd1f61570900c9eebac31acd203079f4", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -11,8 +11,6 @@\n //! Unsafe pointer utility functions\n \n use cast;\n-#[cfg(stage0)] use libc;\n-#[cfg(stage0)] use libc::{c_void, size_t};\n use option::{Option, Some, None};\n use sys;\n use unstable::intrinsics;"}, {"sha": "7946f7e4f13f6b1cc9c5a4f01b54cf34b8506529", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -43,6 +43,7 @@ fn main () {\n use cast;\n use cmp;\n use int;\n+use iterator::IteratorUtil;\n use local_data;\n use prelude::*;\n use str;\n@@ -479,7 +480,7 @@ impl<R: Rng> RngUtil for R {\n     fn gen_char_from(&mut self, chars: &str) -> char {\n         assert!(!chars.is_empty());\n         let mut cs = ~[];\n-        for str::each_char(chars) |c| { cs.push(c) }\n+        for chars.iter().advance |c| { cs.push(c) }\n         self.choose(cs)\n     }\n "}, {"sha": "46f69d020d1ec7155bc29040785da0aaae877b45", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -22,6 +22,7 @@ use intrinsic;\n use intrinsic::{TyDesc, TyVisitor, visit_tydesc};\n use intrinsic::Opaque;\n use io::{Writer, WriterUtil};\n+use iterator::IteratorUtil;\n use libc::c_void;\n use managed;\n use ptr;\n@@ -209,7 +210,7 @@ impl ReprVisitor {\n \n     pub fn write_escaped_slice(&self, slice: &str) {\n         self.writer.write_char('\"');\n-        for slice.each_char |ch| {\n+        for slice.iter().advance |ch| {\n             self.writer.write_escaped_char(ch);\n         }\n         self.writer.write_char('\"');"}, {"sha": "f9d1116499586f3cd2a4fef850cd702250161b1c", "filename": "src/libstd/str.rs", "status": "modified", "additions": 139, "deletions": 299, "changes": 438, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -25,7 +25,7 @@ use clone::Clone;\n use cmp::{TotalOrd, Ordering, Less, Equal, Greater};\n use container::Container;\n use iter::Times;\n-use iterator::Iterator;\n+use iterator::{Iterator, IteratorUtil};\n use libc;\n use option::{None, Option, Some};\n use old_iter::{BaseIter, EqIter};\n@@ -35,7 +35,7 @@ use str;\n use to_str::ToStr;\n use uint;\n use vec;\n-use vec::{OwnedVector, OwnedCopyableVector};\n+use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector};\n \n #[cfg(not(test))] use cmp::{Eq, Ord, Equiv, TotalEq};\n \n@@ -608,11 +608,7 @@ pub fn byte_slice_no_callback<'a>(s: &'a str) -> &'a [u8] {\n \n /// Convert a string to a unique vector of characters\n pub fn to_chars(s: &str) -> ~[char] {\n-    let mut buf = ~[];\n-    for each_char(s) |c| {\n-        buf.push(c);\n-    }\n-    buf\n+    s.iter().collect()\n }\n \n /**\n@@ -856,12 +852,12 @@ pub fn levdistance(s: &str, t: &str) -> uint {\n \n     let mut dcol = vec::from_fn(tlen + 1, |x| x);\n \n-    for s.each_chari |i, sc| {\n+    for s.iter().enumerate().advance |(i, sc)| {\n \n         let mut current = i;\n         dcol[0] = current + 1;\n \n-        for t.each_chari |j, tc| {\n+        for t.iter().enumerate().advance |(j, tc)| {\n \n             let next = dcol[j + 1];\n \n@@ -943,7 +939,7 @@ pub fn each_split_within<'a>(ss: &'a str,\n     let mut cont = true;\n     let slice: &fn() = || { cont = it(slice(ss, slice_start, last_end)) };\n \n-    let machine: &fn(uint, char) -> bool = |i, c| {\n+    let machine: &fn((uint, char)) -> bool = |(i, c)| {\n         let whitespace = if char::is_whitespace(c)       { Ws }       else { Cr };\n         let limit      = if (i - slice_start + 1) <= lim { UnderLim } else { OverLim };\n \n@@ -968,12 +964,12 @@ pub fn each_split_within<'a>(ss: &'a str,\n         cont\n     };\n \n-    str::each_chari(ss, machine);\n+    ss.iter().enumerate().advance(machine);\n \n     // Let the automaton 'run out' by supplying trailing whitespace\n     let mut fake_i = ss.len();\n     while cont && match state { B | C => true, A => false } {\n-        machine(fake_i, ' ');\n+        machine((fake_i, ' '));\n         fake_i += 1;\n     }\n     return cont;\n@@ -1247,97 +1243,12 @@ pub fn any(ss: &str, pred: &fn(char) -> bool) -> bool {\n pub fn map(ss: &str, ff: &fn(char) -> char) -> ~str {\n     let mut result = ~\"\";\n     reserve(&mut result, len(ss));\n-    for ss.each_char |cc| {\n+    for ss.iter().advance |cc| {\n         str::push_char(&mut result, ff(cc));\n     }\n     result\n }\n \n-/// Iterate over the bytes in a string\n-#[inline(always)]\n-pub fn each(s: &str, it: &fn(u8) -> bool) -> bool {\n-    eachi(s, |_i, b| it(b))\n-}\n-\n-/// Iterate over the bytes in a string, with indices\n-#[inline(always)]\n-pub fn eachi(s: &str, it: &fn(uint, u8) -> bool) -> bool {\n-    let mut pos = 0;\n-    let len = s.len();\n-\n-    while pos < len {\n-        if !it(pos, s[pos]) { return false; }\n-        pos += 1;\n-    }\n-    return true;\n-}\n-\n-/// Iterate over the bytes in a string in reverse\n-#[inline(always)]\n-pub fn each_reverse(s: &str, it: &fn(u8) -> bool) -> bool {\n-    eachi_reverse(s, |_i, b| it(b) )\n-}\n-\n-/// Iterate over the bytes in a string in reverse, with indices\n-#[inline(always)]\n-pub fn eachi_reverse(s: &str, it: &fn(uint, u8) -> bool) -> bool {\n-    let mut pos = s.len();\n-    while pos > 0 {\n-        pos -= 1;\n-        if !it(pos, s[pos]) { return false; }\n-    }\n-    return true;\n-}\n-\n-/// Iterate over each char of a string, without allocating\n-#[inline(always)]\n-pub fn each_char(s: &str, it: &fn(char) -> bool) -> bool {\n-    let mut i = 0;\n-    let len = len(s);\n-    while i < len {\n-        let CharRange {ch, next} = char_range_at(s, i);\n-        if !it(ch) { return false; }\n-        i = next;\n-    }\n-    return true;\n-}\n-\n-/// Iterates over the chars in a string, with indices\n-#[inline(always)]\n-pub fn each_chari(s: &str, it: &fn(uint, char) -> bool) -> bool {\n-    let mut pos = 0;\n-    let mut ch_pos = 0u;\n-    let len = s.len();\n-    while pos < len {\n-        let CharRange {ch, next} = char_range_at(s, pos);\n-        pos = next;\n-        if !it(ch_pos, ch) { return false; }\n-        ch_pos += 1u;\n-    }\n-    return true;\n-}\n-\n-/// Iterates over the chars in a string in reverse\n-#[inline(always)]\n-pub fn each_char_reverse(s: &str, it: &fn(char) -> bool) -> bool {\n-    each_chari_reverse(s, |_, c| it(c))\n-}\n-\n-/// Iterates over the chars in a string in reverse, with indices\n-#[inline(always)]\n-pub fn each_chari_reverse(s: &str, it: &fn(uint, char) -> bool) -> bool {\n-    let mut pos = s.len();\n-    let mut ch_pos = s.char_len();\n-    while pos > 0 {\n-        let CharRange {ch, next} = char_range_at_reverse(s, pos);\n-        pos = next;\n-        ch_pos -= 1;\n-\n-        if !it(ch_pos, ch) { return false; }\n-    }\n-    return true;\n-}\n-\n /*\n Section: Searching\n */\n@@ -1657,7 +1568,7 @@ pub fn rfind_between(s: &str, start: uint, end: uint, f: &fn(char) -> bool) -> O\n // Utility used by various searching functions\n fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n     let mut i = at;\n-    for each(needle) |c| { if haystack[i] != c { return false; } i += 1u; }\n+    for needle.bytes_iter().advance |c| { if haystack[i] != c { return false; } i += 1u; }\n     return true;\n }\n \n@@ -1880,7 +1791,7 @@ pub fn is_utf16(v: &[u16]) -> bool {\n /// Converts to a vector of `u16` encoded as UTF-16\n pub fn to_utf16(s: &str) -> ~[u16] {\n     let mut u = ~[];\n-    for s.each_char |ch| {\n+    for s.iter().advance |ch| {\n         // Arithmetic with u32 literals is easier on the eyes than chars.\n         let mut ch = ch as u32;\n \n@@ -2396,7 +2307,7 @@ pub fn capacity(s: &const ~str) -> uint {\n pub fn escape_default(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     reserve_at_least(&mut out, str::len(s));\n-    for s.each_char |c| {\n+    for s.iter().advance |c| {\n         push_str(&mut out, char::escape_default(c));\n     }\n     out\n@@ -2406,7 +2317,7 @@ pub fn escape_default(s: &str) -> ~str {\n pub fn escape_unicode(s: &str) -> ~str {\n     let mut out: ~str = ~\"\";\n     reserve_at_least(&mut out, str::len(s));\n-    for s.each_char |c| {\n+    for s.iter().advance |c| {\n         push_str(&mut out, char::escape_unicode(c));\n     }\n     out\n@@ -2608,15 +2519,10 @@ pub trait StrSlice<'self> {\n     fn any(&self, it: &fn(char) -> bool) -> bool;\n     fn contains<'a>(&self, needle: &'a str) -> bool;\n     fn contains_char(&self, needle: char) -> bool;\n-    fn char_iter(&self) -> StrCharIterator<'self>;\n-    fn each(&self, it: &fn(u8) -> bool) -> bool;\n-    fn eachi(&self, it: &fn(uint, u8) -> bool) -> bool;\n-    fn each_reverse(&self, it: &fn(u8) -> bool) -> bool;\n-    fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) -> bool;\n-    fn each_char(&self, it: &fn(char) -> bool) -> bool;\n-    fn each_chari(&self, it: &fn(uint, char) -> bool) -> bool;\n-    fn each_char_reverse(&self, it: &fn(char) -> bool) -> bool;\n-    fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) -> bool;\n+    fn iter(&self) -> StrCharIterator<'self>;\n+    fn rev_iter(&self) -> StrCharRevIterator<'self>;\n+    fn bytes_iter(&self) -> StrBytesIterator<'self>;\n+    fn bytes_rev_iter(&self) -> StrBytesRevIterator<'self>;\n     fn ends_with(&self, needle: &str) -> bool;\n     fn is_empty(&self) -> bool;\n     fn is_whitespace(&self) -> bool;\n@@ -2670,46 +2576,28 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn char_iter(&self) -> StrCharIterator<'self> {\n+    fn iter(&self) -> StrCharIterator<'self> {\n         StrCharIterator {\n             index: 0,\n             string: *self\n         }\n     }\n-\n-    /// Iterate over the bytes in a string\n-    #[inline]\n-    fn each(&self, it: &fn(u8) -> bool) -> bool { each(*self, it) }\n-    /// Iterate over the bytes in a string, with indices\n-    #[inline]\n-    fn eachi(&self, it: &fn(uint, u8) -> bool) -> bool { eachi(*self, it) }\n-    /// Iterate over the bytes in a string\n-    #[inline]\n-    fn each_reverse(&self, it: &fn(u8) -> bool) -> bool { each_reverse(*self, it) }\n-    /// Iterate over the bytes in a string, with indices\n-    #[inline]\n-    fn eachi_reverse(&self, it: &fn(uint, u8) -> bool) -> bool {\n-        eachi_reverse(*self, it)\n-    }\n-    /// Iterate over the chars in a string\n-    #[inline]\n-    fn each_char(&self, it: &fn(char) -> bool) -> bool { each_char(*self, it) }\n-    /// Iterate over the chars in a string, with indices\n     #[inline]\n-    fn each_chari(&self, it: &fn(uint, char) -> bool) -> bool {\n-        each_chari(*self, it)\n+    fn rev_iter(&self) -> StrCharRevIterator<'self> {\n+        StrCharRevIterator {\n+            index: self.len(),\n+            string: *self\n+        }\n     }\n-    /// Iterate over the chars in a string in reverse\n-    #[inline]\n-    fn each_char_reverse(&self, it: &fn(char) -> bool) -> bool {\n-        each_char_reverse(*self, it)\n+\n+    fn bytes_iter(&self) -> StrBytesIterator<'self> {\n+        StrBytesIterator { it: as_bytes_slice(*self).iter() }\n     }\n-    /// Iterate over the chars in a string in reverse, with indices from the\n-    /// end\n-    #[inline]\n-    fn each_chari_reverse(&self, it: &fn(uint, char) -> bool) -> bool {\n-        each_chari_reverse(*self, it)\n+    fn bytes_rev_iter(&self) -> StrBytesRevIterator<'self> {\n+        StrBytesRevIterator { it: as_bytes_slice(*self).rev_iter() }\n     }\n+\n+\n     /// Returns true if one string ends with another\n     #[inline]\n     fn ends_with(&self, needle: &str) -> bool {\n@@ -2880,9 +2768,55 @@ impl<'self> Iterator<char> for StrCharIterator<'self> {\n         }\n     }\n }\n+/// External iterator for a string's characters in reverse order. Use\n+/// with the `std::iterator` module.\n+pub struct StrCharRevIterator<'self> {\n+    priv index: uint,\n+    priv string: &'self str,\n+}\n+\n+impl<'self> Iterator<char> for StrCharRevIterator<'self> {\n+    #[inline]\n+    fn next(&mut self) -> Option<char> {\n+        if self.index > 0 {\n+            let CharRange {ch, next} = char_range_at_reverse(self.string, self.index);\n+            self.index = next;\n+            Some(ch)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// External iterator for a string's bytes. Use with the `std::iterator`\n+/// module.\n+pub struct StrBytesIterator<'self> {\n+    priv it: vec::VecIterator<'self, u8>\n+}\n+\n+impl<'self> Iterator<u8> for StrBytesIterator<'self> {\n+    #[inline]\n+    fn next(&mut self) -> Option<u8> {\n+        self.it.next().map_consume(|&x| x)\n+    }\n+}\n+\n+/// External iterator for a string's bytes in reverse order. Use with\n+/// the `std::iterator` module.\n+pub struct StrBytesRevIterator<'self> {\n+    priv it: vec::VecRevIterator<'self, u8>\n+}\n+\n+impl<'self> Iterator<u8> for StrBytesRevIterator<'self> {\n+    #[inline]\n+    fn next(&mut self) -> Option<u8> {\n+        self.it.next().map_consume(|&x| x)\n+    }\n+}\n \n #[cfg(test)]\n mod tests {\n+    use iterator::IteratorUtil;\n     use container::Container;\n     use char;\n     use option::Some;\n@@ -2977,7 +2911,7 @@ mod tests {\n             let mut v = ~[];\n             for each_split_char(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         t(\"abc.hello.there\", '.', [~\"abc\", ~\"hello\", ~\"there\"]);\n         t(\".hello.there\", '.', [~\"\", ~\"hello\", ~\"there\"]);\n@@ -2995,7 +2929,7 @@ mod tests {\n             let mut v = ~[];\n             for each_split_char(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         t(data, 'V', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n@@ -3010,7 +2944,7 @@ mod tests {\n             for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         t(\"abc.hello.there\", '.', 0u, [~\"abc.hello.there\"]);\n         t(\"abc.hello.there\", '.', 1u, [~\"abc\", ~\"hello.there\"]);\n@@ -3037,7 +2971,7 @@ mod tests {\n             for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n \n         t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", '\u534e', 1u, [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n@@ -3055,7 +2989,7 @@ mod tests {\n             for each_splitn_char(s, c, n) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n             debug!(\"comparing vs. %?\", u);\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         t(data, 'V', 1u, [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n@@ -3069,7 +3003,7 @@ mod tests {\n             let mut v = ~[];\n             for each_split_char_no_trailing(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         t(\"abc.hello.there\", '.', [~\"abc\", ~\"hello\", ~\"there\"]);\n         t(\".hello.there\", '.', [~\"\", ~\"hello\", ~\"there\"]);\n@@ -3088,7 +3022,7 @@ mod tests {\n             let mut v = ~[];\n             for each_split_char_no_trailing(s, c) |s| { v.push(s.to_owned()) }\n             debug!(\"split_byte to: %?\", v);\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         let data = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         t(data, 'V', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", ~\"i\u1ec7t Nam\"]);\n@@ -3100,7 +3034,7 @@ mod tests {\n         fn t<'a>(s: &str, sep: &'a str, u: &[~str]) {\n             let mut v = ~[];\n             for each_split_str(s, sep) |s| { v.push(s.to_owned()) }\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         t(\"--1233345--\", \"12345\", [~\"--1233345--\"]);\n         t(\"abc::hello::there\", \"::\", [~\"abc\", ~\"hello\", ~\"there\"]);\n@@ -3124,7 +3058,7 @@ mod tests {\n         fn t(s: &str, sepf: &fn(char) -> bool, u: &[~str]) {\n             let mut v = ~[];\n             for each_split(s, sepf) |s| { v.push(s.to_owned()) }\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n \n         t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n@@ -3140,7 +3074,7 @@ mod tests {\n         fn t(s: &str, sepf: &fn(char) -> bool, u: &[~str]) {\n             let mut v = ~[];\n             for each_split_no_trailing(s, sepf) |s| { v.push(s.to_owned()) }\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n \n         t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", |cc| cc == '\u534e', [~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", ~\"Vi\u1ec7t Nam\"]);\n@@ -3159,7 +3093,7 @@ mod tests {\n         fn t(s: &str, f: &fn(&str, &fn(&str) -> bool) -> bool, u: &[~str]) {\n             let mut v = ~[];\n             for f(s) |s| { v.push(s.to_owned()) }\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n \n         t(lf, each_line, [~\"\", ~\"Mary had a little lamb\", ~\"Little lamb\"]);\n@@ -3179,7 +3113,7 @@ mod tests {\n         fn t(s: &str, f: &fn(&str, &fn(&str) -> bool) -> bool, u: &[~str]) {\n             let mut v = ~[];\n             for f(s) |s| { v.push(s.to_owned()) }\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         let data = \"\\nMary had a little lamb\\nLittle lamb\\n\";\n \n@@ -3193,7 +3127,7 @@ mod tests {\n         fn t(s: &str, i: uint, u: &[~str]) {\n             let mut v = ~[];\n             for each_split_within(s, i) |s| { v.push(s.to_owned()) }\n-            assert!(vec::all2(v, u, |a,b| a == b));\n+            assert!(v.iter().zip(u.iter()).all(|(a,b)| a == b));\n         }\n         t(\"\", 0, []);\n         t(\"\", 15, []);\n@@ -3964,154 +3898,12 @@ mod tests {\n         let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = s.len();\n-        for v.each_reverse |ch| {\n+        for v.rev_iter().advance |ch| {\n             assert!(s.char_at_reverse(pos) == *ch);\n             pos -= from_char(*ch).len();\n         }\n     }\n \n-    #[test]\n-    fn test_each() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = [\n-            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-            109\n-        ];\n-        let mut pos = 0;\n-\n-        for s.each |b| {\n-            assert_eq!(b, v[pos]);\n-            pos += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_each_empty() {\n-        for \"\".each |b| {\n-            assert_eq!(b, 0u8);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_eachi() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = [\n-            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-            109\n-        ];\n-        let mut pos = 0;\n-\n-        for s.eachi |i, b| {\n-            assert_eq!(pos, i);\n-            assert_eq!(b, v[pos]);\n-            pos += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_eachi_empty() {\n-        for \"\".eachi |i, b| {\n-            assert_eq!(i, 0);\n-            assert_eq!(b, 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_each_reverse() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = [\n-            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-            109\n-        ];\n-        let mut pos = v.len();\n-\n-        for s.each_reverse |b| {\n-            pos -= 1;\n-            assert_eq!(b, v[pos]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_each_empty_reverse() {\n-        for \"\".each_reverse |b| {\n-            assert_eq!(b, 0u8);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_eachi_reverse() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = [\n-            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-            109\n-        ];\n-        let mut pos = v.len();\n-\n-        for s.eachi_reverse |i, b| {\n-            pos -= 1;\n-            assert_eq!(pos, i);\n-            assert_eq!(b, v[pos]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_eachi_reverse_empty() {\n-        for \"\".eachi_reverse |i, b| {\n-            assert_eq!(i, 0);\n-            assert_eq!(b, 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_each_char() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n-        let mut pos = 0;\n-        for s.each_char |ch| {\n-            assert_eq!(ch, v[pos]);\n-            pos += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_each_chari() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n-        let mut pos = 0;\n-        for s.each_chari |i, ch| {\n-            assert_eq!(pos, i);\n-            assert_eq!(ch, v[pos]);\n-            pos += 1;\n-        }\n-    }\n-\n-    #[test]\n-    fn test_each_char_reverse() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n-        let mut pos = v.len();\n-        for s.each_char_reverse |ch| {\n-            pos -= 1;\n-            assert_eq!(ch, v[pos]);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_each_chari_reverse() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n-        let mut pos = v.len();\n-        for s.each_chari_reverse |i, ch| {\n-            pos -= 1;\n-            assert_eq!(pos, i);\n-            assert_eq!(ch, v[pos]);\n-        }\n-    }\n-\n     #[test]\n     fn test_escape_unicode() {\n         assert_eq!(escape_unicode(\"abc\"), ~\"\\\\x61\\\\x62\\\\x63\");\n@@ -4167,12 +3959,60 @@ mod tests {\n         let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n \n         let mut pos = 0;\n-        let mut it = s.char_iter();\n+        let mut it = s.iter();\n+\n+        for it.advance |c| {\n+            assert_eq!(c, v[pos]);\n+            pos += 1;\n+        }\n+        assert_eq!(pos, v.len());\n+    }\n+\n+    #[test]\n+    fn test_rev_iterator() {\n+        use iterator::*;\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = ~['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n+\n+        let mut pos = 0;\n+        let mut it = s.rev_iter();\n \n         for it.advance |c| {\n             assert_eq!(c, v[pos]);\n             pos += 1;\n         }\n         assert_eq!(pos, v.len());\n     }\n+\n+    #[test]\n+    fn test_bytes_iterator() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = [\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109\n+        ];\n+        let mut pos = 0;\n+\n+        for s.bytes_iter().advance |b| {\n+            assert_eq!(b, v[pos]);\n+            pos += 1;\n+        }\n+    }\n+\n+    #[test]\n+    fn test_bytes_rev_iterator() {\n+        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n+        let v = [\n+            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n+            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n+            109\n+        ];\n+        let mut pos = v.len();\n+\n+        for s.bytes_rev_iter().advance |b| {\n+            pos -= 1;\n+            assert_eq!(b, v[pos]);\n+        }\n+    }\n }"}, {"sha": "e288d605714f4be6efb960c7ea027bb3b41993c3", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -15,6 +15,7 @@ use str;\n use str::StrSlice;\n use cast;\n use old_iter::BaseIter;\n+use iterator::IteratorUtil;\n use vec::{CopyableVector, ImmutableVector, OwnedVector};\n \n /// Datatype to hold one ascii character. It is 8 bit long.\n@@ -101,10 +102,7 @@ impl<'self> AsciiCast<&'self[Ascii]> for &'self str {\n \n     #[inline(always)]\n     fn is_ascii(&self) -> bool {\n-        for self.each |b| {\n-            if !b.is_ascii() { return false; }\n-        }\n-        true\n+        self.bytes_iter().all(|b| b.is_ascii())\n     }\n }\n "}, {"sha": "87e13e494aa4ba0fe37174804bb6afcab039e562", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -14,7 +14,6 @@\n \n use option::{Some, None};\n use cast;\n-use cmp::{Eq, Ord};\n use gc;\n use io;\n use libc;"}, {"sha": "4bd3946f885fd6b5924031cab5d5ab73525076c2", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -14,7 +14,6 @@ use prelude::*;\n use iterator::IteratorUtil;\n use uint;\n use util::{swap, replace};\n-use vec;\n \n // FIXME: #5244: need to manually update the TrieNode constructor\n static SHIFT: uint = 4;"}, {"sha": "cd3e0cf303e1dd41fbc1d1f0c246e03ee9b08948", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -10,6 +10,7 @@\n \n //! Runtime calls emitted by the compiler.\n \n+use iterator::IteratorUtil;\n use uint;\n use cast::transmute;\n use libc::{c_char, c_uchar, c_void, size_t, uintptr_t, c_int, STDERR_FILENO};\n@@ -133,7 +134,7 @@ unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n         Some(borrow_list) => { // recording borrows\n             let mut msg = ~\"borrowed\";\n             let mut sep = \" at \";\n-            for borrow_list.each_reverse |entry| {\n+            for borrow_list.rev_iter().advance |entry| {\n                 if entry.box == box {\n                     str::push_str(&mut msg, sep);\n                     let filename = str::raw::from_c_str(entry.file);"}, {"sha": "6137b589bdbae611d2324ad46775c741e46d5406", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 98, "deletions": 425, "changes": 523, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -1066,138 +1066,12 @@ impl<'self, T:Copy> VectorVector<T> for &'self [&'self [T]] {\n     }\n }\n \n-/**\n- * Reduces a vector from left to right.\n- *\n- * # Arguments\n- * * `z` - initial accumulator value\n- * * `v` - vector to iterate over\n- * * `p` - a closure to operate on vector elements\n- *\n- * # Examples\n- *\n- * Sum all values in the vector [1, 2, 3]:\n- *\n- * ~~~ {.rust}\n- * vec::foldl(0, [1, 2, 3], |a, b| a + *b);\n- * ~~~\n- *\n- */\n-pub fn foldl<'a, T, U>(z: T, v: &'a [U], p: &fn(t: T, u: &'a U) -> T) -> T {\n-    let mut accum = z;\n-    let mut i = 0;\n-    let l = v.len();\n-    while i < l {\n-        // Use a while loop so that liveness analysis can handle moving\n-        // the accumulator.\n-        accum = p(accum, &v[i]);\n-        i += 1;\n-    }\n-    accum\n-}\n-\n-/**\n- * Reduces a vector from right to left. Note that the argument order is\n- * reversed compared to `foldl` to reflect the order they are provided to\n- * the closure.\n- *\n- * # Arguments\n- * * `v` - vector to iterate over\n- * * `z` - initial accumulator value\n- * * `p` - a closure to do operate on vector elements\n- *\n- * # Examples\n- *\n- * Sum all values in the vector [1, 2, 3]:\n- *\n- * ~~~ {.rust}\n- * vec::foldr([1, 2, 3], 0, |a, b| a + *b);\n- * ~~~\n- *\n- */\n-pub fn foldr<'a, T, U>(v: &'a [T], mut z: U, p: &fn(t: &'a T, u: U) -> U) -> U {\n-    let mut i = v.len();\n-    while i > 0 {\n-        i -= 1;\n-        z = p(&v[i], z);\n-    }\n-    return z;\n-}\n-\n-/**\n- * Return true if a predicate matches any elements\n- *\n- * If the vector contains no elements then false is returned.\n- */\n-pub fn any<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n-    for each(v) |elem| { if f(elem) { return true; } }\n-    false\n-}\n-\n-/**\n- * Return true if a predicate matches any elements in both vectors.\n- *\n- * If the vectors contains no elements then false is returned.\n- */\n-pub fn any2<T, U>(v0: &[T], v1: &[U],\n-                   f: &fn(a: &T, b: &U) -> bool) -> bool {\n-    let v0_len = len(v0);\n-    let v1_len = len(v1);\n-    let mut i = 0u;\n-    while i < v0_len && i < v1_len {\n-        if f(&v0[i], &v1[i]) { return true; };\n-        i += 1u;\n-    }\n-    false\n-}\n-\n-/**\n- * Return true if a predicate matches all elements\n- *\n- * If the vector contains no elements then true is returned.\n- */\n-pub fn all<T>(v: &[T], f: &fn(t: &T) -> bool) -> bool {\n-    for each(v) |elem| { if !f(elem) { return false; } }\n-    true\n-}\n-\n-/**\n- * Return true if a predicate matches all elements\n- *\n- * If the vector contains no elements then true is returned.\n- */\n-pub fn alli<T>(v: &[T], f: &fn(uint, t: &T) -> bool) -> bool {\n-    for eachi(v) |i, elem| { if !f(i, elem) { return false; } }\n-    true\n-}\n-\n-/**\n- * Return true if a predicate matches all elements in both vectors.\n- *\n- * If the vectors are not the same size then false is returned.\n- */\n-pub fn all2<T, U>(v0: &[T], v1: &[U],\n-                   f: &fn(t: &T, u: &U) -> bool) -> bool {\n-    let v0_len = len(v0);\n-    if v0_len != len(v1) { return false; }\n-    let mut i = 0u;\n-    while i < v0_len { if !f(&v0[i], &v1[i]) { return false; }; i += 1u; }\n-    true\n-}\n-\n /// Return true if a vector contains an element with the given value\n pub fn contains<T:Eq>(v: &[T], x: &T) -> bool {\n     for each(v) |elt| { if *x == *elt { return true; } }\n     false\n }\n \n-/// Returns the number of elements that are equal to a given value\n-pub fn count<T:Eq>(v: &[T], x: &T) -> uint {\n-    let mut cnt = 0u;\n-    for each(v) |elt| { if *x == *elt { cnt += 1u; } }\n-    cnt\n-}\n-\n /**\n  * Search for the first element that matches a given predicate\n  *\n@@ -1598,34 +1472,6 @@ pub fn eachi<'r,T>(v: &'r [T], f: &fn(uint, v: &'r T) -> bool) -> bool {\n     return true;\n }\n \n-/**\n- * Iterates over a vector's elements in reverse\n- *\n- * Return true to continue, false to break.\n- */\n-#[inline(always)]\n-pub fn each_reverse<'r,T>(v: &'r [T], blk: &fn(v: &'r T) -> bool) -> bool {\n-    eachi_reverse(v, |_i, v| blk(v))\n-}\n-\n-/**\n- * Iterates over a vector's elements and indices in reverse\n- *\n- * Return true to continue, false to break.\n- */\n-#[inline(always)]\n-pub fn eachi_reverse<'r,T>(v: &'r [T],\n-                            blk: &fn(i: uint, v: &'r T) -> bool) -> bool {\n-    let mut i = v.len();\n-    while i > 0 {\n-        i -= 1;\n-        if !blk(i, &v[i]) {\n-            return false;\n-        }\n-    }\n-    return true;\n-}\n-\n /**\n  * Iterate over all permutations of vector `v`.\n  *\n@@ -1964,6 +1810,7 @@ impl<'self,T:Copy> CopyableVector<T> for &'self [T] {\n pub trait ImmutableVector<'self, T> {\n     fn slice(&self, start: uint, end: uint) -> &'self [T];\n     fn iter(self) -> VecIterator<'self, T>;\n+    fn rev_iter(self) -> VecRevIterator<'self, T>;\n     fn head(&self) -> &'self T;\n     fn head_opt(&self) -> Option<&'self T>;\n     fn tail(&self) -> &'self [T];\n@@ -1974,13 +1821,9 @@ pub trait ImmutableVector<'self, T> {\n     fn last_opt(&self) -> Option<&'self T>;\n     fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n-    fn each_reverse(&self, blk: &fn(&T) -> bool) -> bool;\n-    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) -> bool;\n-    fn foldr<'a, U>(&'a self, z: U, p: &fn(t: &'a T, u: U) -> U) -> U;\n     fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n     fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n     fn map_r<U>(&self, f: &fn(x: &T) -> U) -> ~[U];\n-    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool;\n     fn flat_map<U>(&self, f: &fn(t: &T) -> ~[U]) -> ~[U];\n     fn filter_mapped<U:Copy>(&self, f: &fn(t: &T) -> Option<U>) -> ~[U];\n     unsafe fn unsafe_ref(&self, index: uint) -> *T;\n@@ -2002,6 +1845,15 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n                         lifetime: cast::transmute(p)}\n         }\n     }\n+    #[inline]\n+    fn rev_iter(self) -> VecRevIterator<'self, T> {\n+        unsafe {\n+            let p = vec::raw::to_ptr(self);\n+            VecRevIterator{ptr: p.offset(self.len() - 1),\n+                           end: p.offset(-1),\n+                           lifetime: cast::transmute(p)}\n+        }\n+    }\n \n     /// Returns the first element of a vector, failing if the vector is empty.\n     #[inline]\n@@ -2059,24 +1911,6 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         rposition(*self, f)\n     }\n \n-    /// Iterates over a vector's elements in reverse.\n-    #[inline]\n-    fn each_reverse(&self, blk: &fn(&T) -> bool) -> bool {\n-        each_reverse(*self, blk)\n-    }\n-\n-    /// Iterates over a vector's elements and indices in reverse.\n-    #[inline]\n-    fn eachi_reverse(&self, blk: &fn(uint, &T) -> bool) -> bool {\n-        eachi_reverse(*self, blk)\n-    }\n-\n-    /// Reduce a vector from right to left\n-    #[inline]\n-    fn foldr<'a, U>(&'a self, z: U, p: &fn(t: &'a T, u: U) -> U) -> U {\n-        foldr(*self, z, p)\n-    }\n-\n     /// Apply a function to each element of a vector and return the results\n     #[inline]\n     fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U] { map(*self, f) }\n@@ -2100,14 +1934,6 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         r\n     }\n \n-    /**\n-     * Returns true if the function returns true for all elements.\n-     *\n-     *     If the vector is empty, true is returned.\n-     */\n-    fn alli(&self, f: &fn(uint, t: &T) -> bool) -> bool {\n-        alli(*self, f)\n-    }\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n@@ -2350,7 +2176,8 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n #[allow(missing_doc)]\n pub trait MutableVector<'self, T> {\n     fn mut_slice(self, start: uint, end: uint) -> &'self mut [T];\n-    fn mut_iter(self) -> MutVecIterator<'self, T>;\n+    fn mut_iter(self) -> VecMutIterator<'self, T>;\n+    fn mut_rev_iter(self) -> VecMutRevIterator<'self, T>;\n \n     unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T;\n     unsafe fn unsafe_set(&self, index: uint, val: T);\n@@ -2363,14 +2190,23 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     }\n \n     #[inline]\n-    fn mut_iter(self) -> MutVecIterator<'self, T> {\n+    fn mut_iter(self) -> VecMutIterator<'self, T> {\n         unsafe {\n             let p = vec::raw::to_mut_ptr(self);\n-            MutVecIterator{ptr: p, end: p.offset(self.len()),\n+            VecMutIterator{ptr: p, end: p.offset(self.len()),\n                            lifetime: cast::transmute(p)}\n         }\n     }\n \n+    fn mut_rev_iter(self) -> VecMutRevIterator<'self, T> {\n+        unsafe {\n+            let p = vec::raw::to_mut_ptr(self);\n+            VecMutRevIterator{ptr: p.offset(self.len() - 1),\n+                              end: p.offset(-1),\n+                              lifetime: cast::transmute(p)}\n+        }\n+    }\n+\n     #[inline(always)]\n     unsafe fn unsafe_mut_ref(&self, index: uint) -> *mut T {\n         let pair_ptr: &(*mut T, uint) = transmute(self);\n@@ -2872,52 +2708,69 @@ impl<A:Clone> Clone for ~[A] {\n     }\n }\n \n-/// An external iterator for vectors (use with the std::iterator module)\n+macro_rules! iterator {\n+    /* FIXME: #4375 Cannot attach documentation/attributes to a macro generated struct.\n+    (struct $name:ident -> $ptr:ty, $elem:ty) => {\n+        pub struct $name<'self, T> {\n+            priv ptr: $ptr,\n+            priv end: $ptr,\n+            priv lifetime: $elem // FIXME: #5922\n+        }\n+    };*/\n+    (impl $name:ident -> $elem:ty, $step:expr) => {\n+        // could be implemented with &[T] with .slice(), but this avoids bounds checks\n+        impl<'self, T> Iterator<$elem> for $name<'self, T> {\n+            #[inline]\n+            fn next(&mut self) -> Option<$elem> {\n+                unsafe {\n+                    if self.ptr == self.end {\n+                        None\n+                    } else {\n+                        let old = self.ptr;\n+                        self.ptr = self.ptr.offset($step);\n+                        Some(cast::transmute(old))\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+//iterator!{struct VecIterator -> *T, &'self T}\n+/// An iterator for iterating over a vector\n pub struct VecIterator<'self, T> {\n     priv ptr: *T,\n     priv end: *T,\n     priv lifetime: &'self T // FIXME: #5922\n }\n+iterator!{impl VecIterator -> &'self T, 1}\n \n-// could be implemented with &[T] with .slice(), but this avoids bounds checks\n-impl<'self, T> Iterator<&'self T> for VecIterator<'self, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'self T> {\n-        unsafe {\n-            if self.ptr == self.end {\n-                None\n-            } else {\n-                let old = self.ptr;\n-                self.ptr = self.ptr.offset(1);\n-                Some(cast::transmute(old))\n-            }\n-        }\n-    }\n+//iterator!{struct VecRevIterator -> *T, &'self T}\n+/// An iterator for iterating over a vector in reverse\n+pub struct VecRevIterator<'self, T> {\n+    priv ptr: *T,\n+    priv end: *T,\n+    priv lifetime: &'self T // FIXME: #5922\n }\n+iterator!{impl VecRevIterator -> &'self T, -1}\n \n-/// An external iterator for vectors with the possibility of mutating\n-/// elements. (use with the std::iterator module)\n-pub struct MutVecIterator<'self, T> {\n+//iterator!{struct VecMutIterator -> *mut T, &'self mut T}\n+/// An iterator for mutating the elements of a vector\n+pub struct VecMutIterator<'self, T> {\n     priv ptr: *mut T,\n     priv end: *mut T,\n     priv lifetime: &'self mut T // FIXME: #5922\n }\n+iterator!{impl VecMutIterator -> &'self mut T, 1}\n \n-// could be implemented with &[T] with .slice(), but this avoids bounds checks\n-impl<'self, T> Iterator<&'self mut T> for MutVecIterator<'self, T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'self mut T> {\n-        unsafe {\n-            if self.ptr == self.end {\n-                None\n-            } else {\n-                let old = self.ptr;\n-                self.ptr = self.ptr.offset(1);\n-                Some(cast::transmute(old))\n-            }\n-        }\n-    }\n+//iterator!{struct VecMutRevIterator -> *mut T, &'self mut T}\n+/// An iterator for mutating the elements of a vector in reverse\n+pub struct VecMutRevIterator<'self, T> {\n+    priv ptr: *mut T,\n+    priv end: *mut T,\n+    priv lifetime: &'self mut T // FIXME: #5922\n }\n+iterator!{impl VecMutRevIterator -> &'self mut T, -1}\n \n impl<T> FromIter<T> for ~[T]{\n     #[inline(always)]\n@@ -3467,39 +3320,6 @@ mod tests {\n         assert_eq!(v, ~[1, 3, 5]);\n     }\n \n-    #[test]\n-    fn test_foldl() {\n-        // Test on-stack fold.\n-        let mut v = ~[1u, 2u, 3u];\n-        let mut sum = foldl(0u, v, add);\n-        assert_eq!(sum, 6u);\n-\n-        // Test on-heap fold.\n-        v = ~[1u, 2u, 3u, 4u, 5u];\n-        sum = foldl(0u, v, add);\n-        assert_eq!(sum, 15u);\n-    }\n-\n-    #[test]\n-    fn test_foldl2() {\n-        fn sub(a: int, b: &int) -> int {\n-            a - *b\n-        }\n-        let v = ~[1, 2, 3, 4];\n-        let sum = foldl(0, v, sub);\n-        assert_eq!(sum, -10);\n-    }\n-\n-    #[test]\n-    fn test_foldr() {\n-        fn sub(a: &int, b: int) -> int {\n-            *a - b\n-        }\n-        let v = ~[1, 2, 3, 4];\n-        let sum = foldr(v, 0, sub);\n-        assert_eq!(sum, -2);\n-    }\n-\n     #[test]\n     fn test_each_empty() {\n         for each::<int>([]) |_v| {\n@@ -3527,52 +3347,15 @@ mod tests {\n         assert_eq!(i, 6);\n     }\n \n-    #[test]\n-    fn test_each_reverse_empty() {\n-        let v: ~[int] = ~[];\n-        for v.each_reverse |_v| {\n-            fail!(); // should never execute\n-        }\n-    }\n-\n-    #[test]\n-    fn test_each_reverse_nonempty() {\n-        let mut i = 0;\n-        for each_reverse([1, 2, 3]) |v| {\n-            if i == 0 { assert!(*v == 3); }\n-            i += *v\n-        }\n-        assert_eq!(i, 6);\n-    }\n-\n-    #[test]\n-    fn test_eachi_reverse() {\n-        let mut i = 0;\n-        for eachi_reverse([0, 1, 2]) |j, v| {\n-            if i == 0 { assert!(*v == 2); }\n-            assert_eq!(j, *v as uint);\n-            i += *v;\n-        }\n-        assert_eq!(i, 3);\n-    }\n-\n-    #[test]\n-    fn test_eachi_reverse_empty() {\n-        let v: ~[int] = ~[];\n-        for v.eachi_reverse |_i, _v| {\n-            fail!(); // should never execute\n-        }\n-    }\n-\n     #[test]\n     fn test_each_ret_len0() {\n-        let mut a0 : [int, .. 0] = [];\n+        let a0 : [int, .. 0] = [];\n         assert_eq!(each(a0, |_p| fail!()), true);\n     }\n \n     #[test]\n     fn test_each_ret_len1() {\n-        let mut a1 = [17];\n+        let a1 = [17];\n         assert_eq!(each(a1, |_p| true), true);\n         assert_eq!(each(a1, |_p| false), false);\n     }\n@@ -3600,33 +3383,6 @@ mod tests {\n             ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]]);\n     }\n \n-    #[test]\n-    fn test_any_and_all() {\n-        assert!(any([1u, 2u, 3u], is_three));\n-        assert!(!any([0u, 1u, 2u], is_three));\n-        assert!(any([1u, 2u, 3u, 4u, 5u], is_three));\n-        assert!(!any([1u, 2u, 4u, 5u, 6u], is_three));\n-\n-        assert!(all([3u, 3u, 3u], is_three));\n-        assert!(!all([3u, 3u, 2u], is_three));\n-        assert!(all([3u, 3u, 3u, 3u, 3u], is_three));\n-        assert!(!all([3u, 3u, 0u, 1u, 2u], is_three));\n-    }\n-\n-    #[test]\n-    fn test_any2_and_all2() {\n-\n-        assert!(any2([2u, 4u, 6u], [2u, 4u, 6u], is_equal));\n-        assert!(any2([1u, 2u, 3u], [4u, 5u, 3u], is_equal));\n-        assert!(!any2([1u, 2u, 3u], [4u, 5u, 6u], is_equal));\n-        assert!(any2([2u, 4u, 6u], [2u, 4u], is_equal));\n-\n-        assert!(all2([2u, 4u, 6u], [2u, 4u, 6u], is_equal));\n-        assert!(!all2([1u, 2u, 3u], [4u, 5u, 3u], is_equal));\n-        assert!(!all2([1u, 2u, 3u], [4u, 5u, 6u], is_equal));\n-        assert!(!all2([2u, 4u, 6u], [2u, 4u], is_equal));\n-    }\n-\n     #[test]\n     fn test_zip_unzip() {\n         let v1 = ~[1, 2, 3];\n@@ -4371,113 +4127,6 @@ mod tests {\n         };\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_foldl_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do foldl((~0, @0), v) |_a, _b| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            (~0, @0)\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    #[allow(non_implicitly_copyable_typarams)]\n-    fn test_foldr_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do foldr(v, (~0, @0)) |_a, _b| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            (~0, @0)\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_any_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do any(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_any2_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do any(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            false\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_all_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do all(v) |_elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_alli_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do alli(v) |_i, _elt| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            true\n-        };\n-    }\n-\n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_all2_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        let mut i = 0;\n-        do all2(v, v) |_elt1, _elt2| {\n-            if i == 2 {\n-                fail!()\n-            }\n-            i += 0;\n-            true\n-        };\n-    }\n-\n     #[test]\n     #[ignore(windows)]\n     #[should_fail]\n@@ -4642,6 +4291,30 @@ mod tests {\n         assert_eq!(xs, [2, 3, 4, 5, 6])\n     }\n \n+    #[test]\n+    fn test_rev_iterator() {\n+        use iterator::*;\n+\n+        let xs = [1, 2, 5, 10, 11];\n+        let ys = [11, 10, 5, 2, 1];\n+        let mut i = 0;\n+        for xs.rev_iter().advance |&x| {\n+            assert_eq!(x, ys[i]);\n+            i += 1;\n+        }\n+        assert_eq!(i, 5);\n+    }\n+\n+    #[test]\n+    fn test_mut_rev_iterator() {\n+        use iterator::*;\n+        let mut xs = [1u, 2, 3, 4, 5];\n+        for xs.mut_rev_iter().enumerate().advance |(i,x)| {\n+            *x += i;\n+        }\n+        assert_eq!(xs, [5, 5, 5, 5, 5])\n+    }\n+\n     #[test]\n     fn test_reverse_part() {\n         let mut values = [1,2,3,4,5];"}, {"sha": "f27ae3b828c4e5c5263f1ca154881dda329cb6c6", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -15,7 +15,7 @@ use core::prelude::*;\n use codemap::{span, spanned};\n use abi::AbiSet;\n use opt_vec::OptVec;\n-use parse::token::{ident_to_str, interner_get, str_to_ident};\n+use parse::token::{interner_get, str_to_ident};\n \n use core::hashmap::HashMap;\n use core::option::Option;"}, {"sha": "b040397de720d9610dabd354d9b7a73527fc93f3", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -792,6 +792,7 @@ mod test {\n     use ast::*;\n     use super::*;\n     use core::io;\n+    use core::iterator::IteratorUtil;\n \n     #[test] fn xorpush_test () {\n         let mut s = ~[];\n@@ -833,7 +834,7 @@ mod test {\n     // returning the resulting index\n     fn unfold_test_sc(tscs : ~[TestSC], tail: SyntaxContext, table : &mut SCTable)\n         -> SyntaxContext {\n-        tscs.foldr(tail, |tsc : &TestSC,tail : SyntaxContext|\n+        tscs.rev_iter().fold(tail, |tail : SyntaxContext, tsc : &TestSC|\n                   {match *tsc {\n                       M(mrk) => new_mark_internal(mrk,tail,table),\n                       R(ident,name) => new_rename_internal(ident,name,tail,table)}})\n@@ -874,7 +875,7 @@ mod test {\n     // extend a syntax context with a sequence of marks given\n     // in a vector. v[0] will be the outermost mark.\n     fn unfold_marks(mrks:~[Mrk],tail:SyntaxContext,table: &mut SCTable) -> SyntaxContext {\n-        mrks.foldr(tail, |mrk:&Mrk,tail:SyntaxContext|\n+        mrks.rev_iter().fold(tail, |tail:SyntaxContext, mrk:&Mrk|\n                    {new_mark_internal(*mrk,tail,table)})\n     }\n "}, {"sha": "51334772c84b3f5662b02b512d01fc6109c804a3", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -19,6 +19,7 @@ use codemap::BytePos;\n use diagnostic::span_handler;\n use parse::comments::{doc_comment_style, strip_doc_comment_decoration};\n \n+use core::iterator::IteratorUtil;\n use core::hashmap::HashSet;\n use core::vec;\n use extra;\n@@ -313,7 +314,7 @@ pub enum inline_attr {\n /// True if something like #[inline] is found in the list of attrs.\n pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline(always)]\n-    do vec::foldl(ia_none, attrs) |ia,attr| {\n+    do attrs.iter().fold(ia_none) |ia,attr| {\n         match attr.node.value.node {\n           ast::meta_word(@~\"inline\") => ia_hint,\n           ast::meta_list(@~\"inline\", ref items) => {"}, {"sha": "51fbaee7a3396dabaa9113dca58337f13e97f335", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -10,6 +10,7 @@\n \n /* The compiler code necessary to support the bytes! extension. */\n \n+use core::iterator::IteratorUtil;\n use ast;\n use codemap::span;\n use ext::base::*;\n@@ -27,7 +28,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree]) -> bas\n             ast::expr_lit(lit) => match lit.node {\n                 // string literal, push each byte to vector expression\n                 ast::lit_str(s) => {\n-                    for s.each |byte| {\n+                    for s.bytes_iter().advance |byte| {\n                         bytes.push(cx.expr_u8(sp, byte));\n                     }\n                 }"}, {"sha": "078fd4231cab36a965427776dfb51e37f2c46a57", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -1025,11 +1025,11 @@ pub fn cs_fold(use_foldl: bool,\n     match *substructure.fields {\n         EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n-                do all_fields.foldl(base) |&old, &(_, self_f, other_fs)| {\n+                do all_fields.iter().fold(base) |old, &(_, self_f, other_fs)| {\n                     f(cx, span, old, self_f, other_fs)\n                 }\n             } else {\n-                do all_fields.foldr(base) |&(_, self_f, other_fs), old| {\n+                do all_fields.rev_iter().fold(base) |old, &(_, self_f, other_fs)| {\n                     f(cx, span, old, self_f, other_fs)\n                 }\n             }\n@@ -1094,11 +1094,11 @@ pub fn cs_same_method_fold(use_foldl: bool,\n     cs_same_method(\n         |cx, span, vals| {\n             if use_foldl {\n-                do vals.foldl(base) |&old, &new| {\n+                do vals.iter().fold(base) |old, &new| {\n                     f(cx, span, old, new)\n                 }\n             } else {\n-                do vals.foldr(base) |&new, old| {\n+                do vals.rev_iter().fold(base) |old, &new| {\n                     f(cx, span, old, new)\n                 }\n             }"}, {"sha": "453d867fce9d654c8e500cd470bf374f136e2fb9", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -16,7 +16,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n \n-use core::vec;\n+use core::iterator::IteratorUtil;\n \n pub fn expand_deriving_iter_bytes(cx: @ExtCtxt,\n                                   span: span,\n@@ -85,7 +85,7 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: span, substr: &Substructure) -> @\n         cx.span_bug(span, \"#[deriving(IterBytes)] needs at least one field\");\n     }\n \n-    do vec::foldl(exprs[0], exprs.slice(1, exprs.len())) |prev, me| {\n+    do exprs.slice(1, exprs.len()).iter().fold(exprs[0]) |prev, me| {\n         cx.expr_binary(span, and, prev, *me)\n     }\n }"}, {"sha": "c091ab8b6173692afab70ce5360cbf5fa77fec8b", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -19,6 +19,7 @@ library.\n */\n \n use core::prelude::*;\n+use core::iterator::IteratorUtil;\n \n use ast::{enum_def, ident, item, Generics, meta_item, struct_def};\n use ext::base::ExtCtxt;\n@@ -74,7 +75,7 @@ pub fn expand_meta_deriving(cx: @ExtCtxt,\n             in_items\n         }\n         meta_list(_, ref titems) => {\n-            do titems.foldr(in_items) |&titem, in_items| {\n+            do titems.rev_iter().fold(in_items) |in_items, &titem| {\n                 match titem.node {\n                     meta_name_value(tname, _) |\n                     meta_list(tname, _) |"}, {"sha": "1e1f411c050ee886d2784eb8dfc342e09d4bb8a2", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -11,22 +11,23 @@\n use core::prelude::*;\n \n use ast::{blk_, attribute_, attr_outer, meta_word};\n-use ast::{crate, decl_local, expr_, expr_mac, mac_invoc_tt};\n-use ast::{item_mac, local_, stmt_, stmt_decl, stmt_mac, stmt_expr, stmt_semi};\n-use ast::{SCTable, illegal_ctxt};\n+use ast::{crate, expr_, expr_mac, mac_invoc_tt};\n+use ast::{item_mac, stmt_, stmt_mac, stmt_expr, stmt_semi};\n+use ast::{illegal_ctxt};\n use ast;\n-use ast_util::{new_rename, new_mark, resolve, get_sctable};\n+use ast_util::{new_rename, new_mark, resolve};\n use attr;\n use codemap;\n use codemap::{span, CallInfo, ExpandedFrom, NameAndSpan, spanned};\n use ext::base::*;\n use fold::*;\n use parse;\n use parse::{parse_item_from_source_str};\n-use parse::token::{ident_to_str, intern, fresh_name};\n+use parse::token::{ident_to_str, intern};\n use visit;\n-use visit::{Visitor,mk_vt};\n+use visit::Visitor;\n \n+use core::iterator::IteratorUtil;\n use core::vec;\n \n pub fn expand_expr(extsbox: @mut SyntaxEnv,\n@@ -128,7 +129,7 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n     // decorated with \"item decorators\", then use that function to transform\n     // the item into a new set of items.\n     let new_items = do vec::flat_map(module_.items) |item| {\n-        do vec::foldr(item.attrs, ~[*item]) |attr, items| {\n+        do item.attrs.rev_iter().fold(~[*item]) |items, attr| {\n             let mname = attr::get_attr_name(attr);\n \n             match (*extsbox).find(&intern(*mname)) {\n@@ -748,16 +749,14 @@ mod test {\n     use super::*;\n     use ast;\n     use ast::{attribute_, attr_outer, meta_word, empty_ctxt};\n-    use ast_util::{get_sctable};\n     use codemap;\n     use codemap::spanned;\n     use parse;\n-    use parse::token::{gensym, intern, get_ident_interner};\n+    use parse::token::{intern, get_ident_interner};\n     use print::pprust;\n     use util::parser_testing::{string_to_item, string_to_pat, strs_to_idents};\n-    use visit::{mk_vt,Visitor};\n+    use visit::{mk_vt};\n \n-    use core::io;\n     use core::option::{None, Some};\n \n     // make sure that fail! is present"}, {"sha": "a6ec91f899ca89c62f65f71da961a379b791d5d5", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -129,12 +129,12 @@ pub fn copy_up(mpu: &matcher_pos_up) -> ~MatcherPos {\n }\n \n pub fn count_names(ms: &[matcher]) -> uint {\n-    vec::foldl(0u, ms, |ct, m| {\n+    do ms.iter().fold(0) |ct, m| {\n         ct + match m.node {\n           match_tok(_) => 0u,\n           match_seq(ref more_ms, _, _, _, _) => count_names((*more_ms)),\n           match_nonterminal(_,_,_) => 1u\n-        }})\n+        }}\n }\n \n pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)"}, {"sha": "f3bd2d4b8d1cf260533d50d2624c7c608fb434b2", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -19,9 +19,9 @@ use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident};\n use parse::token::{ident_to_str};\n use parse::lexer::TokenAndSpan;\n \n+use core::iterator::IteratorUtil;\n use core::hashmap::HashMap;\n use core::option;\n-use core::vec;\n \n ///an unzipping of `token_tree`s\n struct TtFrame {\n@@ -113,9 +113,7 @@ fn lookup_cur_matched_by_matched(r: &mut TtReader,\n           matched_seq(ref ads, _) => ads[*idx]\n         }\n     }\n-    let r = &mut *r;\n-    let repeat_idx = &r.repeat_idx;\n-    vec::foldl(start, *repeat_idx, red)\n+    r.repeat_idx.iter().fold(start, red)\n }\n \n fn lookup_cur_matched(r: &mut TtReader, name: ident) -> @named_match {\n@@ -152,10 +150,10 @@ fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n     }\n     match *t {\n       tt_delim(ref tts) | tt_seq(_, ref tts, _, _) => {\n-        vec::foldl(lis_unconstrained, *tts, |lis, tt| {\n+        do tts.iter().fold(lis_unconstrained) |lis, tt| {\n             let lis2 = lockstep_iter_size(tt, r);\n             lis_merge(lis, lis2)\n-        })\n+        }\n       }\n       tt_tok(*) => lis_unconstrained,\n       tt_nonterminal(_, name) => match *lookup_cur_matched(r, name) {"}, {"sha": "360ea12ec029ce5fbcc86ff528cc3e56d51b5fdd", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -19,8 +19,8 @@ use parse::lexer::{is_line_non_doc_comment, is_block_non_doc_comment};\n use parse::lexer;\n use parse::token;\n use parse::token::{get_ident_interner};\n-use parse;\n \n+use core::iterator::IteratorUtil;\n use core::io;\n use core::str;\n use core::uint;\n@@ -78,7 +78,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n             if line.trim().is_empty() {\n                 loop;\n             }\n-            for line.each_chari |j, c| {\n+            for line.iter().enumerate().advance |(j, c)| {\n                 if j >= i {\n                     break;\n                 }\n@@ -91,7 +91,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n \n         return do lines.map |line| {\n             let mut chars = ~[];\n-            for str::each_char(*line) |c| { chars.push(c) }\n+            for line.iter().advance |c| { chars.push(c) }\n             if i > chars.len() {\n                 ~\"\"\n             } else {"}, {"sha": "559bca34f21ee9fc7232edd538bb6995f9a791ab", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -341,10 +341,9 @@ mod test {\n     use codemap::{span, BytePos, spanned};\n     use opt_vec;\n     use ast;\n-    use ast::{new_ident};\n     use abi;\n     use parse::parser::Parser;\n-    use parse::token::{intern, str_to_ident};\n+    use parse::token::{str_to_ident};\n     use util::parser_testing::{string_to_tts_and_sess, string_to_parser};\n     use util::parser_testing::{string_to_expr, string_to_item};\n     use util::parser_testing::{string_to_stmt, strs_to_idents};"}, {"sha": "7359448a8f2369b36890f1d7bbeadedd55114791", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -22,7 +22,6 @@ use core::char;\n use core::cmp::Equiv;\n use core::local_data;\n use core::str;\n-use core::hashmap::HashSet;\n use core::rand;\n use core::rand::RngUtil;\n use core::to_bytes;"}, {"sha": "dee18c8a1b3ed9973c079c6c1559bdbd7c46ac22", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -21,6 +21,7 @@ use extra::arc;\n use extra::time;\n use extra::deque::Deque;\n use extra::par;\n+use std::iterator::IteratorUtil;\n use std::hashmap::HashSet;\n use std::int::abs;\n use std::io;\n@@ -111,7 +112,7 @@ fn gen_search_keys(graph: &[~[node_id]], n: uint) -> ~[node_id] {\n     while keys.len() < n {\n         let k = r.gen_uint_range(0u, graph.len());\n \n-        if graph[k].len() > 0u && vec::any(graph[k], |i| {\n+        if graph[k].len() > 0u && graph[k].iter().any(|i| {\n             *i != k as node_id\n         }) {\n             keys.insert(k as node_id);\n@@ -187,7 +188,7 @@ fn bfs2(graph: graph, key: node_id) -> bfs_result {\n     }\n \n     let mut i = 0;\n-    while vec::any(colors, is_gray) {\n+    while colors.iter().any(is_gray) {\n         // Do the BFS.\n         info!(\"PBFS iteration %?\", i);\n         i += 1;\n@@ -362,7 +363,7 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     info!(~\"Verifying tree edges...\");\n \n-    let status = do tree.alli() |k, parent| {\n+    let status = do tree.iter().enumerate().all |(k, parent)| {\n         if *parent != root && *parent != -1i64 {\n             level[*parent] == level[k] - 1\n         }"}, {"sha": "ce8f5e502e8318b23c87c6ceb7ca47307a2c4295", "filename": "src/test/compile-fail/block-arg-as-stmt-with-value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-arg-as-stmt-with-value.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n+use std::iterator::IteratorUtil;\n \n fn compute1() -> float {\n     let v = ~[0f, 1f, 2f, 3f];\n \n-    do vec::foldl(0f, v) |x, y| { x + *y } - 10f\n+    do v.iter().fold(0f) |x, y| { x + *y } - 10f\n     //~^ ERROR mismatched types: expected `()`\n }\n "}, {"sha": "ee96cc293ebbf9b6a3a1eb3988020b2db8c81c48", "filename": "src/test/compile-fail/issue-3044.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n+use std::iterator::IteratorUtil;\n \n fn main() {\n     let needlesArr: ~[char] = ~['a', 'f'];\n-    do vec::foldr(needlesArr) |x, y| {\n+    do needlesArr.iter().fold() |x, y| {\n     }\n-    //~^ ERROR 2 parameters were supplied (including the closure passed by the `do` keyword)\n+    //~^ ERROR 1 parameter was supplied (including the closure passed by the `do` keyword)\n     //\n     // the first error is, um, non-ideal.\n }"}, {"sha": "522516351d2288be277118006a60f2dc77c77983", "filename": "src/test/run-pass/block-arg-can-be-followed-by-binop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n+use std::iterator::IteratorUtil;\n \n pub fn main() {\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n \n     // Trailing expressions don't require parentheses:\n-    let y = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n+    let y = do v.iter().fold(0f) |x, y| { x + *y } + 10f;\n \n     assert_eq!(y, 15f);\n }"}, {"sha": "c6d66e07444c7c1510a10e39b333c441e47f97c1", "filename": "src/test/run-pass/block-arg-can-be-followed-by-block-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n+use std::iterator::IteratorUtil;\n \n pub fn main() {\n     fn f(i: &fn() -> uint) -> uint { i() }\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n-    let z = do do vec::foldl(f, v) |x, _y| { x } { 22u };\n+    let z = do do v.iter().fold(f) |x, _y| { x } { 22u };\n     assert_eq!(z, 22u);\n }"}, {"sha": "a205e9f8f31ef0e67421eb8411fe7d9be72fcd74", "filename": "src/test/run-pass/block-arg-can-be-followed-by-call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::vec;\n+use std::iterator::IteratorUtil;\n \n pub fn main() {\n     fn f(i: uint) -> uint { i }\n     let v = ~[-1f, 0f, 1f, 2f, 3f];\n-    let z = do vec::foldl(f, v) |x, _y| { x } (22u);\n+    let z = do v.iter().fold(f) |x, _y| { x } (22u);\n     assert_eq!(z, 22u);\n }"}, {"sha": "854b45f4672d147d7986d50952741174cf7f38ce", "filename": "src/test/run-pass/block-arg-in-parentheses.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -8,25 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::iterator::IteratorUtil;\n use std::vec;\n \n fn w_semi(v: ~[int]) -> int {\n     // the semicolon causes compiler not to\n     // complain about the ignored return value:\n-    do vec::foldl(0, v) |x,y| { x+*y };\n+    do v.iter().fold(0) |x,y| { x+*y };\n     -10\n }\n \n fn w_paren1(v: ~[int]) -> int {\n-    (do vec::foldl(0, v) |x,y| { x+*y }) - 10\n+    (do v.iter().fold(0) |x,y| { x+*y }) - 10\n }\n \n fn w_paren2(v: ~[int]) -> int {\n-    (do vec::foldl(0, v) |x,y| { x+*y} - 10)\n+    (do v.iter().fold(0) |x,y| { x+*y} - 10)\n }\n \n fn w_ret(v: ~[int]) -> int {\n-    return do vec::foldl(0, v) |x,y| { x+*y } - 10;\n+    return do v.iter().fold(0) |x,y| { x+*y } - 10;\n }\n \n pub fn main() {"}, {"sha": "c34948a897937633b606eb25030d78c338d15d14", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::iterator::IteratorUtil;\n use std::vec;\n \n // Check usage and precedence of block arguments in expressions:\n@@ -20,28 +21,28 @@ pub fn main() {\n     }\n \n     // Usable at all:\n-    let mut any_negative = do vec::any(v) |e| { e.is_negative() };\n+    let mut any_negative = do v.iter().any |e| { e.is_negative() };\n     assert!(any_negative);\n \n     // Higher precedence than assignments:\n-    any_negative = do vec::any(v) |e| { e.is_negative() };\n+    any_negative = do v.iter().any |e| { e.is_negative() };\n     assert!(any_negative);\n \n     // Higher precedence than unary operations:\n     let abs_v = do vec::map(v) |e| { e.abs() };\n-    assert!(do vec::all(abs_v) |e| { e.is_positive() });\n-    assert!(!do vec::any(abs_v) |e| { e.is_negative() });\n+    assert!(do abs_v.iter().all |e| { e.is_positive() });\n+    assert!(!do abs_v.iter().any |e| { e.is_negative() });\n \n     // Usable in funny statement-like forms:\n-    if !do vec::any(v) |e| { e.is_positive() } {\n+    if !do v.iter().any |e| { e.is_positive() } {\n         assert!(false);\n     }\n-    match do vec::all(v) |e| { e.is_negative() } {\n+    match do v.iter().all |e| { e.is_negative() } {\n         true => { fail!(\"incorrect answer.\"); }\n         false => { }\n     }\n     match 3 {\n-      _ if do vec::any(v) |e| { e.is_negative() } => {\n+      _ if do v.iter().any |e| { e.is_negative() } => {\n       }\n       _ => {\n         fail!(\"wrong answer.\");\n@@ -50,15 +51,15 @@ pub fn main() {\n \n \n     // Lower precedence than binary operations:\n-    let w = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n-    let y = do vec::foldl(0f, v) |x, y| { x + *y } + 10f;\n-    let z = 10f + do vec::foldl(0f, v) |x, y| { x + *y };\n+    let w = do v.iter().fold(0f) |x, y| { x + *y } + 10f;\n+    let y = do v.iter().fold(0f) |x, y| { x + *y } + 10f;\n+    let z = 10f + do v.iter().fold(0f) |x, y| { x + *y };\n     assert_eq!(w, y);\n     assert_eq!(y, z);\n \n     // In the tail of a block\n     let w =\n-        if true { do vec::any(abs_v) |e| { e.is_positive() } }\n+        if true { do abs_v.iter().any |e| { e.is_positive() } }\n       else { false };\n     assert!(w);\n }"}, {"sha": "fcebb528c10afbf91381f89d23728459aa418afb", "filename": "src/test/run-pass/issue-2904.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Fissue-2904.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2904.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -14,6 +14,7 @@\n \n extern mod extra;\n \n+use std::iterator::IteratorUtil;\n use std::io::ReaderUtil;\n use std::io;\n use std::str;\n@@ -67,7 +68,7 @@ fn read_board_grid<rdr:'static + io::Reader>(in: rdr) -> ~[~[square]] {\n     let mut grid = ~[];\n     for in.each_line |line| {\n         let mut row = ~[];\n-        for str::each_char(line) |c| {\n+        for line.iter().advance |c| {\n             row.push(square_from_char(c))\n         }\n         grid.push(row)"}, {"sha": "a42d70f5ae2d84a5ca20aca4aa0a46932c480370", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::str;\n+use std::iterator::IteratorUtil;\n \n pub fn main() {\n     let x = ~[1, 2, 3];\n@@ -18,7 +18,7 @@ pub fn main() {\n     assert_eq!(y, 6);\n     let s = ~\"hello there\";\n     let mut i: int = 0;\n-    for str::each(s) |c| {\n+    for s.bytes_iter().advance |c| {\n         if i == 0 { assert!((c == 'h' as u8)); }\n         if i == 1 { assert!((c == 'e' as u8)); }\n         if i == 2 { assert!((c == 'l' as u8)); }"}, {"sha": "4346d242c06bfd746d641ccde5d11371bfa82207", "filename": "src/test/run-pass/ret-break-cont-in-block.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fret-break-cont-in-block.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -10,6 +10,7 @@\n \n // xfail-fast\n \n+use std::iterator::IteratorUtil;\n use std::cmp::Eq;\n use std::vec;\n \n@@ -54,7 +55,8 @@ fn ret_deep() -> ~str {\n \n pub fn main() {\n     let mut last = 0;\n-    for vec::all(~[1, 2, 3, 4, 5, 6, 7]) |e| {\n+    let v = ~[1, 2, 3, 4, 5, 6, 7];\n+    for v.iter().all |e| {\n         last = *e;\n         if *e == 5 { break; }\n         if *e % 2 == 1 { loop; }"}, {"sha": "cbfaa87b69952aa7731adc99cc1aaa78557376d0", "filename": "src/test/run-pass/test-ignore-cfg.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftest-ignore-cfg.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -13,7 +13,7 @@\n \n extern mod extra;\n \n-use std::vec;\n+use std::iterator::IteratorUtil;\n \n #[test]\n #[ignore(cfg(ignorecfg))]\n@@ -30,11 +30,9 @@ fn checktests() {\n     // Pull the tests out of the secreturn test module\n     let tests = __test::tests;\n \n-    assert!(vec::any(\n-        tests,\n-        |t| t.desc.name.to_str() == ~\"shouldignore\" && t.desc.ignore));\n+    assert!(\n+        tests.iter().any(|t| t.desc.name.to_str() == ~\"shouldignore\" && t.desc.ignore));\n \n-    assert!(vec::any(\n-        tests,\n-        |t| t.desc.name.to_str() == ~\"shouldnotignore\" && !t.desc.ignore));\n+    assert!(\n+        tests.iter().any(|t| t.desc.name.to_str() == ~\"shouldnotignore\" && !t.desc.ignore));\n }"}, {"sha": "8a8454390582586d363b63340f4b19d48e370b73", "filename": "src/test/run-pass/utf8.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=b8fa9d3be10e952fbcaf14f3098aebf13dedd7ec", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::str;\n+use std::iterator::IteratorUtil;\n \n pub fn main() {\n     let yen: char = '\u00a5'; // 0xa5\n@@ -43,7 +43,7 @@ pub fn main() {\n \n     fn check_str_eq(a: ~str, b: ~str) {\n         let mut i: int = 0;\n-        for str::each(a) |ab| {\n+        for a.bytes_iter().advance |ab| {\n             debug!(i);\n             debug!(ab);\n             let bb: u8 = b[i];"}]}