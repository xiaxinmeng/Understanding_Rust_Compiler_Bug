{"sha": "d97bfb22f8c4958909c5669c256c50f124c17d58", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5N2JmYjIyZjhjNDk1ODkwOWM1NjY5YzI1NmM1MGYxMjRjMTdkNTg=", "commit": {"author": {"name": "Vladimir Matveev", "email": "vladimir.matweev@gmail.com", "date": "2014-10-19T19:02:21Z"}, "committer": {"name": "Vladimir Matveev", "email": "vladimir.matweev@gmail.com", "date": "2014-11-05T09:01:23Z"}, "message": "Added ToSocketAddr trait\n\nThis commit adds ToSocketAddr trait to std::io::net::ip module. This\ntrait is used for generic conversion from different types (strings,\n(string, u16) tuples, etc.) into a SocketAddr instance. It supports\nmultiple output SocketAddresses when it is appropriate (e.g. DNS name\nresolution).\n\nThis trait is going to be used by TcpStream, TcpListener and UdpSocket\nstructures.", "tree": {"sha": "2b11aed8b0fe2c6157492cb2315f6549730106d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b11aed8b0fe2c6157492cb2315f6549730106d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d97bfb22f8c4958909c5669c256c50f124c17d58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d97bfb22f8c4958909c5669c256c50f124c17d58", "html_url": "https://github.com/rust-lang/rust/commit/d97bfb22f8c4958909c5669c256c50f124c17d58", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d97bfb22f8c4958909c5669c256c50f124c17d58/comments", "author": {"login": "netvl", "id": 280456, "node_id": "MDQ6VXNlcjI4MDQ1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/280456?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netvl", "html_url": "https://github.com/netvl", "followers_url": "https://api.github.com/users/netvl/followers", "following_url": "https://api.github.com/users/netvl/following{/other_user}", "gists_url": "https://api.github.com/users/netvl/gists{/gist_id}", "starred_url": "https://api.github.com/users/netvl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netvl/subscriptions", "organizations_url": "https://api.github.com/users/netvl/orgs", "repos_url": "https://api.github.com/users/netvl/repos", "events_url": "https://api.github.com/users/netvl/events{/privacy}", "received_events_url": "https://api.github.com/users/netvl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "netvl", "id": 280456, "node_id": "MDQ6VXNlcjI4MDQ1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/280456?v=4", "gravatar_id": "", "url": "https://api.github.com/users/netvl", "html_url": "https://github.com/netvl", "followers_url": "https://api.github.com/users/netvl/followers", "following_url": "https://api.github.com/users/netvl/following{/other_user}", "gists_url": "https://api.github.com/users/netvl/gists{/gist_id}", "starred_url": "https://api.github.com/users/netvl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/netvl/subscriptions", "organizations_url": "https://api.github.com/users/netvl/orgs", "repos_url": "https://api.github.com/users/netvl/repos", "events_url": "https://api.github.com/users/netvl/events{/privacy}", "received_events_url": "https://api.github.com/users/netvl/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4375b32dabf8096a1137a68c1070fc9a9292cb06", "url": "https://api.github.com/repos/rust-lang/rust/commits/4375b32dabf8096a1137a68c1070fc9a9292cb06", "html_url": "https://github.com/rust-lang/rust/commit/4375b32dabf8096a1137a68c1070fc9a9292cb06"}], "stats": {"total": 151, "additions": 151, "deletions": 0}, "files": [{"sha": "1a9ba07b1ca1d867367ca499e021c9ea540ca283", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/d97bfb22f8c4958909c5669c256c50f124c17d58/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d97bfb22f8c4958909c5669c256c50f124c17d58/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=d97bfb22f8c4958909c5669c256c50f124c17d58", "patch": "@@ -17,10 +17,14 @@\n \n use fmt;\n use from_str::FromStr;\n+use io::{mod, IoResult, IoError};\n+use io::net;\n use iter::Iterator;\n use option::{Option, None, Some};\n+use result::{Ok, Err};\n use str::StrSlice;\n use slice::{MutableCloneableSlice, MutableSlice, ImmutableSlice};\n+use vec::Vec;\n \n pub type Port = u16;\n \n@@ -348,6 +352,109 @@ impl FromStr for SocketAddr {\n     }\n }\n \n+pub trait ToSocketAddr {\n+    fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n+        self.to_socket_addr_all()\n+            .and_then(|v| v.into_iter().next().ok_or_else(|| IoError {\n+                kind: io::InvalidInput,\n+                desc: \"no address available\",\n+                detail: None\n+            }))\n+    }\n+\n+    #[inline]\n+    fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> {\n+        self.to_socket_addr().map(|a| vec![a])\n+    }\n+}\n+\n+impl ToSocketAddr for SocketAddr {\n+    #[inline]\n+    fn to_socket_addr(&self) -> IoResult<SocketAddr> { Ok(*self) }\n+}\n+\n+impl ToSocketAddr for (IpAddr, u16) {\n+    #[inline]\n+    fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n+        let (ip, port) = *self;\n+        Ok(SocketAddr { ip: ip, port: port })\n+    }\n+}\n+\n+fn resolve_socket_addr(s: &str, p: u16) -> IoResult<Vec<SocketAddr>> {\n+    net::get_host_addresses(s)\n+        .map(|v| v.into_iter().map(|a| SocketAddr { ip: a, port: p }).collect())\n+}\n+\n+fn parse_and_resolve_socket_addr(s: &str) -> IoResult<Vec<SocketAddr>> {\n+    macro_rules! try_opt(\n+        ($e:expr, $msg:expr) => (\n+            match $e {\n+                Some(r) => r,\n+                None => return Err(IoError {\n+                    kind: io::InvalidInput,\n+                    desc: $msg,\n+                    detail: None\n+                })\n+            }\n+        )\n+    )\n+\n+    // split the string by ':' and convert the second part to u16\n+    let mut parts_iter = s.rsplitn(2, ':');\n+    let port_str = try_opt!(parts_iter.next(), \"invalid socket address\");\n+    let host = try_opt!(parts_iter.next(), \"invalid socket address\");\n+    let port: u16 = try_opt!(FromStr::from_str(port_str), \"invalid port value\");\n+    resolve_socket_addr(host, port)\n+}\n+\n+impl<'a> ToSocketAddr for (&'a str, u16) {\n+    fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> {\n+        let (host, port) = *self;\n+\n+        // try to parse the host as a regular IpAddr first\n+        match FromStr::from_str(host) {\n+            Some(addr) => return Ok(vec![SocketAddr {\n+                ip: addr,\n+                port: port\n+            }]),\n+            None => {}\n+        }\n+\n+        resolve_socket_addr(host, port)\n+    }\n+}\n+\n+// accepts strings like 'localhost:12345'\n+impl<'a> ToSocketAddr for &'a str {\n+    fn to_socket_addr(&self) -> IoResult<SocketAddr> {\n+        // try to parse as a regular SocketAddr first\n+        match FromStr::from_str(*self) {\n+            Some(addr) => return Ok(addr),\n+            None => {}\n+        }\n+\n+        parse_and_resolve_socket_addr(*self)\n+            .and_then(|v| v.into_iter().next()\n+                .ok_or_else(|| IoError {\n+                    kind: io::InvalidInput,\n+                    desc: \"no address available\",\n+                    detail: None\n+                })\n+            )\n+    }\n+\n+    fn to_socket_addr_all(&self) -> IoResult<Vec<SocketAddr>> {\n+        // try to parse as a regular SocketAddr first\n+        match FromStr::from_str(*self) {\n+            Some(addr) => return Ok(vec![addr]),\n+            None => {}\n+        }\n+\n+        parse_and_resolve_socket_addr(*self)\n+    }\n+}\n+\n \n #[cfg(test)]\n mod test {\n@@ -457,4 +564,48 @@ mod test {\n         assert_eq!(Ipv6Addr(8, 9, 10, 11, 12, 13, 14, 15).to_string(),\n                    \"8:9:a:b:c:d:e:f\".to_string());\n     }\n+\n+    #[test]\n+    fn to_socket_addr_socketaddr() {\n+        let a = SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 12345 };\n+        assert_eq!(Ok(a), a.to_socket_addr());\n+        assert_eq!(Ok(vec![a]), a.to_socket_addr_all());\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_ipaddr_u16() {\n+        let a = Ipv4Addr(77, 88, 21, 11);\n+        let p = 12345u16;\n+        let e = SocketAddr { ip: a, port: p };\n+        assert_eq!(Ok(e), (a, p).to_socket_addr());\n+        assert_eq!(Ok(vec![e]), (a, p).to_socket_addr_all());\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_str_u16() {\n+        let a = SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 24352 };\n+        assert_eq!(Ok(a), (\"77.88.21.11\", 24352u16).to_socket_addr());\n+        assert_eq!(Ok(vec![a]), (\"77.88.21.11\", 24352u16).to_socket_addr_all());\n+\n+        let a = SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 };\n+        assert_eq!(Ok(a), (\"2a02:6b8:0:1::1\", 53).to_socket_addr());\n+        assert_eq!(Ok(vec![a]), (\"2a02:6b8:0:1::1\", 53).to_socket_addr_all());\n+\n+        let a = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 23924 };\n+        assert!((\"localhost\", 23924u16).to_socket_addr_all().unwrap().contains(&a));\n+    }\n+\n+    #[test]\n+    fn to_socket_addr_str() {\n+        let a = SocketAddr { ip: Ipv4Addr(77, 88, 21, 11), port: 24352 };\n+        assert_eq!(Ok(a), \"77.88.21.11:24352\".to_socket_addr());\n+        assert_eq!(Ok(vec![a]), \"77.88.21.11:24352\".to_socket_addr_all());\n+\n+        let a = SocketAddr { ip: Ipv6Addr(0x2a02, 0x6b8, 0, 1, 0, 0, 0, 1), port: 53 };\n+        assert_eq!(Ok(a), \"[2a02:6b8:0:1::1]:53\".to_socket_addr());\n+        assert_eq!(Ok(vec![a]), \"[2a02:6b8:0:1::1]:53\".to_socket_addr_all());\n+\n+        let a = SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 23924 };\n+        assert!(\"localhost:23924\".to_socket_addr_all().unwrap().contains(&a));\n+    }\n }"}]}