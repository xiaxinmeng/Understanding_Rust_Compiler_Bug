{"sha": "ba824ec52beb0e49b64e86837c1402a0c2d0c971", "node_id": "C_kwDOAAsO6NoAKGJhODI0ZWM1MmJlYjBlNDliNjRlODY4MzdjMTQwMmEwYzJkMGM5NzE", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-12-15T19:52:37Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2021-12-16T19:49:34Z"}, "message": "Clean up search code and unify function returned values", "tree": {"sha": "1132e683041dba6e3a2c4de0834822905913cbe9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1132e683041dba6e3a2c4de0834822905913cbe9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba824ec52beb0e49b64e86837c1402a0c2d0c971", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba824ec52beb0e49b64e86837c1402a0c2d0c971", "html_url": "https://github.com/rust-lang/rust/commit/ba824ec52beb0e49b64e86837c1402a0c2d0c971", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba824ec52beb0e49b64e86837c1402a0c2d0c971/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ee016ae4d4c6ee4a34faa2eb7fdae2ffa7c9b46", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ee016ae4d4c6ee4a34faa2eb7fdae2ffa7c9b46", "html_url": "https://github.com/rust-lang/rust/commit/3ee016ae4d4c6ee4a34faa2eb7fdae2ffa7c9b46"}], "stats": {"total": 204, "additions": 96, "deletions": 108}, "files": [{"sha": "061a9ec774df201f08d4eef4011db9c2e4c8f5a5", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 96, "deletions": 108, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/ba824ec52beb0e49b64e86837c1402a0c2d0c971/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/ba824ec52beb0e49b64e86837c1402a0c2d0c971/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=ba824ec52beb0e49b64e86837c1402a0c2d0c971", "patch": "@@ -176,16 +176,13 @@ window.initSearch = function(rawSearchIndex) {\n             var ar = [];\n             for (var entry in results) {\n                 if (hasOwnPropertyRustdoc(results, entry)) {\n-                    ar.push(results[entry]);\n+                    var result = results[entry];\n+                    result.word = searchWords[result.id];\n+                    result.item = searchIndex[result.id] || {};\n+                    ar.push(result);\n                 }\n             }\n             results = ar;\n-            var i, len, result;\n-            for (i = 0, len = results.length; i < len; ++i) {\n-                result = results[i];\n-                result.word = searchWords[result.id];\n-                result.item = searchIndex[result.id] || {};\n-            }\n             // if there are no results then return to default and fail\n             if (results.length === 0) {\n                 return [];\n@@ -258,7 +255,7 @@ window.initSearch = function(rawSearchIndex) {\n                 return 0;\n             });\n \n-            for (i = 0, len = results.length; i < len; ++i) {\n+            for (var i = 0, len = results.length; i < len; ++i) {\n                 result = results[i];\n \n                 // this validation does not make sense when searching by types\n@@ -344,7 +341,17 @@ window.initSearch = function(rawSearchIndex) {\n             return MAX_LEV_DISTANCE + 1;\n         }\n \n-        // Check for type name and type generics (if any).\n+        /**\n+          * This function checks if the object (`obj`) matches the given type (`val`) and its\n+          * generics (if any).\n+          *\n+          * @param {Object} obj\n+          * @param {string} val\n+          * @param {boolean} literalSearch\n+          *\n+          * @return {integer} - Returns a Levenshtein distance to the best match. If there is\n+          *                     no match, returns `MAX_LEV_DISTANCE + 1`.\n+          */\n         function checkType(obj, val, literalSearch) {\n             var lev_distance = MAX_LEV_DISTANCE + 1;\n             var tmp_lev = MAX_LEV_DISTANCE + 1;\n@@ -363,24 +370,23 @@ window.initSearch = function(rawSearchIndex) {\n                                 elems[obj[GENERICS_DATA][x][NAME]] += 1;\n                             }\n \n-                            var allFound = true;\n                             len = val.generics.length;\n                             for (x = 0; x < len; ++x) {\n                                 firstGeneric = val.generics[x];\n                                 if (elems[firstGeneric]) {\n                                     elems[firstGeneric] -= 1;\n                                 } else {\n-                                    allFound = false;\n-                                    break;\n+                                    // Something wasn't found and this is a literal search so\n+                                    // abort and return a \"failing\" distance.\n+                                    return MAX_LEV_DISTANCE + 1;\n                                 }\n                             }\n-                            if (allFound) {\n-                                return true;\n-                            }\n+                            // Everything was found, success!\n+                            return 0;\n                         }\n-                        return false;\n+                        return MAX_LEV_DISTANCE + 1;\n                     }\n-                    return true;\n+                    return 0;\n                 } else {\n                     // If the type has generics but don't match, then it won't return at this point.\n                     // Otherwise, `checkGenerics` will return 0 and it'll return.\n@@ -392,14 +398,15 @@ window.initSearch = function(rawSearchIndex) {\n                     }\n                 }\n             } else if (literalSearch) {\n+                var found = false;\n                 if ((!val.generics || val.generics.length === 0) &&\n                       obj.length > GENERICS_DATA && obj[GENERICS_DATA].length > 0) {\n-                    return obj[GENERICS_DATA].some(\n+                    found = obj[GENERICS_DATA].some(\n                         function(gen) {\n                             return gen[NAME] === val.name;\n                         });\n                 }\n-                return false;\n+                return found ? 0 : MAX_LEV_DISTANCE + 1;\n             }\n             lev_distance = Math.min(levenshtein(obj[NAME], val.name), lev_distance);\n             if (lev_distance <= MAX_LEV_DISTANCE) {\n@@ -430,6 +437,17 @@ window.initSearch = function(rawSearchIndex) {\n             return Math.min(lev_distance, tmp_lev) + 1;\n         }\n \n+        /**\n+         * This function checks if the object (`obj`) has an argument with the given type (`val`).\n+         *\n+         * @param {Object} obj\n+         * @param {string} val\n+         * @param {boolean} literalSearch\n+         * @param {integer} typeFilter\n+         *\n+         * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n+         *                      match, returns `MAX_LEV_DISTANCE + 1`.\n+         */\n         function findArg(obj, val, literalSearch, typeFilter) {\n             var lev_distance = MAX_LEV_DISTANCE + 1;\n \n@@ -441,19 +459,15 @@ window.initSearch = function(rawSearchIndex) {\n                         continue;\n                     }\n                     tmp = checkType(tmp, val, literalSearch);\n-                    if (literalSearch) {\n-                        if (tmp) {\n-                            return true;\n-                        }\n+                    if (tmp === 0) {\n+                        return 0;\n+                    } else if (literalSearch) {\n                         continue;\n                     }\n                     lev_distance = Math.min(tmp, lev_distance);\n-                    if (lev_distance === 0) {\n-                        return 0;\n-                    }\n                 }\n             }\n-            return literalSearch ? false : lev_distance;\n+            return literalSearch ? MAX_LEV_DISTANCE + 1 : lev_distance;\n         }\n \n         function checkReturned(obj, val, literalSearch, typeFilter) {\n@@ -470,19 +484,15 @@ window.initSearch = function(rawSearchIndex) {\n                         continue;\n                     }\n                     tmp = checkType(tmp, val, literalSearch);\n-                    if (literalSearch) {\n-                        if (tmp) {\n-                            return true;\n-                        }\n+                    if (tmp === 0) {\n+                        return 0;\n+                    } else if (literalSearch) {\n                         continue;\n                     }\n                     lev_distance = Math.min(tmp, lev_distance);\n-                    if (lev_distance === 0) {\n-                        return 0;\n-                    }\n                 }\n             }\n-            return literalSearch ? false : lev_distance;\n+            return literalSearch ? MAX_LEV_DISTANCE + 1 : lev_distance;\n         }\n \n         function checkPath(contains, lastElem, ty) {\n@@ -612,6 +622,44 @@ window.initSearch = function(rawSearchIndex) {\n             onEach(crateAliases, pushFunc);\n         }\n \n+        /**\n+         * This function adds the given result into the provided `res` map if it matches the\n+         * following condition:\n+         *\n+         * * If it is a \"literal search\" (`isExact`), then `lev` must be 0.\n+         * * If it is not a \"literal search\", `lev` must be <= `MAX_LEV_DISTANCE`.\n+         *\n+         * The `res` map contains information which will be used to sort the search results:\n+         *\n+         * * `fullId` is a `string`` used as the key of the object we use for the `res` map.\n+         * * `id` is the index in both `searchWords` and `searchIndex` arrays for this element.\n+         * * `index` is an `integer`` used to sort by the position of the word in the item's name.\n+         * * `lev` is the main metric used to sort the search results.\n+         *\n+         * @param {boolean} isExact\n+         * @param {Object} res\n+         * @param {string} fullId\n+         * @param {integer} id\n+         * @param {integer} index\n+         * @param {integer} lev\n+         */\n+        function addIntoResults(isExact, res, fullId, id, index, lev) {\n+            if (lev === 0 || (!isExact && lev <= MAX_LEV_DISTANCE)) {\n+                if (res[fullId] !== undefined) {\n+                    var result = res[fullId];\n+                    if (result.dontValidate || result.lev <= lev) {\n+                        return;\n+                    }\n+                }\n+                res[fullId] = {\n+                    id: id,\n+                    index: index,\n+                    dontValidate: isExact,\n+                    lev: lev,\n+                };\n+            }\n+        }\n+\n         // quoted values mean literal search\n         var nSearchWords = searchWords.length;\n         var i, it;\n@@ -634,28 +682,11 @@ window.initSearch = function(rawSearchIndex) {\n                 fullId = ty.id;\n \n                 if (searchWords[i] === val.name\n-                    && typePassesFilter(typeFilter, searchIndex[i].ty)\n-                    && results[fullId] === undefined) {\n-                    results[fullId] = {\n-                        id: i,\n-                        index: -1,\n-                        dontValidate: true,\n-                    };\n-                }\n-                if (in_args && results_in_args[fullId] === undefined) {\n-                    results_in_args[fullId] = {\n-                        id: i,\n-                        index: -1,\n-                        dontValidate: true,\n-                    };\n-                }\n-                if (returned && results_returned[fullId] === undefined) {\n-                    results_returned[fullId] = {\n-                        id: i,\n-                        index: -1,\n-                        dontValidate: true,\n-                    };\n+                    && typePassesFilter(typeFilter, searchIndex[i].ty)) {\n+                    addIntoResults(true, results, fullId, i, -1, 0);\n                 }\n+                addIntoResults(true, results_in_args, fullId, i, -1, in_args);\n+                addIntoResults(true, results_returned, fullId, i, -1, returned);\n             }\n             query.inputs = [val];\n             query.output = val;\n@@ -684,39 +715,23 @@ window.initSearch = function(rawSearchIndex) {\n                 fullId = ty.id;\n \n                 returned = checkReturned(ty, output, true, NO_TYPE_FILTER);\n-                if (output.name === \"*\" || returned) {\n+                if (output.name === \"*\" || returned === 0) {\n                     in_args = false;\n                     var is_module = false;\n \n                     if (input === \"*\") {\n                         is_module = true;\n                     } else {\n-                        var allFound = true;\n-                        for (it = 0, len = inputs.length; allFound && it < len; it++) {\n+                        var allFound = 0;\n+                        for (it = 0, len = inputs.length; allFound === 0 && it < len; it++) {\n                             allFound = checkType(type, inputs[it], true);\n                         }\n                         in_args = allFound;\n                     }\n-                    if (in_args) {\n-                        results_in_args[fullId] = {\n-                            id: i,\n-                            index: -1,\n-                            dontValidate: true,\n-                        };\n-                    }\n-                    if (returned) {\n-                        results_returned[fullId] = {\n-                            id: i,\n-                            index: -1,\n-                            dontValidate: true,\n-                        };\n-                    }\n+                    addIntoResults(true, results_in_args, fullId, i, -1, in_args);\n+                    addIntoResults(true, results_returned, fullId, i, -1, returned);\n                     if (is_module) {\n-                        results[fullId] = {\n-                            id: i,\n-                            index: -1,\n-                            dontValidate: true,\n-                        };\n+                        addIntoResults(true, results, fullId, i, -1, 0);\n                     }\n                 }\n             }\n@@ -788,41 +803,14 @@ window.initSearch = function(rawSearchIndex) {\n                         lev = 0;\n                     }\n                 }\n-                if (in_args <= MAX_LEV_DISTANCE) {\n-                    if (results_in_args[fullId] === undefined) {\n-                        results_in_args[fullId] = {\n-                            id: j,\n-                            index: index,\n-                            lev: in_args,\n-                        };\n-                    }\n-                    results_in_args[fullId].lev =\n-                        Math.min(results_in_args[fullId].lev, in_args);\n-                }\n-                if (returned <= MAX_LEV_DISTANCE) {\n-                    if (results_returned[fullId] === undefined) {\n-                        results_returned[fullId] = {\n-                            id: j,\n-                            index: index,\n-                            lev: returned,\n-                        };\n-                    }\n-                    results_returned[fullId].lev =\n-                        Math.min(results_returned[fullId].lev, returned);\n-                }\n+                addIntoResults(false, results_in_args, fullId, j, index, in_args);\n+                addIntoResults(false, results_returned, fullId, j, index, returned);\n                 if (typePassesFilter(typeFilter, ty.ty) &&\n                         (index !== -1 || lev <= MAX_LEV_DISTANCE)) {\n                     if (index !== -1 && paths.length < 2) {\n                         lev = 0;\n                     }\n-                    if (results[fullId] === undefined) {\n-                        results[fullId] = {\n-                            id: j,\n-                            index: index,\n-                            lev: lev,\n-                        };\n-                    }\n-                    results[fullId].lev = Math.min(results[fullId].lev, lev);\n+                    addIntoResults(false, results, fullId, j, index, lev);\n                 }\n             }\n         }"}]}