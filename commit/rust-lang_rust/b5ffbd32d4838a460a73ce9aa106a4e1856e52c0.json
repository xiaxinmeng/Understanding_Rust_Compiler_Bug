{"sha": "b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "node_id": "C_kwDOAAsO6NoAKGI1ZmZiZDMyZDQ4MzhhNDYwYTczY2U5YWExMDZhNGUxODU2ZTUyYzA", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-09-08T15:18:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-08T15:18:34Z"}, "message": "Rollup merge of #101424 - compiler-errors:operator-err-sugg, r=TaKO8Ki\n\nAdjust and slightly generalize operator error suggestion\n\n(in no particular order)\n* Stop passing around a whole extra `ProjectionPredicate`\n* Add spaces around `=` in `Trait<..., Output = Ty>` suggestion\n* Some code clean-ups, including\n    * add `lang_item_for_op` to turn a `Op` into a `DefId`\n    * avoid `SourceMap` because we don't really need to render an expr\n    * Remove `TypeParamVisitor` in favor of just checking `ty.has_param_types_or_consts` -- this acts a bit differently, but shouldn't cause erroneous suggestions (actually might generalize them a bit)\n* We now suggest `Output = Ty` in the `where` clause suggestion when we fail to add `Struct<T>` and `T`.\n\nI can split this out into more PRs if needed, but they're all just miscellaneous generalizations, changes, and nitpicks I saw when messing with this operator code.", "tree": {"sha": "1e905d691d34858fa9b1c8ec42085ada806826dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e905d691d34858fa9b1c8ec42085ada806826dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjGgfKCRBK7hj4Ov3rIwAASb8IAIKy/ZGNdtc1sDR8d+eT8IOD\nIvun1Hb8vqrS68CeKX4u//Igrvd9pqESdJHGzEwlF+csVmyYf6VCmE/9R0Erxzf5\ncVrFDlwt/uh8WnRyEl2WjQEIy1YvBIHgzB1UPy64CCYoO8Y+R7vYZntCkISX/RG2\ncWkw4zKLArq2oDsNDhW16c84jv6Q48MMLFbev3cIXMGRItwnRdXgB0FKddyGV2Sg\nT5PJ2AdaUyepVsEqzNM3ZvSr6VucGWxtT2+fPqz0yKF8r0acfrSzpEp9jysrNfrF\nGmLT9pWaVxKn7PgEsQQEzW/2P0YJNbJPY8CBW/w75pq3Q9WUsTyW3y8PQvXAaGQ=\n=gK/r\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e905d691d34858fa9b1c8ec42085ada806826dd\nparent 1561922a1279abbf8dbb3620b9bbe7f725853a86\nparent 48281b003ff84b230947f64aad9054113f757795\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1662650314 +0530\ncommitter GitHub <noreply@github.com> 1662650314 +0530\n\nRollup merge of #101424 - compiler-errors:operator-err-sugg, r=TaKO8Ki\n\nAdjust and slightly generalize operator error suggestion\n\n(in no particular order)\n* Stop passing around a whole extra `ProjectionPredicate`\n* Add spaces around `=` in `Trait<..., Output = Ty>` suggestion\n* Some code clean-ups, including\n    * add `lang_item_for_op` to turn a `Op` into a `DefId`\n    * avoid `SourceMap` because we don't really need to render an expr\n    * Remove `TypeParamVisitor` in favor of just checking `ty.has_param_types_or_consts` -- this acts a bit differently, but shouldn't cause erroneous suggestions (actually might generalize them a bit)\n* We now suggest `Output = Ty` in the `where` clause suggestion when we fail to add `Struct<T>` and `T`.\n\nI can split this out into more PRs if needed, but they're all just miscellaneous generalizations, changes, and nitpicks I saw when messing with this operator code.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "html_url": "https://github.com/rust-lang/rust/commit/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1561922a1279abbf8dbb3620b9bbe7f725853a86", "url": "https://api.github.com/repos/rust-lang/rust/commits/1561922a1279abbf8dbb3620b9bbe7f725853a86", "html_url": "https://github.com/rust-lang/rust/commit/1561922a1279abbf8dbb3620b9bbe7f725853a86"}, {"sha": "48281b003ff84b230947f64aad9054113f757795", "url": "https://api.github.com/repos/rust-lang/rust/commits/48281b003ff84b230947f64aad9054113f757795", "html_url": "https://github.com/rust-lang/rust/commit/48281b003ff84b230947f64aad9054113f757795"}], "stats": {"total": 488, "additions": 234, "deletions": 254}, "files": [{"sha": "a56fac7c4dd2ca8bd7b8a1beee419a7b195aff2d", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -12,7 +12,7 @@ pub mod util;\n use crate::infer::canonical::Canonical;\n use crate::ty::abstract_const::NotConstEvaluatable;\n use crate::ty::subst::SubstsRef;\n-use crate::ty::{self, AdtKind, Predicate, Ty, TyCtxt};\n+use crate::ty::{self, AdtKind, Ty, TyCtxt};\n \n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Applicability, Diagnostic};\n@@ -416,7 +416,7 @@ pub enum ObligationCauseCode<'tcx> {\n     BinOp {\n         rhs_span: Option<Span>,\n         is_lit: bool,\n-        output_pred: Option<Predicate<'tcx>>,\n+        output_ty: Option<Ty<'tcx>>,\n     },\n }\n "}, {"sha": "e4ad96b659b0813f4b20df58cb7fe146ab56ce91", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -102,13 +102,25 @@ pub fn suggest_arbitrary_trait_bound<'tcx>(\n     generics: &hir::Generics<'_>,\n     err: &mut Diagnostic,\n     trait_pred: PolyTraitPredicate<'tcx>,\n+    associated_ty: Option<(&'static str, Ty<'tcx>)>,\n ) -> bool {\n     if !trait_pred.is_suggestable(tcx, false) {\n         return false;\n     }\n \n     let param_name = trait_pred.skip_binder().self_ty().to_string();\n-    let constraint = trait_pred.print_modifiers_and_trait_path().to_string();\n+    let mut constraint = trait_pred.print_modifiers_and_trait_path().to_string();\n+\n+    if let Some((name, term)) = associated_ty {\n+        // FIXME: this case overlaps with code in TyCtxt::note_and_explain_type_err.\n+        // That should be extracted into a helper function.\n+        if constraint.ends_with('>') {\n+            constraint = format!(\"{}, {} = {}>\", &constraint[..constraint.len() - 1], name, term);\n+        } else {\n+            constraint.push_str(&format!(\"<{} = {}>\", name, term));\n+        }\n+    }\n+\n     let param = generics.params.iter().find(|p| p.name.ident().as_str() == param_name);\n \n     // Skip, there is a param named Self"}, {"sha": "ecbeb9d79b118923057e35e56b48e91f911e1de2", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -25,8 +25,7 @@ use rustc_middle::hir::map;\n use rustc_middle::ty::{\n     self, suggest_arbitrary_trait_bound, suggest_constraining_type_param, AdtKind, DefIdTree,\n     GeneratorDiagnosticData, GeneratorInteriorTypeCause, Infer, InferTy, IsSuggestable,\n-    ProjectionPredicate, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n-    TypeVisitable,\n+    ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable, TypeVisitable,\n };\n use rustc_middle::ty::{TypeAndMut, TypeckResults};\n use rustc_session::Limit;\n@@ -174,7 +173,7 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-        proj_pred: Option<ty::PolyProjectionPredicate<'tcx>>,\n+        associated_item: Option<(&'static str, Ty<'tcx>)>,\n         body_id: hir::HirId,\n     );\n \n@@ -467,7 +466,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         mut err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n-        proj_pred: Option<ty::PolyProjectionPredicate<'tcx>>,\n+        associated_ty: Option<(&'static str, Ty<'tcx>)>,\n         body_id: hir::HirId,\n     ) {\n         let trait_pred = self.resolve_numeric_literals_with_default(trait_pred);\n@@ -604,21 +603,18 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         trait_pred.print_modifiers_and_trait_path().to_string()\n                     );\n \n-                    if let Some(proj_pred) = proj_pred {\n-                        let ProjectionPredicate { projection_ty, term } = proj_pred.skip_binder();\n-                        let item = self.tcx.associated_item(projection_ty.item_def_id);\n-\n+                    if let Some((name, term)) = associated_ty {\n                         // FIXME: this case overlaps with code in TyCtxt::note_and_explain_type_err.\n                         // That should be extracted into a helper function.\n                         if constraint.ends_with('>') {\n                             constraint = format!(\n-                                \"{}, {}={}>\",\n+                                \"{}, {} = {}>\",\n                                 &constraint[..constraint.len() - 1],\n-                                item.name,\n+                                name,\n                                 term\n                             );\n                         } else {\n-                            constraint.push_str(&format!(\"<{}={}>\", item.name, term));\n+                            constraint.push_str(&format!(\"<{} = {}>\", name, term));\n                         }\n                     }\n \n@@ -648,7 +644,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     ..\n                 }) if !param_ty => {\n                     // Missing generic type parameter bound.\n-                    if suggest_arbitrary_trait_bound(self.tcx, generics, &mut err, trait_pred) {\n+                    if suggest_arbitrary_trait_bound(\n+                        self.tcx,\n+                        generics,\n+                        &mut err,\n+                        trait_pred,\n+                        associated_ty,\n+                    ) {\n                         return;\n                     }\n                 }"}, {"sha": "a40478db96901719f5392fff5481c634f393aaaa", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -409,7 +409,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     rhs_span: opt_input_expr.map(|expr| expr.span),\n                     is_lit: opt_input_expr\n                         .map_or(false, |expr| matches!(expr.kind, ExprKind::Lit(_))),\n-                    output_pred: None,\n+                    output_ty: None,\n                 },\n             ),\n             self.param_env,"}, {"sha": "249e9c66ba72ad958334b0613d826abefdaee4a7", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -20,10 +20,7 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::{self, InferOk};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n-use rustc_middle::ty::{\n-    self, AssocKind, DefIdTree, GenericParamDefKind, ProjectionPredicate, ProjectionTy,\n-    ToPredicate, Ty, TypeVisitable,\n-};\n+use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, ToPredicate, Ty, TypeVisitable};\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n@@ -337,22 +334,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Construct an obligation\n         let poly_trait_ref = ty::Binder::dummy(trait_ref);\n-        let opt_output_ty =\n-            expected.only_has_type(self).and_then(|ty| (!ty.needs_infer()).then(|| ty));\n-        let opt_output_assoc_item = self.tcx.associated_items(trait_def_id).find_by_name_and_kind(\n-            self.tcx,\n-            Ident::from_str(\"Output\"),\n-            AssocKind::Type,\n-            trait_def_id,\n-        );\n-        let output_pred =\n-            opt_output_ty.zip(opt_output_assoc_item).map(|(output_ty, output_assoc_item)| {\n-                ty::Binder::dummy(ty::PredicateKind::Projection(ProjectionPredicate {\n-                    projection_ty: ProjectionTy { substs, item_def_id: output_assoc_item.def_id },\n-                    term: output_ty.into(),\n-                }))\n-                .to_predicate(self.tcx)\n-            });\n+        let output_ty = expected.only_has_type(self).and_then(|ty| (!ty.needs_infer()).then(|| ty));\n \n         (\n             traits::Obligation::new(\n@@ -363,7 +345,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         rhs_span: opt_input_expr.map(|expr| expr.span),\n                         is_lit: opt_input_expr\n                             .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n-                        output_pred,\n+                        output_ty,\n                     },\n                 ),\n                 self.param_env,\n@@ -518,7 +500,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     rhs_span: opt_input_expr.map(|expr| expr.span),\n                     is_lit: opt_input_expr\n                         .map_or(false, |expr| matches!(expr.kind, hir::ExprKind::Lit(_))),\n-                    output_pred: None,\n+                    output_ty: None,\n                 },\n             )\n         } else {"}, {"sha": "4754717c29aba777494a494f9822e8f7b9cfdad9", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 149, "deletions": 203, "changes": 352, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -11,9 +11,8 @@ use rustc_infer::traits::ObligationCauseCode;\n use rustc_middle::ty::adjustment::{\n     Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability,\n };\n-use rustc_middle::ty::{\n-    self, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitor,\n-};\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n+use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFolder, TypeSuperFoldable, TypeVisitable};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n@@ -22,8 +21,6 @@ use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt as\n use rustc_trait_selection::traits::{FulfillmentError, TraitEngine, TraitEngineExt};\n use rustc_type_ir::sty::TyKind::*;\n \n-use std::ops::ControlFlow;\n-\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Checks a `a <op>= b`\n     pub fn check_binop_assign(\n@@ -313,8 +310,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // error types are considered \"builtin\"\n             Err(_) if lhs_ty.references_error() || rhs_ty.references_error() => self.tcx.ty_error(),\n             Err(errors) => {\n-                let source_map = self.tcx.sess.source_map();\n-                let (mut err, missing_trait, use_output) = match is_assign {\n+                let (_, trait_def_id) =\n+                    lang_item_for_op(self.tcx, Op::Binary(op, is_assign), op.span);\n+                let missing_trait = trait_def_id\n+                    .map(|def_id| with_no_trimmed_paths!(self.tcx.def_path_str(def_id)));\n+                let (mut err, output_def_id) = match is_assign {\n                     IsAssign::Yes => {\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n@@ -328,112 +328,63 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             lhs_expr.span,\n                             format!(\"cannot use `{}=` on type `{}`\", op.node.as_str(), lhs_ty),\n                         );\n-                        let missing_trait = match op.node {\n-                            hir::BinOpKind::Add => Some(\"std::ops::AddAssign\"),\n-                            hir::BinOpKind::Sub => Some(\"std::ops::SubAssign\"),\n-                            hir::BinOpKind::Mul => Some(\"std::ops::MulAssign\"),\n-                            hir::BinOpKind::Div => Some(\"std::ops::DivAssign\"),\n-                            hir::BinOpKind::Rem => Some(\"std::ops::RemAssign\"),\n-                            hir::BinOpKind::BitAnd => Some(\"std::ops::BitAndAssign\"),\n-                            hir::BinOpKind::BitXor => Some(\"std::ops::BitXorAssign\"),\n-                            hir::BinOpKind::BitOr => Some(\"std::ops::BitOrAssign\"),\n-                            hir::BinOpKind::Shl => Some(\"std::ops::ShlAssign\"),\n-                            hir::BinOpKind::Shr => Some(\"std::ops::ShrAssign\"),\n-                            _ => None,\n-                        };\n                         self.note_unmet_impls_on_type(&mut err, errors);\n-                        (err, missing_trait, false)\n+                        (err, None)\n                     }\n                     IsAssign::No => {\n-                        let (message, missing_trait, use_output) = match op.node {\n-                            hir::BinOpKind::Add => (\n-                                format!(\"cannot add `{rhs_ty}` to `{lhs_ty}`\"),\n-                                Some(\"std::ops::Add\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Sub => (\n-                                format!(\"cannot subtract `{rhs_ty}` from `{lhs_ty}`\"),\n-                                Some(\"std::ops::Sub\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Mul => (\n-                                format!(\"cannot multiply `{lhs_ty}` by `{rhs_ty}`\"),\n-                                Some(\"std::ops::Mul\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Div => (\n-                                format!(\"cannot divide `{lhs_ty}` by `{rhs_ty}`\"),\n-                                Some(\"std::ops::Div\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Rem => (\n-                                format!(\"cannot mod `{lhs_ty}` by `{rhs_ty}`\"),\n-                                Some(\"std::ops::Rem\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::BitAnd => (\n-                                format!(\"no implementation for `{lhs_ty} & {rhs_ty}`\"),\n-                                Some(\"std::ops::BitAnd\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::BitXor => (\n-                                format!(\"no implementation for `{lhs_ty} ^ {rhs_ty}`\"),\n-                                Some(\"std::ops::BitXor\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::BitOr => (\n-                                format!(\"no implementation for `{lhs_ty} | {rhs_ty}`\"),\n-                                Some(\"std::ops::BitOr\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Shl => (\n-                                format!(\"no implementation for `{lhs_ty} << {rhs_ty}`\"),\n-                                Some(\"std::ops::Shl\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Shr => (\n-                                format!(\"no implementation for `{lhs_ty} >> {rhs_ty}`\"),\n-                                Some(\"std::ops::Shr\"),\n-                                true,\n-                            ),\n-                            hir::BinOpKind::Eq | hir::BinOpKind::Ne => (\n-                                format!(\n-                                    \"binary operation `{}` cannot be applied to type `{}`\",\n-                                    op.node.as_str(),\n-                                    lhs_ty\n-                                ),\n-                                Some(\"std::cmp::PartialEq\"),\n-                                false,\n-                            ),\n-                            hir::BinOpKind::Lt\n-                            | hir::BinOpKind::Le\n-                            | hir::BinOpKind::Gt\n-                            | hir::BinOpKind::Ge => (\n-                                format!(\n-                                    \"binary operation `{}` cannot be applied to type `{}`\",\n-                                    op.node.as_str(),\n-                                    lhs_ty\n-                                ),\n-                                Some(\"std::cmp::PartialOrd\"),\n-                                false,\n-                            ),\n-                            _ => (\n-                                format!(\n-                                    \"binary operation `{}` cannot be applied to type `{}`\",\n-                                    op.node.as_str(),\n-                                    lhs_ty\n-                                ),\n-                                None,\n-                                false,\n+                        let message = match op.node {\n+                            hir::BinOpKind::Add => {\n+                                format!(\"cannot add `{rhs_ty}` to `{lhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Sub => {\n+                                format!(\"cannot subtract `{rhs_ty}` from `{lhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Mul => {\n+                                format!(\"cannot multiply `{lhs_ty}` by `{rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Div => {\n+                                format!(\"cannot divide `{lhs_ty}` by `{rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Rem => {\n+                                format!(\"cannot mod `{lhs_ty}` by `{rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::BitAnd => {\n+                                format!(\"no implementation for `{lhs_ty} & {rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::BitXor => {\n+                                format!(\"no implementation for `{lhs_ty} ^ {rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::BitOr => {\n+                                format!(\"no implementation for `{lhs_ty} | {rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Shl => {\n+                                format!(\"no implementation for `{lhs_ty} << {rhs_ty}`\")\n+                            }\n+                            hir::BinOpKind::Shr => {\n+                                format!(\"no implementation for `{lhs_ty} >> {rhs_ty}`\")\n+                            }\n+                            _ => format!(\n+                                \"binary operation `{}` cannot be applied to type `{}`\",\n+                                op.node.as_str(),\n+                                lhs_ty\n                             ),\n                         };\n+                        let output_def_id = trait_def_id.and_then(|def_id| {\n+                            self.tcx\n+                                .associated_item_def_ids(def_id)\n+                                .iter()\n+                                .find(|item_def_id| {\n+                                    self.tcx.associated_item(*item_def_id).name == sym::Output\n+                                })\n+                                .cloned()\n+                        });\n                         let mut err = struct_span_err!(self.tcx.sess, op.span, E0369, \"{message}\");\n                         if !lhs_expr.span.eq(&rhs_expr.span) {\n                             err.span_label(lhs_expr.span, lhs_ty.to_string());\n                             err.span_label(rhs_expr.span, rhs_ty.to_string());\n                         }\n                         self.note_unmet_impls_on_type(&mut err, errors);\n-                        (err, missing_trait, use_output)\n+                        (err, output_def_id)\n                     }\n                 };\n \n@@ -448,24 +399,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         )\n                         .is_ok()\n                     {\n-                        if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n-                            let msg = &format!(\n-                                \"`{}{}` can be used on `{}`, you can dereference `{}`\",\n-                                op.node.as_str(),\n-                                match is_assign {\n-                                    IsAssign::Yes => \"=\",\n-                                    IsAssign::No => \"\",\n-                                },\n-                                lhs_deref_ty.peel_refs(),\n-                                lstring,\n-                            );\n-                            err.span_suggestion_verbose(\n-                                lhs_expr.span.shrink_to_lo(),\n-                                msg,\n-                                \"*\",\n-                                rustc_errors::Applicability::MachineApplicable,\n-                            );\n-                        }\n+                        let msg = &format!(\n+                            \"`{}{}` can be used on `{}` if you dereference the left-hand side\",\n+                            op.node.as_str(),\n+                            match is_assign {\n+                                IsAssign::Yes => \"=\",\n+                                IsAssign::No => \"\",\n+                            },\n+                            lhs_deref_ty,\n+                        );\n+                        err.span_suggestion_verbose(\n+                            lhs_expr.span.shrink_to_lo(),\n+                            msg,\n+                            \"*\",\n+                            rustc_errors::Applicability::MachineApplicable,\n+                        );\n                     }\n                 };\n \n@@ -514,9 +462,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n \n                 if let Some(missing_trait) = missing_trait {\n-                    let mut visitor = TypeParamVisitor(vec![]);\n-                    visitor.visit_ty(lhs_ty);\n-\n                     if op.node == hir::BinOpKind::Add\n                         && self.check_str_addition(\n                             lhs_expr, rhs_expr, lhs_ty, rhs_ty, &mut err, is_assign, op,\n@@ -525,7 +470,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // This has nothing here because it means we did string\n                         // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                         // we don't want the note in the else clause to be emitted\n-                    } else if let [ty] = &visitor.0[..] {\n+                    } else if lhs_ty.has_param_types_or_consts() {\n                         // Look for a TraitPredicate in the Fulfillment errors,\n                         // and use it to generate a suggestion.\n                         //\n@@ -547,25 +492,34 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 if let Some(trait_pred) =\n                                     error.obligation.predicate.to_opt_poly_trait_pred()\n                                 {\n-                                    let proj_pred = match error.obligation.cause.code() {\n+                                    let output_associated_item = match error.obligation.cause.code()\n+                                    {\n                                         ObligationCauseCode::BinOp {\n-                                            output_pred: Some(output_pred),\n+                                            output_ty: Some(output_ty),\n                                             ..\n-                                        } if use_output => {\n-                                            output_pred.to_opt_poly_projection_pred()\n+                                        } => {\n+                                            // Make sure that we're attaching `Output = ..` to the right trait predicate\n+                                            if let Some(output_def_id) = output_def_id\n+                                                && let Some(trait_def_id) = trait_def_id\n+                                                && self.tcx.parent(output_def_id) == trait_def_id\n+                                            {\n+                                                Some((\"Output\", *output_ty))\n+                                            } else {\n+                                                None\n+                                            }\n                                         }\n                                         _ => None,\n                                     };\n \n                                     self.suggest_restricting_param_bound(\n                                         &mut err,\n                                         trait_pred,\n-                                        proj_pred,\n+                                        output_associated_item,\n                                         self.body_id,\n                                     );\n                                 }\n                             }\n-                        } else if *ty != lhs_ty {\n+                        } else {\n                             // When we know that a missing bound is responsible, we don't show\n                             // this note as it is redundant.\n                             err.note(&format!(\n@@ -702,14 +656,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         format!(\"cannot apply unary operator `{}`\", op.as_str()),\n                     );\n \n-                    let mut visitor = TypeParamVisitor(vec![]);\n-                    visitor.visit_ty(operand_ty);\n-                    if let [_] = &visitor.0[..] && let ty::Param(_) = *operand_ty.kind() {\n-                        let predicates = errors\n-                            .iter()\n-                            .filter_map(|error| {\n-                                error.obligation.predicate.to_opt_poly_trait_pred()\n-                            });\n+                    if operand_ty.has_param_types_or_consts() {\n+                        let predicates = errors.iter().filter_map(|error| {\n+                            error.obligation.predicate.to_opt_poly_trait_pred()\n+                        });\n                         for pred in predicates {\n                             self.suggest_restricting_param_bound(\n                                 &mut err,\n@@ -777,64 +727,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         op: Op,\n         expected: Expectation<'tcx>,\n     ) -> Result<MethodCallee<'tcx>, Vec<FulfillmentError<'tcx>>> {\n-        let lang = self.tcx.lang_items();\n-\n         let span = match op {\n             Op::Binary(op, _) => op.span,\n             Op::Unary(_, span) => span,\n         };\n-        let (opname, trait_did) = if let Op::Binary(op, IsAssign::Yes) = op {\n-            match op.node {\n-                hir::BinOpKind::Add => (sym::add_assign, lang.add_assign_trait()),\n-                hir::BinOpKind::Sub => (sym::sub_assign, lang.sub_assign_trait()),\n-                hir::BinOpKind::Mul => (sym::mul_assign, lang.mul_assign_trait()),\n-                hir::BinOpKind::Div => (sym::div_assign, lang.div_assign_trait()),\n-                hir::BinOpKind::Rem => (sym::rem_assign, lang.rem_assign_trait()),\n-                hir::BinOpKind::BitXor => (sym::bitxor_assign, lang.bitxor_assign_trait()),\n-                hir::BinOpKind::BitAnd => (sym::bitand_assign, lang.bitand_assign_trait()),\n-                hir::BinOpKind::BitOr => (sym::bitor_assign, lang.bitor_assign_trait()),\n-                hir::BinOpKind::Shl => (sym::shl_assign, lang.shl_assign_trait()),\n-                hir::BinOpKind::Shr => (sym::shr_assign, lang.shr_assign_trait()),\n-                hir::BinOpKind::Lt\n-                | hir::BinOpKind::Le\n-                | hir::BinOpKind::Ge\n-                | hir::BinOpKind::Gt\n-                | hir::BinOpKind::Eq\n-                | hir::BinOpKind::Ne\n-                | hir::BinOpKind::And\n-                | hir::BinOpKind::Or => {\n-                    span_bug!(span, \"impossible assignment operation: {}=\", op.node.as_str())\n-                }\n-            }\n-        } else if let Op::Binary(op, IsAssign::No) = op {\n-            match op.node {\n-                hir::BinOpKind::Add => (sym::add, lang.add_trait()),\n-                hir::BinOpKind::Sub => (sym::sub, lang.sub_trait()),\n-                hir::BinOpKind::Mul => (sym::mul, lang.mul_trait()),\n-                hir::BinOpKind::Div => (sym::div, lang.div_trait()),\n-                hir::BinOpKind::Rem => (sym::rem, lang.rem_trait()),\n-                hir::BinOpKind::BitXor => (sym::bitxor, lang.bitxor_trait()),\n-                hir::BinOpKind::BitAnd => (sym::bitand, lang.bitand_trait()),\n-                hir::BinOpKind::BitOr => (sym::bitor, lang.bitor_trait()),\n-                hir::BinOpKind::Shl => (sym::shl, lang.shl_trait()),\n-                hir::BinOpKind::Shr => (sym::shr, lang.shr_trait()),\n-                hir::BinOpKind::Lt => (sym::lt, lang.partial_ord_trait()),\n-                hir::BinOpKind::Le => (sym::le, lang.partial_ord_trait()),\n-                hir::BinOpKind::Ge => (sym::ge, lang.partial_ord_trait()),\n-                hir::BinOpKind::Gt => (sym::gt, lang.partial_ord_trait()),\n-                hir::BinOpKind::Eq => (sym::eq, lang.eq_trait()),\n-                hir::BinOpKind::Ne => (sym::ne, lang.eq_trait()),\n-                hir::BinOpKind::And | hir::BinOpKind::Or => {\n-                    span_bug!(span, \"&& and || are not overloadable\")\n-                }\n-            }\n-        } else if let Op::Unary(hir::UnOp::Not, _) = op {\n-            (sym::not, lang.not_trait())\n-        } else if let Op::Unary(hir::UnOp::Neg, _) = op {\n-            (sym::neg, lang.neg_trait())\n-        } else {\n-            bug!(\"lookup_op_method: op not supported: {:?}\", op)\n-        };\n+        let (opname, trait_did) = lang_item_for_op(self.tcx, op, span);\n \n         debug!(\n             \"lookup_op_method(lhs_ty={:?}, op={:?}, opname={:?}, trait_did={:?})\",\n@@ -895,6 +792,66 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n }\n \n+fn lang_item_for_op(\n+    tcx: TyCtxt<'_>,\n+    op: Op,\n+    span: Span,\n+) -> (rustc_span::Symbol, Option<hir::def_id::DefId>) {\n+    let lang = tcx.lang_items();\n+    if let Op::Binary(op, IsAssign::Yes) = op {\n+        match op.node {\n+            hir::BinOpKind::Add => (sym::add_assign, lang.add_assign_trait()),\n+            hir::BinOpKind::Sub => (sym::sub_assign, lang.sub_assign_trait()),\n+            hir::BinOpKind::Mul => (sym::mul_assign, lang.mul_assign_trait()),\n+            hir::BinOpKind::Div => (sym::div_assign, lang.div_assign_trait()),\n+            hir::BinOpKind::Rem => (sym::rem_assign, lang.rem_assign_trait()),\n+            hir::BinOpKind::BitXor => (sym::bitxor_assign, lang.bitxor_assign_trait()),\n+            hir::BinOpKind::BitAnd => (sym::bitand_assign, lang.bitand_assign_trait()),\n+            hir::BinOpKind::BitOr => (sym::bitor_assign, lang.bitor_assign_trait()),\n+            hir::BinOpKind::Shl => (sym::shl_assign, lang.shl_assign_trait()),\n+            hir::BinOpKind::Shr => (sym::shr_assign, lang.shr_assign_trait()),\n+            hir::BinOpKind::Lt\n+            | hir::BinOpKind::Le\n+            | hir::BinOpKind::Ge\n+            | hir::BinOpKind::Gt\n+            | hir::BinOpKind::Eq\n+            | hir::BinOpKind::Ne\n+            | hir::BinOpKind::And\n+            | hir::BinOpKind::Or => {\n+                span_bug!(span, \"impossible assignment operation: {}=\", op.node.as_str())\n+            }\n+        }\n+    } else if let Op::Binary(op, IsAssign::No) = op {\n+        match op.node {\n+            hir::BinOpKind::Add => (sym::add, lang.add_trait()),\n+            hir::BinOpKind::Sub => (sym::sub, lang.sub_trait()),\n+            hir::BinOpKind::Mul => (sym::mul, lang.mul_trait()),\n+            hir::BinOpKind::Div => (sym::div, lang.div_trait()),\n+            hir::BinOpKind::Rem => (sym::rem, lang.rem_trait()),\n+            hir::BinOpKind::BitXor => (sym::bitxor, lang.bitxor_trait()),\n+            hir::BinOpKind::BitAnd => (sym::bitand, lang.bitand_trait()),\n+            hir::BinOpKind::BitOr => (sym::bitor, lang.bitor_trait()),\n+            hir::BinOpKind::Shl => (sym::shl, lang.shl_trait()),\n+            hir::BinOpKind::Shr => (sym::shr, lang.shr_trait()),\n+            hir::BinOpKind::Lt => (sym::lt, lang.partial_ord_trait()),\n+            hir::BinOpKind::Le => (sym::le, lang.partial_ord_trait()),\n+            hir::BinOpKind::Ge => (sym::ge, lang.partial_ord_trait()),\n+            hir::BinOpKind::Gt => (sym::gt, lang.partial_ord_trait()),\n+            hir::BinOpKind::Eq => (sym::eq, lang.eq_trait()),\n+            hir::BinOpKind::Ne => (sym::ne, lang.eq_trait()),\n+            hir::BinOpKind::And | hir::BinOpKind::Or => {\n+                span_bug!(span, \"&& and || are not overloadable\")\n+            }\n+        }\n+    } else if let Op::Unary(hir::UnOp::Not, _) = op {\n+        (sym::not, lang.not_trait())\n+    } else if let Op::Unary(hir::UnOp::Neg, _) = op {\n+        (sym::neg, lang.neg_trait())\n+    } else {\n+        bug!(\"lookup_op_method: op not supported: {:?}\", op)\n+    }\n+}\n+\n // Binary operator categories. These categories summarize the behavior\n // with respect to the builtin operations supported.\n enum BinOpCategory {\n@@ -1017,17 +974,6 @@ fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>, rhs: Ty<'tcx>, op: hir::BinOp) -> bool\n     }\n }\n \n-struct TypeParamVisitor<'tcx>(Vec<Ty<'tcx>>);\n-\n-impl<'tcx> TypeVisitor<'tcx> for TypeParamVisitor<'tcx> {\n-    fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if let ty::Param(_) = ty.kind() {\n-            self.0.push(ty);\n-        }\n-        ty.super_visit_with(self)\n-    }\n-}\n-\n struct TypeParamEraser<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, Span);\n \n impl<'tcx> TypeFolder<'tcx> for TypeParamEraser<'_, 'tcx> {"}, {"sha": "34826d2f4bf7ab2932657a08c53a606ded25d406", "filename": "src/test/ui/binop/binary-op-on-double-ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Fbinop%2Fbinary-op-on-double-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Fbinop%2Fbinary-op-on-double-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinary-op-on-double-ref.stderr?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -6,7 +6,7 @@ LL |         x % 2 == 0\n    |         |\n    |         &&{integer}\n    |\n-help: `%` can be used on `{integer}`, you can dereference `x`\n+help: `%` can be used on `&{integer}` if you dereference the left-hand side\n    |\n LL |         *x % 2 == 0\n    |         +"}, {"sha": "ee758f19ec105345066f5437ce2e17aaf125cc63", "filename": "src/test/ui/generic-associated-types/missing-bounds.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.fixed?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -24,7 +24,7 @@ impl<B: Add + Add<Output = B>> Add for C<B> {\n \n struct D<B>(B);\n \n-impl<B: std::ops::Add<Output=B>> Add for D<B> {\n+impl<B: std::ops::Add<Output = B>> Add for D<B> {\n     type Output = Self;\n \n     fn add(self, rhs: Self) -> Self {"}, {"sha": "c913483a8747c15ef849f859570306d64a177578", "filename": "src/test/ui/generic-associated-types/missing-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmissing-bounds.stderr?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -66,8 +66,8 @@ LL |         Self(self.0 + rhs.0)\n    |\n help: consider restricting type parameter `B`\n    |\n-LL | impl<B: std::ops::Add<Output=B>> Add for D<B> {\n-   |       +++++++++++++++++++++++++\n+LL | impl<B: std::ops::Add<Output = B>> Add for D<B> {\n+   |       +++++++++++++++++++++++++++\n \n error[E0308]: mismatched types\n   --> $DIR/missing-bounds.rs:42:14"}, {"sha": "1e7569fa45106c60b8660a83af58f6c6c3757648", "filename": "src/test/ui/suggestions/issue-97677.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.fixed?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-fn add_ten<N: std::ops::Add<i32, Output=N>>(n: N) -> N {\n+fn add_ten<N: std::ops::Add<i32, Output = N>>(n: N) -> N {\n     n + 10\n     //~^ ERROR cannot add `{integer}` to `N`\n }"}, {"sha": "575d79267f20d718957f456241a28b7ec1c3d66a", "filename": "src/test/ui/suggestions/issue-97677.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-97677.stderr?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -8,8 +8,8 @@ LL |     n + 10\n    |\n help: consider restricting type parameter `N`\n    |\n-LL | fn add_ten<N: std::ops::Add<i32, Output=N>>(n: N) -> N {\n-   |             ++++++++++++++++++++++++++++++\n+LL | fn add_ten<N: std::ops::Add<i32, Output = N>>(n: N) -> N {\n+   |             ++++++++++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "60f5ba45c268d1ae6463509a16cc32c8b4f0e5e1", "filename": "src/test/ui/suggestions/restrict-type-not-param.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-not-param.rs?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -0,0 +1,12 @@\n+use std::ops::Add;\n+\n+struct Wrapper<T>(T);\n+\n+trait Foo {}\n+\n+fn qux<T>(a: Wrapper<T>, b: T) -> T {\n+    a + b\n+    //~^ ERROR cannot add `T` to `Wrapper<T>`\n+}\n+\n+fn main() {}"}, {"sha": "e7d9c5ecbe48208a720fac6deb23cfff4778b96a", "filename": "src/test/ui/suggestions/restrict-type-not-param.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-not-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-not-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Frestrict-type-not-param.stderr?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -0,0 +1,26 @@\n+error[E0369]: cannot add `T` to `Wrapper<T>`\n+  --> $DIR/restrict-type-not-param.rs:8:7\n+   |\n+LL |     a + b\n+   |     - ^ - T\n+   |     |\n+   |     Wrapper<T>\n+   |\n+note: an implementation of `Add<_>` might be missing for `Wrapper<T>`\n+  --> $DIR/restrict-type-not-param.rs:3:1\n+   |\n+LL | struct Wrapper<T>(T);\n+   | ^^^^^^^^^^^^^^^^^ must implement `Add<_>`\n+note: the following trait must be implemented\n+  --> $SRC_DIR/core/src/ops/arith.rs:LL:COL\n+   |\n+LL | pub trait Add<Rhs = Self> {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n+   |\n+LL | fn qux<T>(a: Wrapper<T>, b: T) -> T where Wrapper<T>: Add<T, Output = T> {\n+   |                                     ++++++++++++++++++++++++++++++++++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}, {"sha": "fe5e1d6d2854de0b98f0588d188734ff3404213b", "filename": "src/test/ui/traits/resolution-in-overloaded-op.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fresolution-in-overloaded-op.stderr?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -8,8 +8,8 @@ LL |     a * b\n    |\n help: consider introducing a `where` clause, but there might be an alternative better way to express this requirement\n    |\n-LL | fn foo<T: MyMul<f64, f64>>(a: &T, b: f64) -> f64 where &T: Mul<f64> {\n-   |                                                  ++++++++++++++++++\n+LL | fn foo<T: MyMul<f64, f64>>(a: &T, b: f64) -> f64 where &T: Mul<f64, Output = f64> {\n+   |                                                  ++++++++++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "e394cf8206edef45077760f28886f310e09c0e3c", "filename": "src/test/ui/typeck/assign-non-lval-derefmut.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.stderr?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -19,7 +19,7 @@ LL |     x.lock().unwrap() += 1;\n    |     |\n    |     cannot use `+=` on type `MutexGuard<'_, usize>`\n    |\n-help: `+=` can be used on `usize`, you can dereference `x.lock().unwrap()`\n+help: `+=` can be used on `usize` if you dereference the left-hand side\n    |\n LL |     *x.lock().unwrap() += 1;\n    |     +\n@@ -47,7 +47,7 @@ LL |     y += 1;\n    |     |\n    |     cannot use `+=` on type `MutexGuard<'_, usize>`\n    |\n-help: `+=` can be used on `usize`, you can dereference `y`\n+help: `+=` can be used on `usize` if you dereference the left-hand side\n    |\n LL |     *y += 1;\n    |     +"}, {"sha": "cbdc960baab8e7cafaa456825299b800c3c122ad", "filename": "src/test/ui/typeck/assign-non-lval-mut-ref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b5ffbd32d4838a460a73ce9aa106a4e1856e52c0/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.stderr?ref=b5ffbd32d4838a460a73ce9aa106a4e1856e52c0", "patch": "@@ -19,7 +19,7 @@ LL |     x.last_mut().unwrap() += 1;\n    |     |\n    |     cannot use `+=` on type `&mut usize`\n    |\n-help: `+=` can be used on `usize`, you can dereference `x.last_mut().unwrap()`\n+help: `+=` can be used on `usize` if you dereference the left-hand side\n    |\n LL |     *x.last_mut().unwrap() += 1;\n    |     +\n@@ -45,7 +45,7 @@ LL |     y += 1;\n    |     |\n    |     cannot use `+=` on type `&mut usize`\n    |\n-help: `+=` can be used on `usize`, you can dereference `y`\n+help: `+=` can be used on `usize` if you dereference the left-hand side\n    |\n LL |     *y += 1;\n    |     +"}]}