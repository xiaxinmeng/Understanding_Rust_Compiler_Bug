{"sha": "b88083a58c557d7f7f2289333f45944785465cf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ODA4M2E1OGM1NTdkN2Y3ZjIyODkzMzNmNDU5NDQ3ODU0NjVjZjE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-27T12:21:26Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-25T10:23:36Z"}, "message": "Use OwnerNode in indexing.", "tree": {"sha": "bf6729b533d7cb6300f130e32095a3cf9c0c92ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf6729b533d7cb6300f130e32095a3cf9c0c92ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b88083a58c557d7f7f2289333f45944785465cf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b88083a58c557d7f7f2289333f45944785465cf1", "html_url": "https://github.com/rust-lang/rust/commit/b88083a58c557d7f7f2289333f45944785465cf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b88083a58c557d7f7f2289333f45944785465cf1/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fee421685d9b29a7a865a13dc1c5a76816bcf417", "url": "https://api.github.com/repos/rust-lang/rust/commits/fee421685d9b29a7a865a13dc1c5a76816bcf417", "html_url": "https://github.com/rust-lang/rust/commit/fee421685d9b29a7a865a13dc1c5a76816bcf417"}], "stats": {"total": 163, "additions": 57, "deletions": 106}, "files": [{"sha": "0eb0c3eca4e3f226c0b2883a4a90d73f11c13887", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 50, "deletions": 103, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/b88083a58c557d7f7f2289333f45944785465cf1/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88083a58c557d7f7f2289333f45944785465cf1/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=b88083a58c557d7f7f2289333f45944785465cf1", "patch": "@@ -7,7 +7,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir as hir;\n use rustc_hir::def_id::LocalDefId;\n-use rustc_hir::def_id::CRATE_DEF_INDEX;\n+use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_hir::definitions;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::*;\n@@ -75,26 +75,20 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         arena: &'hir Arena<'hir>,\n         krate: &'hir Crate<'hir>,\n         definitions: &'a definitions::Definitions,\n-        mut hcx: StableHashingContext<'a>,\n+        hcx: StableHashingContext<'a>,\n     ) -> NodeCollector<'a, 'hir> {\n-        let hash = hash_body(&mut hcx, krate.module());\n-\n         let mut collector = NodeCollector {\n             arena,\n             krate,\n             source_map: sess.source_map(),\n             parent_node: hir::CRATE_HIR_ID,\n-            current_dep_node_owner: LocalDefId { local_def_index: CRATE_DEF_INDEX },\n+            current_dep_node_owner: CRATE_DEF_ID,\n             definitions,\n             hcx,\n             map: IndexVec::from_fn_n(|_| None, definitions.def_index_count()),\n             parenting: FxHashMap::default(),\n         };\n-        collector.insert_entry(\n-            hir::CRATE_HIR_ID,\n-            Entry { parent: hir::CRATE_HIR_ID, node: Node::Crate(&krate.module()) },\n-            hash,\n-        );\n+        collector.insert_owner(CRATE_DEF_ID, OwnerNode::Crate(krate.module()));\n \n         collector\n     }\n@@ -108,53 +102,20 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         IndexedHir { map: self.map, parenting: self.parenting }\n     }\n \n-    fn insert_entry(&mut self, id: HirId, entry: Entry<'hir>, hash: Fingerprint) {\n-        let i = id.local_id.as_u32() as usize;\n-\n-        let arena = self.arena;\n-\n-        let data = &mut self.map[id.owner];\n-\n-        if i == 0 {\n-            debug_assert!(data.is_none());\n-            *data = Some(arena.alloc(OwnerNodes {\n-                hash,\n-                nodes: IndexVec::new(),\n-                bodies: FxHashMap::default(),\n-            }));\n-\n-            let dk_parent = self.definitions.def_key(id.owner).parent;\n-            if let Some(dk_parent) = dk_parent {\n-                let dk_parent = LocalDefId { local_def_index: dk_parent };\n-                let dk_parent = self.definitions.local_def_id_to_hir_id(dk_parent);\n-                if dk_parent.owner != entry.parent.owner {\n-                    panic!(\n-                        \"Different parents for {:?} => dk_parent={:?} actual={:?}\",\n-                        id.owner, dk_parent, entry.parent,\n-                    )\n-                }\n-\n-                debug_assert_eq!(self.parenting.get(&id.owner), Some(&entry.parent));\n-            }\n-        } else {\n-            debug_assert_eq!(entry.parent.owner, id.owner);\n-        }\n+    fn insert_owner(&mut self, owner: LocalDefId, node: OwnerNode<'hir>) {\n+        let hash = hash_body(&mut self.hcx, node);\n \n-        let data = data.as_mut().unwrap();\n+        let mut nodes = IndexVec::new();\n+        nodes.push(Some(ParentedNode { parent: ItemLocalId::new(0), node: node.into() }));\n \n-        insert_vec_map(\n-            &mut data.nodes,\n-            id.local_id,\n-            ParentedNode { parent: entry.parent.local_id, node: entry.node },\n-        );\n+        debug_assert!(self.map[owner].is_none());\n+        self.map[owner] =\n+            Some(self.arena.alloc(OwnerNodes { hash, nodes, bodies: FxHashMap::default() }));\n     }\n \n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {\n-        self.insert_with_hash(span, hir_id, node, Fingerprint::ZERO)\n-    }\n-\n-    fn insert_with_hash(&mut self, span: Span, hir_id: HirId, node: Node<'hir>, hash: Fingerprint) {\n-        let entry = Entry { parent: self.parent_node, node };\n+        debug_assert_eq!(self.current_dep_node_owner, hir_id.owner);\n+        debug_assert_ne!(hir_id.local_id.as_u32(), 0);\n \n         // Make sure that the DepNode of some node coincides with the HirId\n         // owner of that node.\n@@ -181,7 +142,14 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             }\n         }\n \n-        self.insert_entry(hir_id, entry, hash);\n+        let nodes = self.map[hir_id.owner].as_mut().unwrap();\n+\n+        debug_assert_eq!(self.parent_node.owner, self.current_dep_node_owner);\n+        insert_vec_map(\n+            &mut nodes.nodes,\n+            hir_id.local_id,\n+            ParentedNode { parent: self.parent_node.local_id, node: node },\n+        );\n     }\n \n     fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_node_id: HirId, f: F) {\n@@ -191,21 +159,15 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         self.parent_node = parent_node;\n     }\n \n-    fn with_dep_node_owner<\n-        T: for<'b> HashStable<StableHashingContext<'b>>,\n-        F: FnOnce(&mut Self, Fingerprint),\n-    >(\n-        &mut self,\n-        dep_node_owner: LocalDefId,\n-        item_like: &T,\n-        f: F,\n-    ) {\n+    fn with_dep_node_owner(&mut self, dep_node_owner: LocalDefId, f: impl FnOnce(&mut Self)) {\n         let prev_owner = self.current_dep_node_owner;\n-        let hash = hash_body(&mut self.hcx, item_like);\n+        let prev_parent = self.parent_node;\n \n         self.current_dep_node_owner = dep_node_owner;\n-        f(self, hash);\n+        self.parent_node = HirId::make_owner(dep_node_owner);\n+        f(self);\n         self.current_dep_node_owner = prev_owner;\n+        self.parent_node = prev_parent;\n     }\n \n     fn insert_nested(&mut self, item: LocalDefId) {\n@@ -271,28 +233,22 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n         debug!(\"visit_item: {:?}\", i);\n-        self.with_dep_node_owner(i.def_id, i, |this, hash| {\n-            let hir_id = i.hir_id();\n-            this.insert_with_hash(i.span, hir_id, Node::Item(i), hash);\n-            this.with_parent(hir_id, |this| {\n-                if let ItemKind::Struct(ref struct_def, _) = i.kind {\n-                    // If this is a tuple or unit-like struct, register the constructor.\n-                    if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n-                        this.insert(i.span, ctor_hir_id, Node::Ctor(struct_def));\n-                    }\n+        self.insert_owner(i.def_id, OwnerNode::Item(i));\n+        self.with_dep_node_owner(i.def_id, |this| {\n+            if let ItemKind::Struct(ref struct_def, _) = i.kind {\n+                // If this is a tuple or unit-like struct, register the constructor.\n+                if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n+                    this.insert(i.span, ctor_hir_id, Node::Ctor(struct_def));\n                 }\n-                intravisit::walk_item(this, i);\n-            });\n+            }\n+            intravisit::walk_item(this, i);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, fi: &'hir ForeignItem<'hir>) {\n-        self.with_dep_node_owner(fi.def_id, fi, |this, hash| {\n-            this.insert_with_hash(fi.span, fi.hir_id(), Node::ForeignItem(fi), hash);\n-\n-            this.with_parent(fi.hir_id(), |this| {\n-                intravisit::walk_foreign_item(this, fi);\n-            });\n+        self.insert_owner(fi.def_id, OwnerNode::ForeignItem(fi));\n+        self.with_dep_node_owner(fi.def_id, |this| {\n+            intravisit::walk_foreign_item(this, fi);\n         });\n     }\n \n@@ -302,26 +258,22 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_const_param_default(&mut self, param: HirId, ct: &'hir AnonConst) {\n-        self.with_parent(param, |this| intravisit::walk_const_param_default(this, ct))\n+        self.with_parent(param, |this| {\n+            intravisit::walk_const_param_default(this, ct);\n+        })\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n-        self.with_dep_node_owner(ti.def_id, ti, |this, hash| {\n-            this.insert_with_hash(ti.span, ti.hir_id(), Node::TraitItem(ti), hash);\n-\n-            this.with_parent(ti.hir_id(), |this| {\n-                intravisit::walk_trait_item(this, ti);\n-            });\n+        self.insert_owner(ti.def_id, OwnerNode::TraitItem(ti));\n+        self.with_dep_node_owner(ti.def_id, |this| {\n+            intravisit::walk_trait_item(this, ti);\n         });\n     }\n \n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n-        self.with_dep_node_owner(ii.def_id, ii, |this, hash| {\n-            this.insert_with_hash(ii.span, ii.hir_id(), Node::ImplItem(ii), hash);\n-\n-            this.with_parent(ii.hir_id(), |this| {\n-                intravisit::walk_impl_item(this, ii);\n-            });\n+        self.insert_owner(ii.def_id, OwnerNode::ImplItem(ii));\n+        self.with_dep_node_owner(ii.def_id, |this| {\n+            intravisit::walk_impl_item(this, ii);\n         });\n     }\n \n@@ -413,7 +365,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_local(&mut self, l: &'hir Local<'hir>) {\n         self.insert(l.span, l.hir_id, Node::Local(l));\n-        self.with_parent(l.hir_id, |this| intravisit::walk_local(this, l))\n+        self.with_parent(l.hir_id, |this| {\n+            intravisit::walk_local(this, l);\n+        })\n     }\n \n     fn visit_lifetime(&mut self, lifetime: &'hir Lifetime) {\n@@ -440,16 +394,9 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         let parent = def_key.parent.map_or(hir::CRATE_HIR_ID, |local_def_index| {\n             self.definitions.local_def_id_to_hir_id(LocalDefId { local_def_index })\n         });\n+        self.insert_owner(macro_def.def_id, OwnerNode::MacroDef(macro_def));\n         self.with_parent(parent, |this| {\n             this.insert_nested(macro_def.def_id);\n-            this.with_dep_node_owner(macro_def.def_id, macro_def, |this, hash| {\n-                this.insert_with_hash(\n-                    macro_def.span,\n-                    macro_def.hir_id(),\n-                    Node::MacroDef(macro_def),\n-                    hash,\n-                );\n-            })\n         });\n     }\n "}, {"sha": "c7bab9fca3219ba6cc0d361234f7941338b16ece", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b88083a58c557d7f7f2289333f45944785465cf1/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88083a58c557d7f7f2289333f45944785465cf1/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=b88083a58c557d7f7f2289333f45944785465cf1", "patch": "@@ -313,7 +313,7 @@ impl<'hir> Map<'hir> {\n     pub fn find(&self, id: HirId) -> Option<Node<'hir>> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n             let owner = self.tcx.hir_owner(id.owner)?;\n-            Some(owner.node)\n+            Some(owner.node.into())\n         } else {\n             let owner = self.tcx.hir_owner_nodes(id.owner)?;\n             let node = owner.nodes[id.local_id].as_ref()?;"}, {"sha": "158499bc0aef787661ac8e3164344293597f62c4", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b88083a58c557d7f7f2289333f45944785465cf1/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b88083a58c557d7f7f2289333f45944785465cf1/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=b88083a58c557d7f7f2289333f45944785465cf1", "patch": "@@ -33,9 +33,12 @@ pub struct IndexedHir<'hir> {\n \n /// Top-level HIR node for current owner. This only contains the node for which\n /// `HirId::local_id == 0`, and excludes bodies.\n+///\n+/// This struct exists to encapsulate all access to the hir_owner query in this module, and to\n+/// implement HashStable without hashing bodies.\n #[derive(Copy, Clone, Debug)]\n pub struct Owner<'tcx> {\n-    node: Node<'tcx>,\n+    node: OwnerNode<'tcx>,\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Owner<'tcx> {\n@@ -140,7 +143,8 @@ pub fn provide(providers: &mut Providers) {\n     providers.hir_module_items = |tcx, id| &tcx.untracked_crate.modules[&id];\n     providers.hir_owner = |tcx, id| {\n         let owner = tcx.index_hir(()).map[id].as_ref()?;\n-        let node = owner.nodes[ItemLocalId::new(0)].as_ref()?.node;\n+        let node = owner.nodes[ItemLocalId::new(0)].as_ref().unwrap().node;\n+        let node = node.as_owner().unwrap(); // Indexing must ensure it is an OwnerNode.\n         Some(Owner { node })\n     };\n     providers.hir_owner_nodes = |tcx, id| tcx.index_hir(()).map[id].as_deref();"}]}