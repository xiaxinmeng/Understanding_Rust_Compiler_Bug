{"sha": "73494404e962f4d61e65e5e204432de5a5128101", "node_id": "C_kwDOAAsO6NoAKDczNDk0NDA0ZTk2MmY0ZDYxZTY1ZTVlMjA0NDMyZGU1YTUxMjgxMDE", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-10-30T18:30:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-30T18:30:26Z"}, "message": "Rollup merge of #90183 - GuillaumeGomez:recurse-deref, r=jyn514\n\nShow all Deref implementations recursively\n\nFixes #87783.\n\nThis is a re-implementation of #80653, so taking the original PR comment:\n\nThis changes `rustdoc` to recursively follow `Deref` targets so that methods from all levels are added to the rendered output. This implementation displays the methods from all levels in the expanded state with separate sections for each level.\n\n![image](https://user-images.githubusercontent.com/279572/103482863-46723b00-4ddb-11eb-972b-c463351a425c.png)\n\ncc `@camelid`\nr? `@jyn514`", "tree": {"sha": "5c9545846aca4a17d79257dbc6be00d88dfb595d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c9545846aca4a17d79257dbc6be00d88dfb595d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73494404e962f4d61e65e5e204432de5a5128101", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhfY9CCRBK7hj4Ov3rIwAAb1wIAKhYtaWwud5ya2JEp44dtAZq\nSy+Yzdt+RN9a39pbSjPB/A9ilamEdkDvHoG4dRpQZklXqCS3p2xSvLqtBfGqqmVY\n+n+u6F5cogpL63rmmzQCsKSfoncgeLv8M7fABiSFHajzB2qlrJ7CdBNCqBDx0192\nUhJhF2KOdFu9tsFNJG3FTeVUhjo6oomzDtOTJF7mkHXQlDEDgCM93fQPg7zFbuyy\n9BRSpEVhPUvAIrYTXRKViFzrSeeBliy6sKHpreehOkqFy16TgA6YRLL+Gsebj25V\nAHZJnu9yr2IsyM+mA3hmtlAXuGKPOz7/MR2tcGhOefgutGqOMgKQ27clMMlVxeg=\n=LaM7\n-----END PGP SIGNATURE-----\n", "payload": "tree 5c9545846aca4a17d79257dbc6be00d88dfb595d\nparent ec83b95ab97d2ca972ede3b36345173cd97a63a5\nparent 78b604569b4381ef47b7c0897be5c318b8f88618\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1635618626 +0200\ncommitter GitHub <noreply@github.com> 1635618626 +0200\n\nRollup merge of #90183 - GuillaumeGomez:recurse-deref, r=jyn514\n\nShow all Deref implementations recursively\n\nFixes #87783.\n\nThis is a re-implementation of #80653, so taking the original PR comment:\n\nThis changes `rustdoc` to recursively follow `Deref` targets so that methods from all levels are added to the rendered output. This implementation displays the methods from all levels in the expanded state with separate sections for each level.\n\n![image](https://user-images.githubusercontent.com/279572/103482863-46723b00-4ddb-11eb-972b-c463351a425c.png)\n\ncc `@camelid`\nr? `@jyn514`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73494404e962f4d61e65e5e204432de5a5128101", "html_url": "https://github.com/rust-lang/rust/commit/73494404e962f4d61e65e5e204432de5a5128101", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73494404e962f4d61e65e5e204432de5a5128101/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec83b95ab97d2ca972ede3b36345173cd97a63a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec83b95ab97d2ca972ede3b36345173cd97a63a5", "html_url": "https://github.com/rust-lang/rust/commit/ec83b95ab97d2ca972ede3b36345173cd97a63a5"}, {"sha": "78b604569b4381ef47b7c0897be5c318b8f88618", "url": "https://api.github.com/repos/rust-lang/rust/commits/78b604569b4381ef47b7c0897be5c318b8f88618", "html_url": "https://github.com/rust-lang/rust/commit/78b604569b4381ef47b7c0897be5c318b8f88618"}], "stats": {"total": 346, "additions": 315, "deletions": 31}, "files": [{"sha": "826e7782db1e96420756258f3c68846699cadef7", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/73494404e962f4d61e65e5e204432de5a5128101/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73494404e962f4d61e65e5e204432de5a5128101/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=73494404e962f4d61e65e5e204432de5a5128101", "patch": "@@ -6,7 +6,7 @@ use std::rc::Rc;\n use std::sync::mpsc::{channel, Receiver};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def_id::LOCAL_CRATE;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n@@ -54,6 +54,9 @@ crate struct Context<'tcx> {\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n     pub(super) render_redirect_pages: bool,\n+    /// Tracks section IDs for `Deref` targets so they match in both the main\n+    /// body and the sidebar.\n+    pub(super) deref_id_map: RefCell<FxHashMap<DefId, String>>,\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     pub(super) id_map: RefCell<IdMap>,\n     /// Shared mutable state.\n@@ -70,7 +73,7 @@ crate struct Context<'tcx> {\n \n // `Context` is cloned a lot, so we don't want the size to grow unexpectedly.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(Context<'_>, 104);\n+rustc_data_structures::static_assert_size!(Context<'_>, 144);\n \n /// Shared mutable state used in [`Context`] and elsewhere.\n crate struct SharedContext<'tcx> {\n@@ -513,6 +516,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             dst,\n             render_redirect_pages: false,\n             id_map: RefCell::new(id_map),\n+            deref_id_map: RefCell::new(FxHashMap::default()),\n             shared: Rc::new(scx),\n             include_sources,\n         };\n@@ -536,6 +540,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             current: self.current.clone(),\n             dst: self.dst.clone(),\n             render_redirect_pages: self.render_redirect_pages,\n+            deref_id_map: RefCell::new(FxHashMap::default()),\n             id_map: RefCell::new(IdMap::new()),\n             shared: Rc::clone(&self.shared),\n             include_sources: self.include_sources,"}, {"sha": "f78129050d7ec6124b67e97374c5e7501ab96f0c", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 78, "deletions": 16, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/73494404e962f4d61e65e5e204432de5a5128101/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73494404e962f4d61e65e5e204432de5a5128101/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=73494404e962f4d61e65e5e204432de5a5128101", "patch": "@@ -1054,6 +1054,19 @@ fn render_assoc_items(\n     containing_item: &clean::Item,\n     it: DefId,\n     what: AssocItemRender<'_>,\n+) {\n+    let mut derefs = FxHashSet::default();\n+    derefs.insert(it);\n+    render_assoc_items_inner(w, cx, containing_item, it, what, &mut derefs)\n+}\n+\n+fn render_assoc_items_inner(\n+    w: &mut Buffer,\n+    cx: &Context<'_>,\n+    containing_item: &clean::Item,\n+    it: DefId,\n+    what: AssocItemRender<'_>,\n+    derefs: &mut FxHashSet<DefId>,\n ) {\n     info!(\"Documenting associated items of {:?}\", containing_item.name);\n     let cache = cx.cache();\n@@ -1063,31 +1076,39 @@ fn render_assoc_items(\n     };\n     let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| i.inner_impl().trait_.is_none());\n     if !non_trait.is_empty() {\n+        let mut tmp_buf = Buffer::empty_from(w);\n         let render_mode = match what {\n             AssocItemRender::All => {\n-                w.write_str(\n+                tmp_buf.write_str(\n                     \"<h2 id=\\\"implementations\\\" class=\\\"small-section-header\\\">\\\n                          Implementations<a href=\\\"#implementations\\\" class=\\\"anchor\\\"></a>\\\n                     </h2>\",\n                 );\n                 RenderMode::Normal\n             }\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n+                let id =\n+                    cx.derive_id(small_url_encode(format!(\"deref-methods-{:#}\", type_.print(cx))));\n+                if let Some(def_id) = type_.def_id(cx.cache()) {\n+                    cx.deref_id_map.borrow_mut().insert(def_id, id.clone());\n+                }\n                 write!(\n-                    w,\n-                    \"<h2 id=\\\"deref-methods\\\" class=\\\"small-section-header\\\">\\\n+                    tmp_buf,\n+                    \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n                          <span>Methods from {trait_}&lt;Target = {type_}&gt;</span>\\\n-                         <a href=\\\"#deref-methods\\\" class=\\\"anchor\\\"></a>\\\n+                         <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n                      </h2>\",\n+                    id = id,\n                     trait_ = trait_.print(cx),\n                     type_ = type_.print(cx),\n                 );\n                 RenderMode::ForDeref { mut_: deref_mut_ }\n             }\n         };\n+        let mut impls_buf = Buffer::empty_from(w);\n         for i in &non_trait {\n             render_impl(\n-                w,\n+                &mut impls_buf,\n                 cx,\n                 i,\n                 containing_item,\n@@ -1104,18 +1125,27 @@ fn render_assoc_items(\n                 },\n             );\n         }\n+        if !impls_buf.is_empty() {\n+            w.push_buffer(tmp_buf);\n+            w.push_buffer(impls_buf);\n+        }\n     }\n-    if let AssocItemRender::DerefFor { .. } = what {\n-        return;\n-    }\n+\n     if !traits.is_empty() {\n         let deref_impl =\n             traits.iter().find(|t| t.trait_did() == cx.tcx().lang_items().deref_trait());\n         if let Some(impl_) = deref_impl {\n             let has_deref_mut =\n                 traits.iter().any(|t| t.trait_did() == cx.tcx().lang_items().deref_mut_trait());\n-            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n+            render_deref_methods(w, cx, impl_, containing_item, has_deref_mut, derefs);\n+        }\n+\n+        // If we were already one level into rendering deref methods, we don't want to render\n+        // anything after recursing into any further deref methods above.\n+        if let AssocItemRender::DerefFor { .. } = what {\n+            return;\n         }\n+\n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n             traits.iter().partition(|t| t.inner_impl().synthetic);\n         let (blanket_impl, concrete): (Vec<&&Impl>, _) =\n@@ -1167,6 +1197,7 @@ fn render_deref_methods(\n     impl_: &Impl,\n     container_item: &clean::Item,\n     deref_mut: bool,\n+    derefs: &mut FxHashSet<DefId>,\n ) {\n     let cache = cx.cache();\n     let deref_type = impl_.inner_impl().trait_.as_ref().unwrap();\n@@ -1188,16 +1219,16 @@ fn render_deref_methods(\n     if let Some(did) = target.def_id(cache) {\n         if let Some(type_did) = impl_.inner_impl().for_.def_id(cache) {\n             // `impl Deref<Target = S> for S`\n-            if did == type_did {\n+            if did == type_did || !derefs.insert(did) {\n                 // Avoid infinite cycles\n                 return;\n             }\n         }\n-        render_assoc_items(w, cx, container_item, did, what);\n+        render_assoc_items_inner(w, cx, container_item, did, what, derefs);\n     } else {\n         if let Some(prim) = target.primitive_type() {\n             if let Some(&did) = cache.primitive_locations.get(&prim) {\n-                render_assoc_items(w, cx, container_item, did, what);\n+                render_assoc_items_inner(w, cx, container_item, did, what, derefs);\n             }\n         }\n     }\n@@ -1987,7 +2018,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n             if let Some(impl_) =\n                 v.iter().find(|i| i.trait_did() == cx.tcx().lang_items().deref_trait())\n             {\n-                sidebar_deref_methods(cx, out, impl_, v);\n+                let mut derefs = FxHashSet::default();\n+                derefs.insert(did);\n+                sidebar_deref_methods(cx, out, impl_, v, &mut derefs);\n             }\n \n             let format_impls = |impls: Vec<&Impl>| {\n@@ -2061,7 +2094,13 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n     }\n }\n \n-fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[Impl]) {\n+fn sidebar_deref_methods(\n+    cx: &Context<'_>,\n+    out: &mut Buffer,\n+    impl_: &Impl,\n+    v: &[Impl],\n+    derefs: &mut FxHashSet<DefId>,\n+) {\n     let c = cx.cache();\n \n     debug!(\"found Deref: {:?}\", impl_);\n@@ -2078,7 +2117,7 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[\n         if let Some(did) = target.def_id(c) {\n             if let Some(type_did) = impl_.inner_impl().for_.def_id(c) {\n                 // `impl Deref<Target = S> for S`\n-                if did == type_did {\n+                if did == type_did || !derefs.insert(did) {\n                     // Avoid infinite cycles\n                     return;\n                 }\n@@ -2102,9 +2141,17 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[\n                 })\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n+                let map;\n+                let id = if let Some(target_def_id) = real_target.def_id(c) {\n+                    map = cx.deref_id_map.borrow();\n+                    map.get(&target_def_id).expect(\"Deref section without derived id\")\n+                } else {\n+                    \"deref-methods\"\n+                };\n                 write!(\n                     out,\n-                    \"<h3 class=\\\"sidebar-title\\\"><a href=\\\"#deref-methods\\\">Methods from {}&lt;Target={}&gt;</a></h3>\",\n+                    \"<h3 class=\\\"sidebar-title\\\"><a href=\\\"#{}\\\">Methods from {}&lt;Target={}&gt;</a></h3>\",\n+                    id,\n                     Escape(&format!(\"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print(cx))),\n                     Escape(&format!(\"{:#}\", real_target.print(cx))),\n                 );\n@@ -2117,6 +2164,21 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &[\n                 out.push_str(\"</div>\");\n             }\n         }\n+\n+        // Recurse into any further impls that might exist for `target`\n+        if let Some(target_did) = target.def_id_no_primitives() {\n+            if let Some(target_impls) = c.impls.get(&target_did) {\n+                if let Some(target_deref_impl) = target_impls.iter().find(|i| {\n+                    i.inner_impl()\n+                        .trait_\n+                        .as_ref()\n+                        .map(|t| Some(t.def_id()) == cx.tcx().lang_items().deref_trait())\n+                        .unwrap_or(false)\n+                }) {\n+                    sidebar_deref_methods(cx, out, target_deref_impl, target_impls, derefs);\n+                }\n+            }\n+        }\n     }\n }\n "}, {"sha": "7a4198198fa694ca15f2883e039972fe5a8a8410", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/73494404e962f4d61e65e5e204432de5a5128101/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73494404e962f4d61e65e5e204432de5a5128101/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=73494404e962f4d61e65e5e204432de5a5128101", "patch": "@@ -3,7 +3,8 @@ use crate::clean::*;\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n \n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::def_id::DefId;\n use rustc_middle::ty::DefIdTree;\n use rustc_span::symbol::sym;\n \n@@ -51,12 +52,35 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     }\n \n     let mut cleaner = BadImplStripper { prims, items: crate_items };\n+    let mut type_did_to_deref_target: FxHashMap<DefId, &Type> = FxHashMap::default();\n+\n+    // Follow all `Deref` targets of included items and recursively add them as valid\n+    fn add_deref_target(\n+        map: &FxHashMap<DefId, &Type>,\n+        cleaner: &mut BadImplStripper,\n+        type_did: DefId,\n+    ) {\n+        if let Some(target) = map.get(&type_did) {\n+            debug!(\"add_deref_target: type {:?}, target {:?}\", type_did, target);\n+            if let Some(target_prim) = target.primitive_type() {\n+                cleaner.prims.insert(target_prim);\n+            } else if let Some(target_did) = target.def_id_no_primitives() {\n+                // `impl Deref<Target = S> for S`\n+                if target_did == type_did {\n+                    // Avoid infinite cycles\n+                    return;\n+                }\n+                cleaner.items.insert(target_did.into());\n+                add_deref_target(map, cleaner, target_did);\n+            }\n+        }\n+    }\n \n     // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n     for it in &new_items {\n         if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n-            if cleaner.keep_impl(for_)\n-                && trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait()\n+            if trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait()\n+                && cleaner.keep_impl(for_, true)\n             {\n                 let target = items\n                     .iter()\n@@ -71,16 +95,26 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n                 } else if let Some(did) = target.def_id(&cx.cache) {\n                     cleaner.items.insert(did.into());\n                 }\n+                if let Some(for_did) = for_.def_id_no_primitives() {\n+                    if type_did_to_deref_target.insert(for_did, target).is_none() {\n+                        // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n+                        // `Deref` target type and the impl for type positions, this map of types is keyed by\n+                        // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n+                        if cleaner.keep_impl_with_def_id(for_did.into()) {\n+                            add_deref_target(&type_did_to_deref_target, &mut cleaner, for_did);\n+                        }\n+                    }\n+                }\n             }\n         }\n     }\n \n     new_items.retain(|it| {\n         if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n-            cleaner.keep_impl(for_)\n-                || trait_\n-                    .as_ref()\n-                    .map_or(false, |t| cleaner.keep_impl_with_def_id(t.def_id().into()))\n+            cleaner.keep_impl(\n+                for_,\n+                trait_.as_ref().map(|t| t.def_id()) == cx.tcx.lang_items().deref_trait(),\n+            ) || trait_.as_ref().map_or(false, |t| cleaner.keep_impl_with_def_id(t.def_id().into()))\n                 || blanket_impl.is_some()\n         } else {\n             true\n@@ -179,14 +213,14 @@ struct BadImplStripper {\n }\n \n impl BadImplStripper {\n-    fn keep_impl(&self, ty: &Type) -> bool {\n+    fn keep_impl(&self, ty: &Type, is_deref: bool) -> bool {\n         if let Generic(_) = ty {\n             // keep impls made on generics\n             true\n         } else if let Some(prim) = ty.primitive_type() {\n             self.prims.contains(&prim)\n         } else if let Some(did) = ty.def_id_no_primitives() {\n-            self.keep_impl_with_def_id(did.into())\n+            is_deref || self.keep_impl_with_def_id(did.into())\n         } else {\n             false\n         }"}, {"sha": "c44fd27f40305b38e454d00232ae2859dbcccfef", "filename": "src/test/rustdoc-ui/recursive-deref-ice.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/73494404e962f4d61e65e5e204432de5a5128101/src%2Ftest%2Frustdoc-ui%2Frecursive-deref-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73494404e962f4d61e65e5e204432de5a5128101/src%2Ftest%2Frustdoc-ui%2Frecursive-deref-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Frecursive-deref-ice.rs?ref=73494404e962f4d61e65e5e204432de5a5128101", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+\n+// ICE found in https://github.com/rust-lang/rust/issues/83123\n+\n+pub struct Attribute;\n+\n+pub struct Map<'hir> {}\n+impl<'hir> Map<'hir> {\n+    pub fn attrs(&self) -> &'hir [Attribute] { &[] }\n+}\n+\n+pub struct List<T>(T);\n+\n+impl<T> std::ops::Deref for List<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] {\n+        &[]\n+    }\n+}"}, {"sha": "9ab338ca9b1d1bd42e7eb1ea4e4b207a350acc46", "filename": "src/test/rustdoc/deref-recursive-pathbuf.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/73494404e962f4d61e65e5e204432de5a5128101/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73494404e962f4d61e65e5e204432de5a5128101/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs?ref=73494404e962f4d61e65e5e204432de5a5128101", "patch": "@@ -0,0 +1,25 @@\n+// #26207: Show all methods reachable via Deref impls, recursing through multiple dereferencing\n+// levels and across multiple crates.\n+// For `Deref` on non-foreign types, look at `deref-recursive.rs`.\n+\n+// @has 'foo/struct.Foo.html'\n+// @has '-' '//*[@id=\"deref-methods-PathBuf\"]' 'Methods from Deref<Target = PathBuf>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.as_path\"]' 'pub fn as_path(&self)'\n+// @has '-' '//*[@id=\"deref-methods-Path\"]' 'Methods from Deref<Target = Path>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.exists\"]' 'pub fn exists(&self)'\n+// @has '-' '//*[@class=\"sidebar-title\"]/a[@href=\"#deref-methods-PathBuf\"]' 'Methods from Deref<Target=PathBuf>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.as_path\"]' 'as_path'\n+// @has '-' '//*[@class=\"sidebar-title\"]/a[@href=\"#deref-methods-Path\"]' 'Methods from Deref<Target=Path>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.exists\"]' 'exists'\n+\n+#![crate_name = \"foo\"]\n+\n+use std::ops::Deref;\n+use std::path::PathBuf;\n+\n+pub struct Foo(PathBuf);\n+\n+impl Deref for Foo {\n+    type Target = PathBuf;\n+    fn deref(&self) -> &PathBuf { &self.0 }\n+}"}, {"sha": "c07e048b0651c41f9ab2ee2b0c055bfd4142fce5", "filename": "src/test/rustdoc/deref-recursive.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/73494404e962f4d61e65e5e204432de5a5128101/src%2Ftest%2Frustdoc%2Fderef-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73494404e962f4d61e65e5e204432de5a5128101/src%2Ftest%2Frustdoc%2Fderef-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-recursive.rs?ref=73494404e962f4d61e65e5e204432de5a5128101", "patch": "@@ -0,0 +1,41 @@\n+// #26207: Show all methods reachable via Deref impls, recursing through multiple dereferencing\n+// levels if needed.\n+// For `Deref` on foreign types, look at `deref-recursive-pathbuf.rs`.\n+\n+// @has 'foo/struct.Foo.html'\n+// @has '-' '//*[@id=\"deref-methods-Bar\"]' 'Methods from Deref<Target = Bar>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.bar\"]' 'pub fn bar(&self)'\n+// @has '-' '//*[@id=\"deref-methods-Baz\"]' 'Methods from Deref<Target = Baz>'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.baz\"]' 'pub fn baz(&self)'\n+// @has '-' '//*[@class=\"sidebar-title\"]/a[@href=\"#deref-methods-Bar\"]' 'Methods from Deref<Target=Bar>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.bar\"]' 'bar'\n+// @has '-' '//*[@class=\"sidebar-title\"]/a[@href=\"#deref-methods-Baz\"]' 'Methods from Deref<Target=Baz>'\n+// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.baz\"]' 'baz'\n+\n+#![crate_name = \"foo\"]\n+\n+use std::ops::Deref;\n+\n+pub struct Foo(Bar);\n+pub struct Bar(Baz);\n+pub struct Baz;\n+\n+impl Deref for Foo {\n+    type Target = Bar;\n+    fn deref(&self) -> &Bar { &self.0 }\n+}\n+\n+impl Deref for Bar {\n+    type Target = Baz;\n+    fn deref(&self) -> &Baz { &self.0 }\n+}\n+\n+impl Bar {\n+    /// This appears under `Foo` methods\n+    pub fn bar(&self) {}\n+}\n+\n+impl Baz {\n+    /// This should also appear in `Foo` methods when recursing\n+    pub fn baz(&self) {}\n+}"}, {"sha": "ad7a96c5dad1fc7c6ce37cc1746c13b7387b85d7", "filename": "src/test/rustdoc/deref-typedef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/73494404e962f4d61e65e5e204432de5a5128101/src%2Ftest%2Frustdoc%2Fderef-typedef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73494404e962f4d61e65e5e204432de5a5128101/src%2Ftest%2Frustdoc%2Fderef-typedef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-typedef.rs?ref=73494404e962f4d61e65e5e204432de5a5128101", "patch": "@@ -1,12 +1,12 @@\n #![crate_name = \"foo\"]\n \n // @has 'foo/struct.Bar.html'\n-// @has '-' '//*[@id=\"deref-methods\"]' 'Methods from Deref<Target = FooJ>'\n+// @has '-' '//*[@id=\"deref-methods-FooJ\"]' 'Methods from Deref<Target = FooJ>'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_a\"]' 'pub fn foo_a(&self)'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_b\"]' 'pub fn foo_b(&self)'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_c\"]' 'pub fn foo_c(&self)'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_j\"]' 'pub fn foo_j(&self)'\n-// @has '-' '//*[@class=\"sidebar-title\"]/a[@href=\"#deref-methods\"]' 'Methods from Deref<Target=FooJ>'\n+// @has '-' '//*[@class=\"sidebar-title\"]/a[@href=\"#deref-methods-FooJ\"]' 'Methods from Deref<Target=FooJ>'\n // @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_a\"]' 'foo_a'\n // @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_b\"]' 'foo_b'\n // @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_c\"]' 'foo_c'"}, {"sha": "65a7debc2538dd8e1804d0a302956a0e60fe5c2c", "filename": "src/test/rustdoc/recursive-deref-sidebar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73494404e962f4d61e65e5e204432de5a5128101/src%2Ftest%2Frustdoc%2Frecursive-deref-sidebar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73494404e962f4d61e65e5e204432de5a5128101/src%2Ftest%2Frustdoc%2Frecursive-deref-sidebar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Frecursive-deref-sidebar.rs?ref=73494404e962f4d61e65e5e204432de5a5128101", "patch": "@@ -15,7 +15,7 @@ impl Deref for A {\n     fn deref(&self) -> &B { todo!() }\n }\n \n-// @!has recursive_deref_sidebar/struct.A.html '//div[@class=\"sidebar-links\"]' 'foo_c'\n+// @has recursive_deref_sidebar/struct.A.html '//div[@class=\"sidebar-links\"]' 'foo_c'\n impl Deref for B {\n     type Target = C;\n     fn deref(&self) -> &C { todo!() }"}, {"sha": "a7504fbccfb508f9384b13b551698a2fc59fd2cc", "filename": "src/test/rustdoc/recursive-deref.rs", "status": "modified", "additions": 99, "deletions": 1, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/73494404e962f4d61e65e5e204432de5a5128101/src%2Ftest%2Frustdoc%2Frecursive-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73494404e962f4d61e65e5e204432de5a5128101/src%2Ftest%2Frustdoc%2Frecursive-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Frecursive-deref.rs?ref=73494404e962f4d61e65e5e204432de5a5128101", "patch": "@@ -1,9 +1,16 @@\n use std::ops::Deref;\n \n+// Cyclic deref with the parent (which is not the top parent).\n pub struct A;\n pub struct B;\n+pub struct C;\n+\n+impl C {\n+    pub fn c(&self) {}\n+}\n \n // @has recursive_deref/struct.A.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for A'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.c\"]' 'pub fn c(&self)'\n impl Deref for A {\n     type Target = B;\n \n@@ -13,8 +20,99 @@ impl Deref for A {\n }\n \n // @has recursive_deref/struct.B.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for B'\n+// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.c\"]' 'pub fn c(&self)'\n impl Deref for B {\n-    type Target = A;\n+    type Target = C;\n+\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+// @has recursive_deref/struct.C.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for C'\n+impl Deref for C {\n+    type Target = B;\n+\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+// Cyclic deref with the grand-parent (which is not the top parent).\n+pub struct D;\n+pub struct E;\n+pub struct F;\n+pub struct G;\n+\n+impl G {\n+    // There is no \"self\" parameter so it shouldn't be listed!\n+    pub fn g() {}\n+}\n+\n+// @has recursive_deref/struct.D.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for D'\n+// We also check that `G::g` method isn't rendered because there is no `self` argument.\n+// @!has '-' '//*[@id=\"deref-methods-G\"]'\n+impl Deref for D {\n+    type Target = E;\n+\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+// @has recursive_deref/struct.E.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for E'\n+// We also check that `G::g` method isn't rendered because there is no `self` argument.\n+// @!has '-' '//*[@id=\"deref-methods-G\"]'\n+impl Deref for E {\n+    type Target = F;\n+\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+// @has recursive_deref/struct.F.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for F'\n+// We also check that `G::g` method isn't rendered because there is no `self` argument.\n+// @!has '-' '//*[@id=\"deref-methods-G\"]'\n+impl Deref for F {\n+    type Target = G;\n+\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+// @has recursive_deref/struct.G.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for G'\n+impl Deref for G {\n+    type Target = E;\n+\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+// Cyclic deref with top parent.\n+pub struct H;\n+pub struct I;\n+\n+impl I {\n+    // There is no \"self\" parameter so it shouldn't be listed!\n+    pub fn i() {}\n+}\n+\n+// @has recursive_deref/struct.H.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for H'\n+// @!has '-' '//*[@id=\"deref-methods-I\"]'\n+impl Deref for H {\n+    type Target = I;\n+\n+    fn deref(&self) -> &Self::Target {\n+        panic!()\n+    }\n+}\n+\n+// @has recursive_deref/struct.I.html '//h3[@class=\"code-header in-band\"]' 'impl Deref for I'\n+impl Deref for I {\n+    type Target = H;\n \n     fn deref(&self) -> &Self::Target {\n         panic!()"}]}