{"sha": "279fe0fa76ea1db3173c2b1d43a65dddf3126332", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3OWZlMGZhNzZlYTFkYjMxNzNjMmIxZDQzYTY1ZGRkZjMxMjYzMzI=", "commit": {"author": {"name": "Flavio Percoco", "email": "flaper87@gmail.com", "date": "2014-01-24T19:48:10Z"}, "committer": {"name": "Flavio Percoco", "email": "flaper87@gmail.com", "date": "2014-01-29T13:15:24Z"}, "message": "Treat unary struct and enum variants as rvalues\n\nCloses #11681", "tree": {"sha": "0ad74c5920e16e2eaa2cdd7ab0a39e5dcdb44393", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ad74c5920e16e2eaa2cdd7ab0a39e5dcdb44393"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/279fe0fa76ea1db3173c2b1d43a65dddf3126332", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/279fe0fa76ea1db3173c2b1d43a65dddf3126332", "html_url": "https://github.com/rust-lang/rust/commit/279fe0fa76ea1db3173c2b1d43a65dddf3126332", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/279fe0fa76ea1db3173c2b1d43a65dddf3126332/comments", "author": {"login": "flaper87", "id": 13816, "node_id": "MDQ6VXNlcjEzODE2", "avatar_url": "https://avatars.githubusercontent.com/u/13816?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flaper87", "html_url": "https://github.com/flaper87", "followers_url": "https://api.github.com/users/flaper87/followers", "following_url": "https://api.github.com/users/flaper87/following{/other_user}", "gists_url": "https://api.github.com/users/flaper87/gists{/gist_id}", "starred_url": "https://api.github.com/users/flaper87/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flaper87/subscriptions", "organizations_url": "https://api.github.com/users/flaper87/orgs", "repos_url": "https://api.github.com/users/flaper87/repos", "events_url": "https://api.github.com/users/flaper87/events{/privacy}", "received_events_url": "https://api.github.com/users/flaper87/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flaper87", "id": 13816, "node_id": "MDQ6VXNlcjEzODE2", "avatar_url": "https://avatars.githubusercontent.com/u/13816?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flaper87", "html_url": "https://github.com/flaper87", "followers_url": "https://api.github.com/users/flaper87/followers", "following_url": "https://api.github.com/users/flaper87/following{/other_user}", "gists_url": "https://api.github.com/users/flaper87/gists{/gist_id}", "starred_url": "https://api.github.com/users/flaper87/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flaper87/subscriptions", "organizations_url": "https://api.github.com/users/flaper87/orgs", "repos_url": "https://api.github.com/users/flaper87/repos", "events_url": "https://api.github.com/users/flaper87/events{/privacy}", "received_events_url": "https://api.github.com/users/flaper87/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d80a9a0f683a397392e0fea9e8c20b32b374fee", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d80a9a0f683a397392e0fea9e8c20b32b374fee", "html_url": "https://github.com/rust-lang/rust/commit/1d80a9a0f683a397392e0fea9e8c20b32b374fee"}], "stats": {"total": 68, "additions": 51, "deletions": 17}, "files": [{"sha": "bad1391ce6b89e3e9125ae14f3c040ed08ad65ec", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/279fe0fa76ea1db3173c2b1d43a65dddf3126332/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279fe0fa76ea1db3173c2b1d43a65dddf3126332/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=279fe0fa76ea1db3173c2b1d43a65dddf3126332", "patch": "@@ -356,7 +356,7 @@ impl mem_categorization_ctxt {\n                         // Convert a bare fn to a closure by adding NULL env.\n                         // Result is an rvalue.\n                         let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                        self.cat_rvalue_node(expr, expr_ty)\n+                        self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n                     }\n \n                     ty::AutoDerefRef(ty::AutoDerefRef {\n@@ -365,7 +365,7 @@ impl mem_categorization_ctxt {\n                         // Equivalent to &*expr or something similar.\n                         // Result is an rvalue.\n                         let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n-                        self.cat_rvalue_node(expr, expr_ty)\n+                        self.cat_rvalue_node(expr.id(), expr.span(), expr_ty)\n                     }\n \n                     ty::AutoDerefRef(ty::AutoDerefRef {\n@@ -398,7 +398,7 @@ impl mem_categorization_ctxt {\n           ast::ExprUnary(_, ast::UnDeref, e_base) => {\n             let method_map = self.method_map.borrow();\n             if method_map.get().contains_key(&expr.id) {\n-                return self.cat_rvalue_node(expr, expr_ty);\n+                return self.cat_rvalue_node(expr.id(), expr.span(), expr_ty);\n             }\n \n             let base_cmt = self.cat_expr(e_base);\n@@ -418,7 +418,7 @@ impl mem_categorization_ctxt {\n           ast::ExprIndex(_, base, _) => {\n             let method_map = self.method_map.borrow();\n             if method_map.get().contains_key(&expr.id) {\n-                return self.cat_rvalue_node(expr, expr_ty);\n+                return self.cat_rvalue_node(expr.id(), expr.span(), expr_ty);\n             }\n \n             let base_cmt = self.cat_expr(base);\n@@ -444,7 +444,7 @@ impl mem_categorization_ctxt {\n           ast::ExprLit(..) | ast::ExprBreak(..) | ast::ExprMac(..) |\n           ast::ExprAgain(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n           ast::ExprInlineAsm(..) | ast::ExprBox(..) => {\n-            return self.cat_rvalue_node(expr, expr_ty);\n+            return self.cat_rvalue_node(expr.id(), expr.span(), expr_ty);\n           }\n \n           ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\")\n@@ -457,13 +457,18 @@ impl mem_categorization_ctxt {\n                    expr_ty: ty::t,\n                    def: ast::Def)\n                    -> cmt {\n+        debug!(\"cat_def: id={} expr={}\",\n+               id, ty_to_str(self.tcx, expr_ty));\n+\n+\n         match def {\n+          ast::DefStruct(..) | ast::DefVariant(..) => {\n+                self.cat_rvalue_node(id, span, expr_ty)\n+          }\n           ast::DefFn(..) | ast::DefStaticMethod(..) | ast::DefMod(_) |\n           ast::DefForeignMod(_) | ast::DefStatic(_, false) |\n-          ast::DefUse(_) | ast::DefVariant(..) |\n-          ast::DefTrait(_) | ast::DefTy(_) | ast::DefPrimTy(_) |\n-          ast::DefTyParam(..) | ast::DefStruct(..) |\n-          ast::DefTyParamBinder(..) | ast::DefRegion(_) |\n+          ast::DefUse(_) | ast::DefTrait(_) | ast::DefTy(_) | ast::DefPrimTy(_) |\n+          ast::DefTyParam(..) | ast::DefTyParamBinder(..) | ast::DefRegion(_) |\n           ast::DefLabel(_) | ast::DefSelfTy(..) | ast::DefMethod(..) => {\n               @cmt_ {\n                   id:id,\n@@ -571,16 +576,13 @@ impl mem_categorization_ctxt {\n         }\n     }\n \n-    pub fn cat_rvalue_node<N:ast_node>(&self,\n-                                       node: &N,\n-                                       expr_ty: ty::t) -> cmt {\n-        match self.tcx.region_maps.temporary_scope(node.id()) {\n+    pub fn cat_rvalue_node(&self, id: ast::NodeId, span: Span, expr_ty: ty::t) -> cmt {\n+        match self.tcx.region_maps.temporary_scope(id) {\n             Some(scope) => {\n-                self.cat_rvalue(node.id(), node.span(),\n-                                ty::ReScope(scope), expr_ty)\n+                self.cat_rvalue(id, span, ty::ReScope(scope), expr_ty)\n             }\n             None => {\n-                self.cat_rvalue(node.id(), node.span(), ty::ReStatic, expr_ty)\n+                self.cat_rvalue(id, span, ty::ReStatic, expr_ty)\n             }\n         }\n     }\n@@ -986,7 +988,7 @@ impl mem_categorization_ctxt {\n               }\n               for &slice_pat in slice.iter() {\n                   let slice_ty = self.pat_ty(slice_pat);\n-                  let slice_cmt = self.cat_rvalue_node(pat, slice_ty);\n+                  let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n                   self.cat_pattern(slice_cmt, slice_pat, |x,y| op(x,y));\n               }\n               for &after_pat in after.iter() {"}, {"sha": "c266952f08f0871f17a5e989029645ff9aeb1059", "filename": "src/test/compile-fail/regions-lifetime-of-struct-or-enum-variant.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/279fe0fa76ea1db3173c2b1d43a65dddf3126332/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-of-struct-or-enum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279fe0fa76ea1db3173c2b1d43a65dddf3126332/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-of-struct-or-enum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-lifetime-of-struct-or-enum-variant.rs?ref=279fe0fa76ea1db3173c2b1d43a65dddf3126332", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This tests verifies that unary structs and enum variants\n+// are treated as rvalues and their lifetime is not bounded to\n+// the static scope.\n+\n+struct Test;\n+\n+enum MyEnum {\n+    Variant1\n+}\n+\n+fn structLifetime() -> &Test {\n+  let testValue = &Test; //~ ERROR borrowed value does not live long enough\n+  testValue\n+}\n+\n+fn variantLifetime() -> &MyEnum {\n+  let testValue = &Variant1; //~ ERROR borrowed value does not live long enough\n+  testValue\n+}\n+\n+\n+fn main() {}"}]}