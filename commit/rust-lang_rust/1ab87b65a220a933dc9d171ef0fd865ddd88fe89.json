{"sha": "1ab87b65a220a933dc9d171ef0fd865ddd88fe89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhYjg3YjY1YTIyMGE5MzNkYzlkMTcxZWYwZmQ4NjVkZGQ4OGZlODk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-02T19:25:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-02T19:25:29Z"}, "message": "Auto merge of #34605 - arielb1:bug-in-the-jungle, r=eddyb\n\nfail obligations that depend on erroring obligations\n\nFix a bug where an obligation that depend on an erroring obligation would\nbe regarded as successful, leading to global cache pollution and random\nlossage.\n\nFixes #33723.\nFixes #34503.\n\nr? @eddyb since @nikomatsakis is on vacation\n\nbeta-nominating because of the massive lossage potential (e.g. with `Copy` this could lead to random memory leaks), plus this is a regression.", "tree": {"sha": "c571e11f80ed9f0e46335b9aceab34003561a5c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c571e11f80ed9f0e46335b9aceab34003561a5c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ab87b65a220a933dc9d171ef0fd865ddd88fe89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ab87b65a220a933dc9d171ef0fd865ddd88fe89", "html_url": "https://github.com/rust-lang/rust/commit/1ab87b65a220a933dc9d171ef0fd865ddd88fe89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ab87b65a220a933dc9d171ef0fd865ddd88fe89/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e85adffd6402acce79887e1b911ff33841c6133a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e85adffd6402acce79887e1b911ff33841c6133a", "html_url": "https://github.com/rust-lang/rust/commit/e85adffd6402acce79887e1b911ff33841c6133a"}, {"sha": "201cdd33df63f378ed6c7e9cf55458e1c382cd97", "url": "https://api.github.com/repos/rust-lang/rust/commits/201cdd33df63f378ed6c7e9cf55458e1c382cd97", "html_url": "https://github.com/rust-lang/rust/commit/201cdd33df63f378ed6c7e9cf55458e1c382cd97"}], "stats": {"total": 95, "additions": 87, "deletions": 8}, "files": [{"sha": "c079146edbf42bbe59989fca939aa519fa374662", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1ab87b65a220a933dc9d171ef0fd865ddd88fe89/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ab87b65a220a933dc9d171ef0fd865ddd88fe89/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=1ab87b65a220a933dc9d171ef0fd865ddd88fe89", "patch": "@@ -208,11 +208,17 @@ impl<O: ForestObligation> ObligationForest<O> {\n     ///\n     /// This CAN be done in a snapshot\n     pub fn register_obligation(&mut self, obligation: O) {\n-        self.register_obligation_at(obligation, None)\n+        // Ignore errors here - there is no guarantee of success.\n+        let _ = self.register_obligation_at(obligation, None);\n     }\n \n-    fn register_obligation_at(&mut self, obligation: O, parent: Option<NodeIndex>) {\n-        if self.done_cache.contains(obligation.as_predicate()) { return }\n+    // returns Err(()) if we already know this obligation failed.\n+    fn register_obligation_at(&mut self, obligation: O, parent: Option<NodeIndex>)\n+                              -> Result<(), ()>\n+    {\n+        if self.done_cache.contains(obligation.as_predicate()) {\n+            return Ok(())\n+        }\n \n         match self.waiting_cache.entry(obligation.as_predicate().clone()) {\n             Entry::Occupied(o) => {\n@@ -226,15 +232,21 @@ impl<O: ForestObligation> ObligationForest<O> {\n                         self.nodes[o.get().get()].dependents.push(parent);\n                     }\n                 }\n+                if let NodeState::Error = self.nodes[o.get().get()].state.get() {\n+                    Err(())\n+                } else {\n+                    Ok(())\n+                }\n             }\n             Entry::Vacant(v) => {\n                 debug!(\"register_obligation_at({:?}, {:?}) - ok\",\n                        obligation, parent);\n                 v.insert(NodeIndex::new(self.nodes.len()));\n                 self.cache_list.push(obligation.as_predicate().clone());\n                 self.nodes.push(Node::new(parent, obligation));\n+                Ok(())\n             }\n-        };\n+        }\n     }\n \n     /// Convert all remaining obligations to the given error.\n@@ -306,12 +318,19 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 Ok(Some(children)) => {\n                     // if we saw a Some(_) result, we are not (yet) stalled\n                     stalled = false;\n+                    self.nodes[index].state.set(NodeState::Success);\n+\n                     for child in children {\n-                        self.register_obligation_at(child,\n-                                                    Some(NodeIndex::new(index)));\n+                        let st = self.register_obligation_at(\n+                            child,\n+                            Some(NodeIndex::new(index))\n+                        );\n+                        if let Err(()) = st {\n+                            // error already reported - propagate it\n+                            // to our node.\n+                            self.error_at(index);\n+                        }\n                     }\n-\n-                    self.nodes[index].state.set(NodeState::Success);\n                 }\n                 Err(err) => {\n                     let backtrace = self.error_at(index);"}, {"sha": "a95b2b84b34c85471ebac43575d7748570784a15", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1ab87b65a220a933dc9d171ef0fd865ddd88fe89/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ab87b65a220a933dc9d171ef0fd865ddd88fe89/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=1ab87b65a220a933dc9d171ef0fd865ddd88fe89", "patch": "@@ -418,3 +418,43 @@ fn orphan() {\n     let errors = forest.to_errors(());\n     assert_eq!(errors.len(), 0);\n }\n+\n+#[test]\n+fn simultaneous_register_and_error() {\n+    // check that registering a failed obligation works correctly\n+    let mut forest = ObligationForest::new();\n+    forest.register_obligation(\"A\");\n+    forest.register_obligation(\"B\");\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A\" => Err(\"An error\"),\n+                \"B\" => Ok(Some(vec![\"A\"])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err, vec![super::Error {\n+        error: \"An error\",\n+        backtrace: vec![\"A\"]\n+    }]);\n+\n+    let mut forest = ObligationForest::new();\n+    forest.register_obligation(\"B\");\n+    forest.register_obligation(\"A\");\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A\" => Err(\"An error\"),\n+                \"B\" => Ok(Some(vec![\"A\"])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err, vec![super::Error {\n+        error: \"An error\",\n+        backtrace: vec![\"A\"]\n+    }]);\n+}"}, {"sha": "e6217243eeb4a3db8931fa6d032b32789d69b132", "filename": "src/test/run-pass/issue-34503.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1ab87b65a220a933dc9d171ef0fd865ddd88fe89/src%2Ftest%2Frun-pass%2Fissue-34503.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ab87b65a220a933dc9d171ef0fd865ddd88fe89/src%2Ftest%2Frun-pass%2Fissue-34503.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-34503.rs?ref=1ab87b65a220a933dc9d171ef0fd865ddd88fe89", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    struct X;\n+    trait Foo<T> {\n+        fn foo(&self) where (T, Option<T>): Ord {}\n+        fn bar(&self, x: &Option<T>) -> bool\n+        where Option<T>: Ord { *x < *x }\n+    }\n+    impl Foo<X> for () {}\n+    let _ = &() as &Foo<X>;\n+}"}]}