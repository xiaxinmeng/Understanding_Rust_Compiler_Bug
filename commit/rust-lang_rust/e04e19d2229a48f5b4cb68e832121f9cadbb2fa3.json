{"sha": "e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "node_id": "C_kwDOAAsO6NoAKGUwNGUxOWQyMjI5YTQ4ZjViNGNiNjhlODMyMTIxZjljYWRiYjJmYTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-04T13:54:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-06-04T13:54:31Z"}, "message": "Auto merge of #112270 - matthiaskrgr:rollup-umplsb6, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #109093 (add `#[doc(alias=\"flatmap\")]` to `Option::and_then`)\n - #110701 (Fix `x test core` when download-rustc is enabled)\n - #111982 (Revert \"Enable incremental independent of stage\")\n - #112158 (Add portable-simd mention)\n - #112172 (doc: improve explanation)\n - #112178 (Fix bug where private item with intermediate doc hidden re-export was not inlined)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0efc94cd89a3d2c3304cdb031b75352cf40841e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0efc94cd89a3d2c3304cdb031b75352cf40841e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "html_url": "https://github.com/rust-lang/rust/commit/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a28e125b2130c179e40023317b7c6004c08442ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/a28e125b2130c179e40023317b7c6004c08442ff", "html_url": "https://github.com/rust-lang/rust/commit/a28e125b2130c179e40023317b7c6004c08442ff"}, {"sha": "0d6749c2afbe10d5b8fb1ecc24f9916663afd79b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d6749c2afbe10d5b8fb1ecc24f9916663afd79b", "html_url": "https://github.com/rust-lang/rust/commit/0d6749c2afbe10d5b8fb1ecc24f9916663afd79b"}], "stats": {"total": 230, "additions": 185, "deletions": 45}, "files": [{"sha": "9b6ff76b2404727db11031e891e0077b6de80ddf", "filename": "library/core/src/option.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "patch": "@@ -1402,6 +1402,7 @@ impl<T> Option<T> {\n     /// let item_2_0 = arr_2d.get(2).and_then(|row| row.get(0));\n     /// assert_eq!(item_2_0, None);\n     /// ```\n+    #[doc(alias = \"flatmap\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn and_then<U, F>(self, f: F) -> Option<U>"}, {"sha": "8c46080e43b387d17c258580908c6f85e6d4d7b6", "filename": "library/std/src/sync/once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs?ref=e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "patch": "@@ -91,7 +91,7 @@ impl Once {\n     /// return).\n     ///\n     /// If the given closure recursively invokes `call_once` on the same [`Once`]\n-    /// instance the exact behavior is not specified, allowed outcomes are\n+    /// instance, the exact behavior is not specified: allowed outcomes are\n     /// a panic or a deadlock.\n     ///\n     /// # Examples"}, {"sha": "848fb9eade917004ecb2f90b0ca63b260b36ec65", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "patch": "@@ -995,7 +995,7 @@ impl<'a> Builder<'a> {\n     }\n \n     pub fn sysroot(&self, compiler: Compiler) -> Interned<PathBuf> {\n-        self.ensure(compile::Sysroot { compiler })\n+        self.ensure(compile::Sysroot::new(compiler))\n     }\n \n     /// Returns the libdir where the standard library and other artifacts are\n@@ -1786,7 +1786,10 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_TLS_MODEL_INITIAL_EXEC\", \"1\");\n         }\n \n-        if self.config.incremental {\n+        // Ignore incremental modes except for stage0, since we're\n+        // not guaranteeing correctness across builds if the compiler\n+        // is changing under your feet.\n+        if self.config.incremental && compiler.stage == 0 {\n             cargo.env(\"CARGO_INCREMENTAL\", \"1\");\n         } else {\n             // Don't rely on any default setting for incr. comp. in Cargo"}, {"sha": "48685f7a9d5ac47b95650854a08ed662a1a977b5", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 92, "deletions": 28, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "patch": "@@ -40,11 +40,18 @@ pub struct Std {\n     ///\n     /// This shouldn't be used from other steps; see the comment on [`Rustc`].\n     crates: Interned<Vec<String>>,\n+    /// When using download-rustc, we need to use a new build of `std` for running unit tests of Std itself,\n+    /// but we need to use the downloaded copy of std for linking to rustdoc. Allow this to be overriden by `builder.ensure` from other steps.\n+    force_recompile: bool,\n }\n \n impl Std {\n     pub fn new(compiler: Compiler, target: TargetSelection) -> Self {\n-        Self { target, compiler, crates: Default::default() }\n+        Self { target, compiler, crates: Default::default(), force_recompile: false }\n+    }\n+\n+    pub fn force_recompile(compiler: Compiler, target: TargetSelection) -> Self {\n+        Self { target, compiler, crates: Default::default(), force_recompile: true }\n     }\n }\n \n@@ -77,6 +84,7 @@ impl Step for Std {\n             compiler: run.builder.compiler(run.builder.top_stage, run.build_triple()),\n             target: run.target,\n             crates: make_run_crates(&run, \"library\"),\n+            force_recompile: false,\n         });\n     }\n \n@@ -89,11 +97,20 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = self.compiler;\n \n-        // When using `download-rustc`, we already have artifacts for the host available\n-        // (they were copied in `impl Step for Sysroot`). Don't recompile them.\n-        // NOTE: the ABI of the beta compiler is different from the ABI of the downloaded compiler,\n-        // so its artifacts can't be reused.\n-        if builder.download_rustc() && compiler.stage != 0 && target == builder.build.build {\n+        // When using `download-rustc`, we already have artifacts for the host available. Don't\n+        // recompile them.\n+        if builder.download_rustc() && target == builder.build.build\n+            // NOTE: the beta compiler may generate different artifacts than the downloaded compiler, so\n+            // its artifacts can't be reused.\n+            && compiler.stage != 0\n+            // This check is specific to testing std itself; see `test::Std` for more details.\n+            && !self.force_recompile\n+        {\n+            cp_rustc_component_to_ci_sysroot(\n+                builder,\n+                compiler,\n+                builder.config.ci_rust_std_contents(),\n+            );\n             return;\n         }\n \n@@ -428,6 +445,8 @@ struct StdLink {\n     pub target: TargetSelection,\n     /// Not actually used; only present to make sure the cache invalidation is correct.\n     crates: Interned<Vec<String>>,\n+    /// See [`Std::force_recompile`].\n+    force_recompile: bool,\n }\n \n impl StdLink {\n@@ -437,6 +456,7 @@ impl StdLink {\n             target_compiler: std.compiler,\n             target: std.target,\n             crates: std.crates,\n+            force_recompile: std.force_recompile,\n         }\n     }\n }\n@@ -460,8 +480,24 @@ impl Step for StdLink {\n         let compiler = self.compiler;\n         let target_compiler = self.target_compiler;\n         let target = self.target;\n-        let libdir = builder.sysroot_libdir(target_compiler, target);\n-        let hostdir = builder.sysroot_libdir(target_compiler, compiler.host);\n+\n+        // NOTE: intentionally does *not* check `target == builder.build` to avoid having to add the same check in `test::Crate`.\n+        let (libdir, hostdir) = if self.force_recompile && builder.download_rustc() {\n+            // NOTE: copies part of `sysroot_libdir` to avoid having to add a new `force_recompile` argument there too\n+            let lib = builder.sysroot_libdir_relative(self.compiler);\n+            let sysroot = builder.ensure(crate::compile::Sysroot {\n+                compiler: self.compiler,\n+                force_recompile: self.force_recompile,\n+            });\n+            let libdir = sysroot.join(lib).join(\"rustlib\").join(target.triple).join(\"lib\");\n+            let hostdir = sysroot.join(lib).join(\"rustlib\").join(compiler.host.triple).join(\"lib\");\n+            (INTERNER.intern_path(libdir), INTERNER.intern_path(hostdir))\n+        } else {\n+            let libdir = builder.sysroot_libdir(target_compiler, target);\n+            let hostdir = builder.sysroot_libdir(target_compiler, compiler.host);\n+            (libdir, hostdir)\n+        };\n+\n         add_to_sysroot(builder, &libdir, &hostdir, &libstd_stamp(builder, compiler, target));\n     }\n }\n@@ -594,6 +630,25 @@ impl Step for StartupObjects {\n     }\n }\n \n+fn cp_rustc_component_to_ci_sysroot(\n+    builder: &Builder<'_>,\n+    compiler: Compiler,\n+    contents: Vec<String>,\n+) {\n+    let sysroot = builder.ensure(Sysroot { compiler, force_recompile: false });\n+\n+    let ci_rustc_dir = builder.out.join(&*builder.build.build.triple).join(\"ci-rustc\");\n+    for file in contents {\n+        let src = ci_rustc_dir.join(&file);\n+        let dst = sysroot.join(file);\n+        if src.is_dir() {\n+            t!(fs::create_dir_all(dst));\n+        } else {\n+            builder.copy(&src, &dst);\n+        }\n+    }\n+}\n+\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n     pub target: TargetSelection,\n@@ -653,18 +708,11 @@ impl Step for Rustc {\n         if builder.download_rustc() && compiler.stage != 0 {\n             // Copy the existing artifacts instead of rebuilding them.\n             // NOTE: this path is only taken for tools linking to rustc-dev (including ui-fulldeps tests).\n-            let sysroot = builder.ensure(Sysroot { compiler });\n-\n-            let ci_rustc_dir = builder.out.join(&*builder.build.build.triple).join(\"ci-rustc\");\n-            for file in builder.config.rustc_dev_contents() {\n-                let src = ci_rustc_dir.join(&file);\n-                let dst = sysroot.join(file);\n-                if src.is_dir() {\n-                    t!(fs::create_dir_all(dst));\n-                } else {\n-                    builder.copy(&src, &dst);\n-                }\n-            }\n+            cp_rustc_component_to_ci_sysroot(\n+                builder,\n+                compiler,\n+                builder.config.ci_rustc_dev_contents(),\n+            );\n             return;\n         }\n \n@@ -1225,6 +1273,14 @@ pub fn compiler_file(\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Sysroot {\n     pub compiler: Compiler,\n+    /// See [`Std::force_recompile`].\n+    force_recompile: bool,\n+}\n+\n+impl Sysroot {\n+    pub(crate) fn new(compiler: Compiler) -> Self {\n+        Sysroot { compiler, force_recompile: false }\n+    }\n }\n \n impl Step for Sysroot {\n@@ -1247,6 +1303,8 @@ impl Step for Sysroot {\n         let sysroot_dir = |stage| {\n             if stage == 0 {\n                 host_dir.join(\"stage0-sysroot\")\n+            } else if self.force_recompile && stage == compiler.stage {\n+                host_dir.join(format!(\"stage{stage}-test-sysroot\"))\n             } else if builder.download_rustc() && compiler.stage != builder.top_stage {\n                 host_dir.join(\"ci-rustc-sysroot\")\n             } else {\n@@ -1286,14 +1344,19 @@ impl Step for Sysroot {\n             // 2. The sysroot is deleted and recreated between each invocation, so running `x test\n             //    ui-fulldeps && x test ui` can't cause failures.\n             let mut filtered_files = Vec::new();\n-            // Don't trim directories or files that aren't loaded per-target; they can't cause conflicts.\n-            let suffix = format!(\"lib/rustlib/{}/lib\", compiler.host);\n-            for path in builder.config.rustc_dev_contents() {\n-                let path = Path::new(&path);\n-                if path.parent().map_or(false, |parent| parent.ends_with(&suffix)) {\n-                    filtered_files.push(path.file_name().unwrap().to_owned());\n+            let mut add_filtered_files = |suffix, contents| {\n+                for path in contents {\n+                    let path = Path::new(&path);\n+                    if path.parent().map_or(false, |parent| parent.ends_with(&suffix)) {\n+                        filtered_files.push(path.file_name().unwrap().to_owned());\n+                    }\n                 }\n-            }\n+            };\n+            let suffix = format!(\"lib/rustlib/{}/lib\", compiler.host);\n+            add_filtered_files(suffix.as_str(), builder.config.ci_rustc_dev_contents());\n+            // NOTE: we can't copy std eagerly because `stage2-test-sysroot` needs to have only the\n+            // newly compiled std, not the downloaded std.\n+            add_filtered_files(\"lib\", builder.config.ci_rust_std_contents());\n \n             let filtered_extensions = [OsStr::new(\"rmeta\"), OsStr::new(\"rlib\"), OsStr::new(\"so\")];\n             let ci_rustc_dir = builder.ci_rustc_dir(builder.config.build);\n@@ -1411,7 +1474,8 @@ impl Step for Assemble {\n \n         // If we're downloading a compiler from CI, we can use the same compiler for all stages other than 0.\n         if builder.download_rustc() {\n-            let sysroot = builder.ensure(Sysroot { compiler: target_compiler });\n+            let sysroot =\n+                builder.ensure(Sysroot { compiler: target_compiler, force_recompile: false });\n             // Ensure that `libLLVM.so` ends up in the newly created target directory,\n             // so that tools using `rustc_private` can use it.\n             dist::maybe_install_llvm_target(builder, target_compiler.host, &sysroot);"}, {"sha": "06f479808b97578b1626eadbfa4c92284384cfbd", "filename": "src/bootstrap/download.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/src%2Fbootstrap%2Fdownload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/src%2Fbootstrap%2Fdownload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdownload.rs?ref=e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "patch": "@@ -271,11 +271,8 @@ impl Config {\n         // `compile::Sysroot` needs to know the contents of the `rustc-dev` tarball to avoid adding\n         // it to the sysroot unless it was explicitly requested. But parsing the 100 MB tarball is slow.\n         // Cache the entries when we extract it so we only have to read it once.\n-        let mut recorded_entries = if dst.ends_with(\"ci-rustc\") && pattern == \"rustc-dev\" {\n-            Some(BufWriter::new(t!(File::create(dst.join(\".rustc-dev-contents\")))))\n-        } else {\n-            None\n-        };\n+        let mut recorded_entries =\n+            if dst.ends_with(\"ci-rustc\") { recorded_entries(dst, pattern) } else { None };\n \n         for member in t!(tar.entries()) {\n             let mut member = t!(member);\n@@ -332,6 +329,17 @@ impl Config {\n     }\n }\n \n+fn recorded_entries(dst: &Path, pattern: &str) -> Option<BufWriter<File>> {\n+    let name = if pattern == \"rustc-dev\" {\n+        \".rustc-dev-contents\"\n+    } else if pattern.starts_with(\"rust-std\") {\n+        \".rust-std-contents\"\n+    } else {\n+        return None;\n+    };\n+    Some(BufWriter::new(t!(File::create(dst.join(name)))))\n+}\n+\n enum DownloadSource {\n     CI,\n     Dist,\n@@ -382,11 +390,20 @@ impl Config {\n         Some(rustfmt_path)\n     }\n \n-    pub(crate) fn rustc_dev_contents(&self) -> Vec<String> {\n+    pub(crate) fn ci_rust_std_contents(&self) -> Vec<String> {\n+        self.ci_component_contents(\".rust-std-contents\")\n+    }\n+\n+    pub(crate) fn ci_rustc_dev_contents(&self) -> Vec<String> {\n+        self.ci_component_contents(\".rustc-dev-contents\")\n+    }\n+\n+    fn ci_component_contents(&self, stamp_file: &str) -> Vec<String> {\n         assert!(self.download_rustc());\n         let ci_rustc_dir = self.out.join(&*self.build.triple).join(\"ci-rustc\");\n-        let rustc_dev_contents_file = t!(File::open(ci_rustc_dir.join(\".rustc-dev-contents\")));\n-        t!(BufReader::new(rustc_dev_contents_file).lines().collect())\n+        let stamp_file = ci_rustc_dir.join(stamp_file);\n+        let contents_file = t!(File::open(&stamp_file), stamp_file.display().to_string());\n+        t!(BufReader::new(contents_file).lines().collect())\n     }\n \n     pub(crate) fn download_ci_rustc(&self, commit: &str) {"}, {"sha": "29e48481f0f84da0129096d895ba2c684465884f", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "patch": "@@ -2204,7 +2204,8 @@ impl Step for Crate {\n         let target = self.target;\n         let mode = self.mode;\n \n-        builder.ensure(compile::Std::new(compiler, target));\n+        // See [field@compile::Std::force_recompile].\n+        builder.ensure(compile::Std::force_recompile(compiler, target));\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n         // If we're not doing a full bootstrap but we're testing a stage2\n@@ -2218,6 +2219,16 @@ impl Step for Crate {\n         match mode {\n             Mode::Std => {\n                 compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n+                // `std_cargo` actually does the wrong thing: it passes `--sysroot build/host/stage2`,\n+                // but we want to use the force-recompile std we just built in `build/host/stage2-test-sysroot`.\n+                // Override it.\n+                if builder.download_rustc() {\n+                    let sysroot = builder\n+                        .out\n+                        .join(compiler.host.triple)\n+                        .join(format!(\"stage{}-test-sysroot\", compiler.stage));\n+                    cargo.env(\"RUSTC_SYSROOT\", sysroot);\n+                }\n             }\n             Mode::Rustc => {\n                 compile::rustc_cargo(builder, &mut cargo, target, compiler.stage);\n@@ -2269,6 +2280,11 @@ impl Step for CrateRustdoc {\n             // isn't really necessary.\n             builder.compiler_for(builder.top_stage, target, target)\n         };\n+        // NOTE: normally `ensure(Rustc)` automatically runs `ensure(Std)` for us. However, when\n+        // using `download-rustc`, the rustc_private artifacts may be in a *different sysroot* from\n+        // the target rustdoc (`ci-rustc-sysroot` vs `stage2`). In that case, we need to ensure this\n+        // explicitly to make sure it ends up in the stage2 sysroot.\n+        builder.ensure(compile::Std::new(compiler, target));\n         builder.ensure(compile::Rustc::new(compiler, target));\n \n         let mut cargo = tool::prepare_tool_cargo(\n@@ -2320,7 +2336,13 @@ impl Step for CrateRustdoc {\n         dylib_path.insert(0, PathBuf::from(&*libdir));\n         cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n-        let _guard = builder.msg(builder.kind, compiler.stage, \"rustdoc\", compiler.host, target);\n+        let _guard = builder.msg_sysroot_tool(\n+            builder.kind,\n+            compiler.stage,\n+            \"rustdoc\",\n+            compiler.host,\n+            target,\n+        );\n         run_cargo_test(\n             cargo,\n             &[],"}, {"sha": "b56b81279962b80a419083299e96a581a5c9ea96", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "patch": "@@ -2180,7 +2180,8 @@ fn get_all_import_attributes<'hir>(\n             // This is the \"original\" reexport so we get all its attributes without filtering them.\n             attrs = import_attrs.iter().map(|attr| (Cow::Borrowed(attr), Some(def_id))).collect();\n             first = false;\n-        } else {\n+        // We don't add attributes of an intermediate re-export if it has `#[doc(hidden)]`.\n+        } else if !cx.tcx.is_doc_hidden(def_id) {\n             add_without_unwanted_attributes(&mut attrs, import_attrs, is_inline, Some(def_id));\n         }\n     }"}, {"sha": "1689445b9ef7c6baffe5329be86c6e679b75f751", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         glob: bool,\n         please_inline: bool,\n     ) -> bool {\n-        debug!(\"maybe_inline_local res: {:?}\", res);\n+        debug!(\"maybe_inline_local (renamed: {renamed:?}) res: {res:?}\");\n \n         if renamed == Some(kw::Underscore) {\n             // We never inline `_` reexports.\n@@ -308,6 +308,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     .cache\n                     .effective_visibilities\n                     .is_directly_public(tcx, item_def_id.to_def_id()) &&\n+                !tcx.is_doc_hidden(item_def_id) &&\n                 !inherits_doc_hidden(tcx, item_def_id, None)\n             {\n                 // The imported item is public and not `doc(hidden)` so no need to inline it."}, {"sha": "e382940a47eb88ec20bc0286ff88634cd5c8548e", "filename": "tests/rustdoc/inline-private-with-intermediate-doc-hidden.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/tests%2Frustdoc%2Finline-private-with-intermediate-doc-hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/tests%2Frustdoc%2Finline-private-with-intermediate-doc-hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Finline-private-with-intermediate-doc-hidden.rs?ref=e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "patch": "@@ -0,0 +1,23 @@\n+// This test ensures that if a private item is re-exported with an intermediate\n+// `#[doc(hidden)]` re-export, it'll still be inlined (and not include any attribute\n+// from the doc hidden re-export.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+// There should only be one struct displayed.\n+// @count - '//*[@id=\"main-content\"]/*[@class=\"small-section-header\"]' 1\n+// @has - '//*[@id=\"main-content\"]/*[@class=\"small-section-header\"]' 'Structs'\n+// @has - '//*[@id=\"main-content\"]//a[@href=\"struct.Reexport.html\"]' 'Reexport'\n+// @has - '//*[@id=\"main-content\"]//*[@class=\"desc docblock-short\"]' 'Visible. Original.'\n+\n+mod private {\n+    /// Original.\n+    pub struct Bar3;\n+}\n+\n+/// Hidden.\n+#[doc(hidden)]\n+pub use crate::private::Bar3;\n+/// Visible.\n+pub use self::Bar3 as Reexport;"}, {"sha": "6cc054e7a8b2c15130568620ffb47f24feb60aeb", "filename": "tests/rustdoc/reexport-attr-merge.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/tests%2Frustdoc%2Freexport-attr-merge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/tests%2Frustdoc%2Freexport-attr-merge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-attr-merge.rs?ref=e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "patch": "@@ -19,9 +19,9 @@ pub use Foo1 as Foo2;\n // First we ensure that only the reexport `Bar2` and the inlined struct `Bar`\n // are inlined.\n // @count - '//a[@class=\"struct\"]' 2\n-// Then we check that both `cfg` are displayed.\n+// Then we check that `cfg` is displayed for base item, but not for intermediate re-exports.\n // @has - '//*[@class=\"stab portability\"]' 'foo'\n-// @has - '//*[@class=\"stab portability\"]' 'bar'\n+// @!has - '//*[@class=\"stab portability\"]' 'bar'\n // And finally we check that the only element displayed is `Bar`.\n // @has - '//a[@class=\"struct\"]' 'Bar'\n #[doc(inline)]"}, {"sha": "1bfd48f07cce7c8c79cab9f7e60316cbc19e45cd", "filename": "triagebot.toml", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e04e19d2229a48f5b4cb68e832121f9cadbb2fa3/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=e04e19d2229a48f5b4cb68e832121f9cadbb2fa3", "patch": "@@ -372,6 +372,14 @@ cc = [\"@GuillaumeGomez\"]\n message = \"Some changes might have occurred in exhaustiveness checking\"\n cc = [\"@Nadrieril\"]\n \n+[mentions.\"library/portable-simd\"]\n+message = \"\"\"\n+Portable SIMD is developed in its own repository. If possible, consider \\\n+making this change to [rust-lang/portable-simd](https://github.com/rust-lang/portable-simd) \\\n+instead.\n+\"\"\"\n+cc = [\"@calebzulawski\"]\n+\n [mentions.\"src/librustdoc/clean/types.rs\"]\n cc = [\"@camelid\"]\n "}]}