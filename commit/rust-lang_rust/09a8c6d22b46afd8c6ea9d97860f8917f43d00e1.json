{"sha": "09a8c6d22b46afd8c6ea9d97860f8917f43d00e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YThjNmQyMmI0NmFmZDhjNmVhOWQ5Nzg2MGY4OTE3ZjQzZDAwZTE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-23T08:01:45Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-23T20:26:33Z"}, "message": "Refactoring: move code around in formatting\n\nTo try and make cleaner abstractions and to start to separate formatting from\nother tasks.", "tree": {"sha": "224221da85e61fab038d367951347a0bbc4d51b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/224221da85e61fab038d367951347a0bbc4d51b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09a8c6d22b46afd8c6ea9d97860f8917f43d00e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09a8c6d22b46afd8c6ea9d97860f8917f43d00e1", "html_url": "https://github.com/rust-lang/rust/commit/09a8c6d22b46afd8c6ea9d97860f8917f43d00e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09a8c6d22b46afd8c6ea9d97860f8917f43d00e1/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71d3d04270474ae0afdeeb410fdcc168a54714b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/71d3d04270474ae0afdeeb410fdcc168a54714b7", "html_url": "https://github.com/rust-lang/rust/commit/71d3d04270474ae0afdeeb410fdcc168a54714b7"}], "stats": {"total": 323, "additions": 163, "deletions": 160}, "files": [{"sha": "d0184d6ea0e9b78b6a2265d2ed0ee869216a81cc", "filename": "src/formatting.rs", "status": "modified", "additions": 154, "deletions": 160, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/09a8c6d22b46afd8c6ea9d97860f8917f43d00e1/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a8c6d22b46afd8c6ea9d97860f8917f43d00e1/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=09a8c6d22b46afd8c6ea9d97860f8917f43d00e1", "patch": "@@ -103,82 +103,15 @@ pub(crate) struct ReportedErrors {\n     pub(crate) has_check_errors: bool,\n }\n \n-fn should_emit_verbose<F>(path: &FileName, config: &Config, f: F)\n+fn should_emit_verbose<F>(is_stdin: bool, config: &Config, f: F)\n where\n     F: Fn(),\n {\n-    if config.verbose() == Verbosity::Verbose && path != &FileName::Stdin {\n+    if config.verbose() == Verbosity::Verbose && !is_stdin {\n         f();\n     }\n }\n \n-// Formatting which depends on the AST.\n-fn format_ast<F>(\n-    krate: &ast::Crate,\n-    parse_session: &mut ParseSess,\n-    main_file: &FileName,\n-    config: &Config,\n-    report: FormatReport,\n-    mut after_file: F,\n-) -> Result<(FileMap, bool, bool), io::Error>\n-where\n-    F: FnMut(&FileName, &mut String, &[(usize, usize)], &FormatReport) -> Result<bool, io::Error>,\n-{\n-    let mut result = FileMap::new();\n-    // diff mode: check if any files are differing\n-    let mut has_diff = false;\n-    let mut has_macro_rewrite_failure = false;\n-\n-    let skip_children = config.skip_children();\n-    for (path, module) in modules::list_files(krate, parse_session.codemap())? {\n-        if (skip_children && path != *main_file) || config.ignore().skip_file(&path) {\n-            continue;\n-        }\n-        should_emit_verbose(&path, config, || println!(\"Formatting {}\", path));\n-        let filemap = parse_session\n-            .codemap()\n-            .lookup_char_pos(module.inner.lo())\n-            .file;\n-        let big_snippet = filemap.src.as_ref().unwrap();\n-        let snippet_provider = SnippetProvider::new(filemap.start_pos, big_snippet);\n-        let mut visitor =\n-            FmtVisitor::from_codemap(parse_session, config, &snippet_provider, report.clone());\n-        // Format inner attributes if available.\n-        if !krate.attrs.is_empty() && path == *main_file {\n-            visitor.skip_empty_lines(filemap.end_pos);\n-            if visitor.visit_attrs(&krate.attrs, ast::AttrStyle::Inner) {\n-                visitor.push_rewrite(module.inner, None);\n-            } else {\n-                visitor.format_separate_mod(module, &*filemap);\n-            }\n-        } else {\n-            visitor.last_pos = filemap.start_pos;\n-            visitor.skip_empty_lines(filemap.end_pos);\n-            visitor.format_separate_mod(module, &*filemap);\n-        };\n-\n-        debug_assert_eq!(\n-            visitor.line_number,\n-            ::utils::count_newlines(&visitor.buffer)\n-        );\n-\n-        has_diff |= match after_file(&path, &mut visitor.buffer, &visitor.skipped_range, &report) {\n-            Ok(result) => result,\n-            Err(e) => {\n-                // Create a new error with path_str to help users see which files failed\n-                let err_msg = format!(\"{}: {}\", path, e);\n-                return Err(io::Error::new(e.kind(), err_msg));\n-            }\n-        };\n-\n-        has_macro_rewrite_failure |= visitor.macro_rewrite_failure;\n-\n-        result.push((path.clone(), visitor.buffer));\n-    }\n-\n-    Ok((result, has_diff, has_macro_rewrite_failure))\n-}\n-\n /// Returns true if the line with the given line number was skipped by `#[rustfmt::skip]`.\n fn is_skipped_line(line_number: usize, skipped_range: &[(usize, usize)]) -> bool {\n     skipped_range\n@@ -380,32 +313,63 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n             }\n             return Ok((FileMap::new(), FormatReport::new()));\n         }\n-        let codemap = Rc::new(CodeMap::new(FilePathMapping::empty()));\n \n-        let tty_handler = if self.config.hide_parse_errors() {\n-            let silent_emitter = Box::new(EmitterWriter::new(\n-                Box::new(Vec::new()),\n-                Some(codemap.clone()),\n-                false,\n-                false,\n-            ));\n-            Handler::with_emitter(true, false, silent_emitter)\n-        } else {\n-            let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n-            let color_cfg = if supports_color {\n-                ColorConfig::Auto\n-            } else {\n-                ColorConfig::Never\n-            };\n-            Handler::with_tty_emitter(color_cfg, true, false, Some(codemap.clone()))\n-        };\n-        let mut parse_session = ParseSess::with_span_handler(tty_handler, codemap.clone());\n+        let input_is_stdin = input.is_text();\n+        let mut filemap = FileMap::new();\n+        // TODO split Session? out vs config - but what about summary?\n+        //  - look at error handling\n+        let format_result = self.format_ast(input, |this, path, mut result| {\n+            if let Some(ref mut out) = this.out {\n+                // TODO pull out the has_diff return value\n+                match filemap::write_file(&mut result, &path, out, &this.config) {\n+                    Ok(b) if b => this.summary.add_diff(),\n+                    Err(e) => {\n+                        // Create a new error with path_str to help users see which files failed\n+                        let err_msg = format!(\"{}: {}\", path, e);\n+                        return Err(io::Error::new(e.kind(), err_msg).into());\n+                    }\n+                    _ => {}\n+                }\n+            }\n+\n+            filemap.push((path, result));\n+            Ok(())\n+        });\n+\n+        should_emit_verbose(input_is_stdin, &self.config, || {\n+            fn duration_to_f32(d: Duration) -> f32 {\n+                d.as_secs() as f32 + d.subsec_nanos() as f32 / 1_000_000_000f32\n+            }\n+\n+            println!(\n+                \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n+                duration_to_f32(self.summary.get_parse_time().unwrap()),\n+                duration_to_f32(self.summary.get_format_time().unwrap()),\n+            )\n+        });\n+\n+        format_result.map(|r| (filemap, r))\n+    }\n \n+    // TODO name, only uses config and summary\n+    // TODO move timing from summary to Session\n+    // Formatting which depends on the AST.\n+    fn format_ast<F>(\n+        &mut self,\n+        input: Input,\n+        mut formatted_file: F,\n+    ) -> Result<FormatReport, ErrorKind>\n+    where\n+        F: FnMut(&mut Session<T>, FileName, String) -> Result<(), ErrorKind>,\n+    {\n         let main_file = match input {\n             Input::File(ref file) => FileName::Real(file.clone()),\n             Input::Text(..) => FileName::Stdin,\n         };\n \n+        // Parse the crate.\n+        let codemap = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let mut parse_session = self.make_parse_sess(codemap.clone());\n         let krate = match parse_input(input, &parse_session, &self.config) {\n             Ok(krate) => krate,\n             Err(err) => {\n@@ -415,7 +379,7 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n                         // Note that if you see this message and want more information,\n                         // then go to `parse_input` and run the parse function without\n                         // `catch_unwind` so rustfmt panics and you can get a backtrace.\n-                        should_emit_verbose(&main_file, &self.config, || {\n+                        should_emit_verbose(main_file != FileName::Stdin, &self.config, || {\n                             println!(\"The Rust parser panicked\")\n                         });\n                     }\n@@ -425,10 +389,9 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n                 return Err(ErrorKind::ParseError);\n             }\n         };\n-\n         self.summary.mark_parse_time();\n \n-        // Suppress error output after parsing.\n+        // Suppress error output if we have to do any further parsing.\n         let silent_emitter = Box::new(EmitterWriter::new(\n             Box::new(Vec::new()),\n             Some(codemap.clone()),\n@@ -439,43 +402,69 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n \n         let report = FormatReport::new();\n \n-        let config = &self.config;\n-        let out = &mut self.out;\n-        let format_result = format_ast(\n-            &krate,\n-            &mut parse_session,\n-            &main_file,\n-            config,\n-            report.clone(),\n-            |file_name, file, skipped_range, report| {\n-                // For some reason, the codemap does not include terminating\n-                // newlines so we must add one on for each file. This is sad.\n-                filemap::append_newline(file);\n-\n-                format_lines(file, file_name, skipped_range, config, report);\n-                replace_with_system_newlines(file, config);\n-\n-                if let Some(ref mut out) = out {\n-                    return filemap::write_file(file, file_name, out, config);\n+        let skip_children = self.config.skip_children();\n+        for (path, module) in modules::list_files(&krate, parse_session.codemap())? {\n+            if (skip_children && path != main_file) || self.config.ignore().skip_file(&path) {\n+                continue;\n+            }\n+            should_emit_verbose(main_file != FileName::Stdin, &self.config, || {\n+                println!(\"Formatting {}\", path)\n+            });\n+            let filemap = parse_session\n+                .codemap()\n+                .lookup_char_pos(module.inner.lo())\n+                .file;\n+            let big_snippet = filemap.src.as_ref().unwrap();\n+            let snippet_provider = SnippetProvider::new(filemap.start_pos, big_snippet);\n+            let mut visitor = FmtVisitor::from_codemap(\n+                &parse_session,\n+                &self.config,\n+                &snippet_provider,\n+                report.clone(),\n+            );\n+            // Format inner attributes if available.\n+            if !krate.attrs.is_empty() && path == main_file {\n+                visitor.skip_empty_lines(filemap.end_pos);\n+                if visitor.visit_attrs(&krate.attrs, ast::AttrStyle::Inner) {\n+                    visitor.push_rewrite(module.inner, None);\n+                } else {\n+                    visitor.format_separate_mod(module, &*filemap);\n                 }\n-                Ok(false)\n-            },\n-        );\n-\n-        self.summary.mark_format_time();\n+            } else {\n+                visitor.last_pos = filemap.start_pos;\n+                visitor.skip_empty_lines(filemap.end_pos);\n+                visitor.format_separate_mod(module, &*filemap);\n+            };\n \n-        should_emit_verbose(&main_file, &self.config, || {\n-            fn duration_to_f32(d: Duration) -> f32 {\n-                d.as_secs() as f32 + d.subsec_nanos() as f32 / 1_000_000_000f32\n+            debug_assert_eq!(\n+                visitor.line_number,\n+                ::utils::count_newlines(&visitor.buffer)\n+            );\n+\n+            // For some reason, the codemap does not include terminating\n+            // newlines so we must add one on for each file. This is sad.\n+            filemap::append_newline(&mut visitor.buffer);\n+\n+            format_lines(\n+                &mut visitor.buffer,\n+                &path,\n+                &visitor.skipped_range,\n+                &self.config,\n+                &report,\n+            );\n+            self.replace_with_system_newlines(&mut visitor.buffer);\n+\n+            if visitor.macro_rewrite_failure {\n+                self.summary.add_macro_foramt_failure();\n             }\n \n-            println!(\n-                \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n-                duration_to_f32(self.summary.get_parse_time().unwrap()),\n-                duration_to_f32(self.summary.get_format_time().unwrap()),\n-            )\n-        });\n+            formatted_file(self, path, visitor.buffer)?;\n+        }\n+        self.summary.mark_format_time();\n \n+        if report.has_warnings() {\n+            self.summary.add_formatting_error();\n+        }\n         {\n             let report_errs = &report.internal.borrow().1;\n             if report_errs.has_check_errors {\n@@ -486,52 +475,57 @@ impl<'b, T: Write + 'b> Session<'b, T> {\n             }\n         }\n \n-        match format_result {\n-            Ok((file_map, has_diff, has_macro_rewrite_failure)) => {\n-                if report.has_warnings() {\n-                    self.summary.add_formatting_error();\n-                }\n-\n-                if has_diff {\n-                    self.summary.add_diff();\n-                }\n+        Ok(report)\n+    }\n \n-                if has_macro_rewrite_failure {\n-                    self.summary.add_macro_foramt_failure();\n-                }\n+    fn make_parse_sess(&self, codemap: Rc<CodeMap>) -> ParseSess {\n+        let tty_handler = if self.config.hide_parse_errors() {\n+            let silent_emitter = Box::new(EmitterWriter::new(\n+                Box::new(Vec::new()),\n+                Some(codemap.clone()),\n+                false,\n+                false,\n+            ));\n+            Handler::with_emitter(true, false, silent_emitter)\n+        } else {\n+            let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n+            let color_cfg = if supports_color {\n+                ColorConfig::Auto\n+            } else {\n+                ColorConfig::Never\n+            };\n+            Handler::with_tty_emitter(color_cfg, true, false, Some(codemap.clone()))\n+        };\n \n-                Ok((file_map, report))\n-            }\n-            Err(e) => Err(From::from(e)),\n-        }\n+        ParseSess::with_span_handler(tty_handler, codemap)\n     }\n-}\n \n-fn replace_with_system_newlines(text: &mut String, config: &Config) -> () {\n-    let style = if config.newline_style() == NewlineStyle::Native {\n-        if cfg!(windows) {\n-            NewlineStyle::Windows\n+    fn replace_with_system_newlines(&self, text: &mut String) -> () {\n+        let style = if self.config.newline_style() == NewlineStyle::Native {\n+            if cfg!(windows) {\n+                NewlineStyle::Windows\n+            } else {\n+                NewlineStyle::Unix\n+            }\n         } else {\n-            NewlineStyle::Unix\n-        }\n-    } else {\n-        config.newline_style()\n-    };\n+            self.config.newline_style()\n+        };\n \n-    match style {\n-        NewlineStyle::Unix => return,\n-        NewlineStyle::Windows => {\n-            let mut transformed = String::with_capacity(text.capacity());\n-            for c in text.chars() {\n-                match c {\n-                    '\\n' => transformed.push_str(\"\\r\\n\"),\n-                    '\\r' => continue,\n-                    c => transformed.push(c),\n+        match style {\n+            NewlineStyle::Unix => return,\n+            NewlineStyle::Windows => {\n+                let mut transformed = String::with_capacity(text.capacity());\n+                for c in text.chars() {\n+                    match c {\n+                        '\\n' => transformed.push_str(\"\\r\\n\"),\n+                        '\\r' => continue,\n+                        c => transformed.push(c),\n+                    }\n                 }\n+                *text = transformed;\n             }\n-            *text = transformed;\n+            NewlineStyle::Native => unreachable!(),\n         }\n-        NewlineStyle::Native => unreachable!(),\n     }\n }\n "}, {"sha": "c35fb25f77797e81d5872aa3f78be6f3a225c2af", "filename": "src/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/09a8c6d22b46afd8c6ea9d97860f8917f43d00e1/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a8c6d22b46afd8c6ea9d97860f8917f43d00e1/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=09a8c6d22b46afd8c6ea9d97860f8917f43d00e1", "patch": "@@ -495,6 +495,15 @@ pub enum Input {\n     Text(String),\n }\n \n+impl Input {\n+    fn is_text(&self) -> bool {\n+        match *self {\n+            Input::File(_) => false,\n+            Input::Text(_) => true,\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod unit_tests {\n     use super::*;"}]}