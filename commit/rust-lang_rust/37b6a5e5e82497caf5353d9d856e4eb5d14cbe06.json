{"sha": "37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3YjZhNWU1ZTgyNDk3Y2FmNTM1M2Q5ZDg1NmU0ZWI1ZDE0Y2JlMDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-16T12:15:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-16T12:15:01Z"}, "message": "Auto merge of #61739 - chansuke:separate-unit-tests, r=petrochenkov\n\nSeparate unit tests\n\nI'm working on #61097.\n\nAbout half of the modules are done but dozens of modules are still remaining. I will rebase and squash the commits later.", "tree": {"sha": "43900cf663f0ff2650f744315f37394e4c4c9f03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43900cf663f0ff2650f744315f37394e4c4c9f03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "html_url": "https://github.com/rust-lang/rust/commit/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68655029d49d20cadcff849d14b362b6778ce86a", "url": "https://api.github.com/repos/rust-lang/rust/commits/68655029d49d20cadcff849d14b362b6778ce86a", "html_url": "https://github.com/rust-lang/rust/commit/68655029d49d20cadcff849d14b362b6778ce86a"}, {"sha": "5a9643c95be10fb99c218286883f82640db72610", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a9643c95be10fb99c218286883f82640db72610", "html_url": "https://github.com/rust-lang/rust/commit/5a9643c95be10fb99c218286883f82640db72610"}], "stats": {"total": 10537, "additions": 5260, "deletions": 5277}, "files": [{"sha": "2e9df48d0000296456892ada00ed2be69d916cdb", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 1, "deletions": 658, "changes": 659, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -1327,661 +1327,4 @@ impl<'a> Builder<'a> {\n }\n \n #[cfg(test)]\n-mod __test {\n-    use super::*;\n-    use crate::config::Config;\n-    use std::thread;\n-\n-    use pretty_assertions::assert_eq;\n-\n-    fn configure(host: &[&str], target: &[&str]) -> Config {\n-        let mut config = Config::default_opts();\n-        // don't save toolstates\n-        config.save_toolstates = None;\n-        config.skip_only_host_steps = false;\n-        config.dry_run = true;\n-        // try to avoid spurious failures in dist where we create/delete each others file\n-        let dir = config.out.join(\"tmp-rustbuild-tests\").join(\n-            &thread::current()\n-                .name()\n-                .unwrap_or(\"unknown\")\n-                .replace(\":\", \"-\"),\n-        );\n-        t!(fs::create_dir_all(&dir));\n-        config.out = dir;\n-        config.build = INTERNER.intern_str(\"A\");\n-        config.hosts = vec![config.build]\n-            .clone()\n-            .into_iter()\n-            .chain(host.iter().map(|s| INTERNER.intern_str(s)))\n-            .collect::<Vec<_>>();\n-        config.targets = config\n-            .hosts\n-            .clone()\n-            .into_iter()\n-            .chain(target.iter().map(|s| INTERNER.intern_str(s)))\n-            .collect::<Vec<_>>();\n-        config\n-    }\n-\n-    fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n-        v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n-    }\n-\n-    #[test]\n-    fn dist_baseline() {\n-        let build = Build::new(configure(&[], &[]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[dist::Docs { host: a },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[dist::Rustc {\n-                compiler: Compiler { host: a, stage: 2 }\n-            },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[dist::Std {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_with_targets() {\n-        let build = Build::new(configure(&[], &[\"B\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { host: a },\n-                dist::Docs { host: b },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[dist::Rustc {\n-                compiler: Compiler { host: a, stage: 2 }\n-            },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_with_hosts() {\n-        let build = Build::new(configure(&[\"B\"], &[]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { host: a },\n-                dist::Docs { host: b },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[\n-                dist::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 }\n-                },\n-                dist::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 }\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_only_cross_host() {\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let mut build = Build::new(configure(&[\"B\"], &[]));\n-        build.config.docs = false;\n-        build.config.extended = true;\n-        build.hosts = vec![b];\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[\n-                dist::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 }\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n-            &[\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn dist_with_targets_and_hosts() {\n-        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { host: a },\n-                dist::Docs { host: b },\n-                dist::Docs { host: c },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[\n-                dist::Mingw { host: a },\n-                dist::Mingw { host: b },\n-                dist::Mingw { host: c },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[\n-                dist::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 }\n-                },\n-                dist::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 }\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_with_target_flag() {\n-        let mut config = configure(&[\"B\"], &[\"C\"]);\n-        config.skip_only_host_steps = true; // as-if --target=C was passed\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { host: a },\n-                dist::Docs { host: b },\n-                dist::Docs { host: c },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[\n-                dist::Mingw { host: a },\n-                dist::Mingw { host: b },\n-                dist::Mingw { host: c },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n-    }\n-\n-    #[test]\n-    fn dist_with_same_targets_and_hosts() {\n-        let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { host: a },\n-                dist::Docs { host: b },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[\n-                dist::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 }\n-                },\n-                dist::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 }\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Std>()),\n-            &[\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Test>()),\n-            &[\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Assemble>()),\n-            &[\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 0 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 1 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 2 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: b, stage: 2 },\n-                },\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn build_default() {\n-        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert!(!builder.cache.all::<compile::Std>().is_empty());\n-        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n-            &[\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Test>()),\n-            &[\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn build_with_target_flag() {\n-        let mut config = configure(&[\"B\"], &[\"C\"]);\n-        config.skip_only_host_steps = true;\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert!(!builder.cache.all::<compile::Std>().is_empty());\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Assemble>()),\n-            &[\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 0 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 1 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 2 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: b, stage: 2 },\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n-            &[\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Test>()),\n-            &[\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_with_no_doc_stage0() {\n-        let mut config = configure(&[], &[]);\n-        config.stage = Some(0);\n-        config.cmd = Subcommand::Test {\n-            paths: vec![\"src/libstd\".into()],\n-            test_args: vec![],\n-            rustc_args: vec![],\n-            fail_fast: true,\n-            doc_tests: DocTests::No,\n-            bless: false,\n-            compare_mode: None,\n-            rustfix_coverage: false,\n-        };\n-\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-\n-        let host = INTERNER.intern_str(\"A\");\n-\n-        builder.run_step_descriptions(\n-            &[StepDescription::from::<test::Crate>()],\n-            &[\"src/libstd\".into()],\n-        );\n-\n-        // Ensure we don't build any compiler artifacts.\n-        assert!(!builder.cache.contains::<compile::Rustc>());\n-        assert_eq!(\n-            first(builder.cache.all::<test::Crate>()),\n-            &[test::Crate {\n-                compiler: Compiler { host, stage: 0 },\n-                target: host,\n-                mode: Mode::Std,\n-                test_kind: test::TestKind::Test,\n-                krate: INTERNER.intern_str(\"std\"),\n-            },]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_exclude() {\n-        let mut config = configure(&[], &[]);\n-        config.exclude = vec![\n-            \"src/test/run-pass\".into(),\n-            \"src/tools/tidy\".into(),\n-        ];\n-        config.cmd = Subcommand::Test {\n-            paths: Vec::new(),\n-            test_args: Vec::new(),\n-            rustc_args: Vec::new(),\n-            fail_fast: true,\n-            doc_tests: DocTests::No,\n-            bless: false,\n-            compare_mode: None,\n-            rustfix_coverage: false,\n-        };\n-\n-        let build = Build::new(config);\n-        let builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n-\n-        // Ensure we have really excluded run-pass & tidy\n-        assert!(!builder.cache.contains::<test::RunPass>());\n-        assert!(!builder.cache.contains::<test::Tidy>());\n-\n-        // Ensure other tests are not affected.\n-        assert!(builder.cache.contains::<test::RunPassFullDeps>());\n-        assert!(builder.cache.contains::<test::RustdocUi>());\n-    }\n-}\n+mod tests;"}, {"sha": "46c58d118f7437e089aaba9ba93490e029a49a84", "filename": "src/bootstrap/builder/tests.rs", "status": "added", "additions": 656, "deletions": 0, "changes": 656, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,656 @@\n+use super::*;\n+use crate::config::Config;\n+use std::thread;\n+\n+use pretty_assertions::assert_eq;\n+\n+fn configure(host: &[&str], target: &[&str]) -> Config {\n+    let mut config = Config::default_opts();\n+    // don't save toolstates\n+    config.save_toolstates = None;\n+    config.skip_only_host_steps = false;\n+    config.dry_run = true;\n+    // try to avoid spurious failures in dist where we create/delete each others file\n+    let dir = config.out.join(\"tmp-rustbuild-tests\").join(\n+        &thread::current()\n+            .name()\n+            .unwrap_or(\"unknown\")\n+            .replace(\":\", \"-\"),\n+    );\n+    t!(fs::create_dir_all(&dir));\n+    config.out = dir;\n+    config.build = INTERNER.intern_str(\"A\");\n+    config.hosts = vec![config.build]\n+        .clone()\n+        .into_iter()\n+        .chain(host.iter().map(|s| INTERNER.intern_str(s)))\n+        .collect::<Vec<_>>();\n+    config.targets = config\n+        .hosts\n+        .clone()\n+        .into_iter()\n+        .chain(target.iter().map(|s| INTERNER.intern_str(s)))\n+        .collect::<Vec<_>>();\n+    config\n+}\n+\n+fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n+    v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n+}\n+\n+#[test]\n+fn dist_baseline() {\n+    let build = Build::new(configure(&[], &[]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[dist::Docs { host: a },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[dist::Rustc {\n+            compiler: Compiler { host: a, stage: 2 }\n+        },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[dist::Std {\n+            compiler: Compiler { host: a, stage: 1 },\n+            target: a,\n+        },]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_with_targets() {\n+    let build = Build::new(configure(&[], &[\"B\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[dist::Rustc {\n+            compiler: Compiler { host: a, stage: 2 }\n+        },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_with_hosts() {\n+    let build = Build::new(configure(&[\"B\"], &[]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_only_cross_host() {\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let mut build = Build::new(configure(&[\"B\"], &[]));\n+    build.config.docs = false;\n+    build.config.extended = true;\n+    build.hosts = vec![b];\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Rustc>()),\n+        &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn dist_with_targets_and_hosts() {\n+    let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+            dist::Docs { host: c },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+            dist::Mingw { host: c },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_with_target_flag() {\n+    let mut config = configure(&[\"B\"], &[\"C\"]);\n+    config.skip_only_host_steps = true; // as-if --target=C was passed\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+            dist::Docs { host: c },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+            dist::Mingw { host: c },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n+}\n+\n+#[test]\n+fn dist_with_same_targets_and_hosts() {\n+    let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Std>()),\n+        &[\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Test>()),\n+        &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Assemble>()),\n+        &[\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 0 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 2 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 2 },\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn build_default() {\n+    let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert!(!builder.cache.all::<compile::Std>().is_empty());\n+    assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Rustc>()),\n+        &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+        ]\n+    );\n+\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Test>()),\n+        &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn build_with_target_flag() {\n+    let mut config = configure(&[\"B\"], &[\"C\"]);\n+    config.skip_only_host_steps = true;\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert!(!builder.cache.all::<compile::Std>().is_empty());\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Assemble>()),\n+        &[\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 0 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 2 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 2 },\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Rustc>()),\n+        &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Test>()),\n+        &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn test_with_no_doc_stage0() {\n+    let mut config = configure(&[], &[]);\n+    config.stage = Some(0);\n+    config.cmd = Subcommand::Test {\n+        paths: vec![\"src/libstd\".into()],\n+        test_args: vec![],\n+        rustc_args: vec![],\n+        fail_fast: true,\n+        doc_tests: DocTests::No,\n+        bless: false,\n+        compare_mode: None,\n+        rustfix_coverage: false,\n+    };\n+\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+\n+    let host = INTERNER.intern_str(\"A\");\n+\n+    builder.run_step_descriptions(\n+        &[StepDescription::from::<test::Crate>()],\n+        &[\"src/libstd\".into()],\n+    );\n+\n+    // Ensure we don't build any compiler artifacts.\n+    assert!(!builder.cache.contains::<compile::Rustc>());\n+    assert_eq!(\n+        first(builder.cache.all::<test::Crate>()),\n+        &[test::Crate {\n+            compiler: Compiler { host, stage: 0 },\n+            target: host,\n+            mode: Mode::Std,\n+            test_kind: test::TestKind::Test,\n+            krate: INTERNER.intern_str(\"std\"),\n+        },]\n+    );\n+}\n+\n+#[test]\n+fn test_exclude() {\n+    let mut config = configure(&[], &[]);\n+    config.exclude = vec![\n+        \"src/test/run-pass\".into(),\n+        \"src/tools/tidy\".into(),\n+    ];\n+    config.cmd = Subcommand::Test {\n+        paths: Vec::new(),\n+        test_args: Vec::new(),\n+        rustc_args: Vec::new(),\n+        fail_fast: true,\n+        doc_tests: DocTests::No,\n+        bless: false,\n+        compare_mode: None,\n+        rustfix_coverage: false,\n+    };\n+\n+    let build = Build::new(config);\n+    let builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n+\n+    // Ensure we have really excluded run-pass & tidy\n+    assert!(!builder.cache.contains::<test::RunPass>());\n+    assert!(!builder.cache.contains::<test::Tidy>());\n+\n+    // Ensure other tests are not affected.\n+    assert!(builder.cache.contains::<test::RunPassFullDeps>());\n+    assert!(builder.cache.contains::<test::RustdocUi>());\n+}"}, {"sha": "5fc58c8ab5a7b20672342635a92f7bff79dc8100", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -141,7 +141,7 @@ mod boxed {\n     pub use std::boxed::Box;\n }\n #[cfg(test)]\n-mod boxed_test;\n+mod tests;\n pub mod collections;\n #[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n pub mod sync;"}, {"sha": "654eabd0703263d7464480e102a636ac4183cc89", "filename": "src/liballoc/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Fliballoc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Fliballoc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "previous_filename": "src/liballoc/boxed_test.rs"}, {"sha": "e2a249c8e61c08c033114ceb20b1c3d99ebd4e44", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 1, "deletions": 215, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -617,218 +617,4 @@ impl SyncDroplessArena {\n }\n \n #[cfg(test)]\n-mod tests {\n-    extern crate test;\n-    use test::Bencher;\n-    use super::TypedArena;\n-    use std::cell::Cell;\n-\n-    #[allow(dead_code)]\n-    #[derive(Debug, Eq, PartialEq)]\n-    struct Point {\n-        x: i32,\n-        y: i32,\n-        z: i32,\n-    }\n-\n-    #[test]\n-    pub fn test_unused() {\n-        let arena: TypedArena<Point> = TypedArena::default();\n-        assert!(arena.chunks.borrow().is_empty());\n-    }\n-\n-    #[test]\n-    fn test_arena_alloc_nested() {\n-        struct Inner {\n-            value: u8,\n-        }\n-        struct Outer<'a> {\n-            inner: &'a Inner,\n-        }\n-        enum EI<'e> {\n-            I(Inner),\n-            O(Outer<'e>),\n-        }\n-\n-        struct Wrap<'a>(TypedArena<EI<'a>>);\n-\n-        impl<'a> Wrap<'a> {\n-            fn alloc_inner<F: Fn() -> Inner>(&self, f: F) -> &Inner {\n-                let r: &EI<'_> = self.0.alloc(EI::I(f()));\n-                if let &EI::I(ref i) = r {\n-                    i\n-                } else {\n-                    panic!(\"mismatch\");\n-                }\n-            }\n-            fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer<'_> {\n-                let r: &EI<'_> = self.0.alloc(EI::O(f()));\n-                if let &EI::O(ref o) = r {\n-                    o\n-                } else {\n-                    panic!(\"mismatch\");\n-                }\n-            }\n-        }\n-\n-        let arena = Wrap(TypedArena::default());\n-\n-        let result = arena.alloc_outer(|| Outer {\n-            inner: arena.alloc_inner(|| Inner { value: 10 }),\n-        });\n-\n-        assert_eq!(result.inner.value, 10);\n-    }\n-\n-    #[test]\n-    pub fn test_copy() {\n-        let arena = TypedArena::default();\n-        for _ in 0..100000 {\n-            arena.alloc(Point { x: 1, y: 2, z: 3 });\n-        }\n-    }\n-\n-    #[bench]\n-    pub fn bench_copy(b: &mut Bencher) {\n-        let arena = TypedArena::default();\n-        b.iter(|| arena.alloc(Point { x: 1, y: 2, z: 3 }))\n-    }\n-\n-    #[bench]\n-    pub fn bench_copy_nonarena(b: &mut Bencher) {\n-        b.iter(|| {\n-            let _: Box<_> = Box::new(Point { x: 1, y: 2, z: 3 });\n-        })\n-    }\n-\n-    #[allow(dead_code)]\n-    struct Noncopy {\n-        string: String,\n-        array: Vec<i32>,\n-    }\n-\n-    #[test]\n-    pub fn test_noncopy() {\n-        let arena = TypedArena::default();\n-        for _ in 0..100000 {\n-            arena.alloc(Noncopy {\n-                string: \"hello world\".to_string(),\n-                array: vec![1, 2, 3, 4, 5],\n-            });\n-        }\n-    }\n-\n-    #[test]\n-    pub fn test_typed_arena_zero_sized() {\n-        let arena = TypedArena::default();\n-        for _ in 0..100000 {\n-            arena.alloc(());\n-        }\n-    }\n-\n-    #[test]\n-    pub fn test_typed_arena_clear() {\n-        let mut arena = TypedArena::default();\n-        for _ in 0..10 {\n-            arena.clear();\n-            for _ in 0..10000 {\n-                arena.alloc(Point { x: 1, y: 2, z: 3 });\n-            }\n-        }\n-    }\n-\n-    #[bench]\n-    pub fn bench_typed_arena_clear(b: &mut Bencher) {\n-        let mut arena = TypedArena::default();\n-        b.iter(|| {\n-            arena.alloc(Point { x: 1, y: 2, z: 3 });\n-            arena.clear();\n-        })\n-    }\n-\n-    // Drop tests\n-\n-    struct DropCounter<'a> {\n-        count: &'a Cell<u32>,\n-    }\n-\n-    impl Drop for DropCounter<'_> {\n-        fn drop(&mut self) {\n-            self.count.set(self.count.get() + 1);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_typed_arena_drop_count() {\n-        let counter = Cell::new(0);\n-        {\n-            let arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n-            for _ in 0..100 {\n-                // Allocate something with drop glue to make sure it doesn't leak.\n-                arena.alloc(DropCounter { count: &counter });\n-            }\n-        };\n-        assert_eq!(counter.get(), 100);\n-    }\n-\n-    #[test]\n-    fn test_typed_arena_drop_on_clear() {\n-        let counter = Cell::new(0);\n-        let mut arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n-        for i in 0..10 {\n-            for _ in 0..100 {\n-                // Allocate something with drop glue to make sure it doesn't leak.\n-                arena.alloc(DropCounter { count: &counter });\n-            }\n-            arena.clear();\n-            assert_eq!(counter.get(), i * 100 + 100);\n-        }\n-    }\n-\n-    thread_local! {\n-        static DROP_COUNTER: Cell<u32> = Cell::new(0)\n-    }\n-\n-    struct SmallDroppable;\n-\n-    impl Drop for SmallDroppable {\n-        fn drop(&mut self) {\n-            DROP_COUNTER.with(|c| c.set(c.get() + 1));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_typed_arena_drop_small_count() {\n-        DROP_COUNTER.with(|c| c.set(0));\n-        {\n-            let arena: TypedArena<SmallDroppable> = TypedArena::default();\n-            for _ in 0..100 {\n-                // Allocate something with drop glue to make sure it doesn't leak.\n-                arena.alloc(SmallDroppable);\n-            }\n-            // dropping\n-        };\n-        assert_eq!(DROP_COUNTER.with(|c| c.get()), 100);\n-    }\n-\n-    #[bench]\n-    pub fn bench_noncopy(b: &mut Bencher) {\n-        let arena = TypedArena::default();\n-        b.iter(|| {\n-            arena.alloc(Noncopy {\n-                string: \"hello world\".to_string(),\n-                array: vec![1, 2, 3, 4, 5],\n-            })\n-        })\n-    }\n-\n-    #[bench]\n-    pub fn bench_noncopy_nonarena(b: &mut Bencher) {\n-        b.iter(|| {\n-            let _: Box<_> = Box::new(Noncopy {\n-                string: \"hello world\".to_string(),\n-                array: vec![1, 2, 3, 4, 5],\n-            });\n-        })\n-    }\n-}\n+mod tests;"}, {"sha": "fa4189409d0e86ad67776c7bd973f12d5802fec6", "filename": "src/libarena/tests.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibarena%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibarena%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,213 @@\n+extern crate test;\n+use test::Bencher;\n+use super::TypedArena;\n+use std::cell::Cell;\n+\n+#[allow(dead_code)]\n+#[derive(Debug, Eq, PartialEq)]\n+struct Point {\n+    x: i32,\n+    y: i32,\n+    z: i32,\n+}\n+\n+#[test]\n+pub fn test_unused() {\n+    let arena: TypedArena<Point> = TypedArena::default();\n+    assert!(arena.chunks.borrow().is_empty());\n+}\n+\n+#[test]\n+fn test_arena_alloc_nested() {\n+    struct Inner {\n+        value: u8,\n+    }\n+    struct Outer<'a> {\n+        inner: &'a Inner,\n+    }\n+    enum EI<'e> {\n+        I(Inner),\n+        O(Outer<'e>),\n+    }\n+\n+    struct Wrap<'a>(TypedArena<EI<'a>>);\n+\n+    impl<'a> Wrap<'a> {\n+        fn alloc_inner<F: Fn() -> Inner>(&self, f: F) -> &Inner {\n+            let r: &EI<'_> = self.0.alloc(EI::I(f()));\n+            if let &EI::I(ref i) = r {\n+                i\n+            } else {\n+                panic!(\"mismatch\");\n+            }\n+        }\n+        fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer<'_> {\n+            let r: &EI<'_> = self.0.alloc(EI::O(f()));\n+            if let &EI::O(ref o) = r {\n+                o\n+            } else {\n+                panic!(\"mismatch\");\n+            }\n+        }\n+    }\n+\n+    let arena = Wrap(TypedArena::default());\n+\n+    let result = arena.alloc_outer(|| Outer {\n+        inner: arena.alloc_inner(|| Inner { value: 10 }),\n+    });\n+\n+    assert_eq!(result.inner.value, 10);\n+}\n+\n+#[test]\n+pub fn test_copy() {\n+    let arena = TypedArena::default();\n+    for _ in 0..100000 {\n+        arena.alloc(Point { x: 1, y: 2, z: 3 });\n+    }\n+}\n+\n+#[bench]\n+pub fn bench_copy(b: &mut Bencher) {\n+    let arena = TypedArena::default();\n+    b.iter(|| arena.alloc(Point { x: 1, y: 2, z: 3 }))\n+}\n+\n+#[bench]\n+pub fn bench_copy_nonarena(b: &mut Bencher) {\n+    b.iter(|| {\n+        let _: Box<_> = Box::new(Point { x: 1, y: 2, z: 3 });\n+    })\n+}\n+\n+#[allow(dead_code)]\n+struct Noncopy {\n+    string: String,\n+    array: Vec<i32>,\n+}\n+\n+#[test]\n+pub fn test_noncopy() {\n+    let arena = TypedArena::default();\n+    for _ in 0..100000 {\n+        arena.alloc(Noncopy {\n+            string: \"hello world\".to_string(),\n+            array: vec![1, 2, 3, 4, 5],\n+        });\n+    }\n+}\n+\n+#[test]\n+pub fn test_typed_arena_zero_sized() {\n+    let arena = TypedArena::default();\n+    for _ in 0..100000 {\n+        arena.alloc(());\n+    }\n+}\n+\n+#[test]\n+pub fn test_typed_arena_clear() {\n+    let mut arena = TypedArena::default();\n+    for _ in 0..10 {\n+        arena.clear();\n+        for _ in 0..10000 {\n+            arena.alloc(Point { x: 1, y: 2, z: 3 });\n+        }\n+    }\n+}\n+\n+#[bench]\n+pub fn bench_typed_arena_clear(b: &mut Bencher) {\n+    let mut arena = TypedArena::default();\n+    b.iter(|| {\n+        arena.alloc(Point { x: 1, y: 2, z: 3 });\n+        arena.clear();\n+    })\n+}\n+\n+// Drop tests\n+\n+struct DropCounter<'a> {\n+    count: &'a Cell<u32>,\n+}\n+\n+impl Drop for DropCounter<'_> {\n+    fn drop(&mut self) {\n+        self.count.set(self.count.get() + 1);\n+    }\n+}\n+\n+#[test]\n+fn test_typed_arena_drop_count() {\n+    let counter = Cell::new(0);\n+    {\n+        let arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n+        for _ in 0..100 {\n+            // Allocate something with drop glue to make sure it doesn't leak.\n+            arena.alloc(DropCounter { count: &counter });\n+        }\n+    };\n+    assert_eq!(counter.get(), 100);\n+}\n+\n+#[test]\n+fn test_typed_arena_drop_on_clear() {\n+    let counter = Cell::new(0);\n+    let mut arena: TypedArena<DropCounter<'_>> = TypedArena::default();\n+    for i in 0..10 {\n+        for _ in 0..100 {\n+            // Allocate something with drop glue to make sure it doesn't leak.\n+            arena.alloc(DropCounter { count: &counter });\n+        }\n+        arena.clear();\n+        assert_eq!(counter.get(), i * 100 + 100);\n+    }\n+}\n+\n+thread_local! {\n+    static DROP_COUNTER: Cell<u32> = Cell::new(0)\n+}\n+\n+struct SmallDroppable;\n+\n+impl Drop for SmallDroppable {\n+    fn drop(&mut self) {\n+        DROP_COUNTER.with(|c| c.set(c.get() + 1));\n+    }\n+}\n+\n+#[test]\n+fn test_typed_arena_drop_small_count() {\n+    DROP_COUNTER.with(|c| c.set(0));\n+    {\n+        let arena: TypedArena<SmallDroppable> = TypedArena::default();\n+        for _ in 0..100 {\n+            // Allocate something with drop glue to make sure it doesn't leak.\n+            arena.alloc(SmallDroppable);\n+        }\n+        // dropping\n+    };\n+    assert_eq!(DROP_COUNTER.with(|c| c.get()), 100);\n+}\n+\n+#[bench]\n+pub fn bench_noncopy(b: &mut Bencher) {\n+    let arena = TypedArena::default();\n+    b.iter(|| {\n+        arena.alloc(Noncopy {\n+            string: \"hello world\".to_string(),\n+            array: vec![1, 2, 3, 4, 5],\n+        })\n+    })\n+}\n+\n+#[bench]\n+pub fn bench_noncopy_nonarena(b: &mut Bencher) {\n+    b.iter(|| {\n+        let _: Box<_> = Box::new(Noncopy {\n+            string: \"hello world\".to_string(),\n+            array: vec![1, 2, 3, 4, 5],\n+        });\n+    })\n+}"}, {"sha": "f6e9143dd0583e2dd2e9f9e2195d7acbe3c2dea6", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 1, "deletions": 245, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -622,248 +622,4 @@ impl<'a> Parser<'a> {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    fn same(fmt: &'static str, p: &[Piece<'static>]) {\n-        let parser = Parser::new(fmt, None, vec![], false);\n-        assert!(parser.collect::<Vec<Piece<'static>>>() == p);\n-    }\n-\n-    fn fmtdflt() -> FormatSpec<'static> {\n-        return FormatSpec {\n-            fill: None,\n-            align: AlignUnknown,\n-            flags: 0,\n-            precision: CountImplied,\n-            width: CountImplied,\n-            ty: \"\",\n-        };\n-    }\n-\n-    fn musterr(s: &str) {\n-        let mut p = Parser::new(s, None, vec![], false);\n-        p.next();\n-        assert!(!p.errors.is_empty());\n-    }\n-\n-    #[test]\n-    fn simple() {\n-        same(\"asdf\", &[String(\"asdf\")]);\n-        same(\"a{{b\", &[String(\"a\"), String(\"{b\")]);\n-        same(\"a}}b\", &[String(\"a\"), String(\"}b\")]);\n-        same(\"a}}\", &[String(\"a\"), String(\"}\")]);\n-        same(\"}}\", &[String(\"}\")]);\n-        same(\"\\\\}}\", &[String(\"\\\\\"), String(\"}\")]);\n-    }\n-\n-    #[test]\n-    fn invalid01() {\n-        musterr(\"{\")\n-    }\n-    #[test]\n-    fn invalid02() {\n-        musterr(\"}\")\n-    }\n-    #[test]\n-    fn invalid04() {\n-        musterr(\"{3a}\")\n-    }\n-    #[test]\n-    fn invalid05() {\n-        musterr(\"{:|}\")\n-    }\n-    #[test]\n-    fn invalid06() {\n-        musterr(\"{:>>>}\")\n-    }\n-\n-    #[test]\n-    fn format_nothing() {\n-        same(\"{}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(0),\n-                   format: fmtdflt(),\n-               })]);\n-    }\n-    #[test]\n-    fn format_position() {\n-        same(\"{3}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentIs(3),\n-                   format: fmtdflt(),\n-               })]);\n-    }\n-    #[test]\n-    fn format_position_nothing_else() {\n-        same(\"{3:}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentIs(3),\n-                   format: fmtdflt(),\n-               })]);\n-    }\n-    #[test]\n-    fn format_type() {\n-        same(\"{3:a}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentIs(3),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: 0,\n-                       precision: CountImplied,\n-                       width: CountImplied,\n-                       ty: \"a\",\n-                   },\n-               })]);\n-    }\n-    #[test]\n-    fn format_align_fill() {\n-        same(\"{3:>}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentIs(3),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignRight,\n-                       flags: 0,\n-                       precision: CountImplied,\n-                       width: CountImplied,\n-                       ty: \"\",\n-                   },\n-               })]);\n-        same(\"{3:0<}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentIs(3),\n-                   format: FormatSpec {\n-                       fill: Some('0'),\n-                       align: AlignLeft,\n-                       flags: 0,\n-                       precision: CountImplied,\n-                       width: CountImplied,\n-                       ty: \"\",\n-                   },\n-               })]);\n-        same(\"{3:*<abcd}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentIs(3),\n-                   format: FormatSpec {\n-                       fill: Some('*'),\n-                       align: AlignLeft,\n-                       flags: 0,\n-                       precision: CountImplied,\n-                       width: CountImplied,\n-                       ty: \"abcd\",\n-                   },\n-               })]);\n-    }\n-    #[test]\n-    fn format_counts() {\n-        use syntax_pos::{GLOBALS, Globals, edition};\n-        GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n-        same(\"{:10s}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(0),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: 0,\n-                       precision: CountImplied,\n-                       width: CountIs(10),\n-                       ty: \"s\",\n-                   },\n-               })]);\n-        same(\"{:10$.10s}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(0),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: 0,\n-                       precision: CountIs(10),\n-                       width: CountIsParam(10),\n-                       ty: \"s\",\n-                   },\n-               })]);\n-        same(\"{:.*s}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(1),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: 0,\n-                       precision: CountIsParam(0),\n-                       width: CountImplied,\n-                       ty: \"s\",\n-                   },\n-               })]);\n-        same(\"{:.10$s}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(0),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: 0,\n-                       precision: CountIsParam(10),\n-                       width: CountImplied,\n-                       ty: \"s\",\n-                   },\n-               })]);\n-        same(\"{:a$.b$s}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(0),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: 0,\n-                       precision: CountIsName(Symbol::intern(\"b\")),\n-                       width: CountIsName(Symbol::intern(\"a\")),\n-                       ty: \"s\",\n-                   },\n-               })]);\n-        });\n-    }\n-    #[test]\n-    fn format_flags() {\n-        same(\"{:-}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(0),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: (1 << FlagSignMinus as u32),\n-                       precision: CountImplied,\n-                       width: CountImplied,\n-                       ty: \"\",\n-                   },\n-               })]);\n-        same(\"{:+#}\",\n-             &[NextArgument(Argument {\n-                   position: ArgumentImplicitlyIs(0),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n-                       precision: CountImplied,\n-                       width: CountImplied,\n-                       ty: \"\",\n-                   },\n-               })]);\n-    }\n-    #[test]\n-    fn format_mixture() {\n-        same(\"abcd {3:a} efg\",\n-             &[String(\"abcd \"),\n-               NextArgument(Argument {\n-                   position: ArgumentIs(3),\n-                   format: FormatSpec {\n-                       fill: None,\n-                       align: AlignUnknown,\n-                       flags: 0,\n-                       precision: CountImplied,\n-                       width: CountImplied,\n-                       ty: \"a\",\n-                   },\n-               }),\n-               String(\" efg\")]);\n-    }\n-}\n+mod tests;"}, {"sha": "7282d4a5f248b8127b2d8ea2f2eb6b6d37a210f5", "filename": "src/libfmt_macros/tests.rs", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibfmt_macros%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibfmt_macros%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,243 @@\n+use super::*;\n+\n+fn same(fmt: &'static str, p: &[Piece<'static>]) {\n+    let parser = Parser::new(fmt, None, vec![], false);\n+    assert!(parser.collect::<Vec<Piece<'static>>>() == p);\n+}\n+\n+fn fmtdflt() -> FormatSpec<'static> {\n+    return FormatSpec {\n+        fill: None,\n+        align: AlignUnknown,\n+        flags: 0,\n+        precision: CountImplied,\n+        width: CountImplied,\n+        ty: \"\",\n+    };\n+}\n+\n+fn musterr(s: &str) {\n+    let mut p = Parser::new(s, None, vec![], false);\n+    p.next();\n+    assert!(!p.errors.is_empty());\n+}\n+\n+#[test]\n+fn simple() {\n+    same(\"asdf\", &[String(\"asdf\")]);\n+    same(\"a{{b\", &[String(\"a\"), String(\"{b\")]);\n+    same(\"a}}b\", &[String(\"a\"), String(\"}b\")]);\n+    same(\"a}}\", &[String(\"a\"), String(\"}\")]);\n+    same(\"}}\", &[String(\"}\")]);\n+    same(\"\\\\}}\", &[String(\"\\\\\"), String(\"}\")]);\n+}\n+\n+#[test]\n+fn invalid01() {\n+    musterr(\"{\")\n+}\n+#[test]\n+fn invalid02() {\n+    musterr(\"}\")\n+}\n+#[test]\n+fn invalid04() {\n+    musterr(\"{3a}\")\n+}\n+#[test]\n+fn invalid05() {\n+    musterr(\"{:|}\")\n+}\n+#[test]\n+fn invalid06() {\n+    musterr(\"{:>>>}\")\n+}\n+\n+#[test]\n+fn format_nothing() {\n+    same(\"{}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(0),\n+               format: fmtdflt(),\n+           })]);\n+}\n+#[test]\n+fn format_position() {\n+    same(\"{3}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentIs(3),\n+               format: fmtdflt(),\n+           })]);\n+}\n+#[test]\n+fn format_position_nothing_else() {\n+    same(\"{3:}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentIs(3),\n+               format: fmtdflt(),\n+           })]);\n+}\n+#[test]\n+fn format_type() {\n+    same(\"{3:a}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentIs(3),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: 0,\n+                   precision: CountImplied,\n+                   width: CountImplied,\n+                   ty: \"a\",\n+               },\n+           })]);\n+}\n+#[test]\n+fn format_align_fill() {\n+    same(\"{3:>}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentIs(3),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignRight,\n+                   flags: 0,\n+                   precision: CountImplied,\n+                   width: CountImplied,\n+                   ty: \"\",\n+               },\n+           })]);\n+    same(\"{3:0<}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentIs(3),\n+               format: FormatSpec {\n+                   fill: Some('0'),\n+                   align: AlignLeft,\n+                   flags: 0,\n+                   precision: CountImplied,\n+                   width: CountImplied,\n+                   ty: \"\",\n+               },\n+           })]);\n+    same(\"{3:*<abcd}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentIs(3),\n+               format: FormatSpec {\n+                   fill: Some('*'),\n+                   align: AlignLeft,\n+                   flags: 0,\n+                   precision: CountImplied,\n+                   width: CountImplied,\n+                   ty: \"abcd\",\n+               },\n+           })]);\n+}\n+#[test]\n+fn format_counts() {\n+    use syntax_pos::{GLOBALS, Globals, edition};\n+    GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n+    same(\"{:10s}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(0),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: 0,\n+                   precision: CountImplied,\n+                   width: CountIs(10),\n+                   ty: \"s\",\n+               },\n+           })]);\n+    same(\"{:10$.10s}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(0),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: 0,\n+                   precision: CountIs(10),\n+                   width: CountIsParam(10),\n+                   ty: \"s\",\n+               },\n+           })]);\n+    same(\"{:.*s}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(1),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: 0,\n+                   precision: CountIsParam(0),\n+                   width: CountImplied,\n+                   ty: \"s\",\n+               },\n+           })]);\n+    same(\"{:.10$s}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(0),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: 0,\n+                   precision: CountIsParam(10),\n+                   width: CountImplied,\n+                   ty: \"s\",\n+               },\n+           })]);\n+    same(\"{:a$.b$s}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(0),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: 0,\n+                   precision: CountIsName(Symbol::intern(\"b\")),\n+                   width: CountIsName(Symbol::intern(\"a\")),\n+                   ty: \"s\",\n+               },\n+           })]);\n+    });\n+}\n+#[test]\n+fn format_flags() {\n+    same(\"{:-}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(0),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: (1 << FlagSignMinus as u32),\n+                   precision: CountImplied,\n+                   width: CountImplied,\n+                   ty: \"\",\n+               },\n+           })]);\n+    same(\"{:+#}\",\n+         &[NextArgument(Argument {\n+               position: ArgumentImplicitlyIs(0),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n+                   precision: CountImplied,\n+                   width: CountImplied,\n+                   ty: \"\",\n+               },\n+           })]);\n+}\n+#[test]\n+fn format_mixture() {\n+    same(\"abcd {3:a} efg\",\n+         &[String(\"abcd \"),\n+           NextArgument(Argument {\n+               position: ArgumentIs(3),\n+               format: FormatSpec {\n+                   fill: None,\n+                   align: AlignUnknown,\n+                   flags: 0,\n+                   precision: CountImplied,\n+                   width: CountImplied,\n+                   ty: \"a\",\n+               },\n+           }),\n+           String(\" efg\")]);\n+}"}, {"sha": "a34e4fb89ff27457ea5b21ec033438c50f21927f", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 382, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -684,385 +684,4 @@ pub fn render_opts<'a, N, E, G, W>(g: &'a G,\n }\n \n #[cfg(test)]\n-mod tests {\n-    use NodeLabels::*;\n-    use super::{Id, Labeller, Nodes, Edges, GraphWalk, render, Style};\n-    use super::LabelText::{self, LabelStr, EscStr, HtmlStr};\n-    use std::io;\n-    use std::io::prelude::*;\n-\n-    /// each node is an index in a vector in the graph.\n-    type Node = usize;\n-    struct Edge {\n-        from: usize,\n-        to: usize,\n-        label: &'static str,\n-        style: Style,\n-    }\n-\n-    fn edge(from: usize, to: usize, label: &'static str, style: Style) -> Edge {\n-        Edge {\n-            from,\n-            to,\n-            label,\n-            style,\n-        }\n-    }\n-\n-    struct LabelledGraph {\n-        /// The name for this graph. Used for labeling generated `digraph`.\n-        name: &'static str,\n-\n-        /// Each node is an index into `node_labels`; these labels are\n-        /// used as the label text for each node. (The node *names*,\n-        /// which are unique identifiers, are derived from their index\n-        /// in this array.)\n-        ///\n-        /// If a node maps to None here, then just use its name as its\n-        /// text.\n-        node_labels: Vec<Option<&'static str>>,\n-\n-        node_styles: Vec<Style>,\n-\n-        /// Each edge relates a from-index to a to-index along with a\n-        /// label; `edges` collects them.\n-        edges: Vec<Edge>,\n-    }\n-\n-    // A simple wrapper around LabelledGraph that forces the labels to\n-    // be emitted as EscStr.\n-    struct LabelledGraphWithEscStrs {\n-        graph: LabelledGraph,\n-    }\n-\n-    enum NodeLabels<L> {\n-        AllNodesLabelled(Vec<L>),\n-        UnlabelledNodes(usize),\n-        SomeNodesLabelled(Vec<Option<L>>),\n-    }\n-\n-    type Trivial = NodeLabels<&'static str>;\n-\n-    impl NodeLabels<&'static str> {\n-        fn to_opt_strs(self) -> Vec<Option<&'static str>> {\n-            match self {\n-                UnlabelledNodes(len) => vec![None; len],\n-                AllNodesLabelled(lbls) => lbls.into_iter().map(|l| Some(l)).collect(),\n-                SomeNodesLabelled(lbls) => lbls.into_iter().collect(),\n-            }\n-        }\n-\n-        fn len(&self) -> usize {\n-            match self {\n-                &UnlabelledNodes(len) => len,\n-                &AllNodesLabelled(ref lbls) => lbls.len(),\n-                &SomeNodesLabelled(ref lbls) => lbls.len(),\n-            }\n-        }\n-    }\n-\n-    impl LabelledGraph {\n-        fn new(name: &'static str,\n-               node_labels: Trivial,\n-               edges: Vec<Edge>,\n-               node_styles: Option<Vec<Style>>)\n-               -> LabelledGraph {\n-            let count = node_labels.len();\n-            LabelledGraph {\n-                name,\n-                node_labels: node_labels.to_opt_strs(),\n-                edges,\n-                node_styles: match node_styles {\n-                    Some(nodes) => nodes,\n-                    None => vec![Style::None; count],\n-                },\n-            }\n-        }\n-    }\n-\n-    impl LabelledGraphWithEscStrs {\n-        fn new(name: &'static str,\n-               node_labels: Trivial,\n-               edges: Vec<Edge>)\n-               -> LabelledGraphWithEscStrs {\n-            LabelledGraphWithEscStrs { graph: LabelledGraph::new(name, node_labels, edges, None) }\n-        }\n-    }\n-\n-    fn id_name<'a>(n: &Node) -> Id<'a> {\n-        Id::new(format!(\"N{}\", *n)).unwrap()\n-    }\n-\n-    impl<'a> Labeller<'a> for LabelledGraph {\n-        type Node = Node;\n-        type Edge = &'a Edge;\n-        fn graph_id(&'a self) -> Id<'a> {\n-            Id::new(self.name).unwrap()\n-        }\n-        fn node_id(&'a self, n: &Node) -> Id<'a> {\n-            id_name(n)\n-        }\n-        fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n-            match self.node_labels[*n] {\n-                Some(l) => LabelStr(l.into()),\n-                None => LabelStr(id_name(n).name()),\n-            }\n-        }\n-        fn edge_label(&'a self, e: &&'a Edge) -> LabelText<'a> {\n-            LabelStr(e.label.into())\n-        }\n-        fn node_style(&'a self, n: &Node) -> Style {\n-            self.node_styles[*n]\n-        }\n-        fn edge_style(&'a self, e: &&'a Edge) -> Style {\n-            e.style\n-        }\n-    }\n-\n-    impl<'a> Labeller<'a> for LabelledGraphWithEscStrs {\n-        type Node = Node;\n-        type Edge = &'a Edge;\n-        fn graph_id(&'a self) -> Id<'a> {\n-            self.graph.graph_id()\n-        }\n-        fn node_id(&'a self, n: &Node) -> Id<'a> {\n-            self.graph.node_id(n)\n-        }\n-        fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n-            match self.graph.node_label(n) {\n-                LabelStr(s) | EscStr(s) | HtmlStr(s) => EscStr(s),\n-            }\n-        }\n-        fn edge_label(&'a self, e: &&'a Edge) -> LabelText<'a> {\n-            match self.graph.edge_label(e) {\n-                LabelStr(s) | EscStr(s) | HtmlStr(s) => EscStr(s),\n-            }\n-        }\n-    }\n-\n-    impl<'a> GraphWalk<'a> for LabelledGraph {\n-        type Node = Node;\n-        type Edge = &'a Edge;\n-        fn nodes(&'a self) -> Nodes<'a, Node> {\n-            (0..self.node_labels.len()).collect()\n-        }\n-        fn edges(&'a self) -> Edges<'a, &'a Edge> {\n-            self.edges.iter().collect()\n-        }\n-        fn source(&'a self, edge: &&'a Edge) -> Node {\n-            edge.from\n-        }\n-        fn target(&'a self, edge: &&'a Edge) -> Node {\n-            edge.to\n-        }\n-    }\n-\n-    impl<'a> GraphWalk<'a> for LabelledGraphWithEscStrs {\n-        type Node = Node;\n-        type Edge = &'a Edge;\n-        fn nodes(&'a self) -> Nodes<'a, Node> {\n-            self.graph.nodes()\n-        }\n-        fn edges(&'a self) -> Edges<'a, &'a Edge> {\n-            self.graph.edges()\n-        }\n-        fn source(&'a self, edge: &&'a Edge) -> Node {\n-            edge.from\n-        }\n-        fn target(&'a self, edge: &&'a Edge) -> Node {\n-            edge.to\n-        }\n-    }\n-\n-    fn test_input(g: LabelledGraph) -> io::Result<String> {\n-        let mut writer = Vec::new();\n-        render(&g, &mut writer).unwrap();\n-        let mut s = String::new();\n-        Read::read_to_string(&mut &*writer, &mut s)?;\n-        Ok(s)\n-    }\n-\n-    // All of the tests use raw-strings as the format for the expected outputs,\n-    // so that you can cut-and-paste the content into a .dot file yourself to\n-    // see what the graphviz visualizer would produce.\n-\n-    #[test]\n-    fn empty_graph() {\n-        let labels: Trivial = UnlabelledNodes(0);\n-        let r = test_input(LabelledGraph::new(\"empty_graph\", labels, vec![], None));\n-        assert_eq!(r.unwrap(),\n-r#\"digraph empty_graph {\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn single_node() {\n-        let labels: Trivial = UnlabelledNodes(1);\n-        let r = test_input(LabelledGraph::new(\"single_node\", labels, vec![], None));\n-        assert_eq!(r.unwrap(),\n-r#\"digraph single_node {\n-    N0[label=\"N0\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn single_node_with_style() {\n-        let labels: Trivial = UnlabelledNodes(1);\n-        let styles = Some(vec![Style::Dashed]);\n-        let r = test_input(LabelledGraph::new(\"single_node\", labels, vec![], styles));\n-        assert_eq!(r.unwrap(),\n-r#\"digraph single_node {\n-    N0[label=\"N0\"][style=\"dashed\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn single_edge() {\n-        let labels: Trivial = UnlabelledNodes(2);\n-        let result = test_input(LabelledGraph::new(\"single_edge\",\n-                                                   labels,\n-                                                   vec![edge(0, 1, \"E\", Style::None)],\n-                                                   None));\n-        assert_eq!(result.unwrap(),\n-r#\"digraph single_edge {\n-    N0[label=\"N0\"];\n-    N1[label=\"N1\"];\n-    N0 -> N1[label=\"E\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn single_edge_with_style() {\n-        let labels: Trivial = UnlabelledNodes(2);\n-        let result = test_input(LabelledGraph::new(\"single_edge\",\n-                                                   labels,\n-                                                   vec![edge(0, 1, \"E\", Style::Bold)],\n-                                                   None));\n-        assert_eq!(result.unwrap(),\n-r#\"digraph single_edge {\n-    N0[label=\"N0\"];\n-    N1[label=\"N1\"];\n-    N0 -> N1[label=\"E\"][style=\"bold\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn test_some_labelled() {\n-        let labels: Trivial = SomeNodesLabelled(vec![Some(\"A\"), None]);\n-        let styles = Some(vec![Style::None, Style::Dotted]);\n-        let result = test_input(LabelledGraph::new(\"test_some_labelled\",\n-                                                   labels,\n-                                                   vec![edge(0, 1, \"A-1\", Style::None)],\n-                                                   styles));\n-        assert_eq!(result.unwrap(),\n-r#\"digraph test_some_labelled {\n-    N0[label=\"A\"];\n-    N1[label=\"N1\"][style=\"dotted\"];\n-    N0 -> N1[label=\"A-1\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn single_cyclic_node() {\n-        let labels: Trivial = UnlabelledNodes(1);\n-        let r = test_input(LabelledGraph::new(\"single_cyclic_node\",\n-                                              labels,\n-                                              vec![edge(0, 0, \"E\", Style::None)],\n-                                              None));\n-        assert_eq!(r.unwrap(),\n-r#\"digraph single_cyclic_node {\n-    N0[label=\"N0\"];\n-    N0 -> N0[label=\"E\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn hasse_diagram() {\n-        let labels = AllNodesLabelled(vec![\"{x,y}\", \"{x}\", \"{y}\", \"{}\"]);\n-        let r = test_input(LabelledGraph::new(\"hasse_diagram\",\n-                                              labels,\n-                                              vec![edge(0, 1, \"\", Style::None),\n-                                                   edge(0, 2, \"\", Style::None),\n-                                                   edge(1, 3, \"\", Style::None),\n-                                                   edge(2, 3, \"\", Style::None)],\n-                                              None));\n-        assert_eq!(r.unwrap(),\n-r#\"digraph hasse_diagram {\n-    N0[label=\"{x,y}\"];\n-    N1[label=\"{x}\"];\n-    N2[label=\"{y}\"];\n-    N3[label=\"{}\"];\n-    N0 -> N1[label=\"\"];\n-    N0 -> N2[label=\"\"];\n-    N1 -> N3[label=\"\"];\n-    N2 -> N3[label=\"\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn left_aligned_text() {\n-        let labels = AllNodesLabelled(vec![\n-            \"if test {\\\n-           \\\\l    branch1\\\n-           \\\\l} else {\\\n-           \\\\l    branch2\\\n-           \\\\l}\\\n-           \\\\lafterward\\\n-           \\\\l\",\n-            \"branch1\",\n-            \"branch2\",\n-            \"afterward\"]);\n-\n-        let mut writer = Vec::new();\n-\n-        let g = LabelledGraphWithEscStrs::new(\"syntax_tree\",\n-                                              labels,\n-                                              vec![edge(0, 1, \"then\", Style::None),\n-                                                   edge(0, 2, \"else\", Style::None),\n-                                                   edge(1, 3, \";\", Style::None),\n-                                                   edge(2, 3, \";\", Style::None)]);\n-\n-        render(&g, &mut writer).unwrap();\n-        let mut r = String::new();\n-        Read::read_to_string(&mut &*writer, &mut r).unwrap();\n-\n-        assert_eq!(r,\n-r#\"digraph syntax_tree {\n-    N0[label=\"if test {\\l    branch1\\l} else {\\l    branch2\\l}\\lafterward\\l\"];\n-    N1[label=\"branch1\"];\n-    N2[label=\"branch2\"];\n-    N3[label=\"afterward\"];\n-    N0 -> N1[label=\"then\"];\n-    N0 -> N2[label=\"else\"];\n-    N1 -> N3[label=\";\"];\n-    N2 -> N3[label=\";\"];\n-}\n-\"#);\n-    }\n-\n-    #[test]\n-    fn simple_id_construction() {\n-        let id1 = Id::new(\"hello\");\n-        match id1 {\n-            Ok(_) => {}\n-            Err(..) => panic!(\"'hello' is not a valid value for id anymore\"),\n-        }\n-    }\n-\n-    #[test]\n-    fn badly_formatted_id() {\n-        let id2 = Id::new(\"Weird { struct : ure } !!!\");\n-        match id2 {\n-            Ok(_) => panic!(\"graphviz id suddenly allows spaces, brackets and stuff\"),\n-            Err(..) => {}\n-        }\n-    }\n-}\n+mod tests;"}, {"sha": "2f713579b17fa0416204f8b0d5abc971d1494f91", "filename": "src/libgraphviz/tests.rs", "status": "added", "additions": 380, "deletions": 0, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibgraphviz%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibgraphviz%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,380 @@\n+use NodeLabels::*;\n+use super::{Id, Labeller, Nodes, Edges, GraphWalk, render, Style};\n+use super::LabelText::{self, LabelStr, EscStr, HtmlStr};\n+use std::io;\n+use std::io::prelude::*;\n+\n+/// each node is an index in a vector in the graph.\n+type Node = usize;\n+struct Edge {\n+    from: usize,\n+    to: usize,\n+    label: &'static str,\n+    style: Style,\n+}\n+\n+fn edge(from: usize, to: usize, label: &'static str, style: Style) -> Edge {\n+    Edge {\n+        from,\n+        to,\n+        label,\n+        style,\n+    }\n+}\n+\n+struct LabelledGraph {\n+    /// The name for this graph. Used for labeling generated `digraph`.\n+    name: &'static str,\n+\n+    /// Each node is an index into `node_labels`; these labels are\n+    /// used as the label text for each node. (The node *names*,\n+    /// which are unique identifiers, are derived from their index\n+    /// in this array.)\n+    ///\n+    /// If a node maps to None here, then just use its name as its\n+    /// text.\n+    node_labels: Vec<Option<&'static str>>,\n+\n+    node_styles: Vec<Style>,\n+\n+    /// Each edge relates a from-index to a to-index along with a\n+    /// label; `edges` collects them.\n+    edges: Vec<Edge>,\n+}\n+\n+// A simple wrapper around LabelledGraph that forces the labels to\n+// be emitted as EscStr.\n+struct LabelledGraphWithEscStrs {\n+    graph: LabelledGraph,\n+}\n+\n+enum NodeLabels<L> {\n+    AllNodesLabelled(Vec<L>),\n+    UnlabelledNodes(usize),\n+    SomeNodesLabelled(Vec<Option<L>>),\n+}\n+\n+type Trivial = NodeLabels<&'static str>;\n+\n+impl NodeLabels<&'static str> {\n+    fn to_opt_strs(self) -> Vec<Option<&'static str>> {\n+        match self {\n+            UnlabelledNodes(len) => vec![None; len],\n+            AllNodesLabelled(lbls) => lbls.into_iter().map(|l| Some(l)).collect(),\n+            SomeNodesLabelled(lbls) => lbls.into_iter().collect(),\n+        }\n+    }\n+\n+    fn len(&self) -> usize {\n+        match self {\n+            &UnlabelledNodes(len) => len,\n+            &AllNodesLabelled(ref lbls) => lbls.len(),\n+            &SomeNodesLabelled(ref lbls) => lbls.len(),\n+        }\n+    }\n+}\n+\n+impl LabelledGraph {\n+    fn new(name: &'static str,\n+           node_labels: Trivial,\n+           edges: Vec<Edge>,\n+           node_styles: Option<Vec<Style>>)\n+           -> LabelledGraph {\n+        let count = node_labels.len();\n+        LabelledGraph {\n+            name,\n+            node_labels: node_labels.to_opt_strs(),\n+            edges,\n+            node_styles: match node_styles {\n+                Some(nodes) => nodes,\n+                None => vec![Style::None; count],\n+            },\n+        }\n+    }\n+}\n+\n+impl LabelledGraphWithEscStrs {\n+    fn new(name: &'static str,\n+           node_labels: Trivial,\n+           edges: Vec<Edge>)\n+           -> LabelledGraphWithEscStrs {\n+        LabelledGraphWithEscStrs { graph: LabelledGraph::new(name, node_labels, edges, None) }\n+    }\n+}\n+\n+fn id_name<'a>(n: &Node) -> Id<'a> {\n+    Id::new(format!(\"N{}\", *n)).unwrap()\n+}\n+\n+impl<'a> Labeller<'a> for LabelledGraph {\n+    type Node = Node;\n+    type Edge = &'a Edge;\n+    fn graph_id(&'a self) -> Id<'a> {\n+        Id::new(self.name).unwrap()\n+    }\n+    fn node_id(&'a self, n: &Node) -> Id<'a> {\n+        id_name(n)\n+    }\n+    fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n+        match self.node_labels[*n] {\n+            Some(l) => LabelStr(l.into()),\n+            None => LabelStr(id_name(n).name()),\n+        }\n+    }\n+    fn edge_label(&'a self, e: &&'a Edge) -> LabelText<'a> {\n+        LabelStr(e.label.into())\n+    }\n+    fn node_style(&'a self, n: &Node) -> Style {\n+        self.node_styles[*n]\n+    }\n+    fn edge_style(&'a self, e: &&'a Edge) -> Style {\n+        e.style\n+    }\n+}\n+\n+impl<'a> Labeller<'a> for LabelledGraphWithEscStrs {\n+    type Node = Node;\n+    type Edge = &'a Edge;\n+    fn graph_id(&'a self) -> Id<'a> {\n+        self.graph.graph_id()\n+    }\n+    fn node_id(&'a self, n: &Node) -> Id<'a> {\n+        self.graph.node_id(n)\n+    }\n+    fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n+        match self.graph.node_label(n) {\n+            LabelStr(s) | EscStr(s) | HtmlStr(s) => EscStr(s),\n+        }\n+    }\n+    fn edge_label(&'a self, e: &&'a Edge) -> LabelText<'a> {\n+        match self.graph.edge_label(e) {\n+            LabelStr(s) | EscStr(s) | HtmlStr(s) => EscStr(s),\n+        }\n+    }\n+}\n+\n+impl<'a> GraphWalk<'a> for LabelledGraph {\n+    type Node = Node;\n+    type Edge = &'a Edge;\n+    fn nodes(&'a self) -> Nodes<'a, Node> {\n+        (0..self.node_labels.len()).collect()\n+    }\n+    fn edges(&'a self) -> Edges<'a, &'a Edge> {\n+        self.edges.iter().collect()\n+    }\n+    fn source(&'a self, edge: &&'a Edge) -> Node {\n+        edge.from\n+    }\n+    fn target(&'a self, edge: &&'a Edge) -> Node {\n+        edge.to\n+    }\n+}\n+\n+impl<'a> GraphWalk<'a> for LabelledGraphWithEscStrs {\n+    type Node = Node;\n+    type Edge = &'a Edge;\n+    fn nodes(&'a self) -> Nodes<'a, Node> {\n+        self.graph.nodes()\n+    }\n+    fn edges(&'a self) -> Edges<'a, &'a Edge> {\n+        self.graph.edges()\n+    }\n+    fn source(&'a self, edge: &&'a Edge) -> Node {\n+        edge.from\n+    }\n+    fn target(&'a self, edge: &&'a Edge) -> Node {\n+        edge.to\n+    }\n+}\n+\n+fn test_input(g: LabelledGraph) -> io::Result<String> {\n+    let mut writer = Vec::new();\n+    render(&g, &mut writer).unwrap();\n+    let mut s = String::new();\n+    Read::read_to_string(&mut &*writer, &mut s)?;\n+    Ok(s)\n+}\n+\n+// All of the tests use raw-strings as the format for the expected outputs,\n+// so that you can cut-and-paste the content into a .dot file yourself to\n+// see what the graphviz visualizer would produce.\n+\n+#[test]\n+fn empty_graph() {\n+    let labels: Trivial = UnlabelledNodes(0);\n+    let r = test_input(LabelledGraph::new(\"empty_graph\", labels, vec![], None));\n+    assert_eq!(r.unwrap(),\n+r#\"digraph empty_graph {\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn single_node() {\n+    let labels: Trivial = UnlabelledNodes(1);\n+    let r = test_input(LabelledGraph::new(\"single_node\", labels, vec![], None));\n+    assert_eq!(r.unwrap(),\n+r#\"digraph single_node {\n+    N0[label=\"N0\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn single_node_with_style() {\n+    let labels: Trivial = UnlabelledNodes(1);\n+    let styles = Some(vec![Style::Dashed]);\n+    let r = test_input(LabelledGraph::new(\"single_node\", labels, vec![], styles));\n+    assert_eq!(r.unwrap(),\n+r#\"digraph single_node {\n+    N0[label=\"N0\"][style=\"dashed\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn single_edge() {\n+    let labels: Trivial = UnlabelledNodes(2);\n+    let result = test_input(LabelledGraph::new(\"single_edge\",\n+                                               labels,\n+                                               vec![edge(0, 1, \"E\", Style::None)],\n+                                               None));\n+    assert_eq!(result.unwrap(),\n+r#\"digraph single_edge {\n+    N0[label=\"N0\"];\n+    N1[label=\"N1\"];\n+    N0 -> N1[label=\"E\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn single_edge_with_style() {\n+    let labels: Trivial = UnlabelledNodes(2);\n+    let result = test_input(LabelledGraph::new(\"single_edge\",\n+                                               labels,\n+                                               vec![edge(0, 1, \"E\", Style::Bold)],\n+                                               None));\n+    assert_eq!(result.unwrap(),\n+r#\"digraph single_edge {\n+    N0[label=\"N0\"];\n+    N1[label=\"N1\"];\n+    N0 -> N1[label=\"E\"][style=\"bold\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn test_some_labelled() {\n+    let labels: Trivial = SomeNodesLabelled(vec![Some(\"A\"), None]);\n+    let styles = Some(vec![Style::None, Style::Dotted]);\n+    let result = test_input(LabelledGraph::new(\"test_some_labelled\",\n+                                               labels,\n+                                               vec![edge(0, 1, \"A-1\", Style::None)],\n+                                               styles));\n+    assert_eq!(result.unwrap(),\n+r#\"digraph test_some_labelled {\n+    N0[label=\"A\"];\n+    N1[label=\"N1\"][style=\"dotted\"];\n+    N0 -> N1[label=\"A-1\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn single_cyclic_node() {\n+    let labels: Trivial = UnlabelledNodes(1);\n+    let r = test_input(LabelledGraph::new(\"single_cyclic_node\",\n+                                          labels,\n+                                          vec![edge(0, 0, \"E\", Style::None)],\n+                                          None));\n+    assert_eq!(r.unwrap(),\n+r#\"digraph single_cyclic_node {\n+    N0[label=\"N0\"];\n+    N0 -> N0[label=\"E\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn hasse_diagram() {\n+    let labels = AllNodesLabelled(vec![\"{x,y}\", \"{x}\", \"{y}\", \"{}\"]);\n+    let r = test_input(LabelledGraph::new(\"hasse_diagram\",\n+                                          labels,\n+                                          vec![edge(0, 1, \"\", Style::None),\n+                                               edge(0, 2, \"\", Style::None),\n+                                               edge(1, 3, \"\", Style::None),\n+                                               edge(2, 3, \"\", Style::None)],\n+                                          None));\n+    assert_eq!(r.unwrap(),\n+r#\"digraph hasse_diagram {\n+    N0[label=\"{x,y}\"];\n+    N1[label=\"{x}\"];\n+    N2[label=\"{y}\"];\n+    N3[label=\"{}\"];\n+    N0 -> N1[label=\"\"];\n+    N0 -> N2[label=\"\"];\n+    N1 -> N3[label=\"\"];\n+    N2 -> N3[label=\"\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn left_aligned_text() {\n+    let labels = AllNodesLabelled(vec![\n+        \"if test {\\\n+       \\\\l    branch1\\\n+       \\\\l} else {\\\n+       \\\\l    branch2\\\n+       \\\\l}\\\n+       \\\\lafterward\\\n+       \\\\l\",\n+        \"branch1\",\n+        \"branch2\",\n+        \"afterward\"]);\n+\n+    let mut writer = Vec::new();\n+\n+    let g = LabelledGraphWithEscStrs::new(\"syntax_tree\",\n+                                          labels,\n+                                          vec![edge(0, 1, \"then\", Style::None),\n+                                               edge(0, 2, \"else\", Style::None),\n+                                               edge(1, 3, \";\", Style::None),\n+                                               edge(2, 3, \";\", Style::None)]);\n+\n+    render(&g, &mut writer).unwrap();\n+    let mut r = String::new();\n+    Read::read_to_string(&mut &*writer, &mut r).unwrap();\n+\n+    assert_eq!(r,\n+r#\"digraph syntax_tree {\n+    N0[label=\"if test {\\l    branch1\\l} else {\\l    branch2\\l}\\lafterward\\l\"];\n+    N1[label=\"branch1\"];\n+    N2[label=\"branch2\"];\n+    N3[label=\"afterward\"];\n+    N0 -> N1[label=\"then\"];\n+    N0 -> N2[label=\"else\"];\n+    N1 -> N3[label=\";\"];\n+    N2 -> N3[label=\";\"];\n+}\n+\"#);\n+}\n+\n+#[test]\n+fn simple_id_construction() {\n+    let id1 = Id::new(\"hello\");\n+    match id1 {\n+        Ok(_) => {}\n+        Err(..) => panic!(\"'hello' is not a valid value for id anymore\"),\n+    }\n+}\n+\n+#[test]\n+fn badly_formatted_id() {\n+    let id2 = Id::new(\"Weird { struct : ure } !!!\");\n+    match id2 {\n+        Ok(_) => panic!(\"graphviz id suddenly allows spaces, brackets and stuff\"),\n+        Err(..) => {}\n+    }\n+}"}, {"sha": "fc092481a4a960e364c861a1cefaae272079344a", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 710, "changes": 711, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! Contains infrastructure for configuring the compiler, including parsing\n //! command line options.\n \n@@ -2720,711 +2718,4 @@ mod dep_tracking {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use getopts;\n-    use crate::lint;\n-    use crate::middle::cstore;\n-    use crate::session::config::{\n-        build_configuration,\n-        build_session_options_and_crate_config,\n-        to_crate_config\n-    };\n-    use crate::session::config::{LtoCli, LinkerPluginLto, SwitchWithOptPath, ExternEntry};\n-    use crate::session::build_session;\n-    use crate::session::search_paths::SearchPath;\n-    use std::collections::{BTreeMap, BTreeSet};\n-    use std::iter::FromIterator;\n-    use std::path::PathBuf;\n-    use super::{Externs, OutputType, OutputTypes, SymbolManglingVersion};\n-    use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel};\n-    use syntax::symbol::sym;\n-    use syntax::edition::{Edition, DEFAULT_EDITION};\n-    use syntax;\n-    use super::Options;\n-\n-    impl ExternEntry {\n-        fn new_public<S: Into<String>,\n-                      I: IntoIterator<Item = Option<S>>>(locations: I) -> ExternEntry {\n-            let locations: BTreeSet<_> = locations.into_iter().map(|o| o.map(|s| s.into()))\n-                .collect();\n-\n-            ExternEntry {\n-                locations,\n-                is_private_dep: false\n-            }\n-        }\n-    }\n-\n-    fn optgroups() -> getopts::Options {\n-        let mut opts = getopts::Options::new();\n-        for group in super::rustc_optgroups() {\n-            (group.apply)(&mut opts);\n-        }\n-        return opts;\n-    }\n-\n-    fn mk_map<K: Ord, V>(entries: Vec<(K, V)>) -> BTreeMap<K, V> {\n-        BTreeMap::from_iter(entries.into_iter())\n-    }\n-\n-    // When the user supplies --test we should implicitly supply --cfg test\n-    #[test]\n-    fn test_switch_implies_cfg_test() {\n-        syntax::with_default_globals(|| {\n-            let matches = &match optgroups().parse(&[\"--test\".to_string()]) {\n-                Ok(m) => m,\n-                Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f),\n-            };\n-            let registry = errors::registry::Registry::new(&[]);\n-            let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n-            let sess = build_session(sessopts, None, registry);\n-            let cfg = build_configuration(&sess, to_crate_config(cfg));\n-            assert!(cfg.contains(&(sym::test, None)));\n-        });\n-    }\n-\n-    // When the user supplies --test and --cfg test, don't implicitly add\n-    // another --cfg test\n-    #[test]\n-    fn test_switch_implies_cfg_test_unless_cfg_test() {\n-        syntax::with_default_globals(|| {\n-            let matches = &match optgroups().parse(&[\"--test\".to_string(),\n-                                                     \"--cfg=test\".to_string()]) {\n-                Ok(m) => m,\n-                Err(f) => panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f),\n-            };\n-            let registry = errors::registry::Registry::new(&[]);\n-            let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n-            let sess = build_session(sessopts, None, registry);\n-            let cfg = build_configuration(&sess, to_crate_config(cfg));\n-            let mut test_items = cfg.iter().filter(|&&(name, _)| name == sym::test);\n-            assert!(test_items.next().is_some());\n-            assert!(test_items.next().is_none());\n-        });\n-    }\n-\n-    #[test]\n-    fn test_can_print_warnings() {\n-        syntax::with_default_globals(|| {\n-            let matches = optgroups().parse(&[\"-Awarnings\".to_string()]).unwrap();\n-            let registry = errors::registry::Registry::new(&[]);\n-            let (sessopts, _) = build_session_options_and_crate_config(&matches);\n-            let sess = build_session(sessopts, None, registry);\n-            assert!(!sess.diagnostic().flags.can_emit_warnings);\n-        });\n-\n-        syntax::with_default_globals(|| {\n-            let matches = optgroups()\n-                .parse(&[\"-Awarnings\".to_string(), \"-Dwarnings\".to_string()])\n-                .unwrap();\n-            let registry = errors::registry::Registry::new(&[]);\n-            let (sessopts, _) = build_session_options_and_crate_config(&matches);\n-            let sess = build_session(sessopts, None, registry);\n-            assert!(sess.diagnostic().flags.can_emit_warnings);\n-        });\n-\n-        syntax::with_default_globals(|| {\n-            let matches = optgroups().parse(&[\"-Adead_code\".to_string()]).unwrap();\n-            let registry = errors::registry::Registry::new(&[]);\n-            let (sessopts, _) = build_session_options_and_crate_config(&matches);\n-            let sess = build_session(sessopts, None, registry);\n-            assert!(sess.diagnostic().flags.can_emit_warnings);\n-        });\n-    }\n-\n-    #[test]\n-    fn test_output_types_tracking_hash_different_paths() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-        let mut v3 = Options::default();\n-\n-        v1.output_types =\n-            OutputTypes::new(&[(OutputType::Exe, Some(PathBuf::from(\"./some/thing\")))]);\n-        v2.output_types =\n-            OutputTypes::new(&[(OutputType::Exe, Some(PathBuf::from(\"/some/thing\")))]);\n-        v3.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n-\n-        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n-        assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_output_types_tracking_hash_different_construction_order() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-\n-        v1.output_types = OutputTypes::new(&[\n-            (OutputType::Exe, Some(PathBuf::from(\"./some/thing\"))),\n-            (OutputType::Bitcode, Some(PathBuf::from(\"./some/thing.bc\"))),\n-        ]);\n-\n-        v2.output_types = OutputTypes::new(&[\n-            (OutputType::Bitcode, Some(PathBuf::from(\"./some/thing.bc\"))),\n-            (OutputType::Exe, Some(PathBuf::from(\"./some/thing\"))),\n-        ]);\n-\n-        assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_externs_tracking_hash_different_construction_order() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-        let mut v3 = Options::default();\n-\n-        v1.externs = Externs::new(mk_map(vec![\n-            (\n-                String::from(\"a\"),\n-                ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n-            ),\n-            (\n-                String::from(\"d\"),\n-                ExternEntry::new_public(vec![Some(\"e\"), Some(\"f\")])\n-            ),\n-        ]));\n-\n-        v2.externs = Externs::new(mk_map(vec![\n-            (\n-                String::from(\"d\"),\n-                ExternEntry::new_public(vec![Some(\"e\"), Some(\"f\")])\n-            ),\n-            (\n-                String::from(\"a\"),\n-                ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n-            ),\n-        ]));\n-\n-        v3.externs = Externs::new(mk_map(vec![\n-            (\n-                String::from(\"a\"),\n-                ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n-            ),\n-            (\n-                String::from(\"d\"),\n-                ExternEntry::new_public(vec![Some(\"f\"), Some(\"e\")])\n-            ),\n-        ]));\n-\n-        assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n-        assert_eq!(v1.dep_tracking_hash(), v3.dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v3.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_lints_tracking_hash_different_values() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-        let mut v3 = Options::default();\n-\n-        v1.lint_opts = vec![\n-            (String::from(\"a\"), lint::Allow),\n-            (String::from(\"b\"), lint::Warn),\n-            (String::from(\"c\"), lint::Deny),\n-            (String::from(\"d\"), lint::Forbid),\n-        ];\n-\n-        v2.lint_opts = vec![\n-            (String::from(\"a\"), lint::Allow),\n-            (String::from(\"b\"), lint::Warn),\n-            (String::from(\"X\"), lint::Deny),\n-            (String::from(\"d\"), lint::Forbid),\n-        ];\n-\n-        v3.lint_opts = vec![\n-            (String::from(\"a\"), lint::Allow),\n-            (String::from(\"b\"), lint::Warn),\n-            (String::from(\"c\"), lint::Forbid),\n-            (String::from(\"d\"), lint::Deny),\n-        ];\n-\n-        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n-        assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_lints_tracking_hash_different_construction_order() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-\n-        v1.lint_opts = vec![\n-            (String::from(\"a\"), lint::Allow),\n-            (String::from(\"b\"), lint::Warn),\n-            (String::from(\"c\"), lint::Deny),\n-            (String::from(\"d\"), lint::Forbid),\n-        ];\n-\n-        v2.lint_opts = vec![\n-            (String::from(\"a\"), lint::Allow),\n-            (String::from(\"c\"), lint::Deny),\n-            (String::from(\"b\"), lint::Warn),\n-            (String::from(\"d\"), lint::Forbid),\n-        ];\n-\n-        assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_search_paths_tracking_hash_different_order() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-        let mut v3 = Options::default();\n-        let mut v4 = Options::default();\n-\n-        const JSON: super::ErrorOutputType = super::ErrorOutputType::Json {\n-            pretty: false,\n-            json_rendered: super::HumanReadableErrorType::Default(super::ColorConfig::Never),\n-        };\n-\n-        // Reference\n-        v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n-        v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n-        v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n-        v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n-        v1.search_paths\n-            .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n-\n-        v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n-        v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n-        v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n-        v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n-        v2.search_paths\n-            .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n-\n-        v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n-        v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n-        v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n-        v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n-        v3.search_paths\n-            .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n-\n-        v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n-        v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n-        v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n-        v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n-        v4.search_paths\n-            .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n-\n-        assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() == v4.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-        assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_native_libs_tracking_hash_different_values() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-        let mut v3 = Options::default();\n-        let mut v4 = Options::default();\n-\n-        // Reference\n-        v1.libs = vec![\n-            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-            (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n-            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-        ];\n-\n-        // Change label\n-        v2.libs = vec![\n-            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-            (String::from(\"X\"), None, Some(cstore::NativeFramework)),\n-            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-        ];\n-\n-        // Change kind\n-        v3.libs = vec![\n-            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-            (String::from(\"b\"), None, Some(cstore::NativeStatic)),\n-            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-        ];\n-\n-        // Change new-name\n-        v4.libs = vec![\n-            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-            (\n-                String::from(\"b\"),\n-                Some(String::from(\"X\")),\n-                Some(cstore::NativeFramework),\n-            ),\n-            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-        ];\n-\n-        assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() != v4.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-        assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_native_libs_tracking_hash_different_order() {\n-        let mut v1 = Options::default();\n-        let mut v2 = Options::default();\n-        let mut v3 = Options::default();\n-\n-        // Reference\n-        v1.libs = vec![\n-            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-            (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n-            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-        ];\n-\n-        v2.libs = vec![\n-            (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n-            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-        ];\n-\n-        v3.libs = vec![\n-            (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n-            (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n-            (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n-        ];\n-\n-        assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n-        assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n-        assert!(v2.dep_tracking_hash() == v3.dep_tracking_hash());\n-\n-        // Check clone\n-        assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n-        assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n-        assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_codegen_options_tracking_hash() {\n-        let reference = Options::default();\n-        let mut opts = Options::default();\n-\n-        // Make sure the changing an [UNTRACKED] option leaves the hash unchanged\n-        opts.cg.ar = Some(String::from(\"abc\"));\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.linker = Some(PathBuf::from(\"linker\"));\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.link_args = Some(vec![String::from(\"abc\"), String::from(\"def\")]);\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.link_dead_code = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.rpath = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.extra_filename = String::from(\"extra-filename\");\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.codegen_units = Some(42);\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.remark = super::Passes::Some(vec![String::from(\"pass1\"), String::from(\"pass2\")]);\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.save_temps = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts.cg.incremental = Some(String::from(\"abc\"));\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        // Make sure changing a [TRACKED] option changes the hash\n-        opts = reference.clone();\n-        opts.cg.lto = LtoCli::Fat;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.target_cpu = Some(String::from(\"abc\"));\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.target_feature = String::from(\"all the features, all of them\");\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.passes = vec![String::from(\"1\"), String::from(\"2\")];\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.llvm_args = vec![String::from(\"1\"), String::from(\"2\")];\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.overflow_checks = Some(true);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.no_prepopulate_passes = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.no_vectorize_loops = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.no_vectorize_slp = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.soft_float = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.prefer_dynamic = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.no_integrated_as = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.no_redzone = Some(true);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.relocation_model = Some(String::from(\"relocation model\"));\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.code_model = Some(String::from(\"code model\"));\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.tls_model = Some(String::from(\"tls model\"));\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.pgo_gen = SwitchWithOptPath::Enabled(None);\n-        assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.pgo_use = Some(PathBuf::from(\"abc\"));\n-        assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.metadata = vec![String::from(\"A\"), String::from(\"B\")];\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.debuginfo = Some(0xdeadbeef);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.debuginfo = Some(0xba5eba11);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.force_frame_pointers = Some(false);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.debug_assertions = Some(true);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.inline_threshold = Some(0xf007ba11);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.panic = Some(PanicStrategy::Abort);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.cg.linker_plugin_lto = LinkerPluginLto::LinkerPluginAuto;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_debugging_options_tracking_hash() {\n-        let reference = Options::default();\n-        let mut opts = Options::default();\n-\n-        // Make sure the changing an [UNTRACKED] option leaves the hash unchanged\n-        opts.debugging_opts.verbose = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.time_passes = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.time_llvm_passes = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.input_stats = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.borrowck_stats = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.meta_stats = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.print_link_args = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.print_llvm_passes = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.ast_json = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.ast_json_noexpand = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.ls = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.save_analysis = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.flowgraph_print_loans = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.flowgraph_print_moves = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.flowgraph_print_assigns = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.flowgraph_print_all = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.print_region_graph = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.parse_only = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.incremental = Some(String::from(\"abc\"));\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.dump_dep_graph = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.query_dep_graph = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.no_analysis = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.unstable_options = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.trace_macros = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.keep_hygiene_data = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.keep_ast = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.print_mono_items = Some(String::from(\"abc\"));\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.dump_mir = Some(String::from(\"abc\"));\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.dump_mir_dir = String::from(\"abc\");\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-        opts.debugging_opts.dump_mir_graphviz = true;\n-        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n-\n-        // Make sure changing a [TRACKED] option changes the hash\n-        opts = reference.clone();\n-        opts.debugging_opts.asm_comments = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.verify_llvm_ir = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.no_landing_pads = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.fewer_names = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.no_codegen = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.treat_err_as_bug = Some(1);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.report_delayed_bugs = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.continue_parse_after_error = true;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.extra_plugins = vec![String::from(\"plugin1\"), String::from(\"plugin2\")];\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.force_overflow_checks = Some(true);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.show_span = Some(String::from(\"abc\"));\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.mir_opt_level = 3;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.relro_level = Some(RelroLevel::Full);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.merge_functions = Some(MergeFunctions::Disabled);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.allow_features = Some(vec![String::from(\"lang_items\")]);\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-\n-        opts = reference.clone();\n-        opts.debugging_opts.symbol_mangling_version = SymbolManglingVersion::V0;\n-        assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n-    }\n-\n-    #[test]\n-    fn test_edition_parsing() {\n-        // test default edition\n-        let options = Options::default();\n-        assert!(options.edition == DEFAULT_EDITION);\n-\n-        let matches = optgroups()\n-            .parse(&[\"--edition=2018\".to_string()])\n-            .unwrap();\n-        let (sessopts, _) = build_session_options_and_crate_config(&matches);\n-        assert!(sessopts.edition == Edition::Edition2018)\n-    }\n-}\n+mod tests;"}, {"sha": "b8477f8dd178956ed298452c12fc3d8d44757fbc", "filename": "src/librustc/session/config/tests.rs", "status": "added", "additions": 706, "deletions": 0, "changes": 706, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,706 @@\n+use getopts;\n+use crate::lint;\n+use crate::middle::cstore;\n+use crate::session::config::{\n+    build_configuration,\n+    build_session_options_and_crate_config,\n+    to_crate_config\n+};\n+use crate::session::config::{LtoCli, LinkerPluginLto, SwitchWithOptPath, ExternEntry};\n+use crate::session::build_session;\n+use crate::session::search_paths::SearchPath;\n+use std::collections::{BTreeMap, BTreeSet};\n+use std::iter::FromIterator;\n+use std::path::PathBuf;\n+use super::{Externs, OutputType, OutputTypes, SymbolManglingVersion};\n+use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel};\n+use syntax::symbol::sym;\n+use syntax::edition::{Edition, DEFAULT_EDITION};\n+use syntax;\n+use super::Options;\n+\n+impl ExternEntry {\n+    fn new_public<S: Into<String>,\n+                  I: IntoIterator<Item = Option<S>>>(locations: I) -> ExternEntry {\n+        let locations: BTreeSet<_> = locations.into_iter().map(|o| o.map(|s| s.into()))\n+            .collect();\n+\n+        ExternEntry {\n+            locations,\n+            is_private_dep: false\n+        }\n+    }\n+}\n+\n+fn optgroups() -> getopts::Options {\n+    let mut opts = getopts::Options::new();\n+    for group in super::rustc_optgroups() {\n+        (group.apply)(&mut opts);\n+    }\n+    return opts;\n+}\n+\n+fn mk_map<K: Ord, V>(entries: Vec<(K, V)>) -> BTreeMap<K, V> {\n+    BTreeMap::from_iter(entries.into_iter())\n+}\n+\n+// When the user supplies --test we should implicitly supply --cfg test\n+#[test]\n+fn test_switch_implies_cfg_test() {\n+    syntax::with_default_globals(|| {\n+        let matches = &match optgroups().parse(&[\"--test\".to_string()]) {\n+            Ok(m) => m,\n+            Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f),\n+        };\n+        let registry = errors::registry::Registry::new(&[]);\n+        let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n+        let sess = build_session(sessopts, None, registry);\n+        let cfg = build_configuration(&sess, to_crate_config(cfg));\n+        assert!(cfg.contains(&(sym::test, None)));\n+    });\n+}\n+\n+// When the user supplies --test and --cfg test, don't implicitly add\n+// another --cfg test\n+#[test]\n+fn test_switch_implies_cfg_test_unless_cfg_test() {\n+    syntax::with_default_globals(|| {\n+        let matches = &match optgroups().parse(&[\"--test\".to_string(),\n+                                                 \"--cfg=test\".to_string()]) {\n+            Ok(m) => m,\n+            Err(f) => panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f),\n+        };\n+        let registry = errors::registry::Registry::new(&[]);\n+        let (sessopts, cfg) = build_session_options_and_crate_config(matches);\n+        let sess = build_session(sessopts, None, registry);\n+        let cfg = build_configuration(&sess, to_crate_config(cfg));\n+        let mut test_items = cfg.iter().filter(|&&(name, _)| name == sym::test);\n+        assert!(test_items.next().is_some());\n+        assert!(test_items.next().is_none());\n+    });\n+}\n+\n+#[test]\n+fn test_can_print_warnings() {\n+    syntax::with_default_globals(|| {\n+        let matches = optgroups().parse(&[\"-Awarnings\".to_string()]).unwrap();\n+        let registry = errors::registry::Registry::new(&[]);\n+        let (sessopts, _) = build_session_options_and_crate_config(&matches);\n+        let sess = build_session(sessopts, None, registry);\n+        assert!(!sess.diagnostic().flags.can_emit_warnings);\n+    });\n+\n+    syntax::with_default_globals(|| {\n+        let matches = optgroups()\n+            .parse(&[\"-Awarnings\".to_string(), \"-Dwarnings\".to_string()])\n+            .unwrap();\n+        let registry = errors::registry::Registry::new(&[]);\n+        let (sessopts, _) = build_session_options_and_crate_config(&matches);\n+        let sess = build_session(sessopts, None, registry);\n+        assert!(sess.diagnostic().flags.can_emit_warnings);\n+    });\n+\n+    syntax::with_default_globals(|| {\n+        let matches = optgroups().parse(&[\"-Adead_code\".to_string()]).unwrap();\n+        let registry = errors::registry::Registry::new(&[]);\n+        let (sessopts, _) = build_session_options_and_crate_config(&matches);\n+        let sess = build_session(sessopts, None, registry);\n+        assert!(sess.diagnostic().flags.can_emit_warnings);\n+    });\n+}\n+\n+#[test]\n+fn test_output_types_tracking_hash_different_paths() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+    let mut v3 = Options::default();\n+\n+    v1.output_types =\n+        OutputTypes::new(&[(OutputType::Exe, Some(PathBuf::from(\"./some/thing\")))]);\n+    v2.output_types =\n+        OutputTypes::new(&[(OutputType::Exe, Some(PathBuf::from(\"/some/thing\")))]);\n+    v3.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n+\n+    assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+    assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+    assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_output_types_tracking_hash_different_construction_order() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+\n+    v1.output_types = OutputTypes::new(&[\n+        (OutputType::Exe, Some(PathBuf::from(\"./some/thing\"))),\n+        (OutputType::Bitcode, Some(PathBuf::from(\"./some/thing.bc\"))),\n+    ]);\n+\n+    v2.output_types = OutputTypes::new(&[\n+        (OutputType::Bitcode, Some(PathBuf::from(\"./some/thing.bc\"))),\n+        (OutputType::Exe, Some(PathBuf::from(\"./some/thing\"))),\n+    ]);\n+\n+    assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_externs_tracking_hash_different_construction_order() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+    let mut v3 = Options::default();\n+\n+    v1.externs = Externs::new(mk_map(vec![\n+        (\n+            String::from(\"a\"),\n+            ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n+        ),\n+        (\n+            String::from(\"d\"),\n+            ExternEntry::new_public(vec![Some(\"e\"), Some(\"f\")])\n+        ),\n+    ]));\n+\n+    v2.externs = Externs::new(mk_map(vec![\n+        (\n+            String::from(\"d\"),\n+            ExternEntry::new_public(vec![Some(\"e\"), Some(\"f\")])\n+        ),\n+        (\n+            String::from(\"a\"),\n+            ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n+        ),\n+    ]));\n+\n+    v3.externs = Externs::new(mk_map(vec![\n+        (\n+            String::from(\"a\"),\n+            ExternEntry::new_public(vec![Some(\"b\"), Some(\"c\")])\n+        ),\n+        (\n+            String::from(\"d\"),\n+            ExternEntry::new_public(vec![Some(\"f\"), Some(\"e\")])\n+        ),\n+    ]));\n+\n+    assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n+    assert_eq!(v1.dep_tracking_hash(), v3.dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v3.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_lints_tracking_hash_different_values() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+    let mut v3 = Options::default();\n+\n+    v1.lint_opts = vec![\n+        (String::from(\"a\"), lint::Allow),\n+        (String::from(\"b\"), lint::Warn),\n+        (String::from(\"c\"), lint::Deny),\n+        (String::from(\"d\"), lint::Forbid),\n+    ];\n+\n+    v2.lint_opts = vec![\n+        (String::from(\"a\"), lint::Allow),\n+        (String::from(\"b\"), lint::Warn),\n+        (String::from(\"X\"), lint::Deny),\n+        (String::from(\"d\"), lint::Forbid),\n+    ];\n+\n+    v3.lint_opts = vec![\n+        (String::from(\"a\"), lint::Allow),\n+        (String::from(\"b\"), lint::Warn),\n+        (String::from(\"c\"), lint::Forbid),\n+        (String::from(\"d\"), lint::Deny),\n+    ];\n+\n+    assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+    assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+    assert!(v2.dep_tracking_hash() != v3.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_lints_tracking_hash_different_construction_order() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+\n+    v1.lint_opts = vec![\n+        (String::from(\"a\"), lint::Allow),\n+        (String::from(\"b\"), lint::Warn),\n+        (String::from(\"c\"), lint::Deny),\n+        (String::from(\"d\"), lint::Forbid),\n+    ];\n+\n+    v2.lint_opts = vec![\n+        (String::from(\"a\"), lint::Allow),\n+        (String::from(\"c\"), lint::Deny),\n+        (String::from(\"b\"), lint::Warn),\n+        (String::from(\"d\"), lint::Forbid),\n+    ];\n+\n+    assert_eq!(v1.dep_tracking_hash(), v2.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_search_paths_tracking_hash_different_order() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+    let mut v3 = Options::default();\n+    let mut v4 = Options::default();\n+\n+    const JSON: super::ErrorOutputType = super::ErrorOutputType::Json {\n+        pretty: false,\n+        json_rendered: super::HumanReadableErrorType::Default(super::ColorConfig::Never),\n+    };\n+\n+    // Reference\n+    v1.search_paths\n+        .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n+    v1.search_paths\n+        .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n+    v1.search_paths\n+        .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n+    v1.search_paths\n+        .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n+    v1.search_paths\n+        .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n+\n+    v2.search_paths\n+        .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n+    v2.search_paths\n+        .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n+    v2.search_paths\n+        .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n+    v2.search_paths\n+        .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n+    v2.search_paths\n+        .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n+\n+    v3.search_paths\n+        .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n+    v3.search_paths\n+        .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n+    v3.search_paths\n+        .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n+    v3.search_paths\n+        .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n+    v3.search_paths\n+        .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n+\n+    v4.search_paths\n+        .push(SearchPath::from_cli_opt(\"all=mno\", JSON));\n+    v4.search_paths\n+        .push(SearchPath::from_cli_opt(\"native=abc\", JSON));\n+    v4.search_paths\n+        .push(SearchPath::from_cli_opt(\"crate=def\", JSON));\n+    v4.search_paths\n+        .push(SearchPath::from_cli_opt(\"dependency=ghi\", JSON));\n+    v4.search_paths\n+        .push(SearchPath::from_cli_opt(\"framework=jkl\", JSON));\n+\n+    assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n+    assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n+    assert!(v1.dep_tracking_hash() == v4.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_native_libs_tracking_hash_different_values() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+    let mut v3 = Options::default();\n+    let mut v4 = Options::default();\n+\n+    // Reference\n+    v1.libs = vec![\n+        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+        (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+    ];\n+\n+    // Change label\n+    v2.libs = vec![\n+        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+        (String::from(\"X\"), None, Some(cstore::NativeFramework)),\n+        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+    ];\n+\n+    // Change kind\n+    v3.libs = vec![\n+        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+        (String::from(\"b\"), None, Some(cstore::NativeStatic)),\n+        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+    ];\n+\n+    // Change new-name\n+    v4.libs = vec![\n+        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+        (\n+            String::from(\"b\"),\n+            Some(String::from(\"X\")),\n+            Some(cstore::NativeFramework),\n+        ),\n+        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+    ];\n+\n+    assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n+    assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+    assert!(v1.dep_tracking_hash() != v4.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+    assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_native_libs_tracking_hash_different_order() {\n+    let mut v1 = Options::default();\n+    let mut v2 = Options::default();\n+    let mut v3 = Options::default();\n+\n+    // Reference\n+    v1.libs = vec![\n+        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+        (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+    ];\n+\n+    v2.libs = vec![\n+        (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+    ];\n+\n+    v3.libs = vec![\n+        (String::from(\"c\"), None, Some(cstore::NativeUnknown)),\n+        (String::from(\"a\"), None, Some(cstore::NativeStatic)),\n+        (String::from(\"b\"), None, Some(cstore::NativeFramework)),\n+    ];\n+\n+    assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n+    assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n+    assert!(v2.dep_tracking_hash() == v3.dep_tracking_hash());\n+\n+    // Check clone\n+    assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n+    assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n+    assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_codegen_options_tracking_hash() {\n+    let reference = Options::default();\n+    let mut opts = Options::default();\n+\n+    // Make sure the changing an [UNTRACKED] option leaves the hash unchanged\n+    opts.cg.ar = Some(String::from(\"abc\"));\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.linker = Some(PathBuf::from(\"linker\"));\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.link_args = Some(vec![String::from(\"abc\"), String::from(\"def\")]);\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.link_dead_code = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.rpath = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.extra_filename = String::from(\"extra-filename\");\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.codegen_units = Some(42);\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.remark = super::Passes::Some(vec![String::from(\"pass1\"), String::from(\"pass2\")]);\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.save_temps = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts.cg.incremental = Some(String::from(\"abc\"));\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    // Make sure changing a [TRACKED] option changes the hash\n+    opts = reference.clone();\n+    opts.cg.lto = LtoCli::Fat;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.target_cpu = Some(String::from(\"abc\"));\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.target_feature = String::from(\"all the features, all of them\");\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.passes = vec![String::from(\"1\"), String::from(\"2\")];\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.llvm_args = vec![String::from(\"1\"), String::from(\"2\")];\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.overflow_checks = Some(true);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.no_prepopulate_passes = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.no_vectorize_loops = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.no_vectorize_slp = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.soft_float = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.prefer_dynamic = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.no_integrated_as = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.no_redzone = Some(true);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.relocation_model = Some(String::from(\"relocation model\"));\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.code_model = Some(String::from(\"code model\"));\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.tls_model = Some(String::from(\"tls model\"));\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.pgo_gen = SwitchWithOptPath::Enabled(None);\n+    assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.pgo_use = Some(PathBuf::from(\"abc\"));\n+    assert_ne!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.metadata = vec![String::from(\"A\"), String::from(\"B\")];\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.debuginfo = Some(0xdeadbeef);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.debuginfo = Some(0xba5eba11);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.force_frame_pointers = Some(false);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.debug_assertions = Some(true);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.inline_threshold = Some(0xf007ba11);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.panic = Some(PanicStrategy::Abort);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.cg.linker_plugin_lto = LinkerPluginLto::LinkerPluginAuto;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_debugging_options_tracking_hash() {\n+    let reference = Options::default();\n+    let mut opts = Options::default();\n+\n+    // Make sure the changing an [UNTRACKED] option leaves the hash unchanged\n+    opts.debugging_opts.verbose = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.time_passes = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.time_llvm_passes = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.input_stats = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.borrowck_stats = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.meta_stats = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.print_link_args = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.print_llvm_passes = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.ast_json = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.ast_json_noexpand = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.ls = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.save_analysis = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.flowgraph_print_loans = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.flowgraph_print_moves = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.flowgraph_print_assigns = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.flowgraph_print_all = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.print_region_graph = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.parse_only = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.incremental = Some(String::from(\"abc\"));\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.dump_dep_graph = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.query_dep_graph = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.no_analysis = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.unstable_options = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.trace_macros = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.keep_hygiene_data = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.keep_ast = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.print_mono_items = Some(String::from(\"abc\"));\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.dump_mir = Some(String::from(\"abc\"));\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.dump_mir_dir = String::from(\"abc\");\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+    opts.debugging_opts.dump_mir_graphviz = true;\n+    assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+\n+    // Make sure changing a [TRACKED] option changes the hash\n+    opts = reference.clone();\n+    opts.debugging_opts.asm_comments = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.verify_llvm_ir = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.no_landing_pads = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.fewer_names = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.no_codegen = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.treat_err_as_bug = Some(1);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.report_delayed_bugs = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.continue_parse_after_error = true;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.extra_plugins = vec![String::from(\"plugin1\"), String::from(\"plugin2\")];\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.force_overflow_checks = Some(true);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.show_span = Some(String::from(\"abc\"));\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.mir_opt_level = 3;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.relro_level = Some(RelroLevel::Full);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.merge_functions = Some(MergeFunctions::Disabled);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.allow_features = Some(vec![String::from(\"lang_items\")]);\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+\n+    opts = reference.clone();\n+    opts.debugging_opts.symbol_mangling_version = SymbolManglingVersion::V0;\n+    assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n+}\n+\n+#[test]\n+fn test_edition_parsing() {\n+    // test default edition\n+    let options = Options::default();\n+    assert!(options.edition == DEFAULT_EDITION);\n+\n+    let matches = optgroups()\n+        .parse(&[\"--edition=2018\".to_string()])\n+        .unwrap();\n+    let (sessopts, _) = build_session_options_and_crate_config(&matches);\n+    assert!(sessopts.edition == Edition::Edition2018)\n+}"}, {"sha": "e27cb6d8dda8973ade54bda2621b77dda290bebe", "filename": "src/librustc_codegen_ssa/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 95, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Frpath.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -173,98 +173,4 @@ fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n }\n \n #[cfg(all(unix, test))]\n-mod tests {\n-    use super::{RPathConfig};\n-    use super::{minimize_rpaths, rpaths_to_flags, get_rpath_relative_to_output};\n-    use std::path::{Path, PathBuf};\n-\n-    #[test]\n-    fn test_rpaths_to_flags() {\n-        let flags = rpaths_to_flags(&[\n-            \"path1\".to_string(),\n-            \"path2\".to_string()\n-        ]);\n-        assert_eq!(flags,\n-                   [\"-Wl,-rpath,path1\",\n-                    \"-Wl,-rpath,path2\"]);\n-    }\n-\n-    #[test]\n-    fn test_minimize1() {\n-        let res = minimize_rpaths(&[\n-            \"rpath1\".to_string(),\n-            \"rpath2\".to_string(),\n-            \"rpath1\".to_string()\n-        ]);\n-        assert!(res == [\n-            \"rpath1\",\n-            \"rpath2\",\n-        ]);\n-    }\n-\n-    #[test]\n-    fn test_minimize2() {\n-        let res = minimize_rpaths(&[\n-            \"1a\".to_string(),\n-            \"2\".to_string(),\n-            \"2\".to_string(),\n-            \"1a\".to_string(),\n-            \"4a\".to_string(),\n-            \"1a\".to_string(),\n-            \"2\".to_string(),\n-            \"3\".to_string(),\n-            \"4a\".to_string(),\n-            \"3\".to_string()\n-        ]);\n-        assert!(res == [\n-            \"1a\",\n-            \"2\",\n-            \"4a\",\n-            \"3\",\n-        ]);\n-    }\n-\n-    #[test]\n-    fn test_rpath_relative() {\n-        if cfg!(target_os = \"macos\") {\n-            let config = &mut RPathConfig {\n-                used_crates: Vec::new(),\n-                has_rpath: true,\n-                is_like_osx: true,\n-                linker_is_gnu: false,\n-                out_filename: PathBuf::from(\"bin/rustc\"),\n-                get_install_prefix_lib_path: &mut || panic!(),\n-            };\n-            let res = get_rpath_relative_to_output(config,\n-                                                   Path::new(\"lib/libstd.so\"));\n-            assert_eq!(res, \"@loader_path/../lib\");\n-        } else {\n-            let config = &mut RPathConfig {\n-                used_crates: Vec::new(),\n-                out_filename: PathBuf::from(\"bin/rustc\"),\n-                get_install_prefix_lib_path: &mut || panic!(),\n-                has_rpath: true,\n-                is_like_osx: false,\n-                linker_is_gnu: true,\n-            };\n-            let res = get_rpath_relative_to_output(config,\n-                                                   Path::new(\"lib/libstd.so\"));\n-            assert_eq!(res, \"$ORIGIN/../lib\");\n-        }\n-    }\n-\n-    #[test]\n-    fn test_xlinker() {\n-        let args = rpaths_to_flags(&[\n-            \"a/normal/path\".to_string(),\n-            \"a,comma,path\".to_string()\n-        ]);\n-\n-        assert_eq!(args, vec![\n-            \"-Wl,-rpath,a/normal/path\".to_string(),\n-            \"-Wl,-rpath\".to_string(),\n-            \"-Xlinker\".to_string(),\n-            \"a,comma,path\".to_string()\n-        ]);\n-    }\n-}\n+mod tests;"}, {"sha": "e42a878d7e45e8c9e0ef5ea9ee5a5e68036eabe2", "filename": "src/librustc_codegen_ssa/back/rpath/tests.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_codegen_ssa%2Fback%2Frpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_codegen_ssa%2Fback%2Frpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Frpath%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,93 @@\n+use super::{RPathConfig};\n+use super::{minimize_rpaths, rpaths_to_flags, get_rpath_relative_to_output};\n+use std::path::{Path, PathBuf};\n+\n+#[test]\n+fn test_rpaths_to_flags() {\n+    let flags = rpaths_to_flags(&[\n+        \"path1\".to_string(),\n+        \"path2\".to_string()\n+    ]);\n+    assert_eq!(flags,\n+               [\"-Wl,-rpath,path1\",\n+                \"-Wl,-rpath,path2\"]);\n+}\n+\n+#[test]\n+fn test_minimize1() {\n+    let res = minimize_rpaths(&[\n+        \"rpath1\".to_string(),\n+        \"rpath2\".to_string(),\n+        \"rpath1\".to_string()\n+    ]);\n+    assert!(res == [\n+        \"rpath1\",\n+        \"rpath2\",\n+    ]);\n+}\n+\n+#[test]\n+fn test_minimize2() {\n+    let res = minimize_rpaths(&[\n+        \"1a\".to_string(),\n+        \"2\".to_string(),\n+        \"2\".to_string(),\n+        \"1a\".to_string(),\n+        \"4a\".to_string(),\n+        \"1a\".to_string(),\n+        \"2\".to_string(),\n+        \"3\".to_string(),\n+        \"4a\".to_string(),\n+        \"3\".to_string()\n+    ]);\n+    assert!(res == [\n+        \"1a\",\n+        \"2\",\n+        \"4a\",\n+        \"3\",\n+    ]);\n+}\n+\n+#[test]\n+fn test_rpath_relative() {\n+    if cfg!(target_os = \"macos\") {\n+        let config = &mut RPathConfig {\n+            used_crates: Vec::new(),\n+            has_rpath: true,\n+            is_like_osx: true,\n+            linker_is_gnu: false,\n+            out_filename: PathBuf::from(\"bin/rustc\"),\n+            get_install_prefix_lib_path: &mut || panic!(),\n+        };\n+        let res = get_rpath_relative_to_output(config,\n+                                               Path::new(\"lib/libstd.so\"));\n+        assert_eq!(res, \"@loader_path/../lib\");\n+    } else {\n+        let config = &mut RPathConfig {\n+            used_crates: Vec::new(),\n+            out_filename: PathBuf::from(\"bin/rustc\"),\n+            get_install_prefix_lib_path: &mut || panic!(),\n+            has_rpath: true,\n+            is_like_osx: false,\n+            linker_is_gnu: true,\n+        };\n+        let res = get_rpath_relative_to_output(config,\n+                                               Path::new(\"lib/libstd.so\"));\n+        assert_eq!(res, \"$ORIGIN/../lib\");\n+    }\n+}\n+\n+#[test]\n+fn test_xlinker() {\n+    let args = rpaths_to_flags(&[\n+        \"a/normal/path\".to_string(),\n+        \"a,comma,path\".to_string()\n+    ]);\n+\n+    assert_eq!(args, vec![\n+        \"-Wl,-rpath,a/normal/path\".to_string(),\n+        \"-Wl,-rpath\".to_string(),\n+        \"-Xlinker\".to_string(),\n+        \"a,comma,path\".to_string()\n+    ]);\n+}"}, {"sha": "a7af615fa5000fae1423c087d2ebb2311c4c783b", "filename": "src/librustc_data_structures/owning_ref/mod.rs", "status": "modified", "additions": 1, "deletions": 714, "changes": 715, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2Fmod.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -1221,717 +1221,4 @@ pub type ErasedArcRef<U> = OwningRef<Arc<dyn Erased>, U>;\n pub type ErasedBoxRefMut<U> = OwningRefMut<Box<dyn Erased>, U>;\n \n #[cfg(test)]\n-mod tests {\n-    mod owning_ref {\n-        use super::super::OwningRef;\n-        use super::super::{RcRef, BoxRef, Erased, ErasedBoxRef};\n-        use std::cmp::{PartialEq, Ord, PartialOrd, Ordering};\n-        use std::hash::{Hash, Hasher};\n-        use std::collections::hash_map::DefaultHasher;\n-        use std::collections::HashMap;\n-        use std::rc::Rc;\n-\n-        #[derive(Debug, PartialEq)]\n-        struct Example(u32, String, [u8; 3]);\n-        fn example() -> Example {\n-            Example(42, \"hello world\".to_string(), [1, 2, 3])\n-        }\n-\n-        #[test]\n-        fn new_deref() {\n-            let or: OwningRef<Box<()>, ()> = OwningRef::new(Box::new(()));\n-            assert_eq!(&*or, &());\n-        }\n-\n-        #[test]\n-        fn into() {\n-            let or: OwningRef<Box<()>, ()> = Box::new(()).into();\n-            assert_eq!(&*or, &());\n-        }\n-\n-        #[test]\n-        fn map_offset_ref() {\n-            let or: BoxRef<Example> = Box::new(example()).into();\n-            let or: BoxRef<_, u32> = or.map(|x| &x.0);\n-            assert_eq!(&*or, &42);\n-\n-            let or: BoxRef<Example> = Box::new(example()).into();\n-            let or: BoxRef<_, u8> = or.map(|x| &x.2[1]);\n-            assert_eq!(&*or, &2);\n-        }\n-\n-        #[test]\n-        fn map_heap_ref() {\n-            let or: BoxRef<Example> = Box::new(example()).into();\n-            let or: BoxRef<_, str> = or.map(|x| &x.1[..5]);\n-            assert_eq!(&*or, \"hello\");\n-        }\n-\n-        #[test]\n-        fn map_static_ref() {\n-            let or: BoxRef<()> = Box::new(()).into();\n-            let or: BoxRef<_, str> = or.map(|_| \"hello\");\n-            assert_eq!(&*or, \"hello\");\n-        }\n-\n-        #[test]\n-        fn map_chained() {\n-            let or: BoxRef<String> = Box::new(example().1).into();\n-            let or: BoxRef<_, str> = or.map(|x| &x[1..5]);\n-            let or: BoxRef<_, str> = or.map(|x| &x[..2]);\n-            assert_eq!(&*or, \"el\");\n-        }\n-\n-        #[test]\n-        fn map_chained_inference() {\n-            let or = BoxRef::new(Box::new(example().1))\n-                .map(|x| &x[..5])\n-                .map(|x| &x[1..3]);\n-            assert_eq!(&*or, \"el\");\n-        }\n-\n-        #[test]\n-        fn owner() {\n-            let or: BoxRef<String> = Box::new(example().1).into();\n-            let or = or.map(|x| &x[..5]);\n-            assert_eq!(&*or, \"hello\");\n-            assert_eq!(&**or.owner(), \"hello world\");\n-        }\n-\n-        #[test]\n-        fn into_inner() {\n-            let or: BoxRef<String> = Box::new(example().1).into();\n-            let or = or.map(|x| &x[..5]);\n-            assert_eq!(&*or, \"hello\");\n-            let s = *or.into_inner();\n-            assert_eq!(&s, \"hello world\");\n-        }\n-\n-        #[test]\n-        fn fmt_debug() {\n-            let or: BoxRef<String> = Box::new(example().1).into();\n-            let or = or.map(|x| &x[..5]);\n-            let s = format!(\"{:?}\", or);\n-            assert_eq!(&s, \"OwningRef { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n-        }\n-\n-        #[test]\n-        fn erased_owner() {\n-            let o1: BoxRef<Example, str> = BoxRef::new(Box::new(example()))\n-                .map(|x| &x.1[..]);\n-\n-            let o2: BoxRef<String, str> = BoxRef::new(Box::new(example().1))\n-                .map(|x| &x[..]);\n-\n-            let os: Vec<ErasedBoxRef<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n-            assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n-        }\n-\n-        #[test]\n-        fn raii_locks() {\n-            use super::super::{RefRef, RefMutRef};\n-            use std::cell::RefCell;\n-            use super::super::{MutexGuardRef, RwLockReadGuardRef, RwLockWriteGuardRef};\n-            use std::sync::{Mutex, RwLock};\n-\n-            {\n-                let a = RefCell::new(1);\n-                let a = {\n-                    let a = RefRef::new(a.borrow());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-            {\n-                let a = RefCell::new(1);\n-                let a = {\n-                    let a = RefMutRef::new(a.borrow_mut());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-            {\n-                let a = Mutex::new(1);\n-                let a = {\n-                    let a = MutexGuardRef::new(a.lock().unwrap());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-            {\n-                let a = RwLock::new(1);\n-                let a = {\n-                    let a = RwLockReadGuardRef::new(a.read().unwrap());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-            {\n-                let a = RwLock::new(1);\n-                let a = {\n-                    let a = RwLockWriteGuardRef::new(a.write().unwrap());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-        }\n-\n-        #[test]\n-        fn eq() {\n-            let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-            let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-            assert_eq!(or1.eq(&or2), true);\n-        }\n-\n-        #[test]\n-        fn cmp() {\n-            let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-            let or2: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n-            assert_eq!(or1.cmp(&or2), Ordering::Less);\n-        }\n-\n-        #[test]\n-        fn partial_cmp() {\n-            let or1: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n-            let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-            assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n-        }\n-\n-        #[test]\n-        fn hash() {\n-            let mut h1 = DefaultHasher::new();\n-            let mut h2 = DefaultHasher::new();\n-\n-            let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-            let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n-\n-            or1.hash(&mut h1);\n-            or2.hash(&mut h2);\n-\n-            assert_eq!(h1.finish(), h2.finish());\n-        }\n-\n-        #[test]\n-        fn borrow() {\n-            let mut hash = HashMap::new();\n-            let     key  = RcRef::<String>::new(Rc::new(\"foo-bar\".to_string())).map(|s| &s[..]);\n-\n-            hash.insert(key.clone().map(|s| &s[..3]), 42);\n-            hash.insert(key.clone().map(|s| &s[4..]), 23);\n-\n-            assert_eq!(hash.get(\"foo\"), Some(&42));\n-            assert_eq!(hash.get(\"bar\"), Some(&23));\n-        }\n-\n-        #[test]\n-        fn total_erase() {\n-            let a: OwningRef<Vec<u8>, [u8]>\n-                = OwningRef::new(vec![]).map(|x| &x[..]);\n-            let b: OwningRef<Box<[u8]>, [u8]>\n-                = OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n-\n-            let c: OwningRef<Rc<Vec<u8>>, [u8]> = unsafe {a.map_owner(Rc::new)};\n-            let d: OwningRef<Rc<Box<[u8]>>, [u8]> = unsafe {b.map_owner(Rc::new)};\n-\n-            let e: OwningRef<Rc<dyn Erased>, [u8]> = c.erase_owner();\n-            let f: OwningRef<Rc<dyn Erased>, [u8]> = d.erase_owner();\n-\n-            let _g = e.clone();\n-            let _h = f.clone();\n-        }\n-\n-        #[test]\n-        fn total_erase_box() {\n-            let a: OwningRef<Vec<u8>, [u8]>\n-                = OwningRef::new(vec![]).map(|x| &x[..]);\n-            let b: OwningRef<Box<[u8]>, [u8]>\n-                = OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n-\n-            let c: OwningRef<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n-            let d: OwningRef<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n-\n-            let _e: OwningRef<Box<dyn Erased>, [u8]> = c.erase_owner();\n-            let _f: OwningRef<Box<dyn Erased>, [u8]> = d.erase_owner();\n-        }\n-\n-        #[test]\n-        fn try_map1() {\n-            use std::any::Any;\n-\n-            let x = Box::new(123_i32);\n-            let y: Box<dyn Any> = x;\n-\n-            assert!(OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok());\n-        }\n-\n-        #[test]\n-        fn try_map2() {\n-            use std::any::Any;\n-\n-            let x = Box::new(123_i32);\n-            let y: Box<dyn Any> = x;\n-\n-            assert!(!OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err());\n-        }\n-    }\n-\n-    mod owning_handle {\n-        use super::super::OwningHandle;\n-        use super::super::RcRef;\n-        use std::rc::Rc;\n-        use std::cell::RefCell;\n-        use std::sync::Arc;\n-        use std::sync::RwLock;\n-\n-        #[test]\n-        fn owning_handle() {\n-            use std::cell::RefCell;\n-            let cell = Rc::new(RefCell::new(2));\n-            let cell_ref = RcRef::new(cell);\n-            let mut handle = OwningHandle::new_with_fn(cell_ref, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-            assert_eq!(*handle, 2);\n-            *handle = 3;\n-            assert_eq!(*handle, 3);\n-        }\n-\n-        #[test]\n-        fn try_owning_handle_ok() {\n-            use std::cell::RefCell;\n-            let cell = Rc::new(RefCell::new(2));\n-            let cell_ref = RcRef::new(cell);\n-            let mut handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n-                Ok(unsafe {\n-                    x.as_ref()\n-                }.unwrap().borrow_mut())\n-            }).unwrap();\n-            assert_eq!(*handle, 2);\n-            *handle = 3;\n-            assert_eq!(*handle, 3);\n-        }\n-\n-        #[test]\n-        fn try_owning_handle_err() {\n-            use std::cell::RefCell;\n-            let cell = Rc::new(RefCell::new(2));\n-            let cell_ref = RcRef::new(cell);\n-            let handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n-                if false {\n-                    return Ok(unsafe {\n-                        x.as_ref()\n-                    }.unwrap().borrow_mut())\n-                }\n-                Err(())\n-            });\n-            assert!(handle.is_err());\n-        }\n-\n-        #[test]\n-        fn nested() {\n-            use std::cell::RefCell;\n-            use std::sync::{Arc, RwLock};\n-\n-            let result = {\n-                let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n-                let curr = RcRef::new(complex);\n-                let curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-                let mut curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().try_write().unwrap());\n-                assert_eq!(*curr, \"someString\");\n-                *curr = \"someOtherString\";\n-                curr\n-            };\n-            assert_eq!(*result, \"someOtherString\");\n-        }\n-\n-        #[test]\n-        fn owning_handle_safe() {\n-            use std::cell::RefCell;\n-            let cell = Rc::new(RefCell::new(2));\n-            let cell_ref = RcRef::new(cell);\n-            let handle = OwningHandle::new(cell_ref);\n-            assert_eq!(*handle, 2);\n-        }\n-\n-        #[test]\n-        fn owning_handle_mut_safe() {\n-            use std::cell::RefCell;\n-            let cell = Rc::new(RefCell::new(2));\n-            let cell_ref = RcRef::new(cell);\n-            let mut handle = OwningHandle::new_mut(cell_ref);\n-            assert_eq!(*handle, 2);\n-            *handle = 3;\n-            assert_eq!(*handle, 3);\n-        }\n-\n-        #[test]\n-        fn owning_handle_safe_2() {\n-            let result = {\n-                let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n-                let curr = RcRef::new(complex);\n-                let curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n-                let mut curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().try_write().unwrap());\n-                assert_eq!(*curr, \"someString\");\n-                *curr = \"someOtherString\";\n-                curr\n-            };\n-            assert_eq!(*result, \"someOtherString\");\n-        }\n-    }\n-\n-    mod owning_ref_mut {\n-        use super::super::{OwningRefMut, BoxRefMut, Erased, ErasedBoxRefMut};\n-        use super::super::BoxRef;\n-        use std::cmp::{PartialEq, Ord, PartialOrd, Ordering};\n-        use std::hash::{Hash, Hasher};\n-        use std::collections::hash_map::DefaultHasher;\n-        use std::collections::HashMap;\n-\n-        #[derive(Debug, PartialEq)]\n-        struct Example(u32, String, [u8; 3]);\n-        fn example() -> Example {\n-            Example(42, \"hello world\".to_string(), [1, 2, 3])\n-        }\n-\n-        #[test]\n-        fn new_deref() {\n-            let or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n-            assert_eq!(&*or, &());\n-        }\n-\n-        #[test]\n-        fn new_deref_mut() {\n-            let mut or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n-            assert_eq!(&mut *or, &mut ());\n-        }\n-\n-        #[test]\n-        fn mutate() {\n-            let mut or: OwningRefMut<Box<usize>, usize> = OwningRefMut::new(Box::new(0));\n-            assert_eq!(&*or, &0);\n-            *or = 1;\n-            assert_eq!(&*or, &1);\n-        }\n-\n-        #[test]\n-        fn into() {\n-            let or: OwningRefMut<Box<()>, ()> = Box::new(()).into();\n-            assert_eq!(&*or, &());\n-        }\n-\n-        #[test]\n-        fn map_offset_ref() {\n-            let or: BoxRefMut<Example> = Box::new(example()).into();\n-            let or: BoxRef<_, u32> = or.map(|x| &mut x.0);\n-            assert_eq!(&*or, &42);\n-\n-            let or: BoxRefMut<Example> = Box::new(example()).into();\n-            let or: BoxRef<_, u8> = or.map(|x| &mut x.2[1]);\n-            assert_eq!(&*or, &2);\n-        }\n-\n-        #[test]\n-        fn map_heap_ref() {\n-            let or: BoxRefMut<Example> = Box::new(example()).into();\n-            let or: BoxRef<_, str> = or.map(|x| &mut x.1[..5]);\n-            assert_eq!(&*or, \"hello\");\n-        }\n-\n-        #[test]\n-        fn map_static_ref() {\n-            let or: BoxRefMut<()> = Box::new(()).into();\n-            let or: BoxRef<_, str> = or.map(|_| \"hello\");\n-            assert_eq!(&*or, \"hello\");\n-        }\n-\n-        #[test]\n-        fn map_mut_offset_ref() {\n-            let or: BoxRefMut<Example> = Box::new(example()).into();\n-            let or: BoxRefMut<_, u32> = or.map_mut(|x| &mut x.0);\n-            assert_eq!(&*or, &42);\n-\n-            let or: BoxRefMut<Example> = Box::new(example()).into();\n-            let or: BoxRefMut<_, u8> = or.map_mut(|x| &mut x.2[1]);\n-            assert_eq!(&*or, &2);\n-        }\n-\n-        #[test]\n-        fn map_mut_heap_ref() {\n-            let or: BoxRefMut<Example> = Box::new(example()).into();\n-            let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x.1[..5]);\n-            assert_eq!(&*or, \"hello\");\n-        }\n-\n-        #[test]\n-        fn map_mut_static_ref() {\n-            static mut MUT_S: [u8; 5] = *b\"hello\";\n-\n-            let mut_s: &'static mut [u8] = unsafe { &mut MUT_S };\n-\n-            let or: BoxRefMut<()> = Box::new(()).into();\n-            let or: BoxRefMut<_, [u8]> = or.map_mut(move |_| mut_s);\n-            assert_eq!(&*or, b\"hello\");\n-        }\n-\n-        #[test]\n-        fn map_mut_chained() {\n-            let or: BoxRefMut<String> = Box::new(example().1).into();\n-            let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[1..5]);\n-            let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[..2]);\n-            assert_eq!(&*or, \"el\");\n-        }\n-\n-        #[test]\n-        fn map_chained_inference() {\n-            let or = BoxRefMut::new(Box::new(example().1))\n-                .map_mut(|x| &mut x[..5])\n-                .map_mut(|x| &mut x[1..3]);\n-            assert_eq!(&*or, \"el\");\n-        }\n-\n-        #[test]\n-        fn try_map_mut() {\n-            let or: BoxRefMut<String> = Box::new(example().1).into();\n-            let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|x| Ok(&mut x[1..5]));\n-            assert_eq!(&*or.unwrap(), \"ello\");\n-\n-            let or: BoxRefMut<String> = Box::new(example().1).into();\n-            let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|_| Err(()));\n-            assert!(or.is_err());\n-        }\n-\n-        #[test]\n-        fn owner() {\n-            let or: BoxRefMut<String> = Box::new(example().1).into();\n-            let or = or.map_mut(|x| &mut x[..5]);\n-            assert_eq!(&*or, \"hello\");\n-            assert_eq!(&**or.owner(), \"hello world\");\n-        }\n-\n-        #[test]\n-        fn into_inner() {\n-            let or: BoxRefMut<String> = Box::new(example().1).into();\n-            let or = or.map_mut(|x| &mut x[..5]);\n-            assert_eq!(&*or, \"hello\");\n-            let s = *or.into_inner();\n-            assert_eq!(&s, \"hello world\");\n-        }\n-\n-        #[test]\n-        fn fmt_debug() {\n-            let or: BoxRefMut<String> = Box::new(example().1).into();\n-            let or = or.map_mut(|x| &mut x[..5]);\n-            let s = format!(\"{:?}\", or);\n-            assert_eq!(&s,\n-                       \"OwningRefMut { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n-        }\n-\n-        #[test]\n-        fn erased_owner() {\n-            let o1: BoxRefMut<Example, str> = BoxRefMut::new(Box::new(example()))\n-                .map_mut(|x| &mut x.1[..]);\n-\n-            let o2: BoxRefMut<String, str> = BoxRefMut::new(Box::new(example().1))\n-                .map_mut(|x| &mut x[..]);\n-\n-            let os: Vec<ErasedBoxRefMut<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n-            assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n-        }\n-\n-        #[test]\n-        fn raii_locks() {\n-            use super::super::RefMutRefMut;\n-            use std::cell::RefCell;\n-            use super::super::{MutexGuardRefMut, RwLockWriteGuardRefMut};\n-            use std::sync::{Mutex, RwLock};\n-\n-            {\n-                let a = RefCell::new(1);\n-                let a = {\n-                    let a = RefMutRefMut::new(a.borrow_mut());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-            {\n-                let a = Mutex::new(1);\n-                let a = {\n-                    let a = MutexGuardRefMut::new(a.lock().unwrap());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-            {\n-                let a = RwLock::new(1);\n-                let a = {\n-                    let a = RwLockWriteGuardRefMut::new(a.write().unwrap());\n-                    assert_eq!(*a, 1);\n-                    a\n-                };\n-                assert_eq!(*a, 1);\n-                drop(a);\n-            }\n-        }\n-\n-        #[test]\n-        fn eq() {\n-            let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-            let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-            assert_eq!(or1.eq(&or2), true);\n-        }\n-\n-        #[test]\n-        fn cmp() {\n-            let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-            let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n-            assert_eq!(or1.cmp(&or2), Ordering::Less);\n-        }\n-\n-        #[test]\n-        fn partial_cmp() {\n-            let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n-            let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-            assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n-        }\n-\n-        #[test]\n-        fn hash() {\n-            let mut h1 = DefaultHasher::new();\n-            let mut h2 = DefaultHasher::new();\n-\n-            let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-            let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n-\n-            or1.hash(&mut h1);\n-            or2.hash(&mut h2);\n-\n-            assert_eq!(h1.finish(), h2.finish());\n-        }\n-\n-        #[test]\n-        fn borrow() {\n-            let mut hash = HashMap::new();\n-            let     key1 = BoxRefMut::<String>::new(Box::new(\"foo\".to_string())).map(|s| &s[..]);\n-            let     key2 = BoxRefMut::<String>::new(Box::new(\"bar\".to_string())).map(|s| &s[..]);\n-\n-            hash.insert(key1, 42);\n-            hash.insert(key2, 23);\n-\n-            assert_eq!(hash.get(\"foo\"), Some(&42));\n-            assert_eq!(hash.get(\"bar\"), Some(&23));\n-        }\n-\n-        #[test]\n-        fn total_erase() {\n-            let a: OwningRefMut<Vec<u8>, [u8]>\n-                = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n-            let b: OwningRefMut<Box<[u8]>, [u8]>\n-                = OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n-\n-            let c: OwningRefMut<Box<Vec<u8>>, [u8]> = unsafe {a.map_owner(Box::new)};\n-            let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = unsafe {b.map_owner(Box::new)};\n-\n-            let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n-            let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n-        }\n-\n-        #[test]\n-        fn total_erase_box() {\n-            let a: OwningRefMut<Vec<u8>, [u8]>\n-                = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n-            let b: OwningRefMut<Box<[u8]>, [u8]>\n-                = OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n-\n-            let c: OwningRefMut<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n-            let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n-\n-            let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n-            let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n-        }\n-\n-        #[test]\n-        fn try_map1() {\n-            use std::any::Any;\n-\n-            let x = Box::new(123_i32);\n-            let y: Box<dyn Any> = x;\n-\n-            assert!(OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_ok());\n-        }\n-\n-        #[test]\n-        fn try_map2() {\n-            use std::any::Any;\n-\n-            let x = Box::new(123_i32);\n-            let y: Box<dyn Any> = x;\n-\n-            assert!(!OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_err());\n-        }\n-\n-        #[test]\n-        fn try_map3() {\n-            use std::any::Any;\n-\n-            let x = Box::new(123_i32);\n-            let y: Box<dyn Any> = x;\n-\n-            assert!(OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok());\n-        }\n-\n-        #[test]\n-        fn try_map4() {\n-            use std::any::Any;\n-\n-            let x = Box::new(123_i32);\n-            let y: Box<dyn Any> = x;\n-\n-            assert!(!OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err());\n-        }\n-\n-        #[test]\n-        fn into_owning_ref() {\n-            use super::super::BoxRef;\n-\n-            let or: BoxRefMut<()> = Box::new(()).into();\n-            let or: BoxRef<()> = or.into();\n-            assert_eq!(&*or, &());\n-        }\n-\n-        struct Foo {\n-            u: u32,\n-        }\n-        struct Bar {\n-            f: Foo,\n-        }\n-\n-        #[test]\n-        fn ref_mut() {\n-            use std::cell::RefCell;\n-\n-            let a = RefCell::new(Bar { f: Foo { u: 42 } });\n-            let mut b = OwningRefMut::new(a.borrow_mut());\n-            assert_eq!(b.f.u, 42);\n-            b.f.u = 43;\n-            let mut c = b.map_mut(|x| &mut x.f);\n-            assert_eq!(c.u, 43);\n-            c.u = 44;\n-            let mut d = c.map_mut(|x| &mut x.u);\n-            assert_eq!(*d, 44);\n-            *d = 45;\n-            assert_eq!(*d, 45);\n-        }\n-    }\n-}\n+mod tests;"}, {"sha": "d368219cab3eb3fd090de5581bddfcb58a7b6f7d", "filename": "src/librustc_data_structures/owning_ref/tests.rs", "status": "added", "additions": 712, "deletions": 0, "changes": 712, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_data_structures%2Fowning_ref%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_data_structures%2Fowning_ref%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fowning_ref%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,712 @@\n+mod owning_ref {\n+    use super::super::OwningRef;\n+    use super::super::{RcRef, BoxRef, Erased, ErasedBoxRef};\n+    use std::cmp::{PartialEq, Ord, PartialOrd, Ordering};\n+    use std::hash::{Hash, Hasher};\n+    use std::collections::hash_map::DefaultHasher;\n+    use std::collections::HashMap;\n+    use std::rc::Rc;\n+\n+    #[derive(Debug, PartialEq)]\n+    struct Example(u32, String, [u8; 3]);\n+    fn example() -> Example {\n+        Example(42, \"hello world\".to_string(), [1, 2, 3])\n+    }\n+\n+    #[test]\n+    fn new_deref() {\n+        let or: OwningRef<Box<()>, ()> = OwningRef::new(Box::new(()));\n+        assert_eq!(&*or, &());\n+    }\n+\n+    #[test]\n+    fn into() {\n+        let or: OwningRef<Box<()>, ()> = Box::new(()).into();\n+        assert_eq!(&*or, &());\n+    }\n+\n+    #[test]\n+    fn map_offset_ref() {\n+        let or: BoxRef<Example> = Box::new(example()).into();\n+        let or: BoxRef<_, u32> = or.map(|x| &x.0);\n+        assert_eq!(&*or, &42);\n+\n+        let or: BoxRef<Example> = Box::new(example()).into();\n+        let or: BoxRef<_, u8> = or.map(|x| &x.2[1]);\n+        assert_eq!(&*or, &2);\n+    }\n+\n+    #[test]\n+    fn map_heap_ref() {\n+        let or: BoxRef<Example> = Box::new(example()).into();\n+        let or: BoxRef<_, str> = or.map(|x| &x.1[..5]);\n+        assert_eq!(&*or, \"hello\");\n+    }\n+\n+    #[test]\n+    fn map_static_ref() {\n+        let or: BoxRef<()> = Box::new(()).into();\n+        let or: BoxRef<_, str> = or.map(|_| \"hello\");\n+        assert_eq!(&*or, \"hello\");\n+    }\n+\n+    #[test]\n+    fn map_chained() {\n+        let or: BoxRef<String> = Box::new(example().1).into();\n+        let or: BoxRef<_, str> = or.map(|x| &x[1..5]);\n+        let or: BoxRef<_, str> = or.map(|x| &x[..2]);\n+        assert_eq!(&*or, \"el\");\n+    }\n+\n+    #[test]\n+    fn map_chained_inference() {\n+        let or = BoxRef::new(Box::new(example().1))\n+            .map(|x| &x[..5])\n+            .map(|x| &x[1..3]);\n+        assert_eq!(&*or, \"el\");\n+    }\n+\n+    #[test]\n+    fn owner() {\n+        let or: BoxRef<String> = Box::new(example().1).into();\n+        let or = or.map(|x| &x[..5]);\n+        assert_eq!(&*or, \"hello\");\n+        assert_eq!(&**or.owner(), \"hello world\");\n+    }\n+\n+    #[test]\n+    fn into_inner() {\n+        let or: BoxRef<String> = Box::new(example().1).into();\n+        let or = or.map(|x| &x[..5]);\n+        assert_eq!(&*or, \"hello\");\n+        let s = *or.into_inner();\n+        assert_eq!(&s, \"hello world\");\n+    }\n+\n+    #[test]\n+    fn fmt_debug() {\n+        let or: BoxRef<String> = Box::new(example().1).into();\n+        let or = or.map(|x| &x[..5]);\n+        let s = format!(\"{:?}\", or);\n+        assert_eq!(&s, \"OwningRef { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n+    }\n+\n+    #[test]\n+    fn erased_owner() {\n+        let o1: BoxRef<Example, str> = BoxRef::new(Box::new(example()))\n+            .map(|x| &x.1[..]);\n+\n+        let o2: BoxRef<String, str> = BoxRef::new(Box::new(example().1))\n+            .map(|x| &x[..]);\n+\n+        let os: Vec<ErasedBoxRef<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n+        assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n+    }\n+\n+    #[test]\n+    fn raii_locks() {\n+        use super::super::{RefRef, RefMutRef};\n+        use std::cell::RefCell;\n+        use super::super::{MutexGuardRef, RwLockReadGuardRef, RwLockWriteGuardRef};\n+        use std::sync::{Mutex, RwLock};\n+\n+        {\n+            let a = RefCell::new(1);\n+            let a = {\n+                let a = RefRef::new(a.borrow());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+        {\n+            let a = RefCell::new(1);\n+            let a = {\n+                let a = RefMutRef::new(a.borrow_mut());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+        {\n+            let a = Mutex::new(1);\n+            let a = {\n+                let a = MutexGuardRef::new(a.lock().unwrap());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+        {\n+            let a = RwLock::new(1);\n+            let a = {\n+                let a = RwLockReadGuardRef::new(a.read().unwrap());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+        {\n+            let a = RwLock::new(1);\n+            let a = {\n+                let a = RwLockWriteGuardRef::new(a.write().unwrap());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+    }\n+\n+    #[test]\n+    fn eq() {\n+        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+        assert_eq!(or1.eq(&or2), true);\n+    }\n+\n+    #[test]\n+    fn cmp() {\n+        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+        let or2: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n+        assert_eq!(or1.cmp(&or2), Ordering::Less);\n+    }\n+\n+    #[test]\n+    fn partial_cmp() {\n+        let or1: BoxRef<[u8]> = BoxRef::new(vec![4, 5, 6].into_boxed_slice());\n+        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+        assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n+    }\n+\n+    #[test]\n+    fn hash() {\n+        let mut h1 = DefaultHasher::new();\n+        let mut h2 = DefaultHasher::new();\n+\n+        let or1: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+        let or2: BoxRef<[u8]> = BoxRef::new(vec![1, 2, 3].into_boxed_slice());\n+\n+        or1.hash(&mut h1);\n+        or2.hash(&mut h2);\n+\n+        assert_eq!(h1.finish(), h2.finish());\n+    }\n+\n+    #[test]\n+    fn borrow() {\n+        let mut hash = HashMap::new();\n+        let     key  = RcRef::<String>::new(Rc::new(\"foo-bar\".to_string())).map(|s| &s[..]);\n+\n+        hash.insert(key.clone().map(|s| &s[..3]), 42);\n+        hash.insert(key.clone().map(|s| &s[4..]), 23);\n+\n+        assert_eq!(hash.get(\"foo\"), Some(&42));\n+        assert_eq!(hash.get(\"bar\"), Some(&23));\n+    }\n+\n+    #[test]\n+    fn total_erase() {\n+        let a: OwningRef<Vec<u8>, [u8]>\n+            = OwningRef::new(vec![]).map(|x| &x[..]);\n+        let b: OwningRef<Box<[u8]>, [u8]>\n+            = OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n+\n+        let c: OwningRef<Rc<Vec<u8>>, [u8]> = unsafe {a.map_owner(Rc::new)};\n+        let d: OwningRef<Rc<Box<[u8]>>, [u8]> = unsafe {b.map_owner(Rc::new)};\n+\n+        let e: OwningRef<Rc<dyn Erased>, [u8]> = c.erase_owner();\n+        let f: OwningRef<Rc<dyn Erased>, [u8]> = d.erase_owner();\n+\n+        let _g = e.clone();\n+        let _h = f.clone();\n+    }\n+\n+    #[test]\n+    fn total_erase_box() {\n+        let a: OwningRef<Vec<u8>, [u8]>\n+            = OwningRef::new(vec![]).map(|x| &x[..]);\n+        let b: OwningRef<Box<[u8]>, [u8]>\n+            = OwningRef::new(vec![].into_boxed_slice()).map(|x| &x[..]);\n+\n+        let c: OwningRef<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n+        let d: OwningRef<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n+\n+        let _e: OwningRef<Box<dyn Erased>, [u8]> = c.erase_owner();\n+        let _f: OwningRef<Box<dyn Erased>, [u8]> = d.erase_owner();\n+    }\n+\n+    #[test]\n+    fn try_map1() {\n+        use std::any::Any;\n+\n+        let x = Box::new(123_i32);\n+        let y: Box<dyn Any> = x;\n+\n+        assert!(OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok());\n+    }\n+\n+    #[test]\n+    fn try_map2() {\n+        use std::any::Any;\n+\n+        let x = Box::new(123_i32);\n+        let y: Box<dyn Any> = x;\n+\n+        assert!(!OwningRef::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err());\n+    }\n+}\n+\n+mod owning_handle {\n+    use super::super::OwningHandle;\n+    use super::super::RcRef;\n+    use std::rc::Rc;\n+    use std::cell::RefCell;\n+    use std::sync::Arc;\n+    use std::sync::RwLock;\n+\n+    #[test]\n+    fn owning_handle() {\n+        use std::cell::RefCell;\n+        let cell = Rc::new(RefCell::new(2));\n+        let cell_ref = RcRef::new(cell);\n+        let mut handle = OwningHandle::new_with_fn(cell_ref, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n+        assert_eq!(*handle, 2);\n+        *handle = 3;\n+        assert_eq!(*handle, 3);\n+    }\n+\n+    #[test]\n+    fn try_owning_handle_ok() {\n+        use std::cell::RefCell;\n+        let cell = Rc::new(RefCell::new(2));\n+        let cell_ref = RcRef::new(cell);\n+        let mut handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n+            Ok(unsafe {\n+                x.as_ref()\n+            }.unwrap().borrow_mut())\n+        }).unwrap();\n+        assert_eq!(*handle, 2);\n+        *handle = 3;\n+        assert_eq!(*handle, 3);\n+    }\n+\n+    #[test]\n+    fn try_owning_handle_err() {\n+        use std::cell::RefCell;\n+        let cell = Rc::new(RefCell::new(2));\n+        let cell_ref = RcRef::new(cell);\n+        let handle = OwningHandle::try_new::<_, ()>(cell_ref, |x| {\n+            if false {\n+                return Ok(unsafe {\n+                    x.as_ref()\n+                }.unwrap().borrow_mut())\n+            }\n+            Err(())\n+        });\n+        assert!(handle.is_err());\n+    }\n+\n+    #[test]\n+    fn nested() {\n+        use std::cell::RefCell;\n+        use std::sync::{Arc, RwLock};\n+\n+        let result = {\n+            let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n+            let curr = RcRef::new(complex);\n+            let curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n+            let mut curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().try_write().unwrap());\n+            assert_eq!(*curr, \"someString\");\n+            *curr = \"someOtherString\";\n+            curr\n+        };\n+        assert_eq!(*result, \"someOtherString\");\n+    }\n+\n+    #[test]\n+    fn owning_handle_safe() {\n+        use std::cell::RefCell;\n+        let cell = Rc::new(RefCell::new(2));\n+        let cell_ref = RcRef::new(cell);\n+        let handle = OwningHandle::new(cell_ref);\n+        assert_eq!(*handle, 2);\n+    }\n+\n+    #[test]\n+    fn owning_handle_mut_safe() {\n+        use std::cell::RefCell;\n+        let cell = Rc::new(RefCell::new(2));\n+        let cell_ref = RcRef::new(cell);\n+        let mut handle = OwningHandle::new_mut(cell_ref);\n+        assert_eq!(*handle, 2);\n+        *handle = 3;\n+        assert_eq!(*handle, 3);\n+    }\n+\n+    #[test]\n+    fn owning_handle_safe_2() {\n+        let result = {\n+            let complex = Rc::new(RefCell::new(Arc::new(RwLock::new(\"someString\"))));\n+            let curr = RcRef::new(complex);\n+            let curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().borrow_mut());\n+            let mut curr = OwningHandle::new_with_fn(curr, |x| unsafe { x.as_ref() }.unwrap().try_write().unwrap());\n+            assert_eq!(*curr, \"someString\");\n+            *curr = \"someOtherString\";\n+            curr\n+        };\n+        assert_eq!(*result, \"someOtherString\");\n+    }\n+}\n+\n+mod owning_ref_mut {\n+    use super::super::{OwningRefMut, BoxRefMut, Erased, ErasedBoxRefMut};\n+    use super::super::BoxRef;\n+    use std::cmp::{PartialEq, Ord, PartialOrd, Ordering};\n+    use std::hash::{Hash, Hasher};\n+    use std::collections::hash_map::DefaultHasher;\n+    use std::collections::HashMap;\n+\n+    #[derive(Debug, PartialEq)]\n+    struct Example(u32, String, [u8; 3]);\n+    fn example() -> Example {\n+        Example(42, \"hello world\".to_string(), [1, 2, 3])\n+    }\n+\n+    #[test]\n+    fn new_deref() {\n+        let or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n+        assert_eq!(&*or, &());\n+    }\n+\n+    #[test]\n+    fn new_deref_mut() {\n+        let mut or: OwningRefMut<Box<()>, ()> = OwningRefMut::new(Box::new(()));\n+        assert_eq!(&mut *or, &mut ());\n+    }\n+\n+    #[test]\n+    fn mutate() {\n+        let mut or: OwningRefMut<Box<usize>, usize> = OwningRefMut::new(Box::new(0));\n+        assert_eq!(&*or, &0);\n+        *or = 1;\n+        assert_eq!(&*or, &1);\n+    }\n+\n+    #[test]\n+    fn into() {\n+        let or: OwningRefMut<Box<()>, ()> = Box::new(()).into();\n+        assert_eq!(&*or, &());\n+    }\n+\n+    #[test]\n+    fn map_offset_ref() {\n+        let or: BoxRefMut<Example> = Box::new(example()).into();\n+        let or: BoxRef<_, u32> = or.map(|x| &mut x.0);\n+        assert_eq!(&*or, &42);\n+\n+        let or: BoxRefMut<Example> = Box::new(example()).into();\n+        let or: BoxRef<_, u8> = or.map(|x| &mut x.2[1]);\n+        assert_eq!(&*or, &2);\n+    }\n+\n+    #[test]\n+    fn map_heap_ref() {\n+        let or: BoxRefMut<Example> = Box::new(example()).into();\n+        let or: BoxRef<_, str> = or.map(|x| &mut x.1[..5]);\n+        assert_eq!(&*or, \"hello\");\n+    }\n+\n+    #[test]\n+    fn map_static_ref() {\n+        let or: BoxRefMut<()> = Box::new(()).into();\n+        let or: BoxRef<_, str> = or.map(|_| \"hello\");\n+        assert_eq!(&*or, \"hello\");\n+    }\n+\n+    #[test]\n+    fn map_mut_offset_ref() {\n+        let or: BoxRefMut<Example> = Box::new(example()).into();\n+        let or: BoxRefMut<_, u32> = or.map_mut(|x| &mut x.0);\n+        assert_eq!(&*or, &42);\n+\n+        let or: BoxRefMut<Example> = Box::new(example()).into();\n+        let or: BoxRefMut<_, u8> = or.map_mut(|x| &mut x.2[1]);\n+        assert_eq!(&*or, &2);\n+    }\n+\n+    #[test]\n+    fn map_mut_heap_ref() {\n+        let or: BoxRefMut<Example> = Box::new(example()).into();\n+        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x.1[..5]);\n+        assert_eq!(&*or, \"hello\");\n+    }\n+\n+    #[test]\n+    fn map_mut_static_ref() {\n+        static mut MUT_S: [u8; 5] = *b\"hello\";\n+\n+        let mut_s: &'static mut [u8] = unsafe { &mut MUT_S };\n+\n+        let or: BoxRefMut<()> = Box::new(()).into();\n+        let or: BoxRefMut<_, [u8]> = or.map_mut(move |_| mut_s);\n+        assert_eq!(&*or, b\"hello\");\n+    }\n+\n+    #[test]\n+    fn map_mut_chained() {\n+        let or: BoxRefMut<String> = Box::new(example().1).into();\n+        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[1..5]);\n+        let or: BoxRefMut<_, str> = or.map_mut(|x| &mut x[..2]);\n+        assert_eq!(&*or, \"el\");\n+    }\n+\n+    #[test]\n+    fn map_chained_inference() {\n+        let or = BoxRefMut::new(Box::new(example().1))\n+            .map_mut(|x| &mut x[..5])\n+            .map_mut(|x| &mut x[1..3]);\n+        assert_eq!(&*or, \"el\");\n+    }\n+\n+    #[test]\n+    fn try_map_mut() {\n+        let or: BoxRefMut<String> = Box::new(example().1).into();\n+        let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|x| Ok(&mut x[1..5]));\n+        assert_eq!(&*or.unwrap(), \"ello\");\n+\n+        let or: BoxRefMut<String> = Box::new(example().1).into();\n+        let or: Result<BoxRefMut<_, str>, ()> = or.try_map_mut(|_| Err(()));\n+        assert!(or.is_err());\n+    }\n+\n+    #[test]\n+    fn owner() {\n+        let or: BoxRefMut<String> = Box::new(example().1).into();\n+        let or = or.map_mut(|x| &mut x[..5]);\n+        assert_eq!(&*or, \"hello\");\n+        assert_eq!(&**or.owner(), \"hello world\");\n+    }\n+\n+    #[test]\n+    fn into_inner() {\n+        let or: BoxRefMut<String> = Box::new(example().1).into();\n+        let or = or.map_mut(|x| &mut x[..5]);\n+        assert_eq!(&*or, \"hello\");\n+        let s = *or.into_inner();\n+        assert_eq!(&s, \"hello world\");\n+    }\n+\n+    #[test]\n+    fn fmt_debug() {\n+        let or: BoxRefMut<String> = Box::new(example().1).into();\n+        let or = or.map_mut(|x| &mut x[..5]);\n+        let s = format!(\"{:?}\", or);\n+        assert_eq!(&s,\n+                   \"OwningRefMut { owner: \\\"hello world\\\", reference: \\\"hello\\\" }\");\n+    }\n+\n+    #[test]\n+    fn erased_owner() {\n+        let o1: BoxRefMut<Example, str> = BoxRefMut::new(Box::new(example()))\n+            .map_mut(|x| &mut x.1[..]);\n+\n+        let o2: BoxRefMut<String, str> = BoxRefMut::new(Box::new(example().1))\n+            .map_mut(|x| &mut x[..]);\n+\n+        let os: Vec<ErasedBoxRefMut<str>> = vec![o1.erase_owner(), o2.erase_owner()];\n+        assert!(os.iter().all(|e| &e[..] == \"hello world\"));\n+    }\n+\n+    #[test]\n+    fn raii_locks() {\n+        use super::super::RefMutRefMut;\n+        use std::cell::RefCell;\n+        use super::super::{MutexGuardRefMut, RwLockWriteGuardRefMut};\n+        use std::sync::{Mutex, RwLock};\n+\n+        {\n+            let a = RefCell::new(1);\n+            let a = {\n+                let a = RefMutRefMut::new(a.borrow_mut());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+        {\n+            let a = Mutex::new(1);\n+            let a = {\n+                let a = MutexGuardRefMut::new(a.lock().unwrap());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+        {\n+            let a = RwLock::new(1);\n+            let a = {\n+                let a = RwLockWriteGuardRefMut::new(a.write().unwrap());\n+                assert_eq!(*a, 1);\n+                a\n+            };\n+            assert_eq!(*a, 1);\n+            drop(a);\n+        }\n+    }\n+\n+    #[test]\n+    fn eq() {\n+        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+        assert_eq!(or1.eq(&or2), true);\n+    }\n+\n+    #[test]\n+    fn cmp() {\n+        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n+        assert_eq!(or1.cmp(&or2), Ordering::Less);\n+    }\n+\n+    #[test]\n+    fn partial_cmp() {\n+        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![4, 5, 6].into_boxed_slice());\n+        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+        assert_eq!(or1.partial_cmp(&or2), Some(Ordering::Greater));\n+    }\n+\n+    #[test]\n+    fn hash() {\n+        let mut h1 = DefaultHasher::new();\n+        let mut h2 = DefaultHasher::new();\n+\n+        let or1: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+        let or2: BoxRefMut<[u8]> = BoxRefMut::new(vec![1, 2, 3].into_boxed_slice());\n+\n+        or1.hash(&mut h1);\n+        or2.hash(&mut h2);\n+\n+        assert_eq!(h1.finish(), h2.finish());\n+    }\n+\n+    #[test]\n+    fn borrow() {\n+        let mut hash = HashMap::new();\n+        let     key1 = BoxRefMut::<String>::new(Box::new(\"foo\".to_string())).map(|s| &s[..]);\n+        let     key2 = BoxRefMut::<String>::new(Box::new(\"bar\".to_string())).map(|s| &s[..]);\n+\n+        hash.insert(key1, 42);\n+        hash.insert(key2, 23);\n+\n+        assert_eq!(hash.get(\"foo\"), Some(&42));\n+        assert_eq!(hash.get(\"bar\"), Some(&23));\n+    }\n+\n+    #[test]\n+    fn total_erase() {\n+        let a: OwningRefMut<Vec<u8>, [u8]>\n+            = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n+        let b: OwningRefMut<Box<[u8]>, [u8]>\n+            = OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n+\n+        let c: OwningRefMut<Box<Vec<u8>>, [u8]> = unsafe {a.map_owner(Box::new)};\n+        let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = unsafe {b.map_owner(Box::new)};\n+\n+        let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n+        let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n+    }\n+\n+    #[test]\n+    fn total_erase_box() {\n+        let a: OwningRefMut<Vec<u8>, [u8]>\n+            = OwningRefMut::new(vec![]).map_mut(|x| &mut x[..]);\n+        let b: OwningRefMut<Box<[u8]>, [u8]>\n+            = OwningRefMut::new(vec![].into_boxed_slice()).map_mut(|x| &mut x[..]);\n+\n+        let c: OwningRefMut<Box<Vec<u8>>, [u8]> = a.map_owner_box();\n+        let d: OwningRefMut<Box<Box<[u8]>>, [u8]> = b.map_owner_box();\n+\n+        let _e: OwningRefMut<Box<dyn Erased>, [u8]> = c.erase_owner();\n+        let _f: OwningRefMut<Box<dyn Erased>, [u8]> = d.erase_owner();\n+    }\n+\n+    #[test]\n+    fn try_map1() {\n+        use std::any::Any;\n+\n+        let x = Box::new(123_i32);\n+        let y: Box<dyn Any> = x;\n+\n+        assert!(OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_ok());\n+    }\n+\n+    #[test]\n+    fn try_map2() {\n+        use std::any::Any;\n+\n+        let x = Box::new(123_i32);\n+        let y: Box<dyn Any> = x;\n+\n+        assert!(!OwningRefMut::new(y).try_map_mut(|x| x.downcast_mut::<i32>().ok_or(())).is_err());\n+    }\n+\n+    #[test]\n+    fn try_map3() {\n+        use std::any::Any;\n+\n+        let x = Box::new(123_i32);\n+        let y: Box<dyn Any> = x;\n+\n+        assert!(OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_ok());\n+    }\n+\n+    #[test]\n+    fn try_map4() {\n+        use std::any::Any;\n+\n+        let x = Box::new(123_i32);\n+        let y: Box<dyn Any> = x;\n+\n+        assert!(!OwningRefMut::new(y).try_map(|x| x.downcast_ref::<i32>().ok_or(())).is_err());\n+    }\n+\n+    #[test]\n+    fn into_owning_ref() {\n+        use super::super::BoxRef;\n+\n+        let or: BoxRefMut<()> = Box::new(()).into();\n+        let or: BoxRef<()> = or.into();\n+        assert_eq!(&*or, &());\n+    }\n+\n+    struct Foo {\n+        u: u32,\n+    }\n+    struct Bar {\n+        f: Foo,\n+    }\n+\n+    #[test]\n+    fn ref_mut() {\n+        use std::cell::RefCell;\n+\n+        let a = RefCell::new(Bar { f: Foo { u: 42 } });\n+        let mut b = OwningRefMut::new(a.borrow_mut());\n+        assert_eq!(b.f.u, 42);\n+        b.f.u = 43;\n+        let mut c = b.map_mut(|x| &mut x.f);\n+        assert_eq!(c.u, 43);\n+        c.u = 44;\n+        let mut d = c.map_mut(|x| &mut x.u);\n+        assert_eq!(*d, 44);\n+        *d = 45;\n+        assert_eq!(*d, 45);\n+    }\n+}"}, {"sha": "fb819dd18a8d698a42e48f19d26ef169ac334849", "filename": "src/librustc_data_structures/sorted_map.rs", "status": "modified", "additions": 1, "deletions": 201, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_data_structures%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_data_structures%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -305,204 +305,4 @@ impl<K: Ord, V> FromIterator<(K, V)> for SortedMap<K, V> {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::SortedMap;\n-\n-    #[test]\n-    fn test_insert_and_iter() {\n-        let mut map = SortedMap::new();\n-        let mut expected = Vec::new();\n-\n-        for x in 0 .. 100 {\n-            assert_eq!(map.iter().cloned().collect::<Vec<_>>(), expected);\n-\n-            let x = 1000 - x * 2;\n-            map.insert(x, x);\n-            expected.insert(0, (x, x));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_get_and_index() {\n-        let mut map = SortedMap::new();\n-        let mut expected = Vec::new();\n-\n-        for x in 0 .. 100 {\n-            let x = 1000 - x;\n-            if x & 1 == 0 {\n-                map.insert(x, x);\n-            }\n-            expected.push(x);\n-        }\n-\n-        for mut x in expected {\n-            if x & 1 == 0 {\n-                assert_eq!(map.get(&x), Some(&x));\n-                assert_eq!(map.get_mut(&x), Some(&mut x));\n-                assert_eq!(map[&x], x);\n-                assert_eq!(&mut map[&x], &mut x);\n-            } else {\n-                assert_eq!(map.get(&x), None);\n-                assert_eq!(map.get_mut(&x), None);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_range() {\n-        let mut map = SortedMap::new();\n-        map.insert(1, 1);\n-        map.insert(3, 3);\n-        map.insert(6, 6);\n-        map.insert(9, 9);\n-\n-        let keys = |s: &[(_, _)]| {\n-            s.into_iter().map(|e| e.0).collect::<Vec<u32>>()\n-        };\n-\n-        for start in 0 .. 11 {\n-            for end in 0 .. 11 {\n-                if end < start {\n-                    continue\n-                }\n-\n-                let mut expected = vec![1, 3, 6, 9];\n-                expected.retain(|&x| x >= start && x < end);\n-\n-                assert_eq!(keys(map.range(start..end)), expected, \"range = {}..{}\", start, end);\n-            }\n-        }\n-    }\n-\n-\n-    #[test]\n-    fn test_offset_keys() {\n-        let mut map = SortedMap::new();\n-        map.insert(1, 1);\n-        map.insert(3, 3);\n-        map.insert(6, 6);\n-\n-        map.offset_keys(|k| *k += 1);\n-\n-        let mut expected = SortedMap::new();\n-        expected.insert(2, 1);\n-        expected.insert(4, 3);\n-        expected.insert(7, 6);\n-\n-        assert_eq!(map, expected);\n-    }\n-\n-    fn keys(s: SortedMap<u32, u32>) -> Vec<u32> {\n-        s.into_iter().map(|(k, _)| k).collect::<Vec<u32>>()\n-    }\n-\n-    fn elements(s: SortedMap<u32, u32>) -> Vec<(u32, u32)> {\n-        s.into_iter().collect::<Vec<(u32, u32)>>()\n-    }\n-\n-    #[test]\n-    fn test_remove_range() {\n-        let mut map = SortedMap::new();\n-        map.insert(1, 1);\n-        map.insert(3, 3);\n-        map.insert(6, 6);\n-        map.insert(9, 9);\n-\n-        for start in 0 .. 11 {\n-            for end in 0 .. 11 {\n-                if end < start {\n-                    continue\n-                }\n-\n-                let mut expected = vec![1, 3, 6, 9];\n-                expected.retain(|&x| x < start || x >= end);\n-\n-                let mut map = map.clone();\n-                map.remove_range(start .. end);\n-\n-                assert_eq!(keys(map), expected, \"range = {}..{}\", start, end);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        let mut map = SortedMap::new();\n-        let mut expected = Vec::new();\n-\n-        for x in 0..10 {\n-            map.insert(x, x);\n-            expected.push((x, x));\n-        }\n-\n-        for x in 0 .. 10 {\n-            let mut map = map.clone();\n-            let mut expected = expected.clone();\n-\n-            assert_eq!(map.remove(&x), Some(x));\n-            expected.remove(x as usize);\n-\n-            assert_eq!(map.iter().cloned().collect::<Vec<_>>(), expected);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_insert_presorted_non_overlapping() {\n-        let mut map = SortedMap::new();\n-        map.insert(2, 0);\n-        map.insert(8, 0);\n-\n-        map.insert_presorted(vec![(3, 0), (7, 0)]);\n-\n-        let expected = vec![2, 3, 7, 8];\n-        assert_eq!(keys(map), expected);\n-    }\n-\n-    #[test]\n-    fn test_insert_presorted_first_elem_equal() {\n-        let mut map = SortedMap::new();\n-        map.insert(2, 2);\n-        map.insert(8, 8);\n-\n-        map.insert_presorted(vec![(2, 0), (7, 7)]);\n-\n-        let expected = vec![(2, 0), (7, 7), (8, 8)];\n-        assert_eq!(elements(map), expected);\n-    }\n-\n-    #[test]\n-    fn test_insert_presorted_last_elem_equal() {\n-        let mut map = SortedMap::new();\n-        map.insert(2, 2);\n-        map.insert(8, 8);\n-\n-        map.insert_presorted(vec![(3, 3), (8, 0)]);\n-\n-        let expected = vec![(2, 2), (3, 3), (8, 0)];\n-        assert_eq!(elements(map), expected);\n-    }\n-\n-    #[test]\n-    fn test_insert_presorted_shuffle() {\n-        let mut map = SortedMap::new();\n-        map.insert(2, 2);\n-        map.insert(7, 7);\n-\n-        map.insert_presorted(vec![(1, 1), (3, 3), (8, 8)]);\n-\n-        let expected = vec![(1, 1), (2, 2), (3, 3), (7, 7), (8, 8)];\n-        assert_eq!(elements(map), expected);\n-    }\n-\n-    #[test]\n-    fn test_insert_presorted_at_end() {\n-        let mut map = SortedMap::new();\n-        map.insert(1, 1);\n-        map.insert(2, 2);\n-\n-        map.insert_presorted(vec![(3, 3), (8, 8)]);\n-\n-        let expected = vec![(1, 1), (2, 2), (3, 3), (8, 8)];\n-        assert_eq!(elements(map), expected);\n-    }\n-}\n+mod tests;"}, {"sha": "f970409cc3d587ae2953effbbf55cb5c219d9194", "filename": "src/librustc_data_structures/sorted_map/tests.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_data_structures%2Fsorted_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_data_structures%2Fsorted_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,199 @@\n+use super::SortedMap;\n+\n+#[test]\n+fn test_insert_and_iter() {\n+    let mut map = SortedMap::new();\n+    let mut expected = Vec::new();\n+\n+    for x in 0 .. 100 {\n+        assert_eq!(map.iter().cloned().collect::<Vec<_>>(), expected);\n+\n+        let x = 1000 - x * 2;\n+        map.insert(x, x);\n+        expected.insert(0, (x, x));\n+    }\n+}\n+\n+#[test]\n+fn test_get_and_index() {\n+    let mut map = SortedMap::new();\n+    let mut expected = Vec::new();\n+\n+    for x in 0 .. 100 {\n+        let x = 1000 - x;\n+        if x & 1 == 0 {\n+            map.insert(x, x);\n+        }\n+        expected.push(x);\n+    }\n+\n+    for mut x in expected {\n+        if x & 1 == 0 {\n+            assert_eq!(map.get(&x), Some(&x));\n+            assert_eq!(map.get_mut(&x), Some(&mut x));\n+            assert_eq!(map[&x], x);\n+            assert_eq!(&mut map[&x], &mut x);\n+        } else {\n+            assert_eq!(map.get(&x), None);\n+            assert_eq!(map.get_mut(&x), None);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_range() {\n+    let mut map = SortedMap::new();\n+    map.insert(1, 1);\n+    map.insert(3, 3);\n+    map.insert(6, 6);\n+    map.insert(9, 9);\n+\n+    let keys = |s: &[(_, _)]| {\n+        s.into_iter().map(|e| e.0).collect::<Vec<u32>>()\n+    };\n+\n+    for start in 0 .. 11 {\n+        for end in 0 .. 11 {\n+            if end < start {\n+                continue\n+            }\n+\n+            let mut expected = vec![1, 3, 6, 9];\n+            expected.retain(|&x| x >= start && x < end);\n+\n+            assert_eq!(keys(map.range(start..end)), expected, \"range = {}..{}\", start, end);\n+        }\n+    }\n+}\n+\n+\n+#[test]\n+fn test_offset_keys() {\n+    let mut map = SortedMap::new();\n+    map.insert(1, 1);\n+    map.insert(3, 3);\n+    map.insert(6, 6);\n+\n+    map.offset_keys(|k| *k += 1);\n+\n+    let mut expected = SortedMap::new();\n+    expected.insert(2, 1);\n+    expected.insert(4, 3);\n+    expected.insert(7, 6);\n+\n+    assert_eq!(map, expected);\n+}\n+\n+fn keys(s: SortedMap<u32, u32>) -> Vec<u32> {\n+    s.into_iter().map(|(k, _)| k).collect::<Vec<u32>>()\n+}\n+\n+fn elements(s: SortedMap<u32, u32>) -> Vec<(u32, u32)> {\n+    s.into_iter().collect::<Vec<(u32, u32)>>()\n+}\n+\n+#[test]\n+fn test_remove_range() {\n+    let mut map = SortedMap::new();\n+    map.insert(1, 1);\n+    map.insert(3, 3);\n+    map.insert(6, 6);\n+    map.insert(9, 9);\n+\n+    for start in 0 .. 11 {\n+        for end in 0 .. 11 {\n+            if end < start {\n+                continue\n+            }\n+\n+            let mut expected = vec![1, 3, 6, 9];\n+            expected.retain(|&x| x < start || x >= end);\n+\n+            let mut map = map.clone();\n+            map.remove_range(start .. end);\n+\n+            assert_eq!(keys(map), expected, \"range = {}..{}\", start, end);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_remove() {\n+    let mut map = SortedMap::new();\n+    let mut expected = Vec::new();\n+\n+    for x in 0..10 {\n+        map.insert(x, x);\n+        expected.push((x, x));\n+    }\n+\n+    for x in 0 .. 10 {\n+        let mut map = map.clone();\n+        let mut expected = expected.clone();\n+\n+        assert_eq!(map.remove(&x), Some(x));\n+        expected.remove(x as usize);\n+\n+        assert_eq!(map.iter().cloned().collect::<Vec<_>>(), expected);\n+    }\n+}\n+\n+#[test]\n+fn test_insert_presorted_non_overlapping() {\n+    let mut map = SortedMap::new();\n+    map.insert(2, 0);\n+    map.insert(8, 0);\n+\n+    map.insert_presorted(vec![(3, 0), (7, 0)]);\n+\n+    let expected = vec![2, 3, 7, 8];\n+    assert_eq!(keys(map), expected);\n+}\n+\n+#[test]\n+fn test_insert_presorted_first_elem_equal() {\n+    let mut map = SortedMap::new();\n+    map.insert(2, 2);\n+    map.insert(8, 8);\n+\n+    map.insert_presorted(vec![(2, 0), (7, 7)]);\n+\n+    let expected = vec![(2, 0), (7, 7), (8, 8)];\n+    assert_eq!(elements(map), expected);\n+}\n+\n+#[test]\n+fn test_insert_presorted_last_elem_equal() {\n+    let mut map = SortedMap::new();\n+    map.insert(2, 2);\n+    map.insert(8, 8);\n+\n+    map.insert_presorted(vec![(3, 3), (8, 0)]);\n+\n+    let expected = vec![(2, 2), (3, 3), (8, 0)];\n+    assert_eq!(elements(map), expected);\n+}\n+\n+#[test]\n+fn test_insert_presorted_shuffle() {\n+    let mut map = SortedMap::new();\n+    map.insert(2, 2);\n+    map.insert(7, 7);\n+\n+    map.insert_presorted(vec![(1, 1), (3, 3), (8, 8)]);\n+\n+    let expected = vec![(1, 1), (2, 2), (3, 3), (7, 7), (8, 8)];\n+    assert_eq!(elements(map), expected);\n+}\n+\n+#[test]\n+fn test_insert_presorted_at_end() {\n+    let mut map = SortedMap::new();\n+    map.insert(1, 1);\n+    map.insert(2, 2);\n+\n+    map.insert_presorted(vec![(3, 3), (8, 8)]);\n+\n+    let expected = vec![(1, 1), (2, 2), (3, 3), (8, 8)];\n+    assert_eq!(elements(map), expected);\n+}"}, {"sha": "903a2d6801230651698a47e181342f3d13818838", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -440,26 +440,4 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::{is_camel_case, to_camel_case};\n-\n-    #[test]\n-    fn camel_case() {\n-        assert!(!is_camel_case(\"userData\"));\n-        assert_eq!(to_camel_case(\"userData\"), \"UserData\");\n-\n-        assert!(is_camel_case(\"X86_64\"));\n-\n-        assert!(!is_camel_case(\"X86__64\"));\n-        assert_eq!(to_camel_case(\"X86__64\"), \"X86_64\");\n-\n-        assert!(!is_camel_case(\"Abc_123\"));\n-        assert_eq!(to_camel_case(\"Abc_123\"), \"Abc123\");\n-\n-        assert!(!is_camel_case(\"A1_b2_c3\"));\n-        assert_eq!(to_camel_case(\"A1_b2_c3\"), \"A1B2C3\");\n-\n-        assert!(!is_camel_case(\"ONE_TWO_THREE\"));\n-        assert_eq!(to_camel_case(\"ONE_TWO_THREE\"), \"OneTwoThree\");\n-    }\n-}\n+mod tests;"}, {"sha": "39c525b8623d072a907f55ca8d781e350bc38602", "filename": "src/librustc_lint/nonstandard_style/tests.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_lint%2Fnonstandard_style%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_lint%2Fnonstandard_style%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,21 @@\n+use super::{is_camel_case, to_camel_case};\n+\n+#[test]\n+fn camel_case() {\n+    assert!(!is_camel_case(\"userData\"));\n+    assert_eq!(to_camel_case(\"userData\"), \"UserData\");\n+\n+    assert!(is_camel_case(\"X86_64\"));\n+\n+    assert!(!is_camel_case(\"X86__64\"));\n+    assert_eq!(to_camel_case(\"X86__64\"), \"X86_64\");\n+\n+    assert!(!is_camel_case(\"Abc_123\"));\n+    assert_eq!(to_camel_case(\"Abc_123\"), \"Abc123\");\n+\n+    assert!(!is_camel_case(\"A1_b2_c3\"));\n+    assert_eq!(to_camel_case(\"A1_b2_c3\"), \"A1B2C3\");\n+\n+    assert!(!is_camel_case(\"ONE_TWO_THREE\"));\n+    assert_eq!(to_camel_case(\"ONE_TWO_THREE\"), \"OneTwoThree\");\n+}"}, {"sha": "76a9a3405bd813271adbdce8e19506c5724d9351", "filename": "src/librustc_metadata/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 49, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_metadata%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -74,55 +74,7 @@ impl DynamicLibrary {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use std::mem;\n-\n-    #[test]\n-    fn test_loading_atoi() {\n-        if cfg!(windows) {\n-            return\n-        }\n-\n-        // The C library does not need to be loaded since it is already linked in\n-        let lib = match DynamicLibrary::open(None) {\n-            Err(error) => panic!(\"Could not load self as module: {}\", error),\n-            Ok(lib) => lib\n-        };\n-\n-        let atoi: extern fn(*const libc::c_char) -> libc::c_int = unsafe {\n-            match lib.symbol(\"atoi\") {\n-                Err(error) => panic!(\"Could not load function atoi: {}\", error),\n-                Ok(atoi) => mem::transmute::<*mut u8, _>(atoi)\n-            }\n-        };\n-\n-        let argument = CString::new(\"1383428980\").unwrap();\n-        let expected_result = 0x52757374;\n-        let result = atoi(argument.as_ptr());\n-        if result != expected_result {\n-            panic!(\"atoi({:?}) != {} but equaled {} instead\", argument,\n-                   expected_result, result)\n-        }\n-    }\n-\n-    #[test]\n-    fn test_errors_do_not_crash() {\n-        use std::path::Path;\n-\n-        if !cfg!(unix) {\n-            return\n-        }\n-\n-        // Open /dev/null as a library to get an error, and make sure\n-        // that only causes an error, and not a crash.\n-        let path = Path::new(\"/dev/null\");\n-        match DynamicLibrary::open(Some(&path)) {\n-            Err(_) => {}\n-            Ok(_) => panic!(\"Successfully opened the empty library.\")\n-        }\n-    }\n-}\n+mod tests;\n \n #[cfg(unix)]\n mod dl {"}, {"sha": "b2302f2f1b5b725dd99bf0332fa1c36bcf324d9d", "filename": "src/librustc_metadata/dynamic_lib/tests.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_metadata%2Fdynamic_lib%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustc_metadata%2Fdynamic_lib%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdynamic_lib%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,47 @@\n+use super::*;\n+use std::mem;\n+\n+#[test]\n+fn test_loading_atoi() {\n+    if cfg!(windows) {\n+        return\n+    }\n+\n+    // The C library does not need to be loaded since it is already linked in\n+    let lib = match DynamicLibrary::open(None) {\n+        Err(error) => panic!(\"Could not load self as module: {}\", error),\n+        Ok(lib) => lib\n+    };\n+\n+    let atoi: extern fn(*const libc::c_char) -> libc::c_int = unsafe {\n+        match lib.symbol(\"atoi\") {\n+            Err(error) => panic!(\"Could not load function atoi: {}\", error),\n+            Ok(atoi) => mem::transmute::<*mut u8, _>(atoi)\n+        }\n+    };\n+\n+    let argument = CString::new(\"1383428980\").unwrap();\n+    let expected_result = 0x52757374;\n+    let result = atoi(argument.as_ptr());\n+    if result != expected_result {\n+        panic!(\"atoi({:?}) != {} but equaled {} instead\", argument,\n+               expected_result, result)\n+    }\n+}\n+\n+#[test]\n+fn test_errors_do_not_crash() {\n+    use std::path::Path;\n+\n+    if !cfg!(unix) {\n+        return\n+    }\n+\n+    // Open /dev/null as a library to get an error, and make sure\n+    // that only causes an error, and not a crash.\n+    let path = Path::new(\"/dev/null\");\n+    match DynamicLibrary::open(Some(&path)) {\n+        Err(_) => {}\n+        Ok(_) => panic!(\"Successfully opened the empty library.\")\n+    }\n+}"}, {"sha": "c698200039623e477be5c887d9984f1244b7c80c", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 22, "deletions": 143, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -43,25 +43,30 @@ fn opts() -> Options {\n     Options::ENABLE_TABLES | Options::ENABLE_FOOTNOTES\n }\n \n-/// A unit struct which has the `fmt::Display` trait implemented. When\n-/// formatted, this struct will emit the HTML corresponding to the rendered\n+/// A tuple struct that has the `fmt::Display` trait implemented.\n+/// When formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n-///\n-/// The second parameter is a list of link replacements.\n-///\n-/// The third is the current list of used header IDs.\n-///\n-/// The fourth is whether to allow the use of explicit error codes in doctest lang strings.\n-///\n-/// The fifth is what default edition to use when parsing doctests (to add a `fn main`).\n pub struct Markdown<'a>(\n-    pub &'a str, pub &'a [(String, String)], pub RefCell<&'a mut IdMap>, pub ErrorCodes, pub Edition);\n-/// A unit struct like `Markdown`, that renders the markdown with a\n-/// table of contents.\n-pub struct MarkdownWithToc<'a>(pub &'a str, pub RefCell<&'a mut IdMap>, pub ErrorCodes, pub Edition);\n-/// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n+    pub &'a str,\n+    /// A list of link replacements.\n+    pub &'a [(String, String)],\n+    /// The current list of used header IDs.\n+    pub RefCell<&'a mut IdMap>,\n+    /// Whether to allow the use of explicit error codes in doctest lang strings.\n+    pub ErrorCodes,\n+    /// Default edition to use when parsing doctests (to add a `fn main`).\n+    pub Edition,\n+);\n+/// A tuple struct like `Markdown` that renders the markdown with a table of contents.\n+pub struct MarkdownWithToc<'a>(\n+    pub &'a str,\n+    pub RefCell<&'a mut IdMap>,\n+    pub ErrorCodes,\n+    pub Edition,\n+);\n+/// A tuple struct like `Markdown` that renders the markdown escaping HTML tags.\n pub struct MarkdownHtml<'a>(pub &'a str, pub RefCell<&'a mut IdMap>, pub ErrorCodes, pub Edition);\n-/// A unit struct like `Markdown`, that renders only the first paragraph.\n+/// A tuple struct like `Markdown` that renders only the first paragraph.\n pub struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [(String, String)]);\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n@@ -1050,130 +1055,4 @@ fn test_unique_id() {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::{ErrorCodes, LangString, Markdown, MarkdownHtml, IdMap};\n-    use super::plain_summary_line;\n-    use std::cell::RefCell;\n-    use syntax::edition::{Edition, DEFAULT_EDITION};\n-\n-    #[test]\n-    fn test_lang_string_parse() {\n-        fn t(s: &str,\n-            should_panic: bool, no_run: bool, ignore: bool, rust: bool, test_harness: bool,\n-            compile_fail: bool, allow_fail: bool, error_codes: Vec<String>,\n-             edition: Option<Edition>) {\n-            assert_eq!(LangString::parse(s, ErrorCodes::Yes), LangString {\n-                should_panic,\n-                no_run,\n-                ignore,\n-                rust,\n-                test_harness,\n-                compile_fail,\n-                error_codes,\n-                original: s.to_owned(),\n-                allow_fail,\n-                edition,\n-            })\n-        }\n-\n-        fn v() -> Vec<String> {\n-            Vec::new()\n-        }\n-\n-        // ignore-tidy-linelength\n-        // marker                | should_panic | no_run | ignore | rust | test_harness\n-        //                       | compile_fail | allow_fail | error_codes | edition\n-        t(\"\",                      false,         false,   false,   true,  false, false, false, v(), None);\n-        t(\"rust\",                  false,         false,   false,   true,  false, false, false, v(), None);\n-        t(\"sh\",                    false,         false,   false,   false, false, false, false, v(), None);\n-        t(\"ignore\",                false,         false,   true,    true,  false, false, false, v(), None);\n-        t(\"should_panic\",          true,          false,   false,   true,  false, false, false, v(), None);\n-        t(\"no_run\",                false,         true,    false,   true,  false, false, false, v(), None);\n-        t(\"test_harness\",          false,         false,   false,   true,  true,  false, false, v(), None);\n-        t(\"compile_fail\",          false,         true,    false,   true,  false, true,  false, v(), None);\n-        t(\"allow_fail\",            false,         false,   false,   true,  false, false, true,  v(), None);\n-        t(\"{.no_run .example}\",    false,         true,    false,   true,  false, false, false, v(), None);\n-        t(\"{.sh .should_panic}\",   true,          false,   false,   false, false, false, false, v(), None);\n-        t(\"{.example .rust}\",      false,         false,   false,   true,  false, false, false, v(), None);\n-        t(\"{.test_harness .rust}\", false,         false,   false,   true,  true,  false, false, v(), None);\n-        t(\"text, no_run\",          false,         true,    false,   false, false, false, false, v(), None);\n-        t(\"text,no_run\",           false,         true,    false,   false, false, false, false, v(), None);\n-        t(\"edition2015\",           false,         false,   false,   true,  false, false, false, v(), Some(Edition::Edition2015));\n-        t(\"edition2018\",           false,         false,   false,   true,  false, false, false, v(), Some(Edition::Edition2018));\n-    }\n-\n-    #[test]\n-    fn test_header() {\n-        fn t(input: &str, expect: &str) {\n-            let mut map = IdMap::new();\n-            let output = Markdown(input, &[], RefCell::new(&mut map),\n-                                  ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n-            assert_eq!(output, expect, \"original: {}\", input);\n-        }\n-\n-        t(\"# Foo bar\", \"<h1 id=\\\"foo-bar\\\" class=\\\"section-header\\\">\\\n-          <a href=\\\"#foo-bar\\\">Foo bar</a></h1>\");\n-        t(\"## Foo-bar_baz qux\", \"<h2 id=\\\"foo-bar_baz-qux\\\" class=\\\"section-\\\n-          header\\\"><a href=\\\"#foo-bar_baz-qux\\\">Foo-bar_baz qux</a></h2>\");\n-        t(\"### **Foo** *bar* baz!?!& -_qux_-%\",\n-          \"<h3 id=\\\"foo-bar-baz--qux-\\\" class=\\\"section-header\\\">\\\n-          <a href=\\\"#foo-bar-baz--qux-\\\"><strong>Foo</strong> \\\n-          <em>bar</em> baz!?!&amp; -<em>qux</em>-%</a></h3>\");\n-        t(\"#### **Foo?** & \\\\*bar?!*  _`baz`_ \u2764 #qux\",\n-          \"<h4 id=\\\"foo--bar--baz--qux\\\" class=\\\"section-header\\\">\\\n-          <a href=\\\"#foo--bar--baz--qux\\\"><strong>Foo?</strong> &amp; *bar?!*  \\\n-          <em><code>baz</code></em> \u2764 #qux</a></h4>\");\n-    }\n-\n-    #[test]\n-    fn test_header_ids_multiple_blocks() {\n-        let mut map = IdMap::new();\n-        fn t(map: &mut IdMap, input: &str, expect: &str) {\n-            let output = Markdown(input, &[], RefCell::new(map),\n-                                  ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n-            assert_eq!(output, expect, \"original: {}\", input);\n-        }\n-\n-        t(&mut map, \"# Example\", \"<h1 id=\\\"example\\\" class=\\\"section-header\\\">\\\n-            <a href=\\\"#example\\\">Example</a></h1>\");\n-        t(&mut map, \"# Panics\", \"<h1 id=\\\"panics\\\" class=\\\"section-header\\\">\\\n-            <a href=\\\"#panics\\\">Panics</a></h1>\");\n-        t(&mut map, \"# Example\", \"<h1 id=\\\"example-1\\\" class=\\\"section-header\\\">\\\n-            <a href=\\\"#example-1\\\">Example</a></h1>\");\n-        t(&mut map, \"# Main\", \"<h1 id=\\\"main\\\" class=\\\"section-header\\\">\\\n-            <a href=\\\"#main\\\">Main</a></h1>\");\n-        t(&mut map, \"# Example\", \"<h1 id=\\\"example-2\\\" class=\\\"section-header\\\">\\\n-            <a href=\\\"#example-2\\\">Example</a></h1>\");\n-        t(&mut map, \"# Panics\", \"<h1 id=\\\"panics-1\\\" class=\\\"section-header\\\">\\\n-            <a href=\\\"#panics-1\\\">Panics</a></h1>\");\n-    }\n-\n-    #[test]\n-    fn test_plain_summary_line() {\n-        fn t(input: &str, expect: &str) {\n-            let output = plain_summary_line(input);\n-            assert_eq!(output, expect, \"original: {}\", input);\n-        }\n-\n-        t(\"hello [Rust](https://www.rust-lang.org) :)\", \"hello Rust :)\");\n-        t(\"hello [Rust](https://www.rust-lang.org \\\"Rust\\\") :)\", \"hello Rust :)\");\n-        t(\"code `let x = i32;` ...\", \"code `let x = i32;` ...\");\n-        t(\"type `Type<'static>` ...\", \"type `Type<'static>` ...\");\n-        t(\"# top header\", \"top header\");\n-        t(\"## header\", \"header\");\n-    }\n-\n-    #[test]\n-    fn test_markdown_html_escape() {\n-        fn t(input: &str, expect: &str) {\n-            let mut idmap = IdMap::new();\n-            let output = MarkdownHtml(input, RefCell::new(&mut idmap),\n-                                      ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n-            assert_eq!(output, expect, \"original: {}\", input);\n-        }\n-\n-        t(\"`Struct<'a, T>`\", \"<p><code>Struct&lt;'a, T&gt;</code></p>\\n\");\n-        t(\"Struct<'a, T>\", \"<p>Struct&lt;'a, T&gt;</p>\\n\");\n-        t(\"Struct<br>\", \"<p>Struct&lt;br&gt;</p>\\n\");\n-    }\n-}\n+mod tests;"}, {"sha": "f470e649d82656e11a96e755dbab822ae7022805", "filename": "src/librustdoc/html/markdown/tests.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,125 @@\n+use super::{ErrorCodes, LangString, Markdown, MarkdownHtml, IdMap};\n+use super::plain_summary_line;\n+use std::cell::RefCell;\n+use syntax::edition::{Edition, DEFAULT_EDITION};\n+\n+#[test]\n+fn test_lang_string_parse() {\n+    fn t(s: &str,\n+        should_panic: bool, no_run: bool, ignore: bool, rust: bool, test_harness: bool,\n+        compile_fail: bool, allow_fail: bool, error_codes: Vec<String>,\n+         edition: Option<Edition>) {\n+        assert_eq!(LangString::parse(s, ErrorCodes::Yes), LangString {\n+            should_panic,\n+            no_run,\n+            ignore,\n+            rust,\n+            test_harness,\n+            compile_fail,\n+            error_codes,\n+            original: s.to_owned(),\n+            allow_fail,\n+            edition,\n+        })\n+    }\n+\n+    fn v() -> Vec<String> {\n+        Vec::new()\n+    }\n+\n+    // ignore-tidy-linelength\n+    // marker                | should_panic | no_run | ignore | rust | test_harness\n+    //                       | compile_fail | allow_fail | error_codes | edition\n+    t(\"\",                      false,         false,   false,   true,  false, false, false, v(), None);\n+    t(\"rust\",                  false,         false,   false,   true,  false, false, false, v(), None);\n+    t(\"sh\",                    false,         false,   false,   false, false, false, false, v(), None);\n+    t(\"ignore\",                false,         false,   true,    true,  false, false, false, v(), None);\n+    t(\"should_panic\",          true,          false,   false,   true,  false, false, false, v(), None);\n+    t(\"no_run\",                false,         true,    false,   true,  false, false, false, v(), None);\n+    t(\"test_harness\",          false,         false,   false,   true,  true,  false, false, v(), None);\n+    t(\"compile_fail\",          false,         true,    false,   true,  false, true,  false, v(), None);\n+    t(\"allow_fail\",            false,         false,   false,   true,  false, false, true,  v(), None);\n+    t(\"{.no_run .example}\",    false,         true,    false,   true,  false, false, false, v(), None);\n+    t(\"{.sh .should_panic}\",   true,          false,   false,   false, false, false, false, v(), None);\n+    t(\"{.example .rust}\",      false,         false,   false,   true,  false, false, false, v(), None);\n+    t(\"{.test_harness .rust}\", false,         false,   false,   true,  true,  false, false, v(), None);\n+    t(\"text, no_run\",          false,         true,    false,   false, false, false, false, v(), None);\n+    t(\"text,no_run\",           false,         true,    false,   false, false, false, false, v(), None);\n+    t(\"edition2015\",           false,         false,   false,   true,  false, false, false, v(), Some(Edition::Edition2015));\n+    t(\"edition2018\",           false,         false,   false,   true,  false, false, false, v(), Some(Edition::Edition2018));\n+}\n+\n+#[test]\n+fn test_header() {\n+    fn t(input: &str, expect: &str) {\n+        let mut map = IdMap::new();\n+        let output = Markdown(input, &[], RefCell::new(&mut map),\n+                              ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n+        assert_eq!(output, expect, \"original: {}\", input);\n+    }\n+\n+    t(\"# Foo bar\", \"<h1 id=\\\"foo-bar\\\" class=\\\"section-header\\\">\\\n+      <a href=\\\"#foo-bar\\\">Foo bar</a></h1>\");\n+    t(\"## Foo-bar_baz qux\", \"<h2 id=\\\"foo-bar_baz-qux\\\" class=\\\"section-\\\n+      header\\\"><a href=\\\"#foo-bar_baz-qux\\\">Foo-bar_baz qux</a></h2>\");\n+    t(\"### **Foo** *bar* baz!?!& -_qux_-%\",\n+      \"<h3 id=\\\"foo-bar-baz--qux-\\\" class=\\\"section-header\\\">\\\n+      <a href=\\\"#foo-bar-baz--qux-\\\"><strong>Foo</strong> \\\n+      <em>bar</em> baz!?!&amp; -<em>qux</em>-%</a></h3>\");\n+    t(\"#### **Foo?** & \\\\*bar?!*  _`baz`_ \u2764 #qux\",\n+      \"<h4 id=\\\"foo--bar--baz--qux\\\" class=\\\"section-header\\\">\\\n+      <a href=\\\"#foo--bar--baz--qux\\\"><strong>Foo?</strong> &amp; *bar?!*  \\\n+      <em><code>baz</code></em> \u2764 #qux</a></h4>\");\n+}\n+\n+#[test]\n+fn test_header_ids_multiple_blocks() {\n+    let mut map = IdMap::new();\n+    fn t(map: &mut IdMap, input: &str, expect: &str) {\n+        let output = Markdown(input, &[], RefCell::new(map),\n+                              ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n+        assert_eq!(output, expect, \"original: {}\", input);\n+    }\n+\n+    t(&mut map, \"# Example\", \"<h1 id=\\\"example\\\" class=\\\"section-header\\\">\\\n+        <a href=\\\"#example\\\">Example</a></h1>\");\n+    t(&mut map, \"# Panics\", \"<h1 id=\\\"panics\\\" class=\\\"section-header\\\">\\\n+        <a href=\\\"#panics\\\">Panics</a></h1>\");\n+    t(&mut map, \"# Example\", \"<h1 id=\\\"example-1\\\" class=\\\"section-header\\\">\\\n+        <a href=\\\"#example-1\\\">Example</a></h1>\");\n+    t(&mut map, \"# Main\", \"<h1 id=\\\"main\\\" class=\\\"section-header\\\">\\\n+        <a href=\\\"#main\\\">Main</a></h1>\");\n+    t(&mut map, \"# Example\", \"<h1 id=\\\"example-2\\\" class=\\\"section-header\\\">\\\n+        <a href=\\\"#example-2\\\">Example</a></h1>\");\n+    t(&mut map, \"# Panics\", \"<h1 id=\\\"panics-1\\\" class=\\\"section-header\\\">\\\n+        <a href=\\\"#panics-1\\\">Panics</a></h1>\");\n+}\n+\n+#[test]\n+fn test_plain_summary_line() {\n+    fn t(input: &str, expect: &str) {\n+        let output = plain_summary_line(input);\n+        assert_eq!(output, expect, \"original: {}\", input);\n+    }\n+\n+    t(\"hello [Rust](https://www.rust-lang.org) :)\", \"hello Rust :)\");\n+    t(\"hello [Rust](https://www.rust-lang.org \\\"Rust\\\") :)\", \"hello Rust :)\");\n+    t(\"code `let x = i32;` ...\", \"code `let x = i32;` ...\");\n+    t(\"type `Type<'static>` ...\", \"type `Type<'static>` ...\");\n+    t(\"# top header\", \"top header\");\n+    t(\"## header\", \"header\");\n+}\n+\n+#[test]\n+fn test_markdown_html_escape() {\n+    fn t(input: &str, expect: &str) {\n+        let mut idmap = IdMap::new();\n+        let output = MarkdownHtml(input, RefCell::new(&mut idmap),\n+                                  ErrorCodes::Yes, DEFAULT_EDITION).to_string();\n+        assert_eq!(output, expect, \"original: {}\", input);\n+    }\n+\n+    t(\"`Struct<'a, T>`\", \"<p><code>Struct&lt;'a, T&gt;</code></p>\\n\");\n+    t(\"Struct<'a, T>\", \"<p>Struct&lt;'a, T&gt;</p>\\n\");\n+    t(\"Struct<br>\", \"<p>Struct&lt;br&gt;</p>\\n\");\n+}"}, {"sha": "2564c611e54e59ebc25de0698cf1aab91b08b686", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 1, "deletions": 82, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -188,85 +188,4 @@ impl fmt::Display for Toc {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::{TocBuilder, Toc, TocEntry};\n-\n-    #[test]\n-    fn builder_smoke() {\n-        let mut builder = TocBuilder::new();\n-\n-        // this is purposely not using a fancy macro like below so\n-        // that we're sure that this is doing the correct thing, and\n-        // there's been no macro mistake.\n-        macro_rules! push {\n-            ($level: expr, $name: expr) => {\n-                assert_eq!(builder.push($level,\n-                                        $name.to_string(),\n-                                        \"\".to_string()),\n-                           $name);\n-            }\n-        }\n-        push!(2, \"0.1\");\n-        push!(1, \"1\");\n-        {\n-            push!(2, \"1.1\");\n-            {\n-                push!(3, \"1.1.1\");\n-                push!(3, \"1.1.2\");\n-            }\n-            push!(2, \"1.2\");\n-            {\n-                push!(3, \"1.2.1\");\n-                push!(3, \"1.2.2\");\n-            }\n-        }\n-        push!(1, \"2\");\n-        push!(1, \"3\");\n-        {\n-            push!(4, \"3.0.0.1\");\n-            {\n-                push!(6, \"3.0.0.1.0.1\");\n-            }\n-            push!(4, \"3.0.0.2\");\n-            push!(2, \"3.1\");\n-            {\n-                push!(4, \"3.1.0.1\");\n-            }\n-        }\n-\n-        macro_rules! toc {\n-            ($(($level: expr, $name: expr, $(($sub: tt))* )),*) => {\n-                Toc {\n-                    entries: vec![\n-                        $(\n-                            TocEntry {\n-                                level: $level,\n-                                name: $name.to_string(),\n-                                sec_number: $name.to_string(),\n-                                id: \"\".to_string(),\n-                                children: toc!($($sub),*)\n-                            }\n-                            ),*\n-                        ]\n-                }\n-            }\n-        }\n-        let expected = toc!(\n-            (2, \"0.1\", ),\n-\n-            (1, \"1\",\n-             ((2, \"1.1\", ((3, \"1.1.1\", )) ((3, \"1.1.2\", ))))\n-             ((2, \"1.2\", ((3, \"1.2.1\", )) ((3, \"1.2.2\", ))))\n-             ),\n-\n-            (1, \"2\", ),\n-\n-            (1, \"3\",\n-             ((4, \"3.0.0.1\", ((6, \"3.0.0.1.0.1\", ))))\n-             ((4, \"3.0.0.2\", ))\n-             ((2, \"3.1\", ((4, \"3.1.0.1\", ))))\n-             )\n-            );\n-        assert_eq!(expected, builder.into_toc());\n-    }\n-}\n+mod tests;"}, {"sha": "ef69ada4664962839c5fc8327a9de7712d2dcc89", "filename": "src/librustdoc/html/toc/tests.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustdoc%2Fhtml%2Ftoc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustdoc%2Fhtml%2Ftoc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,80 @@\n+use super::{TocBuilder, Toc, TocEntry};\n+\n+#[test]\n+fn builder_smoke() {\n+    let mut builder = TocBuilder::new();\n+\n+    // this is purposely not using a fancy macro like below so\n+    // that we're sure that this is doing the correct thing, and\n+    // there's been no macro mistake.\n+    macro_rules! push {\n+        ($level: expr, $name: expr) => {\n+            assert_eq!(builder.push($level,\n+                                    $name.to_string(),\n+                                    \"\".to_string()),\n+                       $name);\n+        }\n+    }\n+    push!(2, \"0.1\");\n+    push!(1, \"1\");\n+    {\n+        push!(2, \"1.1\");\n+        {\n+            push!(3, \"1.1.1\");\n+            push!(3, \"1.1.2\");\n+        }\n+        push!(2, \"1.2\");\n+        {\n+            push!(3, \"1.2.1\");\n+            push!(3, \"1.2.2\");\n+        }\n+    }\n+    push!(1, \"2\");\n+    push!(1, \"3\");\n+    {\n+        push!(4, \"3.0.0.1\");\n+        {\n+            push!(6, \"3.0.0.1.0.1\");\n+        }\n+        push!(4, \"3.0.0.2\");\n+        push!(2, \"3.1\");\n+        {\n+            push!(4, \"3.1.0.1\");\n+        }\n+    }\n+\n+    macro_rules! toc {\n+        ($(($level: expr, $name: expr, $(($sub: tt))* )),*) => {\n+            Toc {\n+                entries: vec![\n+                    $(\n+                        TocEntry {\n+                            level: $level,\n+                            name: $name.to_string(),\n+                            sec_number: $name.to_string(),\n+                            id: \"\".to_string(),\n+                            children: toc!($($sub),*)\n+                        }\n+                        ),*\n+                    ]\n+            }\n+        }\n+    }\n+    let expected = toc!(\n+        (2, \"0.1\", ),\n+\n+        (1, \"1\",\n+         ((2, \"1.1\", ((3, \"1.1.1\", )) ((3, \"1.1.2\", ))))\n+         ((2, \"1.2\", ((3, \"1.2.1\", )) ((3, \"1.2.2\", ))))\n+         ),\n+\n+        (1, \"2\", ),\n+\n+        (1, \"3\",\n+         ((4, \"3.0.0.1\", ((6, \"3.0.0.1.0.1\", ))))\n+         ((4, \"3.0.0.2\", ))\n+         ((2, \"3.1\", ((4, \"3.1.0.1\", ))))\n+         )\n+        );\n+    assert_eq!(expected, builder.into_toc());\n+}"}, {"sha": "9a9fd941240bcfc515270a44183a1a95992f7927", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 301, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -975,304 +975,4 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use super::{TestOptions, make_test};\n-    use syntax::edition::DEFAULT_EDITION;\n-\n-    #[test]\n-    fn make_test_basic() {\n-        //basic use: wraps with `fn main`, adds `#![allow(unused)]`\n-        let opts = TestOptions::default();\n-        let input =\n-\"assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-fn main() {\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_crate_name_no_use() {\n-        // If you give a crate name but *don't* use it within the test, it won't bother inserting\n-        // the `extern crate` statement.\n-        let opts = TestOptions::default();\n-        let input =\n-\"assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-fn main() {\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_crate_name() {\n-        // If you give a crate name and use it within the test, it will insert an `extern crate`\n-        // statement before `fn main`.\n-        let opts = TestOptions::default();\n-        let input =\n-\"use asdf::qwop;\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-extern crate asdf;\n-fn main() {\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 3));\n-    }\n-\n-    #[test]\n-    fn make_test_no_crate_inject() {\n-        // Even if you do use the crate within the test, setting `opts.no_crate_inject` will skip\n-        // adding it anyway.\n-        let opts = TestOptions {\n-            no_crate_inject: true,\n-            display_warnings: false,\n-            attrs: vec![],\n-        };\n-        let input =\n-\"use asdf::qwop;\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-fn main() {\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_ignore_std() {\n-        // Even if you include a crate name, and use it in the doctest, we still won't include an\n-        // `extern crate` statement if the crate is \"std\" -- that's included already by the\n-        // compiler!\n-        let opts = TestOptions::default();\n-        let input =\n-\"use std::*;\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-fn main() {\n-use std::*;\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"std\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_manual_extern_crate() {\n-        // When you manually include an `extern crate` statement in your doctest, `make_test`\n-        // assumes you've included one for your own crate too.\n-        let opts = TestOptions::default();\n-        let input =\n-\"extern crate asdf;\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-extern crate asdf;\n-fn main() {\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_manual_extern_crate_with_macro_use() {\n-        let opts = TestOptions::default();\n-        let input =\n-\"#[macro_use] extern crate asdf;\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-#[macro_use] extern crate asdf;\n-fn main() {\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_opts_attrs() {\n-        // If you supplied some doctest attributes with `#![doc(test(attr(...)))]`, it will use\n-        // those instead of the stock `#![allow(unused)]`.\n-        let mut opts = TestOptions::default();\n-        opts.attrs.push(\"feature(sick_rad)\".to_string());\n-        let input =\n-\"use asdf::qwop;\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![feature(sick_rad)]\n-extern crate asdf;\n-fn main() {\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 3));\n-\n-        // Adding more will also bump the returned line offset.\n-        opts.attrs.push(\"feature(hella_dope)\".to_string());\n-        let expected =\n-\"#![feature(sick_rad)]\n-#![feature(hella_dope)]\n-extern crate asdf;\n-fn main() {\n-use asdf::qwop;\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 4));\n-    }\n-\n-    #[test]\n-    fn make_test_crate_attrs() {\n-        // Including inner attributes in your doctest will apply them to the whole \"crate\", pasting\n-        // them outside the generated main function.\n-        let opts = TestOptions::default();\n-        let input =\n-\"#![feature(sick_rad)]\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-#![feature(sick_rad)]\n-fn main() {\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_with_main() {\n-        // Including your own `fn main` wrapper lets the test use it verbatim.\n-        let opts = TestOptions::default();\n-        let input =\n-\"fn main() {\n-    assert_eq!(2+2, 4);\n-}\";\n-        let expected =\n-\"#![allow(unused)]\n-fn main() {\n-    assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 1));\n-    }\n-\n-    #[test]\n-    fn make_test_fake_main() {\n-        // ... but putting it in a comment will still provide a wrapper.\n-        let opts = TestOptions::default();\n-        let input =\n-\"//Ceci n'est pas une `fn main`\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-//Ceci n'est pas une `fn main`\n-fn main() {\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-    }\n-\n-    #[test]\n-    fn make_test_dont_insert_main() {\n-        // Even with that, if you set `dont_insert_main`, it won't create the `fn main` wrapper.\n-        let opts = TestOptions::default();\n-        let input =\n-\"//Ceci n'est pas une `fn main`\n-assert_eq!(2+2, 4);\";\n-        let expected =\n-\"#![allow(unused)]\n-//Ceci n'est pas une `fn main`\n-assert_eq!(2+2, 4);\".to_string();\n-        let output = make_test(input, None, true, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 1));\n-    }\n-\n-    #[test]\n-    fn make_test_display_warnings() {\n-        // If the user is asking to display doctest warnings, suppress the default `allow(unused)`.\n-        let mut opts = TestOptions::default();\n-        opts.display_warnings = true;\n-        let input =\n-\"assert_eq!(2+2, 4);\";\n-        let expected =\n-\"fn main() {\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 1));\n-    }\n-\n-    #[test]\n-    fn make_test_issues_21299_33731() {\n-        let opts = TestOptions::default();\n-\n-        let input =\n-\"// fn main\n-assert_eq!(2+2, 4);\";\n-\n-        let expected =\n-\"#![allow(unused)]\n-// fn main\n-fn main() {\n-assert_eq!(2+2, 4);\n-}\".to_string();\n-\n-        let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 2));\n-\n-        let input =\n-\"extern crate hella_qwop;\n-assert_eq!(asdf::foo, 4);\";\n-\n-        let expected =\n-\"#![allow(unused)]\n-extern crate hella_qwop;\n-extern crate asdf;\n-fn main() {\n-assert_eq!(asdf::foo, 4);\n-}\".to_string();\n-\n-        let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 3));\n-    }\n-\n-    #[test]\n-    fn make_test_main_in_macro() {\n-        let opts = TestOptions::default();\n-        let input =\n-\"#[macro_use] extern crate my_crate;\n-test_wrapper! {\n-    fn main() {}\n-}\";\n-        let expected =\n-\"#![allow(unused)]\n-#[macro_use] extern crate my_crate;\n-test_wrapper! {\n-    fn main() {}\n-}\".to_string();\n-\n-        let output = make_test(input, Some(\"my_crate\"), false, &opts, DEFAULT_EDITION);\n-        assert_eq!(output, (expected, 1));\n-    }\n-}\n+mod tests;"}, {"sha": "d4d558b7cd78cd997a9edb818d9b034241c48dbd", "filename": "src/librustdoc/test/tests.rs", "status": "added", "additions": 299, "deletions": 0, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustdoc%2Ftest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibrustdoc%2Ftest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,299 @@\n+use super::{TestOptions, make_test};\n+use syntax::edition::DEFAULT_EDITION;\n+\n+#[test]\n+fn make_test_basic() {\n+    //basic use: wraps with `fn main`, adds `#![allow(unused)]`\n+    let opts = TestOptions::default();\n+    let input =\n+\"assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+fn main() {\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_crate_name_no_use() {\n+    // If you give a crate name but *don't* use it within the test, it won't bother inserting\n+    // the `extern crate` statement.\n+    let opts = TestOptions::default();\n+    let input =\n+\"assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+fn main() {\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_crate_name() {\n+    // If you give a crate name and use it within the test, it will insert an `extern crate`\n+    // statement before `fn main`.\n+    let opts = TestOptions::default();\n+    let input =\n+\"use asdf::qwop;\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+extern crate asdf;\n+fn main() {\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 3));\n+}\n+\n+#[test]\n+fn make_test_no_crate_inject() {\n+    // Even if you do use the crate within the test, setting `opts.no_crate_inject` will skip\n+    // adding it anyway.\n+    let opts = TestOptions {\n+        no_crate_inject: true,\n+        display_warnings: false,\n+        attrs: vec![],\n+    };\n+    let input =\n+\"use asdf::qwop;\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+fn main() {\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_ignore_std() {\n+    // Even if you include a crate name, and use it in the doctest, we still won't include an\n+    // `extern crate` statement if the crate is \"std\" -- that's included already by the\n+    // compiler!\n+    let opts = TestOptions::default();\n+    let input =\n+\"use std::*;\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+fn main() {\n+use std::*;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"std\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_manual_extern_crate() {\n+    // When you manually include an `extern crate` statement in your doctest, `make_test`\n+    // assumes you've included one for your own crate too.\n+    let opts = TestOptions::default();\n+    let input =\n+\"extern crate asdf;\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+extern crate asdf;\n+fn main() {\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_manual_extern_crate_with_macro_use() {\n+    let opts = TestOptions::default();\n+    let input =\n+\"#[macro_use] extern crate asdf;\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+#[macro_use] extern crate asdf;\n+fn main() {\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_opts_attrs() {\n+    // If you supplied some doctest attributes with `#![doc(test(attr(...)))]`, it will use\n+    // those instead of the stock `#![allow(unused)]`.\n+    let mut opts = TestOptions::default();\n+    opts.attrs.push(\"feature(sick_rad)\".to_string());\n+    let input =\n+\"use asdf::qwop;\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![feature(sick_rad)]\n+extern crate asdf;\n+fn main() {\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 3));\n+\n+    // Adding more will also bump the returned line offset.\n+    opts.attrs.push(\"feature(hella_dope)\".to_string());\n+    let expected =\n+\"#![feature(sick_rad)]\n+#![feature(hella_dope)]\n+extern crate asdf;\n+fn main() {\n+use asdf::qwop;\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 4));\n+}\n+\n+#[test]\n+fn make_test_crate_attrs() {\n+    // Including inner attributes in your doctest will apply them to the whole \"crate\", pasting\n+    // them outside the generated main function.\n+    let opts = TestOptions::default();\n+    let input =\n+\"#![feature(sick_rad)]\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+#![feature(sick_rad)]\n+fn main() {\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_with_main() {\n+    // Including your own `fn main` wrapper lets the test use it verbatim.\n+    let opts = TestOptions::default();\n+    let input =\n+\"fn main() {\n+    assert_eq!(2+2, 4);\n+}\";\n+    let expected =\n+\"#![allow(unused)]\n+fn main() {\n+    assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 1));\n+}\n+\n+#[test]\n+fn make_test_fake_main() {\n+    // ... but putting it in a comment will still provide a wrapper.\n+    let opts = TestOptions::default();\n+    let input =\n+\"//Ceci n'est pas une `fn main`\n+assert_eq!(2+2, 4);\";\n+    let expected =\n+\"#![allow(unused)]\n+//Ceci n'est pas une `fn main`\n+fn main() {\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+}\n+\n+#[test]\n+fn make_test_dont_insert_main() {\n+    // Even with that, if you set `dont_insert_main`, it won't create the `fn main` wrapper.\n+    let opts = TestOptions::default();\n+    let input =\n+\"//Ceci n'est pas une `fn main`\n+assert_eq!(2+2, 4);\";\n+        let expected =\n+\"#![allow(unused)]\n+//Ceci n'est pas une `fn main`\n+assert_eq!(2+2, 4);\".to_string();\n+    let output = make_test(input, None, true, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 1));\n+}\n+\n+#[test]\n+fn make_test_display_warnings() {\n+    // If the user is asking to display doctest warnings, suppress the default `allow(unused)`.\n+    let mut opts = TestOptions::default();\n+    opts.display_warnings = true;\n+    let input =\n+\"assert_eq!(2+2, 4);\";\n+        let expected =\n+\"fn main() {\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 1));\n+}\n+\n+#[test]\n+fn make_test_issues_21299_33731() {\n+    let opts = TestOptions::default();\n+\n+    let input =\n+\"// fn main\n+assert_eq!(2+2, 4);\";\n+\n+    let expected =\n+\"#![allow(unused)]\n+// fn main\n+fn main() {\n+assert_eq!(2+2, 4);\n+}\".to_string();\n+\n+    let output = make_test(input, None, false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 2));\n+\n+    let input =\n+\"extern crate hella_qwop;\n+assert_eq!(asdf::foo, 4);\";\n+\n+    let expected =\n+\"#![allow(unused)]\n+extern crate hella_qwop;\n+extern crate asdf;\n+fn main() {\n+assert_eq!(asdf::foo, 4);\n+}\".to_string();\n+\n+    let output = make_test(input, Some(\"asdf\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 3));\n+}\n+\n+#[test]\n+fn make_test_main_in_macro() {\n+    let opts = TestOptions::default();\n+    let input =\n+\"#[macro_use] extern crate my_crate;\n+test_wrapper! {\n+    fn main() {}\n+}\";\n+    let expected =\n+\"#![allow(unused)]\n+#[macro_use] extern crate my_crate;\n+test_wrapper! {\n+    fn main() {}\n+}\".to_string();\n+\n+    let output = make_test(input, Some(\"my_crate\"), false, &opts, DEFAULT_EDITION);\n+    assert_eq!(output, (expected, 1));\n+}"}, {"sha": "95d92f311ed3cdb48db3fc6ca6c61920439b9a05", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 1, "deletions": 76, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -143,79 +143,4 @@ impl FromHex for str {\n }\n \n #[cfg(test)]\n-mod tests {\n-    extern crate test;\n-    use test::Bencher;\n-    use crate::hex::{FromHex, ToHex};\n-\n-    #[test]\n-    pub fn test_to_hex() {\n-        assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\");\n-    }\n-\n-    #[test]\n-    pub fn test_from_hex_okay() {\n-        assert_eq!(\"666f6f626172\".from_hex().unwrap(),\n-                   b\"foobar\");\n-        assert_eq!(\"666F6F626172\".from_hex().unwrap(),\n-                   b\"foobar\");\n-    }\n-\n-    #[test]\n-    pub fn test_from_hex_odd_len() {\n-        assert!(\"666\".from_hex().is_err());\n-        assert!(\"66 6\".from_hex().is_err());\n-    }\n-\n-    #[test]\n-    pub fn test_from_hex_invalid_char() {\n-        assert!(\"66y6\".from_hex().is_err());\n-    }\n-\n-    #[test]\n-    pub fn test_from_hex_ignores_whitespace() {\n-        assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap(),\n-                   b\"foobar\");\n-    }\n-\n-    #[test]\n-    pub fn test_to_hex_all_bytes() {\n-        for i in 0..256 {\n-            assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as usize));\n-        }\n-    }\n-\n-    #[test]\n-    pub fn test_from_hex_all_bytes() {\n-        for i in 0..256 {\n-            let ii: &[u8] = &[i as u8];\n-            assert_eq!(format!(\"{:02x}\", i as usize).from_hex()\n-                                                   .unwrap(),\n-                       ii);\n-            assert_eq!(format!(\"{:02X}\", i as usize).from_hex()\n-                                                   .unwrap(),\n-                       ii);\n-        }\n-    }\n-\n-    #[bench]\n-    pub fn bench_to_hex(b: &mut Bencher) {\n-        let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n-                 \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-        b.iter(|| {\n-            s.as_bytes().to_hex();\n-        });\n-        b.bytes = s.len() as u64;\n-    }\n-\n-    #[bench]\n-    pub fn bench_from_hex(b: &mut Bencher) {\n-        let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n-                 \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n-        let sb = s.as_bytes().to_hex();\n-        b.iter(|| {\n-            sb.from_hex().unwrap();\n-        });\n-        b.bytes = sb.len() as u64;\n-    }\n-}\n+mod tests;"}, {"sha": "471912c11d06fd69de0f204bc1acbd8bcf5f3438", "filename": "src/libserialize/hex/tests.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibserialize%2Fhex%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibserialize%2Fhex%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,74 @@\n+extern crate test;\n+use test::Bencher;\n+use crate::hex::{FromHex, ToHex};\n+\n+#[test]\n+pub fn test_to_hex() {\n+    assert_eq!(\"foobar\".as_bytes().to_hex(), \"666f6f626172\");\n+}\n+\n+#[test]\n+pub fn test_from_hex_okay() {\n+    assert_eq!(\"666f6f626172\".from_hex().unwrap(),\n+               b\"foobar\");\n+    assert_eq!(\"666F6F626172\".from_hex().unwrap(),\n+               b\"foobar\");\n+}\n+\n+#[test]\n+pub fn test_from_hex_odd_len() {\n+    assert!(\"666\".from_hex().is_err());\n+    assert!(\"66 6\".from_hex().is_err());\n+}\n+\n+#[test]\n+pub fn test_from_hex_invalid_char() {\n+    assert!(\"66y6\".from_hex().is_err());\n+}\n+\n+#[test]\n+pub fn test_from_hex_ignores_whitespace() {\n+    assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap(),\n+               b\"foobar\");\n+}\n+\n+#[test]\n+pub fn test_to_hex_all_bytes() {\n+    for i in 0..256 {\n+        assert_eq!([i as u8].to_hex(), format!(\"{:02x}\", i as usize));\n+    }\n+}\n+\n+#[test]\n+pub fn test_from_hex_all_bytes() {\n+    for i in 0..256 {\n+        let ii: &[u8] = &[i as u8];\n+        assert_eq!(format!(\"{:02x}\", i as usize).from_hex()\n+                                               .unwrap(),\n+                   ii);\n+        assert_eq!(format!(\"{:02X}\", i as usize).from_hex()\n+                                               .unwrap(),\n+                   ii);\n+    }\n+}\n+\n+#[bench]\n+pub fn bench_to_hex(b: &mut Bencher) {\n+    let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n+             \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n+    b.iter(|| {\n+        s.as_bytes().to_hex();\n+    });\n+    b.bytes = s.len() as u64;\n+}\n+\n+#[bench]\n+pub fn bench_from_hex(b: &mut Bencher) {\n+    let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n+             \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n+    let sb = s.as_bytes().to_hex();\n+    b.iter(|| {\n+        sb.from_hex().unwrap();\n+    });\n+    b.bytes = sb.len() as u64;\n+}"}, {"sha": "8f926e6dd2909458e3f15a8f5cd43232c0957beb", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 1, "deletions": 136, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -2582,139 +2582,4 @@ impl FromStr for Json {\n }\n \n #[cfg(test)]\n-mod tests {\n-    // Benchmarks and tests that require private items\n-\n-    extern crate test;\n-    use test::Bencher;\n-    use super::{from_str, Parser, StackElement, Stack};\n-    use std::string;\n-\n-    #[test]\n-    fn test_stack() {\n-        let mut stack = Stack::new();\n-\n-        assert!(stack.is_empty());\n-        assert!(stack.is_empty());\n-        assert!(!stack.last_is_index());\n-\n-        stack.push_index(0);\n-        stack.bump_index();\n-\n-        assert!(stack.len() == 1);\n-        assert!(stack.is_equal_to(&[StackElement::Index(1)]));\n-        assert!(stack.starts_with(&[StackElement::Index(1)]));\n-        assert!(stack.ends_with(&[StackElement::Index(1)]));\n-        assert!(stack.last_is_index());\n-        assert!(stack.get(0) == StackElement::Index(1));\n-\n-        stack.push_key(\"foo\".to_string());\n-\n-        assert!(stack.len() == 2);\n-        assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.starts_with(&[StackElement::Index(1)]));\n-        assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.ends_with(&[StackElement::Key(\"foo\")]));\n-        assert!(!stack.last_is_index());\n-        assert!(stack.get(0) == StackElement::Index(1));\n-        assert!(stack.get(1) == StackElement::Key(\"foo\"));\n-\n-        stack.push_key(\"bar\".to_string());\n-\n-        assert!(stack.len() == 3);\n-        assert!(stack.is_equal_to(&[StackElement::Index(1),\n-                                    StackElement::Key(\"foo\"),\n-                                    StackElement::Key(\"bar\")]));\n-        assert!(stack.starts_with(&[StackElement::Index(1)]));\n-        assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.starts_with(&[StackElement::Index(1),\n-                                    StackElement::Key(\"foo\"),\n-                                    StackElement::Key(\"bar\")]));\n-        assert!(stack.ends_with(&[StackElement::Key(\"bar\")]));\n-        assert!(stack.ends_with(&[StackElement::Key(\"foo\"), StackElement::Key(\"bar\")]));\n-        assert!(stack.ends_with(&[StackElement::Index(1),\n-                                  StackElement::Key(\"foo\"),\n-                                  StackElement::Key(\"bar\")]));\n-        assert!(!stack.last_is_index());\n-        assert!(stack.get(0) == StackElement::Index(1));\n-        assert!(stack.get(1) == StackElement::Key(\"foo\"));\n-        assert!(stack.get(2) == StackElement::Key(\"bar\"));\n-\n-        stack.pop();\n-\n-        assert!(stack.len() == 2);\n-        assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.starts_with(&[StackElement::Index(1)]));\n-        assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n-        assert!(stack.ends_with(&[StackElement::Key(\"foo\")]));\n-        assert!(!stack.last_is_index());\n-        assert!(stack.get(0) == StackElement::Index(1));\n-        assert!(stack.get(1) == StackElement::Key(\"foo\"));\n-    }\n-\n-    #[bench]\n-    fn bench_streaming_small(b: &mut Bencher) {\n-        b.iter( || {\n-            let mut parser = Parser::new(\n-                r#\"{\n-                    \"a\": 1.0,\n-                    \"b\": [\n-                        true,\n-                        \"foo\\nbar\",\n-                        { \"c\": {\"d\": null} }\n-                    ]\n-                }\"#.chars()\n-            );\n-            loop {\n-                match parser.next() {\n-                    None => return,\n-                    _ => {}\n-                }\n-            }\n-        });\n-    }\n-    #[bench]\n-    fn bench_small(b: &mut Bencher) {\n-        b.iter( || {\n-            let _ = from_str(r#\"{\n-                \"a\": 1.0,\n-                \"b\": [\n-                    true,\n-                    \"foo\\nbar\",\n-                    { \"c\": {\"d\": null} }\n-                ]\n-            }\"#);\n-        });\n-    }\n-\n-    fn big_json() -> string::String {\n-        let mut src = \"[\\n\".to_string();\n-        for _ in 0..500 {\n-            src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n-                            [1,2,3]},\"#);\n-        }\n-        src.push_str(\"{}]\");\n-        return src;\n-    }\n-\n-    #[bench]\n-    fn bench_streaming_large(b: &mut Bencher) {\n-        let src = big_json();\n-        b.iter( || {\n-            let mut parser = Parser::new(src.chars());\n-            loop {\n-                match parser.next() {\n-                    None => return,\n-                    _ => {}\n-                }\n-            }\n-        });\n-    }\n-    #[bench]\n-    fn bench_large(b: &mut Bencher) {\n-        let src = big_json();\n-        b.iter( || { let _ = from_str(&src); });\n-    }\n-}\n+mod tests;"}, {"sha": "a16b8bdd787043efaec62d2245f04f0944d4ad97", "filename": "src/libserialize/json/tests.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibserialize%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibserialize%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,134 @@\n+// Benchmarks and tests that require private items\n+\n+extern crate test;\n+use test::Bencher;\n+use super::{from_str, Parser, StackElement, Stack};\n+use std::string;\n+\n+#[test]\n+fn test_stack() {\n+    let mut stack = Stack::new();\n+\n+    assert!(stack.is_empty());\n+    assert!(stack.is_empty());\n+    assert!(!stack.last_is_index());\n+\n+    stack.push_index(0);\n+    stack.bump_index();\n+\n+    assert!(stack.len() == 1);\n+    assert!(stack.is_equal_to(&[StackElement::Index(1)]));\n+    assert!(stack.starts_with(&[StackElement::Index(1)]));\n+    assert!(stack.ends_with(&[StackElement::Index(1)]));\n+    assert!(stack.last_is_index());\n+    assert!(stack.get(0) == StackElement::Index(1));\n+\n+    stack.push_key(\"foo\".to_string());\n+\n+    assert!(stack.len() == 2);\n+    assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+    assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+    assert!(stack.starts_with(&[StackElement::Index(1)]));\n+    assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+    assert!(stack.ends_with(&[StackElement::Key(\"foo\")]));\n+    assert!(!stack.last_is_index());\n+    assert!(stack.get(0) == StackElement::Index(1));\n+    assert!(stack.get(1) == StackElement::Key(\"foo\"));\n+\n+    stack.push_key(\"bar\".to_string());\n+\n+    assert!(stack.len() == 3);\n+    assert!(stack.is_equal_to(&[StackElement::Index(1),\n+                                StackElement::Key(\"foo\"),\n+                                StackElement::Key(\"bar\")]));\n+    assert!(stack.starts_with(&[StackElement::Index(1)]));\n+    assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+    assert!(stack.starts_with(&[StackElement::Index(1),\n+                                StackElement::Key(\"foo\"),\n+                                StackElement::Key(\"bar\")]));\n+    assert!(stack.ends_with(&[StackElement::Key(\"bar\")]));\n+    assert!(stack.ends_with(&[StackElement::Key(\"foo\"), StackElement::Key(\"bar\")]));\n+    assert!(stack.ends_with(&[StackElement::Index(1),\n+                              StackElement::Key(\"foo\"),\n+                              StackElement::Key(\"bar\")]));\n+    assert!(!stack.last_is_index());\n+    assert!(stack.get(0) == StackElement::Index(1));\n+    assert!(stack.get(1) == StackElement::Key(\"foo\"));\n+    assert!(stack.get(2) == StackElement::Key(\"bar\"));\n+\n+    stack.pop();\n+\n+    assert!(stack.len() == 2);\n+    assert!(stack.is_equal_to(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+    assert!(stack.starts_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+    assert!(stack.starts_with(&[StackElement::Index(1)]));\n+    assert!(stack.ends_with(&[StackElement::Index(1), StackElement::Key(\"foo\")]));\n+    assert!(stack.ends_with(&[StackElement::Key(\"foo\")]));\n+    assert!(!stack.last_is_index());\n+    assert!(stack.get(0) == StackElement::Index(1));\n+    assert!(stack.get(1) == StackElement::Key(\"foo\"));\n+}\n+\n+#[bench]\n+fn bench_streaming_small(b: &mut Bencher) {\n+    b.iter( || {\n+        let mut parser = Parser::new(\n+            r#\"{\n+                \"a\": 1.0,\n+                \"b\": [\n+                    true,\n+                    \"foo\\nbar\",\n+                    { \"c\": {\"d\": null} }\n+                ]\n+            }\"#.chars()\n+        );\n+        loop {\n+            match parser.next() {\n+                None => return,\n+                _ => {}\n+            }\n+        }\n+    });\n+}\n+#[bench]\n+fn bench_small(b: &mut Bencher) {\n+    b.iter( || {\n+        let _ = from_str(r#\"{\n+            \"a\": 1.0,\n+            \"b\": [\n+                true,\n+                \"foo\\nbar\",\n+                { \"c\": {\"d\": null} }\n+            ]\n+        }\"#);\n+    });\n+}\n+\n+fn big_json() -> string::String {\n+    let mut src = \"[\\n\".to_string();\n+    for _ in 0..500 {\n+        src.push_str(r#\"{ \"a\": true, \"b\": null, \"c\":3.1415, \"d\": \"Hello world\", \"e\": \\\n+                        [1,2,3]},\"#);\n+    }\n+    src.push_str(\"{}]\");\n+    return src;\n+}\n+\n+#[bench]\n+fn bench_streaming_large(b: &mut Bencher) {\n+    let src = big_json();\n+    b.iter( || {\n+        let mut parser = Parser::new(src.chars());\n+        loop {\n+            match parser.next() {\n+                None => return,\n+                _ => {}\n+            }\n+        }\n+    });\n+}\n+#[bench]\n+fn bench_large(b: &mut Bencher) {\n+    let src = big_json();\n+    b.iter( || { let _ = from_str(&src); });\n+}"}, {"sha": "3d4f82764413a0021fd93b3dfb194b259ad18264", "filename": "src/libsyntax_ext/format_foreign.rs", "status": "modified", "additions": 2, "deletions": 215, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -605,159 +605,7 @@ pub mod printf {\n     }\n \n     #[cfg(test)]\n-    mod tests {\n-        use super::{\n-            Format as F,\n-            Num as N,\n-            Substitution as S,\n-            iter_subs,\n-            parse_next_substitution as pns,\n-        };\n-\n-        macro_rules! assert_eq_pnsat {\n-            ($lhs:expr, $rhs:expr) => {\n-                assert_eq!(\n-                    pns($lhs).and_then(|(s, _)| s.translate()),\n-                    $rhs.map(<String as From<&str>>::from)\n-                )\n-            };\n-        }\n-\n-        #[test]\n-        fn test_escape() {\n-            assert_eq!(pns(\"has no escapes\"), None);\n-            assert_eq!(pns(\"has no escapes, either %\"), None);\n-            assert_eq!(pns(\"*so* has a %% escape\"), Some((S::Escape,\" escape\")));\n-            assert_eq!(pns(\"%% leading escape\"), Some((S::Escape, \" leading escape\")));\n-            assert_eq!(pns(\"trailing escape %%\"), Some((S::Escape, \"\")));\n-        }\n-\n-        #[test]\n-        fn test_parse() {\n-            macro_rules! assert_pns_eq_sub {\n-                ($in_:expr, {\n-                    $param:expr, $flags:expr,\n-                    $width:expr, $prec:expr, $len:expr, $type_:expr,\n-                    $pos:expr,\n-                }) => {\n-                    assert_eq!(\n-                        pns(concat!($in_, \"!\")),\n-                        Some((\n-                            S::Format(F {\n-                                span: $in_,\n-                                parameter: $param,\n-                                flags: $flags,\n-                                width: $width,\n-                                precision: $prec,\n-                                length: $len,\n-                                type_: $type_,\n-                                position: syntax_pos::InnerSpan::new($pos.0, $pos.1),\n-                            }),\n-                            \"!\"\n-                        ))\n-                    )\n-                };\n-            }\n-\n-            assert_pns_eq_sub!(\"%!\",\n-                { None, \"\", None, None, None, \"!\", (0, 2), });\n-            assert_pns_eq_sub!(\"%c\",\n-                { None, \"\", None, None, None, \"c\", (0, 2), });\n-            assert_pns_eq_sub!(\"%s\",\n-                { None, \"\", None, None, None, \"s\", (0, 2), });\n-            assert_pns_eq_sub!(\"%06d\",\n-                { None, \"0\", Some(N::Num(6)), None, None, \"d\", (0, 4), });\n-            assert_pns_eq_sub!(\"%4.2f\",\n-                { None, \"\", Some(N::Num(4)), Some(N::Num(2)), None, \"f\", (0, 5), });\n-            assert_pns_eq_sub!(\"%#x\",\n-                { None, \"#\", None, None, None, \"x\", (0, 3), });\n-            assert_pns_eq_sub!(\"%-10s\",\n-                { None, \"-\", Some(N::Num(10)), None, None, \"s\", (0, 5), });\n-            assert_pns_eq_sub!(\"%*s\",\n-                { None, \"\", Some(N::Next), None, None, \"s\", (0, 3), });\n-            assert_pns_eq_sub!(\"%-10.*s\",\n-                { None, \"-\", Some(N::Num(10)), Some(N::Next), None, \"s\", (0, 7), });\n-            assert_pns_eq_sub!(\"%-*.*s\",\n-                { None, \"-\", Some(N::Next), Some(N::Next), None, \"s\", (0, 6), });\n-            assert_pns_eq_sub!(\"%.6i\",\n-                { None, \"\", None, Some(N::Num(6)), None, \"i\", (0, 4), });\n-            assert_pns_eq_sub!(\"%+i\",\n-                { None, \"+\", None, None, None, \"i\", (0, 3), });\n-            assert_pns_eq_sub!(\"%08X\",\n-                { None, \"0\", Some(N::Num(8)), None, None, \"X\", (0, 4), });\n-            assert_pns_eq_sub!(\"%lu\",\n-                { None, \"\", None, None, Some(\"l\"), \"u\", (0, 3), });\n-            assert_pns_eq_sub!(\"%Iu\",\n-                { None, \"\", None, None, Some(\"I\"), \"u\", (0, 3), });\n-            assert_pns_eq_sub!(\"%I32u\",\n-                { None, \"\", None, None, Some(\"I32\"), \"u\", (0, 5), });\n-            assert_pns_eq_sub!(\"%I64u\",\n-                { None, \"\", None, None, Some(\"I64\"), \"u\", (0, 5), });\n-            assert_pns_eq_sub!(\"%'d\",\n-                { None, \"'\", None, None, None, \"d\", (0, 3), });\n-            assert_pns_eq_sub!(\"%10s\",\n-                { None, \"\", Some(N::Num(10)), None, None, \"s\", (0, 4), });\n-            assert_pns_eq_sub!(\"%-10.10s\",\n-                { None, \"-\", Some(N::Num(10)), Some(N::Num(10)), None, \"s\", (0, 8), });\n-            assert_pns_eq_sub!(\"%1$d\",\n-                { Some(1), \"\", None, None, None, \"d\", (0, 4), });\n-            assert_pns_eq_sub!(\"%2$.*3$d\",\n-                { Some(2), \"\", None, Some(N::Arg(3)), None, \"d\", (0, 8), });\n-            assert_pns_eq_sub!(\"%1$*2$.*3$d\",\n-                { Some(1), \"\", Some(N::Arg(2)), Some(N::Arg(3)), None, \"d\", (0, 11), });\n-            assert_pns_eq_sub!(\"%-8ld\",\n-                { None, \"-\", Some(N::Num(8)), None, Some(\"l\"), \"d\", (0, 5), });\n-        }\n-\n-        #[test]\n-        fn test_iter() {\n-            let s = \"The %d'th word %% is: `%.*s` %!\\n\";\n-            let subs: Vec<_> = iter_subs(s, 0).map(|sub| sub.translate()).collect();\n-            assert_eq!(\n-                subs.iter().map(|ms| ms.as_ref().map(|s| &s[..])).collect::<Vec<_>>(),\n-                vec![Some(\"{}\"), None, Some(\"{:.*}\"), None]\n-            );\n-        }\n-\n-        /// Checks that the translations are what we expect.\n-        #[test]\n-        fn test_translation() {\n-            assert_eq_pnsat!(\"%c\", Some(\"{}\"));\n-            assert_eq_pnsat!(\"%d\", Some(\"{}\"));\n-            assert_eq_pnsat!(\"%u\", Some(\"{}\"));\n-            assert_eq_pnsat!(\"%x\", Some(\"{:x}\"));\n-            assert_eq_pnsat!(\"%X\", Some(\"{:X}\"));\n-            assert_eq_pnsat!(\"%e\", Some(\"{:e}\"));\n-            assert_eq_pnsat!(\"%E\", Some(\"{:E}\"));\n-            assert_eq_pnsat!(\"%f\", Some(\"{}\"));\n-            assert_eq_pnsat!(\"%g\", Some(\"{:e}\"));\n-            assert_eq_pnsat!(\"%G\", Some(\"{:E}\"));\n-            assert_eq_pnsat!(\"%s\", Some(\"{}\"));\n-            assert_eq_pnsat!(\"%p\", Some(\"{:p}\"));\n-\n-            assert_eq_pnsat!(\"%06d\",        Some(\"{:06}\"));\n-            assert_eq_pnsat!(\"%4.2f\",       Some(\"{:4.2}\"));\n-            assert_eq_pnsat!(\"%#x\",         Some(\"{:#x}\"));\n-            assert_eq_pnsat!(\"%-10s\",       Some(\"{:<10}\"));\n-            assert_eq_pnsat!(\"%*s\",         None);\n-            assert_eq_pnsat!(\"%-10.*s\",     Some(\"{:<10.*}\"));\n-            assert_eq_pnsat!(\"%-*.*s\",      None);\n-            assert_eq_pnsat!(\"%.6i\",        Some(\"{:06}\"));\n-            assert_eq_pnsat!(\"%+i\",         Some(\"{:+}\"));\n-            assert_eq_pnsat!(\"%08X\",        Some(\"{:08X}\"));\n-            assert_eq_pnsat!(\"%lu\",         Some(\"{}\"));\n-            assert_eq_pnsat!(\"%Iu\",         Some(\"{}\"));\n-            assert_eq_pnsat!(\"%I32u\",       Some(\"{}\"));\n-            assert_eq_pnsat!(\"%I64u\",       Some(\"{}\"));\n-            assert_eq_pnsat!(\"%'d\",         None);\n-            assert_eq_pnsat!(\"%10s\",        Some(\"{:>10}\"));\n-            assert_eq_pnsat!(\"%-10.10s\",    Some(\"{:<10.10}\"));\n-            assert_eq_pnsat!(\"%1$d\",        Some(\"{0}\"));\n-            assert_eq_pnsat!(\"%2$.*3$d\",    Some(\"{1:02$}\"));\n-            assert_eq_pnsat!(\"%1$*2$.*3$s\", Some(\"{0:>1$.2$}\"));\n-            assert_eq_pnsat!(\"%-8ld\",       Some(\"{:<8}\"));\n-        }\n-    }\n+    mod tests;\n }\n \n pub mod shell {\n@@ -899,68 +747,7 @@ pub mod shell {\n     }\n \n     #[cfg(test)]\n-    mod tests {\n-        use super::{\n-            Substitution as S,\n-            parse_next_substitution as pns,\n-        };\n-\n-        macro_rules! assert_eq_pnsat {\n-            ($lhs:expr, $rhs:expr) => {\n-                assert_eq!(\n-                    pns($lhs).and_then(|(f, _)| f.translate()),\n-                    $rhs.map(<String as From<&str>>::from)\n-                )\n-            };\n-        }\n-\n-        #[test]\n-        fn test_escape() {\n-            assert_eq!(pns(\"has no escapes\"), None);\n-            assert_eq!(pns(\"has no escapes, either $\"), None);\n-            assert_eq!(pns(\"*so* has a $$ escape\"), Some((S::Escape((11, 13)), \" escape\")));\n-            assert_eq!(pns(\"$$ leading escape\"), Some((S::Escape((0, 2)), \" leading escape\")));\n-            assert_eq!(pns(\"trailing escape $$\"), Some((S::Escape((16, 18)), \"\")));\n-        }\n-\n-        #[test]\n-        fn test_parse() {\n-            macro_rules! assert_pns_eq_sub {\n-                ($in_:expr, $kind:ident($arg:expr, $pos:expr)) => {\n-                    assert_eq!(pns(concat!($in_, \"!\")), Some((S::$kind($arg.into(), $pos), \"!\")))\n-                };\n-            }\n-\n-            assert_pns_eq_sub!(\"$0\", Ordinal(0, (0, 2)));\n-            assert_pns_eq_sub!(\"$1\", Ordinal(1, (0, 2)));\n-            assert_pns_eq_sub!(\"$9\", Ordinal(9, (0, 2)));\n-            assert_pns_eq_sub!(\"$N\", Name(\"N\", (0, 2)));\n-            assert_pns_eq_sub!(\"$NAME\", Name(\"NAME\", (0, 5)));\n-        }\n-\n-        #[test]\n-        fn test_iter() {\n-            use super::iter_subs;\n-            let s = \"The $0'th word $$ is: `$WORD` $!\\n\";\n-            let subs: Vec<_> = iter_subs(s, 0).map(|sub| sub.translate()).collect();\n-            assert_eq!(\n-                subs.iter().map(|ms| ms.as_ref().map(|s| &s[..])).collect::<Vec<_>>(),\n-                vec![Some(\"{0}\"), None, Some(\"{WORD}\")]\n-            );\n-        }\n-\n-        #[test]\n-        fn test_translation() {\n-            assert_eq_pnsat!(\"$0\", Some(\"{0}\"));\n-            assert_eq_pnsat!(\"$9\", Some(\"{9}\"));\n-            assert_eq_pnsat!(\"$1\", Some(\"{1}\"));\n-            assert_eq_pnsat!(\"$10\", Some(\"{1}\"));\n-            assert_eq_pnsat!(\"$stuff\", Some(\"{stuff}\"));\n-            assert_eq_pnsat!(\"$NAME\", Some(\"{NAME}\"));\n-            assert_eq_pnsat!(\"$PREFIX/bin\", Some(\"{PREFIX}\"));\n-        }\n-\n-    }\n+    mod tests;\n }\n \n mod strcursor {"}, {"sha": "87021f1ef5a52857e55023624abb719b71b2113e", "filename": "src/libsyntax_ext/format_foreign/printf/tests.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibsyntax_ext%2Fformat_foreign%2Fprintf%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibsyntax_ext%2Fformat_foreign%2Fprintf%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign%2Fprintf%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,151 @@\n+use super::{\n+    Format as F,\n+    Num as N,\n+    Substitution as S,\n+    iter_subs,\n+    parse_next_substitution as pns,\n+};\n+\n+macro_rules! assert_eq_pnsat {\n+    ($lhs:expr, $rhs:expr) => {\n+        assert_eq!(\n+            pns($lhs).and_then(|(s, _)| s.translate()),\n+            $rhs.map(<String as From<&str>>::from)\n+        )\n+    };\n+}\n+\n+#[test]\n+fn test_escape() {\n+    assert_eq!(pns(\"has no escapes\"), None);\n+    assert_eq!(pns(\"has no escapes, either %\"), None);\n+    assert_eq!(pns(\"*so* has a %% escape\"), Some((S::Escape,\" escape\")));\n+    assert_eq!(pns(\"%% leading escape\"), Some((S::Escape, \" leading escape\")));\n+    assert_eq!(pns(\"trailing escape %%\"), Some((S::Escape, \"\")));\n+}\n+\n+#[test]\n+fn test_parse() {\n+    macro_rules! assert_pns_eq_sub {\n+        ($in_:expr, {\n+            $param:expr, $flags:expr,\n+            $width:expr, $prec:expr, $len:expr, $type_:expr,\n+            $pos:expr,\n+        }) => {\n+            assert_eq!(\n+                pns(concat!($in_, \"!\")),\n+                Some((\n+                    S::Format(F {\n+                        span: $in_,\n+                        parameter: $param,\n+                        flags: $flags,\n+                        width: $width,\n+                        precision: $prec,\n+                        length: $len,\n+                        type_: $type_,\n+                        position: syntax_pos::InnerSpan::new($pos.0, $pos.1),\n+                    }),\n+                    \"!\"\n+                ))\n+            )\n+        };\n+    }\n+\n+    assert_pns_eq_sub!(\"%!\",\n+        { None, \"\", None, None, None, \"!\", (0, 2), });\n+    assert_pns_eq_sub!(\"%c\",\n+        { None, \"\", None, None, None, \"c\", (0, 2), });\n+    assert_pns_eq_sub!(\"%s\",\n+        { None, \"\", None, None, None, \"s\", (0, 2), });\n+    assert_pns_eq_sub!(\"%06d\",\n+        { None, \"0\", Some(N::Num(6)), None, None, \"d\", (0, 4), });\n+    assert_pns_eq_sub!(\"%4.2f\",\n+        { None, \"\", Some(N::Num(4)), Some(N::Num(2)), None, \"f\", (0, 5), });\n+    assert_pns_eq_sub!(\"%#x\",\n+        { None, \"#\", None, None, None, \"x\", (0, 3), });\n+    assert_pns_eq_sub!(\"%-10s\",\n+        { None, \"-\", Some(N::Num(10)), None, None, \"s\", (0, 5), });\n+    assert_pns_eq_sub!(\"%*s\",\n+        { None, \"\", Some(N::Next), None, None, \"s\", (0, 3), });\n+    assert_pns_eq_sub!(\"%-10.*s\",\n+        { None, \"-\", Some(N::Num(10)), Some(N::Next), None, \"s\", (0, 7), });\n+    assert_pns_eq_sub!(\"%-*.*s\",\n+        { None, \"-\", Some(N::Next), Some(N::Next), None, \"s\", (0, 6), });\n+    assert_pns_eq_sub!(\"%.6i\",\n+        { None, \"\", None, Some(N::Num(6)), None, \"i\", (0, 4), });\n+    assert_pns_eq_sub!(\"%+i\",\n+        { None, \"+\", None, None, None, \"i\", (0, 3), });\n+    assert_pns_eq_sub!(\"%08X\",\n+        { None, \"0\", Some(N::Num(8)), None, None, \"X\", (0, 4), });\n+    assert_pns_eq_sub!(\"%lu\",\n+        { None, \"\", None, None, Some(\"l\"), \"u\", (0, 3), });\n+    assert_pns_eq_sub!(\"%Iu\",\n+        { None, \"\", None, None, Some(\"I\"), \"u\", (0, 3), });\n+    assert_pns_eq_sub!(\"%I32u\",\n+        { None, \"\", None, None, Some(\"I32\"), \"u\", (0, 5), });\n+    assert_pns_eq_sub!(\"%I64u\",\n+        { None, \"\", None, None, Some(\"I64\"), \"u\", (0, 5), });\n+    assert_pns_eq_sub!(\"%'d\",\n+        { None, \"'\", None, None, None, \"d\", (0, 3), });\n+    assert_pns_eq_sub!(\"%10s\",\n+        { None, \"\", Some(N::Num(10)), None, None, \"s\", (0, 4), });\n+    assert_pns_eq_sub!(\"%-10.10s\",\n+        { None, \"-\", Some(N::Num(10)), Some(N::Num(10)), None, \"s\", (0, 8), });\n+    assert_pns_eq_sub!(\"%1$d\",\n+        { Some(1), \"\", None, None, None, \"d\", (0, 4), });\n+    assert_pns_eq_sub!(\"%2$.*3$d\",\n+        { Some(2), \"\", None, Some(N::Arg(3)), None, \"d\", (0, 8), });\n+    assert_pns_eq_sub!(\"%1$*2$.*3$d\",\n+        { Some(1), \"\", Some(N::Arg(2)), Some(N::Arg(3)), None, \"d\", (0, 11), });\n+    assert_pns_eq_sub!(\"%-8ld\",\n+        { None, \"-\", Some(N::Num(8)), None, Some(\"l\"), \"d\", (0, 5), });\n+}\n+\n+#[test]\n+fn test_iter() {\n+    let s = \"The %d'th word %% is: `%.*s` %!\\n\";\n+    let subs: Vec<_> = iter_subs(s, 0).map(|sub| sub.translate()).collect();\n+    assert_eq!(\n+        subs.iter().map(|ms| ms.as_ref().map(|s| &s[..])).collect::<Vec<_>>(),\n+        vec![Some(\"{}\"), None, Some(\"{:.*}\"), None]\n+    );\n+}\n+\n+/// Checks that the translations are what we expect.\n+#[test]\n+fn test_translation() {\n+    assert_eq_pnsat!(\"%c\", Some(\"{}\"));\n+    assert_eq_pnsat!(\"%d\", Some(\"{}\"));\n+    assert_eq_pnsat!(\"%u\", Some(\"{}\"));\n+    assert_eq_pnsat!(\"%x\", Some(\"{:x}\"));\n+    assert_eq_pnsat!(\"%X\", Some(\"{:X}\"));\n+    assert_eq_pnsat!(\"%e\", Some(\"{:e}\"));\n+    assert_eq_pnsat!(\"%E\", Some(\"{:E}\"));\n+    assert_eq_pnsat!(\"%f\", Some(\"{}\"));\n+    assert_eq_pnsat!(\"%g\", Some(\"{:e}\"));\n+    assert_eq_pnsat!(\"%G\", Some(\"{:E}\"));\n+    assert_eq_pnsat!(\"%s\", Some(\"{}\"));\n+    assert_eq_pnsat!(\"%p\", Some(\"{:p}\"));\n+\n+    assert_eq_pnsat!(\"%06d\",        Some(\"{:06}\"));\n+    assert_eq_pnsat!(\"%4.2f\",       Some(\"{:4.2}\"));\n+    assert_eq_pnsat!(\"%#x\",         Some(\"{:#x}\"));\n+    assert_eq_pnsat!(\"%-10s\",       Some(\"{:<10}\"));\n+    assert_eq_pnsat!(\"%*s\",         None);\n+    assert_eq_pnsat!(\"%-10.*s\",     Some(\"{:<10.*}\"));\n+    assert_eq_pnsat!(\"%-*.*s\",      None);\n+    assert_eq_pnsat!(\"%.6i\",        Some(\"{:06}\"));\n+    assert_eq_pnsat!(\"%+i\",         Some(\"{:+}\"));\n+    assert_eq_pnsat!(\"%08X\",        Some(\"{:08X}\"));\n+    assert_eq_pnsat!(\"%lu\",         Some(\"{}\"));\n+    assert_eq_pnsat!(\"%Iu\",         Some(\"{}\"));\n+    assert_eq_pnsat!(\"%I32u\",       Some(\"{}\"));\n+    assert_eq_pnsat!(\"%I64u\",       Some(\"{}\"));\n+    assert_eq_pnsat!(\"%'d\",         None);\n+    assert_eq_pnsat!(\"%10s\",        Some(\"{:>10}\"));\n+    assert_eq_pnsat!(\"%-10.10s\",    Some(\"{:<10.10}\"));\n+    assert_eq_pnsat!(\"%1$d\",        Some(\"{0}\"));\n+    assert_eq_pnsat!(\"%2$.*3$d\",    Some(\"{1:02$}\"));\n+    assert_eq_pnsat!(\"%1$*2$.*3$s\", Some(\"{0:>1$.2$}\"));\n+    assert_eq_pnsat!(\"%-8ld\",       Some(\"{:<8}\"));\n+}"}, {"sha": "8ef58b8387e5a5f9cedcf24bd26ed9dc99e0020d", "filename": "src/libsyntax_ext/format_foreign/shell/tests.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibsyntax_ext%2Fformat_foreign%2Fshell%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibsyntax_ext%2Fformat_foreign%2Fshell%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign%2Fshell%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,59 @@\n+use super::{\n+    Substitution as S,\n+    parse_next_substitution as pns,\n+};\n+\n+macro_rules! assert_eq_pnsat {\n+    ($lhs:expr, $rhs:expr) => {\n+        assert_eq!(\n+            pns($lhs).and_then(|(f, _)| f.translate()),\n+            $rhs.map(<String as From<&str>>::from)\n+        )\n+    };\n+}\n+\n+#[test]\n+fn test_escape() {\n+    assert_eq!(pns(\"has no escapes\"), None);\n+    assert_eq!(pns(\"has no escapes, either $\"), None);\n+    assert_eq!(pns(\"*so* has a $$ escape\"), Some((S::Escape((11, 13)), \" escape\")));\n+    assert_eq!(pns(\"$$ leading escape\"), Some((S::Escape((0, 2)), \" leading escape\")));\n+    assert_eq!(pns(\"trailing escape $$\"), Some((S::Escape((16, 18)), \"\")));\n+}\n+\n+#[test]\n+fn test_parse() {\n+    macro_rules! assert_pns_eq_sub {\n+        ($in_:expr, $kind:ident($arg:expr, $pos:expr)) => {\n+            assert_eq!(pns(concat!($in_, \"!\")), Some((S::$kind($arg.into(), $pos), \"!\")))\n+        };\n+    }\n+\n+    assert_pns_eq_sub!(\"$0\", Ordinal(0, (0, 2)));\n+    assert_pns_eq_sub!(\"$1\", Ordinal(1, (0, 2)));\n+    assert_pns_eq_sub!(\"$9\", Ordinal(9, (0, 2)));\n+    assert_pns_eq_sub!(\"$N\", Name(\"N\", (0, 2)));\n+    assert_pns_eq_sub!(\"$NAME\", Name(\"NAME\", (0, 5)));\n+}\n+\n+#[test]\n+fn test_iter() {\n+    use super::iter_subs;\n+    let s = \"The $0'th word $$ is: `$WORD` $!\\n\";\n+    let subs: Vec<_> = iter_subs(s, 0).map(|sub| sub.translate()).collect();\n+    assert_eq!(\n+        subs.iter().map(|ms| ms.as_ref().map(|s| &s[..])).collect::<Vec<_>>(),\n+        vec![Some(\"{0}\"), None, Some(\"{WORD}\")]\n+    );\n+}\n+\n+#[test]\n+fn test_translation() {\n+    assert_eq_pnsat!(\"$0\", Some(\"{0}\"));\n+    assert_eq_pnsat!(\"$9\", Some(\"{9}\"));\n+    assert_eq_pnsat!(\"$1\", Some(\"{1}\"));\n+    assert_eq_pnsat!(\"$10\", Some(\"{1}\"));\n+    assert_eq_pnsat!(\"$stuff\", Some(\"{stuff}\"));\n+    assert_eq_pnsat!(\"$NAME\", Some(\"{NAME}\"));\n+    assert_eq_pnsat!(\"$PREFIX/bin\", Some(\"{PREFIX}\"));\n+}"}, {"sha": "53bf67bdf671f181db9378d731fa0990a0403ead", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 455, "changes": 456, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -1772,458 +1772,4 @@ pub mod bench {\n }\n \n #[cfg(test)]\n-mod tests {\n-    use crate::bench;\n-    use crate::test::{\n-        filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n-        ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n-        TrIgnored, TrOk,\n-    };\n-    use crate::Bencher;\n-    use crate::Concurrent;\n-    use std::sync::mpsc::channel;\n-\n-    fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n-        vec![\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"1\"),\n-                    ignore: true,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {})),\n-            },\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"2\"),\n-                    ignore: false,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {})),\n-            },\n-        ]\n-    }\n-\n-    #[test]\n-    pub fn do_not_run_ignored_tests() {\n-        fn f() {\n-            panic!();\n-        }\n-        let desc = TestDescAndFn {\n-            desc: TestDesc {\n-                name: StaticTestName(\"whatever\"),\n-                ignore: true,\n-                should_panic: ShouldPanic::No,\n-                allow_fail: false,\n-            },\n-            testfn: DynTestFn(Box::new(f)),\n-        };\n-        let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-        let (_, res, _) = rx.recv().unwrap();\n-        assert!(res != TrOk);\n-    }\n-\n-    #[test]\n-    pub fn ignored_tests_result_in_ignored() {\n-        fn f() {}\n-        let desc = TestDescAndFn {\n-            desc: TestDesc {\n-                name: StaticTestName(\"whatever\"),\n-                ignore: true,\n-                should_panic: ShouldPanic::No,\n-                allow_fail: false,\n-            },\n-            testfn: DynTestFn(Box::new(f)),\n-        };\n-        let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-        let (_, res, _) = rx.recv().unwrap();\n-        assert!(res == TrIgnored);\n-    }\n-\n-    #[test]\n-    fn test_should_panic() {\n-        fn f() {\n-            panic!();\n-        }\n-        let desc = TestDescAndFn {\n-            desc: TestDesc {\n-                name: StaticTestName(\"whatever\"),\n-                ignore: false,\n-                should_panic: ShouldPanic::Yes,\n-                allow_fail: false,\n-            },\n-            testfn: DynTestFn(Box::new(f)),\n-        };\n-        let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-        let (_, res, _) = rx.recv().unwrap();\n-        assert!(res == TrOk);\n-    }\n-\n-    #[test]\n-    fn test_should_panic_good_message() {\n-        fn f() {\n-            panic!(\"an error message\");\n-        }\n-        let desc = TestDescAndFn {\n-            desc: TestDesc {\n-                name: StaticTestName(\"whatever\"),\n-                ignore: false,\n-                should_panic: ShouldPanic::YesWithMessage(\"error message\"),\n-                allow_fail: false,\n-            },\n-            testfn: DynTestFn(Box::new(f)),\n-        };\n-        let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-        let (_, res, _) = rx.recv().unwrap();\n-        assert!(res == TrOk);\n-    }\n-\n-    #[test]\n-    fn test_should_panic_bad_message() {\n-        fn f() {\n-            panic!(\"an error message\");\n-        }\n-        let expected = \"foobar\";\n-        let failed_msg = \"panic did not include expected string\";\n-        let desc = TestDescAndFn {\n-            desc: TestDesc {\n-                name: StaticTestName(\"whatever\"),\n-                ignore: false,\n-                should_panic: ShouldPanic::YesWithMessage(expected),\n-                allow_fail: false,\n-            },\n-            testfn: DynTestFn(Box::new(f)),\n-        };\n-        let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-        let (_, res, _) = rx.recv().unwrap();\n-        assert!(res == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n-    }\n-\n-    #[test]\n-    fn test_should_panic_but_succeeds() {\n-        fn f() {}\n-        let desc = TestDescAndFn {\n-            desc: TestDesc {\n-                name: StaticTestName(\"whatever\"),\n-                ignore: false,\n-                should_panic: ShouldPanic::Yes,\n-                allow_fail: false,\n-            },\n-            testfn: DynTestFn(Box::new(f)),\n-        };\n-        let (tx, rx) = channel();\n-        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n-        let (_, res, _) = rx.recv().unwrap();\n-        assert!(res == TrFailed);\n-    }\n-\n-    #[test]\n-    fn parse_ignored_flag() {\n-        let args = vec![\n-            \"progname\".to_string(),\n-            \"filter\".to_string(),\n-            \"--ignored\".to_string(),\n-        ];\n-        let opts = parse_opts(&args).unwrap().unwrap();\n-        assert_eq!(opts.run_ignored, RunIgnored::Only);\n-    }\n-\n-    #[test]\n-    fn parse_include_ignored_flag() {\n-        let args = vec![\n-            \"progname\".to_string(),\n-            \"filter\".to_string(),\n-            \"-Zunstable-options\".to_string(),\n-            \"--include-ignored\".to_string(),\n-        ];\n-        let opts = parse_opts(&args).unwrap().unwrap();\n-        assert_eq!(opts.run_ignored, RunIgnored::Yes);\n-    }\n-\n-    #[test]\n-    pub fn filter_for_ignored_option() {\n-        // When we run ignored tests the test filter should filter out all the\n-        // unignored tests and flip the ignore flag on the rest to false\n-\n-        let mut opts = TestOpts::new();\n-        opts.run_tests = true;\n-        opts.run_ignored = RunIgnored::Only;\n-\n-        let tests = one_ignored_one_unignored_test();\n-        let filtered = filter_tests(&opts, tests);\n-\n-        assert_eq!(filtered.len(), 1);\n-        assert_eq!(filtered[0].desc.name.to_string(), \"1\");\n-        assert!(!filtered[0].desc.ignore);\n-    }\n-\n-    #[test]\n-    pub fn run_include_ignored_option() {\n-        // When we \"--include-ignored\" tests, the ignore flag should be set to false on\n-        // all tests and no test filtered out\n-\n-        let mut opts = TestOpts::new();\n-        opts.run_tests = true;\n-        opts.run_ignored = RunIgnored::Yes;\n-\n-        let tests = one_ignored_one_unignored_test();\n-        let filtered = filter_tests(&opts, tests);\n-\n-        assert_eq!(filtered.len(), 2);\n-        assert!(!filtered[0].desc.ignore);\n-        assert!(!filtered[1].desc.ignore);\n-    }\n-\n-    #[test]\n-    pub fn exclude_should_panic_option() {\n-        let mut opts = TestOpts::new();\n-        opts.run_tests = true;\n-        opts.exclude_should_panic = true;\n-\n-        let mut tests = one_ignored_one_unignored_test();\n-        tests.push(TestDescAndFn {\n-            desc: TestDesc {\n-                name: StaticTestName(\"3\"),\n-                ignore: false,\n-                should_panic: ShouldPanic::Yes,\n-                allow_fail: false,\n-            },\n-            testfn: DynTestFn(Box::new(move || {})),\n-        });\n-\n-        let filtered = filter_tests(&opts, tests);\n-\n-        assert_eq!(filtered.len(), 2);\n-        assert!(filtered.iter().all(|test| test.desc.should_panic == ShouldPanic::No));\n-    }\n-\n-    #[test]\n-    pub fn exact_filter_match() {\n-        fn tests() -> Vec<TestDescAndFn> {\n-            vec![\"base\", \"base::test\", \"base::test1\", \"base::test2\"]\n-                .into_iter()\n-                .map(|name| TestDescAndFn {\n-                    desc: TestDesc {\n-                        name: StaticTestName(name),\n-                        ignore: false,\n-                        should_panic: ShouldPanic::No,\n-                        allow_fail: false,\n-                    },\n-                    testfn: DynTestFn(Box::new(move || {})),\n-                })\n-                .collect()\n-        }\n-\n-        let substr = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"base\".into()),\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(substr.len(), 4);\n-\n-        let substr = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"bas\".into()),\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(substr.len(), 4);\n-\n-        let substr = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"::test\".into()),\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(substr.len(), 3);\n-\n-        let substr = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"base::test\".into()),\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(substr.len(), 3);\n-\n-        let exact = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"base\".into()),\n-                filter_exact: true,\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(exact.len(), 1);\n-\n-        let exact = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"bas\".into()),\n-                filter_exact: true,\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(exact.len(), 0);\n-\n-        let exact = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"::test\".into()),\n-                filter_exact: true,\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(exact.len(), 0);\n-\n-        let exact = filter_tests(\n-            &TestOpts {\n-                filter: Some(\"base::test\".into()),\n-                filter_exact: true,\n-                ..TestOpts::new()\n-            },\n-            tests(),\n-        );\n-        assert_eq!(exact.len(), 1);\n-    }\n-\n-    #[test]\n-    pub fn sort_tests() {\n-        let mut opts = TestOpts::new();\n-        opts.run_tests = true;\n-\n-        let names = vec![\n-            \"sha1::test\".to_string(),\n-            \"isize::test_to_str\".to_string(),\n-            \"isize::test_pow\".to_string(),\n-            \"test::do_not_run_ignored_tests\".to_string(),\n-            \"test::ignored_tests_result_in_ignored\".to_string(),\n-            \"test::first_free_arg_should_be_a_filter\".to_string(),\n-            \"test::parse_ignored_flag\".to_string(),\n-            \"test::parse_include_ignored_flag\".to_string(),\n-            \"test::filter_for_ignored_option\".to_string(),\n-            \"test::run_include_ignored_option\".to_string(),\n-            \"test::sort_tests\".to_string(),\n-        ];\n-        let tests = {\n-            fn testfn() {}\n-            let mut tests = Vec::new();\n-            for name in &names {\n-                let test = TestDescAndFn {\n-                    desc: TestDesc {\n-                        name: DynTestName((*name).clone()),\n-                        ignore: false,\n-                        should_panic: ShouldPanic::No,\n-                        allow_fail: false,\n-                    },\n-                    testfn: DynTestFn(Box::new(testfn)),\n-                };\n-                tests.push(test);\n-            }\n-            tests\n-        };\n-        let filtered = filter_tests(&opts, tests);\n-\n-        let expected = vec![\n-            \"isize::test_pow\".to_string(),\n-            \"isize::test_to_str\".to_string(),\n-            \"sha1::test\".to_string(),\n-            \"test::do_not_run_ignored_tests\".to_string(),\n-            \"test::filter_for_ignored_option\".to_string(),\n-            \"test::first_free_arg_should_be_a_filter\".to_string(),\n-            \"test::ignored_tests_result_in_ignored\".to_string(),\n-            \"test::parse_ignored_flag\".to_string(),\n-            \"test::parse_include_ignored_flag\".to_string(),\n-            \"test::run_include_ignored_option\".to_string(),\n-            \"test::sort_tests\".to_string(),\n-        ];\n-\n-        for (a, b) in expected.iter().zip(filtered) {\n-            assert!(*a == b.desc.name.to_string());\n-        }\n-    }\n-\n-    #[test]\n-    pub fn test_metricmap_compare() {\n-        let mut m1 = MetricMap::new();\n-        let mut m2 = MetricMap::new();\n-        m1.insert_metric(\"in-both-noise\", 1000.0, 200.0);\n-        m2.insert_metric(\"in-both-noise\", 1100.0, 200.0);\n-\n-        m1.insert_metric(\"in-first-noise\", 1000.0, 2.0);\n-        m2.insert_metric(\"in-second-noise\", 1000.0, 2.0);\n-\n-        m1.insert_metric(\"in-both-want-downwards-but-regressed\", 1000.0, 10.0);\n-        m2.insert_metric(\"in-both-want-downwards-but-regressed\", 2000.0, 10.0);\n-\n-        m1.insert_metric(\"in-both-want-downwards-and-improved\", 2000.0, 10.0);\n-        m2.insert_metric(\"in-both-want-downwards-and-improved\", 1000.0, 10.0);\n-\n-        m1.insert_metric(\"in-both-want-upwards-but-regressed\", 2000.0, -10.0);\n-        m2.insert_metric(\"in-both-want-upwards-but-regressed\", 1000.0, -10.0);\n-\n-        m1.insert_metric(\"in-both-want-upwards-and-improved\", 1000.0, -10.0);\n-        m2.insert_metric(\"in-both-want-upwards-and-improved\", 2000.0, -10.0);\n-    }\n-\n-    #[test]\n-    pub fn test_bench_once_no_iter() {\n-        fn f(_: &mut Bencher) {}\n-        bench::run_once(f);\n-    }\n-\n-    #[test]\n-    pub fn test_bench_once_iter() {\n-        fn f(b: &mut Bencher) {\n-            b.iter(|| {})\n-        }\n-        bench::run_once(f);\n-    }\n-\n-    #[test]\n-    pub fn test_bench_no_iter() {\n-        fn f(_: &mut Bencher) {}\n-\n-        let (tx, rx) = channel();\n-\n-        let desc = TestDesc {\n-            name: StaticTestName(\"f\"),\n-            ignore: false,\n-            should_panic: ShouldPanic::No,\n-            allow_fail: false,\n-        };\n-\n-        crate::bench::benchmark(desc, tx, true, f);\n-        rx.recv().unwrap();\n-    }\n-\n-    #[test]\n-    pub fn test_bench_iter() {\n-        fn f(b: &mut Bencher) {\n-            b.iter(|| {})\n-        }\n-\n-        let (tx, rx) = channel();\n-\n-        let desc = TestDesc {\n-            name: StaticTestName(\"f\"),\n-            ignore: false,\n-            should_panic: ShouldPanic::No,\n-            allow_fail: false,\n-        };\n-\n-        crate::bench::benchmark(desc, tx, true, f);\n-        rx.recv().unwrap();\n-    }\n-}\n+mod tests;"}, {"sha": "32c30061983aba7482b20b3d093611a293fbfad8", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 576, "changes": 577, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -318,582 +318,7 @@ pub fn winsorize(samples: &mut [f64], pct: f64) {\n // Test vectors generated from R, using the script src/etc/stat-test-vectors.r.\n \n #[cfg(test)]\n-mod tests {\n-    use crate::stats::Stats;\n-    use crate::stats::Summary;\n-    use std::f64;\n-    use std::io::prelude::*;\n-    use std::io;\n-\n-    macro_rules! assert_approx_eq {\n-        ($a: expr, $b: expr) => {{\n-            let (a, b) = (&$a, &$b);\n-            assert!(\n-                (*a - *b).abs() < 1.0e-6,\n-                \"{} is not approximately equal to {}\",\n-                *a,\n-                *b\n-            );\n-        }};\n-    }\n-\n-    fn check(samples: &[f64], summ: &Summary) {\n-        let summ2 = Summary::new(samples);\n-\n-        let mut w = io::sink();\n-        let w = &mut w;\n-        (write!(w, \"\\n\")).unwrap();\n-\n-        assert_eq!(summ.sum, summ2.sum);\n-        assert_eq!(summ.min, summ2.min);\n-        assert_eq!(summ.max, summ2.max);\n-        assert_eq!(summ.mean, summ2.mean);\n-        assert_eq!(summ.median, summ2.median);\n-\n-        // We needed a few more digits to get exact equality on these\n-        // but they're within float epsilon, which is 1.0e-6.\n-        assert_approx_eq!(summ.var, summ2.var);\n-        assert_approx_eq!(summ.std_dev, summ2.std_dev);\n-        assert_approx_eq!(summ.std_dev_pct, summ2.std_dev_pct);\n-        assert_approx_eq!(summ.median_abs_dev, summ2.median_abs_dev);\n-        assert_approx_eq!(summ.median_abs_dev_pct, summ2.median_abs_dev_pct);\n-\n-        assert_eq!(summ.quartiles, summ2.quartiles);\n-        assert_eq!(summ.iqr, summ2.iqr);\n-    }\n-\n-    #[test]\n-    fn test_min_max_nan() {\n-        let xs = &[1.0, 2.0, f64::NAN, 3.0, 4.0];\n-        let summary = Summary::new(xs);\n-        assert_eq!(summary.min, 1.0);\n-        assert_eq!(summary.max, 4.0);\n-    }\n-\n-    #[test]\n-    fn test_norm2() {\n-        let val = &[958.0000000000, 924.0000000000];\n-        let summ = &Summary {\n-            sum: 1882.0000000000,\n-            min: 924.0000000000,\n-            max: 958.0000000000,\n-            mean: 941.0000000000,\n-            median: 941.0000000000,\n-            var: 578.0000000000,\n-            std_dev: 24.0416305603,\n-            std_dev_pct: 2.5549022912,\n-            median_abs_dev: 25.2042000000,\n-            median_abs_dev_pct: 2.6784484591,\n-            quartiles: (932.5000000000, 941.0000000000, 949.5000000000),\n-            iqr: 17.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_norm10narrow() {\n-        let val = &[\n-            966.0000000000,\n-            985.0000000000,\n-            1110.0000000000,\n-            848.0000000000,\n-            821.0000000000,\n-            975.0000000000,\n-            962.0000000000,\n-            1157.0000000000,\n-            1217.0000000000,\n-            955.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 9996.0000000000,\n-            min: 821.0000000000,\n-            max: 1217.0000000000,\n-            mean: 999.6000000000,\n-            median: 970.5000000000,\n-            var: 16050.7111111111,\n-            std_dev: 126.6914010938,\n-            std_dev_pct: 12.6742097933,\n-            median_abs_dev: 102.2994000000,\n-            median_abs_dev_pct: 10.5408964451,\n-            quartiles: (956.7500000000, 970.5000000000, 1078.7500000000),\n-            iqr: 122.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_norm10medium() {\n-        let val = &[\n-            954.0000000000,\n-            1064.0000000000,\n-            855.0000000000,\n-            1000.0000000000,\n-            743.0000000000,\n-            1084.0000000000,\n-            704.0000000000,\n-            1023.0000000000,\n-            357.0000000000,\n-            869.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 8653.0000000000,\n-            min: 357.0000000000,\n-            max: 1084.0000000000,\n-            mean: 865.3000000000,\n-            median: 911.5000000000,\n-            var: 48628.4555555556,\n-            std_dev: 220.5186059170,\n-            std_dev_pct: 25.4846418487,\n-            median_abs_dev: 195.7032000000,\n-            median_abs_dev_pct: 21.4704552935,\n-            quartiles: (771.0000000000, 911.5000000000, 1017.2500000000),\n-            iqr: 246.2500000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_norm10wide() {\n-        let val = &[\n-            505.0000000000,\n-            497.0000000000,\n-            1591.0000000000,\n-            887.0000000000,\n-            1026.0000000000,\n-            136.0000000000,\n-            1580.0000000000,\n-            940.0000000000,\n-            754.0000000000,\n-            1433.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 9349.0000000000,\n-            min: 136.0000000000,\n-            max: 1591.0000000000,\n-            mean: 934.9000000000,\n-            median: 913.5000000000,\n-            var: 239208.9888888889,\n-            std_dev: 489.0899599142,\n-            std_dev_pct: 52.3146817750,\n-            median_abs_dev: 611.5725000000,\n-            median_abs_dev_pct: 66.9482758621,\n-            quartiles: (567.2500000000, 913.5000000000, 1331.2500000000),\n-            iqr: 764.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_norm25verynarrow() {\n-        let val = &[\n-            991.0000000000,\n-            1018.0000000000,\n-            998.0000000000,\n-            1013.0000000000,\n-            974.0000000000,\n-            1007.0000000000,\n-            1014.0000000000,\n-            999.0000000000,\n-            1011.0000000000,\n-            978.0000000000,\n-            985.0000000000,\n-            999.0000000000,\n-            983.0000000000,\n-            982.0000000000,\n-            1015.0000000000,\n-            1002.0000000000,\n-            977.0000000000,\n-            948.0000000000,\n-            1040.0000000000,\n-            974.0000000000,\n-            996.0000000000,\n-            989.0000000000,\n-            1015.0000000000,\n-            994.0000000000,\n-            1024.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 24926.0000000000,\n-            min: 948.0000000000,\n-            max: 1040.0000000000,\n-            mean: 997.0400000000,\n-            median: 998.0000000000,\n-            var: 393.2066666667,\n-            std_dev: 19.8294393937,\n-            std_dev_pct: 1.9888308788,\n-            median_abs_dev: 22.2390000000,\n-            median_abs_dev_pct: 2.2283567134,\n-            quartiles: (983.0000000000, 998.0000000000, 1013.0000000000),\n-            iqr: 30.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_exp10a() {\n-        let val = &[\n-            23.0000000000,\n-            11.0000000000,\n-            2.0000000000,\n-            57.0000000000,\n-            4.0000000000,\n-            12.0000000000,\n-            5.0000000000,\n-            29.0000000000,\n-            3.0000000000,\n-            21.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 167.0000000000,\n-            min: 2.0000000000,\n-            max: 57.0000000000,\n-            mean: 16.7000000000,\n-            median: 11.5000000000,\n-            var: 287.7888888889,\n-            std_dev: 16.9643416875,\n-            std_dev_pct: 101.5828843560,\n-            median_abs_dev: 13.3434000000,\n-            median_abs_dev_pct: 116.0295652174,\n-            quartiles: (4.2500000000, 11.5000000000, 22.5000000000),\n-            iqr: 18.2500000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_exp10b() {\n-        let val = &[\n-            24.0000000000,\n-            17.0000000000,\n-            6.0000000000,\n-            38.0000000000,\n-            25.0000000000,\n-            7.0000000000,\n-            51.0000000000,\n-            2.0000000000,\n-            61.0000000000,\n-            32.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 263.0000000000,\n-            min: 2.0000000000,\n-            max: 61.0000000000,\n-            mean: 26.3000000000,\n-            median: 24.5000000000,\n-            var: 383.5666666667,\n-            std_dev: 19.5848580967,\n-            std_dev_pct: 74.4671410520,\n-            median_abs_dev: 22.9803000000,\n-            median_abs_dev_pct: 93.7971428571,\n-            quartiles: (9.5000000000, 24.5000000000, 36.5000000000),\n-            iqr: 27.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_exp10c() {\n-        let val = &[\n-            71.0000000000,\n-            2.0000000000,\n-            32.0000000000,\n-            1.0000000000,\n-            6.0000000000,\n-            28.0000000000,\n-            13.0000000000,\n-            37.0000000000,\n-            16.0000000000,\n-            36.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 242.0000000000,\n-            min: 1.0000000000,\n-            max: 71.0000000000,\n-            mean: 24.2000000000,\n-            median: 22.0000000000,\n-            var: 458.1777777778,\n-            std_dev: 21.4050876611,\n-            std_dev_pct: 88.4507754589,\n-            median_abs_dev: 21.4977000000,\n-            median_abs_dev_pct: 97.7168181818,\n-            quartiles: (7.7500000000, 22.0000000000, 35.0000000000),\n-            iqr: 27.2500000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_exp25() {\n-        let val = &[\n-            3.0000000000,\n-            24.0000000000,\n-            1.0000000000,\n-            19.0000000000,\n-            7.0000000000,\n-            5.0000000000,\n-            30.0000000000,\n-            39.0000000000,\n-            31.0000000000,\n-            13.0000000000,\n-            25.0000000000,\n-            48.0000000000,\n-            1.0000000000,\n-            6.0000000000,\n-            42.0000000000,\n-            63.0000000000,\n-            2.0000000000,\n-            12.0000000000,\n-            108.0000000000,\n-            26.0000000000,\n-            1.0000000000,\n-            7.0000000000,\n-            44.0000000000,\n-            25.0000000000,\n-            11.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 593.0000000000,\n-            min: 1.0000000000,\n-            max: 108.0000000000,\n-            mean: 23.7200000000,\n-            median: 19.0000000000,\n-            var: 601.0433333333,\n-            std_dev: 24.5161851301,\n-            std_dev_pct: 103.3565983562,\n-            median_abs_dev: 19.2738000000,\n-            median_abs_dev_pct: 101.4410526316,\n-            quartiles: (6.0000000000, 19.0000000000, 31.0000000000),\n-            iqr: 25.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_binom25() {\n-        let val = &[\n-            18.0000000000,\n-            17.0000000000,\n-            27.0000000000,\n-            15.0000000000,\n-            21.0000000000,\n-            25.0000000000,\n-            17.0000000000,\n-            24.0000000000,\n-            25.0000000000,\n-            24.0000000000,\n-            26.0000000000,\n-            26.0000000000,\n-            23.0000000000,\n-            15.0000000000,\n-            23.0000000000,\n-            17.0000000000,\n-            18.0000000000,\n-            18.0000000000,\n-            21.0000000000,\n-            16.0000000000,\n-            15.0000000000,\n-            31.0000000000,\n-            20.0000000000,\n-            17.0000000000,\n-            15.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 514.0000000000,\n-            min: 15.0000000000,\n-            max: 31.0000000000,\n-            mean: 20.5600000000,\n-            median: 20.0000000000,\n-            var: 20.8400000000,\n-            std_dev: 4.5650848842,\n-            std_dev_pct: 22.2037202539,\n-            median_abs_dev: 5.9304000000,\n-            median_abs_dev_pct: 29.6520000000,\n-            quartiles: (17.0000000000, 20.0000000000, 24.0000000000),\n-            iqr: 7.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_pois25lambda30() {\n-        let val = &[\n-            27.0000000000,\n-            33.0000000000,\n-            34.0000000000,\n-            34.0000000000,\n-            24.0000000000,\n-            39.0000000000,\n-            28.0000000000,\n-            27.0000000000,\n-            31.0000000000,\n-            28.0000000000,\n-            38.0000000000,\n-            21.0000000000,\n-            33.0000000000,\n-            36.0000000000,\n-            29.0000000000,\n-            37.0000000000,\n-            32.0000000000,\n-            34.0000000000,\n-            31.0000000000,\n-            39.0000000000,\n-            25.0000000000,\n-            31.0000000000,\n-            32.0000000000,\n-            40.0000000000,\n-            24.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 787.0000000000,\n-            min: 21.0000000000,\n-            max: 40.0000000000,\n-            mean: 31.4800000000,\n-            median: 32.0000000000,\n-            var: 26.5933333333,\n-            std_dev: 5.1568724372,\n-            std_dev_pct: 16.3814245145,\n-            median_abs_dev: 5.9304000000,\n-            median_abs_dev_pct: 18.5325000000,\n-            quartiles: (28.0000000000, 32.0000000000, 34.0000000000),\n-            iqr: 6.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_pois25lambda40() {\n-        let val = &[\n-            42.0000000000,\n-            50.0000000000,\n-            42.0000000000,\n-            46.0000000000,\n-            34.0000000000,\n-            45.0000000000,\n-            34.0000000000,\n-            49.0000000000,\n-            39.0000000000,\n-            28.0000000000,\n-            40.0000000000,\n-            35.0000000000,\n-            37.0000000000,\n-            39.0000000000,\n-            46.0000000000,\n-            44.0000000000,\n-            32.0000000000,\n-            45.0000000000,\n-            42.0000000000,\n-            37.0000000000,\n-            48.0000000000,\n-            42.0000000000,\n-            33.0000000000,\n-            42.0000000000,\n-            48.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 1019.0000000000,\n-            min: 28.0000000000,\n-            max: 50.0000000000,\n-            mean: 40.7600000000,\n-            median: 42.0000000000,\n-            var: 34.4400000000,\n-            std_dev: 5.8685603004,\n-            std_dev_pct: 14.3978417577,\n-            median_abs_dev: 5.9304000000,\n-            median_abs_dev_pct: 14.1200000000,\n-            quartiles: (37.0000000000, 42.0000000000, 45.0000000000),\n-            iqr: 8.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_pois25lambda50() {\n-        let val = &[\n-            45.0000000000,\n-            43.0000000000,\n-            44.0000000000,\n-            61.0000000000,\n-            51.0000000000,\n-            53.0000000000,\n-            59.0000000000,\n-            52.0000000000,\n-            49.0000000000,\n-            51.0000000000,\n-            51.0000000000,\n-            50.0000000000,\n-            49.0000000000,\n-            56.0000000000,\n-            42.0000000000,\n-            52.0000000000,\n-            51.0000000000,\n-            43.0000000000,\n-            48.0000000000,\n-            48.0000000000,\n-            50.0000000000,\n-            42.0000000000,\n-            43.0000000000,\n-            42.0000000000,\n-            60.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 1235.0000000000,\n-            min: 42.0000000000,\n-            max: 61.0000000000,\n-            mean: 49.4000000000,\n-            median: 50.0000000000,\n-            var: 31.6666666667,\n-            std_dev: 5.6273143387,\n-            std_dev_pct: 11.3913245723,\n-            median_abs_dev: 4.4478000000,\n-            median_abs_dev_pct: 8.8956000000,\n-            quartiles: (44.0000000000, 50.0000000000, 52.0000000000),\n-            iqr: 8.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-    #[test]\n-    fn test_unif25() {\n-        let val = &[\n-            99.0000000000,\n-            55.0000000000,\n-            92.0000000000,\n-            79.0000000000,\n-            14.0000000000,\n-            2.0000000000,\n-            33.0000000000,\n-            49.0000000000,\n-            3.0000000000,\n-            32.0000000000,\n-            84.0000000000,\n-            59.0000000000,\n-            22.0000000000,\n-            86.0000000000,\n-            76.0000000000,\n-            31.0000000000,\n-            29.0000000000,\n-            11.0000000000,\n-            41.0000000000,\n-            53.0000000000,\n-            45.0000000000,\n-            44.0000000000,\n-            98.0000000000,\n-            98.0000000000,\n-            7.0000000000,\n-        ];\n-        let summ = &Summary {\n-            sum: 1242.0000000000,\n-            min: 2.0000000000,\n-            max: 99.0000000000,\n-            mean: 49.6800000000,\n-            median: 45.0000000000,\n-            var: 1015.6433333333,\n-            std_dev: 31.8691595957,\n-            std_dev_pct: 64.1488719719,\n-            median_abs_dev: 45.9606000000,\n-            median_abs_dev_pct: 102.1346666667,\n-            quartiles: (29.0000000000, 45.0000000000, 79.0000000000),\n-            iqr: 50.0000000000,\n-        };\n-        check(val, summ);\n-    }\n-\n-    #[test]\n-    fn test_sum_f64s() {\n-        assert_eq!([0.5f64, 3.2321f64, 1.5678f64].sum(), 5.2999);\n-    }\n-    #[test]\n-    fn test_sum_f64_between_ints_that_sum_to_0() {\n-        assert_eq!([1e30f64, 1.2f64, -1e30f64].sum(), 1.2);\n-    }\n-}\n+mod tests;\n \n #[cfg(test)]\n mod bench {"}, {"sha": "59f936453602a1b5719fececdc09b10ddde97579", "filename": "src/libtest/stats/tests.rs", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibtest%2Fstats%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibtest%2Fstats%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,574 @@\n+use crate::stats::Stats;\n+use crate::stats::Summary;\n+use std::f64;\n+use std::io::prelude::*;\n+use std::io;\n+\n+macro_rules! assert_approx_eq {\n+    ($a: expr, $b: expr) => {{\n+        let (a, b) = (&$a, &$b);\n+        assert!(\n+            (*a - *b).abs() < 1.0e-6,\n+            \"{} is not approximately equal to {}\",\n+            *a,\n+            *b\n+        );\n+    }};\n+}\n+\n+fn check(samples: &[f64], summ: &Summary) {\n+    let summ2 = Summary::new(samples);\n+\n+    let mut w = io::sink();\n+    let w = &mut w;\n+    (write!(w, \"\\n\")).unwrap();\n+\n+    assert_eq!(summ.sum, summ2.sum);\n+    assert_eq!(summ.min, summ2.min);\n+    assert_eq!(summ.max, summ2.max);\n+    assert_eq!(summ.mean, summ2.mean);\n+    assert_eq!(summ.median, summ2.median);\n+\n+    // We needed a few more digits to get exact equality on these\n+    // but they're within float epsilon, which is 1.0e-6.\n+    assert_approx_eq!(summ.var, summ2.var);\n+    assert_approx_eq!(summ.std_dev, summ2.std_dev);\n+    assert_approx_eq!(summ.std_dev_pct, summ2.std_dev_pct);\n+    assert_approx_eq!(summ.median_abs_dev, summ2.median_abs_dev);\n+    assert_approx_eq!(summ.median_abs_dev_pct, summ2.median_abs_dev_pct);\n+\n+    assert_eq!(summ.quartiles, summ2.quartiles);\n+    assert_eq!(summ.iqr, summ2.iqr);\n+}\n+\n+#[test]\n+fn test_min_max_nan() {\n+    let xs = &[1.0, 2.0, f64::NAN, 3.0, 4.0];\n+    let summary = Summary::new(xs);\n+    assert_eq!(summary.min, 1.0);\n+    assert_eq!(summary.max, 4.0);\n+}\n+\n+#[test]\n+fn test_norm2() {\n+    let val = &[958.0000000000, 924.0000000000];\n+    let summ = &Summary {\n+        sum: 1882.0000000000,\n+        min: 924.0000000000,\n+        max: 958.0000000000,\n+        mean: 941.0000000000,\n+        median: 941.0000000000,\n+        var: 578.0000000000,\n+        std_dev: 24.0416305603,\n+        std_dev_pct: 2.5549022912,\n+        median_abs_dev: 25.2042000000,\n+        median_abs_dev_pct: 2.6784484591,\n+        quartiles: (932.5000000000, 941.0000000000, 949.5000000000),\n+        iqr: 17.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_norm10narrow() {\n+    let val = &[\n+        966.0000000000,\n+        985.0000000000,\n+        1110.0000000000,\n+        848.0000000000,\n+        821.0000000000,\n+        975.0000000000,\n+        962.0000000000,\n+        1157.0000000000,\n+        1217.0000000000,\n+        955.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 9996.0000000000,\n+        min: 821.0000000000,\n+        max: 1217.0000000000,\n+        mean: 999.6000000000,\n+        median: 970.5000000000,\n+        var: 16050.7111111111,\n+        std_dev: 126.6914010938,\n+        std_dev_pct: 12.6742097933,\n+        median_abs_dev: 102.2994000000,\n+        median_abs_dev_pct: 10.5408964451,\n+        quartiles: (956.7500000000, 970.5000000000, 1078.7500000000),\n+        iqr: 122.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_norm10medium() {\n+    let val = &[\n+        954.0000000000,\n+        1064.0000000000,\n+        855.0000000000,\n+        1000.0000000000,\n+        743.0000000000,\n+        1084.0000000000,\n+        704.0000000000,\n+        1023.0000000000,\n+        357.0000000000,\n+        869.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 8653.0000000000,\n+        min: 357.0000000000,\n+        max: 1084.0000000000,\n+        mean: 865.3000000000,\n+        median: 911.5000000000,\n+        var: 48628.4555555556,\n+        std_dev: 220.5186059170,\n+        std_dev_pct: 25.4846418487,\n+        median_abs_dev: 195.7032000000,\n+        median_abs_dev_pct: 21.4704552935,\n+        quartiles: (771.0000000000, 911.5000000000, 1017.2500000000),\n+        iqr: 246.2500000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_norm10wide() {\n+    let val = &[\n+        505.0000000000,\n+        497.0000000000,\n+        1591.0000000000,\n+        887.0000000000,\n+        1026.0000000000,\n+        136.0000000000,\n+        1580.0000000000,\n+        940.0000000000,\n+        754.0000000000,\n+        1433.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 9349.0000000000,\n+        min: 136.0000000000,\n+        max: 1591.0000000000,\n+        mean: 934.9000000000,\n+        median: 913.5000000000,\n+        var: 239208.9888888889,\n+        std_dev: 489.0899599142,\n+        std_dev_pct: 52.3146817750,\n+        median_abs_dev: 611.5725000000,\n+        median_abs_dev_pct: 66.9482758621,\n+        quartiles: (567.2500000000, 913.5000000000, 1331.2500000000),\n+        iqr: 764.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_norm25verynarrow() {\n+    let val = &[\n+        991.0000000000,\n+        1018.0000000000,\n+        998.0000000000,\n+        1013.0000000000,\n+        974.0000000000,\n+        1007.0000000000,\n+        1014.0000000000,\n+        999.0000000000,\n+        1011.0000000000,\n+        978.0000000000,\n+        985.0000000000,\n+        999.0000000000,\n+        983.0000000000,\n+        982.0000000000,\n+        1015.0000000000,\n+        1002.0000000000,\n+        977.0000000000,\n+        948.0000000000,\n+        1040.0000000000,\n+        974.0000000000,\n+        996.0000000000,\n+        989.0000000000,\n+        1015.0000000000,\n+        994.0000000000,\n+        1024.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 24926.0000000000,\n+        min: 948.0000000000,\n+        max: 1040.0000000000,\n+        mean: 997.0400000000,\n+        median: 998.0000000000,\n+        var: 393.2066666667,\n+        std_dev: 19.8294393937,\n+        std_dev_pct: 1.9888308788,\n+        median_abs_dev: 22.2390000000,\n+        median_abs_dev_pct: 2.2283567134,\n+        quartiles: (983.0000000000, 998.0000000000, 1013.0000000000),\n+        iqr: 30.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_exp10a() {\n+    let val = &[\n+        23.0000000000,\n+        11.0000000000,\n+        2.0000000000,\n+        57.0000000000,\n+        4.0000000000,\n+        12.0000000000,\n+        5.0000000000,\n+        29.0000000000,\n+        3.0000000000,\n+        21.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 167.0000000000,\n+        min: 2.0000000000,\n+        max: 57.0000000000,\n+        mean: 16.7000000000,\n+        median: 11.5000000000,\n+        var: 287.7888888889,\n+        std_dev: 16.9643416875,\n+        std_dev_pct: 101.5828843560,\n+        median_abs_dev: 13.3434000000,\n+        median_abs_dev_pct: 116.0295652174,\n+        quartiles: (4.2500000000, 11.5000000000, 22.5000000000),\n+        iqr: 18.2500000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_exp10b() {\n+    let val = &[\n+        24.0000000000,\n+        17.0000000000,\n+        6.0000000000,\n+        38.0000000000,\n+        25.0000000000,\n+        7.0000000000,\n+        51.0000000000,\n+        2.0000000000,\n+        61.0000000000,\n+        32.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 263.0000000000,\n+        min: 2.0000000000,\n+        max: 61.0000000000,\n+        mean: 26.3000000000,\n+        median: 24.5000000000,\n+        var: 383.5666666667,\n+        std_dev: 19.5848580967,\n+        std_dev_pct: 74.4671410520,\n+        median_abs_dev: 22.9803000000,\n+        median_abs_dev_pct: 93.7971428571,\n+        quartiles: (9.5000000000, 24.5000000000, 36.5000000000),\n+        iqr: 27.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_exp10c() {\n+    let val = &[\n+        71.0000000000,\n+        2.0000000000,\n+        32.0000000000,\n+        1.0000000000,\n+        6.0000000000,\n+        28.0000000000,\n+        13.0000000000,\n+        37.0000000000,\n+        16.0000000000,\n+        36.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 242.0000000000,\n+        min: 1.0000000000,\n+        max: 71.0000000000,\n+        mean: 24.2000000000,\n+        median: 22.0000000000,\n+        var: 458.1777777778,\n+        std_dev: 21.4050876611,\n+        std_dev_pct: 88.4507754589,\n+        median_abs_dev: 21.4977000000,\n+        median_abs_dev_pct: 97.7168181818,\n+        quartiles: (7.7500000000, 22.0000000000, 35.0000000000),\n+        iqr: 27.2500000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_exp25() {\n+    let val = &[\n+        3.0000000000,\n+        24.0000000000,\n+        1.0000000000,\n+        19.0000000000,\n+        7.0000000000,\n+        5.0000000000,\n+        30.0000000000,\n+        39.0000000000,\n+        31.0000000000,\n+        13.0000000000,\n+        25.0000000000,\n+        48.0000000000,\n+        1.0000000000,\n+        6.0000000000,\n+        42.0000000000,\n+        63.0000000000,\n+        2.0000000000,\n+        12.0000000000,\n+        108.0000000000,\n+        26.0000000000,\n+        1.0000000000,\n+        7.0000000000,\n+        44.0000000000,\n+        25.0000000000,\n+        11.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 593.0000000000,\n+        min: 1.0000000000,\n+        max: 108.0000000000,\n+        mean: 23.7200000000,\n+        median: 19.0000000000,\n+        var: 601.0433333333,\n+        std_dev: 24.5161851301,\n+        std_dev_pct: 103.3565983562,\n+        median_abs_dev: 19.2738000000,\n+        median_abs_dev_pct: 101.4410526316,\n+        quartiles: (6.0000000000, 19.0000000000, 31.0000000000),\n+        iqr: 25.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_binom25() {\n+    let val = &[\n+        18.0000000000,\n+        17.0000000000,\n+        27.0000000000,\n+        15.0000000000,\n+        21.0000000000,\n+        25.0000000000,\n+        17.0000000000,\n+        24.0000000000,\n+        25.0000000000,\n+        24.0000000000,\n+        26.0000000000,\n+        26.0000000000,\n+        23.0000000000,\n+        15.0000000000,\n+        23.0000000000,\n+        17.0000000000,\n+        18.0000000000,\n+        18.0000000000,\n+        21.0000000000,\n+        16.0000000000,\n+        15.0000000000,\n+        31.0000000000,\n+        20.0000000000,\n+        17.0000000000,\n+        15.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 514.0000000000,\n+        min: 15.0000000000,\n+        max: 31.0000000000,\n+        mean: 20.5600000000,\n+        median: 20.0000000000,\n+        var: 20.8400000000,\n+        std_dev: 4.5650848842,\n+        std_dev_pct: 22.2037202539,\n+        median_abs_dev: 5.9304000000,\n+        median_abs_dev_pct: 29.6520000000,\n+        quartiles: (17.0000000000, 20.0000000000, 24.0000000000),\n+        iqr: 7.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_pois25lambda30() {\n+    let val = &[\n+        27.0000000000,\n+        33.0000000000,\n+        34.0000000000,\n+        34.0000000000,\n+        24.0000000000,\n+        39.0000000000,\n+        28.0000000000,\n+        27.0000000000,\n+        31.0000000000,\n+        28.0000000000,\n+        38.0000000000,\n+        21.0000000000,\n+        33.0000000000,\n+        36.0000000000,\n+        29.0000000000,\n+        37.0000000000,\n+        32.0000000000,\n+        34.0000000000,\n+        31.0000000000,\n+        39.0000000000,\n+        25.0000000000,\n+        31.0000000000,\n+        32.0000000000,\n+        40.0000000000,\n+        24.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 787.0000000000,\n+        min: 21.0000000000,\n+        max: 40.0000000000,\n+        mean: 31.4800000000,\n+        median: 32.0000000000,\n+        var: 26.5933333333,\n+        std_dev: 5.1568724372,\n+        std_dev_pct: 16.3814245145,\n+        median_abs_dev: 5.9304000000,\n+        median_abs_dev_pct: 18.5325000000,\n+        quartiles: (28.0000000000, 32.0000000000, 34.0000000000),\n+        iqr: 6.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_pois25lambda40() {\n+    let val = &[\n+        42.0000000000,\n+        50.0000000000,\n+        42.0000000000,\n+        46.0000000000,\n+        34.0000000000,\n+        45.0000000000,\n+        34.0000000000,\n+        49.0000000000,\n+        39.0000000000,\n+        28.0000000000,\n+        40.0000000000,\n+        35.0000000000,\n+        37.0000000000,\n+        39.0000000000,\n+        46.0000000000,\n+        44.0000000000,\n+        32.0000000000,\n+        45.0000000000,\n+        42.0000000000,\n+        37.0000000000,\n+        48.0000000000,\n+        42.0000000000,\n+        33.0000000000,\n+        42.0000000000,\n+        48.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 1019.0000000000,\n+        min: 28.0000000000,\n+        max: 50.0000000000,\n+        mean: 40.7600000000,\n+        median: 42.0000000000,\n+        var: 34.4400000000,\n+        std_dev: 5.8685603004,\n+        std_dev_pct: 14.3978417577,\n+        median_abs_dev: 5.9304000000,\n+        median_abs_dev_pct: 14.1200000000,\n+        quartiles: (37.0000000000, 42.0000000000, 45.0000000000),\n+        iqr: 8.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_pois25lambda50() {\n+    let val = &[\n+        45.0000000000,\n+        43.0000000000,\n+        44.0000000000,\n+        61.0000000000,\n+        51.0000000000,\n+        53.0000000000,\n+        59.0000000000,\n+        52.0000000000,\n+        49.0000000000,\n+        51.0000000000,\n+        51.0000000000,\n+        50.0000000000,\n+        49.0000000000,\n+        56.0000000000,\n+        42.0000000000,\n+        52.0000000000,\n+        51.0000000000,\n+        43.0000000000,\n+        48.0000000000,\n+        48.0000000000,\n+        50.0000000000,\n+        42.0000000000,\n+        43.0000000000,\n+        42.0000000000,\n+        60.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 1235.0000000000,\n+        min: 42.0000000000,\n+        max: 61.0000000000,\n+        mean: 49.4000000000,\n+        median: 50.0000000000,\n+        var: 31.6666666667,\n+        std_dev: 5.6273143387,\n+        std_dev_pct: 11.3913245723,\n+        median_abs_dev: 4.4478000000,\n+        median_abs_dev_pct: 8.8956000000,\n+        quartiles: (44.0000000000, 50.0000000000, 52.0000000000),\n+        iqr: 8.0000000000,\n+    };\n+    check(val, summ);\n+}\n+#[test]\n+fn test_unif25() {\n+    let val = &[\n+        99.0000000000,\n+        55.0000000000,\n+        92.0000000000,\n+        79.0000000000,\n+        14.0000000000,\n+        2.0000000000,\n+        33.0000000000,\n+        49.0000000000,\n+        3.0000000000,\n+        32.0000000000,\n+        84.0000000000,\n+        59.0000000000,\n+        22.0000000000,\n+        86.0000000000,\n+        76.0000000000,\n+        31.0000000000,\n+        29.0000000000,\n+        11.0000000000,\n+        41.0000000000,\n+        53.0000000000,\n+        45.0000000000,\n+        44.0000000000,\n+        98.0000000000,\n+        98.0000000000,\n+        7.0000000000,\n+    ];\n+    let summ = &Summary {\n+        sum: 1242.0000000000,\n+        min: 2.0000000000,\n+        max: 99.0000000000,\n+        mean: 49.6800000000,\n+        median: 45.0000000000,\n+        var: 1015.6433333333,\n+        std_dev: 31.8691595957,\n+        std_dev_pct: 64.1488719719,\n+        median_abs_dev: 45.9606000000,\n+        median_abs_dev_pct: 102.1346666667,\n+        quartiles: (29.0000000000, 45.0000000000, 79.0000000000),\n+        iqr: 50.0000000000,\n+    };\n+    check(val, summ);\n+}\n+\n+#[test]\n+fn test_sum_f64s() {\n+    assert_eq!([0.5f64, 3.2321f64, 1.5678f64].sum(), 5.2999);\n+}\n+#[test]\n+fn test_sum_f64_between_ints_that_sum_to_0() {\n+    assert_eq!([1e30f64, 1.2f64, -1e30f64].sum(), 1.2);\n+}"}, {"sha": "d8734d8caa03ed1a0e850ef732db6522349c766a", "filename": "src/libtest/tests.rs", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/rust-lang/rust/blob/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibtest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b6a5e5e82497caf5353d9d856e4eb5d14cbe06/src%2Flibtest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Ftests.rs?ref=37b6a5e5e82497caf5353d9d856e4eb5d14cbe06", "patch": "@@ -0,0 +1,453 @@\n+use crate::bench;\n+use crate::test::{\n+    filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n+    ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n+    TrIgnored, TrOk,\n+};\n+use crate::Bencher;\n+use crate::Concurrent;\n+use std::sync::mpsc::channel;\n+\n+fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n+    vec![\n+        TestDescAndFn {\n+            desc: TestDesc {\n+                name: StaticTestName(\"1\"),\n+                ignore: true,\n+                should_panic: ShouldPanic::No,\n+                allow_fail: false,\n+            },\n+            testfn: DynTestFn(Box::new(move || {})),\n+        },\n+        TestDescAndFn {\n+            desc: TestDesc {\n+                name: StaticTestName(\"2\"),\n+                ignore: false,\n+                should_panic: ShouldPanic::No,\n+                allow_fail: false,\n+            },\n+            testfn: DynTestFn(Box::new(move || {})),\n+        },\n+    ]\n+}\n+\n+#[test]\n+pub fn do_not_run_ignored_tests() {\n+    fn f() {\n+        panic!();\n+    }\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: true,\n+            should_panic: ShouldPanic::No,\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    let (_, res, _) = rx.recv().unwrap();\n+    assert!(res != TrOk);\n+}\n+\n+#[test]\n+pub fn ignored_tests_result_in_ignored() {\n+    fn f() {}\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: true,\n+            should_panic: ShouldPanic::No,\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    let (_, res, _) = rx.recv().unwrap();\n+    assert!(res == TrIgnored);\n+}\n+\n+#[test]\n+fn test_should_panic() {\n+    fn f() {\n+        panic!();\n+    }\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::Yes,\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    let (_, res, _) = rx.recv().unwrap();\n+    assert!(res == TrOk);\n+}\n+\n+#[test]\n+fn test_should_panic_good_message() {\n+    fn f() {\n+        panic!(\"an error message\");\n+    }\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::YesWithMessage(\"error message\"),\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    let (_, res, _) = rx.recv().unwrap();\n+    assert!(res == TrOk);\n+}\n+\n+#[test]\n+fn test_should_panic_bad_message() {\n+    fn f() {\n+        panic!(\"an error message\");\n+    }\n+    let expected = \"foobar\";\n+    let failed_msg = \"panic did not include expected string\";\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::YesWithMessage(expected),\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    let (_, res, _) = rx.recv().unwrap();\n+    assert!(res == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n+}\n+\n+#[test]\n+fn test_should_panic_but_succeeds() {\n+    fn f() {}\n+    let desc = TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"whatever\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::Yes,\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(f)),\n+    };\n+    let (tx, rx) = channel();\n+    run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+    let (_, res, _) = rx.recv().unwrap();\n+    assert!(res == TrFailed);\n+}\n+\n+#[test]\n+fn parse_ignored_flag() {\n+    let args = vec![\n+        \"progname\".to_string(),\n+        \"filter\".to_string(),\n+        \"--ignored\".to_string(),\n+    ];\n+    let opts = parse_opts(&args).unwrap().unwrap();\n+    assert_eq!(opts.run_ignored, RunIgnored::Only);\n+}\n+\n+#[test]\n+fn parse_include_ignored_flag() {\n+    let args = vec![\n+        \"progname\".to_string(),\n+        \"filter\".to_string(),\n+        \"-Zunstable-options\".to_string(),\n+        \"--include-ignored\".to_string(),\n+    ];\n+    let opts = parse_opts(&args).unwrap().unwrap();\n+    assert_eq!(opts.run_ignored, RunIgnored::Yes);\n+}\n+\n+#[test]\n+pub fn filter_for_ignored_option() {\n+    // When we run ignored tests the test filter should filter out all the\n+    // unignored tests and flip the ignore flag on the rest to false\n+\n+    let mut opts = TestOpts::new();\n+    opts.run_tests = true;\n+    opts.run_ignored = RunIgnored::Only;\n+\n+    let tests = one_ignored_one_unignored_test();\n+    let filtered = filter_tests(&opts, tests);\n+\n+    assert_eq!(filtered.len(), 1);\n+    assert_eq!(filtered[0].desc.name.to_string(), \"1\");\n+    assert!(!filtered[0].desc.ignore);\n+}\n+\n+#[test]\n+pub fn run_include_ignored_option() {\n+    // When we \"--include-ignored\" tests, the ignore flag should be set to false on\n+    // all tests and no test filtered out\n+\n+    let mut opts = TestOpts::new();\n+    opts.run_tests = true;\n+    opts.run_ignored = RunIgnored::Yes;\n+\n+    let tests = one_ignored_one_unignored_test();\n+    let filtered = filter_tests(&opts, tests);\n+\n+    assert_eq!(filtered.len(), 2);\n+    assert!(!filtered[0].desc.ignore);\n+    assert!(!filtered[1].desc.ignore);\n+}\n+\n+#[test]\n+pub fn exclude_should_panic_option() {\n+    let mut opts = TestOpts::new();\n+    opts.run_tests = true;\n+    opts.exclude_should_panic = true;\n+\n+    let mut tests = one_ignored_one_unignored_test();\n+    tests.push(TestDescAndFn {\n+        desc: TestDesc {\n+            name: StaticTestName(\"3\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::Yes,\n+            allow_fail: false,\n+        },\n+        testfn: DynTestFn(Box::new(move || {})),\n+    });\n+\n+    let filtered = filter_tests(&opts, tests);\n+\n+    assert_eq!(filtered.len(), 2);\n+    assert!(filtered.iter().all(|test| test.desc.should_panic == ShouldPanic::No));\n+}\n+\n+#[test]\n+pub fn exact_filter_match() {\n+    fn tests() -> Vec<TestDescAndFn> {\n+        vec![\"base\", \"base::test\", \"base::test1\", \"base::test2\"]\n+            .into_iter()\n+            .map(|name| TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(name),\n+                    ignore: false,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            })\n+            .collect()\n+    }\n+\n+    let substr = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"base\".into()),\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(substr.len(), 4);\n+\n+    let substr = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"bas\".into()),\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(substr.len(), 4);\n+\n+    let substr = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"::test\".into()),\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(substr.len(), 3);\n+\n+    let substr = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"base::test\".into()),\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(substr.len(), 3);\n+\n+    let exact = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"base\".into()),\n+            filter_exact: true,\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(exact.len(), 1);\n+\n+    let exact = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"bas\".into()),\n+            filter_exact: true,\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(exact.len(), 0);\n+\n+    let exact = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"::test\".into()),\n+            filter_exact: true,\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(exact.len(), 0);\n+\n+    let exact = filter_tests(\n+        &TestOpts {\n+            filter: Some(\"base::test\".into()),\n+            filter_exact: true,\n+            ..TestOpts::new()\n+        },\n+        tests(),\n+    );\n+    assert_eq!(exact.len(), 1);\n+}\n+\n+#[test]\n+pub fn sort_tests() {\n+    let mut opts = TestOpts::new();\n+    opts.run_tests = true;\n+\n+    let names = vec![\n+        \"sha1::test\".to_string(),\n+        \"isize::test_to_str\".to_string(),\n+        \"isize::test_pow\".to_string(),\n+        \"test::do_not_run_ignored_tests\".to_string(),\n+        \"test::ignored_tests_result_in_ignored\".to_string(),\n+        \"test::first_free_arg_should_be_a_filter\".to_string(),\n+        \"test::parse_ignored_flag\".to_string(),\n+        \"test::parse_include_ignored_flag\".to_string(),\n+        \"test::filter_for_ignored_option\".to_string(),\n+        \"test::run_include_ignored_option\".to_string(),\n+        \"test::sort_tests\".to_string(),\n+    ];\n+    let tests = {\n+        fn testfn() {}\n+        let mut tests = Vec::new();\n+        for name in &names {\n+            let test = TestDescAndFn {\n+                desc: TestDesc {\n+                    name: DynTestName((*name).clone()),\n+                    ignore: false,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(testfn)),\n+            };\n+            tests.push(test);\n+        }\n+        tests\n+    };\n+    let filtered = filter_tests(&opts, tests);\n+\n+    let expected = vec![\n+        \"isize::test_pow\".to_string(),\n+        \"isize::test_to_str\".to_string(),\n+        \"sha1::test\".to_string(),\n+        \"test::do_not_run_ignored_tests\".to_string(),\n+        \"test::filter_for_ignored_option\".to_string(),\n+        \"test::first_free_arg_should_be_a_filter\".to_string(),\n+        \"test::ignored_tests_result_in_ignored\".to_string(),\n+        \"test::parse_ignored_flag\".to_string(),\n+        \"test::parse_include_ignored_flag\".to_string(),\n+        \"test::run_include_ignored_option\".to_string(),\n+        \"test::sort_tests\".to_string(),\n+    ];\n+\n+    for (a, b) in expected.iter().zip(filtered) {\n+        assert!(*a == b.desc.name.to_string());\n+    }\n+}\n+\n+#[test]\n+pub fn test_metricmap_compare() {\n+    let mut m1 = MetricMap::new();\n+    let mut m2 = MetricMap::new();\n+    m1.insert_metric(\"in-both-noise\", 1000.0, 200.0);\n+    m2.insert_metric(\"in-both-noise\", 1100.0, 200.0);\n+\n+    m1.insert_metric(\"in-first-noise\", 1000.0, 2.0);\n+    m2.insert_metric(\"in-second-noise\", 1000.0, 2.0);\n+\n+    m1.insert_metric(\"in-both-want-downwards-but-regressed\", 1000.0, 10.0);\n+    m2.insert_metric(\"in-both-want-downwards-but-regressed\", 2000.0, 10.0);\n+\n+    m1.insert_metric(\"in-both-want-downwards-and-improved\", 2000.0, 10.0);\n+    m2.insert_metric(\"in-both-want-downwards-and-improved\", 1000.0, 10.0);\n+\n+    m1.insert_metric(\"in-both-want-upwards-but-regressed\", 2000.0, -10.0);\n+    m2.insert_metric(\"in-both-want-upwards-but-regressed\", 1000.0, -10.0);\n+\n+    m1.insert_metric(\"in-both-want-upwards-and-improved\", 1000.0, -10.0);\n+    m2.insert_metric(\"in-both-want-upwards-and-improved\", 2000.0, -10.0);\n+}\n+\n+#[test]\n+pub fn test_bench_once_no_iter() {\n+    fn f(_: &mut Bencher) {}\n+    bench::run_once(f);\n+}\n+\n+#[test]\n+pub fn test_bench_once_iter() {\n+    fn f(b: &mut Bencher) {\n+        b.iter(|| {})\n+    }\n+    bench::run_once(f);\n+}\n+\n+#[test]\n+pub fn test_bench_no_iter() {\n+    fn f(_: &mut Bencher) {}\n+\n+    let (tx, rx) = channel();\n+\n+    let desc = TestDesc {\n+        name: StaticTestName(\"f\"),\n+        ignore: false,\n+        should_panic: ShouldPanic::No,\n+        allow_fail: false,\n+    };\n+\n+    crate::bench::benchmark(desc, tx, true, f);\n+    rx.recv().unwrap();\n+}\n+\n+#[test]\n+pub fn test_bench_iter() {\n+    fn f(b: &mut Bencher) {\n+        b.iter(|| {})\n+    }\n+\n+    let (tx, rx) = channel();\n+\n+    let desc = TestDesc {\n+        name: StaticTestName(\"f\"),\n+        ignore: false,\n+        should_panic: ShouldPanic::No,\n+        allow_fail: false,\n+    };\n+\n+    crate::bench::benchmark(desc, tx, true, f);\n+    rx.recv().unwrap();\n+}"}]}