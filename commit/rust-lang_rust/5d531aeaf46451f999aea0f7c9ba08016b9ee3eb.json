{"sha": "5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNTMxYWVhZjQ2NDUxZjk5OWFlYTBmN2M5YmEwODAxNmI5ZWUzZWI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-09-16T20:34:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2019-09-23T19:29:51Z"}, "message": "rustc: Convert `dependency_formats` to a query\n\nThis commit converts a field of `Session`, `dependency_formats`, into a\nquery of `TyCtxt`. This information then also needed to be threaded\nthrough to other remaining portions of the linker, but it's relatively\nstraightforward. The only change here is that instead of\n`HashMap<CrateType, T>` the data structure changed to `Vec<(CrateType,\nT)>` to make it easier to deal with in queries.", "tree": {"sha": "902f16bc195b4c652fd06dc3145489f764d4e99c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/902f16bc195b4c652fd06dc3145489f764d4e99c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "html_url": "https://github.com/rust-lang/rust/commit/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66bf391c3aabfc77f5f7139fc9e6944f995d574e", "url": "https://api.github.com/repos/rust-lang/rust/commits/66bf391c3aabfc77f5f7139fc9e6944f995d574e", "html_url": "https://github.com/rust-lang/rust/commit/66bf391c3aabfc77f5f7139fc9e6944f995d574e"}], "stats": {"total": 874, "additions": 455, "deletions": 419}, "files": [{"sha": "8b2bf55ccc1208f7bdf358ce8e508603b9e05a40", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 6, "deletions": 372, "changes": 378, "blob_url": "https://github.com/rust-lang/rust/blob/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "patch": "@@ -1,64 +1,10 @@\n-//! Resolution of mixing rlibs and dylibs\n+//! Type definitions for learning about the dependency formats of all upstream\n+//! crates (rlibs/dylibs/oh my).\n //!\n-//! When producing a final artifact, such as a dynamic library, the compiler has\n-//! a choice between linking an rlib or linking a dylib of all upstream\n-//! dependencies. The linking phase must guarantee, however, that a library only\n-//! show up once in the object file. For example, it is illegal for library A to\n-//! be statically linked to B and C in separate dylibs, and then link B and C\n-//! into a crate D (because library A appears twice).\n-//!\n-//! The job of this module is to calculate what format each upstream crate\n-//! should be used when linking each output type requested in this session. This\n-//! generally follows this set of rules:\n-//!\n-//!     1. Each library must appear exactly once in the output.\n-//!     2. Each rlib contains only one library (it's just an object file)\n-//!     3. Each dylib can contain more than one library (due to static linking),\n-//!        and can also bring in many dynamic dependencies.\n-//!\n-//! With these constraints in mind, it's generally a very difficult problem to\n-//! find a solution that's not \"all rlibs\" or \"all dylibs\". I have suspicions\n-//! that NP-ness may come into the picture here...\n-//!\n-//! The current selection algorithm below looks mostly similar to:\n-//!\n-//!     1. If static linking is required, then require all upstream dependencies\n-//!        to be available as rlibs. If not, generate an error.\n-//!     2. If static linking is requested (generating an executable), then\n-//!        attempt to use all upstream dependencies as rlibs. If any are not\n-//!        found, bail out and continue to step 3.\n-//!     3. Static linking has failed, at least one library must be dynamically\n-//!        linked. Apply a heuristic by greedily maximizing the number of\n-//!        dynamically linked libraries.\n-//!     4. Each upstream dependency available as a dynamic library is\n-//!        registered. The dependencies all propagate, adding to a map. It is\n-//!        possible for a dylib to add a static library as a dependency, but it\n-//!        is illegal for two dylibs to add the same static library as a\n-//!        dependency. The same dylib can be added twice. Additionally, it is\n-//!        illegal to add a static dependency when it was previously found as a\n-//!        dylib (and vice versa)\n-//!     5. After all dynamic dependencies have been traversed, re-traverse the\n-//!        remaining dependencies and add them statically (if they haven't been\n-//!        added already).\n-//!\n-//! While not perfect, this algorithm should help support use-cases such as leaf\n-//! dependencies being static while the larger tree of inner dependencies are\n-//! all dynamic. This isn't currently very well battle tested, so it will likely\n-//! fall short in some use cases.\n-//!\n-//! Currently, there is no way to specify the preference of linkage with a\n-//! particular library (other than a global dynamic/static switch).\n-//! Additionally, the algorithm is geared towards finding *any* solution rather\n-//! than finding a number of solutions (there are normally quite a few).\n-\n-use crate::hir::def_id::CrateNum;\n+//! For all the gory details, see the provider of the `dependency_formats`\n+//! query.\n \n use crate::session::config;\n-use crate::ty::TyCtxt;\n-use crate::middle::cstore::{self, DepKind};\n-use crate::middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n-use crate::util::nodemap::FxHashMap;\n-use rustc_target::spec::PanicStrategy;\n \n /// A list of dependencies for a certain crate type.\n ///\n@@ -71,324 +17,12 @@ pub type DependencyList = Vec<Linkage>;\n /// A mapping of all required dependencies for a particular flavor of output.\n ///\n /// This is local to the tcx, and is generally relevant to one session.\n-pub type Dependencies = FxHashMap<config::CrateType, DependencyList>;\n+pub type Dependencies = Vec<(config::CrateType, DependencyList)>;\n \n-#[derive(Copy, Clone, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug, HashStable)]\n pub enum Linkage {\n     NotLinked,\n     IncludedFromDylib,\n     Static,\n     Dynamic,\n }\n-\n-pub fn calculate(tcx: TyCtxt<'_>) {\n-    let sess = &tcx.sess;\n-    let fmts = sess.crate_types.borrow().iter().map(|&ty| {\n-        let linkage = calculate_type(tcx, ty);\n-        verify_ok(tcx, &linkage);\n-        (ty, linkage)\n-    }).collect::<FxHashMap<_, _>>();\n-    sess.abort_if_errors();\n-    sess.dependency_formats.set(fmts);\n-}\n-\n-fn calculate_type(tcx: TyCtxt<'_>, ty: config::CrateType) -> DependencyList {\n-    let sess = &tcx.sess;\n-\n-    if !sess.opts.output_types.should_codegen() {\n-        return Vec::new();\n-    }\n-\n-    let preferred_linkage = match ty {\n-        // cdylibs must have all static dependencies.\n-        config::CrateType::Cdylib => Linkage::Static,\n-\n-        // Generating a dylib without `-C prefer-dynamic` means that we're going\n-        // to try to eagerly statically link all dependencies. This is normally\n-        // done for end-product dylibs, not intermediate products.\n-        config::CrateType::Dylib if !sess.opts.cg.prefer_dynamic => Linkage::Static,\n-        config::CrateType::Dylib => Linkage::Dynamic,\n-\n-        // If the global prefer_dynamic switch is turned off, or the final\n-        // executable will be statically linked, prefer static crate linkage.\n-        config::CrateType::Executable if !sess.opts.cg.prefer_dynamic ||\n-            sess.crt_static() => Linkage::Static,\n-        config::CrateType::Executable => Linkage::Dynamic,\n-\n-        // proc-macro crates are mostly cdylibs, but we also need metadata.\n-        config::CrateType::ProcMacro => Linkage::Static,\n-\n-        // No linkage happens with rlibs, we just needed the metadata (which we\n-        // got long ago), so don't bother with anything.\n-        config::CrateType::Rlib => Linkage::NotLinked,\n-\n-        // staticlibs must have all static dependencies.\n-        config::CrateType::Staticlib => Linkage::Static,\n-    };\n-\n-    if preferred_linkage == Linkage::NotLinked {\n-        // If the crate is not linked, there are no link-time dependencies.\n-        return Vec::new();\n-    }\n-\n-    if preferred_linkage == Linkage::Static {\n-        // Attempt static linkage first. For dylibs and executables, we may be\n-        // able to retry below with dynamic linkage.\n-        if let Some(v) = attempt_static(tcx) {\n-            return v;\n-        }\n-\n-        // Staticlibs, cdylibs, and static executables must have all static\n-        // dependencies. If any are not found, generate some nice pretty errors.\n-        if ty == config::CrateType::Cdylib || ty == config::CrateType::Staticlib ||\n-                (ty == config::CrateType::Executable && sess.crt_static() &&\n-                !sess.target.target.options.crt_static_allows_dylibs) {\n-            for &cnum in tcx.crates().iter() {\n-                if tcx.dep_kind(cnum).macros_only() { continue }\n-                let src = tcx.used_crate_source(cnum);\n-                if src.rlib.is_some() { continue }\n-                sess.err(&format!(\"crate `{}` required to be available in rlib format, \\\n-                                   but was not found in this form\",\n-                                  tcx.crate_name(cnum)));\n-            }\n-            return Vec::new();\n-        }\n-    }\n-\n-    let mut formats = FxHashMap::default();\n-\n-    // Sweep all crates for found dylibs. Add all dylibs, as well as their\n-    // dependencies, ensuring there are no conflicts. The only valid case for a\n-    // dependency to be relied upon twice is for both cases to rely on a dylib.\n-    for &cnum in tcx.crates().iter() {\n-        if tcx.dep_kind(cnum).macros_only() { continue }\n-        let name = tcx.crate_name(cnum);\n-        let src = tcx.used_crate_source(cnum);\n-        if src.dylib.is_some() {\n-            info!(\"adding dylib: {}\", name);\n-            add_library(tcx, cnum, RequireDynamic, &mut formats);\n-            let deps = tcx.dylib_dependency_formats(cnum);\n-            for &(depnum, style) in deps.iter() {\n-                info!(\"adding {:?}: {}\", style, tcx.crate_name(depnum));\n-                add_library(tcx, depnum, style, &mut formats);\n-            }\n-        }\n-    }\n-\n-    // Collect what we've got so far in the return vector.\n-    let last_crate = tcx.crates().len();\n-    let mut ret = (1..last_crate+1).map(|cnum| {\n-        match formats.get(&CrateNum::new(cnum)) {\n-            Some(&RequireDynamic) => Linkage::Dynamic,\n-            Some(&RequireStatic) => Linkage::IncludedFromDylib,\n-            None => Linkage::NotLinked,\n-        }\n-    }).collect::<Vec<_>>();\n-\n-    // Run through the dependency list again, and add any missing libraries as\n-    // static libraries.\n-    //\n-    // If the crate hasn't been included yet and it's not actually required\n-    // (e.g., it's an allocator) then we skip it here as well.\n-    for &cnum in tcx.crates().iter() {\n-        let src = tcx.used_crate_source(cnum);\n-        if src.dylib.is_none() &&\n-           !formats.contains_key(&cnum) &&\n-           tcx.dep_kind(cnum) == DepKind::Explicit {\n-            assert!(src.rlib.is_some() || src.rmeta.is_some());\n-            info!(\"adding staticlib: {}\", tcx.crate_name(cnum));\n-            add_library(tcx, cnum, RequireStatic, &mut formats);\n-            ret[cnum.as_usize() - 1] = Linkage::Static;\n-        }\n-    }\n-\n-    // We've gotten this far because we're emitting some form of a final\n-    // artifact which means that we may need to inject dependencies of some\n-    // form.\n-    //\n-    // Things like allocators and panic runtimes may not have been activated\n-    // quite yet, so do so here.\n-    activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n-                          &|cnum| tcx.is_panic_runtime(cnum));\n-\n-    // When dylib B links to dylib A, then when using B we must also link to A.\n-    // It could be the case, however, that the rlib for A is present (hence we\n-    // found metadata), but the dylib for A has since been removed.\n-    //\n-    // For situations like this, we perform one last pass over the dependencies,\n-    // making sure that everything is available in the requested format.\n-    for (cnum, kind) in ret.iter().enumerate() {\n-        let cnum = CrateNum::new(cnum + 1);\n-        let src = tcx.used_crate_source(cnum);\n-        match *kind {\n-            Linkage::NotLinked |\n-            Linkage::IncludedFromDylib => {}\n-            Linkage::Static if src.rlib.is_some() => continue,\n-            Linkage::Dynamic if src.dylib.is_some() => continue,\n-            kind => {\n-                let kind = match kind {\n-                    Linkage::Static => \"rlib\",\n-                    _ => \"dylib\",\n-                };\n-                sess.err(&format!(\"crate `{}` required to be available in {} format, \\\n-                                   but was not found in this form\",\n-                                  tcx.crate_name(cnum), kind));\n-            }\n-        }\n-    }\n-\n-    ret\n-}\n-\n-fn add_library(\n-    tcx: TyCtxt<'_>,\n-    cnum: CrateNum,\n-    link: LinkagePreference,\n-    m: &mut FxHashMap<CrateNum, LinkagePreference>,\n-) {\n-    match m.get(&cnum) {\n-        Some(&link2) => {\n-            // If the linkages differ, then we'd have two copies of the library\n-            // if we continued linking. If the linkages are both static, then we\n-            // would also have two copies of the library (static from two\n-            // different locations).\n-            //\n-            // This error is probably a little obscure, but I imagine that it\n-            // can be refined over time.\n-            if link2 != link || link == RequireStatic {\n-                tcx.sess.struct_err(&format!(\"cannot satisfy dependencies so `{}` only \\\n-                                              shows up once\", tcx.crate_name(cnum)))\n-                    .help(\"having upstream crates all available in one format \\\n-                           will likely make this go away\")\n-                    .emit();\n-            }\n-        }\n-        None => { m.insert(cnum, link); }\n-    }\n-}\n-\n-fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n-    let sess = &tcx.sess;\n-    let crates = cstore::used_crates(tcx, RequireStatic);\n-    if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n-        return None\n-    }\n-\n-    // All crates are available in an rlib format, so we're just going to link\n-    // everything in explicitly so long as it's actually required.\n-    let last_crate = tcx.crates().len();\n-    let mut ret = (1..last_crate+1).map(|cnum| {\n-        if tcx.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n-            Linkage::Static\n-        } else {\n-            Linkage::NotLinked\n-        }\n-    }).collect::<Vec<_>>();\n-\n-    // Our allocator/panic runtime may not have been linked above if it wasn't\n-    // explicitly linked, which is the case for any injected dependency. Handle\n-    // that here and activate them.\n-    activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n-                          &|cnum| tcx.is_panic_runtime(cnum));\n-\n-    Some(ret)\n-}\n-\n-// Given a list of how to link upstream dependencies so far, ensure that an\n-// injected dependency is activated. This will not do anything if one was\n-// transitively included already (e.g., via a dylib or explicitly so).\n-//\n-// If an injected dependency was not found then we're guaranteed the\n-// metadata::creader module has injected that dependency (not listed as\n-// a required dependency) in one of the session's field. If this field is not\n-// set then this compilation doesn't actually need the dependency and we can\n-// also skip this step entirely.\n-fn activate_injected_dep(injected: Option<CrateNum>,\n-                         list: &mut DependencyList,\n-                         replaces_injected: &dyn Fn(CrateNum) -> bool) {\n-    for (i, slot) in list.iter().enumerate() {\n-        let cnum = CrateNum::new(i + 1);\n-        if !replaces_injected(cnum) {\n-            continue\n-        }\n-        if *slot != Linkage::NotLinked {\n-            return\n-        }\n-    }\n-    if let Some(injected) = injected {\n-        let idx = injected.as_usize() - 1;\n-        assert_eq!(list[idx], Linkage::NotLinked);\n-        list[idx] = Linkage::Static;\n-    }\n-}\n-\n-// After the linkage for a crate has been determined we need to verify that\n-// there's only going to be one allocator in the output.\n-fn verify_ok(tcx: TyCtxt<'_>, list: &[Linkage]) {\n-    let sess = &tcx.sess;\n-    if list.len() == 0 {\n-        return\n-    }\n-    let mut panic_runtime = None;\n-    for (i, linkage) in list.iter().enumerate() {\n-        if let Linkage::NotLinked = *linkage {\n-            continue\n-        }\n-        let cnum = CrateNum::new(i + 1);\n-\n-        if tcx.is_panic_runtime(cnum) {\n-            if let Some((prev, _)) = panic_runtime {\n-                let prev_name = tcx.crate_name(prev);\n-                let cur_name = tcx.crate_name(cnum);\n-                sess.err(&format!(\"cannot link together two \\\n-                                   panic runtimes: {} and {}\",\n-                                  prev_name, cur_name));\n-            }\n-            panic_runtime = Some((cnum, tcx.panic_strategy(cnum)));\n-        }\n-    }\n-\n-    // If we found a panic runtime, then we know by this point that it's the\n-    // only one, but we perform validation here that all the panic strategy\n-    // compilation modes for the whole DAG are valid.\n-    if let Some((cnum, found_strategy)) = panic_runtime {\n-        let desired_strategy = sess.panic_strategy();\n-\n-        // First up, validate that our selected panic runtime is indeed exactly\n-        // our same strategy.\n-        if found_strategy != desired_strategy {\n-            sess.err(&format!(\"the linked panic runtime `{}` is \\\n-                               not compiled with this crate's \\\n-                               panic strategy `{}`\",\n-                              tcx.crate_name(cnum),\n-                              desired_strategy.desc()));\n-        }\n-\n-        // Next up, verify that all other crates are compatible with this panic\n-        // strategy. If the dep isn't linked, we ignore it, and if our strategy\n-        // is abort then it's compatible with everything. Otherwise all crates'\n-        // panic strategy must match our own.\n-        for (i, linkage) in list.iter().enumerate() {\n-            if let Linkage::NotLinked = *linkage {\n-                continue\n-            }\n-            if desired_strategy == PanicStrategy::Abort {\n-                continue\n-            }\n-            let cnum = CrateNum::new(i + 1);\n-            let found_strategy = tcx.panic_strategy(cnum);\n-            let is_compiler_builtins = tcx.is_compiler_builtins(cnum);\n-            if is_compiler_builtins || desired_strategy == found_strategy {\n-                continue\n-            }\n-\n-            sess.err(&format!(\"the crate `{}` is compiled with the \\\n-                               panic strategy `{}` which is \\\n-                               incompatible with this crate's \\\n-                               strategy of `{}`\",\n-                              tcx.crate_name(cnum),\n-                              found_strategy.desc(),\n-                              desired_strategy.desc()));\n-        }\n-    }\n-}"}, {"sha": "4a9fa57f34525a1114223fe72942c128e975509a", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "patch": "@@ -630,6 +630,10 @@ rustc_queries! {\n                                         -> &'tcx [(CrateNum, LinkagePreference)] {\n             desc { \"dylib dependency formats of crate\" }\n         }\n+\n+        query dependency_formats(_: CrateNum) -> Lrc<crate::middle::dependency_format::Dependencies> {\n+            desc { \"get the linkage format of all dependencies\" }\n+        }\n     }\n \n     Codegen {"}, {"sha": "a9a20a924347ca4bbd07fdc0b1b408a78fede58e", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "patch": "@@ -687,7 +687,7 @@ pub enum EntryFnType {\n \n impl_stable_hash_via_hash!(EntryFnType);\n \n-#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Debug)]\n+#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Debug, HashStable)]\n pub enum CrateType {\n     Executable,\n     Dylib,"}, {"sha": "8aca861d1f64d4e20c6386eaf12bc826449b1379", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "patch": "@@ -7,7 +7,6 @@ use rustc_data_structures::fingerprint::Fingerprint;\n \n use crate::lint;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n-use crate::middle::dependency_format;\n use crate::session::config::{OutputType, PrintRequest, SwitchWithOptPath};\n use crate::session::search_paths::{PathKind, SearchPath};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n@@ -91,7 +90,6 @@ pub struct Session {\n     pub plugin_llvm_passes: OneThread<RefCell<Vec<String>>>,\n     pub plugin_attributes: Lock<Vec<(Symbol, AttributeType)>>,\n     pub crate_types: Once<Vec<config::CrateType>>,\n-    pub dependency_formats: Once<dependency_format::Dependencies>,\n     /// The `crate_disambiguator` is constructed out of all the `-C metadata`\n     /// arguments passed to the compiler. Its value together with the crate-name\n     /// forms a unique global identifier for the crate. It is used to allow\n@@ -1247,7 +1245,6 @@ fn build_session_(\n         plugin_llvm_passes: OneThread::new(RefCell::new(Vec::new())),\n         plugin_attributes: Lock::new(Vec::new()),\n         crate_types: Once::new(),\n-        dependency_formats: Once::new(),\n         crate_disambiguator: Once::new(),\n         features: Once::new(),\n         recursion_limit: Once::new(),"}, {"sha": "3b7ae5e33d5e716e7d869d790617fa83a1ac969c", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "patch": "@@ -219,15 +219,24 @@ pub fn get_linker(sess: &Session, linker: &Path, flavor: LinkerFlavor) -> (PathB\n     (linker.to_path_buf(), cmd)\n }\n \n-pub fn each_linked_rlib(sess: &Session,\n-                               info: &CrateInfo,\n-                               f: &mut dyn FnMut(CrateNum, &Path)) -> Result<(), String> {\n+pub fn each_linked_rlib(\n+    info: &CrateInfo,\n+    f: &mut dyn FnMut(CrateNum, &Path),\n+) -> Result<(), String> {\n     let crates = info.used_crates_static.iter();\n-    let fmts = sess.dependency_formats.borrow();\n-    let fmts = fmts.get(&config::CrateType::Executable)\n-                   .or_else(|| fmts.get(&config::CrateType::Staticlib))\n-                   .or_else(|| fmts.get(&config::CrateType::Cdylib))\n-                   .or_else(|| fmts.get(&config::CrateType::ProcMacro));\n+    let mut fmts = None;\n+    for (ty, list) in info.dependency_formats.iter() {\n+        match ty {\n+            config::CrateType::Executable |\n+            config::CrateType::Staticlib |\n+            config::CrateType::Cdylib |\n+            config::CrateType::ProcMacro => {\n+                fmts = Some(list);\n+                break;\n+            }\n+            _ => {}\n+        }\n+    }\n     let fmts = match fmts {\n         Some(f) => f,\n         None => return Err(\"could not find formats for rlibs\".to_string())\n@@ -406,7 +415,7 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(sess: &'a Session,\n                            tempdir);\n     let mut all_native_libs = vec![];\n \n-    let res = each_linked_rlib(sess, &codegen_results.crate_info, &mut |cnum, path| {\n+    let res = each_linked_rlib(&codegen_results.crate_info, &mut |cnum, path| {\n         let name = &codegen_results.crate_info.crate_name[&cnum];\n         let native_libs = &codegen_results.crate_info.native_libraries[&cnum];\n \n@@ -1294,11 +1303,13 @@ pub fn add_local_native_libraries(cmd: &mut dyn Linker,\n // Rust crates are not considered at all when creating an rlib output. All\n // dependencies will be linked when producing the final output (instead of\n // the intermediate rlib version)\n-fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n-                            sess: &'a Session,\n-                            codegen_results: &CodegenResults,\n-                            crate_type: config::CrateType,\n-                            tmpdir: &Path) {\n+fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n+    cmd: &mut dyn Linker,\n+    sess: &'a Session,\n+    codegen_results: &CodegenResults,\n+    crate_type: config::CrateType,\n+    tmpdir: &Path,\n+) {\n     // All of the heavy lifting has previously been accomplished by the\n     // dependency_format module of the compiler. This is just crawling the\n     // output of that module, adding crates as necessary.\n@@ -1307,8 +1318,10 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n     // will slurp up the object files inside), and linking to a dynamic library\n     // involves just passing the right -l flag.\n \n-    let formats = sess.dependency_formats.borrow();\n-    let data = formats.get(&crate_type).unwrap();\n+    let (_, data) = codegen_results.crate_info.dependency_formats\n+        .iter()\n+        .find(|(ty, _)| *ty == crate_type)\n+        .expect(\"failed to find crate type in dependency format list\");\n \n     // Invoke get_used_crates to ensure that we get a topological sorting of\n     // crates.\n@@ -1620,10 +1633,12 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(cmd: &mut dyn Linker,\n // generic function calls a native function, then the generic function must\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n-pub fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n-                                 sess: &Session,\n-                                 codegen_results: &CodegenResults,\n-                                 crate_type: config::CrateType) {\n+pub fn add_upstream_native_libraries(\n+    cmd: &mut dyn Linker,\n+    sess: &Session,\n+    codegen_results: &CodegenResults,\n+    crate_type: config::CrateType,\n+) {\n     // Be sure to use a topological sorting of crates because there may be\n     // interdependencies between native libraries. When passing -nodefaultlibs,\n     // for example, almost all native libraries depend on libc, so we have to\n@@ -1633,8 +1648,10 @@ pub fn add_upstream_native_libraries(cmd: &mut dyn Linker,\n     // This passes RequireStatic, but the actual requirement doesn't matter,\n     // we're just getting an ordering of crate numbers, we're not worried about\n     // the paths.\n-    let formats = sess.dependency_formats.borrow();\n-    let data = formats.get(&crate_type).unwrap();\n+    let (_, data) = codegen_results.crate_info.dependency_formats\n+        .iter()\n+        .find(|(ty, _)| *ty == crate_type)\n+        .expect(\"failed to find crate type in dependency format list\");\n \n     let crates = &codegen_results.crate_info.used_crates_static;\n     for &(cnum, _) in crates {"}, {"sha": "940a9a72bf6d4ebb2761df7c9003fa3ae3e63cb2", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "patch": "@@ -1092,10 +1092,16 @@ fn exported_symbols(tcx: TyCtxt<'_>, crate_type: CrateType) -> Vec<String> {\n         }\n     }\n \n-    let formats = tcx.sess.dependency_formats.borrow();\n-    let deps = formats[&crate_type].iter();\n+    let formats = tcx.dependency_formats(LOCAL_CRATE);\n+    let deps = formats.iter().filter_map(|(t, list)| {\n+        if *t == crate_type {\n+            Some(list)\n+        } else {\n+            None\n+        }\n+    }).next().unwrap();\n \n-    for (index, dep_format) in deps.enumerate() {\n+    for (index, dep_format) in deps.iter().enumerate() {\n         let cnum = CrateNum::new(index + 1);\n         // For each dependency that we are linking to statically ...\n         if *dep_format == Linkage::Static {"}, {"sha": "1a2c23ae0d4f7415b84ae980f59ae60524227d75", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "patch": "@@ -1048,7 +1048,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n     }).expect(\"failed to spawn helper thread\");\n \n     let mut each_linked_rlib_for_lto = Vec::new();\n-    drop(link::each_linked_rlib(sess, crate_info, &mut |cnum, path| {\n+    drop(link::each_linked_rlib(crate_info, &mut |cnum, path| {\n         if link::ignored_for_lto(sess, crate_info, cnum) {\n             return\n         }"}, {"sha": "98d3022a4185d4a826494ceeeec4df38bfecec0c", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "patch": "@@ -539,7 +539,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // linkage, then it's already got an allocator shim and we'll be using that\n     // one instead. If nothing exists then it's our job to generate the\n     // allocator!\n-    let any_dynamic_crate = tcx.sess.dependency_formats.borrow()\n+    let any_dynamic_crate = tcx.dependency_formats(LOCAL_CRATE)\n         .iter()\n         .any(|(_, list)| {\n             use rustc::middle::dependency_format::Linkage;\n@@ -731,6 +731,7 @@ impl CrateInfo {\n             used_crate_source: Default::default(),\n             lang_item_to_crate: Default::default(),\n             missing_lang_items: Default::default(),\n+            dependency_formats: tcx.dependency_formats(LOCAL_CRATE),\n         };\n         let lang_items = tcx.lang_items();\n "}, {"sha": "161d3ce61f0a6f083f988b5730f331ffebb215ca", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "patch": "@@ -33,6 +33,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::svh::Svh;\n use rustc::middle::cstore::{LibSource, CrateSource, NativeLibrary};\n+use rustc::middle::dependency_format::Dependencies;\n use syntax_pos::symbol::Symbol;\n \n mod error_codes;\n@@ -142,6 +143,7 @@ pub struct CrateInfo {\n     pub used_crates_dynamic: Vec<(CrateNum, LibSource)>,\n     pub lang_item_to_crate: FxHashMap<LangItem, CrateNum>,\n     pub missing_lang_items: FxHashMap<CrateNum, Vec<LangItem>>,\n+    pub dependency_formats: Lrc<Dependencies>,\n }\n \n "}, {"sha": "102ea690f5ac959786f41335b872f331509fc09a", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "patch": "@@ -1079,10 +1079,6 @@ pub fn start_codegen<'tcx>(\n         tcx.print_debug_stats();\n     }\n \n-    time(tcx.sess, \"resolving dependency formats\", || {\n-        middle::dependency_format::calculate(tcx)\n-    });\n-\n     let (metadata, need_metadata_module) = time(tcx.sess, \"metadata encoding and writing\", || {\n         encode_and_write_metadata(tcx, outputs)\n     });"}, {"sha": "4a81fd3b320843ae8689aef0f4a41f126b9303b0", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "patch": "@@ -370,6 +370,11 @@ pub fn provide(providers: &mut Providers<'_>) {\n             tcx.arena.alloc(visible_parent_map)\n         },\n \n+        dependency_formats: |tcx, cnum| {\n+            assert_eq!(cnum, LOCAL_CRATE);\n+            Lrc::new(crate::dependency_format::calculate(tcx))\n+        },\n+\n         ..*providers\n     };\n }"}, {"sha": "9de326a67b4236f708b414a985a3e468a78e46c5", "filename": "src/librustc_metadata/dependency_format.rs", "status": "added", "additions": 371, "deletions": 0, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_metadata%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_metadata%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdependency_format.rs?ref=5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "patch": "@@ -0,0 +1,371 @@\n+//! Resolution of mixing rlibs and dylibs\n+//!\n+//! When producing a final artifact, such as a dynamic library, the compiler has\n+//! a choice between linking an rlib or linking a dylib of all upstream\n+//! dependencies. The linking phase must guarantee, however, that a library only\n+//! show up once in the object file. For example, it is illegal for library A to\n+//! be statically linked to B and C in separate dylibs, and then link B and C\n+//! into a crate D (because library A appears twice).\n+//!\n+//! The job of this module is to calculate what format each upstream crate\n+//! should be used when linking each output type requested in this session. This\n+//! generally follows this set of rules:\n+//!\n+//!     1. Each library must appear exactly once in the output.\n+//!     2. Each rlib contains only one library (it's just an object file)\n+//!     3. Each dylib can contain more than one library (due to static linking),\n+//!        and can also bring in many dynamic dependencies.\n+//!\n+//! With these constraints in mind, it's generally a very difficult problem to\n+//! find a solution that's not \"all rlibs\" or \"all dylibs\". I have suspicions\n+//! that NP-ness may come into the picture here...\n+//!\n+//! The current selection algorithm below looks mostly similar to:\n+//!\n+//!     1. If static linking is required, then require all upstream dependencies\n+//!        to be available as rlibs. If not, generate an error.\n+//!     2. If static linking is requested (generating an executable), then\n+//!        attempt to use all upstream dependencies as rlibs. If any are not\n+//!        found, bail out and continue to step 3.\n+//!     3. Static linking has failed, at least one library must be dynamically\n+//!        linked. Apply a heuristic by greedily maximizing the number of\n+//!        dynamically linked libraries.\n+//!     4. Each upstream dependency available as a dynamic library is\n+//!        registered. The dependencies all propagate, adding to a map. It is\n+//!        possible for a dylib to add a static library as a dependency, but it\n+//!        is illegal for two dylibs to add the same static library as a\n+//!        dependency. The same dylib can be added twice. Additionally, it is\n+//!        illegal to add a static dependency when it was previously found as a\n+//!        dylib (and vice versa)\n+//!     5. After all dynamic dependencies have been traversed, re-traverse the\n+//!        remaining dependencies and add them statically (if they haven't been\n+//!        added already).\n+//!\n+//! While not perfect, this algorithm should help support use-cases such as leaf\n+//! dependencies being static while the larger tree of inner dependencies are\n+//! all dynamic. This isn't currently very well battle tested, so it will likely\n+//! fall short in some use cases.\n+//!\n+//! Currently, there is no way to specify the preference of linkage with a\n+//! particular library (other than a global dynamic/static switch).\n+//! Additionally, the algorithm is geared towards finding *any* solution rather\n+//! than finding a number of solutions (there are normally quite a few).\n+\n+use rustc::hir::def_id::CrateNum;\n+use rustc::middle::cstore::LinkagePreference::{self, RequireStatic, RequireDynamic};\n+use rustc::middle::cstore::{self, DepKind};\n+use rustc::middle::dependency_format::{DependencyList, Dependencies, Linkage};\n+use rustc::session::config;\n+use rustc::ty::TyCtxt;\n+use rustc::util::nodemap::FxHashMap;\n+use rustc_target::spec::PanicStrategy;\n+\n+pub fn calculate(tcx: TyCtxt<'_>) -> Dependencies {\n+    tcx.sess.crate_types.borrow().iter().map(|&ty| {\n+        let linkage = calculate_type(tcx, ty);\n+        verify_ok(tcx, &linkage);\n+        (ty, linkage)\n+    }).collect::<Vec<_>>()\n+}\n+\n+fn calculate_type(tcx: TyCtxt<'_>, ty: config::CrateType) -> DependencyList {\n+    let sess = &tcx.sess;\n+\n+    if !sess.opts.output_types.should_codegen() {\n+        return Vec::new();\n+    }\n+\n+    let preferred_linkage = match ty {\n+        // cdylibs must have all static dependencies.\n+        config::CrateType::Cdylib => Linkage::Static,\n+\n+        // Generating a dylib without `-C prefer-dynamic` means that we're going\n+        // to try to eagerly statically link all dependencies. This is normally\n+        // done for end-product dylibs, not intermediate products.\n+        config::CrateType::Dylib if !sess.opts.cg.prefer_dynamic => Linkage::Static,\n+        config::CrateType::Dylib => Linkage::Dynamic,\n+\n+        // If the global prefer_dynamic switch is turned off, or the final\n+        // executable will be statically linked, prefer static crate linkage.\n+        config::CrateType::Executable if !sess.opts.cg.prefer_dynamic ||\n+            sess.crt_static() => Linkage::Static,\n+        config::CrateType::Executable => Linkage::Dynamic,\n+\n+        // proc-macro crates are mostly cdylibs, but we also need metadata.\n+        config::CrateType::ProcMacro => Linkage::Static,\n+\n+        // No linkage happens with rlibs, we just needed the metadata (which we\n+        // got long ago), so don't bother with anything.\n+        config::CrateType::Rlib => Linkage::NotLinked,\n+\n+        // staticlibs must have all static dependencies.\n+        config::CrateType::Staticlib => Linkage::Static,\n+    };\n+\n+    if preferred_linkage == Linkage::NotLinked {\n+        // If the crate is not linked, there are no link-time dependencies.\n+        return Vec::new();\n+    }\n+\n+    if preferred_linkage == Linkage::Static {\n+        // Attempt static linkage first. For dylibs and executables, we may be\n+        // able to retry below with dynamic linkage.\n+        if let Some(v) = attempt_static(tcx) {\n+            return v;\n+        }\n+\n+        // Staticlibs, cdylibs, and static executables must have all static\n+        // dependencies. If any are not found, generate some nice pretty errors.\n+        if ty == config::CrateType::Cdylib || ty == config::CrateType::Staticlib ||\n+                (ty == config::CrateType::Executable && sess.crt_static() &&\n+                !sess.target.target.options.crt_static_allows_dylibs) {\n+            for &cnum in tcx.crates().iter() {\n+                if tcx.dep_kind(cnum).macros_only() { continue }\n+                let src = tcx.used_crate_source(cnum);\n+                if src.rlib.is_some() { continue }\n+                sess.err(&format!(\"crate `{}` required to be available in rlib format, \\\n+                                   but was not found in this form\",\n+                                  tcx.crate_name(cnum)));\n+            }\n+            return Vec::new();\n+        }\n+    }\n+\n+    let mut formats = FxHashMap::default();\n+\n+    // Sweep all crates for found dylibs. Add all dylibs, as well as their\n+    // dependencies, ensuring there are no conflicts. The only valid case for a\n+    // dependency to be relied upon twice is for both cases to rely on a dylib.\n+    for &cnum in tcx.crates().iter() {\n+        if tcx.dep_kind(cnum).macros_only() { continue }\n+        let name = tcx.crate_name(cnum);\n+        let src = tcx.used_crate_source(cnum);\n+        if src.dylib.is_some() {\n+            log::info!(\"adding dylib: {}\", name);\n+            add_library(tcx, cnum, RequireDynamic, &mut formats);\n+            let deps = tcx.dylib_dependency_formats(cnum);\n+            for &(depnum, style) in deps.iter() {\n+                log::info!(\"adding {:?}: {}\", style, tcx.crate_name(depnum));\n+                add_library(tcx, depnum, style, &mut formats);\n+            }\n+        }\n+    }\n+\n+    // Collect what we've got so far in the return vector.\n+    let last_crate = tcx.crates().len();\n+    let mut ret = (1..last_crate+1).map(|cnum| {\n+        match formats.get(&CrateNum::new(cnum)) {\n+            Some(&RequireDynamic) => Linkage::Dynamic,\n+            Some(&RequireStatic) => Linkage::IncludedFromDylib,\n+            None => Linkage::NotLinked,\n+        }\n+    }).collect::<Vec<_>>();\n+\n+    // Run through the dependency list again, and add any missing libraries as\n+    // static libraries.\n+    //\n+    // If the crate hasn't been included yet and it's not actually required\n+    // (e.g., it's an allocator) then we skip it here as well.\n+    for &cnum in tcx.crates().iter() {\n+        let src = tcx.used_crate_source(cnum);\n+        if src.dylib.is_none() &&\n+           !formats.contains_key(&cnum) &&\n+           tcx.dep_kind(cnum) == DepKind::Explicit {\n+            assert!(src.rlib.is_some() || src.rmeta.is_some());\n+            log::info!(\"adding staticlib: {}\", tcx.crate_name(cnum));\n+            add_library(tcx, cnum, RequireStatic, &mut formats);\n+            ret[cnum.as_usize() - 1] = Linkage::Static;\n+        }\n+    }\n+\n+    // We've gotten this far because we're emitting some form of a final\n+    // artifact which means that we may need to inject dependencies of some\n+    // form.\n+    //\n+    // Things like allocators and panic runtimes may not have been activated\n+    // quite yet, so do so here.\n+    activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n+                          &|cnum| tcx.is_panic_runtime(cnum));\n+\n+    // When dylib B links to dylib A, then when using B we must also link to A.\n+    // It could be the case, however, that the rlib for A is present (hence we\n+    // found metadata), but the dylib for A has since been removed.\n+    //\n+    // For situations like this, we perform one last pass over the dependencies,\n+    // making sure that everything is available in the requested format.\n+    for (cnum, kind) in ret.iter().enumerate() {\n+        let cnum = CrateNum::new(cnum + 1);\n+        let src = tcx.used_crate_source(cnum);\n+        match *kind {\n+            Linkage::NotLinked |\n+            Linkage::IncludedFromDylib => {}\n+            Linkage::Static if src.rlib.is_some() => continue,\n+            Linkage::Dynamic if src.dylib.is_some() => continue,\n+            kind => {\n+                let kind = match kind {\n+                    Linkage::Static => \"rlib\",\n+                    _ => \"dylib\",\n+                };\n+                sess.err(&format!(\"crate `{}` required to be available in {} format, \\\n+                                   but was not found in this form\",\n+                                  tcx.crate_name(cnum), kind));\n+            }\n+        }\n+    }\n+\n+    ret\n+}\n+\n+fn add_library(\n+    tcx: TyCtxt<'_>,\n+    cnum: CrateNum,\n+    link: LinkagePreference,\n+    m: &mut FxHashMap<CrateNum, LinkagePreference>,\n+) {\n+    match m.get(&cnum) {\n+        Some(&link2) => {\n+            // If the linkages differ, then we'd have two copies of the library\n+            // if we continued linking. If the linkages are both static, then we\n+            // would also have two copies of the library (static from two\n+            // different locations).\n+            //\n+            // This error is probably a little obscure, but I imagine that it\n+            // can be refined over time.\n+            if link2 != link || link == RequireStatic {\n+                tcx.sess.struct_err(&format!(\"cannot satisfy dependencies so `{}` only \\\n+                                              shows up once\", tcx.crate_name(cnum)))\n+                    .help(\"having upstream crates all available in one format \\\n+                           will likely make this go away\")\n+                    .emit();\n+            }\n+        }\n+        None => { m.insert(cnum, link); }\n+    }\n+}\n+\n+fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n+    let sess = &tcx.sess;\n+    let crates = cstore::used_crates(tcx, RequireStatic);\n+    if !crates.iter().by_ref().all(|&(_, ref p)| p.is_some()) {\n+        return None\n+    }\n+\n+    // All crates are available in an rlib format, so we're just going to link\n+    // everything in explicitly so long as it's actually required.\n+    let last_crate = tcx.crates().len();\n+    let mut ret = (1..last_crate+1).map(|cnum| {\n+        if tcx.dep_kind(CrateNum::new(cnum)) == DepKind::Explicit {\n+            Linkage::Static\n+        } else {\n+            Linkage::NotLinked\n+        }\n+    }).collect::<Vec<_>>();\n+\n+    // Our allocator/panic runtime may not have been linked above if it wasn't\n+    // explicitly linked, which is the case for any injected dependency. Handle\n+    // that here and activate them.\n+    activate_injected_dep(*sess.injected_panic_runtime.get(), &mut ret,\n+                          &|cnum| tcx.is_panic_runtime(cnum));\n+\n+    Some(ret)\n+}\n+\n+// Given a list of how to link upstream dependencies so far, ensure that an\n+// injected dependency is activated. This will not do anything if one was\n+// transitively included already (e.g., via a dylib or explicitly so).\n+//\n+// If an injected dependency was not found then we're guaranteed the\n+// metadata::creader module has injected that dependency (not listed as\n+// a required dependency) in one of the session's field. If this field is not\n+// set then this compilation doesn't actually need the dependency and we can\n+// also skip this step entirely.\n+fn activate_injected_dep(injected: Option<CrateNum>,\n+                         list: &mut DependencyList,\n+                         replaces_injected: &dyn Fn(CrateNum) -> bool) {\n+    for (i, slot) in list.iter().enumerate() {\n+        let cnum = CrateNum::new(i + 1);\n+        if !replaces_injected(cnum) {\n+            continue\n+        }\n+        if *slot != Linkage::NotLinked {\n+            return\n+        }\n+    }\n+    if let Some(injected) = injected {\n+        let idx = injected.as_usize() - 1;\n+        assert_eq!(list[idx], Linkage::NotLinked);\n+        list[idx] = Linkage::Static;\n+    }\n+}\n+\n+// After the linkage for a crate has been determined we need to verify that\n+// there's only going to be one allocator in the output.\n+fn verify_ok(tcx: TyCtxt<'_>, list: &[Linkage]) {\n+    let sess = &tcx.sess;\n+    if list.len() == 0 {\n+        return\n+    }\n+    let mut panic_runtime = None;\n+    for (i, linkage) in list.iter().enumerate() {\n+        if let Linkage::NotLinked = *linkage {\n+            continue\n+        }\n+        let cnum = CrateNum::new(i + 1);\n+\n+        if tcx.is_panic_runtime(cnum) {\n+            if let Some((prev, _)) = panic_runtime {\n+                let prev_name = tcx.crate_name(prev);\n+                let cur_name = tcx.crate_name(cnum);\n+                sess.err(&format!(\"cannot link together two \\\n+                                   panic runtimes: {} and {}\",\n+                                  prev_name, cur_name));\n+            }\n+            panic_runtime = Some((cnum, tcx.panic_strategy(cnum)));\n+        }\n+    }\n+\n+    // If we found a panic runtime, then we know by this point that it's the\n+    // only one, but we perform validation here that all the panic strategy\n+    // compilation modes for the whole DAG are valid.\n+    if let Some((cnum, found_strategy)) = panic_runtime {\n+        let desired_strategy = sess.panic_strategy();\n+\n+        // First up, validate that our selected panic runtime is indeed exactly\n+        // our same strategy.\n+        if found_strategy != desired_strategy {\n+            sess.err(&format!(\"the linked panic runtime `{}` is \\\n+                               not compiled with this crate's \\\n+                               panic strategy `{}`\",\n+                              tcx.crate_name(cnum),\n+                              desired_strategy.desc()));\n+        }\n+\n+        // Next up, verify that all other crates are compatible with this panic\n+        // strategy. If the dep isn't linked, we ignore it, and if our strategy\n+        // is abort then it's compatible with everything. Otherwise all crates'\n+        // panic strategy must match our own.\n+        for (i, linkage) in list.iter().enumerate() {\n+            if let Linkage::NotLinked = *linkage {\n+                continue\n+            }\n+            if desired_strategy == PanicStrategy::Abort {\n+                continue\n+            }\n+            let cnum = CrateNum::new(i + 1);\n+            let found_strategy = tcx.panic_strategy(cnum);\n+            let is_compiler_builtins = tcx.is_compiler_builtins(cnum);\n+            if is_compiler_builtins || desired_strategy == found_strategy {\n+                continue\n+            }\n+\n+            sess.err(&format!(\"the crate `{}` is compiled with the \\\n+                               panic strategy `{}` which is \\\n+                               incompatible with this crate's \\\n+                               strategy of `{}`\",\n+                              tcx.crate_name(cnum),\n+                              found_strategy.desc(),\n+                              desired_strategy.desc()));\n+        }\n+    }\n+}\n+"}, {"sha": "be083cf6020eaddf3e4d55edcc0b55f2be779e4c", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "patch": "@@ -1649,20 +1649,22 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_dylib_dependency_formats(&mut self) -> Lazy<[Option<LinkagePreference>]> {\n-        match self.tcx.sess.dependency_formats.borrow().get(&config::CrateType::Dylib) {\n-            Some(arr) => {\n-                self.lazy(arr.iter().map(|slot| {\n-                    match *slot {\n-                        Linkage::NotLinked |\n-                        Linkage::IncludedFromDylib => None,\n-\n-                        Linkage::Dynamic => Some(LinkagePreference::RequireDynamic),\n-                        Linkage::Static => Some(LinkagePreference::RequireStatic),\n-                    }\n-                }))\n+        let formats = self.tcx.dependency_formats(LOCAL_CRATE);\n+        for (ty, arr) in formats.iter() {\n+            if *ty != config::CrateType::Dylib {\n+                continue;\n             }\n-            None => Lazy::empty(),\n+            return self.lazy(arr.iter().map(|slot| {\n+                match *slot {\n+                    Linkage::NotLinked |\n+                    Linkage::IncludedFromDylib => None,\n+\n+                    Linkage::Dynamic => Some(LinkagePreference::RequireDynamic),\n+                    Linkage::Static => Some(LinkagePreference::RequireStatic),\n+                }\n+            }));\n         }\n+        Lazy::empty()\n     }\n \n     fn encode_info_for_foreign_item(&mut self,"}, {"sha": "9273b064ba9ceecc08821cc5adada0c484d699d7", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d531aeaf46451f999aea0f7c9ba08016b9ee3eb/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=5d531aeaf46451f999aea0f7c9ba08016b9ee3eb", "patch": "@@ -32,6 +32,7 @@ mod schema;\n mod native_libs;\n mod link_args;\n mod foreign_modules;\n+mod dependency_format;\n \n pub mod creader;\n pub mod cstore;"}]}