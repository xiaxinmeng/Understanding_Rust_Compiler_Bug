{"sha": "ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmOTFjZGIxNDBkN2RmZmE0YjA0ZjQyYWIwYmMwMmRjMjU3OTQwZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-18T18:54:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-18T18:54:52Z"}, "message": "Auto merge of #29973 - petrochenkov:privinpub, r=nikomatsakis\n\nSome notes:\nThis patch enforces the rules from [RFC 136](https://github.com/rust-lang/rfcs/blob/master/text/0136-no-privates-in-public.md) and makes \"private in public\" a module-level concept and not crate-level. Only `pub` annotations are used by the new algorithm, crate-level exported node set produced by `EmbargoVisitor` is not used. The error messages are tweaked accordingly and don't use the word \"exported\" to avoid confusing people (https://github.com/rust-lang/rust/issues/29668).\n\nThe old algorithm tried to be extra smart with impls, but it mostly led to unpredictable behavior and bugs like https://github.com/rust-lang/rust/issues/28325.\nThe new algorithm tries to be as simple as possible - an impl is considered public iff its type is public and its trait is public (if presents).\nA type or trait is considered public if all its components are public, [complications](https://internals.rust-lang.org/t/limits-of-type-inference-smartness/2919) with private types leaking to other crates/modules through trait impls and type inference are deliberately ignored so far.\n\nThe new algorithm is not recursive and uses the nice new facility `Crate::visit_all_items`!\n\nObsolete pre-1.0 feature `visible_private_types` is removed.\n\nThis is a [breaking-change].\nThe two main vectors of breakage are type aliases (https://github.com/rust-lang/rust/issues/28450) and impls (https://github.com/rust-lang/rust/issues/28325).\nI need some statistics from a crater run (cc @alexcrichton) to decide on the breakage mitigation strategy.\nUPDATE: All the new errors are reported as warnings controlled by a lint `private_in_public` and lint group `future_incompatible`, but the intent is to make them hard errors eventually.\n\nCloses https://github.com/rust-lang/rust/issues/28325\nCloses https://github.com/rust-lang/rust/issues/28450\nCloses https://github.com/rust-lang/rust/issues/29524\nCloses https://github.com/rust-lang/rust/issues/29627\nCloses https://github.com/rust-lang/rust/issues/29668\nCloses https://github.com/rust-lang/rust/issues/30055\n\nr? @nikomatsakis", "tree": {"sha": "440d7f10732b40ed272fbadef1b5c580b1320a2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/440d7f10732b40ed272fbadef1b5c580b1320a2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "html_url": "https://github.com/rust-lang/rust/commit/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29ea4eef9fa6e36f40bc1f31eb1e56bf5941ee72", "url": "https://api.github.com/repos/rust-lang/rust/commits/29ea4eef9fa6e36f40bc1f31eb1e56bf5941ee72", "html_url": "https://github.com/rust-lang/rust/commit/29ea4eef9fa6e36f40bc1f31eb1e56bf5941ee72"}, {"sha": "785cbe02008985f98fee2a013f2d308207ca596f", "url": "https://api.github.com/repos/rust-lang/rust/commits/785cbe02008985f98fee2a013f2d308207ca596f", "html_url": "https://github.com/rust-lang/rust/commit/785cbe02008985f98fee2a013f2d308207ca596f"}], "stats": {"total": 1128, "additions": 808, "deletions": 320}, "files": [{"sha": "a722c0e38f4c09b5ad53063a0d5a5dbee3b9ef27", "filename": "src/doc/reference.md", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -2372,10 +2372,6 @@ The currently implemented features of the reference compiler are:\n                    Such items should not be allowed by the compiler to exist,\n                    so if you need this there probably is a compiler bug.\n \n-* `visible_private_types` - Allows public APIs to expose otherwise private\n-                            types, e.g. as the return type of a public function.\n-                            This capability may be removed in the future.\n-\n * `allow_internal_unstable` - Allows `macro_rules!` macros to be tagged with the\n                               `#[allow_internal_unstable]` attribute, designed\n                               to allow `std` macros to call"}, {"sha": "e55b1597a21b867ac355f83f02da6fdc6e5cdc02", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -78,7 +78,7 @@ pub struct Node<K, V> {\n     _capacity: usize,\n }\n \n-struct NodeSlice<'a, K: 'a, V: 'a> {\n+pub struct NodeSlice<'a, K: 'a, V: 'a> {\n     keys: &'a [K],\n     vals: &'a [V],\n     pub edges: &'a [Node<K, V>],\n@@ -87,7 +87,7 @@ struct NodeSlice<'a, K: 'a, V: 'a> {\n     has_edges: bool,\n }\n \n-struct MutNodeSlice<'a, K: 'a, V: 'a> {\n+pub struct MutNodeSlice<'a, K: 'a, V: 'a> {\n     keys: &'a [K],\n     vals: &'a mut [V],\n     pub edges: &'a mut [Node<K, V>],\n@@ -1344,7 +1344,7 @@ fn min_load_from_capacity(cap: usize) -> usize {\n /// A trait for pairs of `Iterator`s, one over edges and the other over key/value pairs. This is\n /// necessary, as the `MoveTraversalImpl` needs to have a destructor that deallocates the `Node`,\n /// and a pair of `Iterator`s would require two independent destructors.\n-trait TraversalImpl {\n+pub trait TraversalImpl {\n     type Item;\n     type Edge;\n \n@@ -1358,7 +1358,7 @@ trait TraversalImpl {\n /// A `TraversalImpl` that actually is backed by two iterators. This works in the non-moving case,\n /// as no deallocation needs to be done.\n #[derive(Clone)]\n-struct ElemsAndEdges<Elems, Edges>(Elems, Edges);\n+pub struct ElemsAndEdges<Elems, Edges>(Elems, Edges);\n \n impl<K, V, E, Elems: DoubleEndedIterator, Edges: DoubleEndedIterator>\n         TraversalImpl for ElemsAndEdges<Elems, Edges>\n@@ -1375,7 +1375,7 @@ impl<K, V, E, Elems: DoubleEndedIterator, Edges: DoubleEndedIterator>\n }\n \n /// A `TraversalImpl` taking a `Node` by value.\n-struct MoveTraversalImpl<K, V> {\n+pub struct MoveTraversalImpl<K, V> {\n     keys: RawItems<K>,\n     vals: RawItems<V>,\n     edges: RawItems<Node<K, V>>,\n@@ -1436,7 +1436,7 @@ impl<K, V> Drop for MoveTraversalImpl<K, V> {\n \n /// An abstraction over all the different kinds of traversals a node supports\n #[derive(Clone)]\n-struct AbsTraversal<Impl> {\n+pub struct AbsTraversal<Impl> {\n     inner: Impl,\n     head_is_edge: bool,\n     tail_is_edge: bool,"}, {"sha": "2c5c664566a38e8fcb34ec23ccf5dccc18984fc5", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -117,6 +117,13 @@ declare_lint! {\n     Allow,\n     \"detects trivial casts of numeric types which could be removed\"\n }\n+\n+declare_lint! {\n+    pub PRIVATE_IN_PUBLIC,\n+    Warn,\n+    \"detect private items in public interfaces not caught by the old implementation\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -141,6 +148,7 @@ impl LintPass for HardwiredLints {\n             FAT_PTR_TRANSMUTES,\n             TRIVIAL_CASTS,\n             TRIVIAL_NUMERIC_CASTS,\n+            PRIVATE_IN_PUBLIC,\n             CONST_ERR\n         )\n     }"}, {"sha": "1d0c616c3b71b631424b6a389c82988e48c1b812", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -146,6 +146,9 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     UNUSED_MUT, UNREACHABLE_CODE, UNUSED_MUST_USE,\n                     UNUSED_UNSAFE, PATH_STATEMENTS, UNUSED_ATTRIBUTES);\n \n+    add_lint_group!(sess, \"future_incompatible\",\n+                    PRIVATE_IN_PUBLIC);\n+\n     // We have one lint pass defined specially\n     store.register_late_pass(sess, false, box lint::GatherNodeLevels);\n "}, {"sha": "a02ed06ad099e4e77e50cc935e19f0c3d53db833", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -209,7 +209,7 @@ struct ArmBlocks {\n }\n \n #[derive(Clone, Debug)]\n-struct Candidate<'pat, 'tcx:'pat> {\n+pub struct Candidate<'pat, 'tcx:'pat> {\n     // all of these must be satisfied...\n     match_pairs: Vec<MatchPair<'pat, 'tcx>>,\n \n@@ -235,7 +235,7 @@ struct Binding<'tcx> {\n }\n \n #[derive(Clone, Debug)]\n-struct MatchPair<'pat, 'tcx:'pat> {\n+pub struct MatchPair<'pat, 'tcx:'pat> {\n     // this lvalue...\n     lvalue: Lvalue<'tcx>,\n \n@@ -278,7 +278,7 @@ enum TestKind<'tcx> {\n }\n \n #[derive(Debug)]\n-struct Test<'tcx> {\n+pub struct Test<'tcx> {\n     span: Span,\n     kind: TestKind<'tcx>,\n }"}, {"sha": "bd94f4e5bf2577e411fe73793a0f2e6b6deeb38d", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -18,7 +18,7 @@ use rustc_front::hir;\n use syntax::ast;\n use syntax::codemap::Span;\n \n-struct Builder<'a, 'tcx: 'a> {\n+pub struct Builder<'a, 'tcx: 'a> {\n     hir: Cx<'a, 'tcx>,\n     cfg: CFG<'tcx>,\n     scopes: Vec<scope::Scope<'tcx>>,\n@@ -40,7 +40,7 @@ struct CFG<'tcx> {\n // convenient.\n \n #[must_use] // if you don't use one of these results, you're leaving a dangling edge\n-struct BlockAnd<T>(BasicBlock, T);\n+pub struct BlockAnd<T>(BasicBlock, T);\n \n trait BlockAndExtension {\n     fn and<T>(self, v: T) -> BlockAnd<T>;"}, {"sha": "3fbe3bc200534ac4a93173652b28a653af81221f", "filename": "src/librustc_privacy/diagnostics.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_privacy%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_privacy%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Fdiagnostics.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -21,13 +21,14 @@ trait Foo {\n     fn dummy(&self) { }\n }\n \n-pub trait Bar : Foo {} // error: private trait in exported type parameter bound\n+pub trait Bar : Foo {} // error: private trait in public interface\n pub struct Bar<T: Foo>(pub T); // same error\n pub fn foo<T: Foo> (t: T) {} // same error\n ```\n \n-To solve this error, please ensure that the trait is also public and accessible\n-at the same level of the public functions or types which are bound on it.\n+To solve this error, please ensure that the trait is also public. The trait\n+can be made inaccessible if necessary by placing it into a private inner module,\n+but it still has to be marked with `pub`.\n Example:\n \n ```\n@@ -42,20 +43,22 @@ pub fn foo<T: Foo> (t: T) {} // ok!\n \"##,\n \n E0446: r##\"\n-A private type was used in an exported type signature. Erroneous code example:\n+A private type was used in a public type signature. Erroneous code example:\n \n ```\n mod Foo {\n     struct Bar(u32);\n \n-    pub fn bar() -> Bar { // error: private type in exported type signature\n+    pub fn bar() -> Bar { // error: private type in public interface\n         Bar(0)\n     }\n }\n ```\n \n-To solve this error, please ensure that the type is also public and accessible\n-at the same level of the public functions or types which use it. Example:\n+To solve this error, please ensure that the type is also public. The type\n+can be made inaccessible if necessary by placing it into a private inner module,\n+but it still has to be marked with `pub`.\n+Example:\n \n ```\n mod Foo {"}, {"sha": "9a869b24b8f6dac18aeaa83a91e1287131af79c6", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 264, "deletions": 24, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -38,6 +38,7 @@ use std::mem::replace;\n use rustc_front::hir;\n use rustc_front::intravisit::{self, Visitor};\n \n+use rustc::lint;\n use rustc::middle::def;\n use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::{AccessLevel, AccessLevels};\n@@ -46,7 +47,7 @@ use rustc::middle::privacy::LastPrivate::*;\n use rustc::middle::privacy::PrivateDep::*;\n use rustc::middle::privacy::ExternalExports;\n use rustc::middle::ty;\n-use rustc::util::nodemap::NodeMap;\n+use rustc::util::nodemap::{NodeMap, NodeSet};\n use rustc::front::map as ast_map;\n \n use syntax::ast;\n@@ -1101,14 +1102,23 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n-struct VisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n+///////////////////////////////////////////////////////////////////////////////\n+/// Obsolete visitors for checking for private items in public interfaces.\n+/// These visitors are supposed to be kept in frozen state and produce an\n+/// \"old error node set\". For backward compatibility the new visitor reports\n+/// warnings instead of hard errors when the erroneous node is not in this old set.\n+///////////////////////////////////////////////////////////////////////////////\n+\n+struct ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     access_levels: &'a AccessLevels,\n     in_variant: bool,\n+    // set of errors produced by this obsolete visitor\n+    old_error_set: NodeSet,\n }\n \n-struct CheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n-    inner: &'a VisiblePrivateTypesVisitor<'b, 'tcx>,\n+struct ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n+    inner: &'a ObsoleteVisiblePrivateTypesVisitor<'b, 'tcx>,\n     /// whether the type refers to private types.\n     contains_private: bool,\n     /// whether we've recurred at all (i.e. if we're pointing at the\n@@ -1118,7 +1128,7 @@ struct CheckTypeForPrivatenessVisitor<'a, 'b: 'a, 'tcx: 'b> {\n     outer_type_is_public_path: bool,\n }\n \n-impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn path_is_private_type(&self, path_id: ast::NodeId) -> bool {\n         let did = match self.tcx.def_map.borrow().get(&path_id).map(|d| d.full_def()) {\n             // `int` etc. (None doesn't seem to occur.)\n@@ -1146,14 +1156,11 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n         self.access_levels.is_public(trait_id)\n     }\n \n-    fn check_ty_param_bound(&self,\n+    fn check_ty_param_bound(&mut self,\n                             ty_param_bound: &hir::TyParamBound) {\n         if let hir::TraitTyParamBound(ref trait_ref, _) = *ty_param_bound {\n-            if !self.tcx.sess.features.borrow().visible_private_types &&\n-                self.path_is_private_type(trait_ref.trait_ref.ref_id) {\n-                    let span = trait_ref.trait_ref.path.span;\n-                    span_err!(self.tcx.sess, span, E0445,\n-                              \"private trait in exported type parameter bound\");\n+            if self.path_is_private_type(trait_ref.trait_ref.ref_id) {\n+                self.old_error_set.insert(trait_ref.trait_ref.ref_id);\n             }\n         }\n     }\n@@ -1163,7 +1170,7 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'b, 'tcx, 'v> Visitor<'v> for CheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx, 'v> Visitor<'v> for ObsoleteCheckTypeForPrivatenessVisitor<'a, 'b, 'tcx> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n         if let hir::TyPath(..) = ty.node {\n             if self.inner.path_is_private_type(ty.id) {\n@@ -1183,7 +1190,7 @@ impl<'a, 'b, 'tcx, 'v> Visitor<'v> for CheckTypeForPrivatenessVisitor<'a, 'b, 't\n     fn visit_expr(&mut self, _: &hir::Expr) {}\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n@@ -1224,7 +1231,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n                 // check the properties of the Self type:\n                 {\n-                    let mut visitor = CheckTypeForPrivatenessVisitor {\n+                    let mut visitor = ObsoleteCheckTypeForPrivatenessVisitor {\n                         inner: self,\n                         contains_private: false,\n                         at_outer_type: true,\n@@ -1401,11 +1408,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n     fn visit_ty(&mut self, t: &hir::Ty) {\n         debug!(\"VisiblePrivateTypesVisitor checking ty {:?}\", t);\n-        if let hir::TyPath(_, ref p) = t.node {\n-            if !self.tcx.sess.features.borrow().visible_private_types &&\n-                self.path_is_private_type(t.id) {\n-                span_err!(self.tcx.sess, p.span, E0446,\n-                          \"private type in exported type signature\");\n+        if let hir::TyPath(..) = t.node {\n+            if self.path_is_private_type(t.id) {\n+                self.old_error_set.insert(t.id);\n             }\n         }\n         intravisit::walk_ty(self, t)\n@@ -1439,6 +1444,235 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, _: &hir::Expr) {}\n }\n \n+///////////////////////////////////////////////////////////////////////////////\n+/// SearchInterfaceForPrivateItemsVisitor traverses an item's interface and\n+/// finds any private components in it.\n+/// PrivateItemsInPublicInterfacesVisitor ensures there are no private types\n+/// and traits in public interfaces.\n+///////////////////////////////////////////////////////////////////////////////\n+\n+struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    // Do not report an error when a private type is found\n+    is_quiet: bool,\n+    // Is private component found?\n+    is_public: bool,\n+    old_error_set: &'a NodeSet,\n+}\n+\n+impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+    // Check if the type alias contain private types when substituted\n+    fn is_public_type_alias(&self, item: &hir::Item, path: &hir::Path) -> bool {\n+        // We substitute type aliases only when determining impl publicity\n+        // FIXME: This will probably change and all type aliases will be substituted,\n+        // requires an amendment to RFC 136.\n+        if !self.is_quiet {\n+            return false\n+        }\n+        // Type alias is considered public if the aliased type is\n+        // public, even if the type alias itself is private. So, something\n+        // like `type A = u8; pub fn f() -> A {...}` doesn't cause an error.\n+        if let hir::ItemTy(ref ty, ref generics) = item.node {\n+            let mut check = SearchInterfaceForPrivateItemsVisitor { is_public: true, ..*self };\n+            check.visit_ty(ty);\n+            // If a private type alias with default type parameters is used in public\n+            // interface we must ensure, that the defaults are public if they are actually used.\n+            // ```\n+            // type Alias<T = Private> = T;\n+            // pub fn f() -> Alias {...} // `Private` is implicitly used here, so it must be public\n+            // ```\n+            let provided_params = path.segments.last().unwrap().parameters.types().len();\n+            for ty_param in &generics.ty_params[provided_params..] {\n+                if let Some(ref default_ty) = ty_param.default {\n+                    check.visit_ty(default_ty);\n+                }\n+            }\n+            check.is_public\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: &hir::Ty) {\n+        if self.is_quiet && !self.is_public {\n+            // We are in quiet mode and a private type is already found, no need to proceed\n+            return\n+        }\n+        if let hir::TyPath(_, ref path) = ty.node {\n+            let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n+            match def {\n+                def::DefPrimTy(..) | def::DefSelfTy(..) | def::DefTyParam(..) => {\n+                    // Public\n+                }\n+                def::DefAssociatedTy(..) if self.is_quiet => {\n+                    // Conservatively approximate the whole type alias as public without\n+                    // recursing into its components when determining impl publicity.\n+                    // For example, `impl <Type as Trait>::Alias {...}` may be a public impl\n+                    // even if both `Type` and `Trait` are private.\n+                    // Ideally, associated types should be substituted in the same way as\n+                    // free type aliases, but this isn't done yet.\n+                    return\n+                }\n+                def::DefStruct(def_id) | def::DefTy(def_id, _) |\n+                def::DefTrait(def_id) | def::DefAssociatedTy(def_id, _) => {\n+                    // Non-local means public (private items can't leave their crate, modulo bugs)\n+                    if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+                        let item = self.tcx.map.expect_item(node_id);\n+                        if item.vis != hir::Public && !self.is_public_type_alias(item, path) {\n+                            if !self.is_quiet {\n+                                if self.old_error_set.contains(&ty.id) {\n+                                    span_err!(self.tcx.sess, ty.span, E0446,\n+                                              \"private type in public interface\");\n+                                } else {\n+                                    self.tcx.sess.add_lint (\n+                                        lint::builtin::PRIVATE_IN_PUBLIC,\n+                                        node_id,\n+                                        ty.span,\n+                                        \"private type in public interface (error E0446)\".to_string()\n+                                    );\n+                                }\n+                            }\n+                            self.is_public = false;\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        intravisit::walk_ty(self, ty);\n+    }\n+\n+    fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n+        if self.is_quiet && !self.is_public {\n+            // We are in quiet mode and a private type is already found, no need to proceed\n+            return\n+        }\n+        // Non-local means public (private items can't leave their crate, modulo bugs)\n+        let def_id = self.tcx.trait_ref_to_def_id(trait_ref);\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+            let item = self.tcx.map.expect_item(node_id);\n+            if item.vis != hir::Public {\n+                if !self.is_quiet {\n+                    if self.old_error_set.contains(&trait_ref.ref_id) {\n+                        span_err!(self.tcx.sess, trait_ref.path.span, E0445,\n+                                  \"private trait in public interface\");\n+                    } else {\n+                        self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                               node_id,\n+                                               trait_ref.path.span,\n+                                               \"private trait in public interface (error E0445)\"\n+                                                    .to_string());\n+                    }\n+                }\n+                self.is_public = false;\n+            }\n+        }\n+\n+        intravisit::walk_trait_ref(self, trait_ref);\n+    }\n+\n+    // Don't recurse into function bodies\n+    fn visit_block(&mut self, _: &hir::Block) {}\n+    // Don't recurse into expressions in array sizes or const initializers\n+    fn visit_expr(&mut self, _: &hir::Expr) {}\n+    // Don't recurse into patterns in function arguments\n+    fn visit_pat(&mut self, _: &hir::Pat) {}\n+}\n+\n+struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    old_error_set: &'a NodeSet,\n+}\n+\n+impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n+    // A type is considered public if it doesn't contain any private components\n+    fn is_public_ty(&self, ty: &hir::Ty) -> bool {\n+        let mut check = SearchInterfaceForPrivateItemsVisitor {\n+            tcx: self.tcx, is_quiet: true, is_public: true, old_error_set: self.old_error_set\n+        };\n+        check.visit_ty(ty);\n+        check.is_public\n+    }\n+\n+    // A trait reference is considered public if it doesn't contain any private components\n+    fn is_public_trait_ref(&self, trait_ref: &hir::TraitRef) -> bool {\n+        let mut check = SearchInterfaceForPrivateItemsVisitor {\n+            tcx: self.tcx, is_quiet: true, is_public: true, old_error_set: self.old_error_set\n+        };\n+        check.visit_trait_ref(trait_ref);\n+        check.is_public\n+    }\n+}\n+\n+impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        let mut check = SearchInterfaceForPrivateItemsVisitor {\n+            tcx: self.tcx, is_quiet: false, is_public: true, old_error_set: self.old_error_set\n+        };\n+        match item.node {\n+            // Crates are always public\n+            hir::ItemExternCrate(..) => {}\n+            // All nested items are checked by visit_item\n+            hir::ItemMod(..) => {}\n+            // Checked in resolve\n+            hir::ItemUse(..) => {}\n+            // Subitems of these items have inherited publicity\n+            hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n+            hir::ItemEnum(..) | hir::ItemTrait(..) | hir::ItemTy(..) => {\n+                if item.vis == hir::Public {\n+                    check.visit_item(item);\n+                }\n+            }\n+            // Subitems of foreign modules have their own publicity\n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    if foreign_item.vis == hir::Public {\n+                        check.visit_foreign_item(foreign_item);\n+                    }\n+                }\n+            }\n+            // Subitems of structs have their own publicity\n+            hir::ItemStruct(ref struct_def, ref generics) => {\n+                if item.vis == hir::Public {\n+                    check.visit_generics(generics);\n+                    for field in struct_def.fields() {\n+                        if field.node.kind.visibility() == hir::Public {\n+                            check.visit_struct_field(field);\n+                        }\n+                    }\n+                }\n+            }\n+            // The interface is empty\n+            hir::ItemDefaultImpl(..) => {}\n+            // An inherent impl is public when its type is public\n+            // Subitems of inherent impls have their own publicity\n+            hir::ItemImpl(_, _, ref generics, None, ref ty, ref impl_items) => {\n+                if self.is_public_ty(ty) {\n+                    check.visit_generics(generics);\n+                    for impl_item in impl_items {\n+                        if impl_item.vis == hir::Public {\n+                            check.visit_impl_item(impl_item);\n+                        }\n+                    }\n+                }\n+            }\n+            // A trait impl is public when both its type and its trait are public\n+            // Subitems of trait impls have inherited publicity\n+            hir::ItemImpl(_, _, ref generics, Some(ref trait_ref), ref ty, ref impl_items) => {\n+                if self.is_public_ty(ty) && self.is_public_trait_ref(trait_ref) {\n+                    check.visit_generics(generics);\n+                    for impl_item in impl_items {\n+                        check.visit_impl_item(impl_item);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n pub fn check_crate(tcx: &ty::ctxt,\n                    export_map: &def::ExportMap,\n                    external_exports: ExternalExports)\n@@ -1492,18 +1726,24 @@ pub fn check_crate(tcx: &ty::ctxt,\n     }\n     visitor.update(ast::CRATE_NODE_ID, Some(AccessLevel::Public));\n \n-    let EmbargoVisitor { access_levels, .. } = visitor;\n-\n     {\n-        let mut visitor = VisiblePrivateTypesVisitor {\n+        let mut visitor = ObsoleteVisiblePrivateTypesVisitor {\n             tcx: tcx,\n-            access_levels: &access_levels,\n+            access_levels: &visitor.access_levels,\n             in_variant: false,\n+            old_error_set: NodeSet(),\n         };\n         intravisit::walk_crate(&mut visitor, krate);\n+\n+        // Check for private types and traits in public interfaces\n+        let mut visitor = PrivateItemsInPublicInterfacesVisitor {\n+            tcx: tcx,\n+            old_error_set: &visitor.old_error_set,\n+        };\n+        krate.visit_all_items(&mut visitor);\n     }\n \n-    access_levels\n+    visitor.access_levels\n }\n \n __build_diagnostic_array! { librustc_privacy, DIAGNOSTICS }"}, {"sha": "11d09fa3e9a6b841d4ba85c6fc650c6651f721e8", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -390,9 +390,15 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                 let module = Module::new(parent_link, Some(def), false, is_public);\n                 name_bindings.define_module(module.clone(), sp);\n \n+                let variant_modifiers = if is_public {\n+                    DefModifiers::empty()\n+                } else {\n+                    DefModifiers::PRIVATE_VARIANT\n+                };\n                 for variant in &(*enum_definition).variants {\n                     let item_def_id = self.ast_map.local_def_id(item.id);\n-                    self.build_reduced_graph_for_variant(variant, item_def_id, &module);\n+                    self.build_reduced_graph_for_variant(variant, item_def_id,\n+                                                         &module, variant_modifiers);\n                 }\n                 parent.clone()\n             }\n@@ -494,7 +500,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     fn build_reduced_graph_for_variant(&mut self,\n                                        variant: &Variant,\n                                        item_id: DefId,\n-                                       parent: &Rc<Module>) {\n+                                       parent: &Rc<Module>,\n+                                       variant_modifiers: DefModifiers) {\n         let name = variant.node.name;\n         let is_exported = if variant.node.data.is_struct() {\n             // Not adding fields for variants as they are not accessed with a self receiver\n@@ -512,12 +519,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                       self.ast_map.local_def_id(variant.node.data.id()),\n                                       is_exported),\n                            variant.span,\n-                           DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n+                           DefModifiers::PUBLIC | DefModifiers::IMPORTABLE | variant_modifiers);\n         child.define_type(DefVariant(item_id,\n                                      self.ast_map.local_def_id(variant.node.data.id()),\n                                      is_exported),\n                           variant.span,\n-                          DefModifiers::PUBLIC | DefModifiers::IMPORTABLE);\n+                          DefModifiers::PUBLIC | DefModifiers::IMPORTABLE | variant_modifiers);\n     }\n \n     /// Constructs the reduced graph for one foreign item."}, {"sha": "6896e8e534057506888d7d4efbd03eacc215b689", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -905,8 +905,13 @@ impl fmt::Debug for Module {\n bitflags! {\n     #[derive(Debug)]\n     flags DefModifiers: u8 {\n+        // Enum variants are always considered `PUBLIC`, this is needed for `use Enum::Variant`\n+        // or `use Enum::*` to work on private enums.\n         const PUBLIC     = 1 << 0,\n         const IMPORTABLE = 1 << 1,\n+        // Variants are considered `PUBLIC`, but some of them live in private enums.\n+        // We need to track them to prohibit reexports like `pub use PrivEnum::Variant`.\n+        const PRIVATE_VARIANT = 1 << 2,\n     }\n }\n "}, {"sha": "69d5621ce73d9f203fe8feafec8986053b166ef2", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -25,6 +25,7 @@ use {resolve_error, ResolutionError};\n \n use build_reduced_graph;\n \n+use rustc::lint;\n use rustc::middle::def::*;\n use rustc::middle::def_id::DefId;\n use rustc::middle::privacy::*;\n@@ -452,6 +453,17 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         self.resolver.session.span_note(directive.span, &note_msg);\n                         pub_err = true;\n                     }\n+                    if directive.is_public && child_name_bindings.value_ns.\n+                                              defined_with(DefModifiers::PRIVATE_VARIANT) {\n+                        let msg = format!(\"variant `{}` is private, and cannot be reexported ( \\\n+                                           error E0364), consider declaring its enum as `pub`\",\n+                                           source);\n+                        self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                                       directive.id,\n+                                                       directive.span,\n+                                                       msg);\n+                        pub_err = true;\n+                    }\n                 }\n                 if child_name_bindings.type_ns.defined() {\n                     debug!(\"(resolving single import) found type binding\");\n@@ -465,6 +477,16 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg);\n                         self.resolver.session.span_note(directive.span, &note_msg);\n                     }\n+                    if !pub_err && directive.is_public && child_name_bindings.type_ns.\n+                                                    defined_with(DefModifiers::PRIVATE_VARIANT) {\n+                        let msg = format!(\"variant `{}` is private, and cannot be reexported ( \\\n+                                           error E0365), consider declaring its enum as `pub`\",\n+                                           source);\n+                        self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                                       directive.id,\n+                                                       directive.span,\n+                                                       msg);\n+                    }\n                 }\n             }\n         }\n@@ -842,10 +864,22 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                module_to_string(module_));\n \n         // Merge the child item into the import resolution.\n+        // pub_err makes sure we don't give the same error twice.\n+        let mut pub_err = false;\n         {\n             let mut merge_child_item = |namespace| {\n-                let modifier = DefModifiers::IMPORTABLE | DefModifiers::PUBLIC;\n+                if !pub_err && is_public &&\n+                        name_bindings[namespace].defined_with(DefModifiers::PRIVATE_VARIANT) {\n+                    let msg = format!(\"variant `{}` is private, and cannot be reexported (error \\\n+                                       E0364), consider declaring its enum as `pub`\", name);\n+                    self.resolver.session.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                                   import_directive.id,\n+                                                   import_directive.span,\n+                                                   msg);\n+                    pub_err = true;\n+                }\n \n+                let modifier = DefModifiers::IMPORTABLE | DefModifiers::PUBLIC;\n                 if name_bindings[namespace].defined_with(modifier) {\n                     let namespace_name = match namespace {\n                         TypeNS => \"type\","}, {"sha": "44b161a7575cc545ad5a5ab53c23af73ec7c9675", "filename": "src/librustc_trans/back/msvc/registry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fmsvc%2Fregistry.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -14,7 +14,7 @@ use std::os::windows::prelude::*;\n use std::ptr;\n use libc::{c_void, c_long};\n \n-type DWORD = u32;\n+pub type DWORD = u32;\n type LPCWSTR = *const u16;\n type LONG = c_long;\n type LPDWORD = *mut DWORD;\n@@ -34,7 +34,7 @@ const SYNCHRONIZE: REGSAM = 0x00100000;\n const REG_SZ: DWORD = 1;\n const ERROR_SUCCESS: i32 = 0;\n \n-enum __HKEY__ {}\n+pub enum __HKEY__ {}\n pub type HKEY = *mut __HKEY__;\n pub type PHKEY = *mut HKEY;\n pub type REGSAM = DWORD;"}, {"sha": "ee1d834fc8a89efb638a271e2475184e65e21388", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -145,7 +145,7 @@ impl FunctionDebugContext {\n     }\n }\n \n-struct FunctionDebugContextData {\n+pub struct FunctionDebugContextData {\n     scope_map: RefCell<NodeMap<DIScope>>,\n     fn_metadata: DISubprogram,\n     argument_counter: Cell<usize>,"}, {"sha": "097968cd5a3758dfe7821bffd280b344ada4c4da", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -123,7 +123,7 @@ pub enum BucketState<K, V, M> {\n // A GapThenFull encapsulates the state of two consecutive buckets at once.\n // The first bucket, called the gap, is known to be empty.\n // The second bucket is full.\n-struct GapThenFull<K, V, M> {\n+pub struct GapThenFull<K, V, M> {\n     gap: EmptyBucket<K, V, ()>,\n     full: FullBucket<K, V, M>,\n }"}, {"sha": "0d38411ac93344adfd0ecefbc23e00975c3dcf10", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -82,7 +82,7 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Option<u32>, Status\n     (\"advanced_slice_patterns\", \"1.0.0\", Some(23121), Active),\n     (\"tuple_indexing\", \"1.0.0\", None, Accepted),\n     (\"associated_types\", \"1.0.0\", None, Accepted),\n-    (\"visible_private_types\", \"1.0.0\", Some(29627), Active),\n+    (\"visible_private_types\", \"1.0.0\", None, Removed),\n     (\"slicing_syntax\", \"1.0.0\", None, Accepted),\n     (\"box_syntax\", \"1.0.0\", Some(27779), Active),\n     (\"placement_in_syntax\", \"1.0.0\", Some(27779), Active),\n@@ -514,7 +514,6 @@ pub enum AttributeGate {\n pub struct Features {\n     pub unboxed_closures: bool,\n     pub rustc_diagnostic_macros: bool,\n-    pub visible_private_types: bool,\n     pub allow_quote: bool,\n     pub allow_asm: bool,\n     pub allow_log_syntax: bool,\n@@ -551,7 +550,6 @@ impl Features {\n         Features {\n             unboxed_closures: false,\n             rustc_diagnostic_macros: false,\n-            visible_private_types: false,\n             allow_quote: false,\n             allow_asm: false,\n             allow_log_syntax: false,\n@@ -1130,7 +1128,6 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &Handler,\n     Features {\n         unboxed_closures: cx.has_feature(\"unboxed_closures\"),\n         rustc_diagnostic_macros: cx.has_feature(\"rustc_diagnostic_macros\"),\n-        visible_private_types: cx.has_feature(\"visible_private_types\"),\n         allow_quote: cx.has_feature(\"quote\"),\n         allow_asm: cx.has_feature(\"asm\"),\n         allow_log_syntax: cx.has_feature(\"log_syntax\"),"}, {"sha": "3d777d01d502733a3c8bd539faff6d8d011a30a0", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -13,7 +13,7 @@\n \n use std::marker;\n \n-struct arc_destruct<T: Sync> {\n+pub struct arc_destruct<T: Sync> {\n     _data: isize,\n     _marker: marker::PhantomData<T>\n }\n@@ -37,7 +37,7 @@ fn init() -> arc_destruct<context_res> {\n     arc(context_res())\n }\n \n-struct context_res {\n+pub struct context_res {\n     ctx : isize,\n }\n "}, {"sha": "e640ba3f00fb6d7d2faf69b529d1ab62d439c0fd", "filename": "src/test/compile-fail/issue-17546.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Fissue-17546.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Fissue-17546.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17546.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -14,7 +14,7 @@ use foo::NoResult; // Through a re-export\n mod foo {\n     pub use self::MyEnum::NoResult;\n \n-    enum MyEnum {\n+    pub enum MyEnum {\n         Result,\n         NoResult\n     }"}, {"sha": "300fc5a6ef736427ba86f9b33c6b92b342b4717d", "filename": "src/test/compile-fail/issue-18389.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18389.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -14,7 +14,7 @@ use std::any::TypeId;\n trait Private<P, R> {\n     fn call(&self, p: P, r: R);\n }\n-pub trait Public: Private< //~ ERROR private trait in exported type parameter bound\n+pub trait Public: Private< //~ ERROR private trait in public interface\n     <Self as Public>::P,\n     <Self as Public>::R\n > {"}, {"sha": "f45e80f5252e31666841a9bb413364dee1962da1", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -49,7 +49,7 @@ struct UsedStruct1 {\n }\n struct UsedStruct2(isize);\n struct UsedStruct3;\n-struct UsedStruct4;\n+pub struct UsedStruct4;\n // this struct is never used directly, but its method is, so we don't want\n // to warn it\n struct SemiUsedStruct;"}, {"sha": "d34738282eb268e0d90f430307433a333dfa13f4", "filename": "src/test/compile-fail/lint-visible-private-types.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/29ea4eef9fa6e36f40bc1f31eb1e56bf5941ee72/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea4eef9fa6e36f40bc1f31eb1e56bf5941ee72/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-visible-private-types.rs?ref=29ea4eef9fa6e36f40bc1f31eb1e56bf5941ee72", "patch": "@@ -1,123 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![allow(dead_code)]\n-#![crate_type=\"lib\"]\n-\n-use std::marker;\n-\n-struct Private<T>(marker::PhantomData<T>);\n-pub struct Public<T>(marker::PhantomData<T>);\n-\n-impl Private<Public<isize>> {\n-    pub fn a(&self) -> Private<isize> { panic!() }\n-    fn b(&self) -> Private<isize> { panic!() }\n-\n-    pub fn c() -> Private<isize> { panic!() }\n-    fn d() -> Private<isize> { panic!() }\n-}\n-impl Private<isize> {\n-    pub fn e(&self) -> Private<isize> { panic!() }\n-    fn f(&self) -> Private<isize> { panic!() }\n-}\n-\n-impl Public<Private<isize>> {\n-    pub fn a(&self) -> Private<isize> { panic!() }\n-    fn b(&self) -> Private<isize> { panic!() }\n-\n-    pub fn c() -> Private<isize> { panic!() } //~ ERROR private type in exported type signature\n-    fn d() -> Private<isize> { panic!() }\n-}\n-impl Public<isize> {\n-    pub fn e(&self) -> Private<isize> { panic!() } //~ ERROR private type in exported type signature\n-    fn f(&self) -> Private<isize> { panic!() }\n-}\n-\n-pub fn x(_: Private<isize>) {} //~ ERROR private type in exported type signature\n-\n-fn y(_: Private<isize>) {}\n-\n-\n-pub struct Foo {\n-    pub x: Private<isize>, //~ ERROR private type in exported type signature\n-    y: Private<isize>\n-}\n-\n-struct Bar {\n-    x: Private<isize>,\n-}\n-\n-pub enum Baz {\n-    Baz1(Private<isize>), //~ ERROR private type in exported type signature\n-    Baz2 {\n-        y: Private<isize> //~ ERROR private type in exported type signature\n-    },\n-}\n-\n-enum Qux {\n-    Qux1(Private<isize>),\n-    Qux2 {\n-        x: Private<isize>,\n-    }\n-}\n-\n-pub trait PubTrait {\n-    fn foo(&self) -> Private<isize> { panic!( )} //~ ERROR private type in exported type signature\n-    fn bar(&self) -> Private<isize>; //~ ERROR private type in exported type signature\n-    fn baz() -> Private<isize>; //~ ERROR private type in exported type signature\n-}\n-\n-impl PubTrait for Public<isize> {\n-    fn bar(&self) -> Private<isize> { panic!() }\n-    fn baz() -> Private<isize> { panic!() }\n-}\n-impl PubTrait for Public<Private<isize>> {\n-    fn bar(&self) -> Private<isize> { panic!() }\n-    fn baz() -> Private<isize> { panic!() }\n-}\n-\n-impl PubTrait for Private<isize> {\n-    fn bar(&self) -> Private<isize> { panic!() }\n-    fn baz() -> Private<isize> { panic!() }\n-}\n-impl PubTrait for (Private<isize>,) {\n-    fn bar(&self) -> Private<isize> { panic!() }\n-    fn baz() -> Private<isize> { panic!() }\n-}\n-\n-\n-trait PrivTrait {\n-    fn foo(&self) -> Private<isize> { panic!( )}\n-    fn bar(&self) -> Private<isize>;\n-}\n-impl PrivTrait for Private<isize> {\n-    fn bar(&self) -> Private<isize> { panic!() }\n-}\n-impl PrivTrait for (Private<isize>,) {\n-    fn bar(&self) -> Private<isize> { panic!() }\n-}\n-\n-pub trait ParamTrait<T> {\n-    fn foo() -> T;\n-}\n-\n-impl ParamTrait<Private<isize>> //~ ERROR private type in exported type signature\n-   for Public<isize> {\n-    fn foo() -> Private<isize> { panic!() }\n-}\n-\n-impl ParamTrait<Private<isize>> for Private<isize> {\n-    fn foo() -> Private<isize> { panic!( )}\n-}\n-\n-impl<T: ParamTrait<Private<isize>>>  //~ ERROR private type in exported type signature\n-     ParamTrait<T> for Public<i8> {\n-    fn foo() -> T { panic!() }\n-}"}, {"sha": "f589daf3f39a6317a1a5318ef9b6e6dfa347afe0", "filename": "src/test/compile-fail/priv_in_pub_sig_priv_mod.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/29ea4eef9fa6e36f40bc1f31eb1e56bf5941ee72/src%2Ftest%2Fcompile-fail%2Fpriv_in_pub_sig_priv_mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea4eef9fa6e36f40bc1f31eb1e56bf5941ee72/src%2Ftest%2Fcompile-fail%2Fpriv_in_pub_sig_priv_mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpriv_in_pub_sig_priv_mod.rs?ref=29ea4eef9fa6e36f40bc1f31eb1e56bf5941ee72", "patch": "@@ -1,28 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we properly check for private types in public signatures, even\n-// inside a private module (#22261).\n-\n-mod a {\n-    struct Priv;\n-\n-    pub fn expose_a() -> Priv { //~Error: private type in exported type signature\n-        panic!();\n-    }\n-\n-    mod b {\n-        pub fn expose_b() -> super::Priv { //~Error: private type in exported type signature\n-            panic!();\n-        }\n-    }\n-}\n-\n-pub fn main() {}"}, {"sha": "f9b049c5d3360e584af7a77e377f00e88d14dabe", "filename": "src/test/compile-fail/private-in-public-lint.rs", "status": "renamed", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-lint.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -8,16 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n+mod m1 {\n+    #![deny(private_in_public)]\n \n-#![feature(visible_private_types)]\n+    pub struct Pub;\n+    struct Priv;\n \n-trait Foo { fn dummy(&self) { } }\n+    impl Pub {\n+        pub fn f() -> Priv {} //~ ERROR private type in public interface\n+    }\n+}\n \n-pub trait Bar : Foo {}\n+mod m2 {\n+    #![deny(future_incompatible)]\n \n-struct Baz;\n+    pub struct Pub;\n+    struct Priv;\n \n-pub fn f(_: Baz) {}\n+    impl Pub {\n+        pub fn f() -> Priv {} //~ ERROR private type in public interface\n+    }\n+}\n \n fn main() {}", "previous_filename": "src/test/run-pass/visible-private-types-feature-gate.rs"}, {"sha": "2d1de3ca2823e80f7a50569b3d8fc5220b33f120", "filename": "src/test/compile-fail/private-in-public-warn.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public-warn.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -0,0 +1,251 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Private types and traits are not allowed in public interfaces.\n+// This test also ensures that the checks are performed even inside private modules.\n+\n+#![feature(rustc_attrs)]\n+#![feature(associated_consts)]\n+#![feature(associated_type_defaults)]\n+#![allow(dead_code)]\n+#![allow(unused_variables)]\n+#![allow(improper_ctypes)]\n+\n+mod types {\n+    struct Priv;\n+    pub struct Pub;\n+    pub trait PubTr {\n+        type Alias;\n+    }\n+\n+    pub type Alias = Priv; //~ WARN private type in public interface\n+    pub enum E {\n+        V1(Priv), //~ WARN private type in public interface\n+        V2 { field: Priv }, //~ WARN private type in public interface\n+    }\n+    pub trait Tr {\n+        const C: Priv = Priv; //~ WARN private type in public interface\n+        type Alias = Priv; //~ WARN private type in public interface\n+        fn f1(arg: Priv) {} //~ WARN private type in public interface\n+        fn f2() -> Priv { panic!() } //~ WARN private type in public interface\n+    }\n+    extern {\n+        pub static ES: Priv; //~ WARN private type in public interface\n+        pub fn ef1(arg: Priv); //~ WARN private type in public interface\n+        pub fn ef2() -> Priv; //~ WARN private type in public interface\n+    }\n+    impl PubTr for Pub {\n+        type Alias = Priv; //~ WARN private type in public interface\n+    }\n+}\n+\n+mod traits {\n+    trait PrivTr {}\n+    pub struct Pub<T>(T);\n+    pub trait PubTr {}\n+\n+    pub type Alias<T: PrivTr> = T; //~ WARN private trait in public interface\n+    //~^ WARN trait bounds are not (yet) enforced in type definitions\n+    pub trait Tr1: PrivTr {} //~ WARN private trait in public interface\n+    pub trait Tr2<T: PrivTr> {} //~ WARN private trait in public interface\n+    pub trait Tr3 {\n+        type Alias: PrivTr; //~ WARN private trait in public interface\n+        fn f<T: PrivTr>(arg: T) {} //~ WARN private trait in public interface\n+    }\n+    impl<T: PrivTr> Pub<T> {} //~ WARN private trait in public interface\n+    impl<T: PrivTr> PubTr for Pub<T> {} //~ WARN private trait in public interface\n+}\n+\n+mod traits_where {\n+    trait PrivTr {}\n+    pub struct Pub<T>(T);\n+    pub trait PubTr {}\n+\n+    pub type Alias<T> where T: PrivTr = T; //~ WARN private trait in public interface\n+    pub trait Tr2<T> where T: PrivTr {} //~ WARN private trait in public interface\n+    pub trait Tr3 {\n+        fn f<T>(arg: T) where T: PrivTr {} //~ WARN private trait in public interface\n+    }\n+    impl<T> Pub<T> where T: PrivTr {} //~ WARN private trait in public interface\n+    impl<T> PubTr for Pub<T> where T: PrivTr {} //~ WARN private trait in public interface\n+}\n+\n+mod generics {\n+    struct Priv<T = u8>(T);\n+    pub struct Pub<T = u8>(T);\n+    trait PrivTr<T> {}\n+    pub trait PubTr<T> {}\n+\n+    pub trait Tr1: PrivTr<Pub> {} //~ WARN private trait in public interface\n+    pub trait Tr2: PubTr<Priv> {} //~ WARN private type in public interface\n+    pub trait Tr3: PubTr<[Priv; 1]> {} //~ WARN private type in public interface\n+    pub trait Tr4: PubTr<Pub<Priv>> {} //~ WARN private type in public interface\n+}\n+\n+mod impls {\n+    struct Priv;\n+    pub struct Pub;\n+    trait PrivTr {\n+        type Alias;\n+    }\n+    pub trait PubTr {\n+        type Alias;\n+    }\n+\n+    impl Priv {\n+        pub fn f(arg: Priv) {} // OK\n+    }\n+    impl PrivTr for Priv {\n+        type Alias = Priv; // OK\n+    }\n+    impl PubTr for Priv {\n+        type Alias = Priv; // OK\n+    }\n+    impl PrivTr for Pub {\n+        type Alias = Priv; // OK\n+    }\n+    impl PubTr for Pub {\n+        type Alias = Priv; //~ WARN private type in public interface\n+    }\n+}\n+\n+mod impls_generics {\n+    struct Priv<T = u8>(T);\n+    pub struct Pub<T = u8>(T);\n+    trait PrivTr<T = u8> {\n+        type Alias;\n+    }\n+    pub trait PubTr<T = u8> {\n+        type Alias;\n+    }\n+\n+    impl Priv<Pub> {\n+        pub fn f(arg: Priv) {} // OK\n+    }\n+    impl Pub<Priv> {\n+        pub fn f(arg: Priv) {} // OK\n+    }\n+    impl PrivTr<Pub> for Priv {\n+        type Alias = Priv; // OK\n+    }\n+    impl PubTr<Priv> for Priv {\n+        type Alias = Priv; // OK\n+    }\n+    impl PubTr for Priv<Pub> {\n+        type Alias = Priv; // OK\n+    }\n+    impl PubTr for [Priv; 1] {\n+        type Alias = Priv; // OK\n+    }\n+    impl PubTr for Pub<Priv> {\n+        type Alias = Priv; // OK\n+    }\n+    impl PrivTr<Pub> for Pub {\n+        type Alias = Priv; // OK\n+    }\n+    impl PubTr<Priv> for Pub {\n+        type Alias = Priv; // OK\n+    }\n+}\n+\n+mod aliases_pub {\n+    struct Priv;\n+    mod m {\n+        pub struct Pub1;\n+        pub struct Pub2;\n+        pub struct Pub3;\n+        pub trait PubTr<T = u8> {\n+            type Check = u8;\n+        }\n+    }\n+\n+    use self::m::Pub1 as PrivUseAlias;\n+    use self::m::PubTr as PrivUseAliasTr;\n+    type PrivAlias = m::Pub2;\n+    trait PrivTr {\n+        type AssocAlias = m::Pub3;\n+    }\n+    impl PrivTr for Priv {}\n+\n+    pub fn f1(arg: PrivUseAlias) {} // OK\n+\n+    pub trait Tr1: PrivUseAliasTr {} // OK\n+    // This should be OK, if type aliases are substituted\n+    pub trait Tr2: PrivUseAliasTr<PrivAlias> {} //~ WARN private type in public interface\n+\n+    impl PrivAlias {\n+        pub fn f(arg: Priv) {} //~ WARN private type in public interface\n+    }\n+    // This doesn't even parse\n+    // impl <Priv as PrivTr>::AssocAlias {\n+    //     pub fn f(arg: Priv) {} // WARN private type in public interface\n+    // }\n+    impl PrivUseAliasTr for PrivUseAlias {\n+        type Check = Priv; //~ WARN private type in public interface\n+    }\n+    impl PrivUseAliasTr for PrivAlias {\n+        type Check = Priv; //~ WARN private type in public interface\n+    }\n+    impl PrivUseAliasTr for <Priv as PrivTr>::AssocAlias {\n+        type Check = Priv; //~ WARN private type in public interface\n+    }\n+}\n+\n+mod aliases_priv {\n+    struct Priv;\n+\n+    struct Priv1;\n+    struct Priv2;\n+    struct Priv3;\n+    trait PrivTr1<T = u8> {\n+        type Check = u8;\n+    }\n+\n+    use self::Priv1 as PrivUseAlias;\n+    use self::PrivTr1 as PrivUseAliasTr;\n+    type PrivAlias = Priv2;\n+    trait PrivTr {\n+        type AssocAlias = Priv3;\n+    }\n+    impl PrivTr for Priv {}\n+\n+    pub trait Tr1: PrivUseAliasTr {} //~ WARN private trait in public interface\n+    pub trait Tr2: PrivUseAliasTr<PrivAlias> {} //~ WARN private trait in public interface\n+     //~^ WARN private type in public interface\n+\n+    impl PrivUseAlias {\n+        pub fn f(arg: Priv) {} // OK\n+    }\n+    impl PrivAlias {\n+        pub fn f(arg: Priv) {} // OK\n+    }\n+    // This doesn't even parse\n+    // impl <Priv as PrivTr>::AssocAlias {\n+    //     pub fn f(arg: Priv) {} // OK\n+    // }\n+    impl PrivUseAliasTr for PrivUseAlias {\n+        type Check = Priv; // OK\n+    }\n+    impl PrivUseAliasTr for PrivAlias {\n+        type Check = Priv; // OK\n+    }\n+    impl PrivUseAliasTr for <Priv as PrivTr>::AssocAlias {\n+        type Check = Priv; // OK\n+    }\n+}\n+\n+mod aliases_params {\n+    struct Priv;\n+    type PrivAliasGeneric<T = Priv> = T;\n+    type Result<T> = ::std::result::Result<T, Priv>;\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "be22a2ef6a77f1bcb4ae118fa059b5a3dad4c6c3", "filename": "src/test/compile-fail/private-in-public.rs", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Fprivate-in-public.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Fprivate-in-public.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-in-public.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -0,0 +1,152 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Private types and traits are not allowed in public interfaces.\n+// This test also ensures that the checks are performed even inside private modules.\n+\n+#![feature(associated_consts)]\n+#![feature(associated_type_defaults)]\n+\n+mod types {\n+    struct Priv;\n+    pub struct Pub;\n+    pub trait PubTr {\n+        type Alias;\n+    }\n+\n+    pub const C: Priv = Priv; //~ ERROR private type in public interface\n+    pub static S: Priv = Priv; //~ ERROR private type in public interface\n+    pub fn f1(arg: Priv) {} //~ ERROR private type in public interface\n+    pub fn f2() -> Priv { panic!() } //~ ERROR private type in public interface\n+    pub struct S1(pub Priv); //~ ERROR private type in public interface\n+    pub struct S2 { pub field: Priv } //~ ERROR private type in public interface\n+    impl Pub {\n+        pub const C: Priv = Priv; //~ ERROR private type in public interface\n+        pub fn f1(arg: Priv) {} //~ ERROR private type in public interface\n+        pub fn f2() -> Priv { panic!() } //~ ERROR private type in public interface\n+    }\n+}\n+\n+mod traits {\n+    trait PrivTr {}\n+    pub struct Pub<T>(T);\n+    pub trait PubTr {}\n+\n+    pub enum E<T: PrivTr> { V(T) } //~ ERROR private trait in public interface\n+    pub fn f<T: PrivTr>(arg: T) {} //~ ERROR private trait in public interface\n+    pub struct S1<T: PrivTr>(T); //~ ERROR private trait in public interface\n+    impl<T: PrivTr> Pub<T> {\n+        pub fn f<U: PrivTr>(arg: U) {} //~ ERROR private trait in public interface\n+    }\n+}\n+\n+mod traits_where {\n+    trait PrivTr {}\n+    pub struct Pub<T>(T);\n+    pub trait PubTr {}\n+\n+    pub enum E<T> where T: PrivTr { V(T) } //~ ERROR private trait in public interface\n+    pub fn f<T>(arg: T) where T: PrivTr {} //~ ERROR private trait in public interface\n+    pub struct S1<T>(T) where T: PrivTr; //~ ERROR private trait in public interface\n+    impl<T> Pub<T> where T: PrivTr {\n+        pub fn f<U>(arg: U) where U: PrivTr {} //~ ERROR private trait in public interface\n+    }\n+}\n+\n+mod generics {\n+    struct Priv<T = u8>(T);\n+    pub struct Pub<T = u8>(T);\n+    trait PrivTr<T> {}\n+    pub trait PubTr<T> {}\n+\n+    pub fn f1(arg: [Priv; 1]) {} //~ ERROR private type in public interface\n+    pub fn f2(arg: Pub<Priv>) {} //~ ERROR private type in public interface\n+    pub fn f3(arg: Priv<Pub>) {} //~ ERROR private type in public interface\n+}\n+\n+mod impls {\n+    struct Priv;\n+    pub struct Pub;\n+    trait PrivTr {\n+        type Alias;\n+    }\n+    pub trait PubTr {\n+        type Alias;\n+    }\n+\n+    impl Pub {\n+        pub fn f(arg: Priv) {} //~ ERROR private type in public interface\n+    }\n+}\n+\n+mod aliases_pub {\n+    struct Priv;\n+    mod m {\n+        pub struct Pub1;\n+        pub struct Pub2;\n+        pub struct Pub3;\n+        pub trait PubTr<T = u8> {\n+            type Check = u8;\n+        }\n+    }\n+\n+    use self::m::Pub1 as PrivUseAlias;\n+    use self::m::PubTr as PrivUseAliasTr;\n+    type PrivAlias = m::Pub2;\n+    trait PrivTr {\n+        type AssocAlias = m::Pub3;\n+    }\n+    impl PrivTr for Priv {}\n+\n+    // This should be OK, if type aliases are substituted\n+    pub fn f2(arg: PrivAlias) {} //~ ERROR private type in public interface\n+    // This should be OK, but associated type aliases are not substituted yet\n+    pub fn f3(arg: <Priv as PrivTr>::AssocAlias) {} //~ ERROR private type in public interface\n+\n+    impl PrivUseAlias {\n+        pub fn f(arg: Priv) {} //~ ERROR private type in public interface\n+    }\n+}\n+\n+mod aliases_priv {\n+    struct Priv;\n+\n+    struct Priv1;\n+    struct Priv2;\n+    struct Priv3;\n+    trait PrivTr1<T = u8> {\n+        type Check = u8;\n+    }\n+\n+    use self::Priv1 as PrivUseAlias;\n+    use self::PrivTr1 as PrivUseAliasTr;\n+    type PrivAlias = Priv2;\n+    trait PrivTr {\n+        type AssocAlias = Priv3;\n+    }\n+    impl PrivTr for Priv {}\n+\n+    pub fn f1(arg: PrivUseAlias) {} //~ ERROR private type in public interface\n+    pub fn f2(arg: PrivAlias) {} //~ ERROR private type in public interface\n+    pub fn f3(arg: <Priv as PrivTr>::AssocAlias) {} //~ ERROR private type in public interface\n+}\n+\n+mod aliases_params {\n+    struct Priv;\n+    type PrivAliasGeneric<T = Priv> = T;\n+    type Result<T> = ::std::result::Result<T, Priv>;\n+\n+    // This should be OK, if type aliases are substituted\n+    pub fn f1(arg: PrivAliasGeneric<u8>) {} //~ ERROR private type in public interface\n+    pub fn f2(arg: PrivAliasGeneric) {} //~ ERROR private type in public interface\n+    pub fn f3(arg: Result<u8>) {} //~ ERROR private type in public interface\n+}\n+\n+fn main() {}"}, {"sha": "39698fa593a28219018860a58ae5c7ce14cc23c0", "filename": "src/test/compile-fail/private-variant-reexport.rs", "status": "renamed", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Fprivate-variant-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fcompile-fail%2Fprivate-variant-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fprivate-variant-reexport.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -8,34 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub struct PublicType;\n-struct PrivateType;\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n \n-pub trait PublicTrait {\n-    type Item;\n+mod m1 {\n+    pub use ::E::V; //~ WARN variant `V` is private, and cannot be reexported\n }\n \n-trait PrivateTrait {\n-    type Item;\n+mod m2 {\n+    pub use ::E::{V}; //~ WARN variant `V` is private, and cannot be reexported\n }\n \n-impl PublicTrait for PublicType {\n-    type Item = PrivateType;  //~ ERROR private type in exported type signature\n+mod m3 {\n+    pub use ::E::V::{self}; //~ WARN variant `V` is private, and cannot be reexported\n }\n \n-// OK\n-impl PublicTrait for PrivateType {\n-    type Item = PrivateType;\n+mod m4 {\n+    pub use ::E::*; //~ WARN variant `V` is private, and cannot be reexported\n }\n \n-// OK\n-impl PrivateTrait for PublicType {\n-    type Item = PrivateType;\n-}\n-\n-// OK\n-impl PrivateTrait for PrivateType {\n-    type Item = PrivateType;\n-}\n+enum E { V }\n \n-fn main() {}\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful", "previous_filename": "src/test/compile-fail/issue-22912.rs"}, {"sha": "1f2205b5c71983ee67a847d32b053c8365d15779", "filename": "src/test/compile-fail/visible-private-types-generics.rs", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/29ea4eef9fa6e36f40bc1f31eb1e56bf5941ee72/src%2Ftest%2Fcompile-fail%2Fvisible-private-types-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29ea4eef9fa6e36f40bc1f31eb1e56bf5941ee72/src%2Ftest%2Fcompile-fail%2Fvisible-private-types-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvisible-private-types-generics.rs?ref=29ea4eef9fa6e36f40bc1f31eb1e56bf5941ee72", "patch": "@@ -1,67 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait Foo {\n-    fn dummy(&self) { }\n-}\n-\n-pub fn f<\n-    T\n-    : Foo //~ ERROR private trait in exported type parameter bound\n->() {}\n-\n-pub fn g<T>() where\n-    T\n-    : Foo //~ ERROR private trait in exported type parameter bound\n-{}\n-\n-pub struct S;\n-\n-impl S {\n-    pub fn f<\n-        T\n-        : Foo //~ ERROR private trait in exported type parameter bound\n-    >() {}\n-\n-    pub fn g<T>() where\n-        T\n-        : Foo //~ ERROR private trait in exported type parameter bound\n-    {}\n-}\n-\n-pub struct S1<\n-    T\n-    : Foo //~ ERROR private trait in exported type parameter bound\n-> {\n-    x: T\n-}\n-\n-pub struct S2<T> where\n-    T\n-    : Foo //~ ERROR private trait in exported type parameter bound\n-{\n-    x: T\n-}\n-\n-pub enum E1<\n-    T\n-    : Foo //~ ERROR private trait in exported type parameter bound\n-> {\n-    V1(T)\n-}\n-\n-pub enum E2<T> where\n-    T\n-    : Foo //~ ERROR private trait in exported type parameter bound\n-{\n-    V2(T)\n-}\n-\n-fn main() {}"}, {"sha": "a74369ed3c3a13b7a779c7099185c29f1a7b7bbd", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -182,7 +182,7 @@ use self::Enum1::{Variant1, Variant2};\n use std::marker::PhantomData;\n use std::ptr;\n \n-struct Struct1;\n+pub struct Struct1;\n struct GenericStruct<T1, T2>(PhantomData<(T1,T2)>);\n \n enum Enum1 {"}, {"sha": "d3bdab9082e32a38a676bacb7b009e0270a646a8", "filename": "src/test/run-pass/default_ty_param_struct_and_type_alias.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct_and_type_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct_and_type_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdefault_ty_param_struct_and_type_alias.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -13,11 +13,11 @@\n \n use std::marker::PhantomData;\n \n-struct DeterministicHasher;\n-struct RandomHasher;\n+pub struct DeterministicHasher;\n+pub struct RandomHasher;\n \n \n-struct MyHashMap<K, V, H=DeterministicHasher> {\n+pub struct MyHashMap<K, V, H=DeterministicHasher> {\n     data: PhantomData<(K, V, H)>\n }\n "}, {"sha": "f70f8768766428d337074555fa2111ac679f614f", "filename": "src/test/run-pass/issue-28983.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Frun-pass%2Fissue-28983.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Frun-pass%2Fissue-28983.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-28983.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Test { type T; }\n+pub trait Test { type T; }\n \n impl Test for u32 {\n     type T = i32;"}, {"sha": "be785de44d1943881f65984fcc5dc64952a9bda3", "filename": "src/test/run-pass/issue-29668.rs", "status": "renamed", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Frun-pass%2Fissue-29668.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef91cdb140d7dffa4b04f42ab0bc02dc257940e3/src%2Ftest%2Frun-pass%2Fissue-29668.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-29668.rs?ref=ef91cdb140d7dffa4b04f42ab0bc02dc257940e3", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,10 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait Foo {\n-    fn dummy(&self) { }\n-}\n+// Functions can return unnameable types\n \n-pub trait Bar : Foo {} //~ ERROR private trait in exported type\n+mod m1 {\n+    mod m2 {\n+        #[derive(Debug)]\n+        pub struct A;\n+    }\n+    use self::m2::A;\n+    pub fn x() -> A { A }\n+}\n \n-fn main() {}\n+fn main() {\n+    let x = m1::x();\n+    println!(\"{:?}\", x);\n+}", "previous_filename": "src/test/compile-fail/visible-private-types-supertrait.rs"}]}