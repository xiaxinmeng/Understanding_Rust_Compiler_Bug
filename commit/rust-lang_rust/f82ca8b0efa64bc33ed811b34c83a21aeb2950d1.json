{"sha": "f82ca8b0efa64bc33ed811b34c83a21aeb2950d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4MmNhOGIwZWZhNjRiYzMzZWQ4MTFiMzRjODNhMjFhZWIyOTUwZDE=", "commit": {"author": {"name": "David Ross", "email": "daboross@daboross.net", "date": "2020-02-16T00:20:53Z"}, "committer": {"name": "David Ross", "email": "daboross@daboross.net", "date": "2020-02-16T03:51:02Z"}, "message": "Add more error cases to issue 35813 tests", "tree": {"sha": "e8f43e8e5b10147f45cf96bcad91262d0bed3de4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8f43e8e5b10147f45cf96bcad91262d0bed3de4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f82ca8b0efa64bc33ed811b34c83a21aeb2950d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f82ca8b0efa64bc33ed811b34c83a21aeb2950d1", "html_url": "https://github.com/rust-lang/rust/commit/f82ca8b0efa64bc33ed811b34c83a21aeb2950d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f82ca8b0efa64bc33ed811b34c83a21aeb2950d1/comments", "author": {"login": "daboross", "id": 1152146, "node_id": "MDQ6VXNlcjExNTIxNDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1152146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/daboross", "html_url": "https://github.com/daboross", "followers_url": "https://api.github.com/users/daboross/followers", "following_url": "https://api.github.com/users/daboross/following{/other_user}", "gists_url": "https://api.github.com/users/daboross/gists{/gist_id}", "starred_url": "https://api.github.com/users/daboross/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/daboross/subscriptions", "organizations_url": "https://api.github.com/users/daboross/orgs", "repos_url": "https://api.github.com/users/daboross/repos", "events_url": "https://api.github.com/users/daboross/events{/privacy}", "received_events_url": "https://api.github.com/users/daboross/received_events", "type": "User", "site_admin": false}, "committer": {"login": "daboross", "id": 1152146, "node_id": "MDQ6VXNlcjExNTIxNDY=", "avatar_url": "https://avatars.githubusercontent.com/u/1152146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/daboross", "html_url": "https://github.com/daboross", "followers_url": "https://api.github.com/users/daboross/followers", "following_url": "https://api.github.com/users/daboross/following{/other_user}", "gists_url": "https://api.github.com/users/daboross/gists{/gist_id}", "starred_url": "https://api.github.com/users/daboross/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/daboross/subscriptions", "organizations_url": "https://api.github.com/users/daboross/orgs", "repos_url": "https://api.github.com/users/daboross/repos", "events_url": "https://api.github.com/users/daboross/events{/privacy}", "received_events_url": "https://api.github.com/users/daboross/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0cf204930a2ecaa5f7416602fca6054d4fd44b6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cf204930a2ecaa5f7416602fca6054d4fd44b6b", "html_url": "https://github.com/rust-lang/rust/commit/0cf204930a2ecaa5f7416602fca6054d4fd44b6b"}], "stats": {"total": 283, "additions": 225, "deletions": 58}, "files": [{"sha": "0083a475ddfba255f3dd6abe9b84b4975d8640f7", "filename": "src/test/ui/parser/issue-35813-postfix-after-cast.rs", "status": "modified", "additions": 89, "deletions": 11, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f82ca8b0efa64bc33ed811b34c83a21aeb2950d1/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f82ca8b0efa64bc33ed811b34c83a21aeb2950d1/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.rs?ref=f82ca8b0efa64bc33ed811b34c83a21aeb2950d1", "patch": "@@ -1,53 +1,129 @@\n // edition:2018\n #![crate_type = \"lib\"]\n+#![feature(type_ascription)]\n use std::future::Future;\n use std::pin::Pin;\n \n // This tests the parser for \"x as Y[z]\". It errors, but we want to give useful\n // errors and parse such that further code gives useful errors.\n pub fn index_after_as_cast() {\n     vec![1, 2, 3] as Vec<i32>[0];\n-    //~^ ERROR: casts followed by index operators are not supported\n+    //~^ ERROR: casts cannot be followed by indexing\n+    vec![1, 2, 3]: Vec<i32>[0];\n+    //~^ ERROR: casts cannot be followed by indexing\n }\n \n pub fn index_after_cast_to_index() {\n     (&[0]) as &[i32][0];\n-    //~^ ERROR: casts followed by index operators are not supported\n+    //~^ ERROR: casts cannot be followed by indexing\n+    (&[0i32]): &[i32; 1][0];\n+    //~^ ERROR: casts cannot be followed by indexing\n+}\n+\n+pub fn cast_after_cast() {\n+    if 5u64 as i32 as u16 == 0u16 {\n+        \n+    }\n+    if 5u64: u64: u64 == 0u64 {\n+       \n+    }\n+    let _ = 5u64: u64: u64 as u8 as i8 == 9i8;\n+    let _ = 0i32: i32: i32;\n+    let _ = 0 as i32: i32;\n+    let _ = 0i32: i32 as i32;\n+    let _ = 0 as i32 as i32;\n+    let _ = 0i32: i32: i32 as u32 as i32;\n }\n \n // this tests that the precedence for `!x as Y.Z` is still what we expect\n pub fn precedence() {\n     let x: i32 = &vec![1, 2, 3] as &Vec<i32>[0];\n-    //~^ ERROR: casts followed by index operators are not supported\n+    //~^ ERROR: casts cannot be followed by indexing\n+}\n+\n+pub fn method_calls() {\n+    0 as i32.max(0);\n+    //~^ ERROR: casts cannot be followed by a method call\n+    0: i32.max(0);\n+    //~^ ERROR: casts cannot be followed by a method call\n }\n \n pub fn complex() {\n     let _ = format!(\n-        \"{}\",\n-        if true { 33 } else { 44 } as i32.max(0)\n-        //~^ ERROR: casts followed by method call expressions are not supported\n+        \"{} and {}\",\n+        if true { 33 } else { 44 } as i32.max(0),\n+        //~^ ERROR: casts cannot be followed by a method call\n+        if true { 33 } else { 44 }: i32.max(0)\n+        //~^ ERROR: casts cannot be followed by a method call\n     );\n }\n \n pub fn in_condition() {\n     if 5u64 as i32.max(0) == 0 {\n-        //~^ ERROR: casts followed by method call expressions are not supported\n+        //~^ ERROR: casts cannot be followed by a method call\n+    }\n+    if 5u64: u64.max(0) == 0 {\n+        //~^ ERROR: casts cannot be followed by a method call\n     }\n }\n \n pub fn inside_block() {\n     let _ = if true {\n         5u64 as u32.max(0) == 0\n-        //~^ ERROR: casts followed by method call expressions are not supported\n+        //~^ ERROR: casts cannot be followed by a method call\n+    } else { false };\n+    let _ = if true {\n+        5u64: u64.max(0) == 0\n+        //~^ ERROR: casts cannot be followed by a method call\n     } else { false };\n }\n \n static bar: &[i32] = &(&[1,2,3] as &[i32][0..1]);\n-//~^ ERROR: casts followed by index operators are not supported\n+//~^ ERROR: casts cannot be followed by indexing\n+\n+static bar2: &[i32] = &(&[1i32,2,3]: &[i32; 3][0..1]);\n+//~^ ERROR: casts cannot be followed by indexing\n+\n+\n+pub fn cast_then_try() -> Result<u64,u64> {\n+    Err(0u64) as Result<u64,u64>?;\n+    //~^ ERROR: casts cannot be followed by ?\n+    Err(0u64): Result<u64,u64>?;\n+    //~^ ERROR: casts cannot be followed by ?\n+    Ok(1)\n+}\n+\n+\n+pub fn cast_then_call() {\n+    type F = fn(u8);\n+    // type ascription won't actually do [unique drop fn type] -> fn(u8) casts.\n+    let drop_ptr = drop as fn(u8);\n+    drop as F();\n+    //~^ ERROR: parenthesized type parameters may only be used with a `Fn` trait [E0214]\n+    drop_ptr: F();\n+    //~^ ERROR: parenthesized type parameters may only be used with a `Fn` trait [E0214]\n+}\n+\n+pub fn cast_to_fn_should_work() {\n+    let drop_ptr = drop as fn(u8);\n+    drop as fn(u8);\n+    drop_ptr: fn(u8); \n+}\n+\n+pub fn parens_after_cast_error() {\n+    let drop_ptr = drop as fn(u8);\n+    drop as fn(u8)(0);\n+    //~^ ERROR: casts cannot be followed by a function call\n+    drop_ptr: fn(u8)(0);\n+    //~^ ERROR: casts cannot be followed by a function call\n+}\n \n pub async fn cast_then_await() {\n     Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>.await;\n-    //~^ ERROR: casts followed by awaits are not supported\n+    //~^ ERROR: casts cannot be followed by `.await`\n+\n+    Box::pin(noop()): Pin<Box<_>>.await;\n+    //~^ ERROR: casts cannot be followed by `.await`\n }\n \n pub async fn noop() {}\n@@ -59,5 +135,7 @@ pub struct Foo {\n \n pub fn struct_field() {\n     Foo::default() as Foo.bar;\n-    //~^ ERROR: casts followed by field access expressions are not supported\n+    //~^ ERROR: cannot be followed by a field access\n+    Foo::default(): Foo.bar;\n+    //~^ ERROR: cannot be followed by a field access\n }"}, {"sha": "ec6c4eb810737024d75a6713738f114827364849", "filename": "src/test/ui/parser/issue-35813-postfix-after-cast.stderr", "status": "modified", "additions": 136, "deletions": 47, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/f82ca8b0efa64bc33ed811b34c83a21aeb2950d1/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f82ca8b0efa64bc33ed811b34c83a21aeb2950d1/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-35813-postfix-after-cast.stderr?ref=f82ca8b0efa64bc33ed811b34c83a21aeb2950d1", "patch": "@@ -1,74 +1,163 @@\n-error: casts followed by index operators are not supported\n-  --> $DIR/issue-35813-postfix-after-cast.rs:9:5\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:10:5\n    |\n LL |     vec![1, 2, 3] as Vec<i32>[0];\n-   |     -------------------------^^^\n-   |     |\n-   |     help: try surrounding the expression with parentheses: `(vec![1, 2, 3] as Vec<i32>)`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(vec![1, 2, 3] as Vec<i32>)`\n \n-error: casts followed by index operators are not supported\n-  --> $DIR/issue-35813-postfix-after-cast.rs:14:5\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:12:5\n+   |\n+LL |     vec![1, 2, 3]: Vec<i32>[0];\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(vec![1, 2, 3]: Vec<i32>)`\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:17:5\n    |\n LL |     (&[0]) as &[i32][0];\n-   |     ----------------^^^\n-   |     |\n-   |     help: try surrounding the expression with parentheses: `((&[0]) as &[i32])`\n+   |     ^^^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `((&[0]) as &[i32])`\n \n-error: casts followed by index operators are not supported\n-  --> $DIR/issue-35813-postfix-after-cast.rs:20:18\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:19:5\n+   |\n+LL |     (&[0i32]): &[i32; 1][0];\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `((&[0i32]): &[i32; 1])`\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:40:18\n    |\n LL |     let x: i32 = &vec![1, 2, 3] as &Vec<i32>[0];\n-   |                  ---------------------------^^^\n-   |                  |\n-   |                  help: try surrounding the expression with parentheses: `(&vec![1, 2, 3] as &Vec<i32>)`\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(&vec![1, 2, 3] as &Vec<i32>)`\n \n-error: casts followed by method call expressions are not supported\n-  --> $DIR/issue-35813-postfix-after-cast.rs:33:8\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:45:5\n+   |\n+LL |     0 as i32.max(0);\n+   |     ^^^^^^^^ help: try surrounding the expression in parentheses: `(0 as i32)`\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:47:5\n+   |\n+LL |     0: i32.max(0);\n+   |     ^^^^^^ help: try surrounding the expression in parentheses: `(0: i32)`\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:62:8\n    |\n LL |     if 5u64 as i32.max(0) == 0 {\n-   |        -----------^^^^^^^\n-   |        |\n-   |        help: try surrounding the expression with parentheses: `(5u64 as i32)`\n+   |        ^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(5u64 as i32)`\n \n-error: casts followed by method call expressions are not supported\n-  --> $DIR/issue-35813-postfix-after-cast.rs:40:9\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:65:8\n+   |\n+LL |     if 5u64: u64.max(0) == 0 {\n+   |        ^^^^^^^^^ help: try surrounding the expression in parentheses: `(5u64: u64)`\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:72:9\n    |\n LL |         5u64 as u32.max(0) == 0\n-   |         -----------^^^^^^^\n-   |         |\n-   |         help: try surrounding the expression with parentheses: `(5u64 as u32)`\n+   |         ^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(5u64 as u32)`\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:76:9\n+   |\n+LL |         5u64: u64.max(0) == 0\n+   |         ^^^^^^^^^ help: try surrounding the expression in parentheses: `(5u64: u64)`\n \n-error: casts followed by index operators are not supported\n-  --> $DIR/issue-35813-postfix-after-cast.rs:45:24\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:81:24\n    |\n LL | static bar: &[i32] = &(&[1,2,3] as &[i32][0..1]);\n-   |                        ------------------^^^^^^\n-   |                        |\n-   |                        help: try surrounding the expression with parentheses: `(&[1,2,3] as &[i32])`\n+   |                        ^^^^^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(&[1,2,3] as &[i32])`\n+\n+error: casts cannot be followed by indexing\n+  --> $DIR/issue-35813-postfix-after-cast.rs:84:25\n+   |\n+LL | static bar2: &[i32] = &(&[1i32,2,3]: &[i32; 3][0..1]);\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(&[1i32,2,3]: &[i32; 3])`\n+\n+error: casts cannot be followed by ?\n+  --> $DIR/issue-35813-postfix-after-cast.rs:89:5\n+   |\n+LL |     Err(0u64) as Result<u64,u64>?;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(Err(0u64) as Result<u64,u64>)`\n+\n+error: casts cannot be followed by ?\n+  --> $DIR/issue-35813-postfix-after-cast.rs:91:5\n+   |\n+LL |     Err(0u64): Result<u64,u64>?;\n+   |     ^^^^^^^^^-^^^^^^^^^^^^^^^^\n+   |              |\n+   |              help: maybe write a path separator here: `::`\n+   |\n+   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/23416\n \n-error: casts followed by awaits are not supported\n-  --> $DIR/issue-35813-postfix-after-cast.rs:49:5\n+error: casts cannot be followed by a function call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:115:5\n+   |\n+LL |     drop as fn(u8)(0);\n+   |     ^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(drop as fn(u8))`\n+\n+error: casts cannot be followed by a function call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:117:5\n+   |\n+LL |     drop_ptr: fn(u8)(0);\n+   |     ^^^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(drop_ptr: fn(u8))`\n+\n+error: casts cannot be followed by `.await`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:122:5\n    |\n LL |     Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>.await;\n-   |     -----------------------------------------------------^^^^^^\n-   |     |\n-   |     help: try surrounding the expression with parentheses: `(Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>)`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(Box::pin(noop()) as Pin<Box<dyn Future<Output = ()>>>)`\n+\n+error: casts cannot be followed by `.await`\n+  --> $DIR/issue-35813-postfix-after-cast.rs:125:5\n+   |\n+LL |     Box::pin(noop()): Pin<Box<_>>.await;\n+   |     ^^^^^^^^^^^^^^^^-^^^^^^^^^^^^\n+   |                     |\n+   |                     help: maybe write a path separator here: `::`\n+   |\n+   = note: `#![feature(type_ascription)]` lets you annotate an expression with a type: `<expr>: <type>`\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/23416\n \n-error: casts followed by field access expressions are not supported\n-  --> $DIR/issue-35813-postfix-after-cast.rs:61:5\n+error: casts cannot be followed by a field access\n+  --> $DIR/issue-35813-postfix-after-cast.rs:137:5\n    |\n LL |     Foo::default() as Foo.bar;\n-   |     ---------------------^^^^\n-   |     |\n-   |     help: try surrounding the expression with parentheses: `(Foo::default() as Foo)`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(Foo::default() as Foo)`\n+\n+error: casts cannot be followed by a field access\n+  --> $DIR/issue-35813-postfix-after-cast.rs:139:5\n+   |\n+LL |     Foo::default(): Foo.bar;\n+   |     ^^^^^^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(Foo::default(): Foo)`\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:54:9\n+   |\n+LL |         if true { 33 } else { 44 } as i32.max(0),\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(if true { 33 } else { 44 } as i32)`\n+\n+error: casts cannot be followed by a method call\n+  --> $DIR/issue-35813-postfix-after-cast.rs:56:9\n+   |\n+LL |         if true { 33 } else { 44 }: i32.max(0)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try surrounding the expression in parentheses: `(if true { 33 } else { 44 }: i32)`\n+\n+error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n+  --> $DIR/issue-35813-postfix-after-cast.rs:101:13\n+   |\n+LL |     drop as F();\n+   |             ^^^ only `Fn` traits may use parentheses\n \n-error: casts followed by method call expressions are not supported\n-  --> $DIR/issue-35813-postfix-after-cast.rs:27:9\n+error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n+  --> $DIR/issue-35813-postfix-after-cast.rs:103:15\n    |\n-LL |         if true { 33 } else { 44 } as i32.max(0)\n-   |         ---------------------------------^^^^^^^\n-   |         |\n-   |         help: try surrounding the expression with parentheses: `(if true { 33 } else { 44 } as i32)`\n+LL |     drop_ptr: F();\n+   |               ^^^ only `Fn` traits may use parentheses\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 25 previous errors\n \n+For more information about this error, try `rustc --explain E0214`."}]}