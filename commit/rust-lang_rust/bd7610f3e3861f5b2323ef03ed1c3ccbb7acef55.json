{"sha": "bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNzYxMGYzZTM4NjFmNWIyMzIzZWYwM2VkMWMzY2NiYjdhY2VmNTU=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-10-16T16:04:51Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-10-16T16:28:25Z"}, "message": "introduce `base_and_len` fns for element length", "tree": {"sha": "86b750268c7f18371d34cb0c90a1752f2affef4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86b750268c7f18371d34cb0c90a1752f2affef4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55", "html_url": "https://github.com/rust-lang/rust/commit/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef3ec1fe97f6dbb641349e41cb252d611def91a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef3ec1fe97f6dbb641349e41cb252d611def91a5", "html_url": "https://github.com/rust-lang/rust/commit/ef3ec1fe97f6dbb641349e41cb252d611def91a5"}], "stats": {"total": 105, "additions": 75, "deletions": 30}, "files": [{"sha": "dbcfb4eebbffae8eaaee7df796e0315691296c98", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55", "patch": "@@ -1025,7 +1025,7 @@ fn extract_vec_elems(bcx: @mut Block,\n                       -> ExtractedBlock {\n     let _icx = push_ctxt(\"match::extract_vec_elems\");\n     let vec_datum = match_datum(bcx, val, pat_id);\n-    let (bcx, base, len) = vec_datum.get_vec_base_and_byte_len(bcx, pat_span, pat_id, 0);\n+    let (bcx, base, len) = vec_datum.get_vec_base_and_len(bcx, pat_span, pat_id, 0);\n     let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n \n     let mut elems = do vec::from_fn(elem_count) |i| {\n@@ -1042,13 +1042,9 @@ fn extract_vec_elems(bcx: @mut Block,\n     };\n     if slice.is_some() {\n         let n = slice.unwrap();\n-        let slice_offset = Mul(bcx, vt.llunit_size,\n-            C_int(bcx.ccx(), n as int)\n-        );\n-        let slice_begin = tvec::pointer_add(bcx, base, slice_offset);\n-        let slice_len_offset = Mul(bcx, vt.llunit_size,\n-            C_int(bcx.ccx(), (elem_count - 1u) as int)\n-        );\n+        let slice_byte_offset = Mul(bcx, vt.llunit_size, C_uint(bcx.ccx(), n));\n+        let slice_begin = tvec::pointer_add_byte(bcx, base, slice_byte_offset);\n+        let slice_len_offset = C_uint(bcx.ccx(), elem_count - 1u);\n         let slice_len = Sub(bcx, len, slice_len_offset);\n         let slice_ty = ty::mk_evec(bcx.tcx(),\n             ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable},\n@@ -1058,9 +1054,7 @@ fn extract_vec_elems(bcx: @mut Block,\n         Store(bcx, slice_begin,\n             GEPi(bcx, scratch.val, [0u, abi::slice_elt_base])\n         );\n-        Store(bcx, UDiv(bcx, slice_len, vt.llunit_size),\n-            GEPi(bcx, scratch.val, [0u, abi::slice_elt_len])\n-        );\n+        Store(bcx, slice_len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n         elems[n] = scratch.val;\n         scratch.add_clean(bcx);\n     }\n@@ -1646,8 +1640,8 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n             vec_len(*) => {\n                 let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n                 let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n-                let (_, len) = tvec::get_base_and_byte_len(bcx, unboxed, vt.vec_ty);\n-                test_val = SDiv(bcx, len, vt.llunit_size);\n+                let (_, len) = tvec::get_base_and_len(bcx, unboxed, vt.vec_ty);\n+                test_val = len;\n                 kind = compare_vec_len;\n             }\n         }"}, {"sha": "105cb6e5606db60772d51a4fc2880f8b9dc8a853", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55", "patch": "@@ -305,7 +305,7 @@ pub fn trans_fail_expr(bcx: @mut Block,\n                 bcx, expr::trans_to_datum(bcx, arg_expr));\n \n             if ty::type_is_str(arg_datum.ty) {\n-                let (lldata, _) = arg_datum.get_vec_base_and_byte_len_no_root(bcx);\n+                let (lldata, _) = arg_datum.get_vec_base_and_len_no_root(bcx);\n                 return trans_fail_value(bcx, sp_opt, lldata);\n             } else if bcx.unreachable || ty::type_is_bot(arg_datum.ty) {\n                 return bcx;"}, {"sha": "6411283b79d0e089a740723977fc27c8c43f21df", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55", "patch": "@@ -794,6 +794,30 @@ impl Datum {\n         tvec::get_base_and_byte_len(bcx, llval, self.ty)\n     }\n \n+    pub fn get_vec_base_and_len(&self,\n+                                     mut bcx: @mut Block,\n+                                     span: Span,\n+                                     expr_id: ast::NodeId,\n+                                     derefs: uint)\n+                                     -> (@mut Block, ValueRef, ValueRef) {\n+        //! Converts a vector into the slice pair. Performs rooting\n+        //! and write guards checks.\n+\n+        // only imp't for @[] and @str, but harmless\n+        bcx = write_guard::root_and_write_guard(self, bcx, span, expr_id, derefs);\n+        let (base, len) = self.get_vec_base_and_len_no_root(bcx);\n+        (bcx, base, len)\n+    }\n+\n+    pub fn get_vec_base_and_len_no_root(&self, bcx: @mut Block)\n+                                             -> (ValueRef, ValueRef) {\n+        //! Converts a vector into the slice pair. Des not root\n+        //! nor perform write guard checks.\n+\n+        let llval = self.to_appropriate_llval(bcx);\n+        tvec::get_base_and_len(bcx, llval, self.ty)\n+    }\n+\n     pub fn root_and_write_guard(&self,\n                                 bcx: @mut Block,\n                                 span: Span,"}, {"sha": "48d3e3f7c58b893d4c4f62ae805ea11ecd7b629f", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55", "patch": "@@ -265,7 +265,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         let unit_ty = ty::sequence_element_type(tcx, datum.ty);\n \n         let (bcx, base, len) =\n-            datum.get_vec_base_and_byte_len(bcx, expr.span, expr.id, autoderefs+1);\n+            datum.get_vec_base_and_len(bcx, expr.span, expr.id, autoderefs+1);\n \n         // this type may have a different region/mutability than the\n         // real one, but it will have the same runtime representation\n@@ -275,11 +275,8 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n \n         let scratch = scratch_datum(bcx, slice_ty, \"__adjust\", false);\n \n-        let vt = tvec::vec_types(bcx, datum.ty);\n-        let unscaled_len = UDiv(bcx, len, vt.llunit_size);\n-\n         Store(bcx, base, GEPi(bcx, scratch.val, [0u, abi::slice_elt_base]));\n-        Store(bcx, unscaled_len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n+        Store(bcx, len, GEPi(bcx, scratch.val, [0u, abi::slice_elt_len]));\n         DatumBlock {bcx: bcx, datum: scratch}\n     }\n \n@@ -978,17 +975,14 @@ fn trans_lvalue_unadjusted(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         base::maybe_name_value(bcx.ccx(), vt.llunit_size, \"unit_sz\");\n \n         let (bcx, base, len) =\n-            base_datum.get_vec_base_and_byte_len(bcx, index_expr.span,\n-                                                 index_expr.id, 0);\n+            base_datum.get_vec_base_and_len(bcx, index_expr.span, index_expr.id, 0);\n \n         debug2!(\"trans_index: base {}\", bcx.val_to_str(base));\n         debug2!(\"trans_index: len {}\", bcx.val_to_str(len));\n \n-        let unscaled_len = UDiv(bcx, len, vt.llunit_size);\n-        let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, unscaled_len);\n+        let bounds_check = ICmp(bcx, lib::llvm::IntUGE, ix_val, len);\n         let bcx = do with_cond(bcx, bounds_check) |bcx| {\n-            controlflow::trans_fail_bounds_check(bcx, index_expr.span,\n-                                                 ix_val, unscaled_len)\n+            controlflow::trans_fail_bounds_check(bcx, index_expr.span, ix_val, len)\n         };\n         let elt = InBoundsGEP(bcx, base, [ix_val]);\n         let elt = PointerCast(bcx, elt, vt.llunit_ty.ptr_to());"}, {"sha": "bde98eff41ce777a45d1edce4a05fcf29bd545e0", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=bd7610f3e3861f5b2323ef03ed1c3ccbb7acef55", "patch": "@@ -77,8 +77,8 @@ pub fn get_dataptr(bcx: @mut Block, vptr: ValueRef) -> ValueRef {\n     GEPi(bcx, vptr, [0u, abi::vec_elt_elems, 0u])\n }\n \n-pub fn pointer_add(bcx: @mut Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n-    let _icx = push_ctxt(\"tvec::pointer_add\");\n+pub fn pointer_add_byte(bcx: @mut Block, ptr: ValueRef, bytes: ValueRef) -> ValueRef {\n+    let _icx = push_ctxt(\"tvec::pointer_add_byte\");\n     let old_ty = val_ty(ptr);\n     let bptr = PointerCast(bcx, ptr, Type::i8p());\n     return PointerCast(bcx, InBoundsGEP(bcx, bptr, [bytes]), old_ty);\n@@ -501,8 +501,7 @@ pub fn elements_required(bcx: @mut Block, content_expr: &ast::Expr) -> uint {\n     }\n }\n \n-pub fn get_base_and_byte_len(bcx: @mut Block,\n-                        llval: ValueRef,\n+pub fn get_base_and_byte_len(bcx: @mut Block, llval: ValueRef,\n                         vec_ty: ty::t) -> (ValueRef, ValueRef) {\n     //!\n     //\n@@ -539,6 +538,40 @@ pub fn get_base_and_byte_len(bcx: @mut Block,\n     }\n }\n \n+pub fn get_base_and_len(bcx: @mut Block, llval: ValueRef, vec_ty: ty::t) -> (ValueRef, ValueRef) {\n+    //!\n+    //\n+    // Converts a vector into the slice pair.  The vector should be stored in\n+    // `llval` which should be either immediate or by-ref as appropriate for\n+    // the vector type.  If you have a datum, you would probably prefer to\n+    // call `Datum::get_base_and_len()` which will handle any conversions for\n+    // you.\n+\n+    let ccx = bcx.ccx();\n+    let vt = vec_types(bcx, vec_ty);\n+\n+    let vstore = match ty::get(vt.vec_ty).sty {\n+      ty::ty_estr(vst) | ty::ty_evec(_, vst) => vst,\n+      _ => ty::vstore_uniq\n+    };\n+\n+    match vstore {\n+        ty::vstore_fixed(n) => {\n+            let base = GEPi(bcx, llval, [0u, 0u]);\n+            (base, C_uint(ccx, n))\n+        }\n+        ty::vstore_slice(_) => {\n+            let base = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_base]));\n+            let count = Load(bcx, GEPi(bcx, llval, [0u, abi::slice_elt_len]));\n+            (base, count)\n+        }\n+        ty::vstore_uniq | ty::vstore_box => {\n+            let body = get_bodyptr(bcx, llval, vec_ty);\n+            (get_dataptr(bcx, body), UDiv(bcx, get_fill(bcx, body), vt.llunit_size))\n+        }\n+    }\n+}\n+\n pub type iter_vec_block<'self> = &'self fn(@mut Block, ValueRef, ty::t) -> @mut Block;\n \n pub fn iter_vec_raw(bcx: @mut Block, data_ptr: ValueRef, vec_ty: ty::t,\n@@ -551,7 +584,7 @@ pub fn iter_vec_raw(bcx: @mut Block, data_ptr: ValueRef, vec_ty: ty::t,\n     // FIXME (#3729): Optimize this when the size of the unit type is\n     // statically known to not use pointer casts, which tend to confuse\n     // LLVM.\n-    let data_end_ptr = pointer_add(bcx, data_ptr, fill);\n+    let data_end_ptr = pointer_add_byte(bcx, data_ptr, fill);\n \n     // Now perform the iteration.\n     let header_bcx = base::sub_block(bcx, \"iter_vec_loop_header\");"}]}