{"sha": "3c6f982cc908aacc39c3ac97f31c989f81cc213c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNmY5ODJjYzkwOGFhY2MzOWMzYWM5N2YzMWM5ODlmODFjYzIxM2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-19T09:18:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-19T09:18:49Z"}, "message": "Auto merge of #66131 - eddyb:local-def-id, r=petrochenkov\n\nrustc: use LocalDefId instead of DefIndex where possible.\n\nThat is, wherever `DefIndex` always referred to a \"def\" in the local crate, I replaced it with `LocalDefId`.\nWhile `LocalDefId` already existed, it wasn't used a lot, but I hope I'm on the right track.\n\nUnresolved questions:\n* [x] ~~should `LocalDefId` implement `rustc_index::Idx`?~~\n  * ~~this would get rid of a couple more `DefIndex` uses~~\n* [x] ~~should `LocalDefId` be encoded/decoded as just a `DefIndex`?~~\n  * ~~right now it's a bit messy, `LocalDefId` encodes/decodes like `DefId`~~\n* [x] ~~should `DefId::assert_local` be named something else, like `expect_local`?~~\n\nA future PR should change `tcx.hir().local_def_id(...)` to return `LocalDefId` instead of `DefId`, as changing it in this PR would be too noisy.\n\nr? @michaelwoerister cc @nikomatsakis @petrochenkov @Zoxc", "tree": {"sha": "721005f395aaf957869f5cd3f991f434792bd627", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/721005f395aaf957869f5cd3f991f434792bd627"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c6f982cc908aacc39c3ac97f31c989f81cc213c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c6f982cc908aacc39c3ac97f31c989f81cc213c", "html_url": "https://github.com/rust-lang/rust/commit/3c6f982cc908aacc39c3ac97f31c989f81cc213c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c6f982cc908aacc39c3ac97f31c989f81cc213c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6724d584b8e3b5fa5e06466d1e900cdd60953707", "url": "https://api.github.com/repos/rust-lang/rust/commits/6724d584b8e3b5fa5e06466d1e900cdd60953707", "html_url": "https://github.com/rust-lang/rust/commit/6724d584b8e3b5fa5e06466d1e900cdd60953707"}, {"sha": "16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "url": "https://api.github.com/repos/rust-lang/rust/commits/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84", "html_url": "https://github.com/rust-lang/rust/commit/16e25f0ea3cb93cac85f6107ce62a5d4adbb3e84"}], "stats": {"total": 793, "additions": 357, "deletions": 436}, "files": [{"sha": "b32fa2cda80129e2d59a2646e63af51eaea1476f", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -63,7 +63,7 @@ use crate::ty::subst::SubstsRef;\n use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::HirId;\n use rustc_span::symbol::Symbol;\n use std::fmt;\n@@ -413,19 +413,19 @@ impl<'tcx> DepNodeParams<'tcx> for DefId {\n     }\n }\n \n-impl<'tcx> DepNodeParams<'tcx> for DefIndex {\n+impl<'tcx> DepNodeParams<'tcx> for LocalDefId {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n \n     fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n-        tcx.hir().definitions().def_path_hash(*self).0\n+        self.to_def_id().to_fingerprint(tcx)\n     }\n \n     fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n-        tcx.def_path_str(DefId::local(*self))\n+        self.to_def_id().to_debug_str(tcx)\n     }\n \n     fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n-        dep_node.extract_def_id(tcx).map(|id| id.index)\n+        dep_node.extract_def_id(tcx).map(|id| id.expect_local())\n     }\n }\n \n@@ -477,7 +477,7 @@ impl<'tcx> DepNodeParams<'tcx> for HirId {\n     fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n         let HirId { owner, local_id } = *self;\n \n-        let def_path_hash = tcx.def_path_hash(DefId::local(owner));\n+        let def_path_hash = tcx.def_path_hash(owner.to_def_id());\n         let local_id = Fingerprint::from_smaller_hash(local_id.as_u32().into());\n \n         def_path_hash.0.combine(local_id)"}, {"sha": "f60d20b8cb75d0972ba4e06657d77978867758f0", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -902,7 +902,7 @@ impl DepGraph {\n \n fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    def_id.index == hir_id.owner\n+    def_id.index == hir_id.owner.local_def_index\n }\n \n /// A \"work product\" is an intermediate result that we save into the"}, {"sha": "de0cc61118fed9abe8142d2b1359c85287a9d956", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -10,7 +10,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n use rustc_hir::def_id::CRATE_DEF_INDEX;\n-use rustc_hir::def_id::{DefIndex, LOCAL_CRATE};\n+use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::*;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -30,12 +30,12 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     /// Source map\n     source_map: &'a SourceMap,\n \n-    map: IndexVec<DefIndex, HirOwnerData<'hir>>,\n+    map: IndexVec<LocalDefId, HirOwnerData<'hir>>,\n \n     /// The parent of this node\n     parent_node: hir::HirId,\n \n-    current_dep_node_owner: DefIndex,\n+    current_dep_node_owner: LocalDefId,\n \n     definitions: &'a definitions::Definitions,\n \n@@ -98,7 +98,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         definitions: &'a definitions::Definitions,\n         mut hcx: StableHashingContext<'a>,\n     ) -> NodeCollector<'a, 'hir> {\n-        let root_mod_def_path_hash = definitions.def_path_hash(CRATE_DEF_INDEX);\n+        let root_mod_def_path_hash =\n+            definitions.def_path_hash(LocalDefId { local_def_index: CRATE_DEF_INDEX });\n \n         let mut hir_body_nodes = Vec::new();\n \n@@ -126,7 +127,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             krate,\n             source_map: sess.source_map(),\n             parent_node: hir::CRATE_HIR_ID,\n-            current_dep_node_owner: CRATE_DEF_INDEX,\n+            current_dep_node_owner: LocalDefId { local_def_index: CRATE_DEF_INDEX },\n             definitions,\n             hcx,\n             hir_body_nodes,\n@@ -148,7 +149,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         crate_disambiguator: CrateDisambiguator,\n         cstore: &dyn CrateStore,\n         commandline_args_hash: u64,\n-    ) -> (IndexVec<DefIndex, HirOwnerData<'hir>>, Svh) {\n+    ) -> (IndexVec<LocalDefId, HirOwnerData<'hir>>, Svh) {\n         // Insert bodies into the map\n         for (id, body) in self.krate.bodies.iter() {\n             let bodies = &mut self.map[id.hir_id.owner].with_bodies.as_mut().unwrap().bodies;\n@@ -244,8 +245,8 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             assert_eq!(self.definitions.node_to_hir_id(node_id), hir_id);\n \n             if hir_id.owner != self.current_dep_node_owner {\n-                let node_str = match self.definitions.opt_def_index(node_id) {\n-                    Some(def_index) => self.definitions.def_path(def_index).to_string_no_crate(),\n+                let node_str = match self.definitions.opt_local_def_id(node_id) {\n+                    Some(def_id) => self.definitions.def_path(def_id).to_string_no_crate(),\n                     None => format!(\"{:?}\", node),\n                 };\n \n@@ -285,7 +286,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n         F: FnOnce(&mut Self, Fingerprint),\n     >(\n         &mut self,\n-        dep_node_owner: DefIndex,\n+        dep_node_owner: LocalDefId,\n         item_like: &T,\n         f: F,\n     ) {\n@@ -341,7 +342,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         debug!(\"visit_item: {:?}\", i);\n         debug_assert_eq!(\n             i.hir_id.owner,\n-            self.definitions.opt_def_index(self.definitions.hir_to_node_id(i.hir_id)).unwrap()\n+            self.definitions.opt_local_def_id(self.definitions.hir_to_node_id(i.hir_id)).unwrap()\n         );\n         self.with_dep_node_owner(i.hir_id.owner, i, |this, hash| {\n             this.insert_with_hash(i.span, i.hir_id, Node::Item(i), hash);\n@@ -373,7 +374,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n         debug_assert_eq!(\n             ti.hir_id.owner,\n-            self.definitions.opt_def_index(self.definitions.hir_to_node_id(ti.hir_id)).unwrap()\n+            self.definitions.opt_local_def_id(self.definitions.hir_to_node_id(ti.hir_id)).unwrap()\n         );\n         self.with_dep_node_owner(ti.hir_id.owner, ti, |this, hash| {\n             this.insert_with_hash(ti.span, ti.hir_id, Node::TraitItem(ti), hash);\n@@ -387,7 +388,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n         debug_assert_eq!(\n             ii.hir_id.owner,\n-            self.definitions.opt_def_index(self.definitions.hir_to_node_id(ii.hir_id)).unwrap()\n+            self.definitions.opt_local_def_id(self.definitions.hir_to_node_id(ii.hir_id)).unwrap()\n         );\n         self.with_dep_node_owner(ii.hir_id.owner, ii, |this, hash| {\n             this.insert_with_hash(ii.span, ii.hir_id, Node::ImplItem(ii), hash);\n@@ -506,10 +507,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_macro_def(&mut self, macro_def: &'hir MacroDef<'hir>) {\n-        let node_id = self.definitions.hir_to_node_id(macro_def.hir_id);\n-        let def_index = self.definitions.opt_def_index(node_id).unwrap();\n-\n-        self.with_dep_node_owner(def_index, macro_def, |this, hash| {\n+        self.with_dep_node_owner(macro_def.hir_id.owner, macro_def, |this, hash| {\n             this.insert_with_hash(\n                 macro_def.span,\n                 macro_def.hir_id,"}, {"sha": "aa4742ea891bb7e19580f139ddc67d327e74d0e4", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 77, "deletions": 81, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -5,11 +5,10 @@\n //! expressions) that are mostly just leftovers.\n \n use rustc_ast::ast;\n-use rustc_ast::node_id::NodeMap;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_index::vec::IndexVec;\n use rustc_session::CrateDisambiguator;\n use rustc_span::hygiene::ExpnId;\n@@ -78,25 +77,29 @@ impl DefPathTable {\n #[derive(Clone, Default)]\n pub struct Definitions {\n     table: DefPathTable,\n-    node_to_def_index: NodeMap<DefIndex>,\n-    def_index_to_node: IndexVec<DefIndex, ast::NodeId>,\n \n-    pub(super) node_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n-    /// The reverse mapping of `node_to_hir_id`.\n-    pub(super) hir_to_node_id: FxHashMap<hir::HirId, ast::NodeId>,\n+    def_id_to_span: IndexVec<LocalDefId, Span>,\n+\n+    // FIXME(eddyb) don't go through `ast::NodeId` to convert between `HirId`\n+    // and `LocalDefId` - ideally all `LocalDefId`s would be HIR owners.\n+    node_id_to_def_id: FxHashMap<ast::NodeId, LocalDefId>,\n+    def_id_to_node_id: IndexVec<LocalDefId, ast::NodeId>,\n+\n+    pub(super) node_id_to_hir_id: IndexVec<ast::NodeId, hir::HirId>,\n+    /// The reverse mapping of `node_id_to_hir_id`.\n+    pub(super) hir_id_to_node_id: FxHashMap<hir::HirId, ast::NodeId>,\n \n     /// If `ExpnId` is an ID of some macro expansion,\n     /// then `DefId` is the normal module (`mod`) in which the expanded macro was defined.\n     parent_modules_of_macro_defs: FxHashMap<ExpnId, DefId>,\n-    /// Item with a given `DefIndex` was defined during macro expansion with ID `ExpnId`.\n-    expansions_that_defined: FxHashMap<DefIndex, ExpnId>,\n-    next_disambiguator: FxHashMap<(DefIndex, DefPathData), u32>,\n-    def_index_to_span: FxHashMap<DefIndex, Span>,\n+    /// Item with a given `LocalDefId` was defined during macro expansion with ID `ExpnId`.\n+    expansions_that_defined: FxHashMap<LocalDefId, ExpnId>,\n+    next_disambiguator: FxHashMap<(LocalDefId, DefPathData), u32>,\n     /// When collecting definitions from an AST fragment produced by a macro invocation `ExpnId`\n     /// we know what parent node that fragment should be attached to thanks to this table.\n-    invocation_parents: FxHashMap<ExpnId, DefIndex>,\n+    invocation_parents: FxHashMap<ExpnId, LocalDefId>,\n     /// Indices of unnamed struct or variant fields with unresolved attributes.\n-    placeholder_field_indices: NodeMap<usize>,\n+    placeholder_field_indices: FxHashMap<ast::NodeId, usize>,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -296,43 +299,41 @@ impl Definitions {\n         self.table.index_to_key.len()\n     }\n \n-    pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.table.def_key(index)\n+    pub fn def_key(&self, id: LocalDefId) -> DefKey {\n+        self.table.def_key(id.local_def_index)\n     }\n \n     #[inline(always)]\n-    pub fn def_path_hash(&self, index: DefIndex) -> DefPathHash {\n-        self.table.def_path_hash(index)\n+    pub fn def_path_hash(&self, id: LocalDefId) -> DefPathHash {\n+        self.table.def_path_hash(id.local_def_index)\n     }\n \n     /// Returns the path from the crate root to `index`. The root\n     /// nodes are not included in the path (i.e., this will be an\n     /// empty vector for the crate root). For an inlined item, this\n     /// will be the path of the item in the external crate (but the\n     /// path will begin with the path to the external crate).\n-    pub fn def_path(&self, index: DefIndex) -> DefPath {\n-        DefPath::make(LOCAL_CRATE, index, |p| self.def_key(p))\n+    pub fn def_path(&self, id: LocalDefId) -> DefPath {\n+        DefPath::make(LOCAL_CRATE, id.local_def_index, |index| {\n+            self.def_key(LocalDefId { local_def_index: index })\n+        })\n     }\n \n     #[inline]\n-    pub fn opt_def_index(&self, node: ast::NodeId) -> Option<DefIndex> {\n-        self.node_to_def_index.get(&node).copied()\n-    }\n-\n-    #[inline]\n-    pub fn opt_local_def_id(&self, node: ast::NodeId) -> Option<DefId> {\n-        self.opt_def_index(node).map(DefId::local)\n+    pub fn opt_local_def_id(&self, node: ast::NodeId) -> Option<LocalDefId> {\n+        self.node_id_to_def_id.get(&node).copied()\n     }\n \n+    // FIXME(eddyb) this function can and should return `LocalDefId`.\n     #[inline]\n     pub fn local_def_id(&self, node: ast::NodeId) -> DefId {\n-        self.opt_local_def_id(node).unwrap()\n+        self.opt_local_def_id(node).unwrap().to_def_id()\n     }\n \n     #[inline]\n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n-        if def_id.krate == LOCAL_CRATE {\n-            let node_id = self.def_index_to_node[def_id.index];\n+        if let Some(def_id) = def_id.as_local() {\n+            let node_id = self.def_id_to_node_id[def_id];\n             if node_id != ast::DUMMY_NODE_ID {\n                 return Some(node_id);\n             }\n@@ -342,47 +343,44 @@ impl Definitions {\n \n     #[inline]\n     pub fn as_local_hir_id(&self, def_id: DefId) -> Option<hir::HirId> {\n-        if def_id.krate == LOCAL_CRATE {\n-            let hir_id = self.def_index_to_hir_id(def_id.index);\n+        if let Some(def_id) = def_id.as_local() {\n+            let hir_id = self.local_def_id_to_hir_id(def_id);\n             if hir_id != hir::DUMMY_HIR_ID { Some(hir_id) } else { None }\n         } else {\n             None\n         }\n     }\n \n+    // FIXME(eddyb) rename to `hir_id_to_node_id`.\n     #[inline]\n     pub fn hir_to_node_id(&self, hir_id: hir::HirId) -> ast::NodeId {\n-        self.hir_to_node_id[&hir_id]\n+        self.hir_id_to_node_id[&hir_id]\n     }\n \n+    // FIXME(eddyb) rename to `node_id_to_hir_id`.\n     #[inline]\n     pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n-        self.node_to_hir_id[node_id]\n+        self.node_id_to_hir_id[node_id]\n     }\n \n     #[inline]\n-    pub fn def_index_to_hir_id(&self, def_index: DefIndex) -> hir::HirId {\n-        let node_id = self.def_index_to_node[def_index];\n-        self.node_to_hir_id[node_id]\n+    pub fn local_def_id_to_hir_id(&self, id: LocalDefId) -> hir::HirId {\n+        let node_id = self.def_id_to_node_id[id];\n+        self.node_id_to_hir_id[node_id]\n     }\n \n-    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate, the span exists\n-    /// and it's not `DUMMY_SP`.\n+    /// Retrieves the span of the given `DefId` if `DefId` is in the local crate.\n     #[inline]\n     pub fn opt_span(&self, def_id: DefId) -> Option<Span> {\n-        if def_id.krate == LOCAL_CRATE {\n-            self.def_index_to_span.get(&def_id.index).copied()\n-        } else {\n-            None\n-        }\n+        if let Some(def_id) = def_id.as_local() { Some(self.def_id_to_span[def_id]) } else { None }\n     }\n \n     /// Adds a root definition (no parent) and a few other reserved definitions.\n     pub fn create_root_def(\n         &mut self,\n         crate_name: &str,\n         crate_disambiguator: CrateDisambiguator,\n-    ) -> DefIndex {\n+    ) -> LocalDefId {\n         let key = DefKey {\n             parent: None,\n             disambiguated_data: DisambiguatedDefPathData {\n@@ -395,36 +393,38 @@ impl Definitions {\n         let def_path_hash = key.compute_stable_hash(parent_hash);\n \n         // Create the definition.\n-        let root_index = self.table.allocate(key, def_path_hash);\n-        assert_eq!(root_index, CRATE_DEF_INDEX);\n-        assert!(self.def_index_to_node.is_empty());\n-        self.def_index_to_node.push(ast::CRATE_NODE_ID);\n-        self.node_to_def_index.insert(ast::CRATE_NODE_ID, root_index);\n-        self.set_invocation_parent(ExpnId::root(), root_index);\n+        let root = LocalDefId { local_def_index: self.table.allocate(key, def_path_hash) };\n+        assert_eq!(root.local_def_index, CRATE_DEF_INDEX);\n+\n+        assert_eq!(self.def_id_to_node_id.push(ast::CRATE_NODE_ID), root);\n+        assert_eq!(self.def_id_to_span.push(rustc_span::DUMMY_SP), root);\n+\n+        self.node_id_to_def_id.insert(ast::CRATE_NODE_ID, root);\n+        self.set_invocation_parent(ExpnId::root(), root);\n \n-        root_index\n+        root\n     }\n \n     /// Adds a definition with a parent definition.\n     pub fn create_def_with_parent(\n         &mut self,\n-        parent: DefIndex,\n+        parent: LocalDefId,\n         node_id: ast::NodeId,\n         data: DefPathData,\n         expn_id: ExpnId,\n         span: Span,\n-    ) -> DefIndex {\n+    ) -> LocalDefId {\n         debug!(\n             \"create_def_with_parent(parent={:?}, node_id={:?}, data={:?})\",\n             parent, node_id, data\n         );\n \n         assert!(\n-            !self.node_to_def_index.contains_key(&node_id),\n+            !self.node_id_to_def_id.contains_key(&node_id),\n             \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n             node_id,\n             data,\n-            self.table.def_key(self.node_to_def_index[&node_id])\n+            self.table.def_key(self.node_id_to_def_id[&node_id].local_def_index),\n         );\n \n         // The root node must be created with `create_root_def()`.\n@@ -439,59 +439,55 @@ impl Definitions {\n         };\n \n         let key = DefKey {\n-            parent: Some(parent),\n+            parent: Some(parent.local_def_index),\n             disambiguated_data: DisambiguatedDefPathData { data, disambiguator },\n         };\n \n-        let parent_hash = self.table.def_path_hash(parent);\n+        let parent_hash = self.table.def_path_hash(parent.local_def_index);\n         let def_path_hash = key.compute_stable_hash(parent_hash);\n \n         debug!(\"create_def_with_parent: after disambiguation, key = {:?}\", key);\n \n         // Create the definition.\n-        let index = self.table.allocate(key, def_path_hash);\n-        assert_eq!(index.index(), self.def_index_to_node.len());\n-        self.def_index_to_node.push(node_id);\n+        let def_id = LocalDefId { local_def_index: self.table.allocate(key, def_path_hash) };\n \n-        // Some things for which we allocate `DefIndex`es don't correspond to\n+        assert_eq!(self.def_id_to_node_id.push(node_id), def_id);\n+        assert_eq!(self.def_id_to_span.push(span), def_id);\n+\n+        // Some things for which we allocate `LocalDefId`s don't correspond to\n         // anything in the AST, so they don't have a `NodeId`. For these cases\n-        // we don't need a mapping from `NodeId` to `DefIndex`.\n+        // we don't need a mapping from `NodeId` to `LocalDefId`.\n         if node_id != ast::DUMMY_NODE_ID {\n-            debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n-            self.node_to_def_index.insert(node_id, index);\n+            debug!(\"create_def_with_parent: def_id_to_node_id[{:?}] <-> {:?}\", def_id, node_id);\n+            self.node_id_to_def_id.insert(node_id, def_id);\n         }\n \n         if expn_id != ExpnId::root() {\n-            self.expansions_that_defined.insert(index, expn_id);\n-        }\n-\n-        // The span is added if it isn't dummy.\n-        if !span.is_dummy() {\n-            self.def_index_to_span.insert(index, span);\n+            self.expansions_that_defined.insert(def_id, expn_id);\n         }\n \n-        index\n+        def_id\n     }\n \n     /// Initializes the `ast::NodeId` to `HirId` mapping once it has been generated during\n     /// AST to HIR lowering.\n     pub fn init_node_id_to_hir_id_mapping(&mut self, mapping: IndexVec<ast::NodeId, hir::HirId>) {\n         assert!(\n-            self.node_to_hir_id.is_empty(),\n+            self.node_id_to_hir_id.is_empty(),\n             \"trying to initialize `NodeId` -> `HirId` mapping twice\"\n         );\n-        self.node_to_hir_id = mapping;\n+        self.node_id_to_hir_id = mapping;\n \n-        // Build the reverse mapping of `node_to_hir_id`.\n-        self.hir_to_node_id = self\n-            .node_to_hir_id\n+        // Build the reverse mapping of `node_id_to_hir_id`.\n+        self.hir_id_to_node_id = self\n+            .node_id_to_hir_id\n             .iter_enumerated()\n             .map(|(node_id, &hir_id)| (hir_id, node_id))\n             .collect();\n     }\n \n-    pub fn expansion_that_defined(&self, index: DefIndex) -> ExpnId {\n-        self.expansions_that_defined.get(&index).copied().unwrap_or(ExpnId::root())\n+    pub fn expansion_that_defined(&self, id: LocalDefId) -> ExpnId {\n+        self.expansions_that_defined.get(&id).copied().unwrap_or(ExpnId::root())\n     }\n \n     pub fn parent_module_of_macro_def(&self, expn_id: ExpnId) -> DefId {\n@@ -502,13 +498,13 @@ impl Definitions {\n         self.parent_modules_of_macro_defs.insert(expn_id, module);\n     }\n \n-    pub fn invocation_parent(&self, invoc_id: ExpnId) -> DefIndex {\n+    pub fn invocation_parent(&self, invoc_id: ExpnId) -> LocalDefId {\n         self.invocation_parents[&invoc_id]\n     }\n \n-    pub fn set_invocation_parent(&mut self, invoc_id: ExpnId, parent: DefIndex) {\n+    pub fn set_invocation_parent(&mut self, invoc_id: ExpnId, parent: LocalDefId) {\n         let old_parent = self.invocation_parents.insert(invoc_id, parent);\n-        assert!(old_parent.is_none(), \"parent `DefIndex` is reset for an invocation\");\n+        assert!(old_parent.is_none(), \"parent `LocalDefId` is reset for an invocation\");\n     }\n \n     pub fn placeholder_field_index(&self, node_id: ast::NodeId) -> usize {"}, {"sha": "e3386a2a910ed31596b5bb6cd4b3d2702ea46d2a", "filename": "src/librustc/hir/map/hir_id_validator.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fhir_id_validator.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -3,7 +3,7 @@ use crate::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::{par_iter, Lock, ParallelIterator};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::intravisit;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::{HirId, ItemLocalId};\n@@ -32,7 +32,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n \n struct HirIdValidator<'a, 'hir> {\n     hir_map: Map<'hir>,\n-    owner_def_index: Option<DefIndex>,\n+    owner: Option<LocalDefId>,\n     hir_ids_seen: FxHashSet<ItemLocalId>,\n     errors: &'a Lock<Vec<String>>,\n }\n@@ -46,7 +46,7 @@ impl<'a, 'hir> OuterVisitor<'a, 'hir> {\n     fn new_inner_visitor(&self, hir_map: Map<'hir>) -> HirIdValidator<'a, 'hir> {\n         HirIdValidator {\n             hir_map,\n-            owner_def_index: None,\n+            owner: None,\n             hir_ids_seen: Default::default(),\n             errors: self.errors,\n         }\n@@ -78,12 +78,12 @@ impl<'a, 'hir> HirIdValidator<'a, 'hir> {\n     }\n \n     fn check<F: FnOnce(&mut HirIdValidator<'a, 'hir>)>(&mut self, hir_id: HirId, walk: F) {\n-        assert!(self.owner_def_index.is_none());\n-        let owner_def_index = self.hir_map.local_def_id(hir_id).index;\n-        self.owner_def_index = Some(owner_def_index);\n+        assert!(self.owner.is_none());\n+        let owner = self.hir_map.local_def_id(hir_id).expect_local();\n+        self.owner = Some(owner);\n         walk(self);\n \n-        if owner_def_index == CRATE_DEF_INDEX {\n+        if owner.local_def_index == CRATE_DEF_INDEX {\n             return;\n         }\n \n@@ -105,27 +105,26 @@ impl<'a, 'hir> HirIdValidator<'a, 'hir> {\n             let mut missing_items = Vec::with_capacity(missing.len());\n \n             for local_id in missing {\n-                let hir_id =\n-                    HirId { owner: owner_def_index, local_id: ItemLocalId::from_u32(local_id) };\n+                let hir_id = HirId { owner, local_id: ItemLocalId::from_u32(local_id) };\n \n                 trace!(\"missing hir id {:#?}\", hir_id);\n \n                 missing_items.push(format!(\n                     \"[local_id: {}, owner: {}]\",\n                     local_id,\n-                    self.hir_map.def_path(DefId::local(owner_def_index)).to_string_no_crate()\n+                    self.hir_map.def_path(owner).to_string_no_crate()\n                 ));\n             }\n             self.error(|| {\n                 format!(\n                     \"ItemLocalIds not assigned densely in {}. \\\n                 Max ItemLocalId = {}, missing IDs = {:?}; seens IDs = {:?}\",\n-                    self.hir_map.def_path(DefId::local(owner_def_index)).to_string_no_crate(),\n+                    self.hir_map.def_path(owner).to_string_no_crate(),\n                     max,\n                     missing_items,\n                     self.hir_ids_seen\n                         .iter()\n-                        .map(|&local_id| HirId { owner: owner_def_index, local_id })\n+                        .map(|&local_id| HirId { owner, local_id })\n                         .map(|h| format!(\"({:?} {})\", h, self.hir_map.node_to_string(h)))\n                         .collect::<Vec<_>>()\n                 )\n@@ -142,7 +141,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n     }\n \n     fn visit_id(&mut self, hir_id: HirId) {\n-        let owner = self.owner_def_index.expect(\"no owner_def_index\");\n+        let owner = self.owner.expect(\"no owner\");\n \n         if hir_id == hir::DUMMY_HIR_ID {\n             self.error(|| {\n@@ -159,8 +158,8 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n                 format!(\n                     \"HirIdValidator: The recorded owner of {} is {} instead of {}\",\n                     self.hir_map.node_to_string(hir_id),\n-                    self.hir_map.def_path(DefId::local(hir_id.owner)).to_string_no_crate(),\n-                    self.hir_map.def_path(DefId::local(owner)).to_string_no_crate()\n+                    self.hir_map.def_path(hir_id.owner).to_string_no_crate(),\n+                    self.hir_map.def_path(owner).to_string_no_crate()\n                 )\n             });\n         }"}, {"sha": "36cb19c6c37c727f8c30adb1bf28adbd2a134c24", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -9,7 +9,7 @@ use crate::ty::TyCtxt;\n use rustc_ast::ast::{self, Name, NodeId};\n use rustc_data_structures::svh::Svh;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::intravisit;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::print::Nested;\n@@ -138,7 +138,7 @@ pub struct IndexedHir<'hir> {\n     /// The SVH of the local crate.\n     pub crate_hash: Svh,\n \n-    pub(super) map: IndexVec<DefIndex, HirOwnerData<'hir>>,\n+    pub(super) map: IndexVec<LocalDefId, HirOwnerData<'hir>>,\n }\n \n #[derive(Copy, Clone)]\n@@ -188,20 +188,19 @@ impl<'hir> Map<'hir> {\n         &self.tcx.definitions\n     }\n \n-    pub fn def_key(&self, def_id: DefId) -> DefKey {\n-        assert!(def_id.is_local());\n-        self.tcx.definitions.def_key(def_id.index)\n+    pub fn def_key(&self, def_id: LocalDefId) -> DefKey {\n+        self.tcx.definitions.def_key(def_id)\n     }\n \n     pub fn def_path_from_hir_id(&self, id: HirId) -> Option<DefPath> {\n-        self.opt_local_def_id(id).map(|def_id| self.def_path(def_id))\n+        self.opt_local_def_id(id).map(|def_id| self.def_path(def_id.expect_local()))\n     }\n \n-    pub fn def_path(&self, def_id: DefId) -> DefPath {\n-        assert!(def_id.is_local());\n-        self.tcx.definitions.def_path(def_id.index)\n+    pub fn def_path(&self, def_id: LocalDefId) -> DefPath {\n+        self.tcx.definitions.def_path(def_id)\n     }\n \n+    // FIXME(eddyb) this function can and should return `LocalDefId`.\n     #[inline]\n     pub fn local_def_id_from_node_id(&self, node: NodeId) -> DefId {\n         self.opt_local_def_id_from_node_id(node).unwrap_or_else(|| {\n@@ -214,6 +213,7 @@ impl<'hir> Map<'hir> {\n         })\n     }\n \n+    // FIXME(eddyb) this function can and should return `LocalDefId`.\n     #[inline]\n     pub fn local_def_id(&self, hir_id: HirId) -> DefId {\n         self.opt_local_def_id(hir_id).unwrap_or_else(|| {\n@@ -228,12 +228,12 @@ impl<'hir> Map<'hir> {\n     #[inline]\n     pub fn opt_local_def_id(&self, hir_id: HirId) -> Option<DefId> {\n         let node_id = self.hir_to_node_id(hir_id);\n-        self.tcx.definitions.opt_local_def_id(node_id)\n+        self.opt_local_def_id_from_node_id(node_id)\n     }\n \n     #[inline]\n     pub fn opt_local_def_id_from_node_id(&self, node: NodeId) -> Option<DefId> {\n-        self.tcx.definitions.opt_local_def_id(node)\n+        Some(self.tcx.definitions.opt_local_def_id(node)?.to_def_id())\n     }\n \n     #[inline]\n@@ -256,14 +256,9 @@ impl<'hir> Map<'hir> {\n         self.tcx.definitions.node_to_hir_id(node_id)\n     }\n \n-    #[inline]\n-    pub fn def_index_to_hir_id(&self, def_index: DefIndex) -> HirId {\n-        self.tcx.definitions.def_index_to_hir_id(def_index)\n-    }\n-\n     #[inline]\n     pub fn local_def_id_to_hir_id(&self, def_id: LocalDefId) -> HirId {\n-        self.tcx.definitions.def_index_to_hir_id(def_id.to_def_id().index)\n+        self.tcx.definitions.local_def_id_to_hir_id(def_id)\n     }\n \n     pub fn def_kind(&self, hir_id: HirId) -> Option<DefKind> {\n@@ -347,10 +342,10 @@ impl<'hir> Map<'hir> {\n \n     fn get_entry(&self, id: HirId) -> Entry<'hir> {\n         if id.local_id == ItemLocalId::from_u32(0) {\n-            let owner = self.tcx.hir_owner(id.owner_def_id());\n+            let owner = self.tcx.hir_owner(id.owner);\n             Entry { parent: owner.parent, node: owner.node }\n         } else {\n-            let owner = self.tcx.hir_owner_items(id.owner_def_id());\n+            let owner = self.tcx.hir_owner_items(id.owner);\n             let item = owner.items[id.local_id].as_ref().unwrap();\n             Entry { parent: HirId { owner: id.owner, local_id: item.parent }, node: item.node }\n         }\n@@ -378,11 +373,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n-        self.tcx\n-            .hir_owner_items(DefId::local(id.hir_id.owner))\n-            .bodies\n-            .get(&id.hir_id.local_id)\n-            .unwrap()\n+        self.tcx.hir_owner_items(id.hir_id.owner).bodies.get(&id.hir_id.local_id).unwrap()\n     }\n \n     pub fn fn_decl_by_hir_id(&self, hir_id: HirId) -> Option<&'hir FnDecl<'hir>> {\n@@ -410,6 +401,7 @@ impl<'hir> Map<'hir> {\n         parent\n     }\n \n+    // FIXME(eddyb) this function can and should return `LocalDefId`.\n     pub fn body_owner_def_id(&self, id: BodyId) -> DefId {\n         self.local_def_id(self.body_owner(id))\n     }\n@@ -496,7 +488,7 @@ impl<'hir> Map<'hir> {\n     where\n         V: ItemLikeVisitor<'hir>,\n     {\n-        let module = self.tcx.hir_module_items(module);\n+        let module = self.tcx.hir_module_items(module.expect_local());\n \n         for id in &module.items {\n             visitor.visit_item(self.expect_item(*id));\n@@ -782,6 +774,7 @@ impl<'hir> Map<'hir> {\n         scope\n     }\n \n+    // FIXME(eddyb) this function can and should return `LocalDefId`.\n     pub fn get_parent_did(&self, id: HirId) -> DefId {\n         self.local_def_id(self.get_parent_item(id))\n     }"}, {"sha": "0042b6a3bd42f65b09a9f242c206c991481aa955", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -11,7 +11,7 @@ use crate::ty::TyCtxt;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{LocalDefId, LOCAL_CRATE};\n use rustc_hir::Body;\n use rustc_hir::HirId;\n use rustc_hir::ItemLocalId;\n@@ -60,27 +60,27 @@ impl<'tcx> TyCtxt<'tcx> {\n         map::Map { tcx: self }\n     }\n \n-    pub fn parent_module(self, id: HirId) -> DefId {\n-        self.parent_module_from_def_id(DefId::local(id.owner))\n+    pub fn parent_module(self, id: HirId) -> LocalDefId {\n+        self.parent_module_from_def_id(id.owner)\n     }\n }\n \n pub fn provide(providers: &mut Providers<'_>) {\n     providers.parent_module_from_def_id = |tcx, id| {\n         let hir = tcx.hir();\n-        hir.local_def_id(hir.get_module_parent_node(hir.as_local_hir_id(id).unwrap()))\n+        hir.local_def_id(hir.get_module_parent_node(hir.as_local_hir_id(id.to_def_id()).unwrap()))\n+            .expect_local()\n     };\n     providers.hir_crate = |tcx, _| tcx.untracked_crate;\n     providers.index_hir = map::index_hir;\n     providers.hir_module_items = |tcx, id| {\n-        assert_eq!(id.krate, LOCAL_CRATE);\n         let hir = tcx.hir();\n-        let module = hir.as_local_hir_id(id).unwrap();\n+        let module = hir.as_local_hir_id(id.to_def_id()).unwrap();\n         &tcx.untracked_crate.modules[&module]\n     };\n-    providers.hir_owner = |tcx, id| tcx.index_hir(id.krate).map[id.index].signature.unwrap();\n+    providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature.unwrap();\n     providers.hir_owner_items = |tcx, id| {\n-        tcx.index_hir(id.krate).map[id.index].with_bodies.as_ref().map(|items| &**items).unwrap()\n+        tcx.index_hir(LOCAL_CRATE).map[id].with_bodies.as_ref().map(|items| &**items).unwrap()\n     };\n     map::provide(providers);\n }"}, {"sha": "ba3763f6ee0bd8818ede3eb30b8063bf1b7a5d5c", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -8,7 +8,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, DefIndex};\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_session::Session;\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::Symbol;\n@@ -123,16 +123,16 @@ impl<'a> StableHashingContext<'a> {\n \n     #[inline]\n     pub fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n-        if def_id.is_local() {\n-            self.definitions.def_path_hash(def_id.index)\n+        if let Some(def_id) = def_id.as_local() {\n+            self.local_def_path_hash(def_id)\n         } else {\n             self.cstore.def_path_hash(def_id)\n         }\n     }\n \n     #[inline]\n-    pub fn local_def_path_hash(&self, def_index: DefIndex) -> DefPathHash {\n-        self.definitions.def_path_hash(def_index)\n+    pub fn local_def_path_hash(&self, def_id: LocalDefId) -> DefPathHash {\n+        self.definitions.def_path_hash(def_id)\n     }\n \n     #[inline]"}, {"sha": "1722b29266ad264e2238bb46d5d5f65eefd13f1b", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -6,7 +6,7 @@ use crate::ich::{Fingerprint, NodeIdHashingMode, StableHashingContext};\n use rustc_attr as attr;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher, ToStableHashKey};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX};\n use smallvec::SmallVec;\n use std::mem;\n \n@@ -116,8 +116,8 @@ impl<'ctx> rustc_hir::HashStableContext for StableHashingContext<'ctx> {\n     }\n \n     #[inline]\n-    fn local_def_path_hash(&self, def_index: DefIndex) -> DefPathHash {\n-        self.local_def_path_hash(def_index)\n+    fn local_def_path_hash(&self, def_id: LocalDefId) -> DefPathHash {\n+        self.local_def_path_hash(def_id)\n     }\n }\n \n@@ -197,21 +197,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::BodyId {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::def_id::DefIndex {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        hcx.local_def_path_hash(*self).hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::def_id::DefIndex {\n-    type KeyType = DefPathHash;\n-\n-    #[inline]\n-    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a>) -> DefPathHash {\n-        hcx.local_def_path_hash(*self)\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitCandidate {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {"}, {"sha": "2735c4afca2c8ecd5f3dd46a86306950b11e14e0", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -9,7 +9,6 @@\n use crate::ich::{NodeIdHashingMode, StableHashingContext};\n use crate::ty::{self, DefIdTree, TyCtxt};\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::Node;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -594,7 +593,7 @@ impl<'tcx> ScopeTree {\n                               region scope tree for {:?} / {:?}\",\n                             param_owner,\n                             self.root_parent.map(|id| tcx.hir().local_def_id(id)),\n-                            self.root_body.map(|hir_id| DefId::local(hir_id.owner))\n+                            self.root_body.map(|hir_id| hir_id.owner)\n                         ),\n                     );\n                 }"}, {"sha": "de35c6d87e6f58d4d178726dc0bb3a28b03212ca", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -11,7 +11,7 @@ use crate::ty::query::queries;\n use crate::ty::query::QueryDescription;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n \n use rustc_span::symbol::Symbol;\n use std::borrow::Cow;\n@@ -66,24 +66,27 @@ rustc_queries! {\n         // The items in a module.\n         // This can be conveniently accessed by `tcx.hir().visit_item_likes_in_module`.\n         // Avoid calling this query directly.\n-        query hir_module_items(key: DefId) -> &'tcx hir::ModuleItems {\n+        query hir_module_items(key: LocalDefId) -> &'tcx hir::ModuleItems {\n             eval_always\n+            desc { |tcx| \"HIR module items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n \n-        // An HIR item with a `DefId` that can own other HIR items which do not themselves have\n-        // a `DefId`.\n+        // An HIR item with a `LocalDefId` that can own other HIR items which do\n+        // not themselves have a `LocalDefId`.\n         // This can be conveniently accessed by methods on `tcx.hir()`.\n         // Avoid calling this query directly.\n-        query hir_owner(key: DefId) -> &'tcx HirOwner<'tcx> {\n+        query hir_owner(key: LocalDefId) -> &'tcx HirOwner<'tcx> {\n             eval_always\n+            desc { |tcx| \"HIR owner of `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n \n-        // The HIR items which do not themselves have a `DefId` and are owned by another HIR item\n-        // with a `DefId`.\n+        // The HIR items which do not themselves have a `LocalDefId` and are\n+        // owned by another HIR item with a `LocalDefId`.\n         // This can be conveniently accessed by methods on `tcx.hir()`.\n         // Avoid calling this query directly.\n-        query hir_owner_items(key: DefId) -> &'tcx HirOwnerItems<'tcx> {\n+        query hir_owner_items(key: LocalDefId) -> &'tcx HirOwnerItems<'tcx> {\n             eval_always\n+            desc { |tcx| \"HIR owner items in `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n \n         /// Records the type of every item.\n@@ -135,8 +138,9 @@ rustc_queries! {\n             desc { \"computing the lint levels for items in this crate\" }\n         }\n \n-        query parent_module_from_def_id(_: DefId) -> DefId {\n+        query parent_module_from_def_id(key: LocalDefId) -> LocalDefId {\n             eval_always\n+            desc { |tcx| \"parent module of `{}`\", tcx.def_path_str(key.to_def_id()) }\n         }\n     }\n \n@@ -791,7 +795,7 @@ rustc_queries! {\n         query specializes(_: (DefId, DefId)) -> bool {\n             desc { \"computing whether impls specialize one another\" }\n         }\n-        query in_scope_traits_map(_: DefIndex)\n+        query in_scope_traits_map(_: LocalDefId)\n             -> Option<&'tcx FxHashMap<ItemLocalId, StableVec<TraitCandidate>>> {\n             eval_always\n             desc { \"traits in scope at a block\" }\n@@ -948,15 +952,15 @@ rustc_queries! {\n         query resolve_lifetimes(_: CrateNum) -> &'tcx ResolveLifetimes {\n             desc { \"resolving lifetimes\" }\n         }\n-        query named_region_map(_: DefIndex) ->\n+        query named_region_map(_: LocalDefId) ->\n             Option<&'tcx FxHashMap<ItemLocalId, Region>> {\n             desc { \"looking up a named region\" }\n         }\n-        query is_late_bound_map(_: DefIndex) ->\n+        query is_late_bound_map(_: LocalDefId) ->\n             Option<&'tcx FxHashSet<ItemLocalId>> {\n             desc { \"testing if a region is late bound\" }\n         }\n-        query object_lifetime_defaults_map(_: DefIndex)\n+        query object_lifetime_defaults_map(_: LocalDefId)\n             -> Option<&'tcx FxHashMap<ItemLocalId, Vec<ObjectLifetimeDefault>>> {\n             desc { \"looking up lifetime defaults for a region\" }\n         }"}, {"sha": "742d57fb58a51bfb6d9170813f2b939117f5f1d7", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -55,7 +55,7 @@ use rustc_data_structures::stable_hasher::{\n use rustc_data_structures::sync::{self, Lock, Lrc, WorkerLocal};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, DefIndex, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::{HirId, Node, TraitCandidate};\n use rustc_hir::{ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet};\n use rustc_index::vec::{Idx, IndexVec};\n@@ -205,13 +205,13 @@ fn validate_hir_id_for_typeck_tables(\n     mut_access: bool,\n ) {\n     if let Some(local_id_root) = local_id_root {\n-        if hir_id.owner != local_id_root.index {\n+        if hir_id.owner.to_def_id() != local_id_root {\n             ty::tls::with(|tcx| {\n                 bug!(\n                     \"node {} with HirId::owner {:?} cannot be placed in \\\n                      TypeckTables with local_id_root {:?}\",\n                     tcx.hir().node_to_string(hir_id),\n-                    DefId::local(hir_id.owner),\n+                    hir_id.owner,\n                     local_id_root\n                 )\n             });\n@@ -732,10 +732,12 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for TypeckTables<'tcx> {\n \n                 let local_id_root = local_id_root.expect(\"trying to hash invalid TypeckTables\");\n \n-                let var_owner_def_id =\n-                    DefId { krate: local_id_root.krate, index: var_path.hir_id.owner };\n+                let var_owner_def_id = DefId {\n+                    krate: local_id_root.krate,\n+                    index: var_path.hir_id.owner.local_def_index,\n+                };\n                 let closure_def_id =\n-                    DefId { krate: local_id_root.krate, index: closure_expr_id.to_def_id().index };\n+                    DefId { krate: local_id_root.krate, index: closure_expr_id.local_def_index };\n                 (\n                     hcx.def_path_hash(var_owner_def_id),\n                     var_path.hir_id.local_id,\n@@ -958,7 +960,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n-    trait_map: FxHashMap<DefIndex, FxHashMap<ItemLocalId, StableVec<TraitCandidate>>>,\n+    trait_map: FxHashMap<LocalDefId, FxHashMap<ItemLocalId, StableVec<TraitCandidate>>>,\n \n     /// Export map produced by name resolution.\n     export_map: FxHashMap<DefId, Vec<Export<hir::HirId>>>,\n@@ -1261,7 +1263,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn def_key(self, id: DefId) -> hir_map::DefKey {\n-        if id.is_local() { self.hir().def_key(id) } else { self.cstore.def_key(id) }\n+        if let Some(id) = id.as_local() { self.hir().def_key(id) } else { self.cstore.def_key(id) }\n     }\n \n     /// Converts a `DefId` into its fully expanded `DefPath` (every\n@@ -1270,7 +1272,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Note that if `id` is not local to this crate, the result will\n     ///  be a non-local `DefPath`.\n     pub fn def_path(self, id: DefId) -> hir_map::DefPath {\n-        if id.is_local() { self.hir().def_path(id) } else { self.cstore.def_path(id) }\n+        if let Some(id) = id.as_local() {\n+            self.hir().def_path(id)\n+        } else {\n+            self.cstore.def_path(id)\n+        }\n     }\n \n     /// Returns whether or not the crate with CrateNum 'cnum'\n@@ -1281,8 +1287,8 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn def_path_hash(self, def_id: DefId) -> hir_map::DefPathHash {\n-        if def_id.is_local() {\n-            self.definitions.def_path_hash(def_id.index)\n+        if let Some(def_id) = def_id.as_local() {\n+            self.definitions.def_path_hash(def_id)\n         } else {\n             self.cstore.def_path_hash(def_id)\n         }\n@@ -2747,18 +2753,15 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     };\n \n     providers.lookup_stability = |tcx, id| {\n-        assert_eq!(id.krate, LOCAL_CRATE);\n-        let id = tcx.hir().definitions().def_index_to_hir_id(id.index);\n+        let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n         tcx.stability().local_stability(id)\n     };\n     providers.lookup_const_stability = |tcx, id| {\n-        assert_eq!(id.krate, LOCAL_CRATE);\n-        let id = tcx.hir().definitions().def_index_to_hir_id(id.index);\n+        let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n         tcx.stability().local_const_stability(id)\n     };\n     providers.lookup_deprecation_entry = |tcx, id| {\n-        assert_eq!(id.krate, LOCAL_CRATE);\n-        let id = tcx.hir().definitions().def_index_to_hir_id(id.index);\n+        let id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n         tcx.stability().local_deprecation_entry(id)\n     };\n     providers.extern_mod_stmt_cnum = |tcx, id| {"}, {"sha": "9e3853c51af13cb04afeb63fd9ad8d6b8058bfc8", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -384,7 +384,9 @@ impl Visibility {\n                 Res::Err => Visibility::Public,\n                 def => Visibility::Restricted(def.def_id()),\n             },\n-            hir::VisibilityKind::Inherited => Visibility::Restricted(tcx.parent_module(id)),\n+            hir::VisibilityKind::Inherited => {\n+                Visibility::Restricted(tcx.parent_module(id).to_def_id())\n+            }\n         }\n     }\n \n@@ -3094,9 +3096,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     fn expansion_that_defined(self, scope: DefId) -> ExpnId {\n-        match scope.krate {\n-            LOCAL_CRATE => self.hir().definitions().expansion_that_defined(scope.index),\n-            _ => ExpnId::root(),\n+        match scope.as_local() {\n+            Some(scope) => self.hir().definitions().expansion_that_defined(scope),\n+            None => ExpnId::root(),\n         }\n     }\n \n@@ -3117,7 +3119,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 Some(actual_expansion) => {\n                     self.hir().definitions().parent_module_of_macro_def(actual_expansion)\n                 }\n-                None => self.parent_module(block),\n+                None => self.parent_module(block).to_def_id(),\n             };\n         (ident, scope)\n     }"}, {"sha": "6073d3a545f6db9c7b6dbb12186e188518037a06", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -7,7 +7,7 @@ use crate::ty::fast_reject::SimplifiedType;\n use crate::ty::query::caches::DefaultCacheSelector;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, Ty, TyCtxt};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -84,14 +84,14 @@ impl Key for CrateNum {\n     }\n }\n \n-impl Key for DefIndex {\n+impl Key for LocalDefId {\n     type CacheSelector = DefaultCacheSelector;\n \n     fn query_crate(&self) -> CrateNum {\n-        LOCAL_CRATE\n+        self.to_def_id().query_crate()\n     }\n-    fn default_span(&self, _tcx: TyCtxt<'_>) -> Span {\n-        DUMMY_SP\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        self.to_def_id().default_span(tcx)\n     }\n }\n "}, {"sha": "7ac8358c78a611ed6c38dc9e6cbd3f0c35783bb3", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -44,7 +44,7 @@ use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, DefIndex};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n use rustc_hir::{Crate, HirIdSet, ItemLocalId, TraitCandidate};\n use rustc_index::vec::IndexVec;\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n@@ -147,7 +147,7 @@ rustc_query_append! { [define_queries!][<'tcx>] }\n ///\n /// When you implement a new query, it will likely have a corresponding new\n /// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n-/// a rule of thumb, if your query takes a `DefId` or `DefIndex` as sole parameter,\n+/// a rule of thumb, if your query takes a `DefId` or `LocalDefId` as sole parameter,\n /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n /// add it to the \"We don't have enough information to reconstruct...\" group in\n /// the match below."}, {"sha": "781abea75d9f7bd7d8f90be2691468cfb3680b1a", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -11,7 +11,6 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{HashMapExt, Lock, Lrc, Once};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n-use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_serialize::{\n@@ -657,26 +656,7 @@ impl<'a, 'tcx> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx> {\n impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<LocalDefId, Self::Error> {\n-        Ok(LocalDefId::from_def_id(DefId::decode(self)?))\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<hir::HirId, Self::Error> {\n-        // Load the `DefPathHash` which is what we encoded the `DefIndex` as.\n-        let def_path_hash = DefPathHash::decode(self)?;\n-\n-        // Use the `DefPathHash` to map to the current `DefId`.\n-        let def_id = self.tcx().def_path_hash_to_def_id.as_ref().unwrap()[&def_path_hash];\n-\n-        debug_assert!(def_id.is_local());\n-\n-        // The `ItemLocalId` needs no remapping.\n-        let local_id = hir::ItemLocalId::decode(self)?;\n-\n-        // Reconstruct the `HirId` and look up the corresponding `NodeId` in the\n-        // context of the current session.\n-        Ok(hir::HirId { owner: def_id.index, local_id })\n+        Ok(DefId::decode(self)?.expect_local())\n     }\n }\n \n@@ -873,21 +853,6 @@ where\n     }\n }\n \n-impl<'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'a, 'tcx, E>\n-where\n-    E: 'a + TyEncoder,\n-{\n-    #[inline]\n-    fn specialized_encode(&mut self, id: &hir::HirId) -> Result<(), Self::Error> {\n-        let hir::HirId { owner, local_id } = *id;\n-\n-        let def_path_hash = self.tcx.hir().definitions().def_path_hash(owner);\n-\n-        def_path_hash.encode(self)?;\n-        local_id.encode(self)\n-    }\n-}\n-\n impl<'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'a, 'tcx, E>\n where\n     E: 'a + TyEncoder,"}, {"sha": "94ae2a0973ae9501133172b60d11ab00d03ebf27", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -11,7 +11,7 @@ use rustc_ast::visit::{self, AssocCtxt, Visitor};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_span::source_map::{respan, DesugaringKind};\n use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n@@ -269,7 +269,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 hir::ItemKind::Const(ty, body_id)\n             }\n             ItemKind::Fn(_, FnSig { ref decl, header }, ref generics, ref body) => {\n-                let fn_def_id = self.resolver.definitions().local_def_id(id);\n+                let fn_def_id = self.resolver.definitions().local_def_id(id).expect_local();\n                 self.with_new_scopes(|this| {\n                     this.current_item = Some(ident.span);\n \n@@ -287,7 +287,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         AnonymousLifetimeMode::PassThrough,\n                         |this, idty| {\n                             let ret_id = asyncness.opt_return_id();\n-                            this.lower_fn_decl(&decl, Some((fn_def_id, idty)), true, ret_id)\n+                            this.lower_fn_decl(\n+                                &decl,\n+                                Some((fn_def_id.to_def_id(), idty)),\n+                                true,\n+                                ret_id,\n+                            )\n                         },\n                     );\n                     let sig = hir::FnSig { decl, header: this.lower_fn_header(header) };\n@@ -351,7 +356,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 self_ty: ref ty,\n                 items: ref impl_items,\n             } => {\n-                let def_id = self.resolver.definitions().local_def_id(id);\n+                let def_id = self.resolver.definitions().local_def_id(id).expect_local();\n \n                 // Lower the \"impl header\" first. This ordering is important\n                 // for in-band lifetimes! Consider `'a` here:\n@@ -648,7 +653,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem<'hir> {\n-        let def_id = self.resolver.definitions().local_def_id(i.id);\n+        let def_id = self.resolver.definitions().local_def_id(i.id).expect_local();\n         hir::ForeignItem {\n             hir_id: self.lower_node_id(i.id),\n             ident: i.ident,\n@@ -749,7 +754,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_trait_item(&mut self, i: &AssocItem) -> hir::TraitItem<'hir> {\n-        let trait_item_def_id = self.resolver.definitions().local_def_id(i.id);\n+        let trait_item_def_id = self.resolver.definitions().local_def_id(i.id).expect_local();\n \n         let (generics, kind) = match i.kind {\n             AssocItemKind::Const(_, ref ty, ref default) => {\n@@ -814,7 +819,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_impl_item(&mut self, i: &AssocItem) -> hir::ImplItem<'hir> {\n-        let impl_item_def_id = self.resolver.definitions().local_def_id(i.id);\n+        let impl_item_def_id = self.resolver.definitions().local_def_id(i.id).expect_local();\n \n         let (generics, kind) = match &i.kind {\n             AssocItemKind::Const(_, ty, expr) => {\n@@ -1211,7 +1216,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         generics: &Generics,\n         sig: &FnSig,\n-        fn_def_id: DefId,\n+        fn_def_id: LocalDefId,\n         impl_trait_return_allow: bool,\n         is_async: Option<NodeId>,\n     ) -> (hir::Generics<'hir>, hir::FnSig<'hir>) {\n@@ -1223,7 +1228,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             |this, idty| {\n                 this.lower_fn_decl(\n                     &sig.decl,\n-                    Some((fn_def_id, idty)),\n+                    Some((fn_def_id.to_def_id(), idty)),\n                     impl_trait_return_allow,\n                     is_async,\n                 )"}, {"sha": "dcedcd51f5063d4e8705b9878906372b678b4635", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -53,7 +53,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n-use rustc_hir::def_id::{DefId, DefIdMap, DefIndex, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::intravisit;\n use rustc_hir::{ConstArg, GenericArg, ParamName};\n use rustc_index::vec::IndexVec;\n@@ -160,7 +160,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n \n     type_def_lifetime_params: DefIdMap<usize>,\n \n-    current_hir_id_owner: Vec<(DefIndex, u32)>,\n+    current_hir_id_owner: Vec<(LocalDefId, u32)>,\n     item_local_id_counters: NodeMap<u32>,\n     node_id_to_hir_id: IndexVec<NodeId, hir::HirId>,\n \n@@ -290,7 +290,7 @@ pub fn lower_crate<'a, 'hir>(\n         anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n         type_def_lifetime_params: Default::default(),\n         current_module: hir::CRATE_HIR_ID,\n-        current_hir_id_owner: vec![(CRATE_DEF_INDEX, 0)],\n+        current_hir_id_owner: vec![(LocalDefId { local_def_index: CRATE_DEF_INDEX }, 0)],\n         item_local_id_counters: Default::default(),\n         node_id_to_hir_id: IndexVec::new(),\n         generator_kind: None,\n@@ -407,7 +407,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n \n         impl MiscCollector<'_, '_, '_> {\n-            fn allocate_use_tree_hir_id_counters(&mut self, tree: &UseTree, owner: DefIndex) {\n+            fn allocate_use_tree_hir_id_counters(&mut self, tree: &UseTree, owner: LocalDefId) {\n                 match tree.kind {\n                     UseTreeKind::Simple(_, id1, id2) => {\n                         for &id in &[id1, id2] {\n@@ -463,7 +463,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     | ItemKind::Enum(_, ref generics)\n                     | ItemKind::TyAlias(_, ref generics, ..)\n                     | ItemKind::Trait(_, _, ref generics, ..) => {\n-                        let def_id = self.lctx.resolver.definitions().local_def_id(item.id);\n+                        let def_id =\n+                            self.lctx.resolver.definitions().local_def_id(item.id).expect_local();\n                         let count = generics\n                             .params\n                             .iter()\n@@ -472,7 +473,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 _ => false,\n                             })\n                             .count();\n-                        self.lctx.type_def_lifetime_params.insert(def_id, count);\n+                        self.lctx.type_def_lifetime_params.insert(def_id.to_def_id(), count);\n                     }\n                     ItemKind::Use(ref use_tree) => {\n                         self.allocate_use_tree_hir_id_counters(use_tree, hir_id.owner);\n@@ -598,12 +599,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             .item_local_id_counters\n             .insert(owner, HIR_ID_COUNTER_LOCKED)\n             .unwrap_or_else(|| panic!(\"no `item_local_id_counters` entry for {:?}\", owner));\n-        let def_index = self.resolver.definitions().opt_def_index(owner).unwrap();\n-        self.current_hir_id_owner.push((def_index, counter));\n+        let def_id = self.resolver.definitions().local_def_id(owner).expect_local();\n+        self.current_hir_id_owner.push((def_id, counter));\n         let ret = f(self);\n-        let (new_def_index, new_counter) = self.current_hir_id_owner.pop().unwrap();\n+        let (new_def_id, new_counter) = self.current_hir_id_owner.pop().unwrap();\n \n-        debug_assert!(def_index == new_def_index);\n+        debug_assert!(def_id == new_def_id);\n         debug_assert!(new_counter >= counter);\n \n         let prev = self.item_local_id_counters.insert(owner, new_counter).unwrap();\n@@ -619,11 +620,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// properly. Calling the method twice with the same `NodeId` is fine though.\n     fn lower_node_id(&mut self, ast_node_id: NodeId) -> hir::HirId {\n         self.lower_node_id_generic(ast_node_id, |this| {\n-            let &mut (def_index, ref mut local_id_counter) =\n+            let &mut (owner, ref mut local_id_counter) =\n                 this.current_hir_id_owner.last_mut().unwrap();\n             let local_id = *local_id_counter;\n             *local_id_counter += 1;\n-            hir::HirId { owner: def_index, local_id: hir::ItemLocalId::from_u32(local_id) }\n+            hir::HirId { owner, local_id: hir::ItemLocalId::from_u32(local_id) }\n         })\n     }\n \n@@ -641,12 +642,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             debug_assert!(local_id != HIR_ID_COUNTER_LOCKED);\n \n             *local_id_counter += 1;\n-            let def_index = this.resolver.definitions().opt_def_index(owner).expect(\n+            let owner = this.resolver.definitions().opt_local_def_id(owner).expect(\n                 \"you forgot to call `create_def_with_parent` or are lowering node-IDs \\\n-                         that do not belong to the current owner\",\n+                 that do not belong to the current owner\",\n             );\n \n-            hir::HirId { owner: def_index, local_id: hir::ItemLocalId::from_u32(local_id) }\n+            hir::HirId { owner, local_id: hir::ItemLocalId::from_u32(local_id) }\n         })\n     }\n \n@@ -724,7 +725,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// parameter while `f` is running (and restored afterwards).\n     fn collect_in_band_defs<T>(\n         &mut self,\n-        parent_id: DefId,\n+        parent_def_id: LocalDefId,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n         f: impl FnOnce(&mut Self) -> (Vec<hir::GenericParam<'hir>>, T),\n     ) -> (Vec<hir::GenericParam<'hir>>, T) {\n@@ -744,7 +745,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let params = lifetimes_to_define\n             .into_iter()\n-            .map(|(span, hir_name)| self.lifetime_to_generic_param(span, hir_name, parent_id.index))\n+            .map(|(span, hir_name)| self.lifetime_to_generic_param(span, hir_name, parent_def_id))\n             .chain(in_band_ty_params.into_iter())\n             .collect();\n \n@@ -756,7 +757,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         span: Span,\n         hir_name: ParamName,\n-        parent_index: DefIndex,\n+        parent_def_id: LocalDefId,\n     ) -> hir::GenericParam<'hir> {\n         let node_id = self.resolver.next_node_id();\n \n@@ -771,7 +772,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         // Add a definition for the in-band lifetime def.\n         self.resolver.definitions().create_def_with_parent(\n-            parent_index,\n+            parent_def_id,\n             node_id,\n             DefPathData::LifetimeNs(str_name),\n             ExpnId::root(),\n@@ -860,13 +861,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn add_in_band_defs<T>(\n         &mut self,\n         generics: &Generics,\n-        parent_id: DefId,\n+        parent_def_id: LocalDefId,\n         anonymous_lifetime_mode: AnonymousLifetimeMode,\n         f: impl FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n     ) -> (hir::Generics<'hir>, T) {\n         let (in_band_defs, (mut lowered_generics, res)) =\n             self.with_in_scope_lifetime_defs(&generics.params, |this| {\n-                this.collect_in_band_defs(parent_id, anonymous_lifetime_mode, |this| {\n+                this.collect_in_band_defs(parent_def_id, anonymous_lifetime_mode, |this| {\n                     let mut params = Vec::new();\n                     // Note: it is necessary to lower generics *before* calling `f`.\n                     // When lowering `async fn`, there's a final step when lowering\n@@ -1048,9 +1049,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // constructing the HIR for `impl bounds...` and then lowering that.\n \n                     let impl_trait_node_id = self.resolver.next_node_id();\n-                    let parent_def_index = self.current_hir_id_owner.last().unwrap().0;\n+                    let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n                     self.resolver.definitions().create_def_with_parent(\n-                        parent_def_index,\n+                        parent_def_id,\n                         impl_trait_node_id,\n                         DefPathData::ImplTrait,\n                         ExpnId::root(),\n@@ -1111,12 +1112,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n                             // Construct a AnonConst where the expr is the \"ty\"'s path.\n \n-                            let parent_def_index = self.current_hir_id_owner.last().unwrap().0;\n+                            let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n                             let node_id = self.resolver.next_node_id();\n \n                             // Add a definition for the in-band const def.\n                             self.resolver.definitions().create_def_with_parent(\n-                                parent_def_index,\n+                                parent_def_id,\n                                 node_id,\n                                 DefPathData::AnonConst,\n                                 ExpnId::root(),\n@@ -1278,8 +1279,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     }\n                     ImplTraitContext::Universal(in_band_ty_params) => {\n                         // Add a definition for the in-band `Param`.\n-                        let def_index =\n-                            self.resolver.definitions().opt_def_index(def_node_id).unwrap();\n+                        let def_id =\n+                            self.resolver.definitions().local_def_id(def_node_id).expect_local();\n \n                         let hir_bounds = self.lower_param_bounds(\n                             bounds,\n@@ -1304,7 +1305,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             None,\n                             self.arena.alloc(hir::Path {\n                                 span,\n-                                res: Res::Def(DefKind::TyParam, DefId::local(def_index)),\n+                                res: Res::Def(DefKind::TyParam, def_id.to_def_id()),\n                                 segments: arena_vec![self; hir::PathSegment::from_ident(ident)],\n                             }),\n                         ))\n@@ -1367,18 +1368,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // frequently opened issues show.\n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::OpaqueTy, span, None);\n \n-        let opaque_ty_def_index =\n-            self.resolver.definitions().opt_def_index(opaque_ty_node_id).unwrap();\n+        let opaque_ty_def_id =\n+            self.resolver.definitions().local_def_id(opaque_ty_node_id).expect_local();\n \n         self.allocate_hir_id_counter(opaque_ty_node_id);\n \n         let hir_bounds = self.with_hir_id_owner(opaque_ty_node_id, lower_bounds);\n \n-        let (lifetimes, lifetime_defs) = self.lifetimes_from_impl_trait_bounds(\n-            opaque_ty_node_id,\n-            opaque_ty_def_index,\n-            &hir_bounds,\n-        );\n+        let (lifetimes, lifetime_defs) =\n+            self.lifetimes_from_impl_trait_bounds(opaque_ty_node_id, opaque_ty_def_id, &hir_bounds);\n \n         debug!(\"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes,);\n \n@@ -1396,7 +1394,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 origin,\n             };\n \n-            trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_index);\n+            trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_id);\n             let opaque_ty_id =\n                 lctx.generate_opaque_type(opaque_ty_node_id, opaque_ty_item, span, opaque_ty_span);\n \n@@ -1437,22 +1435,22 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lifetimes_from_impl_trait_bounds(\n         &mut self,\n         opaque_ty_id: NodeId,\n-        parent_index: DefIndex,\n+        parent_def_id: LocalDefId,\n         bounds: hir::GenericBounds<'hir>,\n     ) -> (&'hir [hir::GenericArg<'hir>], &'hir [hir::GenericParam<'hir>]) {\n         debug!(\n             \"lifetimes_from_impl_trait_bounds(opaque_ty_id={:?}, \\\n-             parent_index={:?}, \\\n+             parent_def_id={:?}, \\\n              bounds={:#?})\",\n-            opaque_ty_id, parent_index, bounds,\n+            opaque_ty_id, parent_def_id, bounds,\n         );\n \n         // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n         // appear in the bounds, excluding lifetimes that are created within the bounds.\n         // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n         struct ImplTraitLifetimeCollector<'r, 'a, 'hir> {\n             context: &'r mut LoweringContext<'a, 'hir>,\n-            parent: DefIndex,\n+            parent: LocalDefId,\n             opaque_ty_id: NodeId,\n             collect_elided_lifetimes: bool,\n             currently_bound_lifetimes: Vec<hir::LifetimeName>,\n@@ -1590,7 +1588,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let mut lifetime_collector = ImplTraitLifetimeCollector {\n             context: self,\n-            parent: parent_index,\n+            parent: parent_def_id,\n             opaque_ty_id,\n             collect_elided_lifetimes: true,\n             currently_bound_lifetimes: Vec::new(),\n@@ -1620,12 +1618,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 visitor.visit_ty(ty);\n             }\n         }\n-        let parent_def_id = DefId::local(self.current_hir_id_owner.last().unwrap().0);\n+        let parent_def_id = self.current_hir_id_owner.last().unwrap().0;\n         let ty = l.ty.as_ref().map(|t| {\n             self.lower_ty(\n                 t,\n                 if self.sess.features_untracked().impl_trait_in_bindings {\n-                    ImplTraitContext::OpaqueTy(Some(parent_def_id), hir::OpaqueTyOrigin::Misc)\n+                    ImplTraitContext::OpaqueTy(\n+                        Some(parent_def_id.to_def_id()),\n+                        hir::OpaqueTyOrigin::Misc,\n+                    )\n                 } else {\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                 },\n@@ -1797,8 +1798,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-        let opaque_ty_def_index =\n-            self.resolver.definitions().opt_def_index(opaque_ty_node_id).unwrap();\n+        let opaque_ty_def_id =\n+            self.resolver.definitions().local_def_id(opaque_ty_node_id).expect_local();\n \n         self.allocate_hir_id_counter(opaque_ty_node_id);\n \n@@ -1886,7 +1887,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n             let generic_params =\n                 this.arena.alloc_from_iter(lifetime_params.iter().map(|(span, hir_name)| {\n-                    this.lifetime_to_generic_param(*span, *hir_name, opaque_ty_def_index)\n+                    this.lifetime_to_generic_param(*span, *hir_name, opaque_ty_def_id)\n                 }));\n \n             let opaque_ty_item = hir::OpaqueTy {\n@@ -1900,7 +1901,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 origin: hir::OpaqueTyOrigin::AsyncFn,\n             };\n \n-            trace!(\"exist ty from async fn def index: {:#?}\", opaque_ty_def_index);\n+            trace!(\"exist ty from async fn def id: {:#?}\", opaque_ty_def_id);\n             let opaque_ty_id =\n                 this.generate_opaque_type(opaque_ty_node_id, opaque_ty_item, span, opaque_ty_span);\n "}, {"sha": "1c7987e965f8506ee92bf315badbb5dff17b9fd6", "filename": "src/librustc_hir/hir_id.rs", "status": "modified", "additions": 10, "deletions": 37, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_hir%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_hir%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir_id.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -1,9 +1,8 @@\n-use crate::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n-use rustc_serialize::{self, Decodable, Decoder, Encodable, Encoder};\n+use crate::def_id::{LocalDefId, CRATE_DEF_INDEX};\n use std::fmt;\n \n /// Uniquely identifies a node in the HIR of the current crate. It is\n-/// composed of the `owner`, which is the `DefIndex` of the directly enclosing\n+/// composed of the `owner`, which is the `LocalDefId` of the directly enclosing\n /// `hir::Item`, `hir::TraitItem`, or `hir::ImplItem` (i.e., the closest \"item-like\"),\n /// and the `local_id` which is unique within the given owner.\n ///\n@@ -12,41 +11,12 @@ use std::fmt;\n /// the `local_id` part of the `HirId` changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, PartialOrd, Ord, RustcEncodable, RustcDecodable)]\n pub struct HirId {\n-    pub owner: DefIndex,\n+    pub owner: LocalDefId,\n     pub local_id: ItemLocalId,\n }\n \n-impl HirId {\n-    pub fn owner_def_id(self) -> DefId {\n-        DefId::local(self.owner)\n-    }\n-\n-    pub fn owner_local_def_id(self) -> LocalDefId {\n-        LocalDefId::from_def_id(DefId::local(self.owner))\n-    }\n-}\n-\n-impl rustc_serialize::UseSpecializedEncodable for HirId {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        let HirId { owner, local_id } = *self;\n-\n-        owner.encode(s)?;\n-        local_id.encode(s)?;\n-        Ok(())\n-    }\n-}\n-\n-impl rustc_serialize::UseSpecializedDecodable for HirId {\n-    fn default_decode<D: Decoder>(d: &mut D) -> Result<HirId, D::Error> {\n-        let owner = DefIndex::decode(d)?;\n-        let local_id = ItemLocalId::decode(d)?;\n-\n-        Ok(HirId { owner, local_id })\n-    }\n-}\n-\n impl fmt::Display for HirId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"{:?}\", self)\n@@ -70,9 +40,12 @@ rustc_index::newtype_index! {\n rustc_data_structures::impl_stable_hash_via_hash!(ItemLocalId);\n \n /// The `HirId` corresponding to `CRATE_NODE_ID` and `CRATE_DEF_INDEX`.\n-pub const CRATE_HIR_ID: HirId =\n-    HirId { owner: CRATE_DEF_INDEX, local_id: ItemLocalId::from_u32(0) };\n+pub const CRATE_HIR_ID: HirId = HirId {\n+    owner: LocalDefId { local_def_index: CRATE_DEF_INDEX },\n+    local_id: ItemLocalId::from_u32(0),\n+};\n \n-pub const DUMMY_HIR_ID: HirId = HirId { owner: CRATE_DEF_INDEX, local_id: DUMMY_ITEM_LOCAL_ID };\n+pub const DUMMY_HIR_ID: HirId =\n+    HirId { owner: LocalDefId { local_def_index: CRATE_DEF_INDEX }, local_id: DUMMY_ITEM_LOCAL_ID };\n \n pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId::MAX;"}, {"sha": "996b310896904221a96028f83899f2aee0998b05", "filename": "src/librustc_hir/stable_hash_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_hir%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_hir%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fstable_hash_impls.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -5,7 +5,7 @@ use crate::hir::{\n     VisibilityKind,\n };\n use crate::hir_id::{HirId, ItemLocalId};\n-use rustc_span::def_id::{DefIndex, DefPathHash};\n+use rustc_span::def_id::{DefPathHash, LocalDefId};\n \n /// Requirements for a `StableHashingContext` to be used in this crate.\n /// This is a hack to allow using the `HashStable_Generic` derive macro\n@@ -21,7 +21,7 @@ pub trait HashStableContext:\n     fn hash_hir_ty(&mut self, _: &Ty<'_>, hasher: &mut StableHasher);\n     fn hash_hir_visibility_kind(&mut self, _: &VisibilityKind<'_>, hasher: &mut StableHasher);\n     fn hash_hir_item_like<F: FnOnce(&mut Self)>(&mut self, f: F);\n-    fn local_def_path_hash(&self, def_index: DefIndex) -> DefPathHash;\n+    fn local_def_path_hash(&self, def_id: LocalDefId) -> DefPathHash;\n }\n \n impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for HirId {"}, {"sha": "d8c685f2b22ffe908423d1c428574e353bb02124", "filename": "src/librustc_lint/internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_lint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_lint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Finternal.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n                 }\n             }\n             TyKind::Rptr(_, MutTy { ty: inner_ty, mutbl: Mutability::Not }) => {\n-                if let Some(impl_did) = cx.tcx.impl_of_method(ty.hir_id.owner_def_id()) {\n+                if let Some(impl_did) = cx.tcx.impl_of_method(ty.hir_id.owner.to_def_id()) {\n                     if cx.tcx.impl_trait_ref(impl_did).is_some() {\n                         return;\n                     }"}, {"sha": "229740615f707f60da6fa6b355568764d9f58b5d", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         ) -> bool {\n             if ty.is_unit()\n                 || cx.tcx.is_ty_uninhabited_from(\n-                    cx.tcx.parent_module(expr.hir_id),\n+                    cx.tcx.parent_module(expr.hir_id).to_def_id(),\n                     ty,\n                     cx.param_env,\n                 )"}, {"sha": "f20cdfcba15ca9b1e77fdb5026f1e93f0630aed1", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -870,11 +870,11 @@ impl<'a> CrateLoader<'a> {\n                 let cnum = self.resolve_crate(name, item.span, dep_kind, None);\n \n                 let def_id = definitions.opt_local_def_id(item.id).unwrap();\n-                let path_len = definitions.def_path(def_id.index).data.len();\n+                let path_len = definitions.def_path(def_id).data.len();\n                 self.update_extern_crate(\n                     cnum,\n                     ExternCrate {\n-                        src: ExternCrateSource::Extern(def_id),\n+                        src: ExternCrateSource::Extern(def_id.to_def_id()),\n                         span: item.span,\n                         path_len,\n                         dependency_of: LOCAL_CRATE,"}, {"sha": "2bf74fe272ec97abc5bd5e801f9875b33ccf8de9", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -364,7 +364,7 @@ impl<'a, 'tcx> SpecializedDecoder<DefIndex> for DecodeContext<'a, 'tcx> {\n impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for DecodeContext<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<LocalDefId, Self::Error> {\n-        self.specialized_decode().map(|i| LocalDefId::from_def_id(i))\n+        Ok(DefId::decode(self)?.expect_local())\n     }\n }\n "}, {"sha": "6280fd62de9a828617caa8afa206e42443e48f2e", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -1350,7 +1350,7 @@ impl EncodeContext<'tcx> {\n         let is_proc_macro = self.tcx.sess.crate_types.borrow().contains(&CrateType::ProcMacro);\n         if is_proc_macro {\n             let tcx = self.tcx;\n-            Some(self.lazy(tcx.hir().krate().proc_macros.iter().map(|p| p.owner)))\n+            Some(self.lazy(tcx.hir().krate().proc_macros.iter().map(|p| p.owner.local_def_index)))\n         } else {\n             None\n         }\n@@ -1438,8 +1438,8 @@ impl EncodeContext<'tcx> {\n             .into_iter()\n             .map(|(trait_def_id, mut impls)| {\n                 // Bring everything into deterministic order for hashing\n-                impls.sort_by_cached_key(|&def_index| {\n-                    tcx.hir().definitions().def_path_hash(def_index)\n+                impls.sort_by_cached_key(|&index| {\n+                    tcx.hir().definitions().def_path_hash(LocalDefId { local_def_index: index })\n                 });\n \n                 TraitImpls {"}, {"sha": "077ed49ed2cacc8fc248a8e1f5c3ed561b36536f", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -272,7 +272,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     // Dump facts if requested.\n     let polonius_output = all_facts.and_then(|all_facts| {\n         if infcx.tcx.sess.opts.debugging_opts.nll_facts {\n-            let def_path = infcx.tcx.hir().def_path(def_id);\n+            let def_path = infcx.tcx.def_path(def_id);\n             let dir_path =\n                 PathBuf::from(\"nll-facts\").join(def_path.to_filename_friendly_no_crate());\n             all_facts.write_to_dir(dir_path, location_table).unwrap();"}, {"sha": "05d4fc8880e406dc8fb6194353e504e1c90041ac", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -2008,7 +2008,9 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 &traits::Obligation::new(\n                                     ObligationCause::new(\n                                         span,\n-                                        self.tcx().hir().def_index_to_hir_id(self.mir_def_id.index),\n+                                        self.tcx()\n+                                            .hir()\n+                                            .local_def_id_to_hir_id(self.mir_def_id.expect_local()),\n                                         traits::ObligationCauseCode::RepeatVec(should_suggest),\n                                     ),\n                                     self.param_env,"}, {"sha": "c1acd5bd9a691510020bc1c405c24ab23d787829", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -774,9 +774,9 @@ fn for_each_late_bound_region_defined_on<'tcx>(\n     fn_def_id: DefId,\n     mut f: impl FnMut(ty::Region<'tcx>),\n ) {\n-    if let Some(late_bounds) = tcx.is_late_bound_map(fn_def_id.index) {\n+    if let Some(late_bounds) = tcx.is_late_bound_map(fn_def_id.expect_local()) {\n         for late_bound in late_bounds.iter() {\n-            let hir_id = HirId { owner: fn_def_id.index, local_id: *late_bound };\n+            let hir_id = HirId { owner: fn_def_id.expect_local(), local_id: *late_bound };\n             let name = tcx.hir().name(hir_id);\n             let region_def_id = tcx.hir().local_def_id(hir_id);\n             let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {"}, {"sha": "470e4e7ed25c1fe1adfe0afa796628d55cf64822", "filename": "src/librustc_mir/const_eval/fn_queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -85,7 +85,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n     let parent_id = tcx.hir().get_parent_did(hir_id);\n     if !parent_id.is_top_level_module() {\n-        is_const_impl_raw(tcx, LocalDefId::from_def_id(parent_id))\n+        is_const_impl_raw(tcx, parent_id.expect_local())\n     } else {\n         false\n     }\n@@ -171,7 +171,7 @@ fn const_fn_is_allowed_fn_ptr(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n         is_const_fn_raw,\n-        is_const_impl_raw: |tcx, def_id| is_const_impl_raw(tcx, LocalDefId::from_def_id(def_id)),\n+        is_const_impl_raw: |tcx, def_id| is_const_impl_raw(tcx, def_id.expect_local()),\n         is_promotable_const_fn,\n         const_fn_is_allowed_fn_ptr,\n         ..*providers"}, {"sha": "02b596863ab4090b9026b72b4a4967559bbb89b4", "filename": "src/librustc_mir_build/hair/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fcx%2Fexpr.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -10,7 +10,6 @@ use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::{self, AdtKind, Ty};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n-use rustc_hir::def_id::LocalDefId;\n use rustc_index::vec::Idx;\n use rustc_span::Span;\n \n@@ -812,7 +811,7 @@ fn convert_var<'tcx>(\n             let closure_def_id = cx.body_owner;\n             let upvar_id = ty::UpvarId {\n                 var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n+                closure_expr_id: closure_def_id.expect_local(),\n             };\n             let var_ty = cx.tables().node_type(var_hir_id);\n \n@@ -987,7 +986,7 @@ fn capture_upvar<'tcx>(\n ) -> ExprRef<'tcx> {\n     let upvar_id = ty::UpvarId {\n         var_path: ty::UpvarPath { hir_id: var_hir_id },\n-        closure_expr_id: cx.tcx.hir().local_def_id(closure_expr.hir_id).to_local(),\n+        closure_expr_id: cx.tcx.hir().local_def_id(closure_expr.hir_id).expect_local(),\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);"}, {"sha": "9c86669cf9d929da307390d08eee390e0a6c03aa", "filename": "src/librustc_mir_build/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2Fcheck_match.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -145,7 +145,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n \n     fn check_in_cx(&self, hir_id: HirId, f: impl FnOnce(MatchCheckCtxt<'_, 'tcx>)) {\n         let module = self.tcx.parent_module(hir_id);\n-        MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module, |cx| f(cx));\n+        MatchCheckCtxt::create_and_enter(self.tcx, self.param_env, module.to_def_id(), |cx| f(cx));\n     }\n \n     fn check_match("}, {"sha": "7e0d0bfe9aba45c662b411e33a08bce412ddd9b8", "filename": "src/librustc_passes/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_passes%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_passes%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fentry.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -34,7 +34,7 @@ struct EntryContext<'a, 'tcx> {\n impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx Item<'tcx>) {\n         let def_id = self.map.local_def_id(item.hir_id);\n-        let def_key = self.map.def_key(def_id);\n+        let def_key = self.map.def_key(def_id.expect_local());\n         let at_root = def_key.parent == Some(CRATE_DEF_INDEX);\n         find_item(item, self, at_root);\n     }"}, {"sha": "70b106f5d2332eb0c11736d87cd7d463e984c9ff", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -1128,7 +1128,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Call(ref f, ref args) => {\n-                let m = self.ir.tcx.parent_module(expr.hir_id);\n+                let m = self.ir.tcx.parent_module(expr.hir_id).to_def_id();\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(\n                     m,\n                     self.tables.expr_ty(expr),\n@@ -1143,7 +1143,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::MethodCall(.., ref args) => {\n-                let m = self.ir.tcx.parent_module(expr.hir_id);\n+                let m = self.ir.tcx.parent_module(expr.hir_id).to_def_id();\n                 let succ = if self.ir.tcx.is_ty_uninhabited_from(\n                     m,\n                     self.tables.expr_ty(expr),"}, {"sha": "835e7cfb628169a3c182a62b3dd3dcd7181efe81", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -46,7 +46,7 @@ fn method_might_be_inlined(\n     impl_item: &hir::ImplItem<'_>,\n     impl_src: DefId,\n ) -> bool {\n-    let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner_def_id());\n+    let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id.owner.to_def_id());\n     let generics = tcx.generics_of(tcx.hir().local_def_id(impl_item.hir_id));\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true;"}, {"sha": "c8c8c2299305ba55faee029f57c4291da3eda61d", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -327,7 +327,7 @@ fn def_id_visibility<'tcx>(\n                 }\n                 Node::Expr(expr) => {\n                     return (\n-                        ty::Visibility::Restricted(tcx.parent_module(expr.hir_id)),\n+                        ty::Visibility::Restricted(tcx.parent_module(expr.hir_id).to_def_id()),\n                         expr.span,\n                         \"private\",\n                     );"}, {"sha": "505cd331a25099f5debc4e96d1a632d52dbd9d2d", "filename": "src/librustc_resolve/def_collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_resolve%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_resolve%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdef_collector.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::ast::*;\n use rustc_ast::token::{self, Token};\n use rustc_ast::visit::{self, FnKind};\n use rustc_expand::expand::AstFragment;\n-use rustc_hir::def_id::DefIndex;\n+use rustc_hir::def_id::LocalDefId;\n use rustc_span::hygiene::ExpnId;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n@@ -21,18 +21,18 @@ crate fn collect_definitions(\n /// Creates `DefId`s for nodes in the AST.\n struct DefCollector<'a> {\n     definitions: &'a mut Definitions,\n-    parent_def: DefIndex,\n+    parent_def: LocalDefId,\n     expansion: ExpnId,\n }\n \n impl<'a> DefCollector<'a> {\n-    fn create_def(&mut self, node_id: NodeId, data: DefPathData, span: Span) -> DefIndex {\n+    fn create_def(&mut self, node_id: NodeId, data: DefPathData, span: Span) -> LocalDefId {\n         let parent_def = self.parent_def;\n         debug!(\"create_def(node_id={:?}, data={:?}, parent_def={:?})\", node_id, data, parent_def);\n         self.definitions.create_def_with_parent(parent_def, node_id, data, self.expansion, span)\n     }\n \n-    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n+    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: LocalDefId, f: F) {\n         let orig_parent_def = std::mem::replace(&mut self.parent_def, parent_def);\n         f(self);\n         self.parent_def = orig_parent_def;"}, {"sha": "51bf1f48439725da647c6741d2fa1b5256181c4f", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -17,7 +17,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node, ParamName, QPath};\n use rustc_hir::{GenericParamKind, HirIdMap, HirIdSet, LifetimeParamKind};\n@@ -280,25 +280,14 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     *providers = ty::query::Providers {\n         resolve_lifetimes,\n \n-        named_region_map: |tcx, id| {\n-            let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n-            tcx.resolve_lifetimes(LOCAL_CRATE).defs.get(&id)\n-        },\n-\n-        is_late_bound_map: |tcx, id| {\n-            let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n-            tcx.resolve_lifetimes(LOCAL_CRATE).late_bound.get(&id)\n-        },\n-\n+        named_region_map: |tcx, id| tcx.resolve_lifetimes(LOCAL_CRATE).defs.get(&id),\n+        is_late_bound_map: |tcx, id| tcx.resolve_lifetimes(LOCAL_CRATE).late_bound.get(&id),\n         object_lifetime_defaults_map: |tcx, id| {\n-            let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n             tcx.resolve_lifetimes(LOCAL_CRATE).object_lifetime_defaults.get(&id)\n         },\n \n         ..*providers\n     };\n-\n-    // (*) FIXME the query should be defined to take a LocalDefId\n }\n \n /// Computes the `ResolveLifetimes` map that contains data for the\n@@ -313,15 +302,15 @@ fn resolve_lifetimes(tcx: TyCtxt<'_>, for_krate: CrateNum) -> &ResolveLifetimes\n     let mut rl = ResolveLifetimes::default();\n \n     for (hir_id, v) in named_region_map.defs {\n-        let map = rl.defs.entry(hir_id.owner_local_def_id()).or_default();\n+        let map = rl.defs.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n     }\n     for hir_id in named_region_map.late_bound {\n-        let map = rl.late_bound.entry(hir_id.owner_local_def_id()).or_default();\n+        let map = rl.late_bound.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id);\n     }\n     for (hir_id, v) in named_region_map.object_lifetime_defaults {\n-        let map = rl.object_lifetime_defaults.entry(hir_id.owner_local_def_id()).or_default();\n+        let map = rl.object_lifetime_defaults.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n     }\n "}, {"sha": "4a2a2a296faea32bb1405be9d09a02ae19e0ecd8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -37,7 +37,7 @@ use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_expand::base::SyntaxExtension;\n use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX};\n use rustc_hir::PrimTy::{self, Bool, Char, Float, Int, Str, Uint};\n use rustc_hir::{GlobMap, TraitMap};\n use rustc_metadata::creader::{CStore, CrateLoader};\n@@ -1015,9 +1015,9 @@ impl<'a> AsMut<Resolver<'a>> for Resolver<'a> {\n \n impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n     fn parent(self, id: DefId) -> Option<DefId> {\n-        match id.krate {\n-            LOCAL_CRATE => self.definitions.def_key(id.index).parent,\n-            _ => self.cstore().def_key(id).parent,\n+        match id.as_local() {\n+            Some(id) => self.definitions.def_key(id).parent,\n+            None => self.cstore().def_key(id).parent,\n         }\n         .map(|index| DefId { index, ..id })\n     }\n@@ -1027,7 +1027,11 @@ impl<'a, 'b> DefIdTree for &'a Resolver<'b> {\n /// the resolver is no longer needed as all the relevant information is inline.\n impl rustc_ast_lowering::Resolver for Resolver<'_> {\n     fn def_key(&mut self, id: DefId) -> DefKey {\n-        if id.is_local() { self.definitions().def_key(id.index) } else { self.cstore().def_key(id) }\n+        if let Some(id) = id.as_local() {\n+            self.definitions().def_key(id)\n+        } else {\n+            self.cstore().def_key(id)\n+        }\n     }\n \n     fn item_generics_num_lifetimes(&self, def_id: DefId, sess: &Session) -> usize {"}, {"sha": "29561c91f33184da39af3799f671045759dbdae3", "filename": "src/librustc_span/def_id.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_span%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_span%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fdef_id.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -164,8 +164,13 @@ impl DefId {\n     }\n \n     #[inline]\n-    pub fn to_local(self) -> LocalDefId {\n-        LocalDefId::from_def_id(self)\n+    pub fn as_local(self) -> Option<LocalDefId> {\n+        if self.is_local() { Some(LocalDefId { local_def_index: self.index }) } else { None }\n+    }\n+\n+    #[inline]\n+    pub fn expect_local(self) -> LocalDefId {\n+        self.as_local().unwrap_or_else(|| panic!(\"DefId::expect_local: `{:?}` isn't local\", self))\n     }\n \n     pub fn is_top_level_module(self) -> bool {\n@@ -210,19 +215,26 @@ rustc_data_structures::define_id_collections!(DefIdMap, DefIdSet, DefId);\n /// few cases where we know that only DefIds from the local crate are expected\n /// and a DefId from a different crate would signify a bug somewhere. This\n /// is when LocalDefId comes in handy.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct LocalDefId(DefIndex);\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct LocalDefId {\n+    pub local_def_index: DefIndex,\n+}\n \n-impl LocalDefId {\n+impl Idx for LocalDefId {\n     #[inline]\n-    pub fn from_def_id(def_id: DefId) -> LocalDefId {\n-        assert!(def_id.is_local());\n-        LocalDefId(def_id.index)\n+    fn new(idx: usize) -> Self {\n+        LocalDefId { local_def_index: Idx::new(idx) }\n     }\n+    #[inline]\n+    fn index(self) -> usize {\n+        self.local_def_index.index()\n+    }\n+}\n \n+impl LocalDefId {\n     #[inline]\n     pub fn to_def_id(self) -> DefId {\n-        DefId { krate: LOCAL_CRATE, index: self.0 }\n+        DefId { krate: LOCAL_CRATE, index: self.local_def_index }\n     }\n }\n "}, {"sha": "0523a2019861cef951fc52238c3977393d87a4c2", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -1287,7 +1287,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             let parent = hir.get_parent_node(expr_id);\n             if let Some(hir::Node::Expr(e)) = hir.find(parent) {\n                 let parent_span = hir.span(parent);\n-                let parent_did = parent.owner_def_id();\n+                let parent_did = parent.owner.to_def_id();\n                 // ```rust\n                 // impl T {\n                 //     fn foo(&self) -> i32 {}"}, {"sha": "452f965014bff38c34bb8034caa982bc1707182e", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -185,7 +185,7 @@ fn get_sized_bounds(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SmallVec<[Span; 1]>\n                     .filter_map(|pred| {\n                         match pred {\n                             hir::WherePredicate::BoundPredicate(pred)\n-                                if pred.bounded_ty.hir_id.owner_def_id() == trait_def_id =>\n+                                if pred.bounded_ty.hir_id.owner.to_def_id() == trait_def_id =>\n                             {\n                                 // Fetch spans for trait bounds that are Sized:\n                                 // `trait T where Self: Pred`"}, {"sha": "617c54a738e6eaf2b7298160cb6f5cfa93dbf241", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -1631,7 +1631,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     fn point_at_param_definition(&self, err: &mut DiagnosticBuilder<'_>, param: ty::ParamTy) {\n-        let generics = self.tcx.generics_of(self.body_id.owner_def_id());\n+        let generics = self.tcx.generics_of(self.body_id.owner.to_def_id());\n         let generic_param = generics.type_param(&param, self.tcx);\n         if let ty::GenericParamDefKind::Type { synthetic: Some(..), .. } = generic_param.kind {\n             return;"}, {"sha": "2f0eb5e06709a0191fc4ebb04d8686684172f168", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -427,7 +427,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         });\n \n                     if let Some((field, field_ty)) = field_receiver {\n-                        let scope = self.tcx.parent_module(self.body_id);\n+                        let scope = self.tcx.parent_module(self.body_id).to_def_id();\n                         let is_accessible = field.vis.is_accessible_from(scope, self.tcx);\n \n                         if is_accessible {\n@@ -828,7 +828,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         candidates: Vec<DefId>,\n     ) {\n         let module_did = self.tcx.parent_module(self.body_id);\n-        let module_id = self.tcx.hir().as_local_hir_id(module_did).unwrap();\n+        let module_id = self.tcx.hir().as_local_hir_id(module_did.to_def_id()).unwrap();\n         let krate = self.tcx.hir().krate();\n         let (span, found_use) = UsePlacementFinder::check(self.tcx, krate, module_id);\n         if let Some(span) = span {"}, {"sha": "368f64e4d41aab6716185803f0153936619e06e5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -638,9 +638,8 @@ pub struct InheritedBuilder<'tcx> {\n \n impl Inherited<'_, 'tcx> {\n     pub fn build(tcx: TyCtxt<'tcx>, def_id: DefId) -> InheritedBuilder<'tcx> {\n-        let hir_id_root = if def_id.is_local() {\n-            let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-            DefId::local(hir_id.owner)\n+        let hir_id_root = if let Some(def_id) = def_id.as_local() {\n+            tcx.hir().local_def_id_to_hir_id(def_id).owner.to_def_id()\n         } else {\n             def_id\n         };\n@@ -1128,7 +1127,7 @@ fn typeck_tables_of_with_fallback<'tcx>(\n \n     // Consistency check our TypeckTables instance can hold all ItemLocalIds\n     // it will need to hold.\n-    assert_eq!(tables.local_id_root, Some(DefId::local(id.owner)));\n+    assert_eq!(tables.local_id_root, Some(id.owner.to_def_id()));\n \n     tables\n }"}, {"sha": "1b5f151870c2f7400f449384b83d8479a756c5c5", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -118,7 +118,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             for (&var_hir_id, _) in upvars.iter() {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                    closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n+                    closure_expr_id: closure_def_id.expect_local(),\n                 };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n                 // Adding the upvar Id to the list of Upvars, which will be added\n@@ -228,7 +228,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let upvar_ty = self.node_ty(var_hir_id);\n                     let upvar_id = ty::UpvarId {\n                         var_path: ty::UpvarPath { hir_id: var_hir_id },\n-                        closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n+                        closure_expr_id: closure_def_id.expect_local(),\n                     };\n                     let capture = self.tables.borrow().upvar_capture(upvar_id);\n "}, {"sha": "fd92284effb322842c8af3ffb8309889fd6fc2de", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -9,7 +9,7 @@ use rustc::ty::fold::{TypeFoldable, TypeFolder};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, DefIdSet, DefIndex};\n+use rustc_hir::def_id::DefIdSet;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_infer::infer::error_reporting::TypeAnnotationNeeded::E0282;\n use rustc_infer::infer::InferCtxt;\n@@ -107,11 +107,11 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         body: &'tcx hir::Body<'tcx>,\n         rustc_dump_user_substs: bool,\n     ) -> WritebackCx<'cx, 'tcx> {\n-        let owner = body.id().hir_id;\n+        let owner = body.id().hir_id.owner;\n \n         WritebackCx {\n             fcx,\n-            tables: ty::TypeckTables::empty(Some(DefId::local(owner.owner))),\n+            tables: ty::TypeckTables::empty(Some(owner.to_def_id())),\n             body,\n             rustc_dump_user_substs,\n         }\n@@ -342,7 +342,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         let common_local_id_root = fcx_tables.local_id_root.unwrap();\n \n         for (&id, &origin) in fcx_tables.closure_kind_origins().iter() {\n-            let hir_id = hir::HirId { owner: common_local_id_root.index, local_id: id };\n+            let hir_id = hir::HirId { owner: common_local_id_root.expect_local(), local_id: id };\n             self.tables.closure_kind_origins_mut().insert(hir_id, origin);\n         }\n     }\n@@ -364,7 +364,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n         let mut errors_buffer = Vec::new();\n         for (&local_id, c_ty) in fcx_tables.user_provided_types().iter() {\n-            let hir_id = hir::HirId { owner: common_local_id_root.index, local_id };\n+            let hir_id = hir::HirId { owner: common_local_id_root.expect_local(), local_id };\n \n             if cfg!(debug_assertions) && c_ty.has_local_value() {\n                 span_bug!(hir_id.to_span(self.fcx.tcx), \"writeback: `{:?}` is a local value\", c_ty);\n@@ -557,7 +557,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         let common_local_id_root = fcx_tables.local_id_root.unwrap();\n \n         for (&local_id, fn_sig) in fcx_tables.liberated_fn_sigs().iter() {\n-            let hir_id = hir::HirId { owner: common_local_id_root.index, local_id };\n+            let hir_id = hir::HirId { owner: common_local_id_root.expect_local(), local_id };\n             let fn_sig = self.resolve(fn_sig, &hir_id);\n             self.tables.liberated_fn_sigs_mut().insert(hir_id, fn_sig.clone());\n         }\n@@ -569,7 +569,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         let common_local_id_root = fcx_tables.local_id_root.unwrap();\n \n         for (&local_id, ftys) in fcx_tables.fru_field_types().iter() {\n-            let hir_id = hir::HirId { owner: common_local_id_root.index, local_id };\n+            let hir_id = hir::HirId { owner: common_local_id_root.expect_local(), local_id };\n             let ftys = self.resolve(ftys, &hir_id);\n             self.tables.fru_field_types_mut().insert(hir_id, ftys);\n         }\n@@ -597,13 +597,6 @@ impl Locatable for Span {\n     }\n }\n \n-impl Locatable for DefIndex {\n-    fn to_span(&self, tcx: TyCtxt<'_>) -> Span {\n-        let hir_id = tcx.hir().def_index_to_hir_id(*self);\n-        tcx.hir().span(hir_id)\n-    }\n-}\n-\n impl Locatable for hir::HirId {\n     fn to_span(&self, tcx: TyCtxt<'_>) -> Span {\n         tcx.hir().span(*self)"}, {"sha": "a45d8ce6823a3ddae3722dc9c309f0fb66af1b5a", "filename": "src/librustc_typeck/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fexpr_use_visitor.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -519,7 +519,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             for &var_id in upvars.keys() {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath { hir_id: var_id },\n-                    closure_expr_id: closure_def_id.to_local(),\n+                    closure_expr_id: closure_def_id.expect_local(),\n                 };\n                 let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n                 let captured_place = return_if_err!(self.cat_captured_var("}, {"sha": "7d8bf71cf97b7e455d8783ad05e9275dcaa33307", "filename": "src/librustc_typeck/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_typeck%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustc_typeck%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fmem_categorization.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -470,7 +470,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n \n         let upvar_id = ty::UpvarId {\n             var_path: ty::UpvarPath { hir_id: var_id },\n-            closure_expr_id: closure_expr_def_id.to_local(),\n+            closure_expr_id: closure_expr_def_id.expect_local(),\n         };\n         let var_ty = self.node_ty(var_id)?;\n "}, {"sha": "113c781e33205bc4ba89202d88c7906bc6303640", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c6f982cc908aacc39c3ac97f31c989f81cc213c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=3c6f982cc908aacc39c3ac97f31c989f81cc213c", "patch": "@@ -348,7 +348,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n         let parent_node = self.cx.as_local_hir_id(item.def_id).and_then(|hir_id| {\n             // FIXME: this fails hard for impls in non-module scope, but is necessary for the\n             // current `resolve()` implementation.\n-            match self.cx.as_local_hir_id(self.cx.tcx.parent_module(hir_id)).unwrap() {\n+            match self.cx.as_local_hir_id(self.cx.tcx.parent_module(hir_id).to_def_id()).unwrap() {\n                 id if id != hir_id => Some(id),\n                 _ => None,\n             }"}]}