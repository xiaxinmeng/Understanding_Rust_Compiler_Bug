{"sha": "b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzYWYzN2FjN2I5ZDViZDZkY2Q3NDdhNjIzODI5MDhkY2I3YzljYTk=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2021-09-12T10:44:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-09-12T10:44:58Z"}, "message": "Rollup merge of #88810 - camelid:cleanup-pt1, r=jyn514\n\nrustdoc: Cleanup `clean` part 1\n\nSplit out from #88379.\n\nThese commits are completely independent of each other, and each is a fairly\nsmall change (the last few are new commits; they are not from #88379):\n\n- Remove unnecessary `Cache.*_did` fields\n- rustdoc: Get symbol for `TyParam` directly\n- Create a valid `Res` in `external_path()`\n- Remove unused `hir_id` parameter from `resolve_type`\n- Fix redundant arguments in `external_path()`\n- Remove unnecessary `is_trait` argument\n- rustdoc: Cleanup a pattern match in `external_generic_args()`\n\nr? ``@jyn514``", "tree": {"sha": "2c54847365672917f4a157f52c6a9eff8d0ce36b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2c54847365672917f4a157f52c6a9eff8d0ce36b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhPdoqCRBK7hj4Ov3rIwAAJ14IAApS8eUWbD1uYGdGHGxJhs1F\nY+3YrLNhM4vO8BJ7Am7+i+tmbaS/Dv01p2IsFZ0FhQB57vzDlFxbB7vTfHExjHV0\nYeatcFJMrI9/qyMTRya6aZMSYJ+oY0DyKI8wXyaQOQSV2w2IgaeJm9WWX2VeLT62\nrOzuTOzA3KriyisIe5UXGQ78Z/gQogTcFY2ejw/lgGFP7yd29tumzKJE2I5aksad\nRU0W0nAUjYeOjtSAENOkIgt6Ue1zXwXLyFcVUD5J1aShujUXiz/gVCuvJzZjcwAI\nMYiUU6hGDksUZVZUCrLahFGoaM+gbaC1GiFhsq5kAhTji5vgxu3b51zVN4vNrnQ=\n=qTUg\n-----END PGP SIGNATURE-----\n", "payload": "tree 2c54847365672917f4a157f52c6a9eff8d0ce36b\nparent b87d0d0d94bf12c007bc7a074d056737bf2c945c\nparent 280fc2dcce6349beb46b099da8f5fbbf463185cd\nauthor Manish Goregaokar <manishsmail@gmail.com> 1631443498 -0700\ncommitter GitHub <noreply@github.com> 1631443498 -0700\n\nRollup merge of #88810 - camelid:cleanup-pt1, r=jyn514\n\nrustdoc: Cleanup `clean` part 1\n\nSplit out from #88379.\n\nThese commits are completely independent of each other, and each is a fairly\nsmall change (the last few are new commits; they are not from #88379):\n\n- Remove unnecessary `Cache.*_did` fields\n- rustdoc: Get symbol for `TyParam` directly\n- Create a valid `Res` in `external_path()`\n- Remove unused `hir_id` parameter from `resolve_type`\n- Fix redundant arguments in `external_path()`\n- Remove unnecessary `is_trait` argument\n- rustdoc: Cleanup a pattern match in `external_generic_args()`\n\nr? ``@jyn514``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9", "html_url": "https://github.com/rust-lang/rust/commit/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b87d0d0d94bf12c007bc7a074d056737bf2c945c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b87d0d0d94bf12c007bc7a074d056737bf2c945c", "html_url": "https://github.com/rust-lang/rust/commit/b87d0d0d94bf12c007bc7a074d056737bf2c945c"}, {"sha": "280fc2dcce6349beb46b099da8f5fbbf463185cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/280fc2dcce6349beb46b099da8f5fbbf463185cd", "html_url": "https://github.com/rust-lang/rust/commit/280fc2dcce6349beb46b099da8f5fbbf463185cd"}], "stats": {"total": 143, "additions": 59, "deletions": 84}, "files": [{"sha": "e281bbc59c255c26e0b707e225d6356e5e60e6df", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 26, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9", "patch": "@@ -164,14 +164,7 @@ impl Clean<Type> for (ty::TraitRef<'_>, &[TypeBinding]) {\n             );\n         }\n         inline::record_extern_fqn(cx, trait_ref.def_id, kind);\n-        let path = external_path(\n-            cx,\n-            cx.tcx.item_name(trait_ref.def_id),\n-            Some(trait_ref.def_id),\n-            true,\n-            bounds.to_vec(),\n-            trait_ref.substs,\n-        );\n+        let path = external_path(cx, trait_ref.def_id, true, bounds.to_vec(), trait_ref.substs);\n \n         debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", trait_ref.substs);\n \n@@ -906,7 +899,7 @@ impl Clean<bool> for hir::IsAuto {\n impl Clean<Type> for hir::TraitRef<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         let path = self.path.clean(cx);\n-        resolve_type(cx, path, self.hir_ref_id)\n+        resolve_type(cx, path)\n     }\n }\n \n@@ -1164,7 +1157,7 @@ impl Clean<Item> for ty::AssocItem {\n \n fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n     use rustc_hir::GenericParamCount;\n-    let hir::Ty { hir_id, span, ref kind } = *hir_ty;\n+    let hir::Ty { hir_id: _, span, ref kind } = *hir_ty;\n     let qpath = match kind {\n         hir::TyKind::Path(qpath) => qpath,\n         _ => unreachable!(),\n@@ -1271,7 +1264,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 return cx.enter_alias(ty_substs, lt_substs, ct_substs, |cx| ty.clean(cx));\n             }\n             let path = path.clean(cx);\n-            resolve_type(cx, path, hir_id)\n+            resolve_type(cx, path)\n         }\n         hir::QPath::Resolved(Some(ref qself), ref p) => {\n             // Try to normalize `<X as Y>::T` to a type\n@@ -1292,7 +1285,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 name: p.segments.last().expect(\"segments were empty\").ident.name,\n                 self_def_id: Some(DefId::local(qself.hir_id.owner.local_def_index)),\n                 self_type: Box::new(qself.clean(cx)),\n-                trait_: Box::new(resolve_type(cx, trait_path, hir_id)),\n+                trait_: Box::new(resolve_type(cx, trait_path)),\n             }\n         }\n         hir::QPath::TypeRelative(ref qself, ref segment) => {\n@@ -1308,7 +1301,7 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n                 name: segment.ident.name,\n                 self_def_id: res.opt_def_id(),\n                 self_type: Box::new(qself.clean(cx)),\n-                trait_: Box::new(resolve_type(cx, trait_path, hir_id)),\n+                trait_: Box::new(resolve_type(cx, trait_path)),\n             }\n         }\n         hir::QPath::LangItem(..) => bug!(\"clean: requiring documentation of lang item\"),\n@@ -1448,19 +1441,12 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     AdtKind::Enum => ItemType::Enum,\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n-                let path = external_path(cx, cx.tcx.item_name(did), None, false, vec![], substs);\n+                let path = external_path(cx, did, false, vec![], substs);\n                 ResolvedPath { path, did, is_generic: false }\n             }\n             ty::Foreign(did) => {\n                 inline::record_extern_fqn(cx, did, ItemType::ForeignType);\n-                let path = external_path(\n-                    cx,\n-                    cx.tcx.item_name(did),\n-                    None,\n-                    false,\n-                    vec![],\n-                    InternalSubsts::empty(),\n-                );\n+                let path = external_path(cx, did, false, vec![], InternalSubsts::empty());\n                 ResolvedPath { path, did, is_generic: false }\n             }\n             ty::Dynamic(ref obj, ref reg) => {\n@@ -1484,8 +1470,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n                 for did in dids {\n                     let empty = cx.tcx.intern_substs(&[]);\n-                    let path =\n-                        external_path(cx, cx.tcx.item_name(did), Some(did), false, vec![], empty);\n+                    let path = external_path(cx, did, false, vec![], empty);\n                     inline::record_extern_fqn(cx, did, ItemType::Trait);\n                     let bound = PolyTrait {\n                         trait_: ResolvedPath { path, did, is_generic: false },\n@@ -1502,8 +1487,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     });\n                 }\n \n-                let path =\n-                    external_path(cx, cx.tcx.item_name(did), Some(did), false, bindings, substs);\n+                let path = external_path(cx, did, false, bindings, substs);\n                 bounds.insert(\n                     0,\n                     PolyTrait {"}, {"sha": "b3c320555f9e53e08e030134b440432ed4722cab", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9", "patch": "@@ -1111,7 +1111,7 @@ impl GenericBound {\n     crate fn maybe_sized(cx: &mut DocContext<'_>) -> GenericBound {\n         let did = cx.tcx.require_lang_item(LangItem::Sized, None);\n         let empty = cx.tcx.intern_substs(&[]);\n-        let path = external_path(cx, cx.tcx.item_name(did), Some(did), false, vec![], empty);\n+        let path = external_path(cx, did, false, vec![], empty);\n         inline::record_extern_fqn(cx, did, ItemType::Trait);\n         GenericBound::TraitBound(\n             PolyTrait {"}, {"sha": "b0021d1234cd610ecdabb6494631ef10624dcffd", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9", "patch": "@@ -29,10 +29,6 @@ crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n     let krate = cx.tcx.hir().krate();\n     let module = crate::visit_ast::RustdocVisitor::new(cx).visit(krate);\n \n-    cx.cache.deref_trait_did = cx.tcx.lang_items().deref_trait();\n-    cx.cache.deref_mut_trait_did = cx.tcx.lang_items().deref_mut_trait();\n-    cx.cache.owned_box_did = cx.tcx.lang_items().owned_box();\n-\n     let mut externs = Vec::new();\n     for &cnum in cx.tcx.crates(()).iter() {\n         externs.push(ExternalCrate { crate_num: cnum });\n@@ -97,7 +93,7 @@ crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n \n fn external_generic_args(\n     cx: &mut DocContext<'_>,\n-    trait_did: Option<DefId>,\n+    did: DefId,\n     has_self: bool,\n     bindings: Vec<TypeBinding>,\n     substs: SubstsRef<'_>,\n@@ -125,42 +121,38 @@ fn external_generic_args(\n         })\n         .collect();\n \n-    match trait_did {\n-        // Attempt to sugar an external path like Fn<(A, B,), C> to Fn(A, B) -> C\n-        Some(did) if cx.tcx.fn_trait_kind_from_lang_item(did).is_some() => {\n-            assert!(ty_kind.is_some());\n-            let inputs = match ty_kind {\n-                Some(ty::Tuple(ref tys)) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),\n-                _ => return GenericArgs::AngleBracketed { args, bindings },\n-            };\n-            let output = None;\n-            // FIXME(#20299) return type comes from a projection now\n-            // match types[1].kind {\n-            //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n-            //     _ => Some(types[1].clean(cx))\n-            // };\n-            GenericArgs::Parenthesized { inputs, output }\n-        }\n-        _ => GenericArgs::AngleBracketed { args, bindings },\n+    if cx.tcx.fn_trait_kind_from_lang_item(did).is_some() {\n+        let inputs = match ty_kind.unwrap() {\n+            ty::Tuple(tys) => tys.iter().map(|t| t.expect_ty().clean(cx)).collect(),\n+            _ => return GenericArgs::AngleBracketed { args, bindings },\n+        };\n+        let output = None;\n+        // FIXME(#20299) return type comes from a projection now\n+        // match types[1].kind {\n+        //     ty::Tuple(ref v) if v.is_empty() => None, // -> ()\n+        //     _ => Some(types[1].clean(cx))\n+        // };\n+        GenericArgs::Parenthesized { inputs, output }\n+    } else {\n+        GenericArgs::AngleBracketed { args, bindings }\n     }\n }\n \n-// trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n-// from Fn<(A, B,), C> to Fn(A, B) -> C\n pub(super) fn external_path(\n     cx: &mut DocContext<'_>,\n-    name: Symbol,\n-    trait_did: Option<DefId>,\n+    did: DefId,\n     has_self: bool,\n     bindings: Vec<TypeBinding>,\n     substs: SubstsRef<'_>,\n ) -> Path {\n+    let def_kind = cx.tcx.def_kind(did);\n+    let name = cx.tcx.item_name(did);\n     Path {\n         global: false,\n-        res: Res::Err,\n+        res: Res::Def(def_kind, did),\n         segments: vec![PathSegment {\n             name,\n-            args: external_generic_args(cx, trait_did, has_self, bindings, substs),\n+            args: external_generic_args(cx, did, has_self, bindings, substs),\n         }],\n     }\n }\n@@ -409,16 +401,16 @@ crate fn print_const_expr(tcx: TyCtxt<'_>, body: hir::BodyId) -> String {\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt\n-crate fn resolve_type(cx: &mut DocContext<'_>, path: Path, id: hir::HirId) -> Type {\n-    debug!(\"resolve_type({:?},{:?})\", path, id);\n+crate fn resolve_type(cx: &mut DocContext<'_>, path: Path) -> Type {\n+    debug!(\"resolve_type({:?})\", path);\n \n     let is_generic = match path.res {\n         Res::PrimTy(p) => return Primitive(PrimitiveType::from(p)),\n         Res::SelfTy(..) if path.segments.len() == 1 => {\n             return Generic(kw::SelfUpper);\n         }\n         Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n-            return Generic(Symbol::intern(&path.whole_name()));\n+            return Generic(path.segments[0].name);\n         }\n         Res::SelfTy(..) | Res::Def(DefKind::TyParam | DefKind::AssocTy, _) => true,\n         _ => false,"}, {"sha": "bcfcc3d70395c1e3b996a50df2b1ed44af66c4da", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9", "patch": "@@ -98,9 +98,6 @@ crate struct Cache {\n     stripped_mod: bool,\n \n     crate search_index: Vec<IndexItem>,\n-    crate deref_trait_did: Option<DefId>,\n-    crate deref_mut_trait_did: Option<DefId>,\n-    crate owned_box_did: Option<DefId>,\n \n     // In rare case where a structure is defined in one module but implemented\n     // in another, if the implementing module is parsed before defining module,"}, {"sha": "1f27357f6c6eaf938c219dae0a3320594cd2849d", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 24, "deletions": 22, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9", "patch": "@@ -51,6 +51,7 @@ use rustc_hir::def::CtorKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::Mutability;\n use rustc_middle::middle::stability;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::{kw, sym, Symbol};\n use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n@@ -1067,13 +1068,13 @@ fn render_assoc_items(\n         return;\n     }\n     if !traits.is_empty() {\n-        let deref_impl = traits\n-            .iter()\n-            .find(|t| t.inner_impl().trait_.def_id_full(cache) == cache.deref_trait_did);\n+        let deref_impl = traits.iter().find(|t| {\n+            t.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_trait()\n+        });\n         if let Some(impl_) = deref_impl {\n-            let has_deref_mut = traits\n-                .iter()\n-                .any(|t| t.inner_impl().trait_.def_id_full(cache) == cache.deref_mut_trait_did);\n+            let has_deref_mut = traits.iter().any(|t| {\n+                t.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_mut_trait()\n+            });\n             render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n         }\n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n@@ -1163,7 +1164,7 @@ fn render_deref_methods(\n     }\n }\n \n-fn should_render_item(item: &clean::Item, deref_mut_: bool, cache: &Cache) -> bool {\n+fn should_render_item(item: &clean::Item, deref_mut_: bool, tcx: TyCtxt<'_>) -> bool {\n     let self_type_opt = match *item.kind {\n         clean::MethodItem(ref method, _) => method.decl.self_type(),\n         clean::TyMethodItem(ref method) => method.decl.self_type(),\n@@ -1177,7 +1178,7 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, cache: &Cache) -> bo\n                 (mutability == Mutability::Mut, false, false)\n             }\n             SelfTy::SelfExplicit(clean::ResolvedPath { did, .. }) => {\n-                (false, Some(did) == cache.owned_box_did, false)\n+                (false, Some(did) == tcx.lang_items().owned_box(), false)\n             }\n             SelfTy::SelfValue => (false, false, true),\n             _ => (false, false, false),\n@@ -1300,7 +1301,7 @@ fn render_impl(\n             && match render_mode {\n                 RenderMode::Normal => true,\n                 RenderMode::ForDeref { mut_: deref_mut_ } => {\n-                    should_render_item(&item, deref_mut_, cx.cache())\n+                    should_render_item(&item, deref_mut_, cx.tcx())\n                 }\n             };\n \n@@ -1798,13 +1799,13 @@ fn get_methods(\n     for_deref: bool,\n     used_links: &mut FxHashSet<String>,\n     deref_mut: bool,\n-    cache: &Cache,\n+    tcx: TyCtxt<'_>,\n ) -> Vec<String> {\n     i.items\n         .iter()\n         .filter_map(|item| match item.name {\n             Some(ref name) if !name.is_empty() && item.is_method() => {\n-                if !for_deref || should_render_item(item, deref_mut, cache) {\n+                if !for_deref || should_render_item(item, deref_mut, tcx) {\n                     Some(format!(\n                         \"<a href=\\\"#{}\\\">{}</a>\",\n                         get_next_url(used_links, format!(\"method.{}\", name)),\n@@ -1866,7 +1867,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n             let mut ret = v\n                 .iter()\n                 .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(move |i| get_methods(i.inner_impl(), false, used_links_bor, false, cache))\n+                .flat_map(move |i| {\n+                    get_methods(i.inner_impl(), false, used_links_bor, false, cx.tcx())\n+                })\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n                 // We want links' order to be reproducible so we don't use unstable sort.\n@@ -1884,11 +1887,9 @@ fn sidebar_assoc_items(cx: &Context<'_>, out: &mut Buffer, it: &clean::Item) {\n         }\n \n         if v.iter().any(|i| i.inner_impl().trait_.is_some()) {\n-            if let Some(impl_) = v\n-                .iter()\n-                .filter(|i| i.inner_impl().trait_.is_some())\n-                .find(|i| i.inner_impl().trait_.def_id_full(cache) == cache.deref_trait_did)\n-            {\n+            if let Some(impl_) = v.iter().filter(|i| i.inner_impl().trait_.is_some()).find(|i| {\n+                i.inner_impl().trait_.def_id_full(cache) == cx.tcx().lang_items().deref_trait()\n+            }) {\n                 sidebar_deref_methods(cx, out, impl_, v);\n             }\n \n@@ -1986,10 +1987,9 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n                 }\n             }\n         }\n-        let deref_mut = v\n-            .iter()\n-            .filter(|i| i.inner_impl().trait_.is_some())\n-            .any(|i| i.inner_impl().trait_.def_id_full(c) == c.deref_mut_trait_did);\n+        let deref_mut = v.iter().filter(|i| i.inner_impl().trait_.is_some()).any(|i| {\n+            i.inner_impl().trait_.def_id_full(c) == cx.tcx().lang_items().deref_mut_trait()\n+        });\n         let inner_impl = target\n             .def_id_full(c)\n             .or_else(|| {\n@@ -2002,7 +2002,9 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n             let mut ret = impls\n                 .iter()\n                 .filter(|i| i.inner_impl().trait_.is_none())\n-                .flat_map(|i| get_methods(i.inner_impl(), true, &mut used_links, deref_mut, c))\n+                .flat_map(|i| {\n+                    get_methods(i.inner_impl(), true, &mut used_links, deref_mut, cx.tcx())\n+                })\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n                 write!("}, {"sha": "16ab876e829ef8f25f4d82d79529e4c89c84f3ca", "filename": "src/test/rustdoc/synthetic_auto/no-redundancy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fsynthetic_auto%2Fno-redundancy.rs?ref=b3af37ac7b9d5bd6dcd747a62382908dcb7c9ca9", "patch": "@@ -10,7 +10,7 @@ where\n \n // @has no_redundancy/struct.Outer.html\n // @has - '//*[@id=\"synthetic-implementations-list\"]//*[@class=\"impl has-srclink\"]//h3[@class=\"code-header in-band\"]' \\\n-// \"impl<T> Send for Outer<T> where T: Copy + Send\"\n+// \"impl<T> Send for Outer<T> where T: Send + Copy\"\n pub struct Outer<T> {\n     inner_field: Inner<T>,\n }"}]}