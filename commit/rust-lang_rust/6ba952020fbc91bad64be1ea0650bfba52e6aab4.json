{"sha": "6ba952020fbc91bad64be1ea0650bfba52e6aab4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiYTk1MjAyMGZiYzkxYmFkNjRiZTFlYTA2NTBiZmJhNTJlNmFhYjQ=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2016-01-07T19:05:00Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2016-01-09T19:03:58Z"}, "message": "Remove many instances of 'just'\n\nDoing so is considered weaker writing. Thanks @Charlotteis!\n\nFixes #28810", "tree": {"sha": "33ee5a5555d7b641f5c8c5243fbda2fa5fca866d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33ee5a5555d7b641f5c8c5243fbda2fa5fca866d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ba952020fbc91bad64be1ea0650bfba52e6aab4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ba952020fbc91bad64be1ea0650bfba52e6aab4", "html_url": "https://github.com/rust-lang/rust/commit/6ba952020fbc91bad64be1ea0650bfba52e6aab4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ba952020fbc91bad64be1ea0650bfba52e6aab4/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d70ab2bdf16c22b9f3ff0230089b44855e3f1593", "url": "https://api.github.com/repos/rust-lang/rust/commits/d70ab2bdf16c22b9f3ff0230089b44855e3f1593", "html_url": "https://github.com/rust-lang/rust/commit/d70ab2bdf16c22b9f3ff0230089b44855e3f1593"}], "stats": {"total": 212, "additions": 106, "deletions": 106}, "files": [{"sha": "a0676a33996fc34bf83a380806db5a3acaa11373", "filename": "src/doc/book/associated-types.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fassociated-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fassociated-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fassociated-types.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -24,7 +24,7 @@ fn distance<N, E, G: Graph<N, E>>(graph: &G, start: &N, end: &N) -> u32 { ... }\n ```\n \n Our distance calculation works regardless of our `Edge` type, so the `E` stuff in\n-this signature is just a distraction.\n+this signature is a distraction.\n \n What we really want to say is that a certain `E`dge and `N`ode type come together\n to form each kind of `Graph`. We can do that with associated types:\n@@ -118,10 +118,10 @@ impl Graph for MyGraph {\n This silly implementation always returns `true` and an empty `Vec<Edge>`, but it\n gives you an idea of how to implement this kind of thing. We first need three\n `struct`s, one for the graph, one for the node, and one for the edge. If it made\n-more sense to use a different type, that would work as well, we\u2019re just going to\n+more sense to use a different type, that would work as well, we\u2019re going to\n use `struct`s for all three here.\n \n-Next is the `impl` line, which is just like implementing any other trait.\n+Next is the `impl` line, which is an implementation like any other trait.\n \n From here, we use `=` to define our associated types. The name the trait uses\n goes on the left of the `=`, and the concrete type we\u2019re `impl`ementing this"}, {"sha": "5cafe1693690ddf1a3b9a1524295b5f9906b42ad", "filename": "src/doc/book/casting-between-types.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fcasting-between-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fcasting-between-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcasting-between-types.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -154,7 +154,7 @@ implemented. For this, we need something more dangerous.\n The `transmute` function is provided by a [compiler intrinsic][intrinsics], and\n what it does is very simple, but very scary. It tells Rust to treat a value of\n one type as though it were another type. It does this regardless of the\n-typechecking system, and just completely trusts you.\n+typechecking system, and completely trusts you.\n \n [intrinsics]: intrinsics.html\n "}, {"sha": "f2b92e6dec4ddd664d48b0be1834353557783709", "filename": "src/doc/book/choosing-your-guarantees.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -52,7 +52,7 @@ These pointers cannot be copied in such a way that they outlive the lifetime ass\n \n ## `*const T` and `*mut T`\n \n-These are C-like raw pointers with no lifetime or ownership attached to them. They just point to\n+These are C-like raw pointers with no lifetime or ownership attached to them. They point to\n some location in memory with no other restrictions. The only guarantee that these provide is that\n they cannot be dereferenced except in code marked `unsafe`.\n \n@@ -255,7 +255,7 @@ major ones will be covered below.\n \n ## `Arc<T>`\n \n-[`Arc<T>`][arc] is just a version of `Rc<T>` that uses an atomic reference count (hence, \"Arc\").\n+[`Arc<T>`][arc] is a version of `Rc<T>` that uses an atomic reference count (hence, \"Arc\").\n This can be sent freely between threads.\n \n C++'s `shared_ptr` is similar to `Arc`, however in the case of C++ the inner data is always mutable."}, {"sha": "237545edc05bbf9231b516116bffdb1cba4a6f89", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -253,7 +253,7 @@ use it.\n # Taking closures as arguments\n \n Now that we know that closures are traits, we already know how to accept and\n-return closures: just like any other trait!\n+return closures: the same as any other trait!\n \n This also means that we can choose static vs dynamic dispatch as well. First,\n let\u2019s write a function which takes something callable, calls it, and returns\n@@ -271,7 +271,7 @@ let answer = call_with_one(|x| x + 2);\n assert_eq!(3, answer);\n ```\n \n-We pass our closure, `|x| x + 2`, to `call_with_one`. It just does what it\n+We pass our closure, `|x| x + 2`, to `call_with_one`. It does what it\n suggests: it calls the closure, giving it `1` as an argument.\n \n Let\u2019s examine the signature of `call_with_one` in more depth:\n@@ -448,7 +448,7 @@ This error is letting us know that we don\u2019t have a `&'static Fn(i32) -> i32`,\n we have a `[closure@<anon>:7:9: 7:20]`. Wait, what?\n \n Because each closure generates its own environment `struct` and implementation\n-of `Fn` and friends, these types are anonymous. They exist just solely for\n+of `Fn` and friends, these types are anonymous. They exist solely for\n this closure. So Rust shows them as `closure@<anon>`, rather than some\n autogenerated name.\n "}, {"sha": "44569a04b98243e0f3b3ce2bb87bcf63f30f63a9", "filename": "src/doc/book/concurrency.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fconcurrency.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -305,10 +305,10 @@ fn main() {\n }\n ```\n \n-We use the `mpsc::channel()` method to construct a new channel. We just `send`\n+We use the `mpsc::channel()` method to construct a new channel. We `send`\n a simple `()` down the channel, and then wait for ten of them to come back.\n \n-While this channel is just sending a generic signal, we can send any data that\n+While this channel is sending a generic signal, we can send any data that\n is `Send` over the channel!\n \n ```rust"}, {"sha": "2b6297640d09faab59f7edbd6786602ba026ee85", "filename": "src/doc/book/crates-and-modules.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcrates-and-modules.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -222,7 +222,7 @@ fn hello() -> String {\n }\n ```\n \n-Of course, you can copy and paste this from this web page, or just type\n+Of course, you can copy and paste this from this web page, or type\n something else. It\u2019s not important that you actually put \u2018konnichiwa\u2019 to learn\n about the module system.\n \n@@ -299,7 +299,7 @@ depth.\n Rust allows you to precisely control which aspects of your interface are\n public, and so private is the default. To make things public, you use the `pub`\n keyword. Let\u2019s focus on the `english` module first, so let\u2019s reduce our `src/main.rs`\n-to just this:\n+to only this:\n \n ```rust,ignore\n extern crate phrases;\n@@ -447,7 +447,7 @@ use phrases::english::{greetings, farewells};\n \n ## Re-exporting with `pub use`\n \n-You don\u2019t just use `use` to shorten identifiers. You can also use it inside of your crate\n+You don\u2019t only use `use` to shorten identifiers. You can also use it inside of your crate\n to re-export a function inside another module. This allows you to present an external\n interface that may not directly map to your internal code organization.\n \n@@ -584,5 +584,5 @@ use sayings::english::farewells as en_farewells;\n ```\n \n As you can see, the curly brackets compress `use` statements for several items\n-under the same path, and in this context `self` just refers back to that path.\n+under the same path, and in this context `self` refers back to that path.\n Note: The curly brackets cannot be nested or mixed with star globbing."}, {"sha": "d69ef6cf7e83acfd24fb741a34cba8a2ad5f3199", "filename": "src/doc/book/custom-allocators.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fcustom-allocators.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fcustom-allocators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fcustom-allocators.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -13,7 +13,7 @@ own allocator up and running.\n \n The compiler currently ships two default allocators: `alloc_system` and\n `alloc_jemalloc` (some targets don't have jemalloc, however). These allocators\n-are just normal Rust crates and contain an implementation of the routines to\n+are normal Rust crates and contain an implementation of the routines to\n allocate and deallocate memory. The standard library is not compiled assuming\n either one, and the compiler will decide which allocator is in use at\n compile-time depending on the type of output artifact being produced.\n@@ -134,7 +134,7 @@ pub extern fn __rust_usable_size(size: usize, _align: usize) -> usize {\n     size\n }\n \n-# // just needed to get rustdoc to test this\n+# // only needed to get rustdoc to test this\n # fn main() {}\n # #[lang = \"panic_fmt\"] fn panic_fmt() {}\n # #[lang = \"eh_personality\"] fn eh_personality() {}"}, {"sha": "4053e5776e39f89982e5e2cacde47d52adb3245f", "filename": "src/doc/book/documentation.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fdocumentation.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -193,7 +193,7 @@ If you want something that's not Rust code, you can add an annotation:\n ```\n \n This will highlight according to whatever language you're showing off.\n-If you're just showing plain text, choose `text`.\n+If you're only showing plain text, choose `text`.\n \n It's important to choose the correct annotation here, because `rustdoc` uses it\n in an interesting way: It can be used to actually test your examples in a\n@@ -273,7 +273,7 @@ be hidden from the output, but will be used when compiling your code. You\n can use this to your advantage. In this case, documentation comments need\n to apply to some kind of function, so if I want to show you just a\n documentation comment, I need to add a little function definition below\n-it. At the same time, it's just there to satisfy the compiler, so hiding\n+it. At the same time, it's only there to satisfy the compiler, so hiding\n it makes the example more clear. You can use this technique to explain\n longer examples in detail, while still preserving the testability of your\n documentation.\n@@ -512,7 +512,7 @@ the documentation with comments. For example:\n # fn foo() {}\n ```\n \n-is just\n+is:\n \n ~~~markdown\n # Examples"}, {"sha": "1556caaf993647e17f37d279273f67830f2b68df", "filename": "src/doc/book/error-handling.md", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ferror-handling.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -117,8 +117,8 @@ the first example. This is because the\n panic is embedded in the calls to `unwrap`.\n \n To \u201cunwrap\u201d something in Rust is to say, \u201cGive me the result of the\n-computation, and if there was an error, just panic and stop the program.\u201d\n-It would be better if we just showed the code for unwrapping because it is so\n+computation, and if there was an error, panic and stop the program.\u201d\n+It would be better if we showed the code for unwrapping because it is so\n simple, but to do that, we will first need to explore the `Option` and `Result`\n types. Both of these types have a method called `unwrap` defined on them.\n \n@@ -154,7 +154,7 @@ fn find(haystack: &str, needle: char) -> Option<usize> {\n }\n ```\n \n-Notice that when this function finds a matching character, it doesn't just\n+Notice that when this function finds a matching character, it doesn't only\n return the `offset`. Instead, it returns `Some(offset)`. `Some` is a variant or\n a *value constructor* for the `Option` type. You can think of it as a function\n with the type `fn<T>(value: T) -> Option<T>`. Correspondingly, `None` is also a\n@@ -216,7 +216,7 @@ we saw how to use `find` to discover the extension in a file name. Of course,\n not all file names have a `.` in them, so it's possible that the file name has\n no extension. This *possibility of absence* is encoded into the types using\n `Option<T>`. In other words, the compiler will force us to address the\n-possibility that an extension does not exist. In our case, we just print out a\n+possibility that an extension does not exist. In our case, we only print out a\n message saying as such.\n \n Getting the extension of a file name is a pretty common operation, so it makes\n@@ -248,7 +248,7 @@ tiresome.\n \n In fact, the case analysis in `extension_explicit` follows a very common\n pattern: *map* a function on to the value inside of an `Option<T>`, unless the\n-option is `None`, in which case, just return `None`.\n+option is `None`, in which case, return `None`.\n \n Rust has parametric polymorphism, so it is very easy to define a combinator\n that abstracts this pattern:\n@@ -350,7 +350,7 @@ fn file_name(file_path: &str) -> Option<&str> {\n }\n ```\n \n-You might think that we could just use the `map` combinator to reduce the case\n+You might think that we could use the `map` combinator to reduce the case\n analysis, but its type doesn't quite fit. Namely, `map` takes a function that\n does something only with the inner value. The result of that function is then\n *always* [rewrapped with `Some`](#code-option-map). Instead, we need something\n@@ -670,7 +670,7 @@ The tricky aspect here is that `argv.nth(1)` produces an `Option` while\n with both an `Option` and a `Result`, the solution is *usually* to convert the\n `Option` to a `Result`. In our case, the absence of a command line parameter\n (from `env::args()`) means the user didn't invoke the program correctly. We\n-could just use a `String` to describe the error. Let's try:\n+could use a `String` to describe the error. Let's try:\n \n <span id=\"code-error-double-string\"></span>\n \n@@ -709,7 +709,7 @@ fn ok_or<T, E>(option: Option<T>, err: E) -> Result<T, E> {\n \n The other new combinator used here is\n [`Result::map_err`](../std/result/enum.Result.html#method.map_err).\n-This is just like `Result::map`, except it maps a function on to the *error*\n+This is like `Result::map`, except it maps a function on to the *error*\n portion of a `Result` value. If the `Result` is an `Ok(...)` value, then it is\n returned unmodified.\n \n@@ -841,7 +841,7 @@ example, the very last call to `map` multiplies the `Ok(...)` value (which is\n an `i32`) by `2`. If an error had occurred before that point, this operation\n would have been skipped because of how `map` is defined.\n \n-`map_err` is the trick that makes all of this work. `map_err` is just like\n+`map_err` is the trick that makes all of this work. `map_err` is like\n `map`, except it applies a function to the `Err(...)` value of a `Result`. In\n this case, we want to convert all of our errors to one type: `String`. Since\n both `io::Error` and `num::ParseIntError` implement `ToString`, we can call the\n@@ -901,7 +901,7 @@ reduce explicit case analysis. Combinators aren't the only way.\n ## The `try!` macro\n \n A cornerstone of error handling in Rust is the `try!` macro. The `try!` macro\n-abstracts case analysis just like combinators, but unlike combinators, it also\n+abstracts case analysis like combinators, but unlike combinators, it also\n abstracts *control flow*. Namely, it can abstract the *early return* pattern\n seen above.\n \n@@ -1461,7 +1461,7 @@ expose its representation (like\n [`ErrorKind`](../std/io/enum.ErrorKind.html)) or keep it hidden (like\n [`ParseIntError`](../std/num/struct.ParseIntError.html)). Regardless\n of how you do it, it's usually good practice to at least provide some\n-information about the error beyond just its `String`\n+information about the error beyond its `String`\n representation. But certainly, this will vary depending on use cases.\n \n At a minimum, you should probably implement the\n@@ -1499,7 +1499,7 @@ that can go wrong!\n The data we'll be using comes from the [Data Science\n Toolkit][11]. I've prepared some data from it for this exercise. You\n can either grab the [world population data][12] (41MB gzip compressed,\n-145MB uncompressed) or just the [US population data][13] (2.2MB gzip\n+145MB uncompressed) or only the [US population data][13] (2.2MB gzip\n compressed, 7.2MB uncompressed).\n \n Up until now, we've kept the code limited to Rust's standard library. For a real\n@@ -1706,7 +1706,7 @@ compiler can no longer reason about its underlying type.\n \n [Previously](#the-limits-of-combinators) we started refactoring our code by\n changing the type of our function from `T` to `Result<T, OurErrorType>`. In\n-this case, `OurErrorType` is just `Box<Error>`. But what's `T`? And can we add\n+this case, `OurErrorType` is only `Box<Error>`. But what's `T`? And can we add\n a return type to `main`?\n \n The answer to the second question is no, we can't. That means we'll need to\n@@ -1924,7 +1924,7 @@ parser out of\n But how can we use the same code over both types? There's actually a\n couple ways we could go about this. One way is to write `search` such\n that it is generic on some type parameter `R` that satisfies\n-`io::Read`. Another way is to just use trait objects:\n+`io::Read`. Another way is to use trait objects:\n \n ```rust,ignore\n fn search<P: AsRef<Path>>\n@@ -2081,7 +2081,7 @@ opts.optflag(\"q\", \"quiet\", \"Silences errors and warnings.\");\n ...\n ```\n \n-Now we just need to implement our \u201cquiet\u201d functionality. This requires us to\n+Now we only need to implement our \u201cquiet\u201d functionality. This requires us to\n tweak the case analysis in `main`:\n \n ```rust,ignore\n@@ -2114,7 +2114,7 @@ handling in Rust. These are some good \u201crules of thumb.\" They are emphatically\n heuristics!\n \n * If you're writing short example code that would be overburdened by error\n-  handling, it's probably just fine to use `unwrap` (whether that's\n+  handling, it's probably fine to use `unwrap` (whether that's\n   [`Result::unwrap`](../std/result/enum.Result.html#method.unwrap),\n   [`Option::unwrap`](../std/option/enum.Option.html#method.unwrap)\n   or preferably"}, {"sha": "5c9e55e549e17ed31f8da87f269e7fcbc0fabdec", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -367,7 +367,7 @@ artifact.\n A few examples of how this model can be used are:\n \n * A native build dependency. Sometimes some C/C++ glue is needed when writing\n-  some Rust code, but distribution of the C/C++ code in a library format is just\n+  some Rust code, but distribution of the C/C++ code in a library format is\n   a burden. In this case, the code will be archived into `libfoo.a` and then the\n   Rust crate would declare a dependency via `#[link(name = \"foo\", kind =\n   \"static\")]`.\n@@ -490,7 +490,7 @@ interoperating with the target's libraries. For example, on win32 with a x86\n architecture, this means that the abi used would be `stdcall`. On x86_64,\n however, windows uses the `C` calling convention, so `C` would be used. This\n means that in our previous example, we could have used `extern \"system\" { ... }`\n-to define a block for all windows systems, not just x86 ones.\n+to define a block for all windows systems, not only x86 ones.\n \n # Interoperability with foreign code\n "}, {"sha": "be905599c64415684110f730bd1e4e3ec0149646", "filename": "src/doc/book/functions.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ffunctions.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -124,7 +124,7 @@ statement `x + 1;` doesn\u2019t return a value. There are two kinds of statements i\n Rust: \u2018declaration statements\u2019 and \u2018expression statements\u2019. Everything else is\n an expression. Let\u2019s talk about declaration statements first.\n \n-In some languages, variable bindings can be written as expressions, not just\n+In some languages, variable bindings can be written as expressions, not\n statements. Like Ruby:\n \n ```ruby\n@@ -145,7 +145,7 @@ Note that assigning to an already-bound variable (e.g. `y = 5`) is still an\n expression, although its value is not particularly useful. Unlike other\n languages where an assignment evaluates to the assigned value (e.g. `5` in the\n previous example), in Rust the value of an assignment is an empty tuple `()`\n-because the assigned value can have [just one owner](ownership.html), and any\n+because the assigned value can have [only one owner](ownership.html), and any\n other returned value would be too surprising:\n \n ```rust"}, {"sha": "9ab601419cd7cc1e08ce130232aed9f923aff89b", "filename": "src/doc/book/generics.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgenerics.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -37,7 +37,7 @@ let x: Option<f64> = Some(5);\n // found `core::option::Option<_>` (expected f64 but found integral variable)\n ```\n \n-That doesn\u2019t mean we can\u2019t make `Option<T>`s that hold an `f64`! They just have\n+That doesn\u2019t mean we can\u2019t make `Option<T>`s that hold an `f64`! They have\n to match up:\n \n ```rust\n@@ -118,7 +118,7 @@ let float_origin = Point { x: 0.0, y: 0.0 };\n Similar to functions, the `<T>` is where we declare the generic parameters,\n and we then use `x: T` in the type declaration, too.\n \n-When you want to add an implementation for the generic `struct`, you just\n+When you want to add an implementation for the generic `struct`, you\n declare the type parameter after the `impl`:\n \n ```rust"}, {"sha": "094b88fba86a9933cee405a8ca8f742e4122dc57", "filename": "src/doc/book/getting-started.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fgetting-started.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fgetting-started.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fgetting-started.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -140,7 +140,7 @@ If you're on Windows, please download the appropriate [installer][install-page].\n \n ## Uninstalling\n \n-Uninstalling Rust is as easy as installing it. On Linux or Mac, just run\n+Uninstalling Rust is as easy as installing it. On Linux or Mac, run\n the uninstall script:\n \n ```bash\n@@ -192,7 +192,7 @@ that tradition.\n \n The nice thing about starting with such a simple program is that you can\n quickly verify that your compiler is installed, and that it's working properly.\n-Printing information to the screen is also just a pretty common thing to do, so\n+Printing information to the screen is also a pretty common thing to do, so\n practicing it early on is good.\n \n > Note: This book assumes basic familiarity with the command line. Rust itself\n@@ -248,7 +248,7 @@ $ ./main\n Hello, world!\n ```\n \n-In Windows, just replace `main` with `main.exe`. Regardless of your operating\n+In Windows, replace `main` with `main.exe`. Regardless of your operating\n system, you should see the string `Hello, world!` print to the terminal. If you\n did, then congratulations! You've officially written a Rust program. That makes\n you a Rust programmer! Welcome.\n@@ -289,7 +289,7 @@ that it\u2019s indented with four spaces, not tabs.\n The second important part is the `println!()` line. This is calling a Rust\n *[macro]*, which is how metaprogramming is done in Rust. If it were calling a\n function instead, it would look like this: `println()` (without the !). We'll\n-discuss Rust macros in more detail later, but for now you just need to\n+discuss Rust macros in more detail later, but for now you only need to\n know that when you see a `!` that means that you\u2019re calling a macro instead of\n a normal function.\n \n@@ -456,7 +456,7 @@ authors = [ \"Your name <you@example.com>\" ]\n \n The first line, `[package]`, indicates that the following statements are\n configuring a package. As we add more information to this file, we\u2019ll add other\n-sections, but for now, we just have the package configuration.\n+sections, but for now, we only have the package configuration.\n \n The other three lines set the three bits of configuration that Cargo needs to\n know to compile your program: its name, what version it is, and who wrote it.\n@@ -507,7 +507,7 @@ rebuilds your project if they\u2019ve changed since the last time you built it.\n With simple projects, Cargo doesn't bring a whole lot over just using `rustc`,\n but it will become useful in future. With complex projects composed of multiple\n crates, it\u2019s much easier to let Cargo coordinate the build. With Cargo, you can\n-just run `cargo build`, and it should work the right way.\n+run `cargo build`, and it should work the right way.\n \n ## Building for Release\n "}, {"sha": "2e315333565c743a375e48eb59bdae8737b22c59", "filename": "src/doc/book/guessing-game.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fguessing-game.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -68,7 +68,7 @@ Hello, world!\n ```\n \n Great! The `run` command comes in handy when you need to rapidly iterate on a\n-project. Our game is just such a project, we need to quickly test each\n+project. Our game is such a project, we need to quickly test each\n iteration before moving on to the next one.\n \n # Processing a Guess\n@@ -294,12 +294,12 @@ src/main.rs:10     io::stdin().read_line(&mut guess);\n Rust warns us that we haven\u2019t used the `Result` value. This warning comes from\n a special annotation that `io::Result` has. Rust is trying to tell you that\n you haven\u2019t handled a possible error. The right way to suppress the error is\n-to actually write error handling. Luckily, if we just want to crash if there\u2019s\n+to actually write error handling. Luckily, if we want to crash if there\u2019s\n a problem, we can use these two little methods. If we can recover from the\n error somehow, we\u2019d do something else, but we\u2019ll save that for a future\n project.\n \n-There\u2019s just one line of this first example left:\n+There\u2019s only one line of this first example left:\n \n ```rust,ignore\n     println!(\"You guessed: {}\", guess);\n@@ -408,7 +408,7 @@ $ cargo build\n That\u2019s right, no output! Cargo knows that our project has been built, and that\n all of its dependencies are built, and so there\u2019s no reason to do all that\n stuff. With nothing to do, it simply exits. If we open up `src/main.rs` again,\n-make a trivial change, and then save it again, we\u2019ll just see one line:\n+make a trivial change, and then save it again, we\u2019ll only see one line:\n \n ```bash\n $ cargo build\n@@ -504,7 +504,7 @@ so we need `1` and `101` to get a number ranging from one to a hundred.\n \n [concurrency]: concurrency.html\n \n-The second line just prints out the secret number. This is useful while\n+The second line prints out the secret number. This is useful while\n we\u2019re developing our program, so we can easily test it out. But we\u2019ll be\n deleting it for the final version. It\u2019s not much of a game if it prints out\n the answer when you start it up!\n@@ -705,7 +705,7 @@ input in it. The `trim()` method on `String`s will eliminate any white space at\n the beginning and end of our string. This is important, as we had to press the\n \u2018return\u2019 key to satisfy `read_line()`. This means that if we type `5` and hit\n return, `guess` looks like this: `5\\n`. The `\\n` represents \u2018newline\u2019, the\n-enter key. `trim()` gets rid of this, leaving our string with just the `5`. The\n+enter key. `trim()` gets rid of this, leaving our string with only the `5`. The\n [`parse()` method on strings][parse] parses a string into some kind of number.\n Since it can parse a variety of numbers, we need to give Rust a hint as to the\n exact type of number we want. Hence, `let guess: u32`. The colon (`:`) after\n@@ -853,8 +853,8 @@ fn main() {\n \n By adding the `break` line after the `You win!`, we\u2019ll exit the loop when we\n win. Exiting the loop also means exiting the program, since it\u2019s the last\n-thing in `main()`. We have just one more tweak to make: when someone inputs a\n-non-number, we don\u2019t want to quit, we just want to ignore it. We can do that\n+thing in `main()`. We have only one more tweak to make: when someone inputs a\n+non-number, we don\u2019t want to quit, we want to ignore it. We can do that\n like this:\n \n ```rust,ignore\n@@ -908,12 +908,12 @@ let guess: u32 = match guess.trim().parse() {\n ```\n \n This is how you generally move from \u2018crash on error\u2019 to \u2018actually handle the\n-returned by `parse()` is an `enum` just like `Ordering`, but in this case, each\n+returned by `parse()` is an `enum`  like `Ordering`, but in this case, each\n variant has some data associated with it: `Ok` is a success, and `Err` is a\n failure. Each contains more information: the successfully parsed integer, or an\n error type. In this case, we `match` on `Ok(num)`, which sets the inner value\n-of the `Ok` to the name `num`, and then we just return it on the right-hand\n-side. In the `Err` case, we don\u2019t care what kind of error it is, so we just\n+of the `Ok` to the name `num`, and then we  return it on the right-hand\n+side. In the `Err` case, we don\u2019t care what kind of error it is, so we\n use `_` instead of a name. This ignores the error, and `continue` causes us\n to go to the next iteration of the `loop`.\n "}, {"sha": "5622326d20c31913323f7001e940afaa155c080d", "filename": "src/doc/book/iterators.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fiterators.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -37,7 +37,7 @@ which gives us a reference to the next value of the iterator. `next` returns an\n `None`, we `break` out of the loop.\n \n This code sample is basically the same as our `for` loop version. The `for`\n-loop is just a handy way to write this `loop`/`match`/`break` construct.\n+loop is a handy way to write this `loop`/`match`/`break` construct.\n \n `for` loops aren't the only thing that uses iterators, however. Writing your\n own iterator involves implementing the `Iterator` trait. While doing that is\n@@ -94,8 +94,8 @@ Now we're explicitly dereferencing `num`. Why does `&nums` give us\n references?  Firstly, because we explicitly asked it to with\n `&`. Secondly, if it gave us the data itself, we would have to be its\n owner, which would involve making a copy of the data and giving us the\n-copy. With references, we're just borrowing a reference to the data,\n-and so it's just passing a reference, without needing to do the move.\n+copy. With references, we're only borrowing a reference to the data,\n+and so it's only passing a reference, without needing to do the move.\n \n So, now that we've established that ranges are often not what you want, let's\n talk about what you do want instead.\n@@ -278,7 +278,7 @@ doesn't print any numbers:\n ```\n \n If you are trying to execute a closure on an iterator for its side effects,\n-just use `for` instead.\n+use `for` instead.\n \n There are tons of interesting iterator adaptors. `take(n)` will return an\n iterator over the next `n` elements of the original iterator. Let's try it out"}, {"sha": "8bf90b4ea4d8a882a36ef34b8fe603cb79f1f246", "filename": "src/doc/book/lifetimes.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flifetimes.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -84,7 +84,7 @@ We previously talked a little about [function syntax][functions], but we didn\u2019\n discuss the `<>`s after a function\u2019s name. A function can have \u2018generic\n parameters\u2019 between the `<>`s, of which lifetimes are one kind. We\u2019ll discuss\n other kinds of generics [later in the book][generics], but for now, let\u2019s\n-just focus on the lifetimes aspect.\n+focus on the lifetimes aspect.\n \n [functions]: functions.html\n [generics]: generics.html\n@@ -109,7 +109,7 @@ If we wanted a `&mut` reference, we\u2019d do this:\n ...(x: &'a mut i32)\n ```\n \n-If you compare `&mut i32` to `&'a mut i32`, they\u2019re the same, it\u2019s just that\n+If you compare `&mut i32` to `&'a mut i32`, they\u2019re the same, it\u2019s that\n the lifetime `'a` has snuck in between the `&` and the `mut i32`. We read `&mut\n i32` as \u2018a mutable reference to an `i32`\u2019 and `&'a mut i32` as \u2018a mutable\n reference to an `i32` with the lifetime `'a`\u2019.\n@@ -175,7 +175,7 @@ fn main() {\n ```\n \n As you can see, we need to declare a lifetime for `Foo` in the `impl` line. We repeat\n-`'a` twice, just like on functions: `impl<'a>` defines a lifetime `'a`, and `Foo<'a>`\n+`'a` twice, like on functions: `impl<'a>` defines a lifetime `'a`, and `Foo<'a>`\n uses it.\n \n ## Multiple lifetimes"}, {"sha": "b2532663339ff26aa1d7d6103b64359ddf25270e", "filename": "src/doc/book/method-syntax.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fmethod-syntax.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -49,11 +49,11 @@ and inside it, define a method, `area`.\n Methods take a special first parameter, of which there are three variants:\n `self`, `&self`, and `&mut self`. You can think of this first parameter as\n being the `foo` in `foo.bar()`. The three variants correspond to the three\n-kinds of things `foo` could be: `self` if it\u2019s just a value on the stack,\n+kinds of things `foo` could be: `self` if it\u2019s a value on the stack,\n `&self` if it\u2019s a reference, and `&mut self` if it\u2019s a mutable reference.\n-Because we took the `&self` parameter to `area`, we can use it just like any\n+Because we took the `&self` parameter to `area`, we can use it like any\n other parameter. Because we know it\u2019s a `Circle`, we can access the `radius`\n-just like we would with any other `struct`.\n+like we would with any other `struct`.\n \n We should default to using `&self`, as you should prefer borrowing over taking\n ownership, as well as taking immutable references over mutable ones. Here\u2019s an\n@@ -151,7 +151,7 @@ fn grow(&self, increment: f64) -> Circle {\n # Circle } }\n ```\n \n-We just say we\u2019re returning a `Circle`. With this method, we can grow a new\n+We say we\u2019re returning a `Circle`. With this method, we can grow a new\n `Circle` to any arbitrary size.\n \n # Associated functions"}, {"sha": "b3be71038a992f66605f461c14f5888b708a6c5d", "filename": "src/doc/book/nightly-rust.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fnightly-rust.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fnightly-rust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fnightly-rust.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -39,7 +39,7 @@ script:\n $ sudo /usr/local/lib/rustlib/uninstall.sh\n ```\n \n-If you used the Windows installer, just re-run the `.msi` and it will give you\n+If you used the Windows installer, re-run the `.msi` and it will give you\n an uninstall option.\n \n Some people, and somewhat rightfully so, get very upset when we tell you to\n@@ -66,7 +66,7 @@ Finally, a comment about Windows. Rust considers Windows to be a first-class\n platform upon release, but if we're honest, the Windows experience isn't as\n integrated as the Linux/OS X experience is. We're working on it! If anything\n does not work, it is a bug. Please let us know if that happens. Each and every\n-commit is tested against Windows just like any other platform.\n+commit is tested against Windows like any other platform.\n \n If you've got Rust installed, you can open up a shell, and type this:\n "}, {"sha": "0b7eec72c9187001eec1910df16f70bbc14e21f5", "filename": "src/doc/book/no-stdlib.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fno-stdlib.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -92,7 +92,7 @@ instead.\n The core library has very few dependencies and is much more portable than the\n standard library itself. Additionally, the core library has most of the\n necessary functionality for writing idiomatic and effective Rust code. When\n-using `#![no_std]`, Rust will automatically inject the `core` crate, just like\n+using `#![no_std]`, Rust will automatically inject the `core` crate, like\n we do for `std` when we\u2019re using it.\n \n As an example, here is a program that will calculate the dot product of two"}, {"sha": "fcce831c2d09d23d3ebe8dc0c270bb1f276b5700", "filename": "src/doc/book/operators-and-overloading.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Foperators-and-overloading.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Foperators-and-overloading.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Foperators-and-overloading.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -120,7 +120,7 @@ fn main() {\n }\n ```\n \n-For `HasArea` and `Square`, we just declare a type parameter `T` and replace\n+For `HasArea` and `Square`, we declare a type parameter `T` and replace\n `f64` with it. The `impl` needs more involved modifications:\n \n ```ignore"}, {"sha": "8e9e7246e56f0b3daa935be46250aec061c449bf", "filename": "src/doc/book/patterns.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fpatterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fpatterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fpatterns.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -118,7 +118,7 @@ match origin {\n \n This prints `x is 0`.\n \n-You can do this kind of match on any member, not just the first:\n+You can do this kind of match on any member, not only the first:\n \n ```rust\n struct Point {\n@@ -155,7 +155,7 @@ match some_value {\n ```\n \n In the first arm, we bind the value inside the `Ok` variant to `value`. But\n-in the `Err` arm, we use `_` to disregard the specific error, and just print\n+in the `Err` arm, we use `_` to disregard the specific error, and print\n a general error message.\n \n `_` is valid in any pattern that creates a binding. This can be useful to\n@@ -326,7 +326,7 @@ match x {\n ```\n \n This prints `no`, because the `if` applies to the whole of `4 | 5`, and not to\n-just the `5`. In other words, the precedence of `if` behaves like this:\n+only the `5`. In other words, the precedence of `if` behaves like this:\n \n ```text\n (4 | 5) if y => ..."}, {"sha": "cfd5372b90f91f92f19a60c84e5c972d2e349363", "filename": "src/doc/book/primitive-types.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fprimitive-types.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -160,7 +160,7 @@ documentation][array].\n \n A \u2018slice\u2019 is a reference to (or \u201cview\u201d into) another data structure. They are\n useful for allowing safe, efficient access to a portion of an array without\n-copying. For example, you might want to reference just one line of a file read\n+copying. For example, you might want to reference only one line of a file read\n into memory. By nature, a slice is not created directly, but from an existing\n variable binding. Slices have a defined length, can be mutable or immutable.\n \n@@ -176,7 +176,7 @@ length of the slice:\n ```rust\n let a = [0, 1, 2, 3, 4];\n let complete = &a[..]; // A slice containing all of the elements in a\n-let middle = &a[1..4]; // A slice of a: just the elements 1, 2, and 3\n+let middle = &a[1..4]; // A slice of a: only the elements 1, 2, and 3\n ```\n \n Slices have type `&[T]`. We\u2019ll talk about that `T` when we cover\n@@ -220,11 +220,11 @@ with the type annotated:\n let x: (i32, &str) = (1, \"hello\");\n ```\n \n-As you can see, the type of a tuple looks just like the tuple, but with each\n+As you can see, the type of a tuple looks like the tuple, but with each\n position having a type name rather than the value. Careful readers will also\n note that tuples are heterogeneous: we have an `i32` and a `&str` in this tuple.\n In systems programming languages, strings are a bit more complex than in other\n-languages. For now, just read `&str` as a *string slice*, and we\u2019ll learn more\n+languages. For now, read `&str` as a *string slice*, and we\u2019ll learn more\n soon.\n \n You can assign one tuple into another, if they have the same contained types\n@@ -249,7 +249,7 @@ println!(\"x is {}\", x);\n ```\n \n Remember [before][let] when I said the left-hand side of a `let` statement was more\n-powerful than just assigning a binding? Here we are. We can put a pattern on\n+powerful than assigning a binding? Here we are. We can put a pattern on\n the left-hand side of the `let`, and if it matches up to the right-hand side,\n we can assign multiple bindings at once. In this case, `let` \u201cdestructures\u201d\n or \u201cbreaks up\u201d the tuple, and assigns the bits to three bindings."}, {"sha": "e7faf174600a9381b040c6c03d9deba9476f7774", "filename": "src/doc/book/references-and-borrowing.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -84,7 +84,7 @@ it borrows ownership. A binding that borrows something does not deallocate the\n resource when it goes out of scope. This means that after the call to `foo()`,\n we can use our original bindings again.\n \n-References are immutable, just like bindings. This means that inside of `foo()`,\n+References are immutable, like bindings. This means that inside of `foo()`,\n the vectors can\u2019t be changed at all:\n \n ```rust,ignore\n@@ -129,7 +129,7 @@ You'll also notice we added an asterisk (`*`) in front of `y`, making it `*y`,\n this is because `y` is a `&mut` reference. You'll also need to use them for\n accessing the contents of a reference as well.\n \n-Otherwise, `&mut` references are just like references. There _is_ a large\n+Otherwise, `&mut` references are like references. There _is_ a large\n difference between the two, and how they interact, though. You can tell\n something is fishy in the above example, because we need that extra scope, with\n the `{` and `}`. If we remove them, we get an error:"}, {"sha": "751619d544a4af57746c31b0acf734bd6dab6adf", "filename": "src/doc/book/strings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fstrings.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -44,7 +44,7 @@ let s = \"foo\\\n assert_eq!(\"foobar\", s);\n ```\n \n-Rust has more than just `&str`s though. A `String`, is a heap-allocated string.\n+Rust has more than only `&str`s though. A `String`, is a heap-allocated string.\n This string is growable, and is also guaranteed to be UTF-8. `String`s are\n commonly created by converting from a string slice using the `to_string`\n method."}, {"sha": "b2fddf336273fe0d1f3d663e7bd09886579e41fb", "filename": "src/doc/book/structs.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fstructs.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fstructs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fstructs.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -202,7 +202,7 @@ println!(\"length is {} inches\", integer_length);\n ```\n \n As you can see here, you can extract the inner integer type through a\n-destructuring `let`, just as with regular tuples. In this case, the\n+destructuring `let`, as with regular tuples. In this case, the\n `let Inches(integer_length)` assigns `10` to `integer_length`.\n \n # Unit-like structs\n@@ -223,7 +223,7 @@ This is rarely useful on its own (although sometimes it can serve as a\n marker type), but in combination with other features, it can become\n useful. For instance, a library may ask you to create a structure that\n implements a certain [trait][trait] to handle events. If you don\u2019t have\n-any data you need to store in the structure, you can just create a\n+any data you need to store in the structure, you can create a\n unit-like `struct`.\n \n [trait]: traits.html"}, {"sha": "005184e90a7e96a8e86205d38ffeb132b860420d", "filename": "src/doc/book/testing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftesting.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -365,7 +365,7 @@ test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured\n It works!\n \n The current convention is to use the `tests` module to hold your \"unit-style\"\n-tests. Anything that just tests one small bit of functionality makes sense to\n+tests. Anything that tests one small bit of functionality makes sense to\n go here. But what about \"integration-style\" tests instead? For that, we have\n the `tests` directory.\n "}, {"sha": "3be4096e971c28b6bb7f13ac4533e04fbb98b883", "filename": "src/doc/book/the-stack-and-the-heap.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fthe-stack-and-the-heap.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -44,7 +44,7 @@ values \u2018go on the stack\u2019. What does that mean?\n Well, when a function gets called, some memory gets allocated for all of its\n local variables and some other information. This is called a \u2018stack frame\u2019, and\n for the purpose of this tutorial, we\u2019re going to ignore the extra information\n-and just consider the local variables we\u2019re allocating. So in this case, when\n+and only consider the local variables we\u2019re allocating. So in this case, when\n `main()` is run, we\u2019ll allocate a single 32-bit integer for our stack frame.\n This is automatically handled for you, as you can see; we didn\u2019t have to write\n any special Rust code or anything.\n@@ -177,7 +177,7 @@ And then `bold()` calls `italic()`:\n | 0       | x    | 42    |\n Whew! Our stack is growing tall.\n \n-After `italic()` is over, its frame is deallocated, leaving just `bold()` and\n+After `italic()` is over, its frame is deallocated, leaving only `bold()` and\n `main()`:\n \n | Address | Name | Value |\n@@ -187,7 +187,7 @@ After `italic()` is over, its frame is deallocated, leaving just `bold()` and\n | **1**   | **a**| **5** |\n | 0       | x    | 42    | \n \n-And then `bold()` ends, leaving just `main()`:\n+And then `bold()` ends, leaving only `main()`:\n \n | Address | Name | Value |\n |---------|------|-------|\n@@ -247,7 +247,7 @@ location we\u2019ve asked for.\n We haven\u2019t really talked too much about what it actually means to allocate and\n deallocate memory in these contexts. Getting into very deep detail is out of\n the scope of this tutorial, but what\u2019s important to point out here is that\n-the heap isn\u2019t just a stack that grows from the opposite end. We\u2019ll have an\n+the heap isn\u2019t a stack that grows from the opposite end. We\u2019ll have an\n example of this later in the book, but because the heap can be allocated and\n freed in any order, it can end up with \u2018holes\u2019. Here\u2019s a diagram of the memory\n layout of a program which has been running for a while now:\n@@ -332,13 +332,13 @@ What about when we call `foo()`, passing `y` as an argument?\n | 1       | y    | \u2192 0    |\n | 0       | x    | 5      |\n \n-Stack frames aren\u2019t just for local bindings, they\u2019re for arguments too. So in\n+Stack frames aren\u2019t only for local bindings, they\u2019re for arguments too. So in\n this case, we need to have both `i`, our argument, and `z`, our local variable\n binding. `i` is a copy of the argument, `y`. Since `y`\u2019s value is `0`, so is\n `i`\u2019s.\n \n This is one reason why borrowing a variable doesn\u2019t deallocate any memory: the\n-value of a reference is just a pointer to a memory location. If we got rid of\n+value of a reference is a pointer to a memory location. If we got rid of\n the underlying memory, things wouldn\u2019t work very well.\n \n # A complex example\n@@ -454,7 +454,7 @@ Next, `foo()` calls `bar()` with `x` and `z`:\n | 0                    | h    | 3                      |\n \n We end up allocating another value on the heap, and so we have to subtract one\n-from (2<sup>30</sup>) - 1. It\u2019s easier to just write that than `1,073,741,822`. In any\n+from (2<sup>30</sup>) - 1. It\u2019s easier to write that than `1,073,741,822`. In any\n case, we set up the variables as usual.\n \n At the end of `bar()`, it calls `baz()`:\n@@ -550,7 +550,7 @@ has two big impacts: runtime efficiency and semantic impact.\n \n ## Runtime Efficiency\n \n-Managing the memory for the stack is trivial: The machine just\n+Managing the memory for the stack is trivial: The machine\n increments or decrements a single value, the so-called \u201cstack pointer\u201d.\n Managing memory for the heap is non-trivial: heap-allocated memory is freed at\n arbitrary points, and each block of heap-allocated memory can be of arbitrary"}, {"sha": "1d63435ed5fe71d3d3da89cf7384341082cf3faf", "filename": "src/doc/book/trait-objects.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Ftrait-objects.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Ftrait-objects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftrait-objects.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -272,7 +272,7 @@ made more flexible.\n \n Suppose we\u2019ve got some values that implement `Foo`. The explicit form of\n construction and use of `Foo` trait objects might look a bit like (ignoring the\n-type mismatches: they\u2019re all just pointers anyway):\n+type mismatches: they\u2019re all pointers anyway):\n \n ```rust,ignore\n let a: String = \"foo\".to_string();"}, {"sha": "d40689190e7fef4ca038d359983bf11af33ab41c", "filename": "src/doc/book/traits.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftraits.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -44,8 +44,8 @@ impl HasArea for Circle {\n ```\n \n As you can see, the `trait` block looks very similar to the `impl` block,\n-but we don\u2019t define a body, just a type signature. When we `impl` a trait,\n-we use `impl Trait for Item`, rather than just `impl Item`.\n+but we don\u2019t define a body, only a type signature. When we `impl` a trait,\n+we use `impl Trait for Item`, rather than only `impl Item`.\n \n ## Trait bounds on generic functions\n "}, {"sha": "eb464986af3bed2569ee5c13c426162629451193", "filename": "src/doc/book/unsafe.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Funsafe.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -100,7 +100,7 @@ that you normally can not do. Just three. Here they are:\n \n That\u2019s it. It\u2019s important that `unsafe` does not, for example, \u2018turn off the\n borrow checker\u2019. Adding `unsafe` to some random Rust code doesn\u2019t change its\n-semantics, it won\u2019t just start accepting anything. But it will let you write\n+semantics, it won\u2019t start accepting anything. But it will let you write\n things that _do_ break some of the rules.\n \n You will also encounter the `unsafe` keyword when writing bindings to foreign"}, {"sha": "73b90355e4f1b0331a89e89f0c10bbdc632d619b", "filename": "src/doc/book/unsized-types.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Funsized-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Funsized-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Funsized-types.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -11,7 +11,7 @@ Rust understands a few of these types, but they have some restrictions. There\n are three:\n \n 1. We can only manipulate an instance of an unsized type via a pointer. An\n-   `&[T]` works just fine, but a `[T]` does not.\n+   `&[T]` works fine, but a `[T]` does not.\n 2. Variables and arguments cannot have dynamically sized types.\n 3. Only the last field in a `struct` may have a dynamically sized type; the\n    other fields must not. Enum variants must not have dynamically sized types as"}, {"sha": "29b59937a63fa6b4bf3d93dc230abe160102c662", "filename": "src/doc/book/variable-bindings.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/6ba952020fbc91bad64be1ea0650bfba52e6aab4/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fvariable-bindings.md?ref=6ba952020fbc91bad64be1ea0650bfba52e6aab4", "patch": "@@ -2,7 +2,7 @@\n \n Virtually every non-'Hello World\u2019 Rust program uses *variable bindings*. They\n bind some value to a name, so it can be used later. `let` is\n-used to introduce a binding, just like this:\n+used to introduce a binding, like this:\n \n ```rust\n fn main() {\n@@ -18,7 +18,7 @@ function, rather than leaving it off. Otherwise, you\u2019ll get an error.\n \n In many languages, a variable binding would be called a *variable*, but Rust\u2019s\n variable bindings have a few tricks up their sleeves. For example the\n-left-hand side of a `let` expression is a \u2018[pattern][pattern]\u2019, not just a\n+left-hand side of a `let` expression is a \u2018[pattern][pattern]\u2019, not a\n variable name. This means we can do things like:\n \n ```rust\n@@ -27,7 +27,7 @@ let (x, y) = (1, 2);\n \n After this expression is evaluated, `x` will be one, and `y` will be two.\n Patterns are really powerful, and have [their own section][pattern] in the\n-book. We don\u2019t need those features for now, so we\u2019ll just keep this in the back\n+book. We don\u2019t need those features for now, so we\u2019ll keep this in the back\n of our minds as we go forward.\n \n [pattern]: patterns.html\n@@ -169,10 +169,10 @@ in the middle of a string.\" We add a comma, and then `x`, to indicate that we\n want `x` to be the value we\u2019re interpolating. The comma is used to separate\n arguments we pass to functions and macros, if you\u2019re passing more than one.\n \n-When you just use the curly braces, Rust will attempt to display the value in a\n+When you use the curly braces, Rust will attempt to display the value in a\n meaningful way by checking out its type. If you want to specify the format in a\n more detailed manner, there are a [wide number of options available][format].\n-For now, we'll just stick to the default: integers aren't very complicated to\n+For now, we'll stick to the default: integers aren't very complicated to\n print.\n \n [format]: ../std/fmt/index.html"}]}