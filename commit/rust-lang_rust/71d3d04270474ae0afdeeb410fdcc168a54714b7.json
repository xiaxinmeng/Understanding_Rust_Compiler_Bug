{"sha": "71d3d04270474ae0afdeeb410fdcc168a54714b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxZDNkMDQyNzA0NzRhZTBhZmRlZWI0MTBmZGNjMTY4YTU0NzE0Yjc=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-23T02:52:02Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-23T03:37:34Z"}, "message": "factor out a `Session` object", "tree": {"sha": "3fa5b35afdbddf86bd68a61c43987ab0c24adc74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fa5b35afdbddf86bd68a61c43987ab0c24adc74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71d3d04270474ae0afdeeb410fdcc168a54714b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71d3d04270474ae0afdeeb410fdcc168a54714b7", "html_url": "https://github.com/rust-lang/rust/commit/71d3d04270474ae0afdeeb410fdcc168a54714b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71d3d04270474ae0afdeeb410fdcc168a54714b7/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4153e66e422fde262bac3d36b82e79af69d01f2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4153e66e422fde262bac3d36b82e79af69d01f2d", "html_url": "https://github.com/rust-lang/rust/commit/4153e66e422fde262bac3d36b82e79af69d01f2d"}], "stats": {"total": 659, "additions": 336, "deletions": 323}, "files": [{"sha": "70dec3dcd2fae110864d81fec54254f7c8459e03", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71d3d04270474ae0afdeeb410fdcc168a54714b7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/71d3d04270474ae0afdeeb410fdcc168a54714b7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=71d3d04270474ae0afdeeb410fdcc168a54714b7", "patch": "@@ -533,7 +533,7 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"0.8.3\"\n+version = \"0.9.0\"\n dependencies = [\n  \"assert_cli 0.6.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargo_metadata 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "5023e8bec0da46b7a42eadec52f88a6fadd85b2c", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71d3d04270474ae0afdeeb410fdcc168a54714b7/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/71d3d04270474ae0afdeeb410fdcc168a54714b7/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=71d3d04270474ae0afdeeb410fdcc168a54714b7", "patch": "@@ -1,7 +1,7 @@\n [package]\n \n name = \"rustfmt-nightly\"\n-version = \"0.8.3\"\n+version = \"0.9.0\"\n authors = [\"Nicholas Cameron <ncameron@mozilla.com>\", \"The Rustfmt developers\"]\n description = \"Tool to find and fix Rust formatting issues\"\n repository = \"https://github.com/rust-lang-nursery/rustfmt\""}, {"sha": "5b6398f028ef70630b146f5e308339e859c8c650", "filename": "src/bin/main.rs", "status": "modified", "additions": 66, "deletions": 97, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/71d3d04270474ae0afdeeb410fdcc168a54714b7/src%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d3d04270474ae0afdeeb410fdcc168a54714b7/src%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmain.rs?ref=71d3d04270474ae0afdeeb410fdcc168a54714b7", "patch": "@@ -28,26 +28,16 @@ use failure::err_msg;\n use getopts::{Matches, Options};\n \n use rustfmt::{\n-    checkstyle_footer, checkstyle_header, format_input, load_config, CliOptions, Color, Config,\n-    EmitMode, ErrorKind, FileLines, FileName, Input, Summary, Verbosity,\n+    load_config, CliOptions, Color, Config, EmitMode, ErrorKind, FileLines, FileName, Input,\n+    Session, Verbosity,\n };\n \n fn main() {\n     env_logger::init();\n     let opts = make_opts();\n \n     let exit_code = match execute(&opts) {\n-        Ok((exit_mode, summary)) => {\n-            if summary.has_operational_errors()\n-                || summary.has_parsing_errors()\n-                || ((summary.has_diff || summary.has_check_errors())\n-                    && exit_mode == ExitCodeMode::Check)\n-            {\n-                1\n-            } else {\n-                0\n-            }\n-        }\n+        Ok(code) => code,\n         Err(e) => {\n             eprintln!(\"{}\", e.to_string());\n             1\n@@ -174,26 +164,27 @@ fn is_nightly() -> bool {\n         .unwrap_or(false)\n }\n \n-fn execute(opts: &Options) -> Result<(ExitCodeMode, Summary), failure::Error> {\n+// Returned i32 is an exit code\n+fn execute(opts: &Options) -> Result<i32, failure::Error> {\n     let matches = opts.parse(env::args().skip(1))?;\n     let options = GetOptsOptions::from_matches(&matches)?;\n \n     match determine_operation(&matches)? {\n         Operation::Help(HelpOp::None) => {\n             print_usage_to_stdout(opts, \"\");\n-            Ok((ExitCodeMode::Normal, Summary::default()))\n+            return Ok(1);\n         }\n         Operation::Help(HelpOp::Config) => {\n             Config::print_docs(&mut stdout(), options.unstable_features);\n-            Ok((ExitCodeMode::Normal, Summary::default()))\n+            return Ok(1);\n         }\n         Operation::Help(HelpOp::FileLines) => {\n             print_help_file_lines();\n-            Ok((ExitCodeMode::Normal, Summary::default()))\n+            return Ok(1);\n         }\n         Operation::Version => {\n             print_version();\n-            Ok((ExitCodeMode::Normal, Summary::default()))\n+            return Ok(1);\n         }\n         Operation::ConfigOutputDefault { path } => {\n             let toml = Config::default().all_options().to_toml().map_err(err_msg)?;\n@@ -203,47 +194,51 @@ fn execute(opts: &Options) -> Result<(ExitCodeMode, Summary), failure::Error> {\n             } else {\n                 io::stdout().write_all(toml.as_bytes())?;\n             }\n-            Ok((ExitCodeMode::Normal, Summary::default()))\n-        }\n-        Operation::Stdin { input } => {\n-            // try to read config from local directory\n-            let (mut config, _) = load_config(Some(Path::new(\".\")), Some(options.clone()))?;\n-\n-            // emit mode is always Stdout for Stdin.\n-            config.set().emit_mode(EmitMode::Stdout);\n-            config.set().verbose(Verbosity::Quiet);\n-\n-            // parse file_lines\n-            config.set().file_lines(options.file_lines);\n-            for f in config.file_lines().files() {\n-                match *f {\n-                    FileName::Stdin => {}\n-                    _ => eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f),\n-                }\n-            }\n-\n-            let mut error_summary = Summary::default();\n-            emit_pre_matter(&config);\n-            match format_and_emit_report(Input::Text(input), &config) {\n-                Ok(summary) => error_summary.add(summary),\n-                Err(_) => error_summary.add_operational_error(),\n-            }\n-            emit_post_matter(&config);\n-\n-            Ok((ExitCodeMode::Normal, error_summary))\n+            return Ok(1);\n         }\n+        Operation::Stdin { input } => format_string(input, options),\n         Operation::Format {\n             files,\n             minimal_config_path,\n         } => format(files, minimal_config_path, options),\n     }\n }\n \n+fn format_string(input: String, options: GetOptsOptions) -> Result<i32, failure::Error> {\n+    // try to read config from local directory\n+    let (mut config, _) = load_config(Some(Path::new(\".\")), Some(options.clone()))?;\n+\n+    // emit mode is always Stdout for Stdin.\n+    config.set().emit_mode(EmitMode::Stdout);\n+    config.set().verbose(Verbosity::Quiet);\n+\n+    // parse file_lines\n+    config.set().file_lines(options.file_lines);\n+    for f in config.file_lines().files() {\n+        match *f {\n+            FileName::Stdin => {}\n+            _ => eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f),\n+        }\n+    }\n+\n+    let out = &mut stdout();\n+    let mut session = Session::new(config, Some(out));\n+    format_and_emit_report(&mut session, Input::Text(input));\n+\n+    let exit_code =\n+        if session.summary.has_operational_errors() || session.summary.has_parsing_errors() {\n+            1\n+        } else {\n+            0\n+        };\n+    Ok(exit_code)\n+}\n+\n fn format(\n     files: Vec<PathBuf>,\n     minimal_config_path: Option<String>,\n     options: GetOptsOptions,\n-) -> Result<(ExitCodeMode, Summary), failure::Error> {\n+) -> Result<i32, failure::Error> {\n     options.verify_file_lines(&files);\n     let (config, config_path) = load_config(None, Some(options.clone()))?;\n \n@@ -253,19 +248,19 @@ fn format(\n         }\n     }\n \n-    emit_pre_matter(&config);\n-    let mut error_summary = Summary::default();\n+    let out = &mut stdout();\n+    let mut session = Session::new(config, Some(out));\n \n     for file in files {\n         if !file.exists() {\n             eprintln!(\"Error: file `{}` does not exist\", file.to_str().unwrap());\n-            error_summary.add_operational_error();\n+            session.summary.add_operational_error();\n         } else if file.is_dir() {\n             eprintln!(\"Error: `{}` is a directory\", file.to_str().unwrap());\n-            error_summary.add_operational_error();\n+            session.summary.add_operational_error();\n         } else {\n             // Check the file directory if the config-path could not be read or not provided\n-            let local_config = if config_path.is_none() {\n+            if config_path.is_none() {\n                 let (local_config, config_path) =\n                     load_config(Some(file.parent().unwrap()), Some(options.clone()))?;\n                 if local_config.verbose() == Verbosity::Verbose {\n@@ -277,47 +272,42 @@ fn format(\n                         );\n                     }\n                 }\n-                local_config\n+\n+                session.override_config(local_config, |sess| {\n+                    format_and_emit_report(sess, Input::File(file))\n+                });\n             } else {\n-                config.clone()\n-            };\n-\n-            match format_and_emit_report(Input::File(file), &local_config) {\n-                Ok(summary) => error_summary.add(summary),\n-                Err(_) => {\n-                    error_summary.add_operational_error();\n-                    break;\n-                }\n+                format_and_emit_report(&mut session, Input::File(file));\n             }\n         }\n     }\n-    emit_post_matter(&config);\n \n     // If we were given a path via dump-minimal-config, output any options\n     // that were used during formatting as TOML.\n     if let Some(path) = minimal_config_path {\n         let mut file = File::create(path)?;\n-        let toml = config.used_options().to_toml().map_err(err_msg)?;\n+        let toml = session.config.used_options().to_toml().map_err(err_msg)?;\n         file.write_all(toml.as_bytes())?;\n     }\n \n-    let exit_mode = if options.check {\n-        ExitCodeMode::Check\n+    let exit_code = if session.summary.has_operational_errors()\n+        || session.summary.has_parsing_errors()\n+        || ((session.summary.has_diff || session.summary.has_check_errors()) && options.check)\n+    {\n+        1\n     } else {\n-        ExitCodeMode::Normal\n+        0\n     };\n-    Ok((exit_mode, error_summary))\n+    Ok(exit_code)\n }\n \n-fn format_and_emit_report(input: Input, config: &Config) -> Result<Summary, failure::Error> {\n-    let out = &mut stdout();\n-\n-    match format_input(input, config, Some(out)) {\n-        Ok((summary, report)) => {\n+fn format_and_emit_report<T: Write>(session: &mut Session<T>, input: Input) {\n+    match session.format(input) {\n+        Ok(report) => {\n             if report.has_warnings() {\n                 match term::stderr() {\n                     Some(ref t)\n-                        if config.color().use_colored_tty()\n+                        if session.config.color().use_colored_tty()\n                             && t.supports_color()\n                             && t.supports_attr(term::Attr::Bold) =>\n                     {\n@@ -329,29 +319,14 @@ fn format_and_emit_report(input: Input, config: &Config) -> Result<Summary, fail\n                     _ => eprintln!(\"{}\", report),\n                 }\n             }\n-\n-            Ok(summary)\n         }\n-        Err((msg, mut summary)) => {\n+        Err(msg) => {\n             eprintln!(\"Error writing files: {}\", msg);\n-            summary.add_operational_error();\n-            Ok(summary)\n+            session.summary.add_operational_error();\n         }\n     }\n }\n \n-fn emit_pre_matter(config: &Config) {\n-    if config.emit_mode() == EmitMode::Checkstyle {\n-        println!(\"{}\", checkstyle_header());\n-    }\n-}\n-\n-fn emit_post_matter(config: &Config) {\n-    if config.emit_mode() == EmitMode::Checkstyle {\n-        println!(\"{}\", checkstyle_footer());\n-    }\n-}\n-\n fn print_usage_to_stdout(opts: &Options, reason: &str) {\n     let sep = if reason.is_empty() {\n         String::new()\n@@ -456,12 +431,6 @@ fn determine_operation(matches: &Matches) -> Result<Operation, ErrorKind> {\n     })\n }\n \n-#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n-enum ExitCodeMode {\n-    Normal,\n-    Check,\n-}\n-\n const STABLE_EMIT_MODES: [EmitMode; 3] = [EmitMode::Files, EmitMode::Stdout, EmitMode::Diff];\n \n /// Parsed command line options."}, {"sha": "53e673c5e7a2384168c9cafd93f623b8d584a536", "filename": "src/formatting.rs", "status": "modified", "additions": 120, "deletions": 158, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/71d3d04270474ae0afdeeb410fdcc168a54714b7/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d3d04270474ae0afdeeb410fdcc168a54714b7/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=71d3d04270474ae0afdeeb410fdcc168a54714b7", "patch": "@@ -15,9 +15,8 @@ use syntax::parse::{self, ParseSess};\n use comment::{CharClasses, FullCodeCharKind};\n use issues::BadIssueSeeker;\n use visitor::{FmtVisitor, SnippetProvider};\n-use {filemap, modules, ErrorKind, FormatReport, Input};\n+use {filemap, modules, ErrorKind, FormatReport, Input, Session};\n \n-use config::summary::Summary;\n use config::{Config, FileName, NewlineStyle, Verbosity};\n \n // A map of the files of a crate, with their new content\n@@ -365,143 +364,146 @@ enum ParseError<'sess> {\n     Panic,\n }\n \n-pub(crate) fn format_input_inner<T: Write>(\n-    input: Input,\n-    config: &Config,\n-    mut out: Option<&mut T>,\n-) -> Result<(Summary, FileMap, FormatReport), (ErrorKind, Summary)> {\n-    syntax_pos::hygiene::set_default_edition(config.edition().to_libsyntax_pos_edition());\n-    let mut summary = Summary::default();\n-    if config.disable_all_formatting() {\n-        // When the input is from stdin, echo back the input.\n-        if let Input::Text(ref buf) = input {\n-            if let Err(e) = io::stdout().write_all(buf.as_bytes()) {\n-                return Err((From::from(e), summary));\n+impl<'b, T: Write + 'b> Session<'b, T> {\n+    pub(crate) fn format_input_inner(\n+        &mut self,\n+        input: Input,\n+    ) -> Result<(FileMap, FormatReport), ErrorKind> {\n+        syntax_pos::hygiene::set_default_edition(self.config.edition().to_libsyntax_pos_edition());\n+\n+        if self.config.disable_all_formatting() {\n+            // When the input is from stdin, echo back the input.\n+            if let Input::Text(ref buf) = input {\n+                if let Err(e) = io::stdout().write_all(buf.as_bytes()) {\n+                    return Err(From::from(e));\n+                }\n             }\n+            return Ok((FileMap::new(), FormatReport::new()));\n         }\n-        return Ok((summary, FileMap::new(), FormatReport::new()));\n-    }\n-    let codemap = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+        let codemap = Rc::new(CodeMap::new(FilePathMapping::empty()));\n+\n+        let tty_handler = if self.config.hide_parse_errors() {\n+            let silent_emitter = Box::new(EmitterWriter::new(\n+                Box::new(Vec::new()),\n+                Some(codemap.clone()),\n+                false,\n+                false,\n+            ));\n+            Handler::with_emitter(true, false, silent_emitter)\n+        } else {\n+            let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n+            let color_cfg = if supports_color {\n+                ColorConfig::Auto\n+            } else {\n+                ColorConfig::Never\n+            };\n+            Handler::with_tty_emitter(color_cfg, true, false, Some(codemap.clone()))\n+        };\n+        let mut parse_session = ParseSess::with_span_handler(tty_handler, codemap.clone());\n+\n+        let main_file = match input {\n+            Input::File(ref file) => FileName::Real(file.clone()),\n+            Input::Text(..) => FileName::Stdin,\n+        };\n+\n+        let krate = match parse_input(input, &parse_session, &self.config) {\n+            Ok(krate) => krate,\n+            Err(err) => {\n+                match err {\n+                    ParseError::Error(mut diagnostic) => diagnostic.emit(),\n+                    ParseError::Panic => {\n+                        // Note that if you see this message and want more information,\n+                        // then go to `parse_input` and run the parse function without\n+                        // `catch_unwind` so rustfmt panics and you can get a backtrace.\n+                        should_emit_verbose(&main_file, &self.config, || {\n+                            println!(\"The Rust parser panicked\")\n+                        });\n+                    }\n+                    ParseError::Recovered => {}\n+                }\n+                self.summary.add_parsing_error();\n+                return Err(ErrorKind::ParseError);\n+            }\n+        };\n \n-    let tty_handler = if config.hide_parse_errors() {\n+        self.summary.mark_parse_time();\n+\n+        // Suppress error output after parsing.\n         let silent_emitter = Box::new(EmitterWriter::new(\n             Box::new(Vec::new()),\n             Some(codemap.clone()),\n             false,\n             false,\n         ));\n-        Handler::with_emitter(true, false, silent_emitter)\n-    } else {\n-        let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n-        let color_cfg = if supports_color {\n-            ColorConfig::Auto\n-        } else {\n-            ColorConfig::Never\n-        };\n-        Handler::with_tty_emitter(color_cfg, true, false, Some(codemap.clone()))\n-    };\n-    let mut parse_session = ParseSess::with_span_handler(tty_handler, codemap.clone());\n-\n-    let main_file = match input {\n-        Input::File(ref file) => FileName::Real(file.clone()),\n-        Input::Text(..) => FileName::Stdin,\n-    };\n-\n-    let krate = match parse_input(input, &parse_session, config) {\n-        Ok(krate) => krate,\n-        Err(err) => {\n-            match err {\n-                ParseError::Error(mut diagnostic) => diagnostic.emit(),\n-                ParseError::Panic => {\n-                    // Note that if you see this message and want more information,\n-                    // then go to `parse_input` and run the parse function without\n-                    // `catch_unwind` so rustfmt panics and you can get a backtrace.\n-                    should_emit_verbose(&main_file, config, || {\n-                        println!(\"The Rust parser panicked\")\n-                    });\n+        parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n+\n+        let report = FormatReport::new();\n+\n+        let config = &self.config;\n+        let out = &mut self.out;\n+        let format_result = format_ast(\n+            &krate,\n+            &mut parse_session,\n+            &main_file,\n+            config,\n+            report.clone(),\n+            |file_name, file, skipped_range, report| {\n+                // For some reason, the codemap does not include terminating\n+                // newlines so we must add one on for each file. This is sad.\n+                filemap::append_newline(file);\n+\n+                format_lines(file, file_name, skipped_range, config, report);\n+                replace_with_system_newlines(file, config);\n+\n+                if let Some(ref mut out) = out {\n+                    return filemap::write_file(file, file_name, out, config);\n                 }\n-                ParseError::Recovered => {}\n-            }\n-            summary.add_parsing_error();\n-            return Err((ErrorKind::ParseError, summary));\n-        }\n-    };\n+                Ok(false)\n+            },\n+        );\n+\n+        self.summary.mark_format_time();\n \n-    summary.mark_parse_time();\n-\n-    // Suppress error output after parsing.\n-    let silent_emitter = Box::new(EmitterWriter::new(\n-        Box::new(Vec::new()),\n-        Some(codemap.clone()),\n-        false,\n-        false,\n-    ));\n-    parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n-\n-    let report = FormatReport::new();\n-\n-    let format_result = format_ast(\n-        &krate,\n-        &mut parse_session,\n-        &main_file,\n-        config,\n-        report.clone(),\n-        |file_name, file, skipped_range, report| {\n-            // For some reason, the codemap does not include terminating\n-            // newlines so we must add one on for each file. This is sad.\n-            filemap::append_newline(file);\n-\n-            format_lines(file, file_name, skipped_range, config, report);\n-            replace_with_system_newlines(file, config);\n-\n-            if let Some(ref mut out) = out {\n-                return filemap::write_file(file, file_name, out, config);\n+        should_emit_verbose(&main_file, &self.config, || {\n+            fn duration_to_f32(d: Duration) -> f32 {\n+                d.as_secs() as f32 + d.subsec_nanos() as f32 / 1_000_000_000f32\n             }\n-            Ok(false)\n-        },\n-    );\n \n-    summary.mark_format_time();\n+            println!(\n+                \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n+                duration_to_f32(self.summary.get_parse_time().unwrap()),\n+                duration_to_f32(self.summary.get_format_time().unwrap()),\n+            )\n+        });\n \n-    should_emit_verbose(&main_file, config, || {\n-        fn duration_to_f32(d: Duration) -> f32 {\n-            d.as_secs() as f32 + d.subsec_nanos() as f32 / 1_000_000_000f32\n+        {\n+            let report_errs = &report.internal.borrow().1;\n+            if report_errs.has_check_errors {\n+                self.summary.add_check_error();\n+            }\n+            if report_errs.has_operational_errors {\n+                self.summary.add_operational_error();\n+            }\n         }\n \n-        println!(\n-            \"Spent {0:.3} secs in the parsing phase, and {1:.3} secs in the formatting phase\",\n-            duration_to_f32(summary.get_parse_time().unwrap()),\n-            duration_to_f32(summary.get_format_time().unwrap()),\n-        )\n-    });\n-\n-    {\n-        let report_errs = &report.internal.borrow().1;\n-        if report_errs.has_check_errors {\n-            summary.add_check_error();\n-        }\n-        if report_errs.has_operational_errors {\n-            summary.add_operational_error();\n-        }\n-    }\n+        match format_result {\n+            Ok((file_map, has_diff, has_macro_rewrite_failure)) => {\n+                if report.has_warnings() {\n+                    self.summary.add_formatting_error();\n+                }\n \n-    match format_result {\n-        Ok((file_map, has_diff, has_macro_rewrite_failure)) => {\n-            if report.has_warnings() {\n-                summary.add_formatting_error();\n-            }\n+                if has_diff {\n+                    self.summary.add_diff();\n+                }\n \n-            if has_diff {\n-                summary.add_diff();\n-            }\n+                if has_macro_rewrite_failure {\n+                    self.summary.add_macro_foramt_failure();\n+                }\n \n-            if has_macro_rewrite_failure {\n-                summary.add_macro_foramt_failure();\n+                Ok((file_map, report))\n             }\n-\n-            Ok((summary, file_map, report))\n+            Err(e) => Err(From::from(e)),\n         }\n-        Err(e) => Err((From::from(e), summary)),\n     }\n }\n \n@@ -551,43 +553,3 @@ pub(crate) struct ModifiedLines {\n     /// The set of changed chunks.\n     pub chunks: Vec<ModifiedChunk>,\n }\n-\n-/// Format a file and return a `ModifiedLines` data structure describing\n-/// the changed ranges of lines.\n-#[cfg(test)]\n-pub(crate) fn get_modified_lines(\n-    input: Input,\n-    config: &Config,\n-) -> Result<ModifiedLines, (ErrorKind, Summary)> {\n-    use std::io::BufRead;\n-\n-    let mut data = Vec::new();\n-\n-    let mut config = config.clone();\n-    config.set().emit_mode(::config::EmitMode::ModifiedLines);\n-    ::format_input(input, &config, Some(&mut data))?;\n-\n-    let mut lines = data.lines();\n-    let mut chunks = Vec::new();\n-    while let Some(Ok(header)) = lines.next() {\n-        // Parse the header line\n-        let values: Vec<_> = header\n-            .split(' ')\n-            .map(|s| s.parse::<u32>().unwrap())\n-            .collect();\n-        assert_eq!(values.len(), 3);\n-        let line_number_orig = values[0];\n-        let lines_removed = values[1];\n-        let num_added = values[2];\n-        let mut added_lines = Vec::new();\n-        for _ in 0..num_added {\n-            added_lines.push(lines.next().unwrap().unwrap());\n-        }\n-        chunks.push(ModifiedChunk {\n-            line_number_orig,\n-            lines_removed,\n-            lines: added_lines,\n-        });\n-    }\n-    Ok(ModifiedLines { chunks })\n-}"}, {"sha": "d6ab36614824987d8a8c7de65fc7becb538a1a5e", "filename": "src/git-rustfmt/main.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71d3d04270474ae0afdeeb410fdcc168a54714b7/src%2Fgit-rustfmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d3d04270474ae0afdeeb410fdcc168a54714b7/src%2Fgit-rustfmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgit-rustfmt%2Fmain.rs?ref=71d3d04270474ae0afdeeb410fdcc168a54714b7", "patch": "@@ -22,7 +22,7 @@ use std::str::FromStr;\n \n use getopts::{Matches, Options};\n \n-use rustfmt::{format_input, load_config, CliOptions, Input};\n+use rustfmt::{load_config, CliOptions, Input, Session};\n \n fn prune_files(files: Vec<&str>) -> Vec<&str> {\n     let prefixes: Vec<_> = files\n@@ -73,16 +73,14 @@ fn fmt_files(files: &[&str]) -> i32 {\n         load_config::<NullOptions>(Some(Path::new(\".\")), None).expect(\"couldn't load config\");\n \n     let mut exit_code = 0;\n+    let mut out = stdout();\n+    let mut session = Session::new(config, Some(&mut out));\n     for file in files {\n-        let (summary, report) = format_input(\n-            Input::File(PathBuf::from(file)),\n-            &config,\n-            Some(&mut stdout()),\n-        ).unwrap();\n+        let report = session.format(Input::File(PathBuf::from(file))).unwrap();\n         if report.has_warnings() {\n             eprintln!(\"{}\", report);\n         }\n-        if !summary.has_no_errors() {\n+        if !session.summary.has_no_errors() {\n             exit_code = 1;\n         }\n     }"}, {"sha": "f087ea5e52a8f3223ae9adf92ef02e5777212d9c", "filename": "src/imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71d3d04270474ae0afdeeb410fdcc168a54714b7/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d3d04270474ae0afdeeb410fdcc168a54714b7/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=71d3d04270474ae0afdeeb410fdcc168a54714b7", "patch": "@@ -349,7 +349,7 @@ impl UseTree {\n                 ));\n             }\n             UseTreeKind::Simple(ref rename, ..) => {\n-                let mut name = rewrite_ident(context, path_to_imported_ident(&a.prefix)).to_owned();\n+                let name = rewrite_ident(context, path_to_imported_ident(&a.prefix)).to_owned();\n                 let alias = rename.and_then(|ident| {\n                     if ident == path_to_imported_ident(&a.prefix) {\n                         None\n@@ -511,7 +511,7 @@ impl UseTree {\n                 let prefix = &self.path[..self.path.len() - 1];\n                 let mut result = vec![];\n                 for nested_use_tree in list {\n-                    for mut flattend in &mut nested_use_tree.clone().flatten() {\n+                    for flattend in &mut nested_use_tree.clone().flatten() {\n                         let mut new_path = prefix.to_vec();\n                         new_path.append(&mut flattend.path);\n                         result.push(UseTree {\n@@ -532,7 +532,7 @@ impl UseTree {\n \n     fn merge(&mut self, other: UseTree) {\n         let mut new_path = vec![];\n-        for (mut a, b) in self\n+        for (a, b) in self\n             .path\n             .clone()\n             .iter_mut()"}, {"sha": "721f02b018785624ceae4edddb2b44ed32cb0fac", "filename": "src/items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71d3d04270474ae0afdeeb410fdcc168a54714b7/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d3d04270474ae0afdeeb410fdcc168a54714b7/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=71d3d04270474ae0afdeeb410fdcc168a54714b7", "patch": "@@ -663,7 +663,7 @@ pub fn format_impl(\n             option.compress_where();\n         }\n \n-        let mut where_clause_str = rewrite_where_clause(\n+        let where_clause_str = rewrite_where_clause(\n             context,\n             &generics.where_clause,\n             context.config.brace_style(),"}, {"sha": "6183117a58cba1b430b339a6091721b7495fab0d", "filename": "src/lib.rs", "status": "modified", "additions": 61, "deletions": 22, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/71d3d04270474ae0afdeeb410fdcc168a54714b7/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d3d04270474ae0afdeeb410fdcc168a54714b7/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=71d3d04270474ae0afdeeb410fdcc168a54714b7", "patch": "@@ -14,6 +14,7 @@\n #![feature(type_ascription)]\n #![feature(unicode_internals)]\n #![feature(extern_prelude)]\n+#![feature(nll)]\n \n #[macro_use]\n extern crate derive_new;\n@@ -41,17 +42,17 @@ use std::cell::RefCell;\n use std::collections::HashMap;\n use std::fmt;\n use std::io::{self, Write};\n+use std::mem;\n use std::path::PathBuf;\n use std::rc::Rc;\n use syntax::ast;\n \n use comment::LineClasses;\n use failure::Fail;\n-use formatting::{format_input_inner, FormatErrorMap, FormattingError, ReportedErrors};\n+use formatting::{FormatErrorMap, FormattingError, ReportedErrors};\n use issues::Issue;\n use shape::Indent;\n \n-pub use checkstyle::{footer as checkstyle_footer, header as checkstyle_header};\n pub use config::summary::Summary;\n pub use config::{\n     load_config, CliOptions, Color, Config, EmitMode, FileLines, FileName, NewlineStyle, Range,\n@@ -348,13 +349,16 @@ fn format_snippet(snippet: &str, config: &Config) -> Option<String> {\n     config.set().emit_mode(config::EmitMode::Stdout);\n     config.set().verbose(Verbosity::Quiet);\n     config.set().hide_parse_errors(true);\n-    match format_input(input, &config, Some(&mut out)) {\n-        // `format_input()` returns an empty string on parsing error.\n-        Ok((summary, _)) if summary.has_macro_formatting_failure() => None,\n-        Ok(..) if out.is_empty() && !snippet.is_empty() => None,\n-        Ok(..) => String::from_utf8(out).ok(),\n-        Err(..) => None,\n+    {\n+        let mut session = Session::new(config, Some(&mut out));\n+        let result = session.format(input);\n+        let formatting_error = session.summary.has_macro_formatting_failure()\n+            || session.out.as_ref().unwrap().is_empty() && !snippet.is_empty();\n+        if formatting_error || result.is_err() {\n+            return None;\n+        }\n     }\n+    String::from_utf8(out).ok()\n }\n \n /// Format the given code block. Mainly targeted for code block in comment.\n@@ -436,24 +440,59 @@ fn format_code_block(code_snippet: &str, config: &Config) -> Option<String> {\n     Some(result)\n }\n \n-#[derive(Debug)]\n-pub enum Input {\n-    File(PathBuf),\n-    Text(String),\n+/// A session is a run of rustfmt across a single or multiple inputs.\n+pub struct Session<'b, T: Write + 'b> {\n+    pub config: Config,\n+    pub out: Option<&'b mut T>,\n+    pub summary: Summary,\n+}\n+\n+impl<'b, T: Write + 'b> Session<'b, T> {\n+    pub fn new(config: Config, out: Option<&'b mut T>) -> Session<'b, T> {\n+        if config.emit_mode() == EmitMode::Checkstyle {\n+            println!(\"{}\", checkstyle::header());\n+        }\n+\n+        Session {\n+            config,\n+            out,\n+            summary: Summary::default(),\n+        }\n+    }\n+\n+    /// The main entry point for Rustfmt. Formats the given input according to the\n+    /// given config. `out` is only necessary if required by the configuration.\n+    pub fn format(&mut self, input: Input) -> Result<FormatReport, ErrorKind> {\n+        if !self.config.version_meets_requirement() {\n+            return Err(ErrorKind::VersionMismatch);\n+        }\n+\n+        syntax::with_globals(|| self.format_input_inner(input)).map(|tup| tup.1)\n+    }\n+\n+    pub fn override_config<F, U>(&mut self, mut config: Config, f: F) -> U\n+    where\n+        F: FnOnce(&mut Session<'b, T>) -> U,\n+    {\n+        mem::swap(&mut config, &mut self.config);\n+        let result = f(self);\n+        mem::swap(&mut config, &mut self.config);\n+        result\n+    }\n }\n \n-/// The main entry point for Rustfmt. Formats the given input according to the\n-/// given config. `out` is only necessary if required by the configuration.\n-pub fn format_input<T: Write>(\n-    input: Input,\n-    config: &Config,\n-    out: Option<&mut T>,\n-) -> Result<(Summary, FormatReport), (ErrorKind, Summary)> {\n-    if !config.version_meets_requirement() {\n-        return Err((ErrorKind::VersionMismatch, Summary::default()));\n+impl<'b, T: Write + 'b> Drop for Session<'b, T> {\n+    fn drop(&mut self) {\n+        if self.config.emit_mode() == EmitMode::Checkstyle {\n+            println!(\"{}\", checkstyle::footer());\n+        }\n     }\n+}\n \n-    syntax::with_globals(|| format_input_inner(input, config, out)).map(|tup| (tup.0, tup.2))\n+#[derive(Debug)]\n+pub enum Input {\n+    File(PathBuf),\n+    Text(String),\n }\n \n #[cfg(test)]"}, {"sha": "f02cfbc858c611eed9c5e47944ab96ad491e9ad7", "filename": "src/test/mod.rs", "status": "modified", "additions": 78, "deletions": 33, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/71d3d04270474ae0afdeeb410fdcc168a54714b7/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71d3d04270474ae0afdeeb410fdcc168a54714b7/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=71d3d04270474ae0afdeeb410fdcc168a54714b7", "patch": "@@ -23,9 +23,9 @@ use std::str::Chars;\n use config::summary::Summary;\n use config::{Color, Config, EmitMode, FileName, ReportTactic};\n use filemap;\n-use formatting::{format_input_inner, get_modified_lines, FileMap, ModifiedChunk, ModifiedLines};\n+use formatting::{FileMap, ModifiedChunk};\n use rustfmt_diff::{make_diff, print_diff, DiffLine, Mismatch, OutputWriter};\n-use {format_input, FormatReport, Input};\n+use {FormatReport, Input, Session};\n \n const DIFF_CONTEXT_SIZE: usize = 3;\n const CONFIGURATIONS_FILE_NAME: &str = \"Configurations.md\";\n@@ -142,33 +142,64 @@ fn checkstyle_test() {\n \n #[test]\n fn modified_test() {\n+    use std::io::BufRead;\n+\n     // Test \"modified\" output\n     let filename = \"tests/writemode/source/modified.rs\";\n-    let result = get_modified_lines(Input::File(filename.into()), &Config::default()).unwrap();\n-    assert_eq!(\n-        result,\n-        ModifiedLines {\n-            chunks: vec![\n-                ModifiedChunk {\n-                    line_number_orig: 4,\n-                    lines_removed: 4,\n-                    lines: vec![\"fn blah() {}\".into()],\n-                },\n-                ModifiedChunk {\n-                    line_number_orig: 9,\n-                    lines_removed: 6,\n-                    lines: vec![\"#[cfg(a, b)]\".into(), \"fn main() {}\".into()],\n-                },\n-            ],\n+    let mut data = Vec::new();\n+    let mut config = Config::default();\n+    config.set().emit_mode(::config::EmitMode::ModifiedLines);\n+\n+    {\n+        let mut session = Session::new(config, Some(&mut data));\n+        session.format(Input::File(filename.into())).unwrap();\n+    }\n+\n+    let mut lines = data.lines();\n+    let mut chunks = Vec::new();\n+    while let Some(Ok(header)) = lines.next() {\n+        // Parse the header line\n+        let values: Vec<_> = header\n+            .split(' ')\n+            .map(|s| s.parse::<u32>().unwrap())\n+            .collect();\n+        assert_eq!(values.len(), 3);\n+        let line_number_orig = values[0];\n+        let lines_removed = values[1];\n+        let num_added = values[2];\n+        let mut added_lines = Vec::new();\n+        for _ in 0..num_added {\n+            added_lines.push(lines.next().unwrap().unwrap());\n         }\n+        chunks.push(ModifiedChunk {\n+            line_number_orig,\n+            lines_removed,\n+            lines: added_lines,\n+        });\n+    }\n+\n+    assert_eq!(\n+        chunks,\n+        vec![\n+            ModifiedChunk {\n+                line_number_orig: 4,\n+                lines_removed: 4,\n+                lines: vec![\"fn blah() {}\".into()],\n+            },\n+            ModifiedChunk {\n+                line_number_orig: 9,\n+                lines_removed: 6,\n+                lines: vec![\"#[cfg(a, b)]\".into(), \"fn main() {}\".into()],\n+            },\n+        ],\n     );\n }\n \n // Helper function for comparing the results of rustfmt\n // to a known output file generated by one of the write modes.\n fn assert_output(source: &Path, expected_filename: &Path) {\n     let config = read_config(source);\n-    let (_error_summary, file_map, _report) = format_file(source, &config);\n+    let (_, file_map, _) = format_file(source, config.clone());\n \n     // Populate output by writing to a vec.\n     let mut out = vec![];\n@@ -246,8 +277,11 @@ fn stdin_formatting_smoke_test() {\n     let mut config = Config::default();\n     config.set().emit_mode(EmitMode::Stdout);\n     let mut buf: Vec<u8> = vec![];\n-    let (error_summary, _) = format_input(input, &config, Some(&mut buf)).unwrap();\n-    assert!(error_summary.has_no_errors());\n+    {\n+        let mut session = Session::new(config, Some(&mut buf));\n+        session.format(input).unwrap();\n+        assert!(session.summary.has_no_errors());\n+    }\n     //eprintln!(\"{:?}\", );\n     #[cfg(not(windows))]\n     assert_eq!(buf, \"fn main() {}\\n\".as_bytes());\n@@ -284,8 +318,9 @@ fn format_lines_errors_are_reported() {\n     let input = Input::Text(format!(\"fn {}() {{}}\", long_identifier));\n     let mut config = Config::default();\n     config.set().error_on_line_overflow(true);\n-    let (error_summary, _) = format_input::<io::Stdout>(input, &config, None).unwrap();\n-    assert!(error_summary.has_formatting_errors());\n+    let mut session = Session::<io::Stdout>::new(config, None);\n+    session.format(input).unwrap();\n+    assert!(session.summary.has_formatting_errors());\n }\n \n #[test]\n@@ -295,8 +330,9 @@ fn format_lines_errors_are_reported_with_tabs() {\n     let mut config = Config::default();\n     config.set().error_on_line_overflow(true);\n     config.set().hard_tabs(true);\n-    let (error_summary, _) = format_input::<io::Stdout>(input, &config, None).unwrap();\n-    assert!(error_summary.has_formatting_errors());\n+    let mut session = Session::<io::Stdout>::new(config, None);\n+    session.format(input).unwrap();\n+    assert!(session.summary.has_formatting_errors());\n }\n \n // For each file, run rustfmt and collect the output.\n@@ -380,11 +416,15 @@ fn read_config(filename: &Path) -> Config {\n     config\n }\n \n-fn format_file<P: Into<PathBuf>>(filepath: P, config: &Config) -> (Summary, FileMap, FormatReport) {\n+fn format_file<P: Into<PathBuf>>(filepath: P, config: Config) -> (bool, FileMap, FormatReport) {\n     let filepath = filepath.into();\n     let input = Input::File(filepath);\n-    //format_input::<io::Stdout>(input, config, None).unwrap()\n-    syntax::with_globals(|| format_input_inner::<io::Stdout>(input, config, None)).unwrap()\n+    let mut session = Session::<io::Stdout>::new(config, None);\n+    syntax::with_globals(|| {\n+        let result = session.format_input_inner(input).unwrap();\n+        let parsing_errors = session.summary.has_parsing_errors();\n+        (parsing_errors, result.0, result.1)\n+    })\n }\n \n enum IdempotentCheckError {\n@@ -402,8 +442,8 @@ fn idempotent_check(\n     } else {\n         read_config(filename)\n     };\n-    let (error_summary, file_map, format_report) = format_file(filename, &config);\n-    if error_summary.has_parsing_errors() {\n+    let (parsing_errors, file_map, format_report) = format_file(filename, config);\n+    if parsing_errors {\n         return Err(IdempotentCheckError::Parse);\n     }\n \n@@ -779,10 +819,15 @@ impl ConfigCodeBlock {\n         config.set().emit_mode(EmitMode::Stdout);\n         let mut buf: Vec<u8> = vec![];\n \n-        let (error_summary, _) = format_input(input, &config, Some(&mut buf)).unwrap();\n+        {\n+            let mut session = Session::new(config, Some(&mut buf));\n+            session.format(input).unwrap();\n+            if self.has_parsing_errors(session.summary) {\n+                return false;\n+            }\n+        }\n \n-        !self.has_parsing_errors(error_summary)\n-            && !self.formatted_has_diff(&String::from_utf8(buf).unwrap())\n+        !self.formatted_has_diff(&String::from_utf8(buf).unwrap())\n     }\n \n     // Extract a code block from the iterator. Behavior:"}]}