{"sha": "da384694807172f0ca40eca2e49a11688aba6e93", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhMzg0Njk0ODA3MTcyZjBjYTQwZWNhMmU0OWExMTY4OGFiYTZlOTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-21T20:18:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-21T20:18:11Z"}, "message": "Auto merge of #79273 - Dylan-DPC:rollup-zd10xlt, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #77844 (clarify rules for ZST Boxes)\n - #79067 (Refactor the abi handling code a bit)\n - #79182 (Fix links to extern types in rustdoc (fixes #78777))\n - #79231 (Exhaustively match in variant count instrinsic)\n - #79238 (Direct RUSTC_LOG (tracing/log) output to stderr instead of stdout.)\n - #79256 (Fix typos)\n - #79264 (Get rid of some doctree items)\n - #79272 (Support building clone shims for arrays with generic size)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b1b379214fe7fc680444775c1514583c70d71bea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1b379214fe7fc680444775c1514583c70d71bea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da384694807172f0ca40eca2e49a11688aba6e93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da384694807172f0ca40eca2e49a11688aba6e93", "html_url": "https://github.com/rust-lang/rust/commit/da384694807172f0ca40eca2e49a11688aba6e93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da384694807172f0ca40eca2e49a11688aba6e93/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3adedb8f4c5bb71e9e8a21a047cf8ed121ce0e75", "url": "https://api.github.com/repos/rust-lang/rust/commits/3adedb8f4c5bb71e9e8a21a047cf8ed121ce0e75", "html_url": "https://github.com/rust-lang/rust/commit/3adedb8f4c5bb71e9e8a21a047cf8ed121ce0e75"}, {"sha": "68c9caa6f69d015f39a25e5acbcf90f9a72c7287", "url": "https://api.github.com/repos/rust-lang/rust/commits/68c9caa6f69d015f39a25e5acbcf90f9a72c7287", "html_url": "https://github.com/rust-lang/rust/commit/68c9caa6f69d015f39a25e5acbcf90f9a72c7287"}], "stats": {"total": 974, "additions": 499, "deletions": 475}, "files": [{"sha": "915dd3d9eda1586ecef67545eb8514b309e790cb", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 102, "deletions": 44, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -36,17 +36,17 @@ impl ArgAttributeExt for ArgAttribute {\n     where\n         F: FnMut(llvm::Attribute),\n     {\n-        for_each_kind!(self, f, NoAlias, NoCapture, NonNull, ReadOnly, SExt, StructRet, ZExt, InReg)\n+        for_each_kind!(self, f, NoAlias, NoCapture, NonNull, ReadOnly, InReg)\n     }\n }\n \n pub trait ArgAttributesExt {\n-    fn apply_llfn(&self, idx: AttributePlace, llfn: &Value, ty: Option<&Type>);\n-    fn apply_callsite(&self, idx: AttributePlace, callsite: &Value, ty: Option<&Type>);\n+    fn apply_attrs_to_llfn(&self, idx: AttributePlace, llfn: &Value);\n+    fn apply_attrs_to_callsite(&self, idx: AttributePlace, callsite: &Value);\n }\n \n impl ArgAttributesExt for ArgAttributes {\n-    fn apply_llfn(&self, idx: AttributePlace, llfn: &Value, ty: Option<&Type>) {\n+    fn apply_attrs_to_llfn(&self, idx: AttributePlace, llfn: &Value) {\n         let mut regular = self.regular;\n         unsafe {\n             let deref = self.pointee_size.bytes();\n@@ -61,14 +61,20 @@ impl ArgAttributesExt for ArgAttributes {\n             if let Some(align) = self.pointee_align {\n                 llvm::LLVMRustAddAlignmentAttr(llfn, idx.as_uint(), align.bytes() as u32);\n             }\n-            if regular.contains(ArgAttribute::ByVal) {\n-                llvm::LLVMRustAddByValAttr(llfn, idx.as_uint(), ty.unwrap());\n-            }\n             regular.for_each_kind(|attr| attr.apply_llfn(idx, llfn));\n+            match self.arg_ext {\n+                ArgExtension::None => {}\n+                ArgExtension::Zext => {\n+                    llvm::Attribute::ZExt.apply_llfn(idx, llfn);\n+                }\n+                ArgExtension::Sext => {\n+                    llvm::Attribute::SExt.apply_llfn(idx, llfn);\n+                }\n+            }\n         }\n     }\n \n-    fn apply_callsite(&self, idx: AttributePlace, callsite: &Value, ty: Option<&Type>) {\n+    fn apply_attrs_to_callsite(&self, idx: AttributePlace, callsite: &Value) {\n         let mut regular = self.regular;\n         unsafe {\n             let deref = self.pointee_size.bytes();\n@@ -91,10 +97,16 @@ impl ArgAttributesExt for ArgAttributes {\n                     align.bytes() as u32,\n                 );\n             }\n-            if regular.contains(ArgAttribute::ByVal) {\n-                llvm::LLVMRustAddByValCallSiteAttr(callsite, idx.as_uint(), ty.unwrap());\n-            }\n             regular.for_each_kind(|attr| attr.apply_callsite(idx, callsite));\n+            match self.arg_ext {\n+                ArgExtension::None => {}\n+                ArgExtension::Zext => {\n+                    llvm::Attribute::ZExt.apply_callsite(idx, callsite);\n+                }\n+                ArgExtension::Sext => {\n+                    llvm::Attribute::SExt.apply_callsite(idx, callsite);\n+                }\n+            }\n         }\n     }\n }\n@@ -146,7 +158,7 @@ impl LlvmType for CastTarget {\n             .prefix\n             .iter()\n             .flat_map(|option_kind| {\n-                option_kind.map(|kind| Reg { kind, size: self.prefix_chunk }.llvm_type(cx))\n+                option_kind.map(|kind| Reg { kind, size: self.prefix_chunk_size }.llvm_type(cx))\n             })\n             .chain((0..rest_count).map(|_| rest_ll_unit))\n             .collect();\n@@ -267,10 +279,12 @@ impl ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n             PassMode::Pair(..) => {\n                 OperandValue::Pair(next(), next()).store(bx, dst);\n             }\n-            PassMode::Indirect(_, Some(_)) => {\n+            PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n                 OperandValue::Ref(next(), Some(next()), self.layout.align.abi).store(bx, dst);\n             }\n-            PassMode::Direct(_) | PassMode::Indirect(_, None) | PassMode::Cast(_) => {\n+            PassMode::Direct(_)\n+            | PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ }\n+            | PassMode::Cast(_) => {\n                 let next_arg = next();\n                 self.store(bx, next_arg, dst);\n             }\n@@ -315,14 +329,14 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n             if let PassMode::Pair(_, _) = arg.mode { 2 } else { 1 }\n         ).sum();\n         let mut llargument_tys = Vec::with_capacity(\n-            if let PassMode::Indirect(..) = self.ret.mode { 1 } else { 0 } + args_capacity,\n+            if let PassMode::Indirect { .. } = self.ret.mode { 1 } else { 0 } + args_capacity,\n         );\n \n         let llreturn_ty = match self.ret.mode {\n             PassMode::Ignore => cx.type_void(),\n             PassMode::Direct(_) | PassMode::Pair(..) => self.ret.layout.immediate_llvm_type(cx),\n             PassMode::Cast(cast) => cast.llvm_type(cx),\n-            PassMode::Indirect(..) => {\n+            PassMode::Indirect { .. } => {\n                 llargument_tys.push(cx.type_ptr_to(self.ret.memory_ty(cx)));\n                 cx.type_void()\n             }\n@@ -342,15 +356,17 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n                     llargument_tys.push(arg.layout.scalar_pair_element_llvm_type(cx, 1, true));\n                     continue;\n                 }\n-                PassMode::Indirect(_, Some(_)) => {\n+                PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ } => {\n                     let ptr_ty = cx.tcx.mk_mut_ptr(arg.layout.ty);\n                     let ptr_layout = cx.layout_of(ptr_ty);\n                     llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 0, true));\n                     llargument_tys.push(ptr_layout.scalar_pair_element_llvm_type(cx, 1, true));\n                     continue;\n                 }\n                 PassMode::Cast(cast) => cast.llvm_type(cx),\n-                PassMode::Indirect(_, None) => cx.type_ptr_to(arg.memory_ty(cx)),\n+                PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n+                    cx.type_ptr_to(arg.memory_ty(cx))\n+                }\n             };\n             llargument_tys.push(llarg_ty);\n         }\n@@ -402,35 +418,54 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         }\n \n         let mut i = 0;\n-        let mut apply = |attrs: &ArgAttributes, ty: Option<&Type>| {\n-            attrs.apply_llfn(llvm::AttributePlace::Argument(i), llfn, ty);\n+        let mut apply = |attrs: &ArgAttributes| {\n+            attrs.apply_attrs_to_llfn(llvm::AttributePlace::Argument(i), llfn);\n             i += 1;\n+            i - 1\n         };\n         match self.ret.mode {\n             PassMode::Direct(ref attrs) => {\n-                attrs.apply_llfn(llvm::AttributePlace::ReturnValue, llfn, None);\n+                attrs.apply_attrs_to_llfn(llvm::AttributePlace::ReturnValue, llfn);\n+            }\n+            PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n+                assert!(!on_stack);\n+                let i = apply(attrs);\n+                llvm::Attribute::StructRet.apply_llfn(llvm::AttributePlace::Argument(i), llfn);\n             }\n-            PassMode::Indirect(ref attrs, _) => apply(attrs, Some(self.ret.layout.llvm_type(cx))),\n             _ => {}\n         }\n         for arg in &self.args {\n             if arg.pad.is_some() {\n-                apply(&ArgAttributes::new(), None);\n+                apply(&ArgAttributes::new());\n             }\n             match arg.mode {\n                 PassMode::Ignore => {}\n-                PassMode::Direct(ref attrs) | PassMode::Indirect(ref attrs, None) => {\n-                    apply(attrs, Some(arg.layout.llvm_type(cx)))\n+                PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n+                    let i = apply(attrs);\n+                    unsafe {\n+                        llvm::LLVMRustAddByValAttr(\n+                            llfn,\n+                            llvm::AttributePlace::Argument(i).as_uint(),\n+                            arg.layout.llvm_type(cx),\n+                        );\n+                    }\n                 }\n-                PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {\n-                    apply(attrs, None);\n-                    apply(extra_attrs, None);\n+                PassMode::Direct(ref attrs)\n+                | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n+                    apply(attrs);\n+                }\n+                PassMode::Indirect { ref attrs, extra_attrs: Some(ref extra_attrs), on_stack } => {\n+                    assert!(!on_stack);\n+                    apply(attrs);\n+                    apply(extra_attrs);\n                 }\n                 PassMode::Pair(ref a, ref b) => {\n-                    apply(a, None);\n-                    apply(b, None);\n+                    apply(a);\n+                    apply(b);\n+                }\n+                PassMode::Cast(_) => {\n+                    apply(&ArgAttributes::new());\n                 }\n-                PassMode::Cast(_) => apply(&ArgAttributes::new(), None),\n             }\n         }\n     }\n@@ -439,15 +474,21 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         // FIXME(wesleywiser, eddyb): We should apply `nounwind` and `noreturn` as appropriate to this callsite.\n \n         let mut i = 0;\n-        let mut apply = |attrs: &ArgAttributes, ty: Option<&Type>| {\n-            attrs.apply_callsite(llvm::AttributePlace::Argument(i), callsite, ty);\n+        let mut apply = |attrs: &ArgAttributes| {\n+            attrs.apply_attrs_to_callsite(llvm::AttributePlace::Argument(i), callsite);\n             i += 1;\n+            i - 1\n         };\n         match self.ret.mode {\n             PassMode::Direct(ref attrs) => {\n-                attrs.apply_callsite(llvm::AttributePlace::ReturnValue, callsite, None);\n+                attrs.apply_attrs_to_callsite(llvm::AttributePlace::ReturnValue, callsite);\n+            }\n+            PassMode::Indirect { ref attrs, extra_attrs: _, on_stack } => {\n+                assert!(!on_stack);\n+                let i = apply(attrs);\n+                llvm::Attribute::StructRet\n+                    .apply_callsite(llvm::AttributePlace::Argument(i), callsite);\n             }\n-            PassMode::Indirect(ref attrs, _) => apply(attrs, Some(self.ret.layout.llvm_type(bx))),\n             _ => {}\n         }\n         if let abi::Abi::Scalar(ref scalar) = self.ret.layout.abi {\n@@ -465,22 +506,39 @@ impl<'tcx> FnAbiLlvmExt<'tcx> for FnAbi<'tcx, Ty<'tcx>> {\n         }\n         for arg in &self.args {\n             if arg.pad.is_some() {\n-                apply(&ArgAttributes::new(), None);\n+                apply(&ArgAttributes::new());\n             }\n             match arg.mode {\n                 PassMode::Ignore => {}\n-                PassMode::Direct(ref attrs) | PassMode::Indirect(ref attrs, None) => {\n-                    apply(attrs, Some(arg.layout.llvm_type(bx)))\n+                PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: true } => {\n+                    let i = apply(attrs);\n+                    unsafe {\n+                        llvm::LLVMRustAddByValCallSiteAttr(\n+                            callsite,\n+                            llvm::AttributePlace::Argument(i).as_uint(),\n+                            arg.layout.llvm_type(bx),\n+                        );\n+                    }\n                 }\n-                PassMode::Indirect(ref attrs, Some(ref extra_attrs)) => {\n-                    apply(attrs, None);\n-                    apply(extra_attrs, None);\n+                PassMode::Direct(ref attrs)\n+                | PassMode::Indirect { ref attrs, extra_attrs: None, on_stack: false } => {\n+                    apply(attrs);\n+                }\n+                PassMode::Indirect {\n+                    ref attrs,\n+                    extra_attrs: Some(ref extra_attrs),\n+                    on_stack: _,\n+                } => {\n+                    apply(attrs);\n+                    apply(extra_attrs);\n                 }\n                 PassMode::Pair(ref a, ref b) => {\n-                    apply(a, None);\n-                    apply(b, None);\n+                    apply(a);\n+                    apply(b);\n+                }\n+                PassMode::Cast(_) => {\n+                    apply(&ArgAttributes::new());\n                 }\n-                PassMode::Cast(_) => apply(&ArgAttributes::new(), None),\n             }\n         }\n "}, {"sha": "fd20709f5d80f67ef96ac901725ee362c67bc594", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -255,7 +255,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             return;\n         }\n         let llval = match self.fn_abi.ret.mode {\n-            PassMode::Ignore | PassMode::Indirect(..) => {\n+            PassMode::Ignore | PassMode::Indirect { .. } => {\n                 bx.ret_void();\n                 return;\n             }\n@@ -1101,7 +1101,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // Force by-ref if we have to load through a cast pointer.\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => match arg.mode {\n-                PassMode::Indirect(..) | PassMode::Cast(_) => {\n+                PassMode::Indirect { .. } | PassMode::Cast(_) => {\n                     let scratch = PlaceRef::alloca(bx, arg.layout);\n                     op.val.store(bx, scratch);\n                     (scratch.llval, scratch.align, true)"}, {"sha": "e49e456792b0d443e58bfffd191efb4599f217bc", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -1286,6 +1286,7 @@ pub fn init_env_logger(env: &str) {\n     }\n     let filter = tracing_subscriber::EnvFilter::from_env(env);\n     let layer = tracing_tree::HierarchicalLayer::default()\n+        .with_writer(io::stderr)\n         .with_indent_lines(true)\n         .with_ansi(true)\n         .with_targets(true)"}, {"sha": "19340dd51de14219dfa4d11a806224ec98439f6c", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -947,7 +947,12 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_type(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        self.root.tables.ty.get(self, id).unwrap().decode((self, tcx))\n+        self.root\n+            .tables\n+            .ty\n+            .get(self, id)\n+            .unwrap_or_else(|| panic!(\"Not a type: {:?}\", id))\n+            .decode((self, tcx))\n     }\n \n     fn get_stability(&self, id: DefIndex) -> Option<attr::Stability> {"}, {"sha": "fa0711193df487bbf72025f5e9aa7e0d514f7662", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -15,7 +15,7 @@ use rustc_session::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::DUMMY_SP;\n use rustc_target::abi::call::{\n-    ArgAbi, ArgAttribute, ArgAttributes, Conv, FnAbi, PassMode, Reg, RegKind,\n+    ArgAbi, ArgAttribute, ArgAttributes, ArgExtension, Conv, FnAbi, PassMode, Reg, RegKind,\n };\n use rustc_target::abi::*;\n use rustc_target::spec::{abi::Abi as SpecAbi, HasTargetSpec, PanicStrategy};\n@@ -2619,7 +2619,7 @@ where\n                                       is_return: bool| {\n             // Booleans are always an i1 that needs to be zero-extended.\n             if scalar.is_bool() {\n-                attrs.set(ArgAttribute::ZExt);\n+                attrs.ext(ArgExtension::Zext);\n                 return;\n             }\n \n@@ -2801,9 +2801,6 @@ where\n             for arg in &mut self.args {\n                 fixup(arg, false);\n             }\n-            if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n-                attrs.set(ArgAttribute::StructRet);\n-            }\n             return;\n         }\n "}, {"sha": "f666a89ca56decd9af79427d36d37ed196b59af6", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -75,13 +75,35 @@ crate fn eval_nullary_intrinsic<'tcx>(\n             ensure_monomorphic_enough(tcx, tp_ty)?;\n             ConstValue::from_u64(tcx.type_id_hash(tp_ty))\n         }\n-        sym::variant_count => {\n-            if let ty::Adt(ref adt, _) = tp_ty.kind() {\n-                ConstValue::from_machine_usize(adt.variants.len() as u64, &tcx)\n-            } else {\n-                ConstValue::from_machine_usize(0u64, &tcx)\n-            }\n-        }\n+        sym::variant_count => match tp_ty.kind() {\n+            ty::Adt(ref adt, _) => ConstValue::from_machine_usize(adt.variants.len() as u64, &tcx),\n+            ty::Projection(_)\n+            | ty::Opaque(_, _)\n+            | ty::Param(_)\n+            | ty::Bound(_, _)\n+            | ty::Placeholder(_)\n+            | ty::Infer(_) => throw_inval!(TooGeneric),\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Foreign(_)\n+            | ty::Str\n+            | ty::Array(_, _)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(_, _, _)\n+            | ty::FnDef(_, _)\n+            | ty::FnPtr(_)\n+            | ty::Dynamic(_, _)\n+            | ty::Closure(_, _)\n+            | ty::Generator(_, _, _)\n+            | ty::GeneratorWitness(_)\n+            | ty::Never\n+            | ty::Tuple(_)\n+            | ty::Error(_) => ConstValue::from_machine_usize(0u64, &tcx),\n+        },\n         other => bug!(\"`{}` is not a zero arg intrinsic\", other),\n     })\n }"}, {"sha": "aa5835686a291edf212e31d2bca3bffc1d79c124", "filename": "compiler/rustc_mir/src/shim.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fshim.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -308,10 +308,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n \n     match self_ty.kind() {\n         _ if is_copy => builder.copy_shim(),\n-        ty::Array(ty, len) => {\n-            let len = len.eval_usize(tcx, param_env);\n-            builder.array_shim(dest, src, ty, len)\n-        }\n+        ty::Array(ty, len) => builder.array_shim(dest, src, ty, len),\n         ty::Closure(_, substs) => {\n             builder.tuple_like_shim(dest, src, substs.as_closure().upvar_tys())\n         }\n@@ -485,7 +482,13 @@ impl CloneShimBuilder<'tcx> {\n         }\n     }\n \n-    fn array_shim(&mut self, dest: Place<'tcx>, src: Place<'tcx>, ty: Ty<'tcx>, len: u64) {\n+    fn array_shim(\n+        &mut self,\n+        dest: Place<'tcx>,\n+        src: Place<'tcx>,\n+        ty: Ty<'tcx>,\n+        len: &'tcx ty::Const<'tcx>,\n+    ) {\n         let tcx = self.tcx;\n         let span = self.span;\n \n@@ -503,7 +506,11 @@ impl CloneShimBuilder<'tcx> {\n             ))),\n             self.make_statement(StatementKind::Assign(box (\n                 end,\n-                Rvalue::Use(Operand::Constant(self.make_usize(len))),\n+                Rvalue::Use(Operand::Constant(box Constant {\n+                    span: self.span,\n+                    user_ty: None,\n+                    literal: len,\n+                })),\n             ))),\n         ];\n         self.block(inits, TerminatorKind::Goto { target: BasicBlock::new(1) }, false);"}, {"sha": "5fed500390b68a911173673afeef76882389a9ef", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -33,11 +33,11 @@ pub struct QueryInfo<Q> {\n \n pub(crate) type QueryMap<D, Q> = FxHashMap<QueryJobId<D>, QueryJobInfo<D, Q>>;\n \n-/// A value uniquely identifiying an active query job within a shard in the query cache.\n+/// A value uniquely identifying an active query job within a shard in the query cache.\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n pub struct QueryShardJobId(pub NonZeroU32);\n \n-/// A value uniquely identifiying an active query job.\n+/// A value uniquely identifying an active query job.\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n pub struct QueryJobId<D> {\n     /// Which job within a shard is this\n@@ -536,7 +536,7 @@ fn remove_cycle<CTX: QueryContext>(\n         };\n \n         // We unwrap `waiter` here since there must always be one\n-        // edge which is resumeable / waited using a query latch\n+        // edge which is resumable / waited using a query latch\n         let (waitee_query, waiter_idx) = waiter.unwrap();\n \n         // Extract the waiter we want to resume"}, {"sha": "a630c84142b4d4ebb4f749ff68097bbcfa615d96", "filename": "compiler/rustc_target/src/abi/call/mips64.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmips64.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -1,4 +1,4 @@\n-use crate::abi::call::{ArgAbi, ArgAttribute, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n+use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n use crate::abi::{self, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods};\n \n fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n@@ -7,7 +7,7 @@ fn extend_integer_width_mips<Ty>(arg: &mut ArgAbi<'_, Ty>, bits: u64) {\n         if let abi::Int(i, signed) = scalar.value {\n             if !signed && i.size().bits() == 32 {\n                 if let PassMode::Direct(ref mut attrs) = arg.mode {\n-                    attrs.set(ArgAttribute::SExt);\n+                    attrs.ext(ArgExtension::Sext);\n                     return;\n                 }\n             }\n@@ -137,7 +137,7 @@ where\n     let rest_size = size - Size::from_bytes(8) * prefix_index as u64;\n     arg.cast_to(CastTarget {\n         prefix,\n-        prefix_chunk: Size::from_bytes(8),\n+        prefix_chunk_size: Size::from_bytes(8),\n         rest: Uniform { unit: Reg::i64(), total: rest_size },\n     });\n }"}, {"sha": "5de9a8dfa7ac1719a7b0e388962d3c1881c6374f", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -36,9 +36,12 @@ pub enum PassMode {\n     /// a single uniform or a pair of registers.\n     Cast(CastTarget),\n     /// Pass the argument indirectly via a hidden pointer.\n-    /// The second value, if any, is for the extra data (vtable or length)\n+    /// The `extra_attrs` value, if any, is for the extra data (vtable or length)\n     /// which indicates that it refers to an unsized rvalue.\n-    Indirect(ArgAttributes, Option<ArgAttributes>),\n+    /// `on_stack` defines that the the value should be passed at a fixed\n+    /// stack offset in accordance to the ABI rather than passed using a\n+    /// pointer. This corresponds to the `byval` LLVM argument attribute.\n+    Indirect { attrs: ArgAttributes, extra_attrs: Option<ArgAttributes>, on_stack: bool },\n }\n \n // Hack to disable non_upper_case_globals only for the bitflags! and not for the rest\n@@ -52,24 +55,31 @@ mod attr_impl {\n     bitflags::bitflags! {\n         #[derive(Default)]\n         pub struct ArgAttribute: u16 {\n-            const ByVal     = 1 << 0;\n             const NoAlias   = 1 << 1;\n             const NoCapture = 1 << 2;\n             const NonNull   = 1 << 3;\n             const ReadOnly  = 1 << 4;\n-            const SExt      = 1 << 5;\n-            const StructRet = 1 << 6;\n-            const ZExt      = 1 << 7;\n             const InReg     = 1 << 8;\n         }\n     }\n }\n \n+/// Sometimes an ABI requires small integers to be extended to a full or partial register. This enum\n+/// defines if this extension should be zero-extension or sign-extension when necssary. When it is\n+/// not necesary to extend the argument, this enum is ignored.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum ArgExtension {\n+    None,\n+    Zext,\n+    Sext,\n+}\n+\n /// A compact representation of LLVM attributes (at least those relevant for this module)\n /// that can be manipulated without interacting with LLVM's Attribute machinery.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub struct ArgAttributes {\n     pub regular: ArgAttribute,\n+    pub arg_ext: ArgExtension,\n     /// The minimum size of the pointee, guaranteed to be valid for the duration of the whole call\n     /// (corresponding to LLVM's dereferenceable and dereferenceable_or_null attributes).\n     pub pointee_size: Size,\n@@ -80,11 +90,18 @@ impl ArgAttributes {\n     pub fn new() -> Self {\n         ArgAttributes {\n             regular: ArgAttribute::default(),\n+            arg_ext: ArgExtension::None,\n             pointee_size: Size::ZERO,\n             pointee_align: None,\n         }\n     }\n \n+    pub fn ext(&mut self, ext: ArgExtension) -> &mut Self {\n+        assert!(self.arg_ext == ArgExtension::None || self.arg_ext == ext);\n+        self.arg_ext = ext;\n+        self\n+    }\n+\n     pub fn set(&mut self, attr: ArgAttribute) -> &mut Self {\n         self.regular |= attr;\n         self\n@@ -180,7 +197,7 @@ impl Uniform {\n #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n pub struct CastTarget {\n     pub prefix: [Option<RegKind>; 8],\n-    pub prefix_chunk: Size,\n+    pub prefix_chunk_size: Size,\n     pub rest: Uniform,\n }\n \n@@ -192,29 +209,29 @@ impl From<Reg> for CastTarget {\n \n impl From<Uniform> for CastTarget {\n     fn from(uniform: Uniform) -> CastTarget {\n-        CastTarget { prefix: [None; 8], prefix_chunk: Size::ZERO, rest: uniform }\n+        CastTarget { prefix: [None; 8], prefix_chunk_size: Size::ZERO, rest: uniform }\n     }\n }\n \n impl CastTarget {\n     pub fn pair(a: Reg, b: Reg) -> CastTarget {\n         CastTarget {\n             prefix: [Some(a.kind), None, None, None, None, None, None, None],\n-            prefix_chunk: a.size,\n+            prefix_chunk_size: a.size,\n             rest: Uniform::from(b),\n         }\n     }\n \n     pub fn size<C: HasDataLayout>(&self, cx: &C) -> Size {\n-        (self.prefix_chunk * self.prefix.iter().filter(|x| x.is_some()).count() as u64)\n+        (self.prefix_chunk_size * self.prefix.iter().filter(|x| x.is_some()).count() as u64)\n             .align_to(self.rest.align(cx))\n             + self.rest.total\n     }\n \n     pub fn align<C: HasDataLayout>(&self, cx: &C) -> Align {\n         self.prefix\n             .iter()\n-            .filter_map(|x| x.map(|kind| Reg { kind, size: self.prefix_chunk }.align(cx)))\n+            .filter_map(|x| x.map(|kind| Reg { kind, size: self.prefix_chunk_size }.align(cx)))\n             .fold(cx.data_layout().aggregate_align.abi.max(self.rest.align(cx)), |acc, align| {\n                 acc.max(align)\n             })\n@@ -438,14 +455,14 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n \n         let extra_attrs = self.layout.is_unsized().then_some(ArgAttributes::new());\n \n-        self.mode = PassMode::Indirect(attrs, extra_attrs);\n+        self.mode = PassMode::Indirect { attrs, extra_attrs, on_stack: false };\n     }\n \n     pub fn make_indirect_byval(&mut self) {\n         self.make_indirect();\n         match self.mode {\n-            PassMode::Indirect(ref mut attrs, _) => {\n-                attrs.set(ArgAttribute::ByVal);\n+            PassMode::Indirect { attrs: _, extra_attrs: _, ref mut on_stack } => {\n+                *on_stack = true;\n             }\n             _ => unreachable!(),\n         }\n@@ -457,7 +474,11 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n             if let abi::Int(i, signed) = scalar.value {\n                 if i.size().bits() < bits {\n                     if let PassMode::Direct(ref mut attrs) = self.mode {\n-                        attrs.set(if signed { ArgAttribute::SExt } else { ArgAttribute::ZExt });\n+                        if signed {\n+                            attrs.ext(ArgExtension::Sext)\n+                        } else {\n+                            attrs.ext(ArgExtension::Zext)\n+                        };\n                     }\n                 }\n             }\n@@ -474,15 +495,15 @@ impl<'a, Ty> ArgAbi<'a, Ty> {\n     }\n \n     pub fn is_indirect(&self) -> bool {\n-        matches!(self.mode, PassMode::Indirect(..))\n+        matches!(self.mode, PassMode::Indirect {..})\n     }\n \n     pub fn is_sized_indirect(&self) -> bool {\n-        matches!(self.mode, PassMode::Indirect(_, None))\n+        matches!(self.mode, PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ })\n     }\n \n     pub fn is_unsized_indirect(&self) -> bool {\n-        matches!(self.mode, PassMode::Indirect(_, Some(_)))\n+        matches!(self.mode, PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ })\n     }\n \n     pub fn is_ignore(&self) -> bool {\n@@ -591,10 +612,6 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             a => return Err(format!(\"unrecognized arch \\\"{}\\\" in target specification\", a)),\n         }\n \n-        if let PassMode::Indirect(ref mut attrs, _) = self.ret.mode {\n-            attrs.set(ArgAttribute::StructRet);\n-        }\n-\n         Ok(())\n     }\n }"}, {"sha": "1ab881dd13d1c46a1e8d5f4e0e0b7519fc115ff7", "filename": "compiler/rustc_target/src/abi/call/riscv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Friscv.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -4,7 +4,7 @@\n // Reference: Clang RISC-V ELF psABI lowering code\n // https://github.com/llvm/llvm-project/blob/8e780252a7284be45cf1ba224cabd884847e8e92/clang/lib/CodeGen/TargetInfo.cpp#L9311-L9773\n \n-use crate::abi::call::{ArgAbi, ArgAttribute, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n+use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};\n use crate::abi::{\n     self, Abi, FieldsShape, HasDataLayout, LayoutOf, Size, TyAndLayout, TyAndLayoutMethods,\n };\n@@ -308,7 +308,7 @@ fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {\n             // 32-bit integers are always sign-extended\n             if i.size().bits() == 32 && xlen > 32 {\n                 if let PassMode::Direct(ref mut attrs) = arg.mode {\n-                    attrs.set(ArgAttribute::SExt);\n+                    attrs.ext(ArgExtension::Sext);\n                     return;\n                 }\n             }"}, {"sha": "713b4100a33351472f8a1abfc739588956617021", "filename": "compiler/rustc_target/src/abi/call/x86.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fx86.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -92,9 +92,14 @@ where\n \n         for arg in &mut fn_abi.args {\n             let attrs = match arg.mode {\n-                PassMode::Ignore | PassMode::Indirect(_, None) => continue,\n+                PassMode::Ignore\n+                | PassMode::Indirect { attrs: _, extra_attrs: None, on_stack: _ } => {\n+                    continue;\n+                }\n                 PassMode::Direct(ref mut attrs) => attrs,\n-                PassMode::Pair(..) | PassMode::Indirect(_, Some(_)) | PassMode::Cast(_) => {\n+                PassMode::Pair(..)\n+                | PassMode::Indirect { attrs: _, extra_attrs: Some(_), on_stack: _ }\n+                | PassMode::Cast(_) => {\n                     unreachable!(\"x86 shouldn't be passing arguments by {:?}\", arg.mode)\n                 }\n             };"}, {"sha": "b9490c44f4b25867a68d9336499e60259fd30bc4", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -62,6 +62,13 @@\n //! T` obtained from [`Box::<T>::into_raw`] may be deallocated using the\n //! [`Global`] allocator with [`Layout::for_value(&*value)`].\n //!\n+//! For zero-sized values, the `Box` pointer still has to be [valid] for reads\n+//! and writes and sufficiently aligned. In particular, casting any aligned\n+//! non-zero integer literal to a raw pointer produces a valid pointer, but a\n+//! pointer pointing into previously allocated memory that since got freed is\n+//! not valid. The recommended way to build a Box to a ZST if `Box::new` cannot\n+//! be used is to use [`ptr::NonNull::dangling`].\n+//!\n //! So long as `T: Sized`, a `Box<T>` is guaranteed to be represented\n //! as a single pointer and is also ABI-compatible with C pointers\n //! (i.e. the C type `T*`). This means that if you have extern \"C\"\n@@ -125,6 +132,7 @@\n //! [`Global`]: crate::alloc::Global\n //! [`Layout`]: crate::alloc::Layout\n //! [`Layout::for_value(&*value)`]: crate::alloc::Layout::for_value\n+//! [valid]: ptr#safety\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -530,7 +538,10 @@ impl<T: ?Sized> Box<T> {\n     /// memory problems. For example, a double-free may occur if the\n     /// function is called twice on the same raw pointer.\n     ///\n+    /// The safety conditions are described in the [memory layout] section.\n+    ///\n     /// # Examples\n+    ///\n     /// Recreate a `Box` which was previously converted to a raw pointer\n     /// using [`Box::into_raw`]:\n     /// ```"}, {"sha": "27d49529a5ec20f13702df386b892c9d09e9ba06", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -16,12 +16,16 @@\n //! provided at this point are very minimal:\n //!\n //! * A [null] pointer is *never* valid, not even for accesses of [size zero][zst].\n-//! * All pointers (except for the null pointer) are valid for all operations of\n-//!   [size zero][zst].\n //! * For a pointer to be valid, it is necessary, but not always sufficient, that the pointer\n //!   be *dereferenceable*: the memory range of the given size starting at the pointer must all be\n //!   within the bounds of a single allocated object. Note that in Rust,\n //!   every (stack-allocated) variable is considered a separate allocated object.\n+//! * Even for operations of [size zero][zst], the pointer must not be pointing to deallocated\n+//!   memory, i.e., deallocation makes pointers invalid even for zero-sized operations. However,\n+//!   casting any non-zero integer *literal* to a pointer is valid for zero-sized accesses, even if\n+//!   some memory happens to exist at that address and gets deallocated. This corresponds to writing\n+//!   your own allocator: allocating zero-sized objects is not very hard. The canonical way to\n+//!   obtain a pointer that is valid for zero-sized accesses is [`NonNull::dangling`].\n //! * All accesses performed by functions in this module are *non-atomic* in the sense\n //!   of [atomic operations] used to synchronize between threads. This means it is\n //!   undefined behavior to perform two concurrent accesses to the same location from different"}, {"sha": "d58a88957df22294e2021cf39f1fce04e03c8284", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 64, "deletions": 121, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -231,21 +231,14 @@ impl Clean<Item> for doctree::Module<'_> {\n         let mut items: Vec<Item> = vec![];\n         items.extend(self.extern_crates.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.imports.iter().flat_map(|x| x.clean(cx)));\n-        items.extend(self.structs.iter().map(|x| x.clean(cx)));\n-        items.extend(self.unions.iter().map(|x| x.clean(cx)));\n-        items.extend(self.enums.iter().map(|x| x.clean(cx)));\n         items.extend(self.fns.iter().map(|x| x.clean(cx)));\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n-        items.extend(self.typedefs.iter().map(|x| x.clean(cx)));\n-        items.extend(self.opaque_tys.iter().map(|x| x.clean(cx)));\n-        items.extend(self.statics.iter().map(|x| x.clean(cx)));\n-        items.extend(self.constants.iter().map(|x| x.clean(cx)));\n+        items.extend(self.items.iter().map(|x| x.clean(cx)));\n         items.extend(self.traits.iter().map(|x| x.clean(cx)));\n         items.extend(self.impls.iter().flat_map(|x| x.clean(cx)));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n         items.extend(self.proc_macros.iter().map(|x| x.clean(cx)));\n-        items.extend(self.trait_aliases.iter().map(|x| x.clean(cx)));\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n@@ -1020,20 +1013,6 @@ impl Clean<Item> for doctree::Trait<'_> {\n     }\n }\n \n-impl Clean<Item> for doctree::TraitAlias<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            TraitAliasItem(TraitAlias {\n-                generics: self.generics.clean(cx),\n-                bounds: self.bounds.clean(cx),\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl Clean<bool> for hir::IsAuto {\n     fn clean(&self, _: &DocContext<'_>) -> bool {\n         match *self {\n@@ -1777,38 +1756,6 @@ impl Clean<Visibility> for ty::Visibility {\n     }\n }\n \n-impl Clean<Item> for doctree::Struct<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            StructItem(Struct {\n-                struct_type: self.struct_type,\n-                generics: self.generics.clean(cx),\n-                fields: self.fields.clean(cx),\n-                fields_stripped: false,\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n-impl Clean<Item> for doctree::Union<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            UnionItem(Union {\n-                struct_type: self.struct_type,\n-                generics: self.generics.clean(cx),\n-                fields: self.fields.clean(cx),\n-                fields_stripped: false,\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> VariantStruct {\n         VariantStruct {\n@@ -1819,21 +1766,6 @@ impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n     }\n }\n \n-impl Clean<Item> for doctree::Enum<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            EnumItem(Enum {\n-                variants: self.variants.iter().map(|v| v.clean(cx)).collect(),\n-                generics: self.generics.clean(cx),\n-                variants_stripped: false,\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl Clean<Item> for doctree::Variant<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n         let what_rustc_thinks = Item::from_hir_id_and_parts(\n@@ -1981,33 +1913,6 @@ impl Clean<String> for Symbol {\n     }\n }\n \n-impl Clean<Item> for doctree::Typedef<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let type_ = self.ty.clean(cx);\n-        let item_type = type_.def_id().and_then(|did| inline::build_ty(cx, did));\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            TypedefItem(Typedef { type_, generics: self.gen.clean(cx), item_type }, false),\n-            cx,\n-        )\n-    }\n-}\n-\n-impl Clean<Item> for doctree::OpaqueTy<'_> {\n-    fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            OpaqueTyItem(OpaqueTy {\n-                bounds: self.opaque_ty.bounds.clean(cx),\n-                generics: self.opaque_ty.generics.clean(cx),\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, || {\n@@ -2017,37 +1922,75 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     }\n }\n \n-impl Clean<Item> for doctree::Static<'_> {\n+impl Clean<Item> for (&hir::Item<'_>, Option<Ident>) {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        debug!(\"cleaning static {}: {:?}\", self.name.clean(cx), self);\n-        Item::from_hir_id_and_parts(\n-            self.id,\n-            Some(self.name),\n-            StaticItem(Static {\n-                type_: self.type_.clean(cx),\n-                mutability: self.mutability,\n-                expr: print_const_expr(cx, self.expr),\n+        use hir::ItemKind;\n+\n+        let (item, renamed) = self;\n+        let def_id = cx.tcx.hir().local_def_id(item.hir_id).to_def_id();\n+        let name = match renamed {\n+            Some(ident) => ident.name,\n+            None => cx.tcx.hir().name(item.hir_id),\n+        };\n+        let kind = match item.kind {\n+            ItemKind::Static(ty, mutability, body_id) => StaticItem(Static {\n+                type_: ty.clean(cx),\n+                mutability,\n+                expr: print_const_expr(cx, body_id),\n             }),\n-            cx,\n-        )\n+            ItemKind::Const(ty, body_id) => ConstantItem(Constant {\n+                type_: ty.clean(cx),\n+                expr: print_const_expr(cx, body_id),\n+                value: print_evaluated_const(cx, def_id),\n+                is_literal: is_literal_expr(cx, body_id.hir_id),\n+            }),\n+            ItemKind::OpaqueTy(ref ty) => OpaqueTyItem(OpaqueTy {\n+                bounds: ty.bounds.clean(cx),\n+                generics: ty.generics.clean(cx),\n+            }),\n+            ItemKind::TyAlias(ty, ref generics) => {\n+                let rustdoc_ty = ty.clean(cx);\n+                let item_type = rustdoc_ty.def_id().and_then(|did| inline::build_ty(cx, did));\n+                TypedefItem(\n+                    Typedef { type_: rustdoc_ty, generics: generics.clean(cx), item_type },\n+                    false,\n+                )\n+            }\n+            ItemKind::Enum(ref def, ref generics) => EnumItem(Enum {\n+                variants: def.variants.iter().map(|v| v.clean(cx)).collect(),\n+                generics: generics.clean(cx),\n+                variants_stripped: false,\n+            }),\n+            ItemKind::TraitAlias(ref generics, bounds) => TraitAliasItem(TraitAlias {\n+                generics: generics.clean(cx),\n+                bounds: bounds.clean(cx),\n+            }),\n+            ItemKind::Union(ref variant_data, ref generics) => UnionItem(Union {\n+                struct_type: doctree::struct_type_from_def(&variant_data),\n+                generics: generics.clean(cx),\n+                fields: variant_data.fields().clean(cx),\n+                fields_stripped: false,\n+            }),\n+            ItemKind::Struct(ref variant_data, ref generics) => StructItem(Struct {\n+                struct_type: doctree::struct_type_from_def(&variant_data),\n+                generics: generics.clean(cx),\n+                fields: variant_data.fields().clean(cx),\n+                fields_stripped: false,\n+            }),\n+            _ => unreachable!(\"not yet converted\"),\n+        };\n+\n+        Item::from_def_id_and_parts(def_id, Some(name), kind, cx)\n     }\n }\n \n-impl Clean<Item> for doctree::Constant<'_> {\n+impl Clean<Item> for hir::Variant<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Item {\n-        let def_id = cx.tcx.hir().local_def_id(self.id).to_def_id();\n-\n-        Item::from_def_id_and_parts(\n-            def_id,\n-            Some(self.name),\n-            ConstantItem(Constant {\n-                type_: self.type_.clean(cx),\n-                expr: print_const_expr(cx, self.expr),\n-                value: print_evaluated_const(cx, def_id),\n-                is_literal: is_literal_expr(cx, self.expr.hir_id),\n-            }),\n-            cx,\n-        )\n+        let kind = VariantItem(Variant { kind: self.data.clean(cx) });\n+        let what_rustc_thinks =\n+            Item::from_hir_id_and_parts(self.id, Some(self.ident.name), kind, cx);\n+        // don't show `pub` for variants, which are always public\n+        Item { visibility: Inherited, ..what_rustc_thinks }\n     }\n }\n "}, {"sha": "d56328cc2aa08743c4f711335f2237142aba5128", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 4, "deletions": 79, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -4,7 +4,7 @@ crate use self::StructType::*;\n \n use rustc_ast as ast;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::{self, Span, Symbol};\n+use rustc_span::{self, symbol::Ident, Span, Symbol};\n \n use rustc_hir as hir;\n use rustc_hir::def_id::CrateNum;\n@@ -17,22 +17,16 @@ crate struct Module<'hir> {\n     crate where_inner: Span,\n     crate extern_crates: Vec<ExternCrate<'hir>>,\n     crate imports: Vec<Import<'hir>>,\n-    crate structs: Vec<Struct<'hir>>,\n-    crate unions: Vec<Union<'hir>>,\n-    crate enums: Vec<Enum<'hir>>,\n     crate fns: Vec<Function<'hir>>,\n     crate mods: Vec<Module<'hir>>,\n     crate id: hir::HirId,\n-    crate typedefs: Vec<Typedef<'hir>>,\n-    crate opaque_tys: Vec<OpaqueTy<'hir>>,\n-    crate statics: Vec<Static<'hir>>,\n-    crate constants: Vec<Constant<'hir>>,\n+    // (item, renamed)\n+    crate items: Vec<(&'hir hir::Item<'hir>, Option<Ident>)>,\n     crate traits: Vec<Trait<'hir>>,\n     crate impls: Vec<Impl<'hir>>,\n     crate foreigns: Vec<ForeignItem<'hir>>,\n     crate macros: Vec<Macro>,\n     crate proc_macros: Vec<ProcMacro>,\n-    crate trait_aliases: Vec<TraitAlias<'hir>>,\n     crate is_crate: bool,\n }\n \n@@ -46,21 +40,14 @@ impl Module<'hir> {\n             attrs,\n             extern_crates: Vec::new(),\n             imports: Vec::new(),\n-            structs: Vec::new(),\n-            unions: Vec::new(),\n-            enums: Vec::new(),\n             fns: Vec::new(),\n             mods: Vec::new(),\n-            typedefs: Vec::new(),\n-            opaque_tys: Vec::new(),\n-            statics: Vec::new(),\n-            constants: Vec::new(),\n+            items: Vec::new(),\n             traits: Vec::new(),\n             impls: Vec::new(),\n             foreigns: Vec::new(),\n             macros: Vec::new(),\n             proc_macros: Vec::new(),\n-            trait_aliases: Vec::new(),\n             is_crate: false,\n         }\n     }\n@@ -76,29 +63,6 @@ crate enum StructType {\n     Unit,\n }\n \n-crate struct Struct<'hir> {\n-    crate id: hir::HirId,\n-    crate struct_type: StructType,\n-    crate name: Symbol,\n-    crate generics: &'hir hir::Generics<'hir>,\n-    crate fields: &'hir [hir::StructField<'hir>],\n-}\n-\n-crate struct Union<'hir> {\n-    crate id: hir::HirId,\n-    crate struct_type: StructType,\n-    crate name: Symbol,\n-    crate generics: &'hir hir::Generics<'hir>,\n-    crate fields: &'hir [hir::StructField<'hir>],\n-}\n-\n-crate struct Enum<'hir> {\n-    crate variants: Vec<Variant<'hir>>,\n-    crate generics: &'hir hir::Generics<'hir>,\n-    crate id: hir::HirId,\n-    crate name: Symbol,\n-}\n-\n crate struct Variant<'hir> {\n     crate name: Symbol,\n     crate id: hir::HirId,\n@@ -114,38 +78,6 @@ crate struct Function<'hir> {\n     crate body: hir::BodyId,\n }\n \n-crate struct Typedef<'hir> {\n-    crate ty: &'hir hir::Ty<'hir>,\n-    crate gen: &'hir hir::Generics<'hir>,\n-    crate name: Symbol,\n-    crate id: hir::HirId,\n-}\n-\n-crate struct OpaqueTy<'hir> {\n-    crate opaque_ty: &'hir hir::OpaqueTy<'hir>,\n-    crate name: Symbol,\n-    crate id: hir::HirId,\n-}\n-\n-#[derive(Debug)]\n-crate struct Static<'hir> {\n-    crate type_: &'hir hir::Ty<'hir>,\n-    crate mutability: hir::Mutability,\n-    crate expr: hir::BodyId,\n-    crate name: Symbol,\n-    crate attrs: &'hir [ast::Attribute],\n-    crate vis: &'hir hir::Visibility<'hir>,\n-    crate id: hir::HirId,\n-    crate span: Span,\n-}\n-\n-crate struct Constant<'hir> {\n-    crate type_: &'hir hir::Ty<'hir>,\n-    crate expr: hir::BodyId,\n-    crate name: Symbol,\n-    crate id: hir::HirId,\n-}\n-\n crate struct Trait<'hir> {\n     crate is_auto: hir::IsAuto,\n     crate unsafety: hir::Unsafety,\n@@ -157,13 +89,6 @@ crate struct Trait<'hir> {\n     crate id: hir::HirId,\n }\n \n-crate struct TraitAlias<'hir> {\n-    crate name: Symbol,\n-    crate generics: &'hir hir::Generics<'hir>,\n-    crate bounds: &'hir [hir::GenericBound<'hir>],\n-    crate id: hir::HirId,\n-}\n-\n #[derive(Debug)]\n crate struct Impl<'hir> {\n     crate unsafety: hir::Unsafety,"}, {"sha": "fd09ba04b3db92fdac4e636827ca3cac0c73bbae", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -492,7 +492,14 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             Res::PrimTy(prim) => Some(\n                 self.resolve_primitive_associated_item(prim, ns, module_id, item_name, item_str),\n             ),\n-            Res::Def(DefKind::Struct | DefKind::Union | DefKind::Enum | DefKind::TyAlias, did) => {\n+            Res::Def(\n+                DefKind::Struct\n+                | DefKind::Union\n+                | DefKind::Enum\n+                | DefKind::TyAlias\n+                | DefKind::ForeignTy,\n+                did,\n+            ) => {\n                 debug!(\"looking for associated item named {} for item {:?}\", item_name, did);\n                 // Checks if item_name belongs to `impl SomeItem`\n                 let assoc_item = cx"}, {"sha": "c55e5f7690c14da2a4e8310ed258f6f8f15f1139", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 9, "deletions": 82, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -82,50 +82,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         module\n     }\n \n-    fn visit_variant_data(\n-        &mut self,\n-        item: &'tcx hir::Item<'_>,\n-        name: Symbol,\n-        sd: &'tcx hir::VariantData<'_>,\n-        generics: &'tcx hir::Generics<'_>,\n-    ) -> Struct<'tcx> {\n-        debug!(\"visiting struct\");\n-        let struct_type = struct_type_from_def(&*sd);\n-        Struct { id: item.hir_id, struct_type, name, generics, fields: sd.fields() }\n-    }\n-\n-    fn visit_union_data(\n-        &mut self,\n-        item: &'tcx hir::Item<'_>,\n-        name: Symbol,\n-        sd: &'tcx hir::VariantData<'_>,\n-        generics: &'tcx hir::Generics<'_>,\n-    ) -> Union<'tcx> {\n-        debug!(\"visiting union\");\n-        let struct_type = struct_type_from_def(&*sd);\n-        Union { id: item.hir_id, struct_type, name, generics, fields: sd.fields() }\n-    }\n-\n-    fn visit_enum_def(\n-        &mut self,\n-        it: &'tcx hir::Item<'_>,\n-        name: Symbol,\n-        def: &'tcx hir::EnumDef<'_>,\n-        generics: &'tcx hir::Generics<'_>,\n-    ) -> Enum<'tcx> {\n-        debug!(\"visiting enum\");\n-        Enum {\n-            name,\n-            variants: def\n-                .variants\n-                .iter()\n-                .map(|v| Variant { name: v.ident.name, id: v.id, def: &v.data })\n-                .collect(),\n-            generics,\n-            id: it.hir_id,\n-        }\n-    }\n-\n     fn visit_fn(\n         &mut self,\n         om: &mut Module<'tcx>,\n@@ -414,45 +370,21 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     Some(ident.name),\n                 ));\n             }\n-            hir::ItemKind::Enum(ref ed, ref gen) => {\n-                om.enums.push(self.visit_enum_def(item, ident.name, ed, gen))\n-            }\n-            hir::ItemKind::Struct(ref sd, ref gen) => {\n-                om.structs.push(self.visit_variant_data(item, ident.name, sd, gen))\n-            }\n-            hir::ItemKind::Union(ref sd, ref gen) => {\n-                om.unions.push(self.visit_union_data(item, ident.name, sd, gen))\n-            }\n             hir::ItemKind::Fn(ref sig, ref gen, body) => {\n                 self.visit_fn(om, item, ident.name, &sig.decl, sig.header, gen, body)\n             }\n-            hir::ItemKind::TyAlias(ty, ref gen) => {\n-                let t = Typedef { ty, gen, name: ident.name, id: item.hir_id };\n-                om.typedefs.push(t);\n-            }\n-            hir::ItemKind::OpaqueTy(ref opaque_ty) => {\n-                let t = OpaqueTy { opaque_ty, name: ident.name, id: item.hir_id };\n-                om.opaque_tys.push(t);\n-            }\n-            hir::ItemKind::Static(type_, mutability, expr) => {\n-                let s = Static {\n-                    type_,\n-                    mutability,\n-                    expr,\n-                    id: item.hir_id,\n-                    name: ident.name,\n-                    attrs: &item.attrs,\n-                    span: item.span,\n-                    vis: &item.vis,\n-                };\n-                om.statics.push(s);\n-            }\n-            hir::ItemKind::Const(type_, expr) => {\n+            hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Struct(..)\n+            | hir::ItemKind::Union(..)\n+            | hir::ItemKind::TyAlias(..)\n+            | hir::ItemKind::OpaqueTy(..)\n+            | hir::ItemKind::Static(..)\n+            | hir::ItemKind::TraitAlias(..) => om.items.push((item, renamed)),\n+            hir::ItemKind::Const(..) => {\n                 // Underscore constants do not correspond to a nameable item and\n                 // so are never useful in documentation.\n                 if ident.name != kw::Underscore {\n-                    let s = Constant { type_, expr, id: item.hir_id, name: ident.name };\n-                    om.constants.push(s);\n+                    om.items.push((item, renamed));\n                 }\n             }\n             hir::ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n@@ -469,11 +401,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.traits.push(t);\n             }\n-            hir::ItemKind::TraitAlias(ref generics, ref bounds) => {\n-                let t = TraitAlias { name: ident.name, generics, bounds, id: item.hir_id };\n-                om.trait_aliases.push(t);\n-            }\n-\n             hir::ItemKind::Impl {\n                 unsafety,\n                 polarity,"}, {"sha": "3372304f44a3dc72c916957910e823f3d817bb2f", "filename": "src/test/rustdoc-ui/doc-without-codeblock.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoc-without-codeblock.stderr?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -16,12 +16,6 @@ note: the lint level is defined here\n LL | #![deny(missing_doc_code_examples)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: missing code example in this documentation\n-  --> $DIR/doc-without-codeblock.rs:3:1\n-   |\n-LL | /// Some docs.\n-   | ^^^^^^^^^^^^^^\n-\n error: missing code example in this documentation\n   --> $DIR/doc-without-codeblock.rs:7:1\n    |\n@@ -34,5 +28,11 @@ error: missing code example in this documentation\n LL |     /// Or maybe not because she saved herself!\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: missing code example in this documentation\n+  --> $DIR/doc-without-codeblock.rs:3:1\n+   |\n+LL | /// Some docs.\n+   | ^^^^^^^^^^^^^^\n+\n error: aborting due to 4 previous errors\n "}, {"sha": "936055da01cf741be71a7e3e0455cc60c2581d9e", "filename": "src/test/rustdoc-ui/intra-links-ambiguity.stderr", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -1,14 +1,29 @@\n-error: `ambiguous` is both a struct and a function\n-  --> $DIR/intra-links-ambiguity.rs:27:6\n+error: `true` is both a module and a builtin type\n+  --> $DIR/intra-links-ambiguity.rs:38:6\n    |\n-LL | /// [`ambiguous`] is ambiguous.\n-   |      ^^^^^^^^^^^ ambiguous link\n+LL | /// [true]\n+   |      ^^^^ ambiguous link\n    |\n note: the lint level is defined here\n   --> $DIR/intra-links-ambiguity.rs:1:9\n    |\n LL | #![deny(broken_intra_doc_links)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n+help: to link to the module, prefix with `mod@`\n+   |\n+LL | /// [mod@true]\n+   |      ^^^^^^^^\n+help: to link to the builtin type, prefix with `prim@`\n+   |\n+LL | /// [prim@true]\n+   |      ^^^^^^^^^\n+\n+error: `ambiguous` is both a struct and a function\n+  --> $DIR/intra-links-ambiguity.rs:27:6\n+   |\n+LL | /// [`ambiguous`] is ambiguous.\n+   |      ^^^^^^^^^^^ ambiguous link\n+   |\n help: to link to the struct, prefix with `struct@`\n    |\n LL | /// [`struct@ambiguous`] is ambiguous.\n@@ -82,20 +97,5 @@ help: to link to the function, add parentheses\n LL | /// Ambiguous non-implied shortcut link [`foo::bar()`].\n    |                                          ^^^^^^^^^^^^\n \n-error: `true` is both a module and a builtin type\n-  --> $DIR/intra-links-ambiguity.rs:38:6\n-   |\n-LL | /// [true]\n-   |      ^^^^ ambiguous link\n-   |\n-help: to link to the module, prefix with `mod@`\n-   |\n-LL | /// [mod@true]\n-   |      ^^^^^^^^\n-help: to link to the builtin type, prefix with `prim@`\n-   |\n-LL | /// [prim@true]\n-   |      ^^^^^^^^^\n-\n error: aborting due to 6 previous errors\n "}, {"sha": "bf437a7cf4674bf931ac3acb3f2ae601775a5978", "filename": "src/test/rustdoc-ui/intra-links-warning.stderr", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-warning.stderr?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -36,6 +36,60 @@ warning: unresolved link to `Qux::Z`\n LL |       //! , [Uniooon::X] and [Qux::Z].\n    |                               ^^^^^^ no item named `Qux` in scope\n \n+warning: unresolved link to `BarA`\n+  --> $DIR/intra-links-warning.rs:21:10\n+   |\n+LL | /// bar [BarA] bar\n+   |          ^^^^ no item named `BarA` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+warning: unresolved link to `BarB`\n+  --> $DIR/intra-links-warning.rs:27:9\n+   |\n+LL |  * bar [BarB] bar\n+   |         ^^^^ no item named `BarB` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+warning: unresolved link to `BarC`\n+  --> $DIR/intra-links-warning.rs:34:6\n+   |\n+LL | bar [BarC] bar\n+   |      ^^^^ no item named `BarC` in scope\n+   |\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+warning: unresolved link to `BarD`\n+  --> $DIR/intra-links-warning.rs:45:1\n+   |\n+LL | #[doc = \"Foo\\nbar [BarD] bar\\nbaz\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the link appears in this line:\n+           \n+           bar [BarD] bar\n+                ^^^^\n+   = note: no item named `BarD` in scope\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+\n+warning: unresolved link to `BarF`\n+  --> $DIR/intra-links-warning.rs:50:9\n+   |\n+LL |         #[doc = $f]\n+   |         ^^^^^^^^^^^\n+...\n+LL | f!(\"Foo\\nbar [BarF] bar\\nbaz\");\n+   | ------------------------------- in this macro invocation\n+   |\n+   = note: the link appears in this line:\n+           \n+           bar [BarF] bar\n+                ^^^^\n+   = note: no item named `BarF` in scope\n+   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n+   = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n warning: unresolved link to `Qux:Y`\n   --> $DIR/intra-links-warning.rs:14:13\n    |\n@@ -117,59 +171,5 @@ LL | /// docs [error2]\n    |\n    = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n \n-warning: unresolved link to `BarA`\n-  --> $DIR/intra-links-warning.rs:21:10\n-   |\n-LL | /// bar [BarA] bar\n-   |          ^^^^ no item named `BarA` in scope\n-   |\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n-\n-warning: unresolved link to `BarB`\n-  --> $DIR/intra-links-warning.rs:27:9\n-   |\n-LL |  * bar [BarB] bar\n-   |         ^^^^ no item named `BarB` in scope\n-   |\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n-\n-warning: unresolved link to `BarC`\n-  --> $DIR/intra-links-warning.rs:34:6\n-   |\n-LL | bar [BarC] bar\n-   |      ^^^^ no item named `BarC` in scope\n-   |\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n-\n-warning: unresolved link to `BarD`\n-  --> $DIR/intra-links-warning.rs:45:1\n-   |\n-LL | #[doc = \"Foo\\nbar [BarD] bar\\nbaz\"]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: the link appears in this line:\n-           \n-           bar [BarD] bar\n-                ^^^^\n-   = note: no item named `BarD` in scope\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n-\n-warning: unresolved link to `BarF`\n-  --> $DIR/intra-links-warning.rs:50:9\n-   |\n-LL |         #[doc = $f]\n-   |         ^^^^^^^^^^^\n-...\n-LL | f!(\"Foo\\nbar [BarF] bar\\nbaz\");\n-   | ------------------------------- in this macro invocation\n-   |\n-   = note: the link appears in this line:\n-           \n-           bar [BarF] bar\n-                ^^^^\n-   = note: no item named `BarF` in scope\n-   = help: to escape `[` and `]` characters, add '\\' before them like `\\[` or `\\]`\n-   = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n warning: 19 warnings emitted\n "}, {"sha": "e02ed4a056c128503dec0c5b2af88067fe8d2eae", "filename": "src/test/rustdoc-ui/lint-missing-doc-code-example.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Flint-missing-doc-code-example.stderr?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -1,8 +1,9 @@\n error: missing code example in this documentation\n-  --> $DIR/lint-missing-doc-code-example.rs:49:1\n+  --> $DIR/lint-missing-doc-code-example.rs:19:1\n    |\n-LL | /// Doc\n-   | ^^^^^^^\n+LL | / mod module1 {\n+LL | | }\n+   | |_^\n    |\n note: the lint level is defined here\n   --> $DIR/lint-missing-doc-code-example.rs:2:9\n@@ -11,29 +12,28 @@ LL | #![deny(missing_doc_code_examples)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: missing code example in this documentation\n-  --> $DIR/lint-missing-doc-code-example.rs:63:1\n+  --> $DIR/lint-missing-doc-code-example.rs:37:3\n    |\n-LL | /// Doc\n-   | ^^^^^^^\n+LL |   /// doc\n+   |   ^^^^^^^\n \n error: missing code example in this documentation\n-  --> $DIR/lint-missing-doc-code-example.rs:56:1\n+  --> $DIR/lint-missing-doc-code-example.rs:49:1\n    |\n LL | /// Doc\n    | ^^^^^^^\n \n error: missing code example in this documentation\n-  --> $DIR/lint-missing-doc-code-example.rs:19:1\n+  --> $DIR/lint-missing-doc-code-example.rs:56:1\n    |\n-LL | / mod module1 {\n-LL | | }\n-   | |_^\n+LL | /// Doc\n+   | ^^^^^^^\n \n error: missing code example in this documentation\n-  --> $DIR/lint-missing-doc-code-example.rs:37:3\n+  --> $DIR/lint-missing-doc-code-example.rs:63:1\n    |\n-LL |   /// doc\n-   |   ^^^^^^^\n+LL | /// Doc\n+   | ^^^^^^^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "418e0d91ea7ef8afa16d94071f67ff30caf354c1", "filename": "src/test/rustdoc/intra-link-extern-type.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Frustdoc%2Fintra-link-extern-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Frustdoc%2Fintra-link-extern-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-extern-type.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -0,0 +1,18 @@\n+#![feature(extern_types)]\n+\n+extern {\n+    pub type ExternType;\n+}\n+\n+impl ExternType {\n+    pub fn f(&self) {\n+\n+    }\n+}\n+\n+// @has 'intra_link_extern_type/foreigntype.ExternType.html'\n+// @has 'intra_link_extern_type/fn.links_to_extern_type.html' \\\n+// 'href=\"../intra_link_extern_type/foreigntype.ExternType.html#method.f\"'\n+/// See also [ExternType::f]\n+pub fn links_to_extern_type() {\n+}"}, {"sha": "504c0687c8dc299a6dc1580308c12a246947c795", "filename": "src/test/rustdoc/redirect-rename.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Frustdoc%2Fredirect-rename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Frustdoc%2Fredirect-rename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fredirect-rename.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -4,6 +4,10 @@ mod hidden {\n     // @has foo/hidden/struct.Foo.html\n     // @has - '//p/a' '../../foo/struct.FooBar.html'\n     pub struct Foo {}\n+    pub union U { a: usize }\n+    pub enum Empty {}\n+    pub const C: usize = 1;\n+    pub static S: usize = 1;\n \n     // @has foo/hidden/bar/index.html\n     // @has - '//p/a' '../../foo/baz/index.html'\n@@ -16,6 +20,14 @@ mod hidden {\n \n // @has foo/struct.FooBar.html\n pub use hidden::Foo as FooBar;\n+// @has foo/union.FooU.html\n+pub use hidden::U as FooU;\n+// @has foo/enum.FooEmpty.html\n+pub use hidden::Empty as FooEmpty;\n+// @has foo/constant.FooC.html\n+pub use hidden::C as FooC;\n+// @has foo/static.FooS.html\n+pub use hidden::S as FooS;\n \n // @has foo/baz/index.html\n // @has foo/baz/struct.Thing.html"}, {"sha": "58e0c387ffb9c19cd245747a1e31062f715cb835", "filename": "src/test/ui/consts/issue-79137-monomorphic.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Fui%2Fconsts%2Fissue-79137-monomorphic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Fui%2Fconsts%2Fissue-79137-monomorphic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-79137-monomorphic.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+\n+// Verify that variant count intrinsic can still evaluate for types like `Option<T>`.\n+\n+#![feature(variant_count)]\n+\n+pub struct GetVariantCount<T>(T);\n+\n+impl<T> GetVariantCount<T> {\n+    pub const VALUE: usize = std::mem::variant_count::<T>();\n+}\n+\n+const fn check_variant_count<T>() -> bool {\n+    matches!(GetVariantCount::<Option<T>>::VALUE, GetVariantCount::<Option<()>>::VALUE)\n+}\n+\n+fn main() {\n+    assert!(check_variant_count::<()>());\n+}"}, {"sha": "456035458cfc562945722ec16509d346a650bd65", "filename": "src/test/ui/consts/issue-79137-toogeneric.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Fui%2Fconsts%2Fissue-79137-toogeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Fui%2Fconsts%2Fissue-79137-toogeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-79137-toogeneric.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -0,0 +1,19 @@\n+// Test that `variant_count` only gets evaluated once the type is concrete enough.\n+\n+#![feature(variant_count)]\n+\n+pub struct GetVariantCount<T>(T);\n+\n+impl<T> GetVariantCount<T> {\n+    pub const VALUE: usize = std::mem::variant_count::<T>();\n+}\n+\n+const fn check_variant_count<T>() -> bool {\n+    matches!(GetVariantCount::<T>::VALUE, GetVariantCount::<T>::VALUE)\n+    //~^ ERROR constant pattern depends on a generic parameter\n+    //~| ERROR constant pattern depends on a generic parameter\n+}\n+\n+fn main() {\n+    assert!(check_variant_count::<Option<()>>());\n+}"}, {"sha": "579e6aa09bdbd34a250b7a5a8eee3c9c07b36a5a", "filename": "src/test/ui/consts/issue-79137-toogeneric.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Fui%2Fconsts%2Fissue-79137-toogeneric.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Fui%2Fconsts%2Fissue-79137-toogeneric.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-79137-toogeneric.stderr?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -0,0 +1,14 @@\n+error: constant pattern depends on a generic parameter\n+  --> $DIR/issue-79137-toogeneric.rs:12:43\n+   |\n+LL |     matches!(GetVariantCount::<T>::VALUE, GetVariantCount::<T>::VALUE)\n+   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: constant pattern depends on a generic parameter\n+  --> $DIR/issue-79137-toogeneric.rs:12:43\n+   |\n+LL |     matches!(GetVariantCount::<T>::VALUE, GetVariantCount::<T>::VALUE)\n+   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "8a96303e6b904e3d389ef4ed3966d3a12039db2b", "filename": "src/test/ui/mir/mir-inlining/array-clone-with-generic-size.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Farray-clone-with-generic-size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da384694807172f0ca40eca2e49a11688aba6e93/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Farray-clone-with-generic-size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Fmir-inlining%2Farray-clone-with-generic-size.rs?ref=da384694807172f0ca40eca2e49a11688aba6e93", "patch": "@@ -0,0 +1,13 @@\n+// Checks that we can build a clone shim for array with generic size.\n+// Regression test for issue #79269.\n+//\n+// build-pass\n+// compile-flags: -Zmir-opt-level=2 -Zvalidate-mir\n+#![feature(min_const_generics)]\n+\n+#[derive(Clone)]\n+struct Array<T, const N: usize>([T; N]);\n+\n+fn main() {\n+    let _ = Array([0u32, 1u32, 2u32]).clone();\n+}"}]}