{"sha": "64bcb326516ef7490db46de88b87a4c0990097fe", "node_id": "C_kwDOAAsO6NoAKDY0YmNiMzI2NTE2ZWY3NDkwZGI0NmRlODhiODdhNGMwOTkwMDk3ZmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-24T10:03:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-24T10:03:12Z"}, "message": "Auto merge of #110752 - matthiaskrgr:rollup-959s77u, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #110255 (Suggest using integration tests for test crate using own proc-macro)\n - #110514 (Remove `find_map_relevant_impl`)\n - #110566 (Don't create projection ty for const projection)\n - #110637 (Group some sections of our logs in github actions)\n - #110706 (Add `intrinsics::transmute_unchecked`)\n - #110714 (Normalize types and consts in MIR opts.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e29965e59cfdd41bd229d7142a55d549965122f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e29965e59cfdd41bd229d7142a55d549965122f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64bcb326516ef7490db46de88b87a4c0990097fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64bcb326516ef7490db46de88b87a4c0990097fe", "html_url": "https://github.com/rust-lang/rust/commit/64bcb326516ef7490db46de88b87a4c0990097fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64bcb326516ef7490db46de88b87a4c0990097fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f65615f02d22b85e9205f2716ab36182d34bab2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f65615f02d22b85e9205f2716ab36182d34bab2b", "html_url": "https://github.com/rust-lang/rust/commit/f65615f02d22b85e9205f2716ab36182d34bab2b"}, {"sha": "2ce9b574a40ff27980578aa7ad7843dacc32acb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ce9b574a40ff27980578aa7ad7843dacc32acb7", "html_url": "https://github.com/rust-lang/rust/commit/2ce9b574a40ff27980578aa7ad7843dacc32acb7"}], "stats": {"total": 904, "additions": 509, "deletions": 395}, "files": [{"sha": "0fcbaa2efabb865ac99999b0a99999974a9ebcf6", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -198,7 +198,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             | sym::assert_zero_valid\n             | sym::assert_mem_uninitialized_valid => (1, Vec::new(), tcx.mk_unit()),\n             sym::forget => (1, vec![param(0)], tcx.mk_unit()),\n-            sym::transmute => (2, vec![param(0)], param(1)),\n+            sym::transmute | sym::transmute_unchecked => (2, vec![param(0)], param(1)),\n             sym::prefetch_read_data\n             | sym::prefetch_write_data\n             | sym::prefetch_read_instruction"}, {"sha": "e61037e5ea86fbbf2d30b021f9982bd61070f21d", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 18, "deletions": 44, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -139,40 +139,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         treat_projections: TreatProjections,\n         mut f: impl FnMut(DefId),\n     ) {\n-        let _: Option<()> =\n-            self.find_map_relevant_impl(trait_def_id, self_ty, treat_projections, |did| {\n-                f(did);\n-                None\n-            });\n-    }\n-\n-    /// `trait_def_id` MUST BE the `DefId` of a trait.\n-    pub fn non_blanket_impls_for_ty(\n-        self,\n-        trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n-    ) -> impl Iterator<Item = DefId> + 'tcx {\n-        let impls = self.trait_impls_of(trait_def_id);\n-        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsCandidateKey) {\n-            if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n-                return impls.iter().copied();\n-            }\n-        }\n-\n-        [].iter().copied()\n-    }\n-\n-    /// Applies function to every impl that could possibly match the self type `self_ty` and returns\n-    /// the first non-none value.\n-    ///\n-    /// `trait_def_id` MUST BE the `DefId` of a trait.\n-    pub fn find_map_relevant_impl<T>(\n-        self,\n-        trait_def_id: DefId,\n-        self_ty: Ty<'tcx>,\n-        treat_projections: TreatProjections,\n-        mut f: impl FnMut(DefId) -> Option<T>,\n-    ) -> Option<T> {\n         // FIXME: This depends on the set of all impls for the trait. That is\n         // unfortunate wrt. incremental compilation.\n         //\n@@ -181,9 +147,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let impls = self.trait_impls_of(trait_def_id);\n \n         for &impl_def_id in impls.blanket_impls.iter() {\n-            if let result @ Some(_) = f(impl_def_id) {\n-                return result;\n-            }\n+            f(impl_def_id);\n         }\n \n         // Note that we're using `TreatParams::ForLookup` to query `non_blanket_impls` while using\n@@ -199,20 +163,30 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(simp) = fast_reject::simplify_type(self, self_ty, treat_params) {\n             if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n                 for &impl_def_id in impls {\n-                    if let result @ Some(_) = f(impl_def_id) {\n-                        return result;\n-                    }\n+                    f(impl_def_id);\n                 }\n             }\n         } else {\n             for &impl_def_id in impls.non_blanket_impls.values().flatten() {\n-                if let result @ Some(_) = f(impl_def_id) {\n-                    return result;\n-                }\n+                f(impl_def_id);\n             }\n         }\n+    }\n \n-        None\n+    /// `trait_def_id` MUST BE the `DefId` of a trait.\n+    pub fn non_blanket_impls_for_ty(\n+        self,\n+        trait_def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+    ) -> impl Iterator<Item = DefId> + 'tcx {\n+        let impls = self.trait_impls_of(trait_def_id);\n+        if let Some(simp) = fast_reject::simplify_type(self, self_ty, TreatParams::AsCandidateKey) {\n+            if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n+                return impls.iter().copied();\n+            }\n+        }\n+\n+        [].iter().copied()\n     }\n \n     /// Returns an iterator containing all impls for `trait_def_id`."}, {"sha": "9dbd9fbbb5bb3d23029eceaa27262428b4a91416", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -2,7 +2,6 @@\n \n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir;\n-use crate::ty::fast_reject::TreatProjections;\n use crate::ty::layout::IntegerExt;\n use crate::ty::{\n     self, FallibleTypeFolder, ToPredicate, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n@@ -359,21 +358,29 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.ensure().coherent_trait(drop_trait);\n \n         let ty = self.type_of(adt_did).subst_identity();\n-        let (did, constness) = self.find_map_relevant_impl(\n-            drop_trait,\n-            ty,\n-            // FIXME: This could also be some other mode, like \"unexpected\"\n-            TreatProjections::ForLookup,\n-            |impl_did| {\n-                if let Some(item_id) = self.associated_item_def_ids(impl_did).first() {\n-                    if validate(self, impl_did).is_ok() {\n-                        return Some((*item_id, self.constness(impl_did)));\n-                    }\n-                }\n-                None\n-            },\n-        )?;\n+        let mut dtor_candidate = None;\n+        self.for_each_relevant_impl(drop_trait, ty, |impl_did| {\n+            let Some(item_id) = self.associated_item_def_ids(impl_did).first() else {\n+                self.sess.delay_span_bug(self.def_span(impl_did), \"Drop impl without drop function\");\n+                return;\n+            };\n+\n+            if validate(self, impl_did).is_err() {\n+                // Already `ErrorGuaranteed`, no need to delay a span bug here.\n+                return;\n+            }\n+\n+            if let Some((old_item_id, _)) = dtor_candidate {\n+                self.sess\n+                    .struct_span_err(self.def_span(item_id), \"multiple drop impls found\")\n+                    .span_note(self.def_span(old_item_id), \"other impl here\")\n+                    .delay_as_bug();\n+            }\n+\n+            dtor_candidate = Some((*item_id, self.constness(impl_did)));\n+        });\n \n+        let (did, constness) = dtor_candidate?;\n         Some(ty::Destructor { did, constness })\n     }\n "}, {"sha": "c0861f99620d1faddf629f93b694d6e565ae3e77", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -323,7 +323,7 @@ impl<'tcx> std::fmt::Debug for ScalarTy<'tcx> {\n \n impl<'a, 'tcx> ConstAnalysis<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, map: Map) -> Self {\n-        let param_env = tcx.param_env(body.source.def_id());\n+        let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n         Self {\n             map,\n             tcx,"}, {"sha": "430a6f6cef5be4cb0c38fb2828fbfe931f3090fc", "filename": "compiler/rustc_mir_transform/src/large_enums.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flarge_enums.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -120,7 +120,7 @@ impl EnumSizeOpt {\n     fn optim<'tcx>(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let mut alloc_cache = FxHashMap::default();\n         let body_did = body.source.def_id();\n-        let param_env = tcx.param_env(body_did);\n+        let param_env = tcx.param_env_reveal_all_normalized(body_did);\n \n         let blocks = body.basic_blocks.as_mut();\n         let local_decls = &mut body.local_decls;"}, {"sha": "c7d3f6c9f044c1ded059b4ac5af09a170673dfe5", "filename": "compiler/rustc_mir_transform/src/lower_intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_intrinsics.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -221,7 +221,7 @@ impl<'tcx> MirPass<'tcx> for LowerIntrinsics {\n                             terminator.kind = TerminatorKind::Goto { target };\n                         }\n                     }\n-                    sym::transmute => {\n+                    sym::transmute | sym::transmute_unchecked => {\n                         let dst_ty = destination.ty(local_decls, tcx).ty;\n                         let Ok([arg]) = <[_; 1]>::try_from(std::mem::take(args)) else {\n                             span_bug!("}, {"sha": "59942dc76f9aa9c836f6a20116f27ad2b4ea2d01", "filename": "compiler/rustc_mir_transform/src/match_branches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fmatch_branches.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         let def_id = body.source.def_id();\n-        let param_env = tcx.param_env(def_id);\n+        let param_env = tcx.param_env_reveal_all_normalized(def_id);\n \n         let bbs = body.basic_blocks.as_mut();\n         let mut should_cleanup = false;"}, {"sha": "23442f8b97b7ee0a74fcb8243fd1a5dc7aa883bb", "filename": "compiler/rustc_mir_transform/src/reveal_all.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Freveal_all.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -34,11 +34,23 @@ impl<'tcx> MutVisitor<'tcx> for RevealAllVisitor<'tcx> {\n         self.tcx\n     }\n \n+    #[inline]\n+    fn visit_constant(&mut self, constant: &mut Constant<'tcx>, _: Location) {\n+        // We have to use `try_normalize_erasing_regions` here, since it's\n+        // possible that we visit impossible-to-satisfy where clauses here,\n+        // see #91745\n+        if let Ok(c) = self.tcx.try_normalize_erasing_regions(self.param_env, constant.literal) {\n+            constant.literal = c;\n+        }\n+    }\n+\n     #[inline]\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, _: TyContext) {\n         // We have to use `try_normalize_erasing_regions` here, since it's\n         // possible that we visit impossible-to-satisfy where clauses here,\n         // see #91745\n-        *ty = self.tcx.try_normalize_erasing_regions(self.param_env, *ty).unwrap_or(*ty);\n+        if let Ok(t) = self.tcx.try_normalize_erasing_regions(self.param_env, *ty) {\n+            *ty = t;\n+        }\n     }\n }"}, {"sha": "d4debae5c581a9004a46874bdd33754372730f3a", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -355,7 +355,7 @@ fn build_thread_local_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'t\n fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -> Body<'tcx> {\n     debug!(\"build_clone_shim(def_id={:?})\", def_id);\n \n-    let param_env = tcx.param_env(def_id);\n+    let param_env = tcx.param_env_reveal_all_normalized(def_id);\n \n     let mut builder = CloneShimBuilder::new(tcx, def_id, self_ty);\n     let is_copy = self_ty.is_copy_modulo_regions(tcx, param_env);\n@@ -836,7 +836,7 @@ fn build_call_shim<'tcx>(\n pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n     debug_assert!(tcx.is_constructor(ctor_id));\n \n-    let param_env = tcx.param_env(ctor_id);\n+    let param_env = tcx.param_env_reveal_all_normalized(ctor_id);\n \n     // Normalize the sig.\n     let sig = tcx"}, {"sha": "1ff488169864bfe5ad8807b8d88c43b17a2f6cbf", "filename": "compiler/rustc_mir_transform/src/simplify_branches.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_branches.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -16,7 +16,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyConstCondition {\n     }\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let param_env = tcx.param_env(body.source.def_id());\n+        let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n         for block in body.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {"}, {"sha": "113ca2fc5ada5056cbc211cb4bc897426f2e1858", "filename": "compiler/rustc_mir_transform/src/simplify_comparison_integral.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_comparison_integral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_comparison_integral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_comparison_integral.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -37,7 +37,7 @@ impl<'tcx> MirPass<'tcx> for SimplifyComparisonIntegral {\n         let opts = helper.find_optimizations();\n         let mut storage_deads_to_insert = vec![];\n         let mut storage_deads_to_remove: Vec<(usize, BasicBlock)> = vec![];\n-        let param_env = tcx.param_env(body.source.def_id());\n+        let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n         for opt in opts {\n             trace!(\"SUCCESS: Applying {:?}\", opt);\n             // replace terminator with a switchInt that switches on the integer directly"}, {"sha": "5389b9f52eb2d43f0d42b6fdb4bebdf2117302c4", "filename": "compiler/rustc_mir_transform/src/uninhabited_enum_branching.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Funinhabited_enum_branching.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -109,7 +109,9 @@ impl<'tcx> MirPass<'tcx> for UninhabitedEnumBranching {\n                 continue;\n             };\n \n-            let layout = tcx.layout_of(tcx.param_env(body.source.def_id()).and(discriminant_ty));\n+            let layout = tcx.layout_of(\n+                tcx.param_env_reveal_all_normalized(body.source.def_id()).and(discriminant_ty),\n+            );\n \n             let allowed_variants = if let Ok(layout) = layout {\n                 variant_discriminants(&layout, discriminant_ty, tcx)"}, {"sha": "192badcbc37ea9d6428209ca063266587d3984ae", "filename": "compiler/rustc_resolve/messages.ftl", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_resolve%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_resolve%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fmessages.ftl?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -223,3 +223,6 @@ resolve_remove_surrounding_derive =\n resolve_add_as_non_derive =\n     add as non-Derive macro\n     `#[{$macro_path}]`\n+\n+resolve_proc_macro_same_crate = can't use a procedural macro from the same crate that defines it\n+    .help = you can define integration tests in a directory named `tests`"}, {"sha": "6197af105a96580a5f4a728c8563aabb145e545e", "filename": "compiler/rustc_resolve/src/errors.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -508,3 +508,12 @@ pub(crate) struct RemoveSurroundingDerive {\n pub(crate) struct AddAsNonDerive<'a> {\n     pub(crate) macro_path: &'a str,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_proc_macro_same_crate)]\n+pub(crate) struct ProcMacroSameCrate {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[help]\n+    pub(crate) is_test: bool,\n+}"}, {"sha": "2211fb56ccda1aac5fd810511c9e8d60a64e2b33", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -1,7 +1,7 @@\n //! A bunch of methods and structures more or less related to resolving macros and\n //! interface provided by `Resolver` to macro expander.\n \n-use crate::errors::{AddAsNonDerive, MacroExpectedFound, RemoveSurroundingDerive};\n+use crate::errors::{self, AddAsNonDerive, MacroExpectedFound, RemoveSurroundingDerive};\n use crate::Namespace::*;\n use crate::{BuiltinMacroState, Determinacy};\n use crate::{DeriveData, Finalize, ParentScope, ResolutionError, Resolver, ScopeSet};\n@@ -513,10 +513,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if let Some(def_id) = def_id.as_local() {\n                     self.unused_macros.remove(&def_id);\n                     if self.proc_macro_stubs.contains(&def_id) {\n-                        self.tcx.sess.span_err(\n-                            path.span,\n-                            \"can't use a procedural macro from the same crate that defines it\",\n-                        );\n+                        self.tcx.sess.emit_err(errors::ProcMacroSameCrate {\n+                            span: path.span,\n+                            is_test: self.tcx.sess.is_test_crate(),\n+                        });\n                     }\n                 }\n             }"}, {"sha": "70b9088de506490502ac444b4ca5431487142e88", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -1505,6 +1505,7 @@ symbols! {\n         transmute_generic_consts,\n         transmute_opts,\n         transmute_trait,\n+        transmute_unchecked,\n         transparent,\n         transparent_enums,\n         transparent_unions,"}, {"sha": "8e7097ce4a7791edffb7e545a47798285570385b", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -645,12 +645,16 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             // FIXME: Handling opaques here is kinda sus. Especially because we\n             // simplify them to PlaceholderSimplifiedType.\n             | ty::Alias(ty::Opaque, _) => {\n-                if let Some(def_id) = self.tcx().find_map_relevant_impl(\n+                let mut disqualifying_impl = None;\n+                self.tcx().for_each_relevant_impl_treating_projections(\n                     goal.predicate.def_id(),\n                     goal.predicate.self_ty(),\n                     TreatProjections::NextSolverLookup,\n-                    Some,\n-                ) {\n+                    |impl_def_id| {\n+                        disqualifying_impl = Some(impl_def_id);\n+                    },\n+                );\n+                if let Some(def_id) = disqualifying_impl {\n                     debug!(?def_id, ?goal, \"disqualified auto-trait implementation\");\n                     // No need to actually consider the candidate here,\n                     // since we do that in `consider_impl_candidate`."}, {"sha": "61e382bbe49d6b0a3fdce40c9b5ad6c7777d0ee1", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 79, "deletions": 66, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -32,7 +32,6 @@ use rustc_infer::infer::{InferOk, TypeTrace};\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n use rustc_middle::ty::error::{ExpectedFound, TypeError};\n-use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::fold::{TypeFolder, TypeSuperFoldable};\n use rustc_middle::ty::print::{with_forced_trimmed_paths, FmtPrinter, Print};\n use rustc_middle::ty::{\n@@ -1836,57 +1835,61 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 });\n             let mut diag = struct_span_err!(self.tcx.sess, obligation.cause.span, E0271, \"{msg}\");\n \n-            let secondary_span = match predicate.kind().skip_binder() {\n-                ty::PredicateKind::Clause(ty::Clause::Projection(proj)) => self\n-                    .tcx\n-                    .opt_associated_item(proj.projection_ty.def_id)\n-                    .and_then(|trait_assoc_item| {\n-                        self.tcx\n-                            .trait_of_item(proj.projection_ty.def_id)\n-                            .map(|id| (trait_assoc_item, id))\n-                    })\n-                    .and_then(|(trait_assoc_item, id)| {\n-                        let trait_assoc_ident = trait_assoc_item.ident(self.tcx);\n-                        self.tcx.find_map_relevant_impl(\n-                            id,\n-                            proj.projection_ty.self_ty(),\n-                            TreatProjections::ForLookup,\n-                            |did| {\n-                                self.tcx\n-                                    .associated_items(did)\n-                                    .in_definition_order()\n-                                    .find(|assoc| assoc.ident(self.tcx) == trait_assoc_ident)\n-                            },\n-                        )\n-                    })\n-                    .and_then(|item| match self.tcx.hir().get_if_local(item.def_id) {\n-                        Some(\n-                            hir::Node::TraitItem(hir::TraitItem {\n-                                kind: hir::TraitItemKind::Type(_, Some(ty)),\n-                                ..\n-                            })\n-                            | hir::Node::ImplItem(hir::ImplItem {\n-                                kind: hir::ImplItemKind::Type(ty),\n-                                ..\n-                            }),\n-                        ) => Some((\n-                            ty.span,\n-                            with_forced_trimmed_paths!(format!(\n-                                \"type mismatch resolving `{}`\",\n-                                self.resolve_vars_if_possible(predicate)\n-                                    .print(FmtPrinter::new_with_limit(\n-                                        self.tcx,\n-                                        Namespace::TypeNS,\n-                                        rustc_session::Limit(5),\n-                                    ))\n-                                    .unwrap()\n-                                    .into_buffer()\n-                            )),\n+            let secondary_span = (|| {\n+                let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) =\n+                    predicate.kind().skip_binder()\n+                else {\n+                    return None;\n+                };\n+\n+                let trait_assoc_item = self.tcx.opt_associated_item(proj.projection_ty.def_id)?;\n+                let trait_assoc_ident = trait_assoc_item.ident(self.tcx);\n+\n+                let mut associated_items = vec![];\n+                self.tcx.for_each_relevant_impl(\n+                    self.tcx.trait_of_item(proj.projection_ty.def_id)?,\n+                    proj.projection_ty.self_ty(),\n+                    |impl_def_id| {\n+                        associated_items.extend(\n+                            self.tcx\n+                                .associated_items(impl_def_id)\n+                                .in_definition_order()\n+                                .find(|assoc| assoc.ident(self.tcx) == trait_assoc_ident),\n+                        );\n+                    },\n+                );\n+\n+                let [associated_item]: &[ty::AssocItem] = &associated_items[..] else {\n+                    return None;\n+                };\n+                match self.tcx.hir().get_if_local(associated_item.def_id) {\n+                    Some(\n+                        hir::Node::TraitItem(hir::TraitItem {\n+                            kind: hir::TraitItemKind::Type(_, Some(ty)),\n+                            ..\n+                        })\n+                        | hir::Node::ImplItem(hir::ImplItem {\n+                            kind: hir::ImplItemKind::Type(ty),\n+                            ..\n+                        }),\n+                    ) => Some((\n+                        ty.span,\n+                        with_forced_trimmed_paths!(format!(\n+                            \"type mismatch resolving `{}`\",\n+                            self.resolve_vars_if_possible(predicate)\n+                                .print(FmtPrinter::new_with_limit(\n+                                    self.tcx,\n+                                    Namespace::TypeNS,\n+                                    rustc_session::Limit(5),\n+                                ))\n+                                .unwrap()\n+                                .into_buffer()\n                         )),\n-                        _ => None,\n-                    }),\n-                _ => None,\n-            };\n+                    )),\n+                    _ => None,\n+                }\n+            })();\n+\n             self.note_type_err(\n                 &mut diag,\n                 &obligation.cause,\n@@ -2228,14 +2231,18 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         err: &mut Diagnostic,\n         trait_ref: &ty::PolyTraitRef<'tcx>,\n     ) -> bool {\n-        let get_trait_impl = |trait_def_id| {\n-            self.tcx.find_map_relevant_impl(\n+        let get_trait_impls = |trait_def_id| {\n+            let mut trait_impls = vec![];\n+            self.tcx.for_each_relevant_impl(\n                 trait_def_id,\n                 trait_ref.skip_binder().self_ty(),\n-                TreatProjections::ForLookup,\n-                Some,\n-            )\n+                |impl_def_id| {\n+                    trait_impls.push(impl_def_id);\n+                },\n+            );\n+            trait_impls\n         };\n+\n         let required_trait_path = self.tcx.def_path_str(trait_ref.def_id());\n         let traits_with_same_path: std::collections::BTreeSet<_> = self\n             .tcx\n@@ -2245,17 +2252,23 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             .collect();\n         let mut suggested = false;\n         for trait_with_same_path in traits_with_same_path {\n-            if let Some(impl_def_id) = get_trait_impl(trait_with_same_path) {\n-                let impl_span = self.tcx.def_span(impl_def_id);\n-                err.span_help(impl_span, \"trait impl with same name found\");\n-                let trait_crate = self.tcx.crate_name(trait_with_same_path.krate);\n-                let crate_msg = format!(\n-                    \"perhaps two different versions of crate `{}` are being used?\",\n-                    trait_crate\n-                );\n-                err.note(&crate_msg);\n-                suggested = true;\n+            let trait_impls = get_trait_impls(trait_with_same_path);\n+            if trait_impls.is_empty() {\n+                continue;\n             }\n+            let impl_spans: Vec<_> =\n+                trait_impls.iter().map(|impl_def_id| self.tcx.def_span(*impl_def_id)).collect();\n+            err.span_help(\n+                impl_spans,\n+                format!(\"trait impl{} with same name found\", pluralize!(trait_impls.len())),\n+            );\n+            let trait_crate = self.tcx.crate_name(trait_with_same_path.krate);\n+            let crate_msg = format!(\n+                \"perhaps two different versions of crate `{}` are being used?\",\n+                trait_crate\n+            );\n+            err.note(&crate_msg);\n+            suggested = true;\n         }\n         suggested\n     }"}, {"sha": "ea45412e47f1199487b517f7f3921064dcf74fcc", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -1272,14 +1272,29 @@ fn project<'cx, 'tcx>(\n         ProjectionCandidateSet::Single(candidate) => {\n             Ok(Projected::Progress(confirm_candidate(selcx, obligation, candidate)))\n         }\n-        ProjectionCandidateSet::None => Ok(Projected::NoProgress(\n-            // FIXME(associated_const_generics): this may need to change in the future?\n-            // need to investigate whether or not this is fine.\n-            selcx\n-                .tcx()\n-                .mk_projection(obligation.predicate.def_id, obligation.predicate.substs)\n-                .into(),\n-        )),\n+        ProjectionCandidateSet::None => {\n+            let tcx = selcx.tcx();\n+            let term = match tcx.def_kind(obligation.predicate.def_id) {\n+                DefKind::AssocTy | DefKind::ImplTraitPlaceholder => tcx\n+                    .mk_projection(obligation.predicate.def_id, obligation.predicate.substs)\n+                    .into(),\n+                DefKind::AssocConst => tcx\n+                    .mk_const(\n+                        ty::ConstKind::Unevaluated(ty::UnevaluatedConst::new(\n+                            obligation.predicate.def_id,\n+                            obligation.predicate.substs,\n+                        )),\n+                        tcx.type_of(obligation.predicate.def_id)\n+                            .subst(tcx, obligation.predicate.substs),\n+                    )\n+                    .into(),\n+                kind => {\n+                    bug!(\"unknown projection def-id: {}\", kind.descr(obligation.predicate.def_id))\n+                }\n+            };\n+\n+            Ok(Projected::NoProgress(term))\n+        }\n         // Error occurred while trying to processing impls.\n         ProjectionCandidateSet::Error(e) => Err(ProjectionError::TraitSelectionError(e)),\n         // Inherent ambiguity that prevents us from even enumerating the"}, {"sha": "1db9b8ce92e4fe9aee34355fc58c67444ace136f", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -11,7 +11,7 @@ use hir::LangItem;\n use rustc_hir as hir;\n use rustc_infer::traits::ObligationCause;\n use rustc_infer::traits::{Obligation, SelectionError, TraitObligation};\n-use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams, TreatProjections};\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n use rustc_middle::ty::{self, Ty, TypeVisitableExt};\n \n use crate::traits;\n@@ -875,12 +875,24 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ty::Adt(..) => {\n-                // Find a custom `impl Drop` impl, if it exists\n-                let relevant_impl = self.tcx().find_map_relevant_impl(\n+                let mut relevant_impl = None;\n+                self.tcx().for_each_relevant_impl(\n                     self.tcx().require_lang_item(LangItem::Drop, None),\n                     obligation.predicate.skip_binder().trait_ref.self_ty(),\n-                    TreatProjections::ForLookup,\n-                    Some,\n+                    |impl_def_id| {\n+                        if let Some(old_impl_def_id) = relevant_impl {\n+                            self.tcx()\n+                                .sess\n+                                .struct_span_err(\n+                                    self.tcx().def_span(impl_def_id),\n+                                    \"multiple drop impls found\",\n+                                )\n+                                .span_note(self.tcx().def_span(old_impl_def_id), \"other impl here\")\n+                                .delay_as_bug();\n+                        }\n+\n+                        relevant_impl = Some(impl_def_id);\n+                    },\n                 );\n \n                 if let Some(impl_def_id) = relevant_impl {"}, {"sha": "587877dff552f381c867cea8c6404899fb73d668", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -3,8 +3,9 @@\n use crate::num::NonZeroUsize;\n use crate::{\n     fmt,\n+    intrinsics::transmute_unchecked,\n     iter::{self, ExactSizeIterator, FusedIterator, TrustedLen},\n-    mem::{self, MaybeUninit},\n+    mem::MaybeUninit,\n     ops::{IndexRange, Range},\n     ptr,\n };\n@@ -63,18 +64,11 @@ impl<T, const N: usize> IntoIterator for [T; N] {\n         // an array of `T`.\n         //\n         // With that, this initialization satisfies the invariants.\n-\n-        // FIXME(LukasKalbertodt): actually use `mem::transmute` here, once it\n-        // works with const generics:\n-        //     `mem::transmute::<[T; N], [MaybeUninit<T>; N]>(array)`\n         //\n-        // Until then, we can use `mem::transmute_copy` to create a bitwise copy\n-        // as a different type, then forget `array` so that it is not dropped.\n-        unsafe {\n-            let iter = IntoIter { data: mem::transmute_copy(&self), alive: IndexRange::zero_to(N) };\n-            mem::forget(self);\n-            iter\n-        }\n+        // FIXME: If normal `transmute` ever gets smart enough to allow this\n+        // directly, use it instead of `transmute_unchecked`.\n+        let data: [MaybeUninit<T>; N] = unsafe { transmute_unchecked(self) };\n+        IntoIter { data, alive: IndexRange::zero_to(N) }\n     }\n }\n "}, {"sha": "39edfd8265b41d54cf90be27deb5f07f6fbae830", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -1376,6 +1376,20 @@ extern \"rust-intrinsic\" {\n     #[rustc_nounwind]\n     pub fn transmute<Src, Dst>(src: Src) -> Dst;\n \n+    /// Like [`transmute`], but even less checked at compile-time: rather than\n+    /// giving an error for `size_of::<Src>() != size_of::<Dst>()`, it's\n+    /// **Undefined Behaviour** at runtime.\n+    ///\n+    /// Prefer normal `transmute` where possible, for the extra checking, since\n+    /// both do exactly the same thing at runtime, if they both compile.\n+    ///\n+    /// This is not expected to ever be exposed directly to users, rather it\n+    /// may eventually be exposed through some more-constrained API.\n+    #[cfg(not(bootstrap))]\n+    #[rustc_const_stable(feature = \"const_transmute\", since = \"1.56.0\")]\n+    #[rustc_nounwind]\n+    pub fn transmute_unchecked<Src, Dst>(src: Src) -> Dst;\n+\n     /// Returns `true` if the actual type given as `T` requires drop\n     /// glue; returns `false` if the actual type provided for `T`\n     /// implements `Copy`.\n@@ -2798,3 +2812,11 @@ pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n         write_bytes(dst, val, count)\n     }\n }\n+\n+/// Polyfill for bootstrap\n+#[cfg(bootstrap)]\n+pub const unsafe fn transmute_unchecked<Src, Dst>(src: Src) -> Dst {\n+    use crate::mem::*;\n+    // SAFETY: It's a transmute -- the caller promised it's fine.\n+    unsafe { transmute_copy(&ManuallyDrop::new(src)) }\n+}"}, {"sha": "2588b7d2befac4b71c866135f12416ddd16923a2", "filename": "library/core/src/mem/maybe_uninit.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmaybe_uninit.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -945,14 +945,10 @@ impl<T> MaybeUninit<T> {\n         // * `MaybeUninit<T>` and T are guaranteed to have the same layout\n         // * `MaybeUninit` does not drop, so there are no double-frees\n         // And thus the conversion is safe\n-        let ret = unsafe {\n+        unsafe {\n             intrinsics::assert_inhabited::<[T; N]>();\n-            (&array as *const _ as *const [T; N]).read()\n-        };\n-\n-        // FIXME: required to avoid `~const Destruct` bound\n-        super::forget(array);\n-        ret\n+            intrinsics::transmute_unchecked(array)\n+        }\n     }\n \n     /// Assuming all the elements are initialized, get a slice to them."}, {"sha": "680a8da6adf206699415840b0270b66ba9801890", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -722,11 +722,14 @@ def bootstrap_binary(self):\n \n     def build_bootstrap(self, color, verbose_count):\n         \"\"\"Build bootstrap\"\"\"\n-        print(\"Building bootstrap\")\n+        env = os.environ.copy()\n+        if \"GITHUB_ACTIONS\" in env:\n+            print(\"::group::Building bootstrap\")\n+        else:\n+            print(\"Building bootstrap\")\n         build_dir = os.path.join(self.build_dir, \"bootstrap\")\n         if self.clean and os.path.exists(build_dir):\n             shutil.rmtree(build_dir)\n-        env = os.environ.copy()\n         # `CARGO_BUILD_TARGET` breaks bootstrap build.\n         # See also: <https://github.com/rust-lang/rust/issues/70208>.\n         if \"CARGO_BUILD_TARGET\" in env:\n@@ -798,6 +801,9 @@ def build_bootstrap(self, color, verbose_count):\n         # Run this from the source directory so cargo finds .cargo/config\n         run(args, env=env, verbose=self.verbose, cwd=self.rust_root)\n \n+        if \"GITHUB_ACTIONS\" in env:\n+            print(\"::endgroup::\")\n+\n     def build_triple(self):\n         \"\"\"Build triple as in LLVM\n "}, {"sha": "60de46ce64c1576ae3cd5f821373963f1aea6147", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 6, "deletions": 60, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -105,15 +105,7 @@ impl Step for Std {\n             cargo.arg(\"--lib\");\n         }\n \n-        let msg = if compiler.host == target {\n-            format!(\"Checking stage{} library artifacts ({target})\", builder.top_stage)\n-        } else {\n-            format!(\n-                \"Checking stage{} library artifacts ({} -> {})\",\n-                builder.top_stage, &compiler.host, target\n-            )\n-        };\n-        builder.info(&msg);\n+        let _guard = builder.msg_check(\"library artifacts\", target);\n         run_cargo(\n             builder,\n             cargo,\n@@ -167,18 +159,7 @@ impl Step for Std {\n             cargo.arg(\"-p\").arg(krate.name);\n         }\n \n-        let msg = if compiler.host == target {\n-            format!(\n-                \"Checking stage{} library test/bench/example targets ({target})\",\n-                builder.top_stage\n-            )\n-        } else {\n-            format!(\n-                \"Checking stage{} library test/bench/example targets ({} -> {})\",\n-                builder.top_stage, &compiler.host, target\n-            )\n-        };\n-        builder.info(&msg);\n+        let _guard = builder.msg_check(\"library test/bench/example targets\", target);\n         run_cargo(\n             builder,\n             cargo,\n@@ -252,15 +233,7 @@ impl Step for Rustc {\n             cargo.arg(\"-p\").arg(krate.name);\n         }\n \n-        let msg = if compiler.host == target {\n-            format!(\"Checking stage{} compiler artifacts ({target})\", builder.top_stage)\n-        } else {\n-            format!(\n-                \"Checking stage{} compiler artifacts ({} -> {})\",\n-                builder.top_stage, &compiler.host, target\n-            )\n-        };\n-        builder.info(&msg);\n+        let _guard = builder.msg_check(\"compiler artifacts\", target);\n         run_cargo(\n             builder,\n             cargo,\n@@ -317,15 +290,7 @@ impl Step for CodegenBackend {\n             .arg(builder.src.join(format!(\"compiler/rustc_codegen_{}/Cargo.toml\", backend)));\n         rustc_cargo_env(builder, &mut cargo, target, compiler.stage);\n \n-        let msg = if compiler.host == target {\n-            format!(\"Checking stage{} {} artifacts ({target})\", builder.top_stage, backend)\n-        } else {\n-            format!(\n-                \"Checking stage{} {} library ({} -> {})\",\n-                builder.top_stage, backend, &compiler.host.triple, target.triple\n-            )\n-        };\n-        builder.info(&msg);\n+        let _guard = builder.msg_check(&backend, target);\n \n         run_cargo(\n             builder,\n@@ -385,15 +350,7 @@ impl Step for RustAnalyzer {\n             cargo.arg(\"--benches\");\n         }\n \n-        let msg = if compiler.host == target {\n-            format!(\"Checking stage{} {} artifacts ({target})\", compiler.stage, \"rust-analyzer\")\n-        } else {\n-            format!(\n-                \"Checking stage{} {} artifacts ({} -> {})\",\n-                compiler.stage, \"rust-analyzer\", &compiler.host.triple, target.triple\n-            )\n-        };\n-        builder.info(&msg);\n+        let _guard = builder.msg_check(\"rust-analyzer artifacts\", target);\n         run_cargo(\n             builder,\n             cargo,\n@@ -460,18 +417,7 @@ macro_rules! tool_check_step {\n                 // NOTE: this doesn't enable lints for any other tools unless they explicitly add `#![warn(rustc::internal)]`\n                 // See https://github.com/rust-lang/rust/pull/80573#issuecomment-754010776\n                 cargo.rustflag(\"-Zunstable-options\");\n-                let msg = if compiler.host == target {\n-                    format!(\"Checking stage{} {} artifacts ({target})\", builder.top_stage, stringify!($name).to_lowercase())\n-                } else {\n-                    format!(\n-                        \"Checking stage{} {} artifacts ({} -> {})\",\n-                        builder.top_stage,\n-                        stringify!($name).to_lowercase(),\n-                        &compiler.host.triple,\n-                        target.triple\n-                    )\n-                };\n-                builder.info(&msg);\n+                let _guard = builder.msg_check(&concat!(stringify!($name), \" artifacts\").to_lowercase(), target);\n                 run_cargo(\n                     builder,\n                     cargo,"}, {"sha": "7d2a6862500a3848c7cb5d500a968ab701aa124d", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 15, "deletions": 44, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -143,23 +143,13 @@ impl Step for Std {\n             cargo.arg(\"-p\").arg(krate);\n         }\n \n-        let msg = if compiler.host == target {\n-            format!(\n-                \"Building{} stage{} library artifacts ({}) \",\n-                crate_description(&self.crates),\n-                compiler.stage,\n-                compiler.host\n-            )\n-        } else {\n-            format!(\n-                \"Building{} stage{} library artifacts ({} -> {})\",\n-                crate_description(&self.crates),\n-                compiler.stage,\n-                compiler.host,\n-                target,\n-            )\n-        };\n-        builder.info(&msg);\n+        let _guard = builder.msg(\n+            Kind::Build,\n+            compiler.stage,\n+            format_args!(\"library artifacts{}\", crate_description(&self.crates)),\n+            compiler.host,\n+            target,\n+        );\n         run_cargo(\n             builder,\n             cargo,\n@@ -790,24 +780,13 @@ impl Step for Rustc {\n             cargo.arg(\"-p\").arg(krate);\n         }\n \n-        let msg = if compiler.host == target {\n-            format!(\n-                \"Building{} compiler artifacts (stage{} -> stage{})\",\n-                crate_description(&self.crates),\n-                compiler.stage,\n-                compiler.stage + 1\n-            )\n-        } else {\n-            format!(\n-                \"Building{} compiler artifacts (stage{}:{} -> stage{}:{})\",\n-                crate_description(&self.crates),\n-                compiler.stage,\n-                compiler.host,\n-                compiler.stage + 1,\n-                target,\n-            )\n-        };\n-        builder.info(&msg);\n+        let _guard = builder.msg_sysroot_tool(\n+            Kind::Build,\n+            compiler.stage,\n+            format_args!(\"compiler artifacts{}\", crate_description(&self.crates)),\n+            compiler.host,\n+            target,\n+        );\n         run_cargo(\n             builder,\n             cargo,\n@@ -1114,15 +1093,7 @@ impl Step for CodegenBackend {\n \n         let tmp_stamp = out_dir.join(\".tmp.stamp\");\n \n-        let msg = if compiler.host == target {\n-            format!(\"Building stage{} codegen backend {}\", compiler.stage, backend)\n-        } else {\n-            format!(\n-                \"Building stage{} codegen backend {} ({} -> {})\",\n-                compiler.stage, backend, compiler.host, target\n-            )\n-        };\n-        builder.info(&msg);\n+        let _guard = builder.msg_build(compiler, format_args!(\"codegen backend {backend}\"), target);\n         let files = run_cargo(builder, cargo, vec![], &tmp_stamp, vec![], false, false);\n         if builder.config.dry_run() {\n             return;"}, {"sha": "b62aa9992469b01f4e307f64e72046ec43e4aedc", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -12,7 +12,7 @@ use crate::util::t;\n \n use crate::dist;\n use crate::tarball::GeneratedTarball;\n-use crate::Compiler;\n+use crate::{Compiler, Kind};\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::config::{Config, TargetSelection};\n@@ -52,7 +52,7 @@ fn install_sh(\n     host: Option<TargetSelection>,\n     tarball: &GeneratedTarball,\n ) {\n-    builder.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n+    let _guard = builder.msg(Kind::Install, stage, package, host, host);\n \n     let prefix = default_path(&builder.config.prefix, \"/usr/local\");\n     let sysconfdir = prefix.join(default_path(&builder.config.sysconfdir, \"/etc\"));"}, {"sha": "238d167c4c276dded01f16699f35e77873555b41", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 81, "deletions": 1, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -19,13 +19,14 @@\n use std::cell::{Cell, RefCell};\n use std::collections::{HashMap, HashSet};\n use std::env;\n+use std::fmt::Display;\n use std::fs::{self, File};\n use std::io;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n use std::str;\n \n-use build_helper::ci::CiEnv;\n+use build_helper::ci::{gha, CiEnv};\n use channel::GitInfo;\n use config::{DryRun, Target};\n use filetime::FileTime;\n@@ -993,6 +994,85 @@ impl Build {\n         }\n     }\n \n+    fn msg_check(\n+        &self,\n+        what: impl Display,\n+        target: impl Into<Option<TargetSelection>>,\n+    ) -> Option<gha::Group> {\n+        self.msg(Kind::Check, self.config.stage, what, self.config.build, target)\n+    }\n+\n+    fn msg_build(\n+        &self,\n+        compiler: Compiler,\n+        what: impl Display,\n+        target: impl Into<Option<TargetSelection>>,\n+    ) -> Option<gha::Group> {\n+        self.msg(Kind::Build, compiler.stage, what, compiler.host, target)\n+    }\n+\n+    /// Return a `Group` guard for a [`Step`] that is built for each `--stage`.\n+    fn msg(\n+        &self,\n+        action: impl Into<Kind>,\n+        stage: u32,\n+        what: impl Display,\n+        host: impl Into<Option<TargetSelection>>,\n+        target: impl Into<Option<TargetSelection>>,\n+    ) -> Option<gha::Group> {\n+        let action = action.into();\n+        let msg = |fmt| format!(\"{action:?}ing stage{stage} {what}{fmt}\");\n+        let msg = if let Some(target) = target.into() {\n+            let host = host.into().unwrap();\n+            if host == target {\n+                msg(format_args!(\" ({target})\"))\n+            } else {\n+                msg(format_args!(\" ({host} -> {target})\"))\n+            }\n+        } else {\n+            msg(format_args!(\"\"))\n+        };\n+        self.group(&msg)\n+    }\n+\n+    /// Return a `Group` guard for a [`Step`] that is only built once and isn't affected by `--stage`.\n+    fn msg_unstaged(\n+        &self,\n+        action: impl Into<Kind>,\n+        what: impl Display,\n+        target: TargetSelection,\n+    ) -> Option<gha::Group> {\n+        let action = action.into();\n+        let msg = format!(\"{action:?}ing {what} for {target}\");\n+        self.group(&msg)\n+    }\n+\n+    fn msg_sysroot_tool(\n+        &self,\n+        action: impl Into<Kind>,\n+        stage: u32,\n+        what: impl Display,\n+        host: TargetSelection,\n+        target: TargetSelection,\n+    ) -> Option<gha::Group> {\n+        let action = action.into();\n+        let msg = |fmt| format!(\"{action:?}ing {what} {fmt}\");\n+        let msg = if host == target {\n+            msg(format_args!(\"(stage{stage} -> stage{}, {target})\", stage + 1))\n+        } else {\n+            msg(format_args!(\"(stage{stage}:{host} -> stage{}:{target})\", stage + 1))\n+        };\n+        self.group(&msg)\n+    }\n+\n+    fn group(&self, msg: &str) -> Option<gha::Group> {\n+        self.info(&msg);\n+        match self.config.dry_run {\n+            DryRun::SelfCheck => None,\n+            DryRun::Disabled | DryRun::UserSelected => Some(gha::group(&msg)),\n+        }\n+    }\n+\n     /// Returns the number of parallel jobs that have been configured for this\n     /// build.\n     fn jobs(&self) -> u32 {"}, {"sha": "67cb88373910c64719f735f961328cc44b97fcee", "filename": "src/bootstrap/llvm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fllvm.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -21,7 +21,7 @@ use crate::channel;\n use crate::config::{Config, TargetSelection};\n use crate::util::get_clang_cl_resource_dir;\n use crate::util::{self, exe, output, t, up_to_date};\n-use crate::{CLang, GitRepo};\n+use crate::{CLang, GitRepo, Kind};\n \n use build_helper::ci::CiEnv;\n \n@@ -271,7 +271,7 @@ impl Step for Llvm {\n             panic!(\"shared linking to LLVM is not currently supported on {}\", target.triple);\n         }\n \n-        builder.info(&format!(\"Building LLVM for {}\", target));\n+        let _guard = builder.msg_unstaged(Kind::Build, \"LLVM\", target);\n         t!(stamp.remove());\n         let _time = util::timeit(&builder);\n         t!(fs::create_dir_all(&out_dir));\n@@ -813,7 +813,7 @@ impl Step for Lld {\n             return out_dir;\n         }\n \n-        builder.info(&format!(\"Building LLD for {}\", target));\n+        let _guard = builder.msg_unstaged(Kind::Build, \"LLD\", target);\n         let _time = util::timeit(&builder);\n         t!(fs::create_dir_all(&out_dir));\n \n@@ -911,7 +911,7 @@ impl Step for Sanitizers {\n             return runtimes;\n         }\n \n-        builder.info(&format!(\"Building sanitizers for {}\", self.target));\n+        let _guard = builder.msg_unstaged(Kind::Build, \"sanitizers\", self.target);\n         t!(stamp.remove());\n         let _time = util::timeit(&builder);\n \n@@ -1103,7 +1103,7 @@ impl Step for CrtBeginEnd {\n             return out_dir;\n         }\n \n-        builder.info(\"Building crtbegin.o and crtend.o\");\n+        let _guard = builder.msg_unstaged(Kind::Build, \"crtbegin.o and crtend.o\", self.target);\n         t!(fs::create_dir_all(&out_dir));\n \n         let mut cfg = cc::Build::new();\n@@ -1168,7 +1168,7 @@ impl Step for Libunwind {\n             return out_dir;\n         }\n \n-        builder.info(&format!(\"Building libunwind.a for {}\", self.target.triple));\n+        let _guard = builder.msg_unstaged(Kind::Build, \"libunwind.a\", self.target);\n         t!(fs::create_dir_all(&out_dir));\n \n         let mut cc_cfg = cc::Build::new();"}, {"sha": "601351ea8e3c099eae214052a6e9229488080fd9", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -5,7 +5,6 @@\n \n use std::env;\n use std::ffi::OsString;\n-use std::fmt;\n use std::fs;\n use std::iter;\n use std::path::{Path, PathBuf};\n@@ -57,12 +56,12 @@ impl TestKind {\n     }\n }\n \n-impl fmt::Display for TestKind {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.write_str(match *self {\n-            TestKind::Test => \"Testing\",\n-            TestKind::Bench => \"Benchmarking\",\n-        })\n+impl Into<Kind> for TestKind {\n+    fn into(self) -> Kind {\n+        match self {\n+            TestKind::Test => Kind::Test,\n+            TestKind::Bench => Kind::Bench,\n+        }\n     }\n }\n \n@@ -1905,7 +1904,13 @@ impl BookTest {\n         rustbook_cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n         rustbook_cmd.env(\"PATH\", new_path).arg(\"test\").arg(path);\n         builder.add_rust_test_threads(&mut rustbook_cmd);\n-        builder.info(&format!(\"Testing rustbook {}\", self.path.display()));\n+        let _guard = builder.msg(\n+            Kind::Test,\n+            compiler.stage,\n+            format_args!(\"rustbook {}\", self.path.display()),\n+            compiler.host,\n+            compiler.host,\n+        );\n         let _time = util::timeit(&builder);\n         let toolstate = if try_run(builder, &mut rustbook_cmd) {\n             ToolState::TestPass\n@@ -2033,7 +2038,8 @@ impl Step for ErrorIndex {\n         let mut tool = tool::ErrorIndex::command(builder);\n         tool.arg(\"markdown\").arg(&output);\n \n-        builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n+        let _guard =\n+            builder.msg(Kind::Test, compiler.stage, \"error-index\", compiler.host, compiler.host);\n         let _time = util::timeit(&builder);\n         builder.run_quiet(&mut tool);\n         // The tests themselves need to link to std, so make sure it is\n@@ -2263,14 +2269,13 @@ impl Step for Crate {\n             );\n         }\n \n-        builder.info(&format!(\n-            \"{}{} stage{} ({} -> {})\",\n+        let _guard = builder.msg(\n             test_kind,\n-            crate_description(&self.crates),\n             compiler.stage,\n-            &compiler.host,\n-            target\n-        ));\n+            crate_description(&self.crates),\n+            compiler.host,\n+            target,\n+        );\n         let _time = util::timeit(&builder);\n         crate::render_tests::try_run_tests(builder, &mut cargo.into());\n     }\n@@ -2386,10 +2391,8 @@ impl Step for CrateRustdoc {\n             cargo.arg(\"--quiet\");\n         }\n \n-        builder.info(&format!(\n-            \"{} rustdoc stage{} ({} -> {})\",\n-            test_kind, compiler.stage, &compiler.host, target\n-        ));\n+        let _guard = builder.msg(test_kind, compiler.stage, \"rustdoc\", compiler.host, target);\n+\n         let _time = util::timeit(&builder);\n \n         add_flags_and_try_run_tests(builder, &mut cargo.into());\n@@ -2453,10 +2456,8 @@ impl Step for CrateRustdocJsonTypes {\n             cargo.arg(\"'-Ctarget-feature=-crt-static'\");\n         }\n \n-        builder.info(&format!(\n-            \"{} rustdoc-json-types stage{} ({} -> {})\",\n-            test_kind, compiler.stage, &compiler.host, target\n-        ));\n+        let _guard =\n+            builder.msg(test_kind, compiler.stage, \"rustdoc-json-types\", compiler.host, target);\n         let _time = util::timeit(&builder);\n \n         add_flags_and_try_run_tests(builder, &mut cargo.into());\n@@ -2845,7 +2846,7 @@ impl Step for TestHelpers {\n             return;\n         }\n \n-        builder.info(\"Building test helpers\");\n+        let _guard = builder.msg_unstaged(Kind::Build, \"test helpers\", target);\n         t!(fs::create_dir_all(&dst));\n         let mut cfg = cc::Build::new();\n         // FIXME: Workaround for https://github.com/emscripten-core/emscripten/issues/9013"}, {"sha": "f3724b2c0e4cd9f6d6fc8a3461347f4bfa358f6e", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 23, "deletions": 38, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -11,6 +11,7 @@ use crate::toolstate::ToolState;\n use crate::util::{add_dylib_path, exe, t};\n use crate::Compiler;\n use crate::Mode;\n+use crate::{gha, Kind};\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub enum SourceType {\n@@ -32,41 +33,27 @@ struct ToolBuild {\n     allow_features: &'static str,\n }\n \n-fn tooling_output(\n-    mode: Mode,\n-    tool: &str,\n-    build_stage: u32,\n-    host: &TargetSelection,\n-    target: &TargetSelection,\n-) -> String {\n-    match mode {\n-        // depends on compiler stage, different to host compiler\n-        Mode::ToolRustc => {\n-            if host == target {\n-                format!(\"Building tool {} (stage{} -> stage{})\", tool, build_stage, build_stage + 1)\n-            } else {\n-                format!(\n-                    \"Building tool {} (stage{}:{} -> stage{}:{})\",\n-                    tool,\n-                    build_stage,\n-                    host,\n-                    build_stage + 1,\n-                    target\n-                )\n-            }\n-        }\n-        // doesn't depend on compiler, same as host compiler\n-        Mode::ToolStd => {\n-            if host == target {\n-                format!(\"Building tool {} (stage{})\", tool, build_stage)\n-            } else {\n-                format!(\n-                    \"Building tool {} (stage{}:{} -> stage{}:{})\",\n-                    tool, build_stage, host, build_stage, target\n-                )\n-            }\n+impl Builder<'_> {\n+    fn msg_tool(\n+        &self,\n+        mode: Mode,\n+        tool: &str,\n+        build_stage: u32,\n+        host: &TargetSelection,\n+        target: &TargetSelection,\n+    ) -> Option<gha::Group> {\n+        match mode {\n+            // depends on compiler stage, different to host compiler\n+            Mode::ToolRustc => self.msg_sysroot_tool(\n+                Kind::Build,\n+                build_stage,\n+                format_args!(\"tool {tool}\"),\n+                *host,\n+                *target,\n+            ),\n+            // doesn't depend on compiler, same as host compiler\n+            _ => self.msg(Kind::Build, build_stage, format_args!(\"tool {tool}\"), *host, *target),\n         }\n-        _ => format!(\"Building tool {} (stage{})\", tool, build_stage),\n     }\n }\n \n@@ -111,14 +98,13 @@ impl Step for ToolBuild {\n         if !self.allow_features.is_empty() {\n             cargo.allow_features(self.allow_features);\n         }\n-        let msg = tooling_output(\n+        let _guard = builder.msg_tool(\n             self.mode,\n             self.tool,\n             self.compiler.stage,\n             &self.compiler.host,\n             &self.target,\n         );\n-        builder.info(&msg);\n \n         let mut cargo = Command::from(cargo);\n         let is_expected = builder.try_run(&mut cargo);\n@@ -492,14 +478,13 @@ impl Step for Rustdoc {\n             cargo.rustflag(\"--cfg=parallel_compiler\");\n         }\n \n-        let msg = tooling_output(\n+        let _guard = builder.msg_tool(\n             Mode::ToolRustc,\n             \"rustdoc\",\n             build_compiler.stage,\n             &self.compiler.host,\n             &target,\n         );\n-        builder.info(&msg);\n         builder.run(&mut cargo.into());\n \n         // Cargo adds a number of paths to the dylib search path on windows, which results in"}, {"sha": "f2486abaaa77eec089db98341303ee157c6ff48e", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{DefKind, Namespace, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n use rustc_hir::Mutability;\n-use rustc_middle::ty::{fast_reject::TreatProjections, Ty, TyCtxt};\n+use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_middle::{bug, ty};\n use rustc_resolve::rustdoc::{has_primitive_or_keyword_docs, prepare_to_doc_link_resolution};\n use rustc_resolve::rustdoc::{strip_generics_from_path, MalformedGenerics};\n@@ -772,11 +772,10 @@ fn trait_impls_for<'a>(\n     module: DefId,\n ) -> FxHashSet<(DefId, DefId)> {\n     let tcx = cx.tcx;\n-    let iter = tcx.doc_link_traits_in_scope(module).iter().flat_map(|&trait_| {\n-        trace!(\"considering explicit impl for trait {:?}\", trait_);\n+    let mut impls = FxHashSet::default();\n \n-        // Look at each trait implementation to see if it's an impl for `did`\n-        tcx.find_map_relevant_impl(trait_, ty, TreatProjections::ForLookup, |impl_| {\n+    for &trait_ in tcx.doc_link_traits_in_scope(module) {\n+        tcx.for_each_relevant_impl(trait_, ty, |impl_| {\n             let trait_ref = tcx.impl_trait_ref(impl_).expect(\"this is not an inherent impl\");\n             // Check if these are the same type.\n             let impl_type = trait_ref.skip_binder().self_ty();\n@@ -800,10 +799,13 @@ fn trait_impls_for<'a>(\n                     _ => false,\n                 };\n \n-            if saw_impl { Some((impl_, trait_)) } else { None }\n-        })\n-    });\n-    iter.collect()\n+            if saw_impl {\n+                impls.insert((impl_, trait_));\n+            }\n+        });\n+    }\n+\n+    impls\n }\n \n /// Check for resolve collisions between a trait and its derive."}, {"sha": "d2e9c324af8c6f9a62fb9b45959b768df89d4617", "filename": "src/tools/build_helper/src/ci.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Ftools%2Fbuild_helper%2Fsrc%2Fci.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/src%2Ftools%2Fbuild_helper%2Fsrc%2Fci.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild_helper%2Fsrc%2Fci.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -38,3 +38,27 @@ impl CiEnv {\n         }\n     }\n }\n+\n+pub mod gha {\n+    /// All github actions log messages from this call to the Drop of the return value\n+    /// will be grouped and hidden by default in logs. Note that nesting these does\n+    /// not really work.\n+    pub fn group(name: impl std::fmt::Display) -> Group {\n+        if std::env::var_os(\"GITHUB_ACTIONS\").is_some() {\n+            eprintln!(\"::group::{name}\");\n+        }\n+        Group(())\n+    }\n+\n+    /// A guard that closes the current github actions log group on drop.\n+    #[must_use]\n+    pub struct Group(());\n+\n+    impl Drop for Group {\n+        fn drop(&mut self) {\n+            if std::env::var_os(\"GITHUB_ACTIONS\").is_some() {\n+                eprintln!(\"::endgroup::\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "664e697c2a5d2976539c759b992e78204ea62beb", "filename": "tests/codegen/intrinsics/transmute.rs", "status": "modified", "additions": 9, "deletions": 33, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -8,10 +8,10 @@\n #![feature(inline_const)]\n #![allow(unreachable_code)]\n \n-use std::mem::{transmute, MaybeUninit};\n+use std::mem::MaybeUninit;\n+use std::intrinsics::{transmute, transmute_unchecked};\n \n-// Some of the cases here are statically rejected by `mem::transmute`, so\n-// we need to generate custom MIR for those cases to get to codegen.\n+// Some of these need custom MIR to not get removed by MIR optimizations.\n use std::intrinsics::mir::*;\n \n enum Never {}\n@@ -30,59 +30,35 @@ pub struct Aggregate8(u8);\n \n // CHECK-LABEL: @check_bigger_size(\n #[no_mangle]\n-#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n pub unsafe fn check_bigger_size(x: u16) -> u32 {\n     // CHECK: call void @llvm.trap\n-    mir!{\n-        {\n-            RET = CastTransmute(x);\n-            Return()\n-        }\n-    }\n+    transmute_unchecked(x)\n }\n \n // CHECK-LABEL: @check_smaller_size(\n #[no_mangle]\n-#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n pub unsafe fn check_smaller_size(x: u32) -> u16 {\n     // CHECK: call void @llvm.trap\n-    mir!{\n-        {\n-            RET = CastTransmute(x);\n-            Return()\n-        }\n-    }\n+    transmute_unchecked(x)\n }\n \n // CHECK-LABEL: @check_smaller_array(\n #[no_mangle]\n-#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n pub unsafe fn check_smaller_array(x: [u32; 7]) -> [u32; 3] {\n     // CHECK: call void @llvm.trap\n-    mir!{\n-        {\n-            RET = CastTransmute(x);\n-            Return()\n-        }\n-    }\n+    transmute_unchecked(x)\n }\n \n // CHECK-LABEL: @check_bigger_array(\n #[no_mangle]\n-#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n pub unsafe fn check_bigger_array(x: [u32; 3]) -> [u32; 7] {\n     // CHECK: call void @llvm.trap\n-    mir!{\n-        {\n-            RET = CastTransmute(x);\n-            Return()\n-        }\n-    }\n+    transmute_unchecked(x)\n }\n \n // CHECK-LABEL: @check_to_uninhabited(\n #[no_mangle]\n-#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n pub unsafe fn check_to_uninhabited(x: u16) -> BigNever {\n     // CHECK: call void @llvm.trap\n     mir!{\n@@ -95,7 +71,7 @@ pub unsafe fn check_to_uninhabited(x: u16) -> BigNever {\n \n // CHECK-LABEL: @check_from_uninhabited(\n #[no_mangle]\n-#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n pub unsafe fn check_from_uninhabited(x: BigNever) -> u16 {\n     // CHECK: ret i16 poison\n     mir!{"}, {"sha": "b1a0f39962b617b951a54d295c2c890212997d62", "filename": "tests/ui/associated-consts/projection-unspecified-but-bounded.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/tests%2Fui%2Fassociated-consts%2Fprojection-unspecified-but-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/tests%2Fui%2Fassociated-consts%2Fprojection-unspecified-but-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-consts%2Fprojection-unspecified-but-bounded.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -0,0 +1,16 @@\n+#![feature(associated_const_equality)]\n+\n+// Issue 110549\n+\n+pub trait TraitWAssocConst {\n+    const A: usize;\n+}\n+\n+fn foo<T: TraitWAssocConst<A = 32>>() {}\n+\n+fn bar<T: TraitWAssocConst>() {\n+    foo::<T>();\n+    //~^ ERROR type mismatch resolving `<T as TraitWAssocConst>::A == 32`\n+}\n+\n+fn main() {}"}, {"sha": "8175e510a093f1e0017ce1a94c569c203c2b1003", "filename": "tests/ui/associated-consts/projection-unspecified-but-bounded.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/tests%2Fui%2Fassociated-consts%2Fprojection-unspecified-but-bounded.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/tests%2Fui%2Fassociated-consts%2Fprojection-unspecified-but-bounded.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-consts%2Fprojection-unspecified-but-bounded.stderr?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -0,0 +1,17 @@\n+error[E0271]: type mismatch resolving `<T as TraitWAssocConst>::A == 32`\n+  --> $DIR/projection-unspecified-but-bounded.rs:12:11\n+   |\n+LL |     foo::<T>();\n+   |           ^ expected `32`, found `<T as TraitWAssocConst>::A`\n+   |\n+   = note: expected constant `32`\n+              found constant `<T as TraitWAssocConst>::A`\n+note: required by a bound in `foo`\n+  --> $DIR/projection-unspecified-but-bounded.rs:9:28\n+   |\n+LL | fn foo<T: TraitWAssocConst<A = 32>>() {}\n+   |                            ^^^^^^ required by this bound in `foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0271`."}, {"sha": "c13f384fa3ae14a9474ad57a3ca6c8adc182d62c", "filename": "tests/ui/proc-macro/test-same-crate.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/tests%2Fui%2Fproc-macro%2Ftest-same-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/tests%2Fui%2Fproc-macro%2Ftest-same-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Ftest-same-crate.rs?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -0,0 +1,16 @@\n+// compile-flags: --test\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+use proc_macro::TokenStream;\n+\n+#[proc_macro]\n+pub fn mac(input: TokenStream) -> TokenStream { loop {} }\n+\n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn t() { crate::mac!(A) }\n+    //~^ ERROR can't use a procedural macro from the same crate that defines it\n+    //~| HELP you can define integration tests in a directory named `tests`\n+}"}, {"sha": "5d12e149c3c4cf7f87d87337549d03f9048e6744", "filename": "tests/ui/proc-macro/test-same-crate.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/64bcb326516ef7490db46de88b87a4c0990097fe/tests%2Fui%2Fproc-macro%2Ftest-same-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64bcb326516ef7490db46de88b87a4c0990097fe/tests%2Fui%2Fproc-macro%2Ftest-same-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fproc-macro%2Ftest-same-crate.stderr?ref=64bcb326516ef7490db46de88b87a4c0990097fe", "patch": "@@ -0,0 +1,10 @@\n+error: can't use a procedural macro from the same crate that defines it\n+  --> $DIR/test-same-crate.rs:13:14\n+   |\n+LL |     fn t() { crate::mac!(A) }\n+   |              ^^^^^^^^^^\n+   |\n+   = help: you can define integration tests in a directory named `tests`\n+\n+error: aborting due to previous error\n+"}]}