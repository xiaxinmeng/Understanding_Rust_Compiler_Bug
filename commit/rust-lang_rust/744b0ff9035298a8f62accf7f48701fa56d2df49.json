{"sha": "744b0ff9035298a8f62accf7f48701fa56d2df49", "node_id": "C_kwDOAAsO6NoAKDc0NGIwZmY5MDM1Mjk4YThmNjJhY2NmN2Y0ODcwMWZhNTZkMmRmNDk", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-04-09T03:15:18Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-04-09T03:41:50Z"}, "message": "Don't lint `iter_with_drain` on references", "tree": {"sha": "4a32c995086e79b8fa556ffc31e0e56b12558fdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a32c995086e79b8fa556ffc31e0e56b12558fdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/744b0ff9035298a8f62accf7f48701fa56d2df49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/744b0ff9035298a8f62accf7f48701fa56d2df49", "html_url": "https://github.com/rust-lang/rust/commit/744b0ff9035298a8f62accf7f48701fa56d2df49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/744b0ff9035298a8f62accf7f48701fa56d2df49/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a63308be0a66fe34aa1ccefef76fa6a0bc50d2a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a63308be0a66fe34aa1ccefef76fa6a0bc50d2a3", "html_url": "https://github.com/rust-lang/rust/commit/a63308be0a66fe34aa1ccefef76fa6a0bc50d2a3"}], "stats": {"total": 109, "additions": 51, "deletions": 58}, "files": [{"sha": "152072e09c77275795922332495b9622baea5335", "filename": "clippy_lints/src/methods/iter_with_drain.rs", "status": "modified", "additions": 33, "deletions": 58, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/744b0ff9035298a8f62accf7f48701fa56d2df49/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744b0ff9035298a8f62accf7f48701fa56d2df49/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs?ref=744b0ff9035298a8f62accf7f48701fa56d2df49", "patch": "@@ -1,72 +1,47 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher::Range;\n use clippy_utils::is_integer_const;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{\n-    higher::{self, Range},\n-    SpanlessEq,\n-};\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, QPath};\n use rustc_lint::LateContext;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n use super::ITER_WITH_DRAIN;\n \n-const DRAIN_TYPES: &[Symbol] = &[sym::Vec, sym::VecDeque];\n-\n pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span, arg: &Expr<'_>) {\n-    let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n-    if let Some(drained_type) = DRAIN_TYPES.iter().find(|&&sym| is_type_diagnostic_item(cx, ty, sym)) {\n-        // Refuse to emit `into_iter` suggestion on draining struct fields due\n-        // to the strong possibility of processing unmovable field.\n-        if let ExprKind::Field(..) = recv.kind {\n-            return;\n-        }\n+    if !matches!(recv.kind, ExprKind::Field(..))\n+        && let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def()\n+        && let Some(ty_name) = cx.tcx.get_diagnostic_name(adt.did())\n+        && matches!(ty_name, sym::Vec | sym::VecDeque)\n+        && let Some(range) = Range::hir(arg)\n+        && is_full_range(cx, recv, range)\n+    {\n+        span_lint_and_sugg(\n+            cx,\n+            ITER_WITH_DRAIN,\n+            span.with_hi(expr.span.hi()),\n+            &format!(\"`drain(..)` used on a `{}`\", ty_name),\n+            \"try this\",\n+            \"into_iter()\".to_string(),\n+            Applicability::MaybeIncorrect,\n+        );\n+    };\n+}\n \n-        if let Some(range) = higher::Range::hir(arg) {\n-            let left_full = match range {\n-                Range { start: Some(start), .. } if is_integer_const(cx, start, 0) => true,\n-                Range { start: None, .. } => true,\n-                _ => false,\n-            };\n-            let full = left_full\n-                && match range {\n-                    Range {\n-                        end: Some(end),\n-                        limits: RangeLimits::HalfOpen,\n-                        ..\n-                    } => {\n-                        // `x.drain(..x.len())` call\n-                        if_chain! {\n-                            if let ExprKind::MethodCall(len_path, len_args, _) = end.kind;\n-                            if len_path.ident.name == sym::len && len_args.len() == 1;\n-                            if let ExprKind::Path(QPath::Resolved(_, drain_path)) = recv.kind;\n-                            if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_args[0].kind;\n-                            if SpanlessEq::new(cx).eq_path(drain_path, len_path);\n-                            then { true }\n-                            else { false }\n-                        }\n-                    },\n-                    Range {\n-                        end: None,\n-                        limits: RangeLimits::HalfOpen,\n-                        ..\n-                    } => true,\n-                    _ => false,\n-                };\n-            if full {\n-                span_lint_and_sugg(\n-                    cx,\n-                    ITER_WITH_DRAIN,\n-                    span.with_hi(expr.span.hi()),\n-                    &format!(\"`drain(..)` used on a `{}`\", drained_type),\n-                    \"try this\",\n-                    \"into_iter()\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n+fn is_full_range(cx: &LateContext<'_>, container: &Expr<'_>, range: Range<'_>) -> bool {\n+    range.start.map_or(true, |e| is_integer_const(cx, e, 0))\n+        && range.end.map_or(true, |e| {\n+            if range.limits == RangeLimits::HalfOpen\n+                && let ExprKind::Path(QPath::Resolved(None, container_path)) = container.kind\n+                && let ExprKind::MethodCall(name, [self_arg], _) = e.kind\n+                && name.ident.name == sym::len\n+                && let ExprKind::Path(QPath::Resolved(None, path)) = self_arg.kind\n+            {\n+                container_path.res == path.res\n+            } else {\n+                false\n             }\n-        }\n-    }\n+        })\n }"}, {"sha": "0330d5549264a122a1c43deee1dfbe41dcea55a3", "filename": "tests/ui/iter_with_drain.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/744b0ff9035298a8f62accf7f48701fa56d2df49/tests%2Fui%2Fiter_with_drain.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/744b0ff9035298a8f62accf7f48701fa56d2df49/tests%2Fui%2Fiter_with_drain.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_with_drain.fixed?ref=744b0ff9035298a8f62accf7f48701fa56d2df49", "patch": "@@ -39,6 +39,15 @@ fn should_not_help() {\n     let _: Vec<_> = b.drain(0..a.len()).collect();\n }\n \n+fn _closed_range(mut x: Vec<String>) {\n+    let _: Vec<String> = x.drain(0..=x.len()).collect();\n+}\n+\n+fn _with_mut(x: &mut Vec<String>, y: &mut VecDeque<String>) {\n+    let _: Vec<String> = x.drain(..).collect();\n+    let _: Vec<String> = y.drain(..).collect();\n+}\n+\n #[derive(Default)]\n struct Bomb {\n     fire: Vec<u8>,"}, {"sha": "993936fb8de3d5b345ebcd2ef233e27c24f08420", "filename": "tests/ui/iter_with_drain.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/744b0ff9035298a8f62accf7f48701fa56d2df49/tests%2Fui%2Fiter_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/744b0ff9035298a8f62accf7f48701fa56d2df49/tests%2Fui%2Fiter_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_with_drain.rs?ref=744b0ff9035298a8f62accf7f48701fa56d2df49", "patch": "@@ -39,6 +39,15 @@ fn should_not_help() {\n     let _: Vec<_> = b.drain(0..a.len()).collect();\n }\n \n+fn _closed_range(mut x: Vec<String>) {\n+    let _: Vec<String> = x.drain(0..=x.len()).collect();\n+}\n+\n+fn _with_mut(x: &mut Vec<String>, y: &mut VecDeque<String>) {\n+    let _: Vec<String> = x.drain(..).collect();\n+    let _: Vec<String> = y.drain(..).collect();\n+}\n+\n #[derive(Default)]\n struct Bomb {\n     fire: Vec<u8>,"}]}