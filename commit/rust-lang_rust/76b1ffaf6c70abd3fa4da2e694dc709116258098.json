{"sha": "76b1ffaf6c70abd3fa4da2e694dc709116258098", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YjFmZmFmNmM3MGFiZDNmYTRkYTJlNjk0ZGM3MDkxMTYyNTgwOTg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-18T23:10:36Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-24T09:29:45Z"}, "message": "syntax_ext: Reuse built-in attribute template checking for macro attributes", "tree": {"sha": "86f34d3ebbe34aa49072a1447c8adcfc0623a2ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86f34d3ebbe34aa49072a1447c8adcfc0623a2ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76b1ffaf6c70abd3fa4da2e694dc709116258098", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76b1ffaf6c70abd3fa4da2e694dc709116258098", "html_url": "https://github.com/rust-lang/rust/commit/76b1ffaf6c70abd3fa4da2e694dc709116258098", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76b1ffaf6c70abd3fa4da2e694dc709116258098/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "433024147ae1e9795fe7e94cb1810a17fd37fa51", "url": "https://api.github.com/repos/rust-lang/rust/commits/433024147ae1e9795fe7e94cb1810a17fd37fa51", "html_url": "https://github.com/rust-lang/rust/commit/433024147ae1e9795fe7e94cb1810a17fd37fa51"}], "stats": {"total": 245, "additions": 132, "deletions": 113}, "files": [{"sha": "b63d14ca949ee6b7b8189e5d71c068f0d75e480d", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=76b1ffaf6c70abd3fa4da2e694dc709116258098", "patch": "@@ -36,10 +36,10 @@ use syntax::tokenstream::{TokenTree, TokenStream};\n use syntax::ast;\n use syntax::ptr::P;\n use syntax::ast::Expr;\n-use syntax::attr::{self, HasAttrs};\n+use syntax::attr::{self, HasAttrs, AttributeTemplate};\n use syntax::source_map::Spanned;\n use syntax::edition::Edition;\n-use syntax::feature_gate::{AttributeGate, AttributeTemplate, AttributeType};\n+use syntax::feature_gate::{AttributeGate, AttributeType};\n use syntax::feature_gate::{Stability, deprecated_attributes};\n use syntax_pos::{BytePos, Span, SyntaxContext};\n use syntax::symbol::{Symbol, kw, sym};"}, {"sha": "713094416524ba4f9997e1b79f20cfb0c80034ae", "filename": "src/libsyntax/attr/builtin.rs", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=76b1ffaf6c70abd3fa4da2e694dc709116258098", "patch": "@@ -1,6 +1,9 @@\n //! Parsing and validation of builtin attributes\n \n use crate::ast::{self, Attribute, MetaItem, NestedMetaItem};\n+use crate::early_buffered_lints::BufferedEarlyLintId;\n+use crate::ext::base::ExtCtxt;\n+use crate::ext::build::AstBuilder;\n use crate::feature_gate::{Features, GatedCfg};\n use crate::parse::ParseSess;\n \n@@ -19,6 +22,27 @@ enum AttrError {\n     UnsupportedLiteral(&'static str, /* is_bytestr */ bool),\n }\n \n+/// A template that the attribute input must match.\n+/// Only top-level shape (`#[attr]` vs `#[attr(...)]` vs `#[attr = ...]`) is considered now.\n+#[derive(Clone, Copy)]\n+pub struct AttributeTemplate {\n+    crate word: bool,\n+    crate list: Option<&'static str>,\n+    crate name_value_str: Option<&'static str>,\n+}\n+\n+impl AttributeTemplate {\n+    /// Checks that the given meta-item is compatible with this template.\n+    fn compatible(&self, meta_item_kind: &ast::MetaItemKind) -> bool {\n+        match meta_item_kind {\n+            ast::MetaItemKind::Word => self.word,\n+            ast::MetaItemKind::List(..) => self.list.is_some(),\n+            ast::MetaItemKind::NameValue(lit) if lit.node.is_str() => self.name_value_str.is_some(),\n+            ast::MetaItemKind::NameValue(..) => false,\n+        }\n+    }\n+}\n+\n fn handle_errors(sess: &ParseSess, span: Span, error: AttrError) {\n     let diag = &sess.span_diagnostic;\n     match error {\n@@ -901,3 +925,75 @@ pub fn find_transparency(\n     let fallback = if is_legacy { Transparency::SemiTransparent } else { Transparency::Opaque };\n     (transparency.map_or(fallback, |t| t.0), error)\n }\n+\n+pub fn check_builtin_macro_attribute(ecx: &ExtCtxt<'_>, meta_item: &MetaItem, name: Symbol) {\n+    // All the built-in macro attributes are \"words\" at the moment.\n+    let template = AttributeTemplate { word: true, list: None, name_value_str: None };\n+    let attr = ecx.attribute(meta_item.span, meta_item.clone());\n+    check_builtin_attribute(ecx.parse_sess, &attr, name, template);\n+}\n+\n+crate fn check_builtin_attribute(\n+    sess: &ParseSess, attr: &ast::Attribute, name: Symbol, template: AttributeTemplate\n+) {\n+    // Some special attributes like `cfg` must be checked\n+    // before the generic check, so we skip them here.\n+    let should_skip = |name| name == sym::cfg;\n+    // Some of previously accepted forms were used in practice,\n+    // report them as warnings for now.\n+    let should_warn = |name| name == sym::doc || name == sym::ignore ||\n+                             name == sym::inline || name == sym::link;\n+\n+    match attr.parse_meta(sess) {\n+        Ok(meta) => if !should_skip(name) && !template.compatible(&meta.node) {\n+            let error_msg = format!(\"malformed `{}` attribute input\", name);\n+            let mut msg = \"attribute must be of the form \".to_owned();\n+            let mut suggestions = vec![];\n+            let mut first = true;\n+            if template.word {\n+                first = false;\n+                let code = format!(\"#[{}]\", name);\n+                msg.push_str(&format!(\"`{}`\", &code));\n+                suggestions.push(code);\n+            }\n+            if let Some(descr) = template.list {\n+                if !first {\n+                    msg.push_str(\" or \");\n+                }\n+                first = false;\n+                let code = format!(\"#[{}({})]\", name, descr);\n+                msg.push_str(&format!(\"`{}`\", &code));\n+                suggestions.push(code);\n+            }\n+            if let Some(descr) = template.name_value_str {\n+                if !first {\n+                    msg.push_str(\" or \");\n+                }\n+                let code = format!(\"#[{} = \\\"{}\\\"]\", name, descr);\n+                msg.push_str(&format!(\"`{}`\", &code));\n+                suggestions.push(code);\n+            }\n+            if should_warn(name) {\n+                sess.buffer_lint(\n+                    BufferedEarlyLintId::IllFormedAttributeInput,\n+                    meta.span,\n+                    ast::CRATE_NODE_ID,\n+                    &msg,\n+                );\n+            } else {\n+                sess.span_diagnostic.struct_span_err(meta.span, &error_msg)\n+                    .span_suggestions(\n+                        meta.span,\n+                        if suggestions.len() == 1 {\n+                            \"must be of the form\"\n+                        } else {\n+                            \"the following are the possible correct uses\"\n+                        },\n+                        suggestions.into_iter(),\n+                        Applicability::HasPlaceholders,\n+                    ).emit();\n+            }\n+        }\n+        Err(mut err) => err.emit(),\n+    }\n+}"}, {"sha": "72184b0bd6400374f59ad582793a44c6707a9b25", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 88, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=76b1ffaf6c70abd3fa4da2e694dc709116258098", "patch": "@@ -19,8 +19,7 @@ use crate::ast::{\n     self, AssocTyConstraint, AssocTyConstraintKind, NodeId, GenericParam, GenericParamKind,\n     PatKind, RangeEnd,\n };\n-use crate::attr;\n-use crate::early_buffered_lints::BufferedEarlyLintId;\n+use crate::attr::{self, check_builtin_attribute, AttributeTemplate};\n use crate::source_map::Spanned;\n use crate::edition::{ALL_EDITIONS, Edition};\n use crate::visit::{self, FnKind, Visitor};\n@@ -906,27 +905,6 @@ pub enum AttributeGate {\n     Ungated,\n }\n \n-/// A template that the attribute input must match.\n-/// Only top-level shape (`#[attr]` vs `#[attr(...)]` vs `#[attr = ...]`) is considered now.\n-#[derive(Clone, Copy)]\n-pub struct AttributeTemplate {\n-    word: bool,\n-    list: Option<&'static str>,\n-    name_value_str: Option<&'static str>,\n-}\n-\n-impl AttributeTemplate {\n-    /// Checks that the given meta-item is compatible with this template.\n-    fn compatible(&self, meta_item_kind: &ast::MetaItemKind) -> bool {\n-        match meta_item_kind {\n-            ast::MetaItemKind::Word => self.word,\n-            ast::MetaItemKind::List(..) => self.list.is_some(),\n-            ast::MetaItemKind::NameValue(lit) if lit.node.is_str() => self.name_value_str.is_some(),\n-            ast::MetaItemKind::NameValue(..) => false,\n-        }\n-    }\n-}\n-\n /// A convenience macro for constructing attribute templates.\n /// E.g., `template!(Word, List: \"description\")` means that the attribute\n /// supports forms `#[attr]` and `#[attr(description)]`.\n@@ -1901,70 +1879,6 @@ impl<'a> PostExpansionVisitor<'a> {\n             Abi::System => {}\n         }\n     }\n-\n-    fn check_builtin_attribute(&mut self, attr: &ast::Attribute, name: Symbol,\n-                               template: AttributeTemplate) {\n-        // Some special attributes like `cfg` must be checked\n-        // before the generic check, so we skip them here.\n-        let should_skip = |name| name == sym::cfg;\n-        // Some of previously accepted forms were used in practice,\n-        // report them as warnings for now.\n-        let should_warn = |name| name == sym::doc || name == sym::ignore ||\n-                                 name == sym::inline || name == sym::link;\n-\n-        match attr.parse_meta(self.context.parse_sess) {\n-            Ok(meta) => if !should_skip(name) && !template.compatible(&meta.node) {\n-                let error_msg = format!(\"malformed `{}` attribute input\", name);\n-                let mut msg = \"attribute must be of the form \".to_owned();\n-                let mut suggestions = vec![];\n-                let mut first = true;\n-                if template.word {\n-                    first = false;\n-                    let code = format!(\"#[{}]\", name);\n-                    msg.push_str(&format!(\"`{}`\", &code));\n-                    suggestions.push(code);\n-                }\n-                if let Some(descr) = template.list {\n-                    if !first {\n-                        msg.push_str(\" or \");\n-                    }\n-                    first = false;\n-                    let code = format!(\"#[{}({})]\", name, descr);\n-                    msg.push_str(&format!(\"`{}`\", &code));\n-                    suggestions.push(code);\n-                }\n-                if let Some(descr) = template.name_value_str {\n-                    if !first {\n-                        msg.push_str(\" or \");\n-                    }\n-                    let code = format!(\"#[{} = \\\"{}\\\"]\", name, descr);\n-                    msg.push_str(&format!(\"`{}`\", &code));\n-                    suggestions.push(code);\n-                }\n-                if should_warn(name) {\n-                    self.context.parse_sess.buffer_lint(\n-                        BufferedEarlyLintId::IllFormedAttributeInput,\n-                        meta.span,\n-                        ast::CRATE_NODE_ID,\n-                        &msg,\n-                    );\n-                } else {\n-                    self.context.parse_sess.span_diagnostic.struct_span_err(meta.span, &error_msg)\n-                        .span_suggestions(\n-                            meta.span,\n-                            if suggestions.len() == 1 {\n-                                \"must be of the form\"\n-                            } else {\n-                                \"the following are the possible correct uses\"\n-                            },\n-                            suggestions.into_iter(),\n-                            Applicability::HasPlaceholders,\n-                        ).emit();\n-                }\n-            }\n-            Err(mut err) => err.emit(),\n-        }\n-    }\n }\n \n impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n@@ -2005,7 +1919,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n         match attr_info {\n             // `rustc_dummy` doesn't have any restrictions specific to built-in attributes.\n             Some(&(name, _, template, _)) if name != sym::rustc_dummy =>\n-                self.check_builtin_attribute(attr, name, template),\n+                check_builtin_attribute(self.context.parse_sess, attr, name, template),\n             _ => if let Some(TokenTree::Token(token)) = attr.tokens.trees().next() {\n                 if token == token::Eq {\n                     // All key-value attributes are restricted to meta-item syntax."}, {"sha": "196db3d7baa5b965bd29d8e6f5294915734213c3", "filename": "src/libsyntax_ext/global_allocator.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Flibsyntax_ext%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_allocator.rs?ref=76b1ffaf6c70abd3fa4da2e694dc709116258098", "patch": "@@ -1,31 +1,22 @@\n-use errors::Applicability;\n-use syntax::ast::{self, Arg, Attribute, Expr, FnHeader, Generics, Ident, Item};\n use syntax::ast::{ItemKind, Mutability, Ty, TyKind, Unsafety, VisibilityKind};\n-use syntax::source_map::respan;\n+use syntax::ast::{self, Arg, Attribute, Expr, FnHeader, Generics, Ident, Item};\n+use syntax::attr::check_builtin_macro_attribute;\n use syntax::ext::allocator::{AllocatorKind, AllocatorMethod, AllocatorTy, ALLOCATOR_METHODS};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::ptr::P;\n+use syntax::source_map::respan;\n use syntax::symbol::{kw, sym};\n use syntax_pos::Span;\n \n pub fn expand(\n     ecx: &mut ExtCtxt<'_>,\n-    span: Span,\n+    _span: Span,\n     meta_item: &ast::MetaItem,\n     item: Annotatable,\n ) -> Vec<Annotatable> {\n-    if !meta_item.is_word() {\n-        let msg = format!(\"malformed `{}` attribute input\", meta_item.path);\n-        ecx.parse_sess.span_diagnostic.struct_span_err(span, &msg)\n-            .span_suggestion(\n-                span,\n-                \"must be of the form\",\n-                format!(\"`#[{}]`\", meta_item.path),\n-                Applicability::MachineApplicable\n-            ).emit();\n-    }\n+    check_builtin_macro_attribute(ecx, meta_item, sym::global_allocator);\n \n     let not_static = |item: Annotatable| {\n         ecx.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");"}, {"sha": "d381c42f9ce84a1b543912144a35272f90c1e7d1", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=76b1ffaf6c70abd3fa4da2e694dc709116258098", "patch": "@@ -1,31 +1,34 @@\n /// The expansion from a test function to the appropriate test struct for libtest\n /// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n \n+use syntax::ast;\n+use syntax::attr::{self, check_builtin_macro_attribute};\n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::SyntaxContext;\n-use syntax::attr;\n-use syntax::ast;\n use syntax::print::pprust;\n use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n+\n use std::iter;\n \n pub fn expand_test(\n     cx: &mut ExtCtxt<'_>,\n     attr_sp: Span,\n-    _meta_item: &ast::MetaItem,\n+    meta_item: &ast::MetaItem,\n     item: Annotatable,\n ) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(cx, meta_item, sym::test);\n     expand_test_or_bench(cx, attr_sp, item, false)\n }\n \n pub fn expand_bench(\n     cx: &mut ExtCtxt<'_>,\n     attr_sp: Span,\n-    _meta_item: &ast::MetaItem,\n+    meta_item: &ast::MetaItem,\n     item: Annotatable,\n ) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(cx, meta_item, sym::bench);\n     expand_test_or_bench(cx, attr_sp, item, true)\n }\n "}, {"sha": "ea4a8d541ab9928f8636bdde77b24a1adfc17532", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=76b1ffaf6c70abd3fa4da2e694dc709116258098", "patch": "@@ -9,20 +9,23 @@\n // We mark item with an inert attribute \"rustc_test_marker\" which the test generation\n // logic will pick up on.\n \n+use syntax::ast;\n+use syntax::attr::check_builtin_macro_attribute;\n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::ext::hygiene::SyntaxContext;\n-use syntax::ast;\n use syntax::source_map::respan;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n pub fn expand(\n     ecx: &mut ExtCtxt<'_>,\n     attr_sp: Span,\n-    _meta_item: &ast::MetaItem,\n+    meta_item: &ast::MetaItem,\n     anno_item: Annotatable\n ) -> Vec<Annotatable> {\n+    check_builtin_macro_attribute(ecx, meta_item, sym::test_case);\n+\n     if !ecx.ecfg.should_test { return vec![]; }\n \n     let sp = attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(ecx.current_expansion.id));"}, {"sha": "dfff2a7e7094d368a9a83a8854c3a429557fdcb9", "filename": "src/test/ui/allocator/allocator-args.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fallocator%2Fallocator-args.stderr?ref=76b1ffaf6c70abd3fa4da2e694dc709116258098", "patch": "@@ -2,7 +2,7 @@ error: malformed `global_allocator` attribute input\n   --> $DIR/allocator-args.rs:10:1\n    |\n LL | #[global_allocator(malloc)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: ``#[global_allocator]``\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[global_allocator]`\n \n error: aborting due to previous error\n "}, {"sha": "e82cb93c6359eb733f9300526fc4c9431c2a5a22", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-bench.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-bench.stderr?ref=76b1ffaf6c70abd3fa4da2e694dc709116258098", "patch": "@@ -1,7 +1,13 @@\n+error: malformed `bench` attribute input\n+  --> $DIR/issue-43106-gating-of-bench.rs:15:1\n+   |\n+LL | #![bench                   = \"4100\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[bench]`\n+\n error[E0601]: `main` function not found in crate `issue_43106_gating_of_bench`\n    |\n    = note: consider adding a `main` function to `$DIR/issue-43106-gating-of-bench.rs`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0601`."}, {"sha": "9866fa3730ef2dce697ac2c6a09e25bcee315e7f", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-test.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76b1ffaf6c70abd3fa4da2e694dc709116258098/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-test.stderr?ref=76b1ffaf6c70abd3fa4da2e694dc709116258098", "patch": "@@ -1,7 +1,13 @@\n+error: malformed `test` attribute input\n+  --> $DIR/issue-43106-gating-of-test.rs:10:1\n+   |\n+LL | #![test                    = \"4200\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: must be of the form: `#[test]`\n+\n error[E0601]: `main` function not found in crate `issue_43106_gating_of_test`\n    |\n    = note: consider adding a `main` function to `$DIR/issue-43106-gating-of-test.rs`\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0601`."}]}