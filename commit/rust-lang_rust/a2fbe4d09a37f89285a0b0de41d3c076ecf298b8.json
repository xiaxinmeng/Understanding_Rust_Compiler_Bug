{"sha": "a2fbe4d09a37f89285a0b0de41d3c076ecf298b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyZmJlNGQwOWEzN2Y4OTI4NWEwYjBkZTQxZDNjMDc2ZWNmMjk4Yjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-10T14:04:02Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-07-11T18:37:45Z"}, "message": "Construct the graph only when it is needed to report errors.", "tree": {"sha": "b2263b921b26e64f276e9b5d936c4b37f7856427", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2263b921b26e64f276e9b5d936c4b37f7856427"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2fbe4d09a37f89285a0b0de41d3c076ecf298b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2fbe4d09a37f89285a0b0de41d3c076ecf298b8", "html_url": "https://github.com/rust-lang/rust/commit/a2fbe4d09a37f89285a0b0de41d3c076ecf298b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2fbe4d09a37f89285a0b0de41d3c076ecf298b8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e706590e70cb0a050834ba75f46cbdd5a71cf5e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e706590e70cb0a050834ba75f46cbdd5a71cf5e3", "html_url": "https://github.com/rust-lang/rust/commit/e706590e70cb0a050834ba75f46cbdd5a71cf5e3"}], "stats": {"total": 112, "additions": 57, "deletions": 55}, "files": [{"sha": "c3b35aba5181be6254e2d0956a77e058ef85a0f8", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 57, "deletions": 55, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/a2fbe4d09a37f89285a0b0de41d3c076ecf298b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2fbe4d09a37f89285a0b0de41d3c076ecf298b8/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=a2fbe4d09a37f89285a0b0de41d3c076ecf298b8", "patch": "@@ -722,63 +722,21 @@ struct RegionAndOrigin {\n     origin: SubregionOrigin,\n }\n \n-type Graph = graph::Graph<(), Constraint>;\n-type GraphNode = graph::Node<()>;\n-type GraphEdge = graph::Edge<Constraint>;\n+type RegionGraph = graph::Graph<(), Constraint>;\n \n impl RegionVarBindings {\n-    fn infer_variable_values(&mut self,\n+    fn infer_variable_values(&self,\n                              errors: &mut OptVec<RegionResolutionError>)\n                              -> ~[VarValue] {\n         let mut var_data = self.construct_var_data();\n         self.expansion(var_data);\n         self.contraction(var_data);\n-        let graph = self.construct_graph();\n-        self.collect_concrete_region_errors(&graph, errors);\n-        self.extract_values_and_collect_conflicts(&graph, var_data, errors)\n+        self.collect_concrete_region_errors(errors);\n+        self.extract_values_and_collect_conflicts(var_data, errors)\n     }\n \n-    fn construct_graph(&mut self) -> Graph {\n-        let num_vars = self.num_vars();\n-        let num_edges = self.constraints.len();\n-\n-        let mut graph = graph::Graph::with_capacity(num_vars + 1,\n-                                                    num_edges);\n-\n-        for uint::range(0, num_vars) |var_idx| {\n-            graph.add_node(());\n-        }\n-        let dummy_idx = graph.add_node(());\n-\n-        for self.constraints.iter().advance |(constraint, _)| {\n-            match *constraint {\n-                ConstrainVarSubVar(a_id, b_id) => {\n-                    graph.add_edge(NodeIndex(a_id.to_uint()),\n-                                   NodeIndex(b_id.to_uint()),\n-                                   *constraint);\n-                }\n-                ConstrainRegSubVar(_, b_id) => {\n-                    graph.add_edge(dummy_idx,\n-                                   NodeIndex(b_id.to_uint()),\n-                                   *constraint);\n-                }\n-                ConstrainVarSubReg(a_id, _) => {\n-                    graph.add_edge(NodeIndex(a_id.to_uint()),\n-                                   dummy_idx,\n-                                   *constraint);\n-                }\n-                ConstrainRegSubReg(*) => {\n-                    // Relations between two concrete regions do not\n-                    // require an edge in the graph.\n-                }\n-            }\n-        }\n-\n-        return graph;\n-    }\n-\n-    fn construct_var_data(&mut self) -> ~[VarData] {\n-        vec::from_fn(self.num_vars(), |var_idx| {\n+    fn construct_var_data(&self) -> ~[VarData] {\n+        vec::from_fn(self.num_vars(), |_| {\n             VarData {\n                 // All nodes are initially classified as contracting; during\n                 // the expansion phase, we will shift the classification for\n@@ -790,7 +748,7 @@ impl RegionVarBindings {\n         })\n     }\n \n-    fn expansion(&mut self, var_data: &mut [VarData]) {\n+    fn expansion(&self, var_data: &mut [VarData]) {\n         do self.iterate_until_fixed_point(\"Expansion\") |constraint| {\n             match *constraint {\n               ConstrainRegSubVar(a_region, b_vid) => {\n@@ -957,7 +915,6 @@ impl RegionVarBindings {\n \n     fn collect_concrete_region_errors(\n         &self,\n-        graph: &Graph,\n         errors: &mut OptVec<RegionResolutionError>)\n     {\n         for self.constraints.iter().advance |(constraint, _)| {\n@@ -985,7 +942,6 @@ impl RegionVarBindings {\n \n     fn extract_values_and_collect_conflicts(\n         &self,\n-        graph: &Graph,\n         var_data: &[VarData],\n         errors: &mut OptVec<RegionResolutionError>)\n         -> ~[VarValue]\n@@ -1005,6 +961,8 @@ impl RegionVarBindings {\n         // overlapping locations.\n         let mut dup_vec = vec::from_elem(self.num_vars(), uint::max_value);\n \n+        let mut opt_graph = None;\n+\n         for uint::range(0, self.num_vars()) |idx| {\n             match var_data[idx].value {\n                 Value(_) => {\n@@ -1040,6 +998,11 @@ impl RegionVarBindings {\n                        starts to create problems we'll have to revisit\n                        this portion of the code and think hard about it. =) */\n \n+                    if opt_graph.is_none() {\n+                        opt_graph = Some(self.construct_graph());\n+                    }\n+                    let graph = opt_graph.get_ref();\n+\n                     let node_vid = RegionVid { id: idx };\n                     match var_data[idx].classification {\n                         Expanding => {\n@@ -1058,9 +1021,48 @@ impl RegionVarBindings {\n         vec::from_fn(self.num_vars(), |idx| var_data[idx].value)\n     }\n \n+    fn construct_graph(&self) -> RegionGraph {\n+        let num_vars = self.num_vars();\n+        let num_edges = self.constraints.len();\n+\n+        let mut graph = graph::Graph::with_capacity(num_vars + 1,\n+                                                    num_edges);\n+\n+        for uint::range(0, num_vars) |_| {\n+            graph.add_node(());\n+        }\n+        let dummy_idx = graph.add_node(());\n+\n+        for self.constraints.iter().advance |(constraint, _)| {\n+            match *constraint {\n+                ConstrainVarSubVar(a_id, b_id) => {\n+                    graph.add_edge(NodeIndex(a_id.to_uint()),\n+                                   NodeIndex(b_id.to_uint()),\n+                                   *constraint);\n+                }\n+                ConstrainRegSubVar(_, b_id) => {\n+                    graph.add_edge(dummy_idx,\n+                                   NodeIndex(b_id.to_uint()),\n+                                   *constraint);\n+                }\n+                ConstrainVarSubReg(a_id, _) => {\n+                    graph.add_edge(NodeIndex(a_id.to_uint()),\n+                                   dummy_idx,\n+                                   *constraint);\n+                }\n+                ConstrainRegSubReg(*) => {\n+                    // Relations between two concrete regions do not\n+                    // require an edge in the graph.\n+                }\n+            }\n+        }\n+\n+        return graph;\n+    }\n+\n     fn collect_error_for_expanding_node(\n         &self,\n-        graph: &Graph,\n+        graph: &RegionGraph,\n         var_data: &[VarData],\n         dup_vec: &mut [uint],\n         node_idx: RegionVid,\n@@ -1105,7 +1107,7 @@ impl RegionVarBindings {\n \n     fn collect_error_for_contracting_node(\n         &self,\n-        graph: &Graph,\n+        graph: &RegionGraph,\n         var_data: &[VarData],\n         dup_vec: &mut [uint],\n         node_idx: RegionVid,\n@@ -1148,7 +1150,7 @@ impl RegionVarBindings {\n     }\n \n     fn collect_concrete_regions(&self,\n-                                graph: &Graph,\n+                                graph: &RegionGraph,\n                                 var_data: &[VarData],\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction,\n@@ -1202,7 +1204,7 @@ impl RegionVarBindings {\n \n         fn process_edges(this: &RegionVarBindings,\n                          state: &mut WalkState,\n-                         graph: &Graph,\n+                         graph: &RegionGraph,\n                          source_vid: RegionVid,\n                          dir: Direction) {\n             debug!(\"process_edges(source_vid=%?, dir=%?)\", source_vid, dir);"}]}