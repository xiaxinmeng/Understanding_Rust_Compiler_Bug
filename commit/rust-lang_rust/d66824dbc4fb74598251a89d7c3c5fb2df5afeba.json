{"sha": "d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "node_id": "C_kwDOAAsO6NoAKGQ2NjgyNGRiYzRmYjc0NTk4MjUxYTg5ZDdjM2M1ZmIyZGY1YWZlYmE", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-11-21T16:51:16Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-12-15T16:07:28Z"}, "message": "Make alignment checks a future incompat lint", "tree": {"sha": "14f9cf94e9a62acd51d8dc04d9e4df8f5cccd7d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14f9cf94e9a62acd51d8dc04d9e4df8f5cccd7d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "html_url": "https://github.com/rust-lang/rust/commit/d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed71e32e1440765d3e133e9892d59ca130477cec", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed71e32e1440765d3e133e9892d59ca130477cec", "html_url": "https://github.com/rust-lang/rust/commit/ed71e32e1440765d3e133e9892d59ca130477cec"}], "stats": {"total": 250, "additions": 180, "deletions": 70}, "files": [{"sha": "18e01567ca35e44888e52e19abd6bb07edca0d0e", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "patch": "@@ -1,3 +1,4 @@\n+use crate::const_eval::CheckAlignment;\n use std::borrow::Cow;\n \n use either::{Left, Right};\n@@ -76,7 +77,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n             None => InternKind::Constant,\n         }\n     };\n-    ecx.machine.check_alignment = false; // interning doesn't need to respect alignment\n+    ecx.machine.check_alignment = CheckAlignment::No; // interning doesn't need to respect alignment\n     intern_const_alloc_recursive(ecx, intern_kind, &ret)?;\n     // we leave alignment checks off, since this `ecx` will not be used for further evaluation anyway\n \n@@ -102,11 +103,7 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n         tcx,\n         root_span,\n         param_env,\n-        CompileTimeInterpreter::new(\n-            tcx.const_eval_limit(),\n-            can_access_statics,\n-            /*check_alignment:*/ false,\n-        ),\n+        CompileTimeInterpreter::new(tcx.const_eval_limit(), can_access_statics, CheckAlignment::No),\n     )\n }\n \n@@ -311,7 +308,11 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n         CompileTimeInterpreter::new(\n             tcx.const_eval_limit(),\n             /*can_access_statics:*/ is_static,\n-            /*check_alignment:*/ true,\n+            if tcx.sess.opts.unstable_opts.extra_const_ub_checks {\n+                CheckAlignment::Error\n+            } else {\n+                CheckAlignment::FutureIncompat\n+            },\n         ),\n     );\n "}, {"sha": "355ad66929629477617bc9fe4c005615860bd231", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "patch": "@@ -47,14 +47,34 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     pub(super) can_access_statics: bool,\n \n     /// Whether to check alignment during evaluation.\n-    pub(super) check_alignment: bool,\n+    pub(super) check_alignment: CheckAlignment,\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum CheckAlignment {\n+    /// Ignore alignment when following relocations.\n+    /// This is mainly used in interning.\n+    No,\n+    /// Hard error when dereferencing a misaligned pointer.\n+    Error,\n+    /// Emit a future incompat lint when dereferencing a misaligned pointer.\n+    FutureIncompat,\n+}\n+\n+impl CheckAlignment {\n+    pub fn should_check(&self) -> bool {\n+        match self {\n+            CheckAlignment::No => false,\n+            CheckAlignment::Error | CheckAlignment::FutureIncompat => true,\n+        }\n+    }\n }\n \n impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n     pub(crate) fn new(\n         const_eval_limit: Limit,\n         can_access_statics: bool,\n-        check_alignment: bool,\n+        check_alignment: CheckAlignment,\n     ) -> Self {\n         CompileTimeInterpreter {\n             steps_remaining: const_eval_limit.0,\n@@ -309,7 +329,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     const PANIC_ON_ALLOC_FAIL: bool = false; // will be raised as a proper error\n \n     #[inline(always)]\n-    fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> CheckAlignment {\n         ecx.machine.check_alignment\n     }\n "}, {"sha": "f551b5c29114d9984fcf108ceb1b9e12628db580", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "patch": "@@ -248,6 +248,15 @@ impl<'mir, 'tcx, Prov: Provenance, Extra> Frame<'mir, 'tcx, Prov, Extra> {\n             Right(span) => span,\n         }\n     }\n+\n+    pub fn lint_root(&self) -> Option<hir::HirId> {\n+        self.current_source_info().and_then(|source_info| {\n+            match &self.body.source_scopes[source_info.scope].local_data {\n+                mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n+                mir::ClearCrossCrate::Clear => None,\n+            }\n+        })\n+    }\n }\n \n impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n@@ -954,12 +963,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // This deliberately does *not* honor `requires_caller_location` since it is used for much\n         // more than just panics.\n         for frame in stack.iter().rev() {\n-            let lint_root = frame.current_source_info().and_then(|source_info| {\n-                match &frame.body.source_scopes[source_info.scope].local_data {\n-                    mir::ClearCrossCrate::Set(data) => Some(data.lint_root),\n-                    mir::ClearCrossCrate::Clear => None,\n-                }\n-            });\n+            let lint_root = frame.lint_root();\n             let span = frame.current_span();\n \n             frames.push(FrameInfo { span, instance: frame.instance, lint_root });"}, {"sha": "f52545317ea1a48fca2f750fb7aaf3ca9fd6831f", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "patch": "@@ -13,6 +13,8 @@ use rustc_span::def_id::DefId;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi as CallAbi;\n \n+use crate::const_eval::CheckAlignment;\n+\n use super::{\n     AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n     MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar, StackPopUnwind,\n@@ -122,7 +124,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     const PANIC_ON_ALLOC_FAIL: bool;\n \n     /// Whether memory accesses should be alignment-checked.\n-    fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n+    fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> CheckAlignment;\n \n     /// Whether, when checking alignment, we should look at the actual address and thus support\n     /// custom alignment logic based on whatever the integer address happens to be."}, {"sha": "ffd5e05bcc40aa678811a63877e2d697404920ee", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 62, "deletions": 21, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "patch": "@@ -14,10 +14,15 @@ use std::ptr;\n \n use rustc_ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::CRATE_HIR_ID;\n use rustc_middle::mir::display_allocation;\n+use rustc_middle::mir::interpret::UndefinedBehaviorInfo;\n use rustc_middle::ty::{self, Instance, ParamEnv, Ty, TyCtxt};\n+use rustc_session::lint::builtin::INVALID_ALIGNMENT;\n use rustc_target::abi::{Align, HasDataLayout, Size};\n \n+use crate::const_eval::CheckAlignment;\n+\n use super::{\n     alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc, InterpCx,\n     InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance, Scalar,\n@@ -377,7 +382,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             ptr,\n             size,\n             align,\n-            /* force_alignment_check */ true,\n+            CheckAlignment::Error,\n             msg,\n             |alloc_id, _, _| {\n                 let (size, align) = self.get_live_alloc_size_and_align(alloc_id)?;\n@@ -396,27 +401,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ptr: Pointer<Option<M::Provenance>>,\n         size: Size,\n         align: Align,\n-        force_alignment_check: bool,\n+        check: CheckAlignment,\n         msg: CheckInAllocMsg,\n         alloc_size: impl FnOnce(\n             AllocId,\n             Size,\n             M::ProvenanceExtra,\n         ) -> InterpResult<'tcx, (Size, Align, T)>,\n     ) -> InterpResult<'tcx, Option<T>> {\n-        fn check_offset_align<'tcx>(offset: u64, align: Align) -> InterpResult<'tcx> {\n-            if offset % align.bytes() == 0 {\n-                Ok(())\n-            } else {\n-                // The biggest power of two through which `offset` is divisible.\n-                let offset_pow2 = 1 << offset.trailing_zeros();\n-                throw_ub!(AlignmentCheckFailed {\n-                    has: Align::from_bytes(offset_pow2).unwrap(),\n-                    required: align,\n-                })\n-            }\n-        }\n-\n         Ok(match self.ptr_try_get_alloc_id(ptr) {\n             Err(addr) => {\n                 // We couldn't get a proper allocation. This is only okay if the access size is 0,\n@@ -425,8 +417,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     throw_ub!(DanglingIntPointer(addr, msg));\n                 }\n                 // Must be aligned.\n-                if force_alignment_check {\n-                    check_offset_align(addr, align)?;\n+                if check.should_check() {\n+                    self.check_offset_align(addr, align, check)?;\n                 }\n                 None\n             }\n@@ -449,16 +441,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 }\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n-                if force_alignment_check {\n+                if check.should_check() {\n                     if M::use_addr_for_alignment_check(self) {\n                         // `use_addr_for_alignment_check` can only be true if `OFFSET_IS_ADDR` is true.\n-                        check_offset_align(ptr.addr().bytes(), align)?;\n+                        self.check_offset_align(ptr.addr().bytes(), align, check)?;\n                     } else {\n                         // Check allocation alignment and offset alignment.\n                         if alloc_align.bytes() < align.bytes() {\n-                            throw_ub!(AlignmentCheckFailed { has: alloc_align, required: align });\n+                            self.alignment_check_failed(alloc_align, align, check)?;\n                         }\n-                        check_offset_align(offset.bytes(), align)?;\n+                        self.check_offset_align(offset.bytes(), align, check)?;\n                     }\n                 }\n \n@@ -468,6 +460,55 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         })\n     }\n+\n+    fn check_offset_align(\n+        &self,\n+        offset: u64,\n+        align: Align,\n+        check: CheckAlignment,\n+    ) -> InterpResult<'tcx> {\n+        if offset % align.bytes() == 0 {\n+            Ok(())\n+        } else {\n+            // The biggest power of two through which `offset` is divisible.\n+            let offset_pow2 = 1 << offset.trailing_zeros();\n+            self.alignment_check_failed(Align::from_bytes(offset_pow2).unwrap(), align, check)\n+        }\n+    }\n+\n+    fn alignment_check_failed(\n+        &self,\n+        has: Align,\n+        required: Align,\n+        check: CheckAlignment,\n+    ) -> InterpResult<'tcx, ()> {\n+        match check {\n+            CheckAlignment::Error => {\n+                throw_ub!(AlignmentCheckFailed { has, required })\n+            }\n+            CheckAlignment::No => span_bug!(\n+                self.cur_span(),\n+                \"`alignment_check_failed` called when no alignment check requested\"\n+            ),\n+            CheckAlignment::FutureIncompat => self.tcx.struct_span_lint_hir(\n+                INVALID_ALIGNMENT,\n+                self.stack().iter().find_map(|frame| frame.lint_root()).unwrap_or(CRATE_HIR_ID),\n+                self.cur_span(),\n+                UndefinedBehaviorInfo::AlignmentCheckFailed { has, required }.to_string(),\n+                |db| {\n+                    let mut stacktrace = self.generate_stacktrace();\n+                    // Filter out `requires_caller_location` frames.\n+                    stacktrace\n+                        .retain(|frame| !frame.instance.def.requires_caller_location(*self.tcx));\n+                    for frame in stacktrace {\n+                        db.span_label(frame.span, format!(\"inside `{}`\", frame.instance));\n+                    }\n+                    db\n+                },\n+            ),\n+        }\n+        Ok(())\n+    }\n }\n \n /// Allocation accessors"}, {"sha": "905eb71bb18edde28b2eeb30f7d406defedcf4ce", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "patch": "@@ -364,13 +364,8 @@ where\n             .size_and_align_of_mplace(&mplace)?\n             .unwrap_or((mplace.layout.size, mplace.layout.align.abi));\n         assert!(mplace.align <= align, \"dynamic alignment less strict than static one?\");\n-        let align = M::enforce_alignment(self).then_some(align);\n-        self.check_ptr_access_align(\n-            mplace.ptr,\n-            size,\n-            align.unwrap_or(Align::ONE),\n-            CheckInAllocMsg::DerefTest,\n-        )?;\n+        let align = if M::enforce_alignment(self).should_check() { align } else { Align::ONE };\n+        self.check_ptr_access_align(mplace.ptr, size, align, CheckInAllocMsg::DerefTest)?;\n         Ok(())\n     }\n "}, {"sha": "4ce107ea68d4f0f3869cebe3cce00c706a42f58d", "filename": "compiler/rustc_const_eval/src/util/might_permit_raw_init.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmight_permit_raw_init.rs?ref=d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "patch": "@@ -3,7 +3,7 @@ use rustc_middle::ty::{ParamEnv, TyCtxt};\n use rustc_session::Limit;\n use rustc_target::abi::{Abi, FieldsShape, InitKind, Scalar, Variants};\n \n-use crate::const_eval::CompileTimeInterpreter;\n+use crate::const_eval::{CheckAlignment, CompileTimeInterpreter};\n use crate::interpret::{InterpCx, MemoryKind, OpTy};\n \n /// Determines if this type permits \"raw\" initialization by just transmuting some memory into an\n@@ -41,7 +41,7 @@ fn might_permit_raw_init_strict<'tcx>(\n     let machine = CompileTimeInterpreter::new(\n         Limit::new(0),\n         /*can_access_statics:*/ false,\n-        /*check_alignment:*/ true,\n+        CheckAlignment::Error,\n     );\n \n     let mut cx = InterpCx::new(tcx, rustc_span::DUMMY_SP, ParamEnv::reveal_all(), machine);"}, {"sha": "dddc200b2fb1a1bcb88af87cb6a32c72f0d3072c", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "patch": "@@ -1019,6 +1019,42 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    /// The `invalid_alignment` lint detects dereferences of misaligned pointers during\n+    /// constant evluation.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// const FOO: () = unsafe {\n+    ///     let x = [0_u8; 10];\n+    ///     let y = x.as_ptr() as *const u32;\n+    ///     *y; // the address of a `u8` array is unknown and thus we don't know if\n+    ///     // it is aligned enough for reading a `u32`.\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// The compiler allowed dereferencing raw pointers irrespective of alignment\n+    /// during const eval due to the const evaluator at the time not making it easy\n+    /// or cheap to check. Now that it is both, this is not accepted anymore.\n+    ///\n+    /// Since it was undefined behaviour to begin with, this breakage does not violate\n+    /// Rust's stability guarantees. Using undefined behaviour can cause arbitrary\n+    /// behaviour, including failure to build.\n+    ///\n+    /// [future-incompatible]: ../index.md#future-incompatible-lints\n+    pub INVALID_ALIGNMENT,\n+    Deny,\n+    \"raw pointers must be aligned before dereferencing\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #68585 <https://github.com/rust-lang/rust/issues/104616>\",\n+    };\n+}\n+\n declare_lint! {\n     /// The `exported_private_dependencies` lint detects private dependencies\n     /// that are exposed in a public interface."}, {"sha": "c8ba6310d590be1861dea20b5f04d25b99f98a4a", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "patch": "@@ -6,6 +6,7 @@ use std::cell::Cell;\n use either::Right;\n \n use rustc_ast::Mutability;\n+use rustc_const_eval::const_eval::CheckAlignment;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::DefKind;\n use rustc_index::bit_set::BitSet;\n@@ -186,10 +187,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     type MemoryKind = !;\n \n     #[inline(always)]\n-    fn enforce_alignment(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_alignment(_ecx: &InterpCx<'mir, 'tcx, Self>) -> CheckAlignment {\n         // We do not check for alignment to avoid having to carry an `Align`\n         // in `ConstValue::ByRef`.\n-        false\n+        CheckAlignment::No\n     }\n \n     #[inline(always)]"}, {"sha": "37675426f1916a62e71384dc9fdca7a6a6bb4eaf", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "patch": "@@ -2,6 +2,7 @@\n //!\n //! Currently, this pass only propagates scalar values.\n \n+use rustc_const_eval::const_eval::CheckAlignment;\n use rustc_const_eval::interpret::{ConstValue, ImmTy, Immediate, InterpCx, Scalar};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::mir::visit::{MutVisitor, Visitor};\n@@ -448,7 +449,7 @@ impl<'mir, 'tcx> rustc_const_eval::interpret::Machine<'mir, 'tcx> for DummyMachi\n     type MemoryKind = !;\n     const PANIC_ON_ALLOC_FAIL: bool = true;\n \n-    fn enforce_alignment(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+    fn enforce_alignment(_ecx: &InterpCx<'mir, 'tcx, Self>) -> CheckAlignment {\n         unimplemented!()\n     }\n "}, {"sha": "8cd3918c0b4077e0bee864c5c87be00e248c2fde", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.32bit.stderr", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.32bit.stderr?ref=d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "patch": "@@ -148,20 +148,22 @@ LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n                \u257e\u2500alloc41\u2500\u257c                                     \u2502 \u257e\u2500\u2500\u257c\n            }\n \n-error[E0080]: evaluation of constant value failed\n+error: accessing memory with alignment 1, but alignment 4 is required\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = note: accessing memory with alignment 1, but alignment 4 is required\n-   |\n-note: inside `std::ptr::read::<u32>`\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-note: inside `ptr::const_ptr::<impl *const u32>::read`\n+   = note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `UNALIGNED_READ`\n-  --> $DIR/ub-ref-ptr.rs:65:5\n+   |\n+   = note: inside `ptr::const_ptr::<impl *const u32>::read`\n+   |\n+  ::: $DIR/ub-ref-ptr.rs:65:5\n    |\n LL |     ptr.read();\n-   |     ^^^^^^^^^^\n+   |     ---------- inside `UNALIGNED_READ`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n+   = note: `#[deny(invalid_alignment)]` on by default\n \n error: aborting due to 15 previous errors\n "}, {"sha": "77c52788a9cb9e075e7bd2921c7eb4659032f83f", "filename": "src/test/ui/consts/const-eval/ub-ref-ptr.64bit.stderr", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref-ptr.64bit.stderr?ref=d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "patch": "@@ -148,20 +148,22 @@ LL | const DATA_FN_PTR: fn() = unsafe { mem::transmute(&13) };\n                \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc41\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n            }\n \n-error[E0080]: evaluation of constant value failed\n+error: accessing memory with alignment 1, but alignment 4 is required\n   --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n    |\n-   = note: accessing memory with alignment 1, but alignment 4 is required\n-   |\n-note: inside `std::ptr::read::<u32>`\n-  --> $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n-note: inside `ptr::const_ptr::<impl *const u32>::read`\n+   = note: inside `std::ptr::read::<u32>`\n   --> $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-note: inside `UNALIGNED_READ`\n-  --> $DIR/ub-ref-ptr.rs:65:5\n+   |\n+   = note: inside `ptr::const_ptr::<impl *const u32>::read`\n+   |\n+  ::: $DIR/ub-ref-ptr.rs:65:5\n    |\n LL |     ptr.read();\n-   |     ^^^^^^^^^^\n+   |     ---------- inside `UNALIGNED_READ`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #68585 <https://github.com/rust-lang/rust/issues/104616>\n+   = note: `#[deny(invalid_alignment)]` on by default\n \n error: aborting due to 15 previous errors\n "}, {"sha": "8f3c979f5ebab242423528d8a61d40e087e097e2", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d66824dbc4fb74598251a89d7c3c5fb2df5afeba/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=d66824dbc4fb74598251a89d7c3c5fb2df5afeba", "patch": "@@ -24,6 +24,7 @@ use rustc_span::def_id::{CrateNum, DefId};\n use rustc_span::Symbol;\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n+use rustc_const_eval::const_eval::CheckAlignment;\n \n use crate::{\n     concurrency::{data_race, weak_memory},\n@@ -752,8 +753,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     const PANIC_ON_ALLOC_FAIL: bool = false;\n \n     #[inline(always)]\n-    fn enforce_alignment(ecx: &MiriInterpCx<'mir, 'tcx>) -> bool {\n-        ecx.machine.check_alignment != AlignmentCheck::None\n+    fn enforce_alignment(ecx: &MiriInterpCx<'mir, 'tcx>) -> CheckAlignment {\n+        if ecx.machine.check_alignment == AlignmentCheck::None {\n+            CheckAlignment::No\n+        } else {\n+            CheckAlignment::Error\n+        }\n     }\n \n     #[inline(always)]"}]}