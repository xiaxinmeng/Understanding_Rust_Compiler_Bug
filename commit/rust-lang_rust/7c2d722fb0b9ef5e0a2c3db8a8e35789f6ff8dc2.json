{"sha": "7c2d722fb0b9ef5e0a2c3db8a8e35789f6ff8dc2", "node_id": "C_kwDOAAsO6NoAKDdjMmQ3MjJmYjBiOWVmNWUwYTJjM2RiOGE4ZTM1Nzg5ZjZmZjhkYzI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-06T21:13:09Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-08-06T21:13:09Z"}, "message": "Simplify encoding a bit.", "tree": {"sha": "e0db0ee8374b28a68163d02a050ce90b73173fd5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0db0ee8374b28a68163d02a050ce90b73173fd5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c2d722fb0b9ef5e0a2c3db8a8e35789f6ff8dc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c2d722fb0b9ef5e0a2c3db8a8e35789f6ff8dc2", "html_url": "https://github.com/rust-lang/rust/commit/7c2d722fb0b9ef5e0a2c3db8a8e35789f6ff8dc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c2d722fb0b9ef5e0a2c3db8a8e35789f6ff8dc2/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d74af405eb349922e7aca4ecc510991bb5ae9ab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d74af405eb349922e7aca4ecc510991bb5ae9ab4", "html_url": "https://github.com/rust-lang/rust/commit/d74af405eb349922e7aca4ecc510991bb5ae9ab4"}], "stats": {"total": 69, "additions": 35, "deletions": 34}, "files": [{"sha": "463cfece715088930006da83d01c9963e7bd33d8", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7c2d722fb0b9ef5e0a2c3db8a8e35789f6ff8dc2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c2d722fb0b9ef5e0a2c3db8a8e35789f6ff8dc2/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=7c2d722fb0b9ef5e0a2c3db8a8e35789f6ff8dc2", "patch": "@@ -234,13 +234,17 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n             s.source_file_cache =\n                 (source_map.files()[source_file_index].clone(), source_file_index);\n         }\n+        let (ref source_file, source_file_index) = s.source_file_cache;\n \n-        if !s.source_file_cache.0.contains(span.hi) {\n+        if !source_file.contains(span.hi) {\n             // Unfortunately, macro expansion still sometimes generates Spans\n             // that malformed in this way.\n             return TAG_PARTIAL_SPAN.encode(s);\n         }\n \n+        // Length is independent of the span provenance.\n+        let len = span.hi - span.lo;\n+\n         // There are two possible cases here:\n         // 1. This span comes from a 'foreign' crate - e.g. some crate upstream of the\n         // crate we are writing metadata for. When the metadata for *this* crate gets\n@@ -257,47 +261,44 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for Span {\n         // if we're a proc-macro crate.\n         // This allows us to avoid loading the dependencies of proc-macro crates: all of\n         // the information we need to decode `Span`s is stored in the proc-macro crate.\n-        let (tag, lo, hi, metadata_index) =\n-            if s.source_file_cache.0.is_imported() && !s.is_proc_macro {\n-                // To simplify deserialization, we 'rebase' this span onto the crate it originally came from\n-                // (the crate that 'owns' the file it references. These rebased 'lo' and 'hi' values\n-                // are relative to the source map information for the 'foreign' crate whose CrateNum\n-                // we write into the metadata. This allows `imported_source_files` to binary\n-                // search through the 'foreign' crate's source map information, using the\n-                // deserialized 'lo' and 'hi' values directly.\n-                //\n-                // All of this logic ensures that the final result of deserialization is a 'normal'\n-                // Span that can be used without any additional trouble.\n-                let (external_start_pos, metadata_index) = {\n-                    // Introduce a new scope so that we drop the 'lock()' temporary\n-                    match &*s.source_file_cache.0.external_src.lock() {\n-                        ExternalSource::Foreign { original_start_pos, metadata_index, .. } => {\n-                            (*original_start_pos, *metadata_index)\n-                        }\n-                        src => panic!(\"Unexpected external source {:?}\", src),\n+        let (tag, lo, metadata_index) = if source_file.is_imported() && !s.is_proc_macro {\n+            // To simplify deserialization, we 'rebase' this span onto the crate it originally came from\n+            // (the crate that 'owns' the file it references. These rebased 'lo' and 'hi' values\n+            // are relative to the source map information for the 'foreign' crate whose CrateNum\n+            // we write into the metadata. This allows `imported_source_files` to binary\n+            // search through the 'foreign' crate's source map information, using the\n+            // deserialized 'lo' and 'hi' values directly.\n+            //\n+            // All of this logic ensures that the final result of deserialization is a 'normal'\n+            // Span that can be used without any additional trouble.\n+            let (external_start_pos, metadata_index) = {\n+                // Introduce a new scope so that we drop the 'lock()' temporary\n+                match &*source_file.external_src.lock() {\n+                    ExternalSource::Foreign { original_start_pos, metadata_index, .. } => {\n+                        (*original_start_pos, *metadata_index)\n                     }\n-                };\n-                let lo = (span.lo - s.source_file_cache.0.start_pos) + external_start_pos;\n-                let hi = (span.hi - s.source_file_cache.0.start_pos) + external_start_pos;\n-\n-                (TAG_VALID_SPAN_FOREIGN, lo, hi, metadata_index)\n-            } else {\n-                // Record the fact that we need to encode the data for this `SourceFile`\n-                let source_files =\n-                    s.required_source_files.as_mut().expect(\"Already encoded SourceMap!\");\n-                let (source_file_index, _) = source_files.insert_full(s.source_file_cache.1);\n-                let source_file_index: u32 =\n-                    source_file_index.try_into().expect(\"cannot export more than U32_MAX files\");\n-\n-                (TAG_VALID_SPAN_LOCAL, span.lo, span.hi, source_file_index)\n+                    src => panic!(\"Unexpected external source {:?}\", src),\n+                }\n             };\n+            let lo = (span.lo - source_file.start_pos) + external_start_pos;\n+\n+            (TAG_VALID_SPAN_FOREIGN, lo, metadata_index)\n+        } else {\n+            // Record the fact that we need to encode the data for this `SourceFile`\n+            let source_files =\n+                s.required_source_files.as_mut().expect(\"Already encoded SourceMap!\");\n+            let (metadata_index, _) = source_files.insert_full(source_file_index);\n+            let metadata_index: u32 =\n+                metadata_index.try_into().expect(\"cannot export more than U32_MAX files\");\n+\n+            (TAG_VALID_SPAN_LOCAL, span.lo, metadata_index)\n+        };\n \n         tag.encode(s);\n         lo.encode(s);\n \n         // Encode length which is usually less than span.hi and profits more\n         // from the variable-length integer encoding that we use.\n-        let len = hi - lo;\n         len.encode(s);\n \n         // Encode the index of the `SourceFile` for the span, in order to make decoding faster."}]}