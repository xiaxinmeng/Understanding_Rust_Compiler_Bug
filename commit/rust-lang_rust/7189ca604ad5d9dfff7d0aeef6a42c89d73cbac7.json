{"sha": "7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxODljYTYwNGFkNWQ5ZGZmZjdkMGFlZWY2YTQyYzg5ZDczY2JhYzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-11T01:38:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-11T01:38:31Z"}, "message": "Auto merge of #75383 - Dylan-DPC:rollup-6hi36zn, r=Dylan-DPC\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #75098 (Clippy pointer cast lint experiment)\n - #75249 (Only add a border for the rust logo)\n - #75315 (Avoid deleting temporary files on error)\n - #75316 (Don't try to use wasm intrinsics on vectors)\n - #75337 (instance: only polymorphize upvar substs)\n - #75339 (evaluate required_consts when pushing stack frame in Miri engine)\n - #75363 (Use existing `infcx` when emitting trait impl diagnostic)\n - #75366 (Add help button)\n - #75369 (Move to intra-doc links in /library/core/src/borrow.rs)\n - #75379 (Use intra-doc links in /library/core/src/cmp.rs)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "5a938c9c4a0f61ea14fe485a17b04cdfe5a2c386", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a938c9c4a0f61ea14fe485a17b04cdfe5a2c386"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "html_url": "https://github.com/rust-lang/rust/commit/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bb5a863c8d60029abce0d56c5c303b5097b6070", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bb5a863c8d60029abce0d56c5c303b5097b6070", "html_url": "https://github.com/rust-lang/rust/commit/3bb5a863c8d60029abce0d56c5c303b5097b6070"}, {"sha": "0a738d41b11fb53c699b5c061372474a67a2b307", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a738d41b11fb53c699b5c061372474a67a2b307", "html_url": "https://github.com/rust-lang/rust/commit/0a738d41b11fb53c699b5c061372474a67a2b307"}], "stats": {"total": 1333, "additions": 926, "deletions": 407}, "files": [{"sha": "3f8bf0ac8e890bbccaecd67e6ef3ebda04a2757e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -3367,6 +3367,7 @@ dependencies = [\n  \"smallvec 1.4.0\",\n  \"stable_deref_trait\",\n  \"stacker\",\n+ \"tempfile\",\n  \"tracing\",\n  \"winapi 0.3.8\",\n ]"}, {"sha": "6f5a6aa7c79cabf9ab3cf72a8d39b6f6bd544936", "filename": "library/core/src/borrow.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/library%2Fcore%2Fsrc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/library%2Fcore%2Fsrc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fborrow.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -40,14 +40,12 @@\n /// provide a reference to related type `T`, it is often better to use\n /// [`AsRef<T>`] as more types can safely implement it.\n ///\n-/// [`AsRef<T>`]: ../../std/convert/trait.AsRef.html\n-/// [`BorrowMut<T>`]: trait.BorrowMut.html\n+/// [`BorrowMut<T>`]: BorrowMut\n /// [`Box<T>`]: ../../std/boxed/struct.Box.html\n /// [`Mutex<T>`]: ../../std/sync/struct.Mutex.html\n /// [`Rc<T>`]: ../../std/rc/struct.Rc.html\n-/// [`str`]: ../../std/primitive.str.html\n /// [`String`]: ../../std/string/struct.String.html\n-/// [`borrow`]: #tymethod.borrow\n+/// [`borrow`]: Borrow::borrow\n ///\n /// # Examples\n ///\n@@ -152,10 +150,9 @@\n /// If it wants to allow others access to the underlying `str`, it can do\n /// that via `AsRef<str>` which doesn\u2019t carry any extra requirements.\n ///\n-/// [`Hash`]: ../../std/hash/trait.Hash.html\n+/// [`Hash`]: crate::hash::Hash\n /// [`HashMap<K, V>`]: ../../std/collections/struct.HashMap.html\n /// [`String`]: ../../std/string/struct.String.html\n-/// [`str`]: ../../std/primitive.str.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Borrow<Borrowed: ?Sized> {\n     /// Immutably borrows from an owned value.\n@@ -187,7 +184,7 @@ pub trait Borrow<Borrowed: ?Sized> {\n /// an underlying type by providing a mutable reference. See [`Borrow<T>`]\n /// for more information on borrowing as another type.\n ///\n-/// [`Borrow<T>`]: trait.Borrow.html\n+/// [`Borrow<T>`]: Borrow\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BorrowMut<Borrowed: ?Sized>: Borrow<Borrowed> {\n     /// Mutably borrows from an owned value."}, {"sha": "e775ded60f593e4aaf131e68508eeffa81e26344", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -17,14 +17,8 @@\n //!\n //! For more details, see the respective documentation of each item in the list.\n //!\n-//! [`Eq`]: trait.Eq.html\n-//! [`PartialEq`]: trait.PartialEq.html\n-//! [`Ord`]: trait.Ord.html\n-//! [`PartialOrd`]: trait.PartialOrd.html\n-//! [`Ordering`]: enum.Ordering.html\n-//! [`Reverse`]: struct.Reverse.html\n-//! [`max`]: fn.max.html\n-//! [`min`]: fn.min.html\n+//! [`max`]: Ord::max\n+//! [`min`]: Ord::min\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "a0f4311b33a26c410289e08f32ec1e1cb63f230b", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -728,20 +728,25 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         // codegen. Note that this has a semantic difference in that the\n         // intrinsic can trap whereas `fptoui` never traps. That difference,\n         // however, is handled by `fptosui_may_trap` above.\n+        //\n+        // Note that we skip the wasm intrinsics for vector types where `fptoui`\n+        // must be used instead.\n         if self.wasm_and_missing_nontrapping_fptoint() {\n             let src_ty = self.cx.val_ty(val);\n-            let float_width = self.cx.float_width(src_ty);\n-            let int_width = self.cx.int_width(dest_ty);\n-            let name = match (int_width, float_width) {\n-                (32, 32) => Some(\"llvm.wasm.trunc.unsigned.i32.f32\"),\n-                (32, 64) => Some(\"llvm.wasm.trunc.unsigned.i32.f64\"),\n-                (64, 32) => Some(\"llvm.wasm.trunc.unsigned.i64.f32\"),\n-                (64, 64) => Some(\"llvm.wasm.trunc.unsigned.i64.f64\"),\n-                _ => None,\n-            };\n-            if let Some(name) = name {\n-                let intrinsic = self.get_intrinsic(name);\n-                return self.call(intrinsic, &[val], None);\n+            if self.cx.type_kind(src_ty) != TypeKind::Vector {\n+                let float_width = self.cx.float_width(src_ty);\n+                let int_width = self.cx.int_width(dest_ty);\n+                let name = match (int_width, float_width) {\n+                    (32, 32) => Some(\"llvm.wasm.trunc.unsigned.i32.f32\"),\n+                    (32, 64) => Some(\"llvm.wasm.trunc.unsigned.i32.f64\"),\n+                    (64, 32) => Some(\"llvm.wasm.trunc.unsigned.i64.f32\"),\n+                    (64, 64) => Some(\"llvm.wasm.trunc.unsigned.i64.f64\"),\n+                    _ => None,\n+                };\n+                if let Some(name) = name {\n+                    let intrinsic = self.get_intrinsic(name);\n+                    return self.call(intrinsic, &[val], None);\n+                }\n             }\n         }\n         unsafe { llvm::LLVMBuildFPToUI(self.llbuilder, val, dest_ty, UNNAMED) }\n@@ -750,18 +755,20 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn fptosi(&mut self, val: &'ll Value, dest_ty: &'ll Type) -> &'ll Value {\n         if self.wasm_and_missing_nontrapping_fptoint() {\n             let src_ty = self.cx.val_ty(val);\n-            let float_width = self.cx.float_width(src_ty);\n-            let int_width = self.cx.int_width(dest_ty);\n-            let name = match (int_width, float_width) {\n-                (32, 32) => Some(\"llvm.wasm.trunc.signed.i32.f32\"),\n-                (32, 64) => Some(\"llvm.wasm.trunc.signed.i32.f64\"),\n-                (64, 32) => Some(\"llvm.wasm.trunc.signed.i64.f32\"),\n-                (64, 64) => Some(\"llvm.wasm.trunc.signed.i64.f64\"),\n-                _ => None,\n-            };\n-            if let Some(name) = name {\n-                let intrinsic = self.get_intrinsic(name);\n-                return self.call(intrinsic, &[val], None);\n+            if self.cx.type_kind(src_ty) != TypeKind::Vector {\n+                let float_width = self.cx.float_width(src_ty);\n+                let int_width = self.cx.int_width(dest_ty);\n+                let name = match (int_width, float_width) {\n+                    (32, 32) => Some(\"llvm.wasm.trunc.signed.i32.f32\"),\n+                    (32, 64) => Some(\"llvm.wasm.trunc.signed.i32.f64\"),\n+                    (64, 32) => Some(\"llvm.wasm.trunc.signed.i64.f32\"),\n+                    (64, 64) => Some(\"llvm.wasm.trunc.signed.i64.f64\"),\n+                    _ => None,\n+                };\n+                if let Some(name) = name {\n+                    let intrinsic = self.get_intrinsic(name);\n+                    return self.call(intrinsic, &[val], None);\n+                }\n             }\n         }\n         unsafe { llvm::LLVMBuildFPToSI(self.llbuilder, val, dest_ty, UNNAMED) }"}, {"sha": "d725a60118e3c794e5324262c9cea920aa052431", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -1,4 +1,5 @@\n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_fs_util::fix_windows_verbatim_for_gcc;\n use rustc_hir::def_id::CrateNum;\n use rustc_middle::middle::cstore::{EncodedMetadata, LibSource, NativeLib};\n@@ -23,7 +24,7 @@ use super::rpath::{self, RPathConfig};\n use crate::{looks_like_rust_object_file, CodegenResults, CrateInfo, METADATA_FILENAME};\n \n use cc::windows_registry;\n-use tempfile::{Builder as TempFileBuilder, TempDir};\n+use tempfile::Builder as TempFileBuilder;\n \n use std::ffi::OsString;\n use std::path::{Path, PathBuf};\n@@ -70,35 +71,29 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n             }\n         });\n \n-        let tmpdir = TempFileBuilder::new()\n-            .prefix(\"rustc\")\n-            .tempdir()\n-            .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n-\n         if outputs.outputs.should_codegen() {\n+            let tmpdir = TempFileBuilder::new()\n+                .prefix(\"rustc\")\n+                .tempdir()\n+                .unwrap_or_else(|err| sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+            let path = MaybeTempDir::new(tmpdir, sess.opts.cg.save_temps);\n             let out_filename = out_filename(sess, crate_type, outputs, crate_name);\n             match crate_type {\n                 CrateType::Rlib => {\n                     let _timer = sess.timer(\"link_rlib\");\n-                    link_rlib::<B>(\n-                        sess,\n-                        codegen_results,\n-                        RlibFlavor::Normal,\n-                        &out_filename,\n-                        &tmpdir,\n-                    )\n-                    .build();\n+                    link_rlib::<B>(sess, codegen_results, RlibFlavor::Normal, &out_filename, &path)\n+                        .build();\n                 }\n                 CrateType::Staticlib => {\n-                    link_staticlib::<B>(sess, codegen_results, &out_filename, &tmpdir);\n+                    link_staticlib::<B>(sess, codegen_results, &out_filename, &path);\n                 }\n                 _ => {\n                     link_natively::<B>(\n                         sess,\n                         crate_type,\n                         &out_filename,\n                         codegen_results,\n-                        tmpdir.path(),\n+                        path.as_ref(),\n                         target_cpu,\n                     );\n                 }\n@@ -107,10 +102,6 @@ pub fn link_binary<'a, B: ArchiveBuilder<'a>>(\n                 sess.parse_sess.span_diagnostic.emit_artifact_notification(&out_filename, \"link\");\n             }\n         }\n-\n-        if sess.opts.cg.save_temps {\n-            let _ = tmpdir.into_path();\n-        }\n     }\n \n     // Remove the temporary object file and metadata if we aren't saving temps\n@@ -279,8 +270,8 @@ pub fn each_linked_rlib(\n /// building an `.rlib` (stomping over one another), or writing an `.rmeta` into a\n /// directory being searched for `extern crate` (observing an incomplete file).\n /// The returned path is the temporary file containing the complete metadata.\n-pub fn emit_metadata(sess: &Session, metadata: &EncodedMetadata, tmpdir: &TempDir) -> PathBuf {\n-    let out_filename = tmpdir.path().join(METADATA_FILENAME);\n+pub fn emit_metadata(sess: &Session, metadata: &EncodedMetadata, tmpdir: &MaybeTempDir) -> PathBuf {\n+    let out_filename = tmpdir.as_ref().join(METADATA_FILENAME);\n     let result = fs::write(&out_filename, &metadata.raw_data);\n \n     if let Err(e) = result {\n@@ -301,7 +292,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n     codegen_results: &CodegenResults,\n     flavor: RlibFlavor,\n     out_filename: &Path,\n-    tmpdir: &TempDir,\n+    tmpdir: &MaybeTempDir,\n ) -> B {\n     info!(\"preparing rlib to {:?}\", out_filename);\n     let mut ab = <B as ArchiveBuilder>::new(sess, out_filename, None);\n@@ -406,7 +397,7 @@ fn link_staticlib<'a, B: ArchiveBuilder<'a>>(\n     sess: &'a Session,\n     codegen_results: &CodegenResults,\n     out_filename: &Path,\n-    tempdir: &TempDir,\n+    tempdir: &MaybeTempDir,\n ) {\n     let mut ab =\n         link_rlib::<B>(sess, codegen_results, RlibFlavor::StaticlibBase, out_filename, tempdir);"}, {"sha": "36c32e600311252bfe5e4629951f747f824568c2", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -30,6 +30,7 @@ bitflags = \"1.2.1\"\n measureme = \"0.7.1\"\n libc = \"0.2\"\n stacker = \"0.1.9\"\n+tempfile = \"3.0.5\"\n \n [dependencies.parking_lot]\n version = \"0.10\""}, {"sha": "3884fc051056edff3bbbee3da634077916797320", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -95,6 +95,7 @@ pub mod vec_linked_list;\n pub mod work_queue;\n pub use atomic_ref::AtomicRef;\n pub mod frozen;\n+pub mod temp_dir;\n \n pub struct OnDrop<F: Fn()>(pub F);\n "}, {"sha": "0d9b3e3ca25c0a744e131615d47b60d6b76f4174", "filename": "src/librustc_data_structures/temp_dir.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_data_structures%2Ftemp_dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_data_structures%2Ftemp_dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftemp_dir.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -0,0 +1,34 @@\n+use std::mem::ManuallyDrop;\n+use std::path::Path;\n+use tempfile::TempDir;\n+\n+/// This is used to avoid TempDir being dropped on error paths unintentionally.\n+#[derive(Debug)]\n+pub struct MaybeTempDir {\n+    dir: ManuallyDrop<TempDir>,\n+    // Whether the TempDir should be deleted on drop.\n+    keep: bool,\n+}\n+\n+impl Drop for MaybeTempDir {\n+    fn drop(&mut self) {\n+        // Safety: We are in the destructor, and no further access will\n+        // occur.\n+        let dir = unsafe { ManuallyDrop::take(&mut self.dir) };\n+        if self.keep {\n+            dir.into_path();\n+        }\n+    }\n+}\n+\n+impl AsRef<Path> for MaybeTempDir {\n+    fn as_ref(&self) -> &Path {\n+        self.dir.path()\n+    }\n+}\n+\n+impl MaybeTempDir {\n+    pub fn new(dir: TempDir, keep_on_drop: bool) -> MaybeTempDir {\n+        MaybeTempDir { dir: ManuallyDrop::new(dir), keep: keep_on_drop }\n+    }\n+}"}, {"sha": "1ddf88c030660e318958322fbc9cb9bac06d93e3", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -2,7 +2,7 @@\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n-use crate::infer::{Subtype, TyCtxtInferExt, ValuePairs};\n+use crate::infer::{Subtype, ValuePairs};\n use crate::traits::ObligationCauseCode::CompareImplMethodObligation;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n@@ -53,7 +53,6 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     }\n \n     fn emit_err(&self, sp: Span, expected: Ty<'tcx>, found: Ty<'tcx>, trait_def_id: DefId) {\n-        let tcx = self.tcx();\n         let trait_sp = self.tcx().def_span(trait_def_id);\n         let mut err = self\n             .tcx()\n@@ -85,9 +84,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             );\n         }\n \n-        if let Some((expected, found)) = tcx\n-            .infer_ctxt()\n-            .enter(|infcx| infcx.expected_found_str_ty(&ExpectedFound { expected, found }))\n+        if let Some((expected, found)) =\n+            self.infcx.expected_found_str_ty(&ExpectedFound { expected, found })\n         {\n             // Highlighted the differences when showing the \"expected/found\" note.\n             err.note_expected_found(&\"\", expected, &\"\", found);"}, {"sha": "701fca8e4b53488f80fcbc1184c1acaa8caa5201", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -9,6 +9,7 @@ use rustc_ast::{self, ast, visit};\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::sync::{par_iter, Lrc, OnceCell, ParallelIterator, WorkerLocal};\n+use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_data_structures::{box_region_allow_access, declare_box_region_type, parallel};\n use rustc_errors::{ErrorReported, PResult};\n use rustc_expand::base::ExtCtxt;\n@@ -974,6 +975,7 @@ fn encode_and_write_metadata(\n             .prefix(\"rmeta\")\n             .tempdir_in(out_filename.parent().unwrap())\n             .unwrap_or_else(|err| tcx.sess.fatal(&format!(\"couldn't create a temp dir: {}\", err)));\n+        let metadata_tmpdir = MaybeTempDir::new(metadata_tmpdir, tcx.sess.opts.cg.save_temps);\n         let metadata_filename = emit_metadata(tcx.sess, &metadata, &metadata_tmpdir);\n         if let Err(e) = fs::rename(&metadata_filename, &out_filename) {\n             tcx.sess.fatal(&format!(\"failed to write {}: {}\", out_filename.display(), e));"}, {"sha": "5be09c0e9bc2bcaef3eda598d7438b76ee119b5e", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 167, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -1,17 +1,13 @@\n use super::{AllocId, Pointer, RawConst, Scalar};\n \n use crate::mir::interpret::ConstValue;\n-use crate::ty::layout::LayoutError;\n-use crate::ty::query::TyCtxtAt;\n-use crate::ty::{self, layout, tls, FnSig, Ty};\n+use crate::ty::{layout, query::TyCtxtAt, tls, FnSig, Ty};\n \n use rustc_data_structures::sync::Lock;\n use rustc_errors::{pluralize, struct_span_err, DiagnosticBuilder, ErrorReported};\n-use rustc_hir as hir;\n-use rustc_hir::definitions::DefPathData;\n use rustc_macros::HashStable;\n use rustc_session::CtfeBacktrace;\n-use rustc_span::{def_id::DefId, Pos, Span};\n+use rustc_span::def_id::DefId;\n use rustc_target::abi::{Align, Size};\n use std::{any::Any, backtrace::Backtrace, fmt, mem};\n \n@@ -34,167 +30,6 @@ CloneTypeFoldableAndLiftImpls! {\n pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n pub type ConstEvalResult<'tcx> = Result<ConstValue<'tcx>, ErrorHandled>;\n \n-#[derive(Debug)]\n-pub struct ConstEvalErr<'tcx> {\n-    pub span: Span,\n-    pub error: crate::mir::interpret::InterpError<'tcx>,\n-    pub stacktrace: Vec<FrameInfo<'tcx>>,\n-}\n-\n-#[derive(Debug)]\n-pub struct FrameInfo<'tcx> {\n-    pub instance: ty::Instance<'tcx>,\n-    pub span: Span,\n-    pub lint_root: Option<hir::HirId>,\n-}\n-\n-impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ty::tls::with(|tcx| {\n-            if tcx.def_key(self.instance.def_id()).disambiguated_data.data\n-                == DefPathData::ClosureExpr\n-            {\n-                write!(f, \"inside closure\")?;\n-            } else {\n-                write!(f, \"inside `{}`\", self.instance)?;\n-            }\n-            if !self.span.is_dummy() {\n-                let lo = tcx.sess.source_map().lookup_char_pos(self.span.lo());\n-                write!(f, \" at {}:{}:{}\", lo.file.name, lo.line, lo.col.to_usize() + 1)?;\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<'tcx> ConstEvalErr<'tcx> {\n-    pub fn struct_error(\n-        &self,\n-        tcx: TyCtxtAt<'tcx>,\n-        message: &str,\n-        emit: impl FnOnce(DiagnosticBuilder<'_>),\n-    ) -> ErrorHandled {\n-        self.struct_generic(tcx, message, emit, None)\n-    }\n-\n-    pub fn report_as_error(&self, tcx: TyCtxtAt<'tcx>, message: &str) -> ErrorHandled {\n-        self.struct_error(tcx, message, |mut e| e.emit())\n-    }\n-\n-    pub fn report_as_lint(\n-        &self,\n-        tcx: TyCtxtAt<'tcx>,\n-        message: &str,\n-        lint_root: hir::HirId,\n-        span: Option<Span>,\n-    ) -> ErrorHandled {\n-        self.struct_generic(\n-            tcx,\n-            message,\n-            |mut lint: DiagnosticBuilder<'_>| {\n-                // Apply the span.\n-                if let Some(span) = span {\n-                    let primary_spans = lint.span.primary_spans().to_vec();\n-                    // point at the actual error as the primary span\n-                    lint.replace_span_with(span);\n-                    // point to the `const` statement as a secondary span\n-                    // they don't have any label\n-                    for sp in primary_spans {\n-                        if sp != span {\n-                            lint.span_label(sp, \"\");\n-                        }\n-                    }\n-                }\n-                lint.emit();\n-            },\n-            Some(lint_root),\n-        )\n-    }\n-\n-    /// Create a diagnostic for this const eval error.\n-    ///\n-    /// Sets the message passed in via `message` and adds span labels with detailed error\n-    /// information before handing control back to `emit` to do any final processing.\n-    /// It's the caller's responsibility to call emit(), stash(), etc. within the `emit`\n-    /// function to dispose of the diagnostic properly.\n-    ///\n-    /// If `lint_root.is_some()` report it as a lint, else report it as a hard error.\n-    /// (Except that for some errors, we ignore all that -- see `must_error` below.)\n-    fn struct_generic(\n-        &self,\n-        tcx: TyCtxtAt<'tcx>,\n-        message: &str,\n-        emit: impl FnOnce(DiagnosticBuilder<'_>),\n-        lint_root: Option<hir::HirId>,\n-    ) -> ErrorHandled {\n-        let must_error = match self.error {\n-            err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n-                return ErrorHandled::TooGeneric;\n-            }\n-            err_inval!(TypeckError(error_reported)) => {\n-                return ErrorHandled::Reported(error_reported);\n-            }\n-            // We must *always* hard error on these, even if the caller wants just a lint.\n-            err_inval!(Layout(LayoutError::SizeOverflow(_))) => true,\n-            _ => false,\n-        };\n-        trace!(\"reporting const eval failure at {:?}\", self.span);\n-\n-        let err_msg = match &self.error {\n-            InterpError::MachineStop(msg) => {\n-                // A custom error (`ConstEvalErrKind` in `librustc_mir/interp/const_eval/error.rs`).\n-                // Should be turned into a string by now.\n-                msg.downcast_ref::<String>().expect(\"invalid MachineStop payload\").clone()\n-            }\n-            err => err.to_string(),\n-        };\n-\n-        let finish = |mut err: DiagnosticBuilder<'_>, span_msg: Option<String>| {\n-            if let Some(span_msg) = span_msg {\n-                err.span_label(self.span, span_msg);\n-            }\n-            // Add spans for the stacktrace. Don't print a single-line backtrace though.\n-            if self.stacktrace.len() > 1 {\n-                for frame_info in &self.stacktrace {\n-                    err.span_label(frame_info.span, frame_info.to_string());\n-                }\n-            }\n-            // Let the caller finish the job.\n-            emit(err)\n-        };\n-\n-        if must_error {\n-            // The `message` makes little sense here, this is a more serious error than the\n-            // caller thinks anyway.\n-            // See <https://github.com/rust-lang/rust/pull/63152>.\n-            finish(struct_error(tcx, &err_msg), None);\n-            ErrorHandled::Reported(ErrorReported)\n-        } else {\n-            // Regular case.\n-            if let Some(lint_root) = lint_root {\n-                // Report as lint.\n-                let hir_id = self\n-                    .stacktrace\n-                    .iter()\n-                    .rev()\n-                    .find_map(|frame| frame.lint_root)\n-                    .unwrap_or(lint_root);\n-                tcx.struct_span_lint_hir(\n-                    rustc_session::lint::builtin::CONST_ERR,\n-                    hir_id,\n-                    tcx.span,\n-                    |lint| finish(lint.build(message), Some(err_msg)),\n-                );\n-                ErrorHandled::Linted\n-            } else {\n-                // Report as hard error.\n-                finish(struct_error(tcx, message), Some(err_msg));\n-                ErrorHandled::Reported(ErrorReported)\n-            }\n-        }\n-    }\n-}\n-\n pub fn struct_error<'tcx>(tcx: TyCtxtAt<'tcx>, msg: &str) -> DiagnosticBuilder<'tcx> {\n     struct_span_err!(tcx.sess, tcx.span, E0080, \"{}\", msg)\n }"}, {"sha": "2507f2184fff1026c54437d9e9a6d5dce1cf31b9", "filename": "src/librustc_middle/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -117,9 +117,9 @@ use crate::ty::subst::GenericArgKind;\n use crate::ty::{self, Instance, Ty, TyCtxt};\n \n pub use self::error::{\n-    struct_error, CheckInAllocMsg, ConstEvalErr, ConstEvalRawResult, ConstEvalResult, ErrorHandled,\n-    FrameInfo, InterpError, InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType,\n-    ResourceExhaustionInfo, UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n+    struct_error, CheckInAllocMsg, ConstEvalRawResult, ConstEvalResult, ErrorHandled, InterpError,\n+    InterpErrorInfo, InterpResult, InvalidProgramInfo, MachineStopType, ResourceExhaustionInfo,\n+    UndefinedBehaviorInfo, UninitBytesAccess, UnsupportedOpInfo,\n };\n \n pub use self::value::{get_slice_bytes, ConstValue, RawConst, Scalar, ScalarMaybeUninit};"}, {"sha": "27f50c240db67e61233673ff82d45584b0cbe9e3", "filename": "src/librustc_middle/ty/flags.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_middle%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_middle%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fflags.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -85,8 +85,6 @@ impl FlagComputation {\n             }\n \n             &ty::Generator(_, ref substs, _) => {\n-                self.add_flags(TypeFlags::MAY_POLYMORPHIZE);\n-\n                 let substs = substs.as_generator();\n                 let should_remove_further_specializable =\n                     !self.flags.contains(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n@@ -109,8 +107,6 @@ impl FlagComputation {\n             }\n \n             &ty::Closure(_, substs) => {\n-                self.add_flags(TypeFlags::MAY_POLYMORPHIZE);\n-\n                 let substs = substs.as_closure();\n                 let should_remove_further_specializable =\n                     !self.flags.contains(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n@@ -196,8 +192,6 @@ impl FlagComputation {\n             }\n \n             &ty::FnDef(_, substs) => {\n-                self.add_flags(TypeFlags::MAY_POLYMORPHIZE);\n-\n                 self.add_substs(substs);\n             }\n "}, {"sha": "492f8ce9ef1a9d1afd832535d5a91b7a7edf1b35", "filename": "src/librustc_middle/ty/fold.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_middle%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_middle%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ffold.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -150,12 +150,6 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.has_type_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE)\n     }\n \n-    /// Does this value contain closures, generators or functions such that it may require\n-    /// polymorphization?\n-    fn may_polymorphize(&self) -> bool {\n-        self.has_type_flags(TypeFlags::MAY_POLYMORPHIZE)\n-    }\n-\n     /// A visitor that does not recurse into types, works like `fn walk_shallow` in `Ty`.\n     fn visit_tys_shallow(&self, visit: impl FnMut(Ty<'tcx>) -> bool) -> bool {\n         pub struct Visitor<F>(F);"}, {"sha": "2def000da648086d7acdaf216c7d9fcffd050c00", "filename": "src/librustc_middle/ty/instance.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_middle%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_middle%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Finstance.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -492,6 +492,20 @@ fn polymorphize<'tcx>(\n     let unused = tcx.unused_generic_params(def_id);\n     debug!(\"polymorphize: unused={:?}\", unused);\n \n+    // If this is a closure or generator then we need to handle the case where another closure\n+    // from the function is captured as an upvar and hasn't been polymorphized. In this case,\n+    // the unpolymorphized upvar closure would result in a polymorphized closure producing\n+    // multiple mono items (and eventually symbol clashes).\n+    let upvars_ty = if tcx.is_closure(def_id) {\n+        Some(substs.as_closure().tupled_upvars_ty())\n+    } else if tcx.type_of(def_id).is_generator() {\n+        Some(substs.as_generator().tupled_upvars_ty())\n+    } else {\n+        None\n+    };\n+    let has_upvars = upvars_ty.map(|ty| ty.tuple_fields().count() > 0).unwrap_or(false);\n+    debug!(\"polymorphize: upvars_ty={:?} has_upvars={:?}\", upvars_ty, has_upvars);\n+\n     struct PolymorphizationFolder<'tcx> {\n         tcx: TyCtxt<'tcx>,\n     };\n@@ -512,14 +526,6 @@ fn polymorphize<'tcx>(\n                         self.tcx.mk_closure(def_id, polymorphized_substs)\n                     }\n                 }\n-                ty::FnDef(def_id, substs) => {\n-                    let polymorphized_substs = polymorphize(self.tcx, def_id, substs);\n-                    if substs == polymorphized_substs {\n-                        ty\n-                    } else {\n-                        self.tcx.mk_fn_def(def_id, polymorphized_substs)\n-                    }\n-                }\n                 ty::Generator(def_id, substs, movability) => {\n                     let polymorphized_substs = polymorphize(self.tcx, def_id, substs);\n                     if substs == polymorphized_substs {\n@@ -537,24 +543,31 @@ fn polymorphize<'tcx>(\n         let is_unused = unused.contains(param.index).unwrap_or(false);\n         debug!(\"polymorphize: param={:?} is_unused={:?}\", param, is_unused);\n         match param.kind {\n-            // If parameter is a const or type parameter..\n+            // Upvar case: If parameter is a type parameter..\n+            ty::GenericParamDefKind::Type { .. } if\n+                // ..and has upvars..\n+                has_upvars &&\n+                // ..and this param has the same type as the tupled upvars..\n+                upvars_ty == Some(substs[param.index as usize].expect_ty()) => {\n+                    // ..then double-check that polymorphization marked it used..\n+                    debug_assert!(!is_unused);\n+                    // ..and polymorphize any closures/generators captured as upvars.\n+                    let upvars_ty = upvars_ty.unwrap();\n+                    let polymorphized_upvars_ty = upvars_ty.fold_with(\n+                        &mut PolymorphizationFolder { tcx });\n+                    debug!(\"polymorphize: polymorphized_upvars_ty={:?}\", polymorphized_upvars_ty);\n+                    ty::GenericArg::from(polymorphized_upvars_ty)\n+                },\n+\n+            // Simple case: If parameter is a const or type parameter..\n             ty::GenericParamDefKind::Const | ty::GenericParamDefKind::Type { .. } if\n                 // ..and is within range and unused..\n                 unused.contains(param.index).unwrap_or(false) =>\n                     // ..then use the identity for this parameter.\n                     tcx.mk_param_from_def(param),\n \n-            // If the parameter does not contain any closures or generators, then use the\n-            // substitution directly.\n-            _ if !substs.may_polymorphize() => substs[param.index as usize],\n-\n-            // Otherwise, use the substitution after polymorphizing.\n-            _ => {\n-                let arg = substs[param.index as usize];\n-                let polymorphized_arg = arg.fold_with(&mut PolymorphizationFolder { tcx });\n-                debug!(\"polymorphize: arg={:?} polymorphized_arg={:?}\", arg, polymorphized_arg);\n-                ty::GenericArg::from(polymorphized_arg)\n-            }\n+            // Otherwise, use the parameter as before.\n+            _ => substs[param.index as usize],\n         }\n     })\n }"}, {"sha": "6798addb8aaa3a0c35d653f9347356132be259b6", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -575,10 +575,6 @@ bitflags! {\n         /// Does this value have parameters/placeholders/inference variables which could be\n         /// replaced later, in a way that would change the results of `impl` specialization?\n         const STILL_FURTHER_SPECIALIZABLE = 1 << 17;\n-\n-        /// Does this value contain closures, generators or functions such that it may require\n-        /// polymorphization?\n-        const MAY_POLYMORPHIZE = 1 << 18;\n     }\n }\n "}, {"sha": "044d27a6a9dc3d0dd21aeb8bf708cc01e933cdcb", "filename": "src/librustc_mir/const_eval/error.rs", "status": "modified", "additions": 157, "deletions": 13, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ferror.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -1,12 +1,16 @@\n use std::error::Error;\n use std::fmt;\n \n+use rustc_errors::{DiagnosticBuilder, ErrorReported};\n+use rustc_hir as hir;\n use rustc_middle::mir::AssertKind;\n-use rustc_middle::ty::ConstInt;\n+use rustc_middle::ty::{layout::LayoutError, query::TyCtxtAt, ConstInt};\n use rustc_span::{Span, Symbol};\n \n use super::InterpCx;\n-use crate::interpret::{ConstEvalErr, InterpErrorInfo, Machine};\n+use crate::interpret::{\n+    struct_error, ErrorHandled, FrameInfo, InterpError, InterpErrorInfo, Machine,\n+};\n \n /// The CTFE machine has some custom error kinds.\n #[derive(Clone, Debug)]\n@@ -48,15 +52,155 @@ impl fmt::Display for ConstEvalErrKind {\n \n impl Error for ConstEvalErrKind {}\n \n-/// Turn an interpreter error into something to report to the user.\n-/// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n-/// Should be called only if the error is actually going to to be reported!\n-pub fn error_to_const_error<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>>(\n-    ecx: &InterpCx<'mir, 'tcx, M>,\n-    error: InterpErrorInfo<'tcx>,\n-    span: Option<Span>,\n-) -> ConstEvalErr<'tcx> {\n-    error.print_backtrace();\n-    let stacktrace = ecx.generate_stacktrace();\n-    ConstEvalErr { error: error.kind, stacktrace, span: span.unwrap_or_else(|| ecx.cur_span()) }\n+/// When const-evaluation errors, this type is constructed with the resulting information,\n+/// and then used to emit the error as a lint or hard error.\n+#[derive(Debug)]\n+pub struct ConstEvalErr<'tcx> {\n+    pub span: Span,\n+    pub error: InterpError<'tcx>,\n+    pub stacktrace: Vec<FrameInfo<'tcx>>,\n+}\n+\n+impl<'tcx> ConstEvalErr<'tcx> {\n+    /// Turn an interpreter error into something to report to the user.\n+    /// As a side-effect, if RUSTC_CTFE_BACKTRACE is set, this prints the backtrace.\n+    /// Should be called only if the error is actually going to to be reported!\n+    pub fn new<'mir, M: Machine<'mir, 'tcx>>(\n+        ecx: &InterpCx<'mir, 'tcx, M>,\n+        error: InterpErrorInfo<'tcx>,\n+        span: Option<Span>,\n+    ) -> ConstEvalErr<'tcx>\n+    where\n+        'tcx: 'mir,\n+    {\n+        error.print_backtrace();\n+        let stacktrace = ecx.generate_stacktrace();\n+        ConstEvalErr { error: error.kind, stacktrace, span: span.unwrap_or_else(|| ecx.cur_span()) }\n+    }\n+\n+    pub fn struct_error(\n+        &self,\n+        tcx: TyCtxtAt<'tcx>,\n+        message: &str,\n+        emit: impl FnOnce(DiagnosticBuilder<'_>),\n+    ) -> ErrorHandled {\n+        self.struct_generic(tcx, message, emit, None)\n+    }\n+\n+    pub fn report_as_error(&self, tcx: TyCtxtAt<'tcx>, message: &str) -> ErrorHandled {\n+        self.struct_error(tcx, message, |mut e| e.emit())\n+    }\n+\n+    pub fn report_as_lint(\n+        &self,\n+        tcx: TyCtxtAt<'tcx>,\n+        message: &str,\n+        lint_root: hir::HirId,\n+        span: Option<Span>,\n+    ) -> ErrorHandled {\n+        self.struct_generic(\n+            tcx,\n+            message,\n+            |mut lint: DiagnosticBuilder<'_>| {\n+                // Apply the span.\n+                if let Some(span) = span {\n+                    let primary_spans = lint.span.primary_spans().to_vec();\n+                    // point at the actual error as the primary span\n+                    lint.replace_span_with(span);\n+                    // point to the `const` statement as a secondary span\n+                    // they don't have any label\n+                    for sp in primary_spans {\n+                        if sp != span {\n+                            lint.span_label(sp, \"\");\n+                        }\n+                    }\n+                }\n+                lint.emit();\n+            },\n+            Some(lint_root),\n+        )\n+    }\n+\n+    /// Create a diagnostic for this const eval error.\n+    ///\n+    /// Sets the message passed in via `message` and adds span labels with detailed error\n+    /// information before handing control back to `emit` to do any final processing.\n+    /// It's the caller's responsibility to call emit(), stash(), etc. within the `emit`\n+    /// function to dispose of the diagnostic properly.\n+    ///\n+    /// If `lint_root.is_some()` report it as a lint, else report it as a hard error.\n+    /// (Except that for some errors, we ignore all that -- see `must_error` below.)\n+    fn struct_generic(\n+        &self,\n+        tcx: TyCtxtAt<'tcx>,\n+        message: &str,\n+        emit: impl FnOnce(DiagnosticBuilder<'_>),\n+        lint_root: Option<hir::HirId>,\n+    ) -> ErrorHandled {\n+        let must_error = match self.error {\n+            err_inval!(Layout(LayoutError::Unknown(_))) | err_inval!(TooGeneric) => {\n+                return ErrorHandled::TooGeneric;\n+            }\n+            err_inval!(TypeckError(error_reported)) => {\n+                return ErrorHandled::Reported(error_reported);\n+            }\n+            // We must *always* hard error on these, even if the caller wants just a lint.\n+            err_inval!(Layout(LayoutError::SizeOverflow(_))) => true,\n+            _ => false,\n+        };\n+        trace!(\"reporting const eval failure at {:?}\", self.span);\n+\n+        let err_msg = match &self.error {\n+            InterpError::MachineStop(msg) => {\n+                // A custom error (`ConstEvalErrKind` in `librustc_mir/interp/const_eval/error.rs`).\n+                // Should be turned into a string by now.\n+                msg.downcast_ref::<String>().expect(\"invalid MachineStop payload\").clone()\n+            }\n+            err => err.to_string(),\n+        };\n+\n+        let finish = |mut err: DiagnosticBuilder<'_>, span_msg: Option<String>| {\n+            if let Some(span_msg) = span_msg {\n+                err.span_label(self.span, span_msg);\n+            }\n+            // Add spans for the stacktrace. Don't print a single-line backtrace though.\n+            if self.stacktrace.len() > 1 {\n+                for frame_info in &self.stacktrace {\n+                    err.span_label(frame_info.span, frame_info.to_string());\n+                }\n+            }\n+            // Let the caller finish the job.\n+            emit(err)\n+        };\n+\n+        if must_error {\n+            // The `message` makes little sense here, this is a more serious error than the\n+            // caller thinks anyway.\n+            // See <https://github.com/rust-lang/rust/pull/63152>.\n+            finish(struct_error(tcx, &err_msg), None);\n+            ErrorHandled::Reported(ErrorReported)\n+        } else {\n+            // Regular case.\n+            if let Some(lint_root) = lint_root {\n+                // Report as lint.\n+                let hir_id = self\n+                    .stacktrace\n+                    .iter()\n+                    .rev()\n+                    .find_map(|frame| frame.lint_root)\n+                    .unwrap_or(lint_root);\n+                tcx.struct_span_lint_hir(\n+                    rustc_session::lint::builtin::CONST_ERR,\n+                    hir_id,\n+                    tcx.span,\n+                    |lint| finish(lint.build(message), Some(err_msg)),\n+                );\n+                ErrorHandled::Linted\n+            } else {\n+                // Report as hard error.\n+                finish(struct_error(tcx, message), Some(err_msg));\n+                ErrorHandled::Reported(ErrorReported)\n+            }\n+        }\n+    }\n }"}, {"sha": "7fbe5c409d3ce283f0a694a86a9f4d4551c21130", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -1,13 +1,14 @@\n-use super::{error_to_const_error, CompileTimeEvalContext, CompileTimeInterpreter, MemoryExtra};\n+use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr, MemoryExtra};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, Immediate, InternKind,\n     InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RawConst, RefTracking, Scalar,\n     ScalarMaybeUninit, StackPopCleanup,\n };\n+\n use rustc_hir::def::DefKind;\n use rustc_middle::mir;\n-use rustc_middle::mir::interpret::{ConstEvalErr, ErrorHandled};\n+use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::traits::Reveal;\n use rustc_middle::ty::{self, subst::Subst, TyCtxt};\n use rustc_span::source_map::Span;\n@@ -213,7 +214,7 @@ fn validate_and_turn_into_const<'tcx>(\n     })();\n \n     val.map_err(|error| {\n-        let err = error_to_const_error(&ecx, error, None);\n+        let err = ConstEvalErr::new(&ecx, error, None);\n         err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\", |mut diag| {\n             diag.note(note_on_undefined_behavior_error());\n             diag.emit();\n@@ -312,7 +313,7 @@ pub fn const_eval_raw_provider<'tcx>(\n     res.and_then(|body| eval_body_using_ecx(&mut ecx, cid, &body))\n         .map(|place| RawConst { alloc_id: place.ptr.assert_ptr().alloc_id, ty: place.layout.ty })\n         .map_err(|error| {\n-            let err = error_to_const_error(&ecx, error, None);\n+            let err = ConstEvalErr::new(&ecx, error, None);\n             // errors in statics are always emitted as fatal errors\n             if is_static {\n                 // Ensure that if the above error was either `TooGeneric` or `Reported`"}, {"sha": "7c2f749c1567cf3e376899a06afd2f4d4d9fbbf5", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -1,22 +1,22 @@\n use std::cell::Cell;\n+use std::fmt;\n use std::mem;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::{self as hir, def::DefKind, def_id::DefId, definitions::DefPathData};\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_middle::ich::StableHashingContext;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{\n-    sign_extend, truncate, FrameInfo, GlobalId, InterpResult, Pointer, Scalar,\n+    sign_extend, truncate, GlobalId, InterpResult, Pointer, Scalar,\n };\n use rustc_middle::ty::layout::{self, TyAndLayout};\n use rustc_middle::ty::{\n     self, query::TyCtxtAt, subst::SubstsRef, ParamEnv, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_span::{source_map::DUMMY_SP, Span};\n+use rustc_span::{source_map::DUMMY_SP, Pos, Span};\n use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n \n use super::{\n@@ -88,6 +88,14 @@ pub struct Frame<'mir, 'tcx, Tag = (), Extra = ()> {\n     pub loc: Option<mir::Location>,\n }\n \n+/// What we store about a frame in an interpreter backtrace.\n+#[derive(Debug)]\n+pub struct FrameInfo<'tcx> {\n+    pub instance: ty::Instance<'tcx>,\n+    pub span: Span,\n+    pub lint_root: Option<hir::HirId>,\n+}\n+\n #[derive(Clone, Eq, PartialEq, Debug, HashStable)] // Miri debug-prints these\n pub enum StackPopCleanup {\n     /// Jump to the next block in the caller, or cause UB if None (that's a function\n@@ -185,6 +193,25 @@ impl<'mir, 'tcx, Tag, Extra> Frame<'mir, 'tcx, Tag, Extra> {\n     }\n }\n \n+impl<'tcx> fmt::Display for FrameInfo<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        ty::tls::with(|tcx| {\n+            if tcx.def_key(self.instance.def_id()).disambiguated_data.data\n+                == DefPathData::ClosureExpr\n+            {\n+                write!(f, \"inside closure\")?;\n+            } else {\n+                write!(f, \"inside `{}`\", self.instance)?;\n+            }\n+            if !self.span.is_dummy() {\n+                let lo = tcx.sess.source_map().lookup_char_pos(self.span.lo());\n+                write!(f, \" at {}:{}:{}\", lo.file.name, lo.line, lo.col.to_usize() + 1)?;\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &TargetDataLayout {\n@@ -625,6 +652,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let frame = M::init_frame_extra(self, pre_frame)?;\n         self.stack_mut().push(frame);\n \n+        // Make sure all the constants required by this frame evaluate successfully (post-monomorphization check).\n+        for const_ in &body.required_consts {\n+            let const_ =\n+                self.subst_from_current_frame_and_normalize_erasing_regions(const_.literal);\n+            self.const_to_op(const_, None)?;\n+        }\n+\n         // Locals are initially uninitialized.\n         let dummy = LocalState { value: LocalValue::Uninitialized, layout: Cell::new(None) };\n         let mut locals = IndexVec::from_elem(dummy, &body.local_decls);"}, {"sha": "5218b03d65ecc995b859b53c89ae21583238c4c3", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -18,7 +18,7 @@ mod visitor;\n \n pub use rustc_middle::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n-pub use self::eval_context::{Frame, InterpCx, LocalState, LocalValue, StackPopCleanup};\n+pub use self::eval_context::{Frame, FrameInfo, InterpCx, LocalState, LocalValue, StackPopCleanup};\n pub use self::intern::{intern_const_alloc_recursive, InternKind};\n pub use self::machine::{compile_time_machine, AllocMap, Machine, MayLeak, StackPopJump};\n pub use self::memory::{get_static, AllocCheck, FnVal, Memory, MemoryKind};"}, {"sha": "bff83b3c6db745d9d6ae8624e52374c7e8cdf142", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -26,7 +26,7 @@ use rustc_span::{def_id::DefId, Span};\n use rustc_target::abi::{HasDataLayout, LayoutOf, Size, TargetDataLayout};\n use rustc_trait_selection::traits;\n \n-use crate::const_eval::error_to_const_error;\n+use crate::const_eval::ConstEvalErr;\n use crate::interpret::{\n     self, compile_time_machine, truncate, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx,\n     LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy,\n@@ -451,7 +451,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             Ok(op) => Some(op),\n             Err(error) => {\n                 let tcx = self.ecx.tcx.at(c.span);\n-                let err = error_to_const_error(&self.ecx, error, Some(c.span));\n+                let err = ConstEvalErr::new(&self.ecx, error, Some(c.span));\n                 if let Some(lint_root) = self.lint_root(source_info) {\n                     let lint_only = match c.literal.val {\n                         // Promoteds must lint and not error as the user didn't ask for them"}, {"sha": "418ea29b84f2f53a9862d3c67b364099178e283e", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n }\n \n #[derive(Copy, Clone)]\n-enum CastError {\n+pub enum CastError {\n     ErrorReported,\n \n     CastToBool,\n@@ -593,7 +593,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n     /// Checks a cast, and report an error if one exists. In some cases, this\n     /// can return Ok and create type errors in the fcx rather than returning\n     /// directly. coercion-cast is handled in check instead of here.\n-    fn do_check(&self, fcx: &FnCtxt<'a, 'tcx>) -> Result<CastKind, CastError> {\n+    pub fn do_check(&self, fcx: &FnCtxt<'a, 'tcx>) -> Result<CastKind, CastError> {\n         use rustc_middle::ty::cast::CastTy::*;\n         use rustc_middle::ty::cast::IntTy::*;\n "}, {"sha": "a40b6860f7765d7da49774f51ef87504cee3d9d2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -67,7 +67,7 @@ type parameter).\n pub mod _match;\n mod autoderef;\n mod callee;\n-mod cast;\n+pub mod cast;\n mod closure;\n pub mod coercion;\n mod compare_method;\n@@ -648,7 +648,7 @@ impl Inherited<'_, 'tcx> {\n }\n \n impl<'tcx> InheritedBuilder<'tcx> {\n-    fn enter<F, R>(&mut self, f: F) -> R\n+    pub fn enter<F, R>(&mut self, f: F) -> R\n     where\n         F: for<'a> FnOnce(Inherited<'a, 'tcx>) -> R,\n     {"}, {"sha": "49843fa43dd8c8e7fc4dd5f1008cc0dca37ce9f7", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -74,11 +74,11 @@ extern crate log;\n #[macro_use]\n extern crate rustc_middle;\n \n-// This is used by Clippy.\n+// These are used by Clippy.\n+pub mod check;\n pub mod expr_use_visitor;\n \n mod astconv;\n-mod check;\n mod check_unused;\n mod coherence;\n mod collect;"}, {"sha": "fd67a66395d7ca2753c81775e9ebb05838bc54b0", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -95,6 +95,7 @@ pub fn render<T: Print, S: Print>(\n                            placeholder=\\\"Click or press \u2018S\u2019 to search, \u2018?\u2019 for more options\u2026\\\" \\\n                            type=\\\"search\\\">\\\n                 </div>\\\n+                <span class=\\\"help-button\\\">?</span>\n                 <a id=\\\"settings-menu\\\" href=\\\"{root_path}settings.html\\\">\\\n                     <img src=\\\"{static_root_path}wheel{suffix}.svg\\\" \\\n                          width=\\\"18\\\" \\\n@@ -138,7 +139,7 @@ pub fn render<T: Print, S: Print>(\n             if layout.logo.is_empty() {\n                 format!(\n                     \"<a href='{path}index.html'>\\\n-                     <div class='logo-container'>\\\n+                     <div class='logo-container rust-logo'>\\\n                      <img src='{static_root_path}rust-logo{suffix}.png' alt='logo'></div></a>\",\n                     path = p,\n                     static_root_path = static_root_path,"}, {"sha": "63853e7394b4d505f4ed8758cdb5954aada27735", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -473,7 +473,9 @@ function defocusSearchBar() {\n     }());\n \n     document.addEventListener(\"click\", function(ev) {\n-        if (hasClass(ev.target, \"collapse-toggle\")) {\n+        if (hasClass(ev.target, \"help-button\")) {\n+            displayHelp(true, ev);\n+        } else if (hasClass(ev.target, \"collapse-toggle\")) {\n             collapseDocs(ev.target, \"toggle\");\n         } else if (hasClass(ev.target.parentNode, \"collapse-toggle\")) {\n             collapseDocs(ev.target.parentNode, \"toggle\");"}, {"sha": "346ceacc928c472b368ebbc401f564170eb7691a", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -674,7 +674,7 @@ a {\n }\n .search-container > div {\n \tdisplay: inline-flex;\n-\twidth: calc(100% - 34px);\n+\twidth: calc(100% - 63px);\n }\n #crate-search {\n \tmargin-top: 5px;\n@@ -1250,14 +1250,24 @@ h4 > .notable-traits {\n \toutline: none;\n }\n \n-#settings-menu {\n+#settings-menu, .help-button {\n \tposition: absolute;\n-\tright: 0;\n \ttop: 10px;\n+}\n+\n+#settings-menu {\n+\tright: 0;\n \toutline: none;\n }\n \n-#theme-picker, #settings-menu {\n+.help-button {\n+\tright: 30px;\n+\tfont-family: \"Fira Sans\",sans-serif;\n+\ttext-align: center;\n+\tfont-size: 17px;\n+}\n+\n+#theme-picker, #settings-menu, .help-button {\n \tpadding: 4px;\n \twidth: 27px;\n \theight: 29px;"}, {"sha": "6e8db1e9eb7926d079ee51cea67a6872cdc091f1", "filename": "src/librustdoc/html/static/themes/ayu.css", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -62,8 +62,11 @@ pre {\n \tbackground-color: #14191f;\n }\n \n-.logo-container > img {\n-\tfilter: drop-shadow(0 0 5px #fff);\n+.logo-container.rust-logo > img {\n+\tfilter: drop-shadow(1px 0 0px #fff)\n+\t\tdrop-shadow(0 1px 0 #fff)\n+\t\tdrop-shadow(-1px 0 0 #fff)\n+\t\tdrop-shadow(0 -1px 0 #fff);\n }\n \n /* Improve the scrollbar display on firefox */\n@@ -489,7 +492,7 @@ kbd {\n \tbox-shadow-color: #c6cbd1;\n }\n \n-#theme-picker, #settings-menu {\n+#theme-picker, #settings-menu, .help-button {\n \tborder-color: #5c6773;\n \tbackground-color: #0f1419;\n }\n@@ -499,7 +502,8 @@ kbd {\n }\n \n #theme-picker:hover, #theme-picker:focus,\n-#settings-menu:hover, #settings-menu:focus {\n+#settings-menu:hover, #settings-menu:focus,\n+.help-button:hover, .help-button:focus {\n \tborder-color: #e0e0e0;\n }\n "}, {"sha": "eeb1f0a3d4a0bfa7448dfc4575f7a23fb36dbd3a", "filename": "src/librustdoc/html/static/themes/dark.css", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fdark.css?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -34,8 +34,11 @@ pre {\n \tbackground-color: #505050;\n }\n \n-.logo-container > img {\n-\tfilter: drop-shadow(0 0 5px #fff);\n+.logo-container.rust-logo > img {\n+\tfilter: drop-shadow(1px 0 0px #fff)\n+\t\tdrop-shadow(0 1px 0 #fff)\n+\t\tdrop-shadow(-1px 0 0 #fff)\n+\t\tdrop-shadow(0 -1px 0 #fff)\n }\n \n /* Improve the scrollbar display on firefox */\n@@ -383,13 +386,14 @@ kbd {\n \tbox-shadow-color: #c6cbd1;\n }\n \n-#theme-picker, #settings-menu {\n+#theme-picker, #settings-menu, .help-button {\n \tborder-color: #e0e0e0;\n \tbackground: #f0f0f0;\n }\n \n #theme-picker:hover, #theme-picker:focus,\n-#settings-menu:hover, #settings-menu:focus {\n+#settings-menu:hover, #settings-menu:focus,\n+.help-button:hover, .help-button:focus {\n \tborder-color: #ffb900;\n }\n "}, {"sha": "9dea875b87747bd8c633478c41b2407927dd788b", "filename": "src/librustdoc/html/static/themes/light.css", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Flight.css?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -45,8 +45,8 @@ pre {\n \tscrollbar-color: rgba(36, 37, 39, 0.6) #d9d9d9;\n }\n \n-.logo-container > img {\n-\tfilter: drop-shadow(0 0 5px #aaa);\n+.logo-container.rust-logo > img {\n+\t/* No need for a border in here! */\n }\n \n /* Improve the scrollbar display on webkit-based browsers */\n@@ -377,13 +377,14 @@ kbd {\n \tbox-shadow-color: #c6cbd1;\n }\n \n-#theme-picker, #settings-menu {\n+#theme-picker, #settings-menu, .help-button {\n \tborder-color: #e0e0e0;\n \tbackground-color: #fff;\n }\n \n #theme-picker:hover, #theme-picker:focus,\n-#settings-menu:hover, #settings-menu:focus {\n+#settings-menu:hover, #settings-menu:focus,\n+.help-button:hover, .help-button:focus {\n \tborder-color: #717171;\n }\n "}, {"sha": "af47b440640afdf36530efd9d64c361cdb9c8088", "filename": "src/test/codegen-units/polymorphization/pr-75255.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3bb5a863c8d60029abce0d56c5c303b5097b6070/src%2Ftest%2Fcodegen-units%2Fpolymorphization%2Fpr-75255.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bb5a863c8d60029abce0d56c5c303b5097b6070/src%2Ftest%2Fcodegen-units%2Fpolymorphization%2Fpr-75255.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpolymorphization%2Fpr-75255.rs?ref=3bb5a863c8d60029abce0d56c5c303b5097b6070", "patch": "@@ -1,52 +0,0 @@\n-// compile-flags:-Zpolymorphize=on -Zprint-mono-items=lazy -Copt-level=1\n-// ignore-tidy-linelength\n-\n-#![crate_type = \"rlib\"]\n-\n-// Test that only one copy of `Iter::map` and `iter::repeat` are generated.\n-\n-fn unused<T>() -> u64 {\n-    42\n-}\n-\n-fn foo<T>() {\n-    let x = [1, 2, 3, std::mem::size_of::<T>()];\n-    x.iter().map(|_| ());\n-}\n-\n-//~ MONO_ITEM fn core::iter[0]::adapters[0]::{{impl}}[29]::new[0]<core::slice[0]::Iter[0]<usize>, pr_75255::foo[0]::{{closure}}[0]<T>> @@ pr_75255-cgu.0[External]\n-//~ MONO_ITEM fn core::iter[0]::traits[0]::iterator[0]::Iterator[0]::map[0]<core::slice[0]::Iter[0]<usize>, (), pr_75255::foo[0]::{{closure}}[0]<T>> @@ pr_75255-cgu.1[Internal]\n-\n-fn bar<T>() {\n-    std::iter::repeat(unused::<T>);\n-}\n-\n-//~ MONO_ITEM fn core::iter[0]::sources[0]::repeat[0]<fn() -> u64> @@ pr_75255-cgu.1[Internal]\n-\n-pub fn dispatch() {\n-    foo::<String>();\n-    foo::<Vec<String>>();\n-\n-    bar::<String>();\n-    bar::<Vec<String>>();\n-}\n-\n-// These are all the items that aren't relevant to the test.\n-//~ MONO_ITEM fn core::mem[0]::size_of[0]<alloc::string[0]::String[0]> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn core::mem[0]::size_of[0]<alloc::vec[0]::Vec[0]<alloc::string[0]::String[0]>> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn core::mem[0]::size_of[0]<usize> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::add[0]<usize> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::is_null[0]<usize> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::offset[0]<usize> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::wrapping_add[0]<u8> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn core::ptr[0]::const_ptr[0]::{{impl}}[0]::wrapping_offset[0]<u8> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn core::ptr[0]::non_null[0]::{{impl}}[3]::new_unchecked[0]<usize> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn core::ptr[0]::null[0]<u8> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn core::slice[0]::{{impl}}[0]::as_ptr[0]<usize> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn core::slice[0]::{{impl}}[0]::iter[0]<usize> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn core::slice[0]::{{impl}}[0]::len[0]<usize> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn pr_75255::dispatch[0] @@ pr_75255-cgu.1[External]\n-//~ MONO_ITEM fn pr_75255::foo[0]<alloc::string[0]::String[0]> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn pr_75255::foo[0]<alloc::vec[0]::Vec[0]<alloc::string[0]::String[0]>> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn pr_75255::bar[0]<alloc::string[0]::String[0]> @@ pr_75255-cgu.1[Internal]\n-//~ MONO_ITEM fn pr_75255::bar[0]<alloc::vec[0]::Vec[0]<alloc::string[0]::String[0]>> @@ pr_75255-cgu.1[Internal]"}, {"sha": "71d55dbb96e115c4621e902c94e67381f9240201", "filename": "src/test/mir-opt/const_allocation2.main.ConstProp.after.mir.32bit", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.mir.32bit", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.mir.32bit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.mir.32bit?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -30,41 +30,41 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 8, align: 4) {\n-    \u257e\u2500alloc21\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n+    \u257e\u2500alloc23\u2500\u257c 03 00 00 00                         \u2502 \u257e\u2500\u2500\u257c....\n }\n \n-alloc21 (size: 48, align: 4) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc4\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc9\u2500\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n-    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc19\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n+alloc23 (size: 48, align: 4) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc8\u2500\u2500\u257c 00 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x10 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500alloc13\u2500\u257c 02 00 00 00 \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u257c....\n+    0x20 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500alloc21\u2500\u257c 03 00 00 00 \u2502 ....*...\u257e\u2500\u2500\u257c....\n }\n \n-alloc4 (size: 0, align: 4) {}\n+alloc8 (size: 0, align: 4) {}\n \n-alloc9 (size: 8, align: 4) {\n-    \u257e\u2500alloc7\u2500\u2500\u257c \u257e\u2500alloc8\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+alloc13 (size: 8, align: 4) {\n+    \u257e\u2500alloc11\u2500\u257c \u257e\u2500alloc12\u2500\u257c                         \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n-alloc7 (size: 1, align: 1) {\n+alloc11 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc8 (size: 1, align: 1) {\n+alloc12 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc19 (size: 12, align: 4) {\n-    \u257e\u2500a15+0x3\u2500\u257c \u257e\u2500alloc16\u2500\u257c \u257e\u2500a18+0x2\u2500\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n+alloc21 (size: 12, align: 4) {\n+    \u257e\u2500a17+0x3\u2500\u257c \u257e\u2500alloc18\u2500\u257c \u257e\u2500a20+0x2\u2500\u257c             \u2502 \u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\u257e\u2500\u2500\u257c\n }\n \n-alloc15 (size: 4, align: 1) {\n+alloc17 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc16 (size: 1, align: 1) {\n+alloc18 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc18 (size: 4, align: 1) {\n+alloc20 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "79bad7ea9262be0757bfcc4eb519c97c0ac60062", "filename": "src/test/mir-opt/const_allocation2.main.ConstProp.after.mir.64bit", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.mir.64bit", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.mir.64bit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_allocation2.main.ConstProp.after.mir.64bit?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -30,44 +30,44 @@ fn main() -> () {\n }\n \n alloc0 (static: FOO, size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc21\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc23\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 03 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n }\n \n-alloc21 (size: 72, align: 8) {\n-    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc23 (size: 72, align: 8) {\n+    0x00 \u2502 00 00 00 00 __ __ __ __ \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....\u2591\u2591\u2591\u2591\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x10 \u2502 00 00 00 00 00 00 00 00 00 00 00 00 __ __ __ __ \u2502 ............\u2591\u2591\u2591\u2591\n-    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc9\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n-    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc19\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x20 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc13\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c 02 00 00 00 00 00 00 00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c........\n+    0x30 \u2502 01 00 00 00 2a 00 00 00 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc21\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 ....*...\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n     0x40 \u2502 03 00 00 00 00 00 00 00                         \u2502 ........\n }\n \n-alloc4 (size: 0, align: 8) {}\n+alloc8 (size: 0, align: 8) {}\n \n-alloc9 (size: 16, align: 8) {\n-    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc7\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc8\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc13 (size: 16, align: 8) {\n+    \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc11\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc12\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc7 (size: 1, align: 1) {\n+alloc11 (size: 1, align: 1) {\n     05                                              \u2502 .\n }\n \n-alloc8 (size: 1, align: 1) {\n+alloc12 (size: 1, align: 1) {\n     06                                              \u2502 .\n }\n \n-alloc19 (size: 24, align: 8) {\n-    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc15+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc16\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n-    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc18+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+alloc21 (size: 24, align: 8) {\n+    0x00 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc17+0x3\u2500\u2500\u2500\u2500\u2500\u257c \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u2500alloc18\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u257c \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n+    0x10 \u2502 \u257e\u2500\u2500\u2500\u2500\u2500alloc20+0x2\u2500\u2500\u2500\u2500\u2500\u257c                         \u2502 \u257e\u2500\u2500\u2500\u2500\u2500\u2500\u257c\n }\n \n-alloc15 (size: 4, align: 1) {\n+alloc17 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }\n \n-alloc16 (size: 1, align: 1) {\n+alloc18 (size: 1, align: 1) {\n     2a                                              \u2502 *\n }\n \n-alloc18 (size: 4, align: 1) {\n+alloc20 (size: 4, align: 1) {\n     2a 45 15 6f                                     \u2502 *E.o\n }"}, {"sha": "93c4e9372e8fbf47880f3d610489ac08db3c1d82", "filename": "src/test/ui/consts/const-eval/erroneous-const.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -0,0 +1,20 @@\n+//! Make sure we error on erroneous consts even if they are unused.\n+#![warn(const_err, unconditional_panic)]\n+\n+struct PrintName<T>(T);\n+impl<T> PrintName<T> {\n+    const VOID: () = [()][2]; //~WARN any use of this value will cause an error\n+    //~^ WARN this operation will panic at runtime\n+}\n+\n+const fn no_codegen<T>() {\n+    if false { //~ERROR evaluation of constant value failed\n+        let _ = PrintName::<T>::VOID;\n+    }\n+}\n+\n+pub static FOO: () = no_codegen::<i32>(); //~ERROR could not evaluate static initializer\n+\n+fn main() {\n+    FOO\n+}"}, {"sha": "da7e7247d50f98ef85d961112cf1a796886e373d", "filename": "src/test/ui/consts/const-eval/erroneous-const.stderr", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Ferroneous-const.stderr?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -0,0 +1,43 @@\n+warning: this operation will panic at runtime\n+  --> $DIR/erroneous-const.rs:6:22\n+   |\n+LL |     const VOID: () = [()][2];\n+   |                      ^^^^^^^ index out of bounds: the len is 1 but the index is 2\n+   |\n+note: the lint level is defined here\n+  --> $DIR/erroneous-const.rs:2:20\n+   |\n+LL | #![warn(const_err, unconditional_panic)]\n+   |                    ^^^^^^^^^^^^^^^^^^^\n+\n+warning: any use of this value will cause an error\n+  --> $DIR/erroneous-const.rs:6:22\n+   |\n+LL |     const VOID: () = [()][2];\n+   |     -----------------^^^^^^^-\n+   |                      |\n+   |                      index out of bounds: the len is 1 but the index is 2\n+   |\n+note: the lint level is defined here\n+  --> $DIR/erroneous-const.rs:2:9\n+   |\n+LL | #![warn(const_err, unconditional_panic)]\n+   |         ^^^^^^^^^\n+\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/erroneous-const.rs:11:5\n+   |\n+LL | /     if false {\n+LL | |         let _ = PrintName::<T>::VOID;\n+LL | |     }\n+   | |_____^ referenced constant has errors\n+\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/erroneous-const.rs:16:22\n+   |\n+LL | pub static FOO: () = no_codegen::<i32>();\n+   |                      ^^^^^^^^^^^^^^^^^^^ referenced constant has errors\n+\n+error: aborting due to 2 previous errors; 2 warnings emitted\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "0e3ea4bc8c9de0f4e008cc413f9e1cdd465c3bb2", "filename": "src/test/ui/mismatched_types/issue-74918-missing-lifetime.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -0,0 +1,28 @@\n+// Regression test for issue #74918\n+// Tests that we don't ICE after emitting an error\n+\n+struct ChunkingIterator<T, S: 'static + Iterator<Item = T>> {\n+    source: S,\n+}\n+\n+impl<T, S: Iterator<Item = T>> Iterator for ChunkingIterator<T, S> {\n+    type Item = IteratorChunk<T, S>; //~ ERROR missing lifetime\n+\n+    fn next(&mut self) -> Option<IteratorChunk<T, S>> { //~ ERROR `impl`\n+        todo!()\n+    }\n+}\n+\n+struct IteratorChunk<'a, T, S: Iterator<Item = T>> {\n+    source: &'a mut S,\n+}\n+\n+impl<T, S: Iterator<Item = T>> Iterator for IteratorChunk<'_, T, S> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        todo!()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "da3056eac90093201a1c97c6377012a2b343854e", "filename": "src/test/ui/mismatched_types/issue-74918-missing-lifetime.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-74918-missing-lifetime.stderr?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -0,0 +1,30 @@\n+error[E0106]: missing lifetime specifier\n+  --> $DIR/issue-74918-missing-lifetime.rs:9:31\n+   |\n+LL |     type Item = IteratorChunk<T, S>;\n+   |                               ^ expected named lifetime parameter\n+   |\n+help: consider introducing a named lifetime parameter\n+   |\n+LL |     type Item<'a> = IteratorChunk<<'a>T, S>;\n+   |              ^^^^                 ^^^^\n+\n+error: `impl` item signature doesn't match `trait` item signature\n+  --> $DIR/issue-74918-missing-lifetime.rs:11:5\n+   |\n+LL |     fn next(&mut self) -> Option<IteratorChunk<T, S>> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found `fn(&mut ChunkingIterator<T, S>) -> std::option::Option<IteratorChunk<'_, T, S>>`\n+   | \n+  ::: $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n+   |\n+LL |     fn next(&mut self) -> Option<Self::Item>;\n+   |     ----------------------------------------- expected `fn(&mut ChunkingIterator<T, S>) -> std::option::Option<IteratorChunk<'static, _, _>>`\n+   |\n+   = note: expected `fn(&mut ChunkingIterator<T, S>) -> std::option::Option<IteratorChunk<'static, _, _>>`\n+              found `fn(&mut ChunkingIterator<T, S>) -> std::option::Option<IteratorChunk<'_, _, _>>`\n+   = help: the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+   = help: verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0106`."}, {"sha": "4410514476dc1c34921281e333dc2816c9abc260", "filename": "src/test/ui/mismatched_types/issue-75361-mismatched-impl.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-75361-mismatched-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-75361-mismatched-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-75361-mismatched-impl.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -0,0 +1,24 @@\n+// Regresison test for issue #75361\n+// Tests that we don't ICE on mismatched types with inference variables\n+\n+\n+trait MyTrait {\n+    type Item;\n+}\n+\n+pub trait Graph {\n+  type EdgeType;\n+\n+  fn adjacent_edges(&self) -> Box<dyn MyTrait<Item = &Self::EdgeType>>;\n+}\n+\n+impl<T> Graph for T {\n+  type EdgeType = T;\n+\n+  fn adjacent_edges(&self) -> Box<dyn MyTrait<Item = &Self::EdgeType> + '_> { //~ ERROR `impl`\n+      panic!()\n+  }\n+\n+}\n+\n+fn main() {}"}, {"sha": "5be7f5271dee87dd1af876174713a32b3dfcb187", "filename": "src/test/ui/mismatched_types/issue-75361-mismatched-impl.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-75361-mismatched-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-75361-mismatched-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-75361-mismatched-impl.stderr?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -0,0 +1,19 @@\n+error: `impl` item signature doesn't match `trait` item signature\n+  --> $DIR/issue-75361-mismatched-impl.rs:18:3\n+   |\n+LL |   fn adjacent_edges(&self) -> Box<dyn MyTrait<Item = &Self::EdgeType>>;\n+   |   --------------------------------------------------------------------- expected `fn(&T) -> std::boxed::Box<(dyn MyTrait<Item = &_> + 'static)>`\n+...\n+LL |   fn adjacent_edges(&self) -> Box<dyn MyTrait<Item = &Self::EdgeType> + '_> {\n+   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found `fn(&T) -> std::boxed::Box<dyn MyTrait<Item = &_>>`\n+   |\n+   = note: expected `fn(&T) -> std::boxed::Box<(dyn MyTrait<Item = &T> + 'static)>`\n+              found `fn(&T) -> std::boxed::Box<dyn MyTrait<Item = &T>>`\n+help: the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+  --> $DIR/issue-75361-mismatched-impl.rs:12:55\n+   |\n+LL |   fn adjacent_edges(&self) -> Box<dyn MyTrait<Item = &Self::EdgeType>>;\n+   |                                                       ^^^^^^^^^^^^^^ consider borrowing this type parameter in the trait\n+\n+error: aborting due to previous error\n+"}, {"sha": "a6e6949101775cebc31d7fb7b807991d90a3f831", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -1730,6 +1730,7 @@ Released 2018-09-13\n [`transmute_int_to_float`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_int_to_float\n [`transmute_ptr_to_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ptr\n [`transmute_ptr_to_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_ptr_to_ref\n+[`transmutes_expressible_as_ptr_casts`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmutes_expressible_as_ptr_casts\n [`transmuting_null`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmuting_null\n [`trivial_regex`]: https://rust-lang.github.io/rust-clippy/master/index.html#trivial_regex\n [`trivially_copy_pass_by_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref"}, {"sha": "828ee91059601d2f9a5361c1b404b5e05cca217a", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -788,6 +788,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &to_digit_is_some::TO_DIGIT_IS_SOME,\n         &trait_bounds::TYPE_REPETITION_IN_BOUNDS,\n         &transmute::CROSSPOINTER_TRANSMUTE,\n+        &transmute::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n         &transmute::TRANSMUTE_BYTES_TO_STR,\n         &transmute::TRANSMUTE_FLOAT_TO_INT,\n         &transmute::TRANSMUTE_INT_TO_BOOL,\n@@ -1417,6 +1418,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&temporary_assignment::TEMPORARY_ASSIGNMENT),\n         LintId::of(&to_digit_is_some::TO_DIGIT_IS_SOME),\n         LintId::of(&transmute::CROSSPOINTER_TRANSMUTE),\n+        LintId::of(&transmute::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS),\n         LintId::of(&transmute::TRANSMUTE_BYTES_TO_STR),\n         LintId::of(&transmute::TRANSMUTE_FLOAT_TO_INT),\n         LintId::of(&transmute::TRANSMUTE_INT_TO_BOOL),\n@@ -1617,6 +1619,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&swap::MANUAL_SWAP),\n         LintId::of(&temporary_assignment::TEMPORARY_ASSIGNMENT),\n         LintId::of(&transmute::CROSSPOINTER_TRANSMUTE),\n+        LintId::of(&transmute::TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS),\n         LintId::of(&transmute::TRANSMUTE_BYTES_TO_STR),\n         LintId::of(&transmute::TRANSMUTE_FLOAT_TO_INT),\n         LintId::of(&transmute::TRANSMUTE_INT_TO_BOOL),"}, {"sha": "f077c14618316e51a305d848015ebc2ab2a36e4d", "filename": "src/tools/clippy/clippy_lints/src/transmute.rs", "status": "modified", "additions": 103, "deletions": 2, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -7,8 +7,10 @@ use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, GenericArg, Mutability, QPath, TyKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, cast::CastKind, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::DUMMY_SP;\n+use rustc_typeck::check::{cast::CastCheck, FnCtxt, Inherited};\n use std::borrow::Cow;\n \n declare_clippy_lint! {\n@@ -48,6 +50,29 @@ declare_clippy_lint! {\n     \"transmutes that have the same to and from types or could be a cast/coercion\"\n }\n \n+// FIXME: Merge this lint with USELESS_TRANSMUTE once that is out of the nursery.\n+declare_clippy_lint! {\n+    /// **What it does:**Checks for transmutes that could be a pointer cast.\n+    ///\n+    /// **Why is this bad?** Readability. The code tricks people into thinking that\n+    /// something complex is going on.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust,ignore\n+    /// core::intrinsics::transmute::<*const [i32], *const [u16]>(p)\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// p as *const [u16]\n+    /// ```\n+    pub TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n+    complexity,\n+    \"transmutes that could be a pointer cast\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for transmutes between a type `T` and `*T`.\n     ///\n@@ -269,6 +294,7 @@ declare_clippy_lint! {\n     correctness,\n     \"transmute between collections of layout-incompatible types\"\n }\n+\n declare_lint_pass!(Transmute => [\n     CROSSPOINTER_TRANSMUTE,\n     TRANSMUTE_PTR_TO_REF,\n@@ -281,6 +307,7 @@ declare_lint_pass!(Transmute => [\n     TRANSMUTE_INT_TO_FLOAT,\n     TRANSMUTE_FLOAT_TO_INT,\n     UNSOUND_COLLECTION_TRANSMUTE,\n+    TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n ]);\n \n // used to check for UNSOUND_COLLECTION_TRANSMUTE\n@@ -601,7 +628,25 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                             );\n                         }\n                     },\n-                    _ => return,\n+                    (_, _) if can_be_expressed_as_pointer_cast(cx, e, from_ty, to_ty) => span_lint_and_then(\n+                        cx,\n+                        TRANSMUTES_EXPRESSIBLE_AS_PTR_CASTS,\n+                        e.span,\n+                        &format!(\n+                            \"transmute from `{}` to `{}` which could be expressed as a pointer cast instead\",\n+                            from_ty,\n+                            to_ty\n+                        ),\n+                        |diag| {\n+                            if let Some(arg) = sugg::Sugg::hir_opt(cx, &args[0]) {\n+                                let sugg = arg.as_ty(&to_ty.to_string()).to_string();\n+                                diag.span_suggestion(e.span, \"try\", sugg, Applicability::MachineApplicable);\n+                            }\n+                        }\n+                    ),\n+                    _ => {\n+                        return;\n+                    },\n                 }\n             }\n         }\n@@ -648,3 +693,59 @@ fn is_layout_incompatible<'tcx>(cx: &LateContext<'tcx>, from: Ty<'tcx>, to: Ty<'\n         false\n     }\n }\n+\n+/// Check if the type conversion can be expressed as a pointer cast, instead of\n+/// a transmute. In certain cases, including some invalid casts from array\n+/// references to pointers, this may cause additional errors to be emitted and/or\n+/// ICE error messages. This function will panic if that occurs.\n+fn can_be_expressed_as_pointer_cast<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    from_ty: Ty<'tcx>,\n+    to_ty: Ty<'tcx>,\n+) -> bool {\n+    use CastKind::*;\n+    matches!(\n+        check_cast(cx, e, from_ty, to_ty),\n+        Some(PtrPtrCast | PtrAddrCast | AddrPtrCast | ArrayPtrCast | FnPtrPtrCast | FnPtrAddrCast)\n+    )\n+}\n+\n+/// If a cast from from_ty to to_ty is valid, returns an Ok containing the kind of\n+/// the cast. In certain cases, including some invalid casts from array references\n+/// to pointers, this may cause additional errors to be emitted and/or ICE error\n+/// messages. This function will panic if that occurs.\n+fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>, to_ty: Ty<'tcx>) -> Option<CastKind> {\n+    let hir_id = e.hir_id;\n+    let local_def_id = hir_id.owner;\n+\n+    Inherited::build(cx.tcx, local_def_id).enter(|inherited| {\n+        let fn_ctxt = FnCtxt::new(&inherited, cx.param_env, hir_id);\n+\n+        // If we already have errors, we can't be sure we can pointer cast.\n+        assert!(\n+            !fn_ctxt.errors_reported_since_creation(),\n+            \"Newly created FnCtxt contained errors\"\n+        );\n+\n+        if let Ok(check) = CastCheck::new(\n+            &fn_ctxt, e, from_ty, to_ty,\n+            // We won't show any error to the user, so we don't care what the span is here.\n+            DUMMY_SP, DUMMY_SP,\n+        ) {\n+            let res = check.do_check(&fn_ctxt);\n+\n+            // do_check's documentation says that it might return Ok and create\n+            // errors in the fcx instead of returing Err in some cases. Those cases\n+            // should be filtered out before getting here.\n+            assert!(\n+                !fn_ctxt.errors_reported_since_creation(),\n+                \"`fn_ctxt` contained errors after cast check!\"\n+            );\n+\n+            res.ok()\n+        } else {\n+            None\n+        }\n+    })\n+}"}, {"sha": "1f3f70631fb29ca5422b47e596cbe007d9a1f49f", "filename": "src/tools/clippy/src/lintlist/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -2215,6 +2215,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"transmute\",\n     },\n+    Lint {\n+        name: \"transmutes_expressible_as_ptr_casts\",\n+        group: \"complexity\",\n+        desc: \"transmutes that could be a pointer cast\",\n+        deprecation: None,\n+        module: \"transmute\",\n+    },\n     Lint {\n         name: \"transmuting_null\",\n         group: \"correctness\","}, {"sha": "98288dde6d845acbad6d27df59e2a1732ba3c5a8", "filename": "src/tools/clippy/tests/ui/transmutes_expressible_as_ptr_casts.fixed", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.fixed?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -0,0 +1,90 @@\n+// run-rustfix\n+#![warn(clippy::transmutes_expressible_as_ptr_casts)]\n+// These two warnings currrently cover the cases transmutes_expressible_as_ptr_casts\n+// would otherwise be responsible for\n+#![warn(clippy::useless_transmute)]\n+#![warn(clippy::transmute_ptr_to_ptr)]\n+#![allow(unused_unsafe)]\n+#![allow(dead_code)]\n+\n+use std::mem::{size_of, transmute};\n+\n+// rustc_typeck::check::cast contains documentation about when a cast `e as U` is \n+// valid, which we quote from below.\n+fn main() {\n+    // We should see an error message for each transmute, and no error messages for\n+    // the casts, since the casts are the recommended fixes.\n+\n+    // e is an integer and U is *U_0, while U_0: Sized; addr-ptr-cast\n+    let _ptr_i32_transmute = unsafe {\n+        usize::MAX as *const i32\n+    };\n+    let ptr_i32 = usize::MAX as *const i32;\n+\n+    // e has type *T, U is *U_0, and either U_0: Sized ...\n+    let _ptr_i8_transmute = unsafe {\n+        ptr_i32 as *const i8\n+    };\n+    let _ptr_i8 = ptr_i32 as *const i8;\n+\n+    let slice_ptr = &[0,1,2,3] as *const [i32];\n+\n+    // ... or pointer_kind(T) = pointer_kind(U_0); ptr-ptr-cast\n+    let _ptr_to_unsized_transmute = unsafe {\n+        slice_ptr as *const [u16]\n+    };\n+    let _ptr_to_unsized = slice_ptr as *const [u16];\n+    // TODO: We could try testing vtable casts here too, but maybe\n+    // we should wait until std::raw::TraitObject is stabilized?\n+\n+    // e has type *T and U is a numeric type, while T: Sized; ptr-addr-cast\n+    let _usize_from_int_ptr_transmute = unsafe {\n+        ptr_i32 as usize\n+    };\n+    let _usize_from_int_ptr = ptr_i32 as usize;\n+\n+    let array_ref: &[i32; 4] = &[1,2,3,4];\n+\n+    // e has type &[T; n] and U is *const T; array-ptr-cast\n+    let _array_ptr_transmute = unsafe {\n+        array_ref as *const [i32; 4]\n+    };\n+    let _array_ptr = array_ref as *const [i32; 4];\n+\n+    fn foo(_: usize) -> u8 { 42 }\n+\n+    // e is a function pointer type and U has type *T, while T: Sized; fptr-ptr-cast\n+    let _usize_ptr_transmute = unsafe {\n+        foo as *const usize\n+    };\n+    let _usize_ptr_transmute = foo as *const usize;\n+\n+    // e is a function pointer type and U is an integer; fptr-addr-cast\n+    let _usize_from_fn_ptr_transmute = unsafe {\n+        foo as usize\n+    };\n+    let _usize_from_fn_ptr = foo as *const usize;\n+}\n+\n+// If a ref-to-ptr cast of this form where the pointer type points to a type other\n+// than the referenced type, calling `CastCheck::do_check` has been observed to\n+// cause an ICE error message. `do_check` is currently called inside the\n+// `transmutes_expressible_as_ptr_casts` check, but other, more specific lints\n+// currently prevent it from being called in these cases. This test is meant to\n+// fail if the ordering of the checks ever changes enough to cause these cases to\n+// fall through into `do_check`.\n+fn trigger_do_check_to_emit_error(in_param: &[i32; 1]) -> *const u8 {\n+    unsafe { in_param as *const [i32; 1] as *const u8 }\n+}\n+\n+#[repr(C)]\n+struct Single(u64);\n+\n+#[repr(C)]\n+struct Pair(u32, u32);\n+\n+fn cannot_be_expressed_as_pointer_cast(in_param: Single) -> Pair {\n+    assert_eq!(size_of::<Single>(), size_of::<Pair>());\n+\n+    unsafe { transmute::<Single, Pair>(in_param) }\n+}"}, {"sha": "fd5055c08f63379f2bdf86da911a7922a166e605", "filename": "src/tools/clippy/tests/ui/transmutes_expressible_as_ptr_casts.rs", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.rs?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -0,0 +1,90 @@\n+// run-rustfix\n+#![warn(clippy::transmutes_expressible_as_ptr_casts)]\n+// These two warnings currrently cover the cases transmutes_expressible_as_ptr_casts\n+// would otherwise be responsible for\n+#![warn(clippy::useless_transmute)]\n+#![warn(clippy::transmute_ptr_to_ptr)]\n+#![allow(unused_unsafe)]\n+#![allow(dead_code)]\n+\n+use std::mem::{size_of, transmute};\n+\n+// rustc_typeck::check::cast contains documentation about when a cast `e as U` is \n+// valid, which we quote from below.\n+fn main() {\n+    // We should see an error message for each transmute, and no error messages for\n+    // the casts, since the casts are the recommended fixes.\n+\n+    // e is an integer and U is *U_0, while U_0: Sized; addr-ptr-cast\n+    let _ptr_i32_transmute = unsafe {\n+        transmute::<usize, *const i32>(usize::MAX)\n+    };\n+    let ptr_i32 = usize::MAX as *const i32;\n+\n+    // e has type *T, U is *U_0, and either U_0: Sized ...\n+    let _ptr_i8_transmute = unsafe {\n+        transmute::<*const i32, *const i8>(ptr_i32)\n+    };\n+    let _ptr_i8 = ptr_i32 as *const i8;\n+\n+    let slice_ptr = &[0,1,2,3] as *const [i32];\n+\n+    // ... or pointer_kind(T) = pointer_kind(U_0); ptr-ptr-cast\n+    let _ptr_to_unsized_transmute = unsafe {\n+        transmute::<*const [i32], *const [u16]>(slice_ptr)\n+    };\n+    let _ptr_to_unsized = slice_ptr as *const [u16];\n+    // TODO: We could try testing vtable casts here too, but maybe\n+    // we should wait until std::raw::TraitObject is stabilized?\n+\n+    // e has type *T and U is a numeric type, while T: Sized; ptr-addr-cast\n+    let _usize_from_int_ptr_transmute = unsafe {\n+        transmute::<*const i32, usize>(ptr_i32)\n+    };\n+    let _usize_from_int_ptr = ptr_i32 as usize;\n+\n+    let array_ref: &[i32; 4] = &[1,2,3,4];\n+\n+    // e has type &[T; n] and U is *const T; array-ptr-cast\n+    let _array_ptr_transmute = unsafe {\n+        transmute::<&[i32; 4], *const [i32; 4]>(array_ref)\n+    };\n+    let _array_ptr = array_ref as *const [i32; 4];\n+\n+    fn foo(_: usize) -> u8 { 42 }\n+\n+    // e is a function pointer type and U has type *T, while T: Sized; fptr-ptr-cast\n+    let _usize_ptr_transmute = unsafe {\n+        transmute::<fn(usize) -> u8, *const usize>(foo)\n+    };\n+    let _usize_ptr_transmute = foo as *const usize;\n+\n+    // e is a function pointer type and U is an integer; fptr-addr-cast\n+    let _usize_from_fn_ptr_transmute = unsafe {\n+        transmute::<fn(usize) -> u8, usize>(foo)\n+    };\n+    let _usize_from_fn_ptr = foo as *const usize;\n+}\n+\n+// If a ref-to-ptr cast of this form where the pointer type points to a type other\n+// than the referenced type, calling `CastCheck::do_check` has been observed to\n+// cause an ICE error message. `do_check` is currently called inside the\n+// `transmutes_expressible_as_ptr_casts` check, but other, more specific lints\n+// currently prevent it from being called in these cases. This test is meant to\n+// fail if the ordering of the checks ever changes enough to cause these cases to\n+// fall through into `do_check`.\n+fn trigger_do_check_to_emit_error(in_param: &[i32; 1]) -> *const u8 {\n+    unsafe { transmute::<&[i32; 1], *const u8>(in_param) }\n+}\n+\n+#[repr(C)]\n+struct Single(u64);\n+\n+#[repr(C)]\n+struct Pair(u32, u32);\n+\n+fn cannot_be_expressed_as_pointer_cast(in_param: Single) -> Pair {\n+    assert_eq!(size_of::<Single>(), size_of::<Pair>());\n+\n+    unsafe { transmute::<Single, Pair>(in_param) }\n+}"}, {"sha": "46597acc6c0d272ce9c7175855290c94593559bf", "filename": "src/tools/clippy/tests/ui/transmutes_expressible_as_ptr_casts.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr?ref=7189ca604ad5d9dfff7d0aeef6a42c89d73cbac7", "patch": "@@ -0,0 +1,56 @@\n+error: transmute from an integer to a pointer\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:20:9\n+   |\n+LL |         transmute::<usize, *const i32>(usize::MAX)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `usize::MAX as *const i32`\n+   |\n+   = note: `-D clippy::useless-transmute` implied by `-D warnings`\n+\n+error: transmute from a pointer to a pointer\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:26:9\n+   |\n+LL |         transmute::<*const i32, *const i8>(ptr_i32)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr_i32 as *const i8`\n+   |\n+   = note: `-D clippy::transmute-ptr-to-ptr` implied by `-D warnings`\n+\n+error: transmute from a pointer to a pointer\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:34:9\n+   |\n+LL |         transmute::<*const [i32], *const [u16]>(slice_ptr)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `slice_ptr as *const [u16]`\n+\n+error: transmute from `*const i32` to `usize` which could be expressed as a pointer cast instead\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:42:9\n+   |\n+LL |         transmute::<*const i32, usize>(ptr_i32)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `ptr_i32 as usize`\n+   |\n+   = note: `-D clippy::transmutes-expressible-as-ptr-casts` implied by `-D warnings`\n+\n+error: transmute from a reference to a pointer\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:50:9\n+   |\n+LL |         transmute::<&[i32; 4], *const [i32; 4]>(array_ref)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `array_ref as *const [i32; 4]`\n+\n+error: transmute from `fn(usize) -> u8 {main::foo}` to `*const usize` which could be expressed as a pointer cast instead\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:58:9\n+   |\n+LL |         transmute::<fn(usize) -> u8, *const usize>(foo)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `foo as *const usize`\n+\n+error: transmute from `fn(usize) -> u8 {main::foo}` to `usize` which could be expressed as a pointer cast instead\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:64:9\n+   |\n+LL |         transmute::<fn(usize) -> u8, usize>(foo)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `foo as usize`\n+\n+error: transmute from a reference to a pointer\n+  --> $DIR/transmutes_expressible_as_ptr_casts.rs:77:14\n+   |\n+LL |     unsafe { transmute::<&[i32; 1], *const u8>(in_param) }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `in_param as *const [i32; 1] as *const u8`\n+\n+error: aborting due to 8 previous errors\n+"}]}