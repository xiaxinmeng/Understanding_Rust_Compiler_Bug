{"sha": "d7638f9dba5cef5c4db7b9008196ede4450d8521", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NjM4ZjlkYmE1Y2VmNWM0ZGI3YjkwMDgxOTZlZGU0NDUwZDg1MjE=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-05-08T22:27:29Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-05T19:01:36Z"}, "message": "change to newer macro escape mechanism, using uints in more places", "tree": {"sha": "ca96d50b78c7defd451ef9807a7f7554acc3436f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca96d50b78c7defd451ef9807a7f7554acc3436f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d7638f9dba5cef5c4db7b9008196ede4450d8521", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d7638f9dba5cef5c4db7b9008196ede4450d8521", "html_url": "https://github.com/rust-lang/rust/commit/d7638f9dba5cef5c4db7b9008196ede4450d8521", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d7638f9dba5cef5c4db7b9008196ede4450d8521/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77c2c0900f975e1fa9179c3e7492d62656734295", "url": "https://api.github.com/repos/rust-lang/rust/commits/77c2c0900f975e1fa9179c3e7492d62656734295", "html_url": "https://github.com/rust-lang/rust/commit/77c2c0900f975e1fa9179c3e7492d62656734295"}], "stats": {"total": 294, "additions": 166, "deletions": 128}, "files": [{"sha": "48cfe61309c2ff07912b75c4fbcd1b63a773954a", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 83, "deletions": 42, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/d7638f9dba5cef5c4db7b9008196ede4450d8521/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7638f9dba5cef5c4db7b9008196ede4450d8521/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=d7638f9dba5cef5c4db7b9008196ede4450d8521", "patch": "@@ -11,13 +11,15 @@\n use core::prelude::*;\n \n use ast;\n+use ast::Name;\n use codemap;\n use codemap::{CodeMap, span, ExpnInfo, ExpandedFrom};\n use codemap::CallInfo;\n use diagnostic::span_handler;\n use ext;\n use parse;\n use parse::token;\n+use parse::token::{intern};\n \n use core::hashmap::HashMap;\n use core::vec;\n@@ -91,29 +93,33 @@ pub enum SyntaxExtension {\n     IdentTT(SyntaxExpanderTTItem),\n }\n \n+// The SyntaxEnv is the environment that's threaded through the expansion\n+// of macros. It contains bindings for macros, and also a special binding\n+// for \" block\" (not a legal identifier) that maps to a BlockInfo\n pub type SyntaxEnv = @mut MapChain<Name, Transformer>;\n \n-// Name : the domain of SyntaxEnvs\n-// want to change these to uints....\n-// note that we use certain strings that are not legal as identifiers\n-// to indicate, for instance, how blocks are supposed to behave.\n-type Name = @~str;\n-\n // Transformer : the codomain of SyntaxEnvs\n \n-// NB: it may seem crazy to lump both of these into one environment;\n-// what would it mean to bind \"foo\" to BlockLimit(true)? The idea\n-// is that this follows the lead of MTWT, and accommodates growth\n-// toward a more uniform syntax syntax (sorry) where blocks are just\n-// another kind of transformer.\n-\n pub enum Transformer {\n     // this identifier maps to a syntax extension or macro\n     SE(SyntaxExtension),\n-    // should blocks occurring here limit macro scopes?\n-    ScopeMacros(bool)\n+    // blockinfo : this is ... well, it's simpler than threading\n+    // another whole data stack-structured data structure through\n+    // expansion. Basically, there's an invariant that every\n+    // map must contain a binding for \" block\".\n+    BlockInfo(BlockInfo)\n+}\n+\n+pub struct BlockInfo {\n+    // should macros escape from this scope?\n+    macros_escape : bool,\n+    // what are the pending renames?\n+    pending_renames : @mut RenameList\n }\n \n+// a list of ident->name renamings\n+type RenameList = ~[(ast::ident,Name)];\n+\n // The base map of methods for expanding syntax extension\n // AST nodes into full ASTs\n pub fn syntax_expander_table() -> SyntaxEnv {\n@@ -127,77 +133,80 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n     }\n     let mut syntax_expanders = HashMap::new();\n     // NB identifier starts with space, and can't conflict with legal idents\n-    syntax_expanders.insert(@~\" block\",\n-                            @ScopeMacros(true));\n-    syntax_expanders.insert(@~\"macro_rules\",\n+    syntax_expanders.insert(intern(&\" block\"),\n+                            @BlockInfo(BlockInfo{\n+                                macros_escape : false,\n+                                pending_renames : @mut ~[]\n+                            }));\n+    syntax_expanders.insert(intern(&\"macro_rules\"),\n                             builtin_item_tt(\n                                 ext::tt::macro_rules::add_new_extension));\n-    syntax_expanders.insert(@~\"fmt\",\n+    syntax_expanders.insert(intern(&\"fmt\"),\n                             builtin_normal_tt(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(\n-        @~\"auto_encode\",\n+        intern(&\"auto_encode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));\n     syntax_expanders.insert(\n-        @~\"auto_decode\",\n+        intern(&\"auto_decode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_decode)));\n-    syntax_expanders.insert(@~\"env\",\n+    syntax_expanders.insert(intern(&\"env\"),\n                             builtin_normal_tt(ext::env::expand_syntax_ext));\n-    syntax_expanders.insert(@~\"bytes\",\n+    syntax_expanders.insert(intern(\"bytes\"),\n                             builtin_normal_tt(ext::bytes::expand_syntax_ext));\n-    syntax_expanders.insert(@~\"concat_idents\",\n+    syntax_expanders.insert(intern(\"concat_idents\"),\n                             builtin_normal_tt(\n                                 ext::concat_idents::expand_syntax_ext));\n-    syntax_expanders.insert(@~\"log_syntax\",\n+    syntax_expanders.insert(intern(&\"log_syntax\"),\n                             builtin_normal_tt(\n                                 ext::log_syntax::expand_syntax_ext));\n-    syntax_expanders.insert(@~\"deriving\",\n+    syntax_expanders.insert(intern(&\"deriving\"),\n                             @SE(ItemDecorator(\n                                 ext::deriving::expand_meta_deriving)));\n \n     // Quasi-quoting expanders\n-    syntax_expanders.insert(@~\"quote_tokens\",\n+    syntax_expanders.insert(intern(&\"quote_tokens\"),\n                        builtin_normal_tt(ext::quote::expand_quote_tokens));\n-    syntax_expanders.insert(@~\"quote_expr\",\n+    syntax_expanders.insert(intern(&\"quote_expr\"),\n                        builtin_normal_tt(ext::quote::expand_quote_expr));\n-    syntax_expanders.insert(@~\"quote_ty\",\n+    syntax_expanders.insert(intern(&\"quote_ty\"),\n                        builtin_normal_tt(ext::quote::expand_quote_ty));\n-    syntax_expanders.insert(@~\"quote_item\",\n+    syntax_expanders.insert(intern(&\"quote_item\"),\n                        builtin_normal_tt(ext::quote::expand_quote_item));\n-    syntax_expanders.insert(@~\"quote_pat\",\n+    syntax_expanders.insert(intern(&\"quote_pat\"),\n                        builtin_normal_tt(ext::quote::expand_quote_pat));\n-    syntax_expanders.insert(@~\"quote_stmt\",\n+    syntax_expanders.insert(intern(&\"quote_stmt\"),\n                        builtin_normal_tt(ext::quote::expand_quote_stmt));\n \n-    syntax_expanders.insert(@~\"line\",\n+    syntax_expanders.insert(intern(&\"line\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_line));\n-    syntax_expanders.insert(@~\"col\",\n+    syntax_expanders.insert(intern(&\"col\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_col));\n-    syntax_expanders.insert(@~\"file\",\n+    syntax_expanders.insert(intern(&\"file\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_file));\n-    syntax_expanders.insert(@~\"stringify\",\n+    syntax_expanders.insert(intern(&\"stringify\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_stringify));\n-    syntax_expanders.insert(@~\"include\",\n+    syntax_expanders.insert(intern(&\"include\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_include));\n-    syntax_expanders.insert(@~\"include_str\",\n+    syntax_expanders.insert(intern(&\"include_str\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_include_str));\n-    syntax_expanders.insert(@~\"include_bin\",\n+    syntax_expanders.insert(intern(&\"include_bin\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_include_bin));\n-    syntax_expanders.insert(@~\"module_path\",\n+    syntax_expanders.insert(intern(&\"module_path\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_mod));\n-    syntax_expanders.insert(@~\"proto\",\n+    syntax_expanders.insert(intern(&\"proto\"),\n                             builtin_item_tt(ext::pipes::expand_proto));\n-    syntax_expanders.insert(@~\"asm\",\n+    syntax_expanders.insert(intern(&\"asm\"),\n                             builtin_normal_tt(ext::asm::expand_asm));\n     syntax_expanders.insert(\n-        @~\"trace_macros\",\n+        intern(&\"trace_macros\"),\n         builtin_normal_tt(ext::trace_macros::expand_trace_macros));\n     MapChain::new(~syntax_expanders)\n }\n@@ -478,7 +487,39 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n             ConsMapChain (~ref mut map,_) => map.insert(key,ext)\n         }\n     }\n+    // insert the binding into the topmost frame for which the binding\n+    // associated with 'n' exists and satisfies pred\n+    // ... there are definitely some opportunities for abstraction\n+    // here that I'm ignoring. (e.g., manufacturing a predicate on\n+    // the maps in the chain, and using an abstract \"find\".\n+    fn insert_into_frame(&mut self, key: K, ext: @V, n: K, pred: &fn(&@V)->bool) {\n+        match *self {\n+            BaseMapChain (~ref mut map) => {\n+                if satisfies_pred(map,&n,pred) {\n+                    map.insert(key,ext);\n+                } else {\n+                    fail!(~\"expected map chain containing satisfying frame\")\n+                }\n+            },\n+            ConsMapChain (~ref mut map, rest) => {\n+                if satisfies_pred(map,&n,pred) {\n+                    map.insert(key,ext);\n+                } else {\n+                    rest.insert_into_frame(key,ext,n,pred)\n+                }\n+            }\n+        }\n+    }\n+}\n \n+fn satisfies_pred<K : Eq + Hash + IterBytes,V>(map : &mut HashMap<K,V>,\n+                                               n: &K,\n+                                               pred: &fn(&V)->bool)\n+    -> bool {\n+    match map.find(n) {\n+        Some(ref v) => (pred(*v)),\n+        None => false\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "c23e34e0f91fa21ece82a7e080d92ac8fa1cc52e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 55, "deletions": 73, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/d7638f9dba5cef5c4db7b9008196ede4450d8521/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7638f9dba5cef5c4db7b9008196ede4450d8521/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d7638f9dba5cef5c4db7b9008196ede4450d8521", "patch": "@@ -25,6 +25,7 @@ use ext::base::*;\n use fold::*;\n use parse;\n use parse::{parse_item_from_source_str};\n+use parse::token::{get_ident_interner,intern};\n \n use core::vec;\n \n@@ -48,15 +49,14 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             fmt!(\"expected macro name without module \\\n                                   separators\"));\n                     }\n-                    /* using idents and token::special_idents would make the\n-                    the macro names be hygienic */\n-                    let extname = cx.parse_sess().interner.get(pth.idents[0]);\n+                    let extname = pth.idents[0];\n+                    let extnamestr = get_ident_interner().get(extname);\n                     // leaving explicit deref here to highlight unbox op:\n-                    match (*extsbox).find(&extname) {\n+                    match (*extsbox).find(&extname.repr) {\n                         None => {\n                             cx.span_fatal(\n                                 pth.span,\n-                                fmt!(\"macro undefined: '%s'\", *extname))\n+                                fmt!(\"macro undefined: '%s'\", *extnamestr))\n                         }\n                         Some(@SE(NormalTT(SyntaxExpanderTT{\n                             expander: exp,\n@@ -65,7 +65,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             cx.bt_push(ExpandedFrom(CallInfo {\n                                 call_site: s,\n                                 callee: NameAndSpan {\n-                                    name: copy *extname,\n+                                    name: copy *extnamestr,\n                                     span: exp_sp,\n                                 },\n                             }));\n@@ -78,7 +78,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                                         pth.span,\n                                         fmt!(\n                                             \"non-expr macro in expr pos: %s\",\n-                                            *extname\n+                                            *extnamestr\n                                         )\n                                     )\n                                 }\n@@ -94,7 +94,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                         _ => {\n                             cx.span_fatal(\n                                 pth.span,\n-                                fmt!(\"'%s' is not a tt-style macro\", *extname)\n+                                fmt!(\"'%s' is not a tt-style macro\", *extnamestr)\n                             )\n                         }\n                     }\n@@ -131,7 +131,7 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n         do vec::foldr(item.attrs, ~[*item]) |attr, items| {\n             let mname = attr::get_attr_name(attr);\n \n-            match (*extsbox).find(&mname) {\n+            match (*extsbox).find(&intern(*mname)) {\n               Some(@SE(ItemDecorator(dec_fn))) => {\n                   cx.bt_push(ExpandedFrom(CallInfo {\n                       call_site: attr.span,\n@@ -155,16 +155,20 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n \n // eval $e with a new exts frame:\n macro_rules! with_exts_frame (\n-    ($extsboxexpr:expr,$e:expr) =>\n+    ($extsboxexpr:expr,$macros_escape:expr,$e:expr) =>\n     ({let extsbox = $extsboxexpr;\n       let oldexts = *extsbox;\n       *extsbox = oldexts.push_frame();\n+      extsbox.insert(intern(special_block_name),\n+                     @BlockInfo(BlockInfo{macros_escape:$macros_escape,pending_renames:@mut ~[]}));\n       let result = $e;\n       *extsbox = oldexts;\n       result\n      })\n )\n \n+static special_block_name : &'static str = \" block\";\n+\n // When we enter a module, record it, for the sake of `module!`\n pub fn expand_item(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n@@ -182,14 +186,8 @@ pub fn expand_item(extsbox: @mut SyntaxEnv,\n           match it.node {\n               ast::item_mod(_) | ast::item_foreign_mod(_) => {\n                   cx.mod_push(it.ident);\n-                  let result =\n-                      // don't push a macro scope for macro_escape:\n-                      if contains_macro_escape(it.attrs) {\n-                      orig(it,fld)\n-                  } else {\n-                      // otherwise, push a scope:\n-                      with_exts_frame!(extsbox,orig(it,fld))\n-                  };\n+                  let macro_escape = contains_macro_escape(it.attrs);\n+                  let result = with_exts_frame!(extsbox,macro_escape,orig(it,fld));\n                   cx.mod_pop();\n                   result\n               }\n@@ -205,31 +203,6 @@ pub fn contains_macro_escape (attrs: &[ast::attribute]) -> bool {\n     attrs.any(|attr| \"macro_escape\" == *attr::get_attr_name(attr))\n }\n \n-// this macro disables (one layer of) macro\n-// scoping, to allow a block to add macro bindings\n-// to its parent env\n-macro_rules! without_macro_scoping(\n-    ($extsexpr:expr,$exp:expr) =>\n-    ({\n-        // only evaluate this once:\n-        let exts = $extsexpr;\n-        // capture the existing binding:\n-        let existingBlockBinding =\n-            match exts.find(&@~\" block\"){\n-                Some(binding) => binding,\n-                None => cx.bug(\"expected to find \\\" block\\\" binding\")\n-            };\n-        // this prevents the block from limiting the macros' scope:\n-        exts.insert(@~\" block\",@ScopeMacros(false));\n-        let result = $exp;\n-        // reset the block binding. Note that since the original\n-        // one may have been inherited, this procedure may wind\n-        // up introducing a block binding where one didn't exist\n-        // before.\n-        exts.insert(@~\" block\",existingBlockBinding);\n-        result\n-    }))\n-\n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n@@ -243,22 +216,24 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n         _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n \n-    let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-    let expanded = match (*extsbox).find(&extname) {\n+    let extname = pth.idents[0];\n+    let interner = get_ident_interner();\n+    let extnamestr = interner.get(extname);\n+    let expanded = match (*extsbox).find(&extname.repr) {\n         None => cx.span_fatal(pth.span,\n-                              fmt!(\"macro undefined: '%s!'\", *extname)),\n+                              fmt!(\"macro undefined: '%s!'\", *extnamestr)),\n \n         Some(@SE(NormalTT(ref expand))) => {\n             if it.ident != parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects no ident argument, \\\n-                                    given '%s'\", *extname,\n-                                   *cx.parse_sess().interner.get(it.ident)));\n+                                    given '%s'\", *extnamestr,\n+                                   *interner.get(it.ident)));\n             }\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n-                    name: copy *extname,\n+                    name: copy *extnamestr,\n                     span: expand.span\n                 }\n             }));\n@@ -268,36 +243,53 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             if it.ident == parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects an ident argument\",\n-                                   *extname));\n+                                   *extnamestr));\n             }\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n-                    name: copy *extname,\n+                    name: copy *extnamestr,\n                     span: expand.span\n                 }\n             }));\n             ((*expand).expander)(cx, it.span, it.ident, tts)\n         }\n         _ => cx.span_fatal(\n-            it.span, fmt!(\"%s! is not legal in item position\", *extname))\n+            it.span, fmt!(\"%s! is not legal in item position\", *extnamestr))\n     };\n \n     let maybe_it = match expanded {\n         MRItem(it) => fld.fold_item(it),\n         MRExpr(_) => cx.span_fatal(pth.span,\n                                     ~\"expr macro in item position: \"\n-                                    + *extname),\n+                                    + *extnamestr),\n         MRAny(_, item_maker, _) => item_maker().chain(|i| {fld.fold_item(i)}),\n         MRDef(ref mdef) => {\n-            extsbox.insert(@/*bad*/ copy mdef.name, @SE((*mdef).ext));\n+            insert_macro(*extsbox,intern(mdef.name), @SE((*mdef).ext));\n             None\n         }\n     };\n     cx.bt_pop();\n     return maybe_it;\n }\n \n+\n+// insert a macro into the innermost frame that doesn't have the\n+// macro_escape tag.\n+fn insert_macro(exts: SyntaxEnv, name: ast::Name, transformer: @Transformer) {\n+    let block_err_msg = \"special identifier ' block' was bound to a non-BlockInfo\";\n+    let is_non_escaping_block =\n+        |t : &@Transformer| -> bool{\n+        match t {\n+            &@BlockInfo(BlockInfo {macros_escape:false,_}) => true,\n+            &@BlockInfo(BlockInfo {_}) => false,\n+            _ => fail!(block_err_msg)\n+        }\n+    };\n+    exts.insert_into_frame(name,transformer,intern(special_block_name),\n+                           is_non_escaping_block)\n+}\n+\n // expand a stmt\n pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n@@ -323,16 +315,17 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             fmt!(\"expected macro name without module \\\n                   separators\"));\n     }\n-    let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-    let (fully_expanded, sp) = match (*extsbox).find(&extname) {\n+    let extname = pth.idents[0];\n+    let extnamestr = get_ident_interner().get(extname);\n+    let (fully_expanded, sp) = match (*extsbox).find(&extname.repr) {\n         None =>\n-            cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", *extname)),\n+            cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", *extnamestr)),\n \n         Some(@SE(NormalTT(\n             SyntaxExpanderTT{expander: exp, span: exp_sp}))) => {\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: sp,\n-                callee: NameAndSpan { name: copy *extname, span: exp_sp }\n+                callee: NameAndSpan { name: copy *extnamestr, span: exp_sp }\n             }));\n             let expanded = match exp(cx, mac.span, tts) {\n                 MRExpr(e) =>\n@@ -341,7 +334,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                 MRAny(_,_,stmt_mkr) => stmt_mkr(),\n                 _ => cx.span_fatal(\n                     pth.span,\n-                    fmt!(\"non-stmt macro in stmt pos: %s\", *extname))\n+                    fmt!(\"non-stmt macro in stmt pos: %s\", *extnamestr))\n             };\n \n             //keep going, outside-in\n@@ -362,7 +355,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n         _ => {\n             cx.span_fatal(pth.span,\n-                          fmt!(\"'%s' is not a tt-style macro\", *extname))\n+                          fmt!(\"'%s' is not a tt-style macro\", *extnamestr))\n         }\n     };\n \n@@ -382,19 +375,8 @@ pub fn expand_block(extsbox: @mut SyntaxEnv,\n                     fld: @ast_fold,\n                     orig: @fn(&blk_, span, @ast_fold) -> (blk_, span))\n                  -> (blk_, span) {\n-    match (*extsbox).find(&@~\" block\") {\n-        // no scope limit on macros in this block, no need\n-        // to push an exts frame:\n-        Some(@ScopeMacros(false)) => {\n-            orig (blk,sp,fld)\n-        },\n-        // this block should limit the scope of its macros:\n-        Some(@ScopeMacros(true)) => {\n-            // see note below about treatment of exts table\n-            with_exts_frame!(extsbox,orig(blk,sp,fld))\n-        },\n-        _ => cx.span_bug(sp, \"expected ScopeMacros binding for \\\" block\\\"\")\n-    }\n+    // see note below about treatment of exts table\n+    with_exts_frame!(extsbox,false,orig(blk,sp,fld))\n }\n \n // given a mutable list of renames, return a tree-folder that applies those"}, {"sha": "8306b0ff1a99e1596e518c499d6113c95f5798bf", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d7638f9dba5cef5c4db7b9008196ede4450d8521/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7638f9dba5cef5c4db7b9008196ede4450d8521/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=d7638f9dba5cef5c4db7b9008196ede4450d8521", "patch": "@@ -351,6 +351,7 @@ mod test {\n     use codemap::{span, BytePos, spanned};\n     use opt_vec;\n     use ast;\n+    use ast_util::new_ident;\n     use abi;\n     use parse::parser::Parser;\n     use parse::token::intern;\n@@ -377,17 +378,22 @@ mod test {\n         span{lo:BytePos(a),hi:BytePos(b),expn_info:None}\n     }\n \n+    // compose new_ident and intern:\n+    fn intern_ident(str : &str) -> ast::ident {\n+        new_ident(intern(str))\n+    }\n+\n     // convert a vector of uints to a vector of ast::idents\n     fn ints_to_idents(ids: ~[~str]) -> ~[ast::ident] {\n-        ids.map(|u| intern(*u))\n+        ids.map(|u| intern_ident(*u))\n     }\n \n     #[test] fn path_exprs_1 () {\n         assert_eq!(string_to_expr(@~\"a\"),\n                    @ast::expr{id:1,\n                               node:ast::expr_path(@ast::Path {span:sp(0,1),\n                                                               global:false,\n-                                                              idents:~[intern(\"a\")],\n+                                                              idents:~[intern_ident(\"a\")],\n                                                               rp:None,\n                                                               types:~[]}),\n                               span:sp(0,1)})\n@@ -449,7 +455,7 @@ mod test {\n                                                   node:ast::expr_path(\n                                                       @ast::Path{span:sp(7,8),\n                                                                  global:false,\n-                                                                 idents:~[intern(\"d\")],\n+                                                                 idents:~[intern_ident(\"d\")],\n                                                                  rp:None,\n                                                                  types:~[]\n                                                                 }),\n@@ -466,7 +472,7 @@ mod test {\n                                @ast::Path{\n                                    span:sp(0,1),\n                                    global:false,\n-                                   idents:~[intern(\"b\")],\n+                                   idents:~[intern_ident(\"b\")],\n                                    rp:None,\n                                    types: ~[]}),\n                            span: sp(0,1)},\n@@ -487,7 +493,7 @@ mod test {\n                                                   @ast::Path{\n                                                       span:sp(0,1),\n                                                       global:false,\n-                                                      idents:~[intern(\"b\")],\n+                                                      idents:~[intern_ident(\"b\")],\n                                                       rp: None,\n                                                       types: ~[]},\n                                                   None // no idea\n@@ -506,7 +512,7 @@ mod test {\n                                         span:sp(4,4), // this is bizarre...\n                                         // check this in the original parser?\n                                         global:false,\n-                                        idents:~[intern(\"int\")],\n+                                        idents:~[intern_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n                                                        2),\n@@ -516,7 +522,7 @@ mod test {\n                                                            @ast::Path{\n                                                                span:sp(0,1),\n                                                                global:false,\n-                                                               idents:~[intern(\"b\")],\n+                                                               idents:~[intern_ident(\"b\")],\n                                                                rp: None,\n                                                                types: ~[]},\n                                                            None // no idea\n@@ -532,7 +538,7 @@ mod test {\n         // assignment order of the node_ids.\n         assert_eq!(string_to_item(@~\"fn a (b : int) { b; }\"),\n                   Some(\n-                      @ast::item{ident:intern(\"a\"),\n+                      @ast::item{ident:intern_ident(\"a\"),\n                             attrs:~[],\n                             id: 9, // fixme\n                             node: ast::item_fn(ast::fn_decl{\n@@ -542,7 +548,7 @@ mod test {\n                                                 node: ast::ty_path(@ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n-                                        idents:~[intern(\"int\")],\n+                                        idents:~[intern_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n                                                        2),\n@@ -553,7 +559,7 @@ mod test {\n                                                        @ast::Path{\n                                                            span:sp(6,7),\n                                                            global:false,\n-                                                           idents:~[intern(\"b\")],\n+                                                           idents:~[intern_ident(\"b\")],\n                                                            rp: None,\n                                                            types: ~[]},\n                                                        None // no idea\n@@ -583,7 +589,7 @@ mod test {\n                                                         @ast::Path{\n                                                             span:sp(17,18),\n                                                             global:false,\n-                                                            idents:~[intern(\"b\")],\n+                                                            idents:~[intern_ident(\"b\")],\n                                                             rp:None,\n                                                             types: ~[]}),\n                                                     span: sp(17,18)},"}, {"sha": "4635db0e10f3b02e0bafa3c30ffd886126a299dc", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d7638f9dba5cef5c4db7b9008196ede4450d8521/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7638f9dba5cef5c4db7b9008196ede4450d8521/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d7638f9dba5cef5c4db7b9008196ede4450d8521", "patch": "@@ -2628,6 +2628,13 @@ impl Parser {\n             // to the macro clause of parse_item_or_view_item. This\n             // could use some cleanup, it appears to me.\n \n+            // whoops! I now have a guess: I'm guessing the \"parens-only\"\n+            // rule here is deliberate, to allow macro users to use parens\n+            // for things that should be parsed as stmt_mac, and braces\n+            // for things that should expand into items. Tricky, and\n+            // somewhat awkward... and probably undocumented. Of course,\n+            // I could just be wrong.\n+\n             check_expected_item(self, item_attrs);\n \n             // Potential trouble: if we allow macros with paths instead of"}, {"sha": "cd274817a16a99b332ffd81346f50fb2d0db5960", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d7638f9dba5cef5c4db7b9008196ede4450d8521/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d7638f9dba5cef5c4db7b9008196ede4450d8521/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d7638f9dba5cef5c4db7b9008196ede4450d8521", "patch": "@@ -394,6 +394,8 @@ pub struct ident_interner {\n }\n \n impl ident_interner {\n+    // I'm torn as to whether these should produce idents or\n+    // just uints.\n     pub fn intern(&self, val: &str) -> ast::ident {\n         ast::ident { repr: self.interner.intern(val), ctxt: 0 }\n     }\n@@ -530,9 +532,9 @@ pub fn mk_fake_ident_interner() -> @ident_interner {\n }\n \n // maps a string to its interned representation\n-pub fn intern(str : &str) -> ast::ident {\n+pub fn intern(str : &str) -> uint {\n     let interner = get_ident_interner();\n-    interner.intern(str)\n+    interner.intern(str).repr\n }\n \n /**"}]}