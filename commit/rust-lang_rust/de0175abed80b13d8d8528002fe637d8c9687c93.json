{"sha": "de0175abed80b13d8d8528002fe637d8c9687c93", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMDE3NWFiZWQ4MGIxM2Q4ZDg1MjgwMDJmZTYzN2Q4Yzk2ODdjOTM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-12T22:09:50Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-12T22:10:40Z"}, "message": "rustc: Switch to indices for type parameters", "tree": {"sha": "88fe8e28d5cc64c174233c0986ddc4734f2280e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88fe8e28d5cc64c174233c0986ddc4734f2280e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de0175abed80b13d8d8528002fe637d8c9687c93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de0175abed80b13d8d8528002fe637d8c9687c93", "html_url": "https://github.com/rust-lang/rust/commit/de0175abed80b13d8d8528002fe637d8c9687c93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de0175abed80b13d8d8528002fe637d8c9687c93/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e11e8754dee0332874ab2a15960e123adffc2bab", "url": "https://api.github.com/repos/rust-lang/rust/commits/e11e8754dee0332874ab2a15960e123adffc2bab", "html_url": "https://github.com/rust-lang/rust/commit/e11e8754dee0332874ab2a15960e123adffc2bab"}], "stats": {"total": 637, "additions": 255, "deletions": 382}, "files": [{"sha": "dfc69695c269e9c858b29735aff1950ebb1730f1", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=de0175abed80b13d8d8528002fe637d8c9687c93", "patch": "@@ -17,7 +17,7 @@ type crate_num = int;\n type def_num = int;\n type def_id = tup(crate_num, def_num);\n \n-type ty_param = rec(ident ident, def_id id);\n+type ty_param = ident;\n \n // Annotations added during successive passes.\n tag ann {\n@@ -39,7 +39,7 @@ tag def {\n     def_upvar(def_id);\n     def_variant(def_id /* tag */, def_id /* variant */);\n     def_ty(def_id);\n-    def_ty_arg(def_id);\n+    def_ty_arg(uint);\n     def_binding(def_id);\n     def_use(def_id);\n     def_native_ty(def_id);\n@@ -59,7 +59,7 @@ fn def_id_of_def(def d) -> def_id {\n         case (def_upvar(?id)) { ret id; }\n         case (def_variant(_, ?id)) { ret id; }\n         case (def_ty(?id)) { ret id; }\n-        case (def_ty_arg(?id)) { ret id; }\n+        case (def_ty_arg(_)) { fail; }\n         case (def_binding(?id)) { ret id; }\n         case (def_use(?id)) { ret id; }\n         case (def_native_ty(?id)) { ret id; }"}, {"sha": "b70153803c86b54902bcd776d5fa3cf44e4a42a0", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=de0175abed80b13d8d8528002fe637d8c9687c93", "patch": "@@ -131,7 +131,7 @@ impure fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n             st.pos = st.pos + 1u;\n             ret ty.ty_tag(def, params);\n         }\n-        case ('p') {ret ty.ty_param(parse_def(st, sd));}\n+        case ('p') {ret ty.ty_param(parse_int(st) as uint);}\n         case ('@') {ret ty.ty_box(parse_mt(st, sd));}\n         case ('V') {ret ty.ty_vec(parse_mt(st, sd));}\n         case ('P') {ret ty.ty_port(parse_ty(st, sd));}\n@@ -351,14 +351,13 @@ fn item_type(&ebml.doc item, int this_cnum) -> @ty.t {\n     ret parse_ty_str(s, bind parse_external_def_id(this_cnum, _));\n }\n \n-fn item_ty_params(&ebml.doc item, int this_cnum) -> vec[ast.def_id] {\n-    let vec[ast.def_id] params = vec();\n-    auto tp = metadata.tag_items_data_item_ty_param;\n+fn item_ty_param_count(&ebml.doc item, int this_cnum) -> uint {\n+    let uint ty_param_count = 0u;\n+    auto tp = metadata.tag_items_data_item_ty_param_count;\n     for each (ebml.doc p in ebml.tagged_docs(item, tp)) {\n-        auto ext = parse_def_id(ebml.doc_data(p));\n-        _vec.push[ast.def_id](params, tup(this_cnum, ext._1));\n+        ty_param_count = ebml.vint_at(ebml.doc_data(p), 0u)._0;\n     }\n-    ret params;\n+    ret ty_param_count;\n }\n \n fn tag_variant_ids(&ebml.doc item, int this_cnum) -> vec[ast.def_id] {\n@@ -511,23 +510,23 @@ fn lookup_def(session.session sess, int cnum, vec[ast.ident] path)\n     ret some[ast.def](def);\n }\n \n-fn get_type(session.session sess, ast.def_id def) -> ty.ty_params_opt_and_ty {\n+fn get_type(session.session sess, ast.def_id def)\n+        -> ty.ty_param_count_and_ty {\n     auto external_crate_id = def._0;\n     auto data = sess.get_external_crate(external_crate_id);\n     auto item = lookup_item(def._1, data);\n     auto t = item_type(item, external_crate_id);\n \n-    auto tps_opt;\n+    auto tp_count;\n     auto kind_ch = item_kind(item);\n     auto has_ty_params = kind_has_type_params(kind_ch);\n     if (has_ty_params) {\n-        auto tps = item_ty_params(item, external_crate_id);\n-        tps_opt = some[vec[ast.def_id]](tps);\n+        tp_count = item_ty_param_count(item, external_crate_id);\n     } else {\n-        tps_opt = none[vec[ast.def_id]];\n+        tp_count = 0u;\n     }\n \n-    ret tup(tps_opt, t);\n+    ret tup(tp_count, t);\n }\n \n fn get_symbol(session.session sess, ast.def_id def) -> str {"}, {"sha": "85badb1e7099cf07805e94923665dbb036f40ad1", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=de0175abed80b13d8d8528002fe637d8c9687c93", "patch": "@@ -1740,8 +1740,7 @@ impure fn parse_block(parser p) -> ast.block {\n }\n \n impure fn parse_ty_param(parser p) -> ast.ty_param {\n-    auto ident = parse_ident(p);\n-    ret rec(ident=ident, id=p.next_def_id());\n+    ret parse_ident(p);\n }\n \n impure fn parse_ty_params(parser p) -> vec[ast.ty_param] {"}, {"sha": "31aec74d87292e11c946cd5cb489ab8bb13aaab6", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=de0175abed80b13d8d8528002fe637d8c9687c93", "patch": "@@ -29,7 +29,7 @@ const uint tag_def_id = 0x07u;\n const uint tag_items_data = 0x08u;\n const uint tag_items_data_item = 0x09u;\n const uint tag_items_data_item_kind = 0x0au;\n-const uint tag_items_data_item_ty_param = 0x0bu;\n+const uint tag_items_data_item_ty_param_count = 0x0bu;\n const uint tag_items_data_item_type = 0x0cu;\n const uint tag_items_data_item_symbol = 0x0du;\n const uint tag_items_data_item_variant = 0x0eu;\n@@ -134,7 +134,7 @@ fn sty_str(ty.sty st, def_str ds) -> str {\n         }\n         case (ty.ty_var(?id)) {ret \"X\" + common.istr(id);}\n         case (ty.ty_native) {ret \"E\";}\n-        case (ty.ty_param(?def)) {ret \"p\" + ds(def) + \"|\";}\n+        case (ty.ty_param(?id)) {ret \"p\" + common.uistr(id);}\n         case (ty.ty_type) {ret \"Y\";}\n     }\n }\n@@ -310,13 +310,10 @@ fn def_to_str(ast.def_id did) -> str {\n     ret #fmt(\"%d:%d\", did._0, did._1);\n }\n \n-// TODO: We need to encode the \"crate numbers\" somewhere for diamond imports.\n-fn encode_type_params(&ebml.writer ebml_w, vec[ast.ty_param] tps) {\n-    for (ast.ty_param tp in tps) {\n-        ebml.start_tag(ebml_w, tag_items_data_item_ty_param);\n-        ebml_w.writer.write(_str.bytes(def_to_str(tp.id)));\n-        ebml.end_tag(ebml_w);\n-    }\n+fn encode_type_param_count(&ebml.writer ebml_w, vec[ast.ty_param] tps) {\n+    ebml.start_tag(ebml_w, tag_items_data_item_ty_param_count);\n+    ebml.write_vint(ebml_w.writer, _vec.len[ast.ty_param](tps));\n+    ebml.end_tag(ebml_w);\n }\n \n fn encode_variant_id(&ebml.writer ebml_w, ast.def_id vid) {\n@@ -374,7 +371,7 @@ fn encode_tag_variant_info(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             encode_symbol(cx, ebml_w, variant.node.id);\n         }\n         encode_discriminant(cx, ebml_w, variant.node.id);\n-        encode_type_params(ebml_w, ty_params);\n+        encode_type_param_count(ebml_w, ty_params);\n         ebml.end_tag(ebml_w);\n     }\n }\n@@ -394,7 +391,7 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'f' as u8);\n-            encode_type_params(ebml_w, tps);\n+            encode_type_param_count(ebml_w, tps);\n             encode_type(ebml_w, trans.node_ann_type(cx, ann));\n             encode_symbol(cx, ebml_w, did);\n             ebml.end_tag(ebml_w);\n@@ -415,15 +412,15 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'y' as u8);\n-            encode_type_params(ebml_w, tps);\n+            encode_type_param_count(ebml_w, tps);\n             encode_type(ebml_w, trans.node_ann_type(cx, ann));\n             ebml.end_tag(ebml_w);\n         }\n         case (ast.item_tag(?id, ?variants, ?tps, ?did, ?ann)) {\n             ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 't' as u8);\n-            encode_type_params(ebml_w, tps);\n+            encode_type_param_count(ebml_w, tps);\n             encode_type(ebml_w, trans.node_ann_type(cx, ann));\n             for (ast.variant v in variants) {\n                 encode_variant_id(ebml_w, v.node.id);\n@@ -436,7 +433,7 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, odid.ctor);\n             encode_kind(ebml_w, 'o' as u8);\n-            encode_type_params(ebml_w, tps);\n+            encode_type_param_count(ebml_w, tps);\n             auto fn_ty = trans.node_ann_type(cx, ann);\n             encode_type(ebml_w, fn_ty);\n             encode_symbol(cx, ebml_w, odid.ctor);\n@@ -445,7 +442,7 @@ fn encode_info_for_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n             ebml.start_tag(ebml_w, tag_items_data_item);\n             encode_def_id(ebml_w, odid.ty);\n             encode_kind(ebml_w, 'y' as u8);\n-            encode_type_params(ebml_w, tps);\n+            encode_type_param_count(ebml_w, tps);\n             encode_type(ebml_w, ty.ty_fn_ret(fn_ty));\n             ebml.end_tag(ebml_w);\n         }\n@@ -464,7 +461,7 @@ fn encode_info_for_native_item(@trans.crate_ctxt cx, &ebml.writer ebml_w,\n         case (ast.native_item_fn(_, _, _, ?tps, ?did, ?ann)) {\n             encode_def_id(ebml_w, did);\n             encode_kind(ebml_w, 'F' as u8);\n-            encode_type_params(ebml_w, tps);\n+            encode_type_param_count(ebml_w, tps);\n             encode_type(ebml_w, trans.node_ann_type(cx, ann));\n             encode_symbol(cx, ebml_w, did);\n         }"}, {"sha": "8af9455a29ac727c66433d03cf2d7356d87f6779", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=de0175abed80b13d8d8528002fe637d8c9687c93", "patch": "@@ -398,19 +398,22 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n         }\n     }\n \n-    fn handle_fn_decl(ast.ident i, &ast.fn_decl decl,\n+    fn handle_fn_decl(ast.ident identifier, &ast.fn_decl decl,\n                       &vec[ast.ty_param] ty_params) -> option.t[def_wrap] {\n         for (ast.arg a in decl.inputs) {\n-            if (_str.eq(a.ident, i)) {\n+            if (_str.eq(a.ident, identifier)) {\n                 auto t = ast.def_arg(a.id);\n                 ret some(def_wrap_other(t));\n             }\n         }\n+\n+        auto i = 0u;\n         for (ast.ty_param tp in ty_params) {\n-            if (_str.eq(tp.ident, i)) {\n-                auto t = ast.def_ty_arg(tp.id);\n+            if (_str.eq(tp, identifier)) {\n+                auto t = ast.def_ty_arg(i);\n                 ret some(def_wrap_other(t));\n             }\n+            i += 1u;\n         }\n         ret none[def_wrap];\n     }\n@@ -450,53 +453,60 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n         }\n     }\n \n-    fn in_scope(&session.session sess, ast.ident i, &scope s, namespace ns)\n-            -> option.t[def_wrap] {\n+    fn in_scope(&session.session sess, ast.ident identifier, &scope s,\n+            namespace ns) -> option.t[def_wrap] {\n         alt (s) {\n \n             case (scope_crate(?c)) {\n-                ret check_mod(i, c.node.module, ns);\n+                ret check_mod(identifier, c.node.module, ns);\n             }\n \n             case (scope_item(?it)) {\n                 alt (it.node) {\n                     case (ast.item_fn(_, ?f, ?ty_params, _, _)) {\n-                        ret handle_fn_decl(i, f.decl, ty_params);\n+                        ret handle_fn_decl(identifier, f.decl, ty_params);\n                     }\n                     case (ast.item_obj(_, ?ob, ?ty_params, _, _)) {\n                         for (ast.obj_field f in ob.fields) {\n-                            if (_str.eq(f.ident, i)) {\n+                            if (_str.eq(f.ident, identifier)) {\n                                 auto t = ast.def_obj_field(f.id);\n                                 ret some(def_wrap_other(t));\n                             }\n                         }\n+\n+                        auto i = 0u;\n                         for (ast.ty_param tp in ty_params) {\n-                            if (_str.eq(tp.ident, i)) {\n-                                auto t = ast.def_ty_arg(tp.id);\n+                            if (_str.eq(tp, identifier)) {\n+                                auto t = ast.def_ty_arg(i);\n                                 ret some(def_wrap_other(t));\n                             }\n+                            i += 1u;\n                         }\n                     }\n                     case (ast.item_tag(_,?variants,?ty_params,?tag_id,_)) {\n+                        auto i = 0u;\n                         for (ast.ty_param tp in ty_params) {\n-                            if (_str.eq(tp.ident, i)) {\n-                                auto t = ast.def_ty_arg(tp.id);\n+                            if (_str.eq(tp, identifier)) {\n+                                auto t = ast.def_ty_arg(i);\n                                 ret some(def_wrap_other(t));\n                             }\n+                            i += 1u;\n                         }\n                     }\n                     case (ast.item_mod(_, ?m, _)) {\n-                        ret check_mod(i, m, ns);\n+                        ret check_mod(identifier, m, ns);\n                     }\n                     case (ast.item_native_mod(_, ?m, _)) {\n-                        ret check_native_mod(i, m);\n+                        ret check_native_mod(identifier, m);\n                     }\n                     case (ast.item_ty(_, _, ?ty_params, _, _)) {\n+                        auto i = 0u;\n                         for (ast.ty_param tp in ty_params) {\n-                            if (_str.eq(tp.ident, i)) {\n-                                auto t = ast.def_ty_arg(tp.id);\n+                            if (_str.eq(tp, identifier)) {\n+                                auto t = ast.def_ty_arg(i);\n                                 ret some(def_wrap_other(t));\n                             }\n+                            i += 1u;\n                         }\n                     }\n                     case (_) { /* fall through */ }\n@@ -506,7 +516,7 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n             case (scope_native_item(?it)) {\n                 alt (it.node) {\n                     case (ast.native_item_fn(_, _, ?decl, ?ty_params, _, _)) {\n-                        ret handle_fn_decl(i, decl, ty_params);\n+                        ret handle_fn_decl(identifier, decl, ty_params);\n                     }\n                 }\n             }\n@@ -518,7 +528,7 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n             case (scope_loop(?d)) {\n                 alt (d.node) {\n                     case (ast.decl_local(?local)) {\n-                        if (_str.eq(local.ident, i)) {\n+                        if (_str.eq(local.ident, identifier)) {\n                             auto lc = ast.def_local(local.id);\n                             ret some(def_wrap_other(lc));\n                         }\n@@ -527,11 +537,11 @@ fn lookup_name_wrapped(&env e, ast.ident i, namespace ns)\n             }\n \n             case (scope_block(?b)) {\n-                ret check_block(i, b.node, ns);\n+                ret check_block(identifier, b.node, ns);\n             }\n \n             case (scope_arm(?a)) {\n-                alt (a.index.find(i)) {\n+                alt (a.index.find(identifier)) {\n                     case (some[ast.def_id](?did)) {\n                         auto t = ast.def_binding(did);\n                         ret some[def_wrap](def_wrap_other(t));"}, {"sha": "6c4620d247606ef427e80b1ecb4a74e21477feb1", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 52, "deletions": 64, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=de0175abed80b13d8d8528002fe637d8c9687c93", "patch": "@@ -128,7 +128,8 @@ state type fn_ctxt = rec(ValueRef llfn,\n                          hashmap[ast.def_id, ValueRef] llobjfields,\n                          hashmap[ast.def_id, ValueRef] lllocals,\n                          hashmap[ast.def_id, ValueRef] llupvars,\n-                         hashmap[ast.def_id, ValueRef] lltydescs,\n+                         // FIXME: this should probably be just vec[ValueRef]\n+                         hashmap[uint, ValueRef] lltydescs,\n                          @crate_ctxt ccx);\n \n tag cleanup {\n@@ -770,14 +771,11 @@ fn type_of_arg(@crate_ctxt cx, &ty.arg arg) -> TypeRef {\n     ret typ;\n }\n \n-fn type_of_ty_params_opt_and_ty(@crate_ctxt ccx, ty.ty_params_opt_and_ty tpt)\n-        -> TypeRef {\n+fn type_of_ty_param_count_and_ty(@crate_ctxt ccx,\n+                                 ty.ty_param_count_and_ty tpt) -> TypeRef {\n     alt (tpt._1.struct) {\n         case (ty.ty_fn(?proto, ?inputs, ?output)) {\n-            auto ty_params = option.get[vec[ast.def_id]](tpt._0);\n-            auto ty_param_count = _vec.len[ast.def_id](ty_params);\n-            auto llfnty = type_of_fn(ccx, proto, inputs, output,\n-                                     ty_param_count);\n+            auto llfnty = type_of_fn(ccx, proto, inputs, output, tpt._0);\n             ret T_fn_pair(ccx.tn, llfnty);\n         }\n         case (_) {\n@@ -1121,9 +1119,6 @@ fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n         }\n     }\n \n-    // Pull the type parameters out of the corresponding tag item.\n-    let vec[ast.def_id] ty_params = tag_ty_params(cx, tid);\n-\n     // Compute max(variant sizes).\n     auto max_size = 0u;\n     auto variants = tag_variants(cx, tid);\n@@ -1149,7 +1144,7 @@ fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n         auto tup_ty = ty.plain_tup_ty(args);\n \n         // Perform any type parameter substitutions.\n-        tup_ty = ty.substitute_ty_params(ty_params, subtys, tup_ty);\n+        tup_ty = ty.substitute_type_params(subtys, tup_ty);\n \n         // Here we possibly do a recursive call.\n         auto this_size = llsize_of_real(cx, type_of(cx, tup_ty));\n@@ -1215,14 +1210,13 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n             let ValueRef max_size = alloca(bcx, T_int());\n             bcx.build.Store(C_int(0), max_size);\n \n-            auto ty_params = tag_ty_params(bcx.fcx.ccx, tid);\n             auto variants = tag_variants(bcx.fcx.ccx, tid);\n             for (variant_info variant in variants) {\n                 // Perform type substitution on the raw argument types.\n                 let vec[@ty.t] raw_tys = variant.args;\n                 let vec[@ty.t] tys = vec();\n                 for (@ty.t raw_ty in raw_tys) {\n-                    auto t = ty.substitute_ty_params(ty_params, tps, raw_ty);\n+                    auto t = ty.substitute_type_params(tps, raw_ty);\n                     tys += vec(t);\n                 }\n \n@@ -1387,7 +1381,6 @@ fn GEP_tag(@block_ctxt cx,\n            vec[@ty.t] ty_substs,\n            int ix)\n         -> result {\n-    auto ty_params = tag_ty_params(cx.fcx.ccx, tag_id);\n     auto variant = tag_variant_with_id(cx.fcx.ccx, tag_id, variant_id);\n \n     // Synthesize a tuple type so that GEP_tup_like() can work its magic.\n@@ -1397,7 +1390,7 @@ fn GEP_tag(@block_ctxt cx,\n     auto i = 0;\n     let vec[@ty.t] true_arg_tys = vec();\n     for (@ty.t aty in arg_tys) {\n-        auto arg_ty = ty.substitute_ty_params(ty_params, ty_substs, aty);\n+        auto arg_ty = ty.substitute_type_params(ty_substs, aty);\n         true_arg_tys += vec(arg_ty);\n         if (i == ix) {\n             elem_ty = arg_ty;\n@@ -1466,23 +1459,23 @@ fn field_of_tydesc(@block_ctxt cx, @ty.t t, int field) -> result {\n }\n \n // Given a type containing ty params, build a vector containing a ValueRef for\n-// each of the ty params it uses (from the current frame), as well as a vec\n-// containing a def_id for each such param. This is used solely for\n+// each of the ty params it uses (from the current frame) and a vector of the\n+// indices of the ty params present in the type. This is used solely for\n // constructing derived tydescs.\n-fn linearize_ty_params(@block_ctxt cx, @ty.t t)\n-    -> tup(vec[ast.def_id], vec[ValueRef]) {\n+fn linearize_ty_params(@block_ctxt cx, @ty.t t) ->\n+        tup(vec[uint], vec[ValueRef]) {\n     let vec[ValueRef] param_vals = vec();\n-    let vec[ast.def_id] param_defs = vec();\n+    let vec[uint] param_defs = vec();\n     type rr = rec(@block_ctxt cx,\n                   mutable vec[ValueRef] vals,\n-                  mutable vec[ast.def_id] defs);\n+                  mutable vec[uint] defs);\n \n     state obj folder(@rr r) {\n         fn fold_simple_ty(@ty.t t) -> @ty.t {\n             alt(t.struct) {\n                 case (ty.ty_param(?pid)) {\n                     let bool seen = false;\n-                    for (ast.def_id d in r.defs) {\n+                    for (uint d in r.defs) {\n                         if (d == pid) {\n                             seen = true;\n                         }\n@@ -1511,11 +1504,11 @@ fn linearize_ty_params(@block_ctxt cx, @ty.t t)\n fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n     // Is the supplied type a type param? If so, return the passed-in tydesc.\n     alt (ty.type_param(t)) {\n-        case (some[ast.def_id](?id)) {\n+        case (some[uint](?id)) {\n             check (cx.fcx.lltydescs.contains_key(id));\n             ret res(cx, cx.fcx.lltydescs.get(id));\n         }\n-        case (none[ast.def_id])      { /* fall through */ }\n+        case (none[uint])      { /* fall through */ }\n     }\n \n     // Does it contain a type param? If so, generate a derived tydesc.\n@@ -1524,7 +1517,7 @@ fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n     if (ty.count_ty_params(t) > 0u) {\n         auto tys = linearize_ty_params(cx, t);\n \n-        check (n_params == _vec.len[ast.def_id](tys._0));\n+        check (n_params == _vec.len[uint](tys._0));\n         check (n_params == _vec.len[ValueRef](tys._1));\n \n         if (!cx.fcx.ccx.tydescs.contains_key(t)) {\n@@ -1566,9 +1559,9 @@ fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n \n     // Otherwise, generate a tydesc if necessary, and return it.\n     if (!cx.fcx.ccx.tydescs.contains_key(t)) {\n-        let vec[ast.def_id] defs = vec();\n+        let vec[uint] tps = vec();\n         declare_tydesc(cx.fcx.ccx, t);\n-        define_tydesc(cx.fcx.ccx, t, defs);\n+        define_tydesc(cx.fcx.ccx, t, tps);\n     }\n     ret res(cx, cx.fcx.ccx.tydescs.get(t).tydesc);\n }\n@@ -1624,16 +1617,14 @@ fn declare_tydesc(@crate_ctxt cx, @ty.t t) {\n }\n \n // declare_tydesc() above must have been called first.\n-fn define_tydesc(@crate_ctxt cx, @ty.t t, vec[ast.def_id] typaram_defs) {\n+fn define_tydesc(@crate_ctxt cx, @ty.t t, vec[uint] ty_params) {\n     auto info = cx.tydescs.get(t);\n     auto gvar = info.tydesc;\n \n     auto tg = make_take_glue;\n-    auto take_glue = make_generic_glue(cx, t, info.take_glue, tg,\n-                                       typaram_defs);\n+    auto take_glue = make_generic_glue(cx, t, info.take_glue, tg, ty_params);\n     auto dg = make_drop_glue;\n-    auto drop_glue = make_generic_glue(cx, t, info.drop_glue, dg,\n-                                       typaram_defs);\n+    auto drop_glue = make_generic_glue(cx, t, info.drop_glue, dg, ty_params);\n }\n \n fn declare_generic_glue(@crate_ctxt cx, @ty.t t, str name) -> ValueRef {\n@@ -1647,8 +1638,7 @@ fn declare_generic_glue(@crate_ctxt cx, @ty.t t, str name) -> ValueRef {\n }\n \n fn make_generic_glue(@crate_ctxt cx, @ty.t t, ValueRef llfn,\n-                     val_and_ty_fn helper,\n-                     vec[ast.def_id] typaram_defs) -> ValueRef {\n+                     val_and_ty_fn helper, vec[uint] ty_params) -> ValueRef {\n     auto fcx = new_fn_ctxt(cx, llfn);\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n@@ -1668,13 +1658,15 @@ fn make_generic_glue(@crate_ctxt cx, @ty.t t, ValueRef llfn,\n             llty = T_ptr(type_of(cx, t));\n         }\n \n+        auto ty_param_count = _vec.len[uint](ty_params);\n+\n         auto lltyparams = llvm.LLVMGetParam(llfn, 3u);\n-        auto p = 0;\n-        for (ast.def_id d in typaram_defs) {\n-            auto llparam = bcx.build.GEP(lltyparams, vec(C_int(p)));\n+        auto p = 0u;\n+        while (p < ty_param_count) {\n+            auto llparam = bcx.build.GEP(lltyparams, vec(C_int(p as int)));\n             llparam = bcx.build.Load(llparam);\n-            bcx.fcx.lltydescs.insert(d, llparam);\n-            p += 1;\n+            bcx.fcx.lltydescs.insert(ty_params.(p), llparam);\n+            p += 1u;\n         }\n \n         auto llrawptr = llvm.LLVMGetParam(llfn, 4u);\n@@ -1928,11 +1920,6 @@ fn decr_refcnt_and_if_zero(@block_ctxt cx,\n \n // Tag information\n \n-// Returns the type parameters of a tag.\n-fn tag_ty_params(@crate_ctxt cx, ast.def_id id) -> vec[ast.def_id] {\n-    ret ty.lookup_generic_item_type(cx.sess, cx.type_cache, id)._0;\n-}\n-\n type variant_info = rec(vec[@ty.t] args, @ty.t ctor_ty, ast.def_id id);\n \n // Returns information about the variants in a tag.\n@@ -2105,8 +2092,6 @@ fn iter_structural_ty_full(@block_ctxt cx,\n \n             auto next_cx = new_sub_block_ctxt(bcx, \"tag-iter-next\");\n \n-            auto ty_params = tag_ty_params(bcx.fcx.ccx, tid);\n-\n             auto i = 0u;\n             for (variant_info variant in variants) {\n                 auto variant_cx = new_sub_block_ctxt(bcx,\n@@ -2133,8 +2118,8 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                                 auto llfldp_b = rslt.val;\n                                 variant_cx = rslt.bcx;\n \n-                                auto ty_subst = ty.substitute_ty_params(\n-                                    ty_params, tps, a.ty);\n+                                auto ty_subst =\n+                                    ty.substitute_type_params(tps, a.ty);\n \n                                 auto llfld_a =\n                                     load_if_immediate(variant_cx,\n@@ -3642,16 +3627,16 @@ fn lval_val(@block_ctxt cx, ValueRef val) -> lval_result {\n }\n \n fn trans_external_path(@block_ctxt cx, ast.def_id did,\n-                       ty.ty_params_opt_and_ty tpt) -> lval_result {\n+                       ty.ty_param_count_and_ty tpt) -> lval_result {\n     auto ccx = cx.fcx.ccx;\n     auto name = creader.get_symbol(ccx.sess, did);\n     auto v = get_extern_const(ccx.externs, ccx.llmod,\n-                              name, type_of_ty_params_opt_and_ty(ccx, tpt));\n+                              name, type_of_ty_param_count_and_ty(ccx, tpt));\n     ret lval_val(cx, v);\n }\n \n fn lval_generic_fn(@block_ctxt cx,\n-                   ty.ty_params_and_ty tpt,\n+                   ty.ty_param_count_and_ty tpt,\n                    ast.def_id fn_id,\n                    &ast.ann ann)\n         -> lval_result {\n@@ -3662,12 +3647,11 @@ fn lval_generic_fn(@block_ctxt cx,\n         lv = lval_val(cx, cx.fcx.ccx.fn_pairs.get(fn_id));\n     } else {\n         // External reference.\n-        auto tpot = tup(some[vec[ast.def_id]](tpt._0), tpt._1);\n-        lv = trans_external_path(cx, fn_id, tpot);\n+        lv = trans_external_path(cx, fn_id, tpt);\n     }\n \n     auto monoty;\n-    auto tys;\n+    let vec[@ty.t] tys;\n     alt (ann) {\n         case (ast.ann_none) {\n             cx.fcx.ccx.sess.bug(\"no type annotation for path!\");\n@@ -3750,17 +3734,17 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                     ret lval_mem(cx, cx.fcx.llobjfields.get(did));\n                 }\n                 case (ast.def_fn(?did)) {\n-                    auto tyt = ty.lookup_generic_item_type(cx.fcx.ccx.sess,\n+                    auto tyt = ty.lookup_item_type(cx.fcx.ccx.sess,\n                         cx.fcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_obj(?did)) {\n-                    auto tyt = ty.lookup_generic_item_type(cx.fcx.ccx.sess,\n+                    auto tyt = ty.lookup_item_type(cx.fcx.ccx.sess,\n                         cx.fcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n                 case (ast.def_variant(?tid, ?vid)) {\n-                    auto v_tyt = ty.lookup_generic_item_type(cx.fcx.ccx.sess,\n+                    auto v_tyt = ty.lookup_item_type(cx.fcx.ccx.sess,\n                         cx.fcx.ccx.type_cache, vid);\n                     alt (v_tyt._1.struct) {\n                         case (ty.ty_fn(_, _, _)) {\n@@ -3801,7 +3785,7 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                     ret lval_mem(cx, cx.fcx.ccx.consts.get(did));\n                 }\n                 case (ast.def_native_fn(?did)) {\n-                    auto tyt = ty.lookup_generic_item_type(cx.fcx.ccx.sess,\n+                    auto tyt = ty.lookup_item_type(cx.fcx.ccx.sess,\n                         cx.fcx.ccx.type_cache, did);\n                     ret lval_generic_fn(cx, tyt, did, ann);\n                 }\n@@ -5500,7 +5484,7 @@ fn new_fn_ctxt(@crate_ctxt cx,\n     let hashmap[ast.def_id, ValueRef] llobjfields = new_def_hash[ValueRef]();\n     let hashmap[ast.def_id, ValueRef] lllocals = new_def_hash[ValueRef]();\n     let hashmap[ast.def_id, ValueRef] llupvars = new_def_hash[ValueRef]();\n-    let hashmap[ast.def_id, ValueRef] lltydescs = new_def_hash[ValueRef]();\n+    let hashmap[uint, ValueRef] lltydescs = common.new_uint_hash[ValueRef]();\n \n     let BasicBlockRef llallocas =\n         llvm.LLVMAppendBasicBlock(llfndecl, _str.buf(\"allocas\"));\n@@ -5541,11 +5525,13 @@ fn create_llargs_for_fn_args(&@fn_ctxt cx,\n             cx.llself = some[self_vt](rec(v = cx.llenv, t = tt._1));\n         }\n         case (none[tup(TypeRef, @ty.t)]) {\n+            auto i = 0u;\n             for (ast.ty_param tp in ty_params) {\n                 auto llarg = llvm.LLVMGetParam(cx.llfn, arg_n);\n                 check (llarg as int != 0);\n-                cx.lltydescs.insert(tp.id, llarg);\n+                cx.lltydescs.insert(i, llarg);\n                 arg_n += 1u;\n+                i += 1u;\n             }\n         }\n     }\n@@ -5695,7 +5681,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n                                                vec(C_int(0),\n                                                    C_int(i)));\n         lltyparam = bcx.build.Load(lltyparam);\n-        fcx.lltydescs.insert(p.id, lltyparam);\n+        fcx.lltydescs.insert(i as uint, lltyparam);\n         i += 1;\n     }\n \n@@ -5889,7 +5875,7 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n         bcx = body_typarams.bcx;\n         let int i = 0;\n         for (ast.ty_param tp in ty_params) {\n-            auto typaram = bcx.fcx.lltydescs.get(tp.id);\n+            auto typaram = bcx.fcx.lltydescs.get(i as uint);\n             auto capture = GEP_tup_like(bcx, typarams_ty, body_typarams.val,\n                                         vec(0, i));\n             bcx = capture.bcx;\n@@ -5951,8 +5937,10 @@ fn trans_tag_variant(@crate_ctxt cx, ast.def_id tag_id,\n                               fn_args, ty_params);\n \n     let vec[@ty.t] ty_param_substs = vec();\n+    i = 0u;\n     for (ast.ty_param tp in ty_params) {\n-        ty_param_substs += vec(plain_ty(ty.ty_param(tp.id)));\n+        ty_param_substs += vec(plain_ty(ty.ty_param(i)));\n+        i += 1u;\n     }\n \n     auto arg_tys = arg_tys_of_fn(variant.node.ann);\n@@ -6905,7 +6893,7 @@ fn trans_vec_append_glue(@crate_ctxt cx) {\n                     llobjfields=new_def_hash[ValueRef](),\n                     lllocals=new_def_hash[ValueRef](),\n                     llupvars=new_def_hash[ValueRef](),\n-                    lltydescs=new_def_hash[ValueRef](),\n+                    lltydescs=common.new_uint_hash[ValueRef](),\n                     ccx=cx);\n \n     auto bcx = new_top_block_ctxt(fcx);"}, {"sha": "6adfd3b94e854b999b70f7d6ff791c2f03b92dcd", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 56, "deletions": 96, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=de0175abed80b13d8d8528002fe637d8c9687c93", "patch": "@@ -57,7 +57,7 @@ tag sty {\n     ty_obj(vec[method]);\n     ty_var(int);                                    // ephemeral type var\n     ty_local(ast.def_id);                           // type of a local var\n-    ty_param(ast.def_id);                           // fn/tag type param\n+    ty_param(uint);                                 // fn/tag type param\n     ty_type;\n     ty_native;\n     // TODO: ty_fn_arg(@t), for a possibly-aliased function argument\n@@ -68,10 +68,8 @@ tag sty {\n type unify_handler = obj {\n     fn resolve_local(ast.def_id id) -> @t;\n     fn record_local(ast.def_id id, @t ty);\n-    fn unify_expected_param(ast.def_id id, @t expected, @t actual)\n-        -> unify_result;\n-    fn unify_actual_param(ast.def_id id, @t expected, @t actual)\n-        -> unify_result;\n+    fn unify_expected_param(uint id, @t expected, @t actual) -> unify_result;\n+    fn unify_actual_param(uint id, @t expected, @t actual) -> unify_result;\n };\n \n tag type_err {\n@@ -94,8 +92,8 @@ tag unify_result {\n }\n \n \n-type ty_params_opt_and_ty = tup(option.t[vec[ast.def_id]], @ty.t);\n-type type_cache = hashmap[ast.def_id,ty_params_opt_and_ty];\n+type ty_param_count_and_ty = tup(uint, @t);\n+type type_cache = hashmap[ast.def_id,ty_param_count_and_ty];\n \n \n // Stringification\n@@ -248,8 +246,7 @@ fn ty_to_str(&@t typ) -> str {\n         }\n \n         case (ty_param(?id)) {\n-            s += \"<P\" + util.common.istr(id._0) + \":\" +\n-                util.common.istr(id._1) + \">\";\n+            s += \"'\" + _str.unsafe_from_bytes(vec(('a' as u8) + (id as u8)));\n         }\n     }\n \n@@ -558,12 +555,12 @@ fn type_is_signed(@t ty) -> bool {\n     fail;\n }\n \n-fn type_param(@t ty) -> option.t[ast.def_id] {\n+fn type_param(@t ty) -> option.t[uint] {\n     alt (ty.struct) {\n-        case (ty_param(?id)) { ret some[ast.def_id](id); }\n-        case (_)             { /* fall through */        }\n+        case (ty_param(?id)) { ret some[uint](id); }\n+        case (_)             { /* fall through */  }\n     }\n-    ret none[ast.def_id];\n+    ret none[uint];\n }\n \n fn plain_ty(&sty st) -> @t {\n@@ -605,29 +602,32 @@ fn ann_to_type(&ast.ann ann) -> @t {\n     }\n }\n \n+// Returns the number of distinct type parameters in the given type.\n fn count_ty_params(@t ty) -> uint {\n-    state obj ty_param_counter(@mutable vec[ast.def_id] param_ids) {\n+    state obj ty_param_counter(@mutable vec[uint] param_indices) {\n         fn fold_simple_ty(@t ty) -> @t {\n             alt (ty.struct) {\n-                case (ty_param(?param_id)) {\n-                    for (ast.def_id other_param_id in *param_ids) {\n-                        if (param_id._0 == other_param_id._0 &&\n-                                param_id._1 == other_param_id._1) {\n-                            ret ty;\n+                case (ty_param(?param_idx)) {\n+                    auto seen = false;\n+                    for (uint other_param_idx in *param_indices) {\n+                        if (param_idx == other_param_idx) {\n+                            seen = true;\n                         }\n                     }\n-                    *param_ids += vec(param_id);\n+                    if (!seen) {\n+                        *param_indices += vec(param_idx);\n+                    }\n                 }\n                 case (_) { /* fall through */ }\n             }\n             ret ty;\n         }\n     }\n \n-    let vec[ast.def_id] param_ids_inner = vec();\n-    let @mutable vec[ast.def_id] param_ids = @mutable param_ids_inner;\n-    fold_ty(ty_param_counter(param_ids), ty);\n-    ret _vec.len[ast.def_id](*param_ids);\n+    let vec[uint] v = vec();    // FIXME: typechecker botch\n+    let @mutable vec[uint] param_indices = @mutable v;\n+    fold_ty(ty_param_counter(param_indices), ty);\n+    ret _vec.len[uint](*param_indices);\n }\n \n // Type accessors for substructures of types\n@@ -674,59 +674,50 @@ fn is_fn_ty(@t fty) -> bool {\n \n // Type accessors for AST nodes\n \n-// Given an item, returns the associated type as well as a list of the IDs of\n-// its type parameters.\n-type ty_params_and_ty = tup(vec[ast.def_id], @t);\n-fn native_item_ty(@ast.native_item it) -> ty_params_and_ty {\n-    auto ty_params;\n+// Given an item, returns the associated type as well as the number of type\n+// parameters it has.\n+fn native_item_ty(@ast.native_item it) -> ty_param_count_and_ty {\n+    auto ty_param_count;\n     auto result_ty;\n     alt (it.node) {\n         case (ast.native_item_fn(_, _, _, ?tps, _, ?ann)) {\n-            ty_params = tps;\n+            ty_param_count = _vec.len[ast.ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n     }\n-    let vec[ast.def_id] ty_param_ids = vec();\n-    for (ast.ty_param tp in ty_params) {\n-        ty_param_ids += vec(tp.id);\n-    }\n-    ret tup(ty_param_ids, result_ty);\n+    ret tup(ty_param_count, result_ty);\n }\n \n-fn item_ty(@ast.item it) -> ty_params_and_ty {\n-    let vec[ast.ty_param] ty_params;\n+fn item_ty(@ast.item it) -> ty_param_count_and_ty {\n+    auto ty_param_count;\n     auto result_ty;\n     alt (it.node) {\n         case (ast.item_const(_, _, _, _, ?ann)) {\n-            ty_params = vec();\n+            ty_param_count = 0u;\n             result_ty = ann_to_type(ann);\n         }\n         case (ast.item_fn(_, _, ?tps, _, ?ann)) {\n-            ty_params = tps;\n+            ty_param_count = _vec.len[ast.ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n         case (ast.item_mod(_, _, _)) {\n             fail;   // modules are typeless\n         }\n         case (ast.item_ty(_, _, ?tps, _, ?ann)) {\n-            ty_params = tps;\n+            ty_param_count = _vec.len[ast.ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n         case (ast.item_tag(_, _, ?tps, ?did, ?ann)) {\n-            ty_params = tps;\n+            ty_param_count = _vec.len[ast.ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n         case (ast.item_obj(_, _, ?tps, _, ?ann)) {\n-            ty_params = tps;\n+            ty_param_count = _vec.len[ast.ty_param](tps);\n             result_ty = ann_to_type(ann);\n         }\n     }\n \n-    let vec[ast.def_id] ty_param_ids = vec();\n-    for (ast.ty_param tp in ty_params) {\n-        ty_param_ids += vec(tp.id);\n-    }\n-    ret tup(ty_param_ids, result_ty);\n+    ret tup(ty_param_count, result_ty);\n }\n \n fn stmt_ty(@ast.stmt s) -> @t {\n@@ -1608,24 +1599,25 @@ fn type_err_to_str(&ty.type_err err) -> str {\n \n // Type parameter resolution, used in translation and typechecking\n \n-fn resolve_ty_params(ty_params_and_ty ty_params_and_polyty,\n+fn resolve_ty_params(ty_param_count_and_ty ty_params_and_polyty,\n                      @t monoty) -> vec[@t] {\n-    obj resolve_ty_params_handler(@hashmap[ast.def_id,@t] bindings) {\n+    // TODO: Use a vector, not a hashmap here.\n+    obj resolve_ty_params_handler(@hashmap[uint,@t] bindings) {\n         fn resolve_local(ast.def_id id) -> @t { log \"resolve local\"; fail; }\n         fn record_local(ast.def_id id, @t ty) { log \"record local\"; fail; }\n-        fn unify_expected_param(ast.def_id id, @t expected, @t actual)\n+        fn unify_expected_param(uint id, @t expected, @t actual)\n                 -> unify_result {\n             bindings.insert(id, actual);\n             ret ures_ok(actual);\n         }\n-        fn unify_actual_param(ast.def_id id, @t expected, @t actual)\n+        fn unify_actual_param(uint id, @t expected, @t actual)\n                 -> unify_result {\n             bindings.insert(id, expected);\n             ret ures_ok(expected);\n         }\n     }\n \n-    auto bindings = @new_def_hash[@t]();\n+    auto bindings = @common.new_uint_hash[@t]();\n     auto handler = resolve_ty_params_handler(bindings);\n \n     auto unify_res = unify(ty_params_and_polyty._1, monoty, handler);\n@@ -1639,56 +1631,32 @@ fn resolve_ty_params(ty_params_and_ty ty_params_and_polyty,\n     }\n \n     let vec[@t] result_tys = vec();\n-    auto ty_param_ids = ty_params_and_polyty._0;\n-    for (ast.def_id tp in ty_param_ids) {\n-        check (bindings.contains_key(tp));\n-        result_tys += vec(bindings.get(tp));\n+    auto ty_param_count = ty_params_and_polyty._0;\n+    auto i = 0u;\n+    while (i < ty_param_count) {\n+        check (bindings.contains_key(i));\n+        result_tys += vec(bindings.get(i));\n+        i += 1u;\n     }\n \n     ret result_tys;\n }\n \n // Performs type parameter replacement using the supplied mapping from\n // parameter IDs to types.\n-fn replace_type_params(@t typ, hashmap[ast.def_id,@t] param_map) -> @t {\n-    state obj param_replacer(hashmap[ast.def_id,@t] param_map) {\n+fn substitute_type_params(vec[@t] bindings, @t typ) -> @t {\n+    state obj param_replacer(vec[@t] bindings) {\n         fn fold_simple_ty(@t typ) -> @t {\n             alt (typ.struct) {\n-                case (ty_param(?param_def)) {\n-                    if (param_map.contains_key(param_def)) {\n-                        ret param_map.get(param_def);\n-                    } else {\n-                        ret typ;\n-                    }\n-                }\n-                case (_) {\n-                    ret typ;\n-                }\n+                case (ty_param(?param_index)) { ret bindings.(param_index); }\n+                case (_) { ret typ; }\n             }\n         }\n     }\n-    auto replacer = param_replacer(param_map);\n+    auto replacer = param_replacer(bindings);\n     ret fold_ty(replacer, typ);\n }\n \n-// Substitutes the type parameters specified by @ty_params with the\n-// corresponding types in @bound in the given type. The two vectors must have\n-// the same length.\n-fn substitute_ty_params(vec[ast.def_id] ty_params, vec[@t] bound, @t ty)\n-        -> @t {\n-    auto ty_param_len = _vec.len[ast.def_id](ty_params);\n-    check (ty_param_len == _vec.len[@t](bound));\n-\n-    auto bindings = common.new_def_hash[@t]();\n-    auto i = 0u;\n-    while (i < ty_param_len) {\n-        bindings.insert(ty_params.(i), bound.(i));\n-        i += 1u;\n-    }\n-\n-    ret replace_type_params(ty, bindings);\n-}\n-\n \n fn def_has_ty_params(&ast.def def) -> bool {\n     alt (def) {\n@@ -1712,7 +1680,7 @@ fn def_has_ty_params(&ast.def def) -> bool {\n // If the given item is in an external crate, looks up its type and adds it to\n // the type cache. Returns the type parameters and type.\n fn lookup_item_type(session.session sess, &type_cache cache,\n-                    ast.def_id did) -> ty_params_opt_and_ty {\n+                    ast.def_id did) -> ty_param_count_and_ty {\n     if (did._0 == sess.get_targ_crate_num()) {\n         // The item is in this crate. The caller should have added it to the\n         // type cache already; we simply return it.\n@@ -1729,14 +1697,6 @@ fn lookup_item_type(session.session sess, &type_cache cache,\n     ret tyt;\n }\n \n-// A convenience function to retrive type parameters and a type when it's\n-// known that the item supports generics (functions, variants, objects).\n-fn lookup_generic_item_type(session.session sess, &type_cache cache,\n-                            ast.def_id did) -> ty_params_and_ty {\n-    auto tp_opt_and_ty = lookup_item_type(sess, cache, did);\n-    ret tup(option.get[vec[ast.def_id]](tp_opt_and_ty._0), tp_opt_and_ty._1);\n-}\n-\n \n // Local Variables:\n // mode: rust"}, {"sha": "5c512e7eac5dbeeaffd71bfa3e554b83be5d9c72", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 86, "deletions": 166, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=de0175abed80b13d8d8528002fe637d8c9687c93", "patch": "@@ -22,7 +22,7 @@ import middle.ty.plain_ty;\n import middle.ty.ty_to_str;\n import middle.ty.type_is_integral;\n import middle.ty.type_is_scalar;\n-import middle.ty.ty_params_opt_and_ty;\n+import middle.ty.ty_param_count_and_ty;\n import middle.ty.ty_nil;\n \n import std._str;\n@@ -59,7 +59,7 @@ type fn_ctxt = rec(@ty.t ret_ty,\n                    @crate_ctxt ccx);\n \n // Used for ast_ty_to_ty() below.\n-type ty_getter = fn(ast.def_id) -> ty.ty_params_opt_and_ty;\n+type ty_getter = fn(ast.def_id) -> ty.ty_param_count_and_ty;\n \n // Turns a type into an ann_type, using defaults for other fields.\n fn triv_ann(@ty.t t) -> ann {\n@@ -75,8 +75,7 @@ fn boring_ann() -> ann {\n // Replaces parameter types inside a type with type variables.\n fn generalize_ty(@crate_ctxt cx, @ty.t t) -> @ty.t {\n     state obj ty_generalizer(@crate_ctxt cx,\n-                             @hashmap[ast.def_id,@ty.t]\n-                             ty_params_to_ty_vars) {\n+                             @hashmap[uint,@ty.t] ty_params_to_ty_vars) {\n         fn fold_simple_ty(@ty.t t) -> @ty.t {\n             alt (t.struct) {\n                 case (ty.ty_param(?pid)) {\n@@ -93,77 +92,59 @@ fn generalize_ty(@crate_ctxt cx, @ty.t t) -> @ty.t {\n         }\n     }\n \n-    auto generalizer = ty_generalizer(cx, @common.new_def_hash[@ty.t]());\n+    auto generalizer = ty_generalizer(cx, @common.new_uint_hash[@ty.t]());\n     ret ty.fold_ty(generalizer, t);\n }\n \n // Substitutes the user's explicit types for the parameters in a path\n // expression.\n fn substitute_ty_params(&@crate_ctxt ccx,\n                         @ty.t typ,\n-                        vec[ast.def_id] ty_params,\n+                        uint ty_param_count,\n                         vec[@ty.t] supplied,\n                         &span sp) -> @ty.t {\n-    state obj ty_substituter(@crate_ctxt ccx,\n-                             vec[ast.def_id] ty_params,\n-                             vec[@ty.t] supplied) {\n+    state obj ty_substituter(@crate_ctxt ccx, vec[@ty.t] supplied) {\n         fn fold_simple_ty(@ty.t typ) -> @ty.t {\n             alt (typ.struct) {\n-                case (ty.ty_param(?pid)) {\n-                    // Find the index of the type parameter.\n-                    auto ty_param_len = _vec.len[ast.def_id](ty_params);\n-                    auto i = 0u;\n-                    while (i < ty_param_len &&\n-                            !common.def_eq(pid, ty_params.(i))) {\n-                        i += 1u;\n-                    }\n-                    if (i == ty_param_len) {\n-                        log \"substitute_ty_params(): \" +\n-                            \"no ty param for param id!\";\n-                        fail;\n-                    }\n-\n-                    // Substitute it in.\n-                    ret supplied.(i);\n-                }\n+                case (ty.ty_param(?pid)) { ret supplied.(pid); }\n                 case (_) { ret typ; }\n             }\n         }\n     }\n \n-    auto ty_param_len = _vec.len[ast.def_id](ty_params);\n     auto supplied_len = _vec.len[@ty.t](supplied);\n-    if (ty_param_len != supplied_len) {\n-        ccx.sess.span_err(sp, \"expected \" + _uint.to_str(ty_param_len, 10u) +\n+    if (ty_param_count != supplied_len) {\n+        ccx.sess.span_err(sp, \"expected \" +\n+                          _uint.to_str(ty_param_count, 10u) +\n                           \" type parameter(s) but found \" +\n                           _uint.to_str(supplied_len, 10u) + \" parameter(s)\");\n         fail;\n     }\n \n-    auto substituter = ty_substituter(ccx, ty_params, supplied);\n+    auto substituter = ty_substituter(ccx, supplied);\n     ret ty.fold_ty(substituter, typ);\n }\n \n \n-// Returns the type parameters and the type for the given definition.\n-fn ty_params_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n-        -> ty_params_opt_and_ty {\n+// Returns the type parameter count and the type for the given definition.\n+fn ty_param_count_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n+        -> ty_param_count_and_ty {\n     alt (defn) {\n         case (ast.def_arg(?id)) {\n             check (fcx.locals.contains_key(id));\n-            ret tup(none[vec[ast.def_id]], fcx.locals.get(id));\n+            ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_local(?id)) {\n             auto t;\n             alt (fcx.locals.find(id)) {\n                 case (some[@ty.t](?t1)) { t = t1; }\n                 case (none[@ty.t]) { t = plain_ty(ty.ty_local(id)); }\n             }\n-            ret tup(none[vec[ast.def_id]], t);\n+            ret tup(0u, t);\n         }\n         case (ast.def_obj_field(?id)) {\n             check (fcx.locals.contains_key(id));\n-            ret tup(none[vec[ast.def_id]], fcx.locals.get(id));\n+            ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_fn(?id)) {\n             ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache, id);\n@@ -179,7 +160,7 @@ fn ty_params_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n         }\n         case (ast.def_binding(?id)) {\n             check (fcx.locals.contains_key(id));\n-            ret tup(none[vec[ast.def_id]], fcx.locals.get(id));\n+            ret tup(0u, fcx.locals.get(id));\n         }\n         case (ast.def_obj(?id)) {\n             ret ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.type_cache, id);\n@@ -188,7 +169,7 @@ fn ty_params_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n         case (ast.def_mod(_)) {\n             // Hopefully part of a path.\n             // TODO: return a type that's more poisonous, perhaps?\n-            ret tup(none[vec[ast.def_id]], plain_ty(ty.ty_nil));\n+            ret tup(0u, plain_ty(ty.ty_nil));\n         }\n \n         case (ast.def_ty(_)) {\n@@ -205,10 +186,10 @@ fn ty_params_and_ty_for_def(@fn_ctxt fcx, &ast.def defn)\n }\n \n // Instantiates the given path, which must refer to an item with the given\n-// type parameters and type.\n-fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_params_opt_and_ty tpt,\n+// number of type parameters and type.\n+fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n         &span sp) -> ast.ann {\n-    auto ty_params = tpt._0;\n+    auto ty_param_count = tpt._0;\n     auto t = tpt._1;\n \n     auto ty_substs_opt;\n@@ -222,61 +203,25 @@ fn instantiate_path(@fn_ctxt fcx, &ast.path pth, &ty_params_opt_and_ty tpt,\n         }\n         ty_substs_opt = some[vec[@ty.t]](ty_substs);\n \n-        alt (ty_params) {\n-            case (none[vec[ast.def_id]]) {\n-                fcx.ccx.sess.span_err(sp, \"this kind of item may not take \" +\n-                                          \"type parameters\");\n-                fail;\n-            }\n-            case (some[vec[ast.def_id]](?tps)) {\n-                t = substitute_ty_params(fcx.ccx, t, tps, ty_substs, sp);\n-            }\n+        if (ty_param_count == 0u) {\n+            fcx.ccx.sess.span_err(sp, \"this item does not take type \" +\n+                                  \"parameters\");\n+            fail;\n         }\n+\n+        t = substitute_ty_params(fcx.ccx, t, ty_param_count, ty_substs, sp);\n     } else {\n         ty_substs_opt = none[vec[@ty.t]];\n \n-        alt (ty_params) {\n-            case (none[vec[ast.def_id]]) {  /* nothing */ }\n-            case (some[vec[ast.def_id]](_)) {\n-                // We will acquire the type parameters through\n-                // unification.\n-                t = generalize_ty(fcx.ccx, t);\n-            }\n+        if (ty_param_count > 0u) {\n+            // We will acquire the type parameters through unification.\n+            t = generalize_ty(fcx.ccx, t);\n         }\n     }\n \n     ret ast.ann_type(t, ty_substs_opt, none[@ts_ann]);\n }\n \n-// Returns the type parameters and polytype of an item, if it's an item that\n-// supports type parameters.\n-//\n-// TODO: This function is a little silly in the presence of the new\n-// lookup_item_type(); remove this in favor of lookup_item_type() if possible.\n-fn ty_params_for_item(@crate_ctxt ccx, &ast.def d)\n-        -> option.t[ty.ty_params_and_ty] {\n-    auto did;\n-    alt (d) {\n-        case (ast.def_fn(?id))          { did = id;                      }\n-        case (ast.def_obj(?id))         { did = id;                      }\n-        case (ast.def_obj_field(_))     { ret none[ty.ty_params_and_ty]; }\n-        case (ast.def_mod(_))           { ret none[ty.ty_params_and_ty]; }\n-        case (ast.def_const(_))         { ret none[ty.ty_params_and_ty]; }\n-        case (ast.def_arg(_))           { ret none[ty.ty_params_and_ty]; }\n-        case (ast.def_local(_))         { ret none[ty.ty_params_and_ty]; }\n-        case (ast.def_variant(_, ?vid)) { did = vid;                     }\n-        case (ast.def_ty(_))            { ret none[ty.ty_params_and_ty]; }\n-        case (ast.def_ty_arg(_))        { ret none[ty.ty_params_and_ty]; }\n-        case (ast.def_binding(_))       { ret none[ty.ty_params_and_ty]; }\n-        case (ast.def_use(_))           { ret none[ty.ty_params_and_ty]; }\n-        case (ast.def_native_ty(_))     { ret none[ty.ty_params_and_ty]; }\n-        case (ast.def_native_fn(?id))   { did = id;                      }\n-    }\n-\n-    auto tpt = ty.lookup_generic_item_type(ccx.sess, ccx.type_cache, did);\n-    ret some[ty.ty_params_and_ty](tpt);\n-}\n-\n // Parses the programmer's textual representation of a type into our internal\n // notion of a type. `getter` is a function that returns the type\n // corresponding to a definition ID.\n@@ -295,25 +240,20 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n         // TODO: maybe record cname chains so we can do\n         // \"foo = int\" like OCaml?\n         auto params_opt_and_ty = getter(id);\n-        alt (params_opt_and_ty._0) {\n-            case (none[vec[ast.def_id]]) {\n-                // FIXME: Session error. This is completely user-unfriendly.\n-                log \"item has no type parameters\";\n-                fail;\n-            }\n-            case (some[vec[ast.def_id]](?params)) {\n-                auto num_type_args = _vec.len[@ast.ty](args);\n-                check(num_type_args == _vec.len[ast.def_id](params));\n \n-                auto param_map = common.new_def_hash[@ty.t]();\n-                for each (uint i in _uint.range(0u, num_type_args)) {\n-                    auto arg = args.(i);\n-                    auto param = params.(i);\n-                    param_map.insert(param, ast_ty_to_ty(getter, arg));\n-                }\n-                ret ty.replace_type_params(params_opt_and_ty._1, param_map);\n-            }\n+        if (params_opt_and_ty._0 == 0u) {\n+            ret params_opt_and_ty._1;\n+        }\n+\n+        // The typedef is type-parametric. Do the type substitution.\n+        //\n+        // TODO: Make sure the number of supplied bindings matches the number\n+        // of type parameters in the typedef. Emit a friendly error otherwise.\n+        let vec[@ty.t] param_bindings = vec();\n+        for (@ast.ty ast_ty in args) {\n+            param_bindings += vec(ast_ty_to_ty(getter, ast_ty));\n         }\n+        ret ty.substitute_type_params(param_bindings, params_opt_and_ty._1);\n     }\n \n     auto mut = ast.imm;\n@@ -403,7 +343,7 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n // A convenience function to use a crate_ctxt to resolve names for\n // ast_ty_to_ty.\n fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> @ty.t {\n-    fn getter(@crate_ctxt ccx, ast.def_id id) -> ty.ty_params_opt_and_ty {\n+    fn getter(@crate_ctxt ccx, ast.def_id id) -> ty.ty_param_count_and_ty {\n         ret ty.lookup_item_type(ccx.sess, ccx.type_cache, id);\n     }\n     auto f = bind getter(ccx, _);\n@@ -422,27 +362,19 @@ fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> @ty.t {\n // We then annotate the AST with the resulting types and return the annotated\n // AST, along with a table mapping item IDs to their types.\n \n-fn ty_params_to_def_ids(vec[ast.ty_param] tps) -> vec[ast.def_id] {\n-    let vec[ast.def_id] result = vec();\n-    for (ast.ty_param tp in tps) {\n-        result += vec(tp.id);\n-    }\n-    ret result;\n-}\n-\n fn ty_of_fn_decl(@ty_item_table id_to_ty_item,\n                  ty.type_cache type_cache,\n                  fn(&@ast.ty ast_ty) -> @ty.t convert,\n                  fn(&ast.arg a) -> arg ty_of_arg,\n                  &ast.fn_decl decl,\n                  ast.proto proto,\n                  vec[ast.ty_param] ty_params,\n-                 ast.def_id def_id) -> ty.ty_params_opt_and_ty {\n+                 ast.def_id def_id) -> ty.ty_param_count_and_ty {\n     auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n     auto output_ty = convert(decl.output);\n     auto t_fn = plain_ty(ty.ty_fn(proto, input_tys, output_ty));\n-    auto params_opt = some[vec[ast.def_id]](ty_params_to_def_ids(ty_params));\n-    auto tpt = tup(params_opt, t_fn);\n+    auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n+    auto tpt = tup(ty_param_count, t_fn);\n     type_cache.insert(def_id, tpt);\n     ret tpt;\n }\n@@ -454,12 +386,12 @@ fn ty_of_native_fn_decl(@ty_item_table id_to_ty_item,\n                  &ast.fn_decl decl,\n                  ast.native_abi abi,\n                  vec[ast.ty_param] ty_params,\n-                 ast.def_id def_id) -> ty.ty_params_opt_and_ty {\n+                 ast.def_id def_id) -> ty.ty_param_count_and_ty {\n     auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n     auto output_ty = convert(decl.output);\n     auto t_fn = plain_ty(ty.ty_native_fn(abi, input_tys, output_ty));\n-    auto params_opt = some[vec[ast.def_id]](ty_params_to_def_ids(ty_params));\n-    auto tpt = tup(params_opt, t_fn);\n+    auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n+    auto tpt = tup(ty_param_count, t_fn);\n     type_cache.insert(def_id, tpt);\n     ret tpt;\n }\n@@ -470,7 +402,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n     fn getter(session.session sess,\n               @ty_item_table id_to_ty_item,\n               ty.type_cache type_cache,\n-              ast.def_id id) -> ty.ty_params_opt_and_ty {\n+              ast.def_id id) -> ty.ty_param_count_and_ty {\n \n         if (id._0 != sess.get_targ_crate_num()) {\n             // This is a type we need to load in from the crate reader.\n@@ -520,16 +452,15 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                  ty.type_cache type_cache,\n                  &ast.ident id,\n                  &ast._obj obj_info,\n-                 vec[ast.ty_param] ty_params) -> ty.ty_params_opt_and_ty {\n+                 vec[ast.ty_param] ty_params) -> ty.ty_param_count_and_ty {\n         auto f = bind ty_of_method(sess, id_to_ty_item, type_cache, _);\n         auto methods =\n             _vec.map[@ast.method,method](f, obj_info.methods);\n \n         auto t_obj = @rec(struct=ty.ty_obj(ty.sort_methods(methods)),\n                           cname=some[str](id));\n-        auto params = ty_params_to_def_ids(ty_params);\n-        auto params_opt = some[vec[ast.def_id]](params);\n-        ret tup(params_opt, t_obj);\n+        auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n+        ret tup(ty_param_count, t_obj);\n     }\n \n     fn ty_of_obj_ctor(session.session sess,\n@@ -539,7 +470,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                       &ast._obj obj_info,\n                       ast.def_id obj_ty_id,\n                       vec[ast.ty_param] ty_params)\n-            -> ty.ty_params_opt_and_ty {\n+            -> ty.ty_param_count_and_ty {\n         auto t_obj = ty_of_obj(sess, id_to_ty_item, type_cache,\n                                id, obj_info, ty_params);\n         let vec[arg] t_inputs = vec();\n@@ -558,7 +489,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n     fn ty_of_item(session.session sess,\n                   @ty_item_table id_to_ty_item,\n                   ty.type_cache type_cache,\n-                  @ast.item it) -> ty.ty_params_opt_and_ty {\n+                  @ast.item it) -> ty.ty_param_count_and_ty {\n \n         auto get = bind getter(sess, id_to_ty_item, type_cache, _);\n         auto convert = bind ast_ty_to_ty(get, _);\n@@ -567,7 +498,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n             case (ast.item_const(?ident, ?t, _, ?def_id, _)) {\n                 auto typ = convert(t);\n-                type_cache.insert(def_id, tup(none[vec[ast.def_id]], typ));\n+                type_cache.insert(def_id, tup(0u, typ));\n             }\n \n             case (ast.item_fn(?ident, ?fn_info, ?tps, ?def_id, _)) {\n@@ -597,24 +528,26 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                 // Tell ast_ty_to_ty() that we want to perform a recursive\n                 // call to resolve any named types.\n                 auto typ = convert(ty);\n-                auto params = ty_params_to_def_ids(tps);\n-                auto params_opt = some[vec[ast.def_id]](params);\n-                auto tpt = tup(params_opt, typ);\n+                auto ty_param_count = _vec.len[ast.ty_param](tps);\n+                auto tpt = tup(ty_param_count, typ);\n                 type_cache.insert(def_id, tpt);\n                 ret tpt;\n             }\n \n             case (ast.item_tag(_, _, ?tps, ?def_id, _)) {\n                 // Create a new generic polytype.\n                 let vec[@ty.t] subtys = vec();\n+\n+                auto i = 0u;\n                 for (ast.ty_param tp in tps) {\n-                    subtys += vec(plain_ty(ty.ty_param(tp.id)));\n+                    subtys += vec(plain_ty(ty.ty_param(i)));\n+                    i += 1u;\n                 }\n+\n                 auto t = plain_ty(ty.ty_tag(def_id, subtys));\n \n-                auto params = ty_params_to_def_ids(tps);\n-                auto params_opt = some[vec[ast.def_id]](params);\n-                auto tpt = tup(params_opt, t);\n+                auto ty_param_count = _vec.len[ast.ty_param](tps);\n+                auto tpt = tup(ty_param_count, t);\n                 type_cache.insert(def_id, tpt);\n                 ret tpt;\n             }\n@@ -628,7 +561,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                          @ty_item_table id_to_ty_item,\n                          ty.type_cache type_cache,\n                          @ast.native_item it,\n-                         ast.native_abi abi) -> ty.ty_params_opt_and_ty {\n+                         ast.native_abi abi) -> ty.ty_param_count_and_ty {\n         alt (it.node) {\n             case (ast.native_item_fn(?ident, ?lname, ?fn_decl,\n                                      ?params, ?def_id, _)) {\n@@ -645,7 +578,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                 }\n \n                 auto t = @rec(struct=ty.ty_native, cname=none[str]);\n-                auto tpt = tup(none[vec[ast.def_id]], t);\n+                auto tpt = tup(0u, t);\n                 type_cache.insert(def_id, tpt);\n                 ret tpt;\n             }\n@@ -663,12 +596,13 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n         // Create a set of parameter types shared among all the variants.\n         let vec[@ty.t] ty_param_tys = vec();\n+        auto i = 0u;\n         for (ast.ty_param tp in ty_params) {\n-            ty_param_tys += vec(plain_ty(ty.ty_param(tp.id)));\n+            ty_param_tys += vec(plain_ty(ty.ty_param(i)));\n+            i += 1u;\n         }\n \n-        auto params = ty_params_to_def_ids(ty_params);\n-        auto params_opt = some[vec[ast.def_id]](params);\n+        auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n \n         for (ast.variant variant in variants) {\n             // Nullary tag constructors get turned into constants; n-ary tag\n@@ -690,7 +624,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                 result_ty = plain_ty(ty.ty_fn(ast.proto_fn, args, tag_t));\n             }\n \n-            auto tpt = tup(params_opt, result_ty);\n+            auto tpt = tup(ty_param_count, result_ty);\n             type_cache.insert(variant.node.id, tpt);\n             auto variant_t = rec(ann=triv_ann(result_ty)\n                 with variant.node\n@@ -743,7 +677,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n \n     // Second pass: translate the types of all items.\n-    auto type_cache = common.new_def_hash[ty.ty_params_opt_and_ty]();\n+    auto type_cache = common.new_def_hash[ty.ty_param_count_and_ty]();\n \n     type env = rec(session.session sess,\n                    @ty_item_table id_to_ty_item,\n@@ -920,25 +854,21 @@ fn unify(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> ty.unify_result {\n         fn record_local(ast.def_id id, @ty.t t) {\n             fcx.locals.insert(id, t);\n         }\n-        fn unify_expected_param(ast.def_id id, @ty.t expected, @ty.t actual)\n+        fn unify_expected_param(uint id, @ty.t expected, @ty.t actual)\n                 -> ty.unify_result {\n             alt (actual.struct) {\n                 case (ty.ty_param(?actual_id)) {\n-                    if (id._0 == actual_id._0 && id._1 == actual_id._1) {\n-                        ret ty.ures_ok(expected);\n-                    }\n+                    if (id == actual_id) { ret ty.ures_ok(expected); }\n                 }\n                 case (_) { /* fall through */ }\n             }\n             ret ty.ures_err(ty.terr_mismatch, expected, actual);\n         }\n-        fn unify_actual_param(ast.def_id id, @ty.t expected, @ty.t actual)\n+        fn unify_actual_param(uint id, @ty.t expected, @ty.t actual)\n                 -> ty.unify_result {\n             alt (expected.struct) {\n                 case (ty.ty_param(?expected_id)) {\n-                    if (id._0 == expected_id._0 && id._1 == expected_id._1) {\n-                        ret ty.ures_ok(actual);\n-                    }\n+                    if (id == expected_id) { ret ty.ures_ok(actual); }\n                 }\n                 case (_) { /* fall through */ }\n             }\n@@ -1087,7 +1017,7 @@ mod Pushdown {\n                 // Figure out the type parameters of the tag.\n                 auto tag_id = option.get[ast.variant_def](vdef_opt)._0;\n \n-                auto tpt = ty.lookup_generic_item_type(fcx.ccx.sess,\n+                auto tpt = ty.lookup_item_type(fcx.ccx.sess,\n                     fcx.ccx.type_cache, tag_id);\n                 auto ty_params = tpt._0;\n \n@@ -1367,15 +1297,10 @@ mod Pushdown {\n                         alt (tps_opt) {\n                             case (none[vec[@ty.t]]) {\n                                 auto defn = option.get[ast.def](d);\n-                                alt (ty_params_for_item(fcx.ccx, defn)) {\n-                                case (none[ty.ty_params_and_ty]) {\n-                                    ty_params_opt = none[vec[@ty.t]];\n-                                }\n-                                case (some[ty.ty_params_and_ty](?tpt)) {\n-                                    auto tps = ty.resolve_ty_params(tpt, t);\n-                                    ty_params_opt = some[vec[@ty.t]](tps);\n-                                }\n-                                }\n+                                auto tpt =\n+                                    ty_param_count_and_ty_for_def(fcx, defn);\n+                                auto tps = ty.resolve_ty_params(tpt, t);\n+                                ty_params_opt = some[vec[@ty.t]](tps);\n                             }\n                             case (some[vec[@ty.t]](?tps)) {\n                                 ty_params_opt = some[vec[@ty.t]](tps);\n@@ -1841,7 +1766,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto t = plain_ty(ty.ty_nil);\n             check (defopt != none[ast.def]);\n             auto defn = option.get[ast.def](defopt);\n-            auto tpt = ty_params_and_ty_for_def(fcx, defn);\n+            auto tpt = ty_param_count_and_ty_for_def(fcx, defn);\n             auto ann = instantiate_path(fcx, pth, tpt, expr.span);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_path(pth, defopt, ann));\n@@ -2217,13 +2142,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto this_obj_id = fcx.ccx.this_obj;\n             alt (this_obj_id) {\n                 case (some[ast.def_id](?def_id)) {\n-                    auto this_obj_tpt = fcx.ccx.type_cache.find(def_id);\n-                    alt (this_obj_tpt) {\n-                        case (some[ty_params_opt_and_ty](?tpt)) {\n-                            this_obj_ty = tpt._1;\n-                        }\n-                        case (_) { fail; }\n-                    }\n+                    this_obj_ty = ty.lookup_item_type(fcx.ccx.sess,\n+                        fcx.ccx.type_cache, def_id)._1;\n                 }\n                 case (_) { fail; }\n             }"}, {"sha": "6aee29d72410e747d9364411932c653842e7010c", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de0175abed80b13d8d8528002fe637d8c9687c93/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=de0175abed80b13d8d8528002fe637d8c9687c93", "patch": "@@ -796,7 +796,7 @@ impure fn print_type_params(ps s, vec[ast.ty_param] params) {\n     if (_vec.len[ast.ty_param](params) > 0u) {\n         wrd(s.s, \"[\");\n         impure fn printParam(ps s, &ast.ty_param param) {\n-            wrd(s.s, param.ident);\n+            wrd(s.s, param);\n         }\n         auto f = printParam;\n         commasep[ast.ty_param](s, params, f);"}]}