{"sha": "0c8de9ed52ddc14e3797f89ab260a4e45be62418", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjOGRlOWVkNTJkZGMxNGUzNzk3Zjg5YWIyNjBhNGU0NWJlNjI0MTg=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2015-12-23T01:19:32Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2015-12-23T01:42:01Z"}, "message": "Split MatchPass::check_expr for dogfood", "tree": {"sha": "3ba18db7f82ab14ece884247423cb9a621875055", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ba18db7f82ab14ece884247423cb9a621875055"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c8de9ed52ddc14e3797f89ab260a4e45be62418", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c8de9ed52ddc14e3797f89ab260a4e45be62418", "html_url": "https://github.com/rust-lang/rust/commit/0c8de9ed52ddc14e3797f89ab260a4e45be62418", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c8de9ed52ddc14e3797f89ab260a4e45be62418/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3373ea43c0ba0f226bc0a5e9bd578118fa564547", "url": "https://api.github.com/repos/rust-lang/rust/commits/3373ea43c0ba0f226bc0a5e9bd578118fa564547", "html_url": "https://github.com/rust-lang/rust/commit/3373ea43c0ba0f226bc0a5e9bd578118fa564547"}], "stats": {"total": 211, "additions": 110, "deletions": 101}, "files": [{"sha": "78b39ac179184bef852b540a0b2278a038892b54", "filename": "src/matches.rs", "status": "modified", "additions": 110, "deletions": 101, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/0c8de9ed52ddc14e3797f89ab260a4e45be62418/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c8de9ed52ddc14e3797f89ab260a4e45be62418/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=0c8de9ed52ddc14e3797f89ab260a4e45be62418", "patch": "@@ -96,117 +96,126 @@ impl LateLintPass for MatchPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if in_external_macro(cx, expr.span) { return; }\n         if let ExprMatch(ref ex, ref arms, MatchSource::Normal) = expr.node {\n-            // check preconditions for SINGLE_MATCH\n-                // only two arms\n-            if arms.len() == 2 &&\n-                // both of the arms have a single pattern and no guard\n-                arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n-                arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n-                // and the second pattern is a `_` wildcard: this is not strictly necessary,\n-                // since the exhaustiveness check will ensure the last one is a catch-all,\n-                // but in some cases, an explicit match is preferred to catch situations\n-                // when an enum is extended, so we don't consider these cases\n-                arms[1].pats[0].node == PatWild &&\n-                // we don't want any content in the second arm (unit or empty block)\n-                is_unit_expr(&arms[1].body) &&\n-                // finally, MATCH_BOOL doesn't apply here\n-                (cx.tcx.expr_ty(ex).sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow)\n-            {\n-                span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n-                                   \"you seem to be trying to use match for destructuring a \\\n-                                    single pattern. Consider using `if let`\",\n-                                   &format!(\"try\\nif let {} = {} {}\",\n-                                            snippet(cx, arms[0].pats[0].span, \"..\"),\n-                                            snippet(cx, ex.span, \"..\"),\n-                                            expr_block(cx, &arms[0].body, None, \"..\")));\n-            }\n+            check_single_match(cx, ex, arms, expr);\n+            check_match_bool(cx, ex, arms, expr);\n+            check_overlapping_arms(cx, arms);\n+        }\n+        if let ExprMatch(ref ex, ref arms, source) = expr.node {\n+            check_match_ref_pats(cx, ex, arms, source, expr);\n+        }\n+    }\n+}\n \n-            // check preconditions for MATCH_BOOL\n-            // type of expression == bool\n-            if cx.tcx.expr_ty(ex).sty == ty::TyBool {\n-                if arms.len() == 2 && arms[0].pats.len() == 1 { // no guards\n-                    let exprs = if let PatLit(ref arm_bool) = arms[0].pats[0].node {\n-                        if let ExprLit(ref lit) = arm_bool.node {\n-                            match lit.node {\n-                                LitBool(true) => Some((&*arms[0].body, &*arms[1].body)),\n-                                LitBool(false) => Some((&*arms[1].body, &*arms[0].body)),\n-                                _ => None,\n-                            }\n-                        } else { None }\n-                    } else { None };\n-                    if let Some((ref true_expr, ref false_expr)) = exprs {\n-                        if !is_unit_expr(true_expr) {\n-                            if !is_unit_expr(false_expr) {\n-                                span_help_and_lint(cx, MATCH_BOOL, expr.span,\n-                                    \"you seem to be trying to match on a boolean expression. \\\n-                                   Consider using an if..else block:\",\n-                                   &format!(\"try\\nif {} {} else {}\",\n-                                        snippet(cx, ex.span, \"b\"),\n-                                        expr_block(cx, true_expr, None, \"..\"),\n-                                        expr_block(cx, false_expr, None, \"..\")));\n-                            } else {\n-                                span_help_and_lint(cx, MATCH_BOOL, expr.span,\n-                                    \"you seem to be trying to match on a boolean expression. \\\n-                                   Consider using an if..else block:\",\n-                                   &format!(\"try\\nif {} {}\",\n-                                        snippet(cx, ex.span, \"b\"),\n-                                        expr_block(cx, true_expr, None, \"..\")));\n-                            }\n-                        } else if !is_unit_expr(false_expr) {\n-                            span_help_and_lint(cx, MATCH_BOOL, expr.span,\n-                                \"you seem to be trying to match on a boolean expression. \\\n-                               Consider using an if..else block:\",\n-                               &format!(\"try\\nif !{} {}\",\n-                                    snippet(cx, ex.span, \"b\"),\n-                                    expr_block(cx, false_expr, None, \"..\")));\n-                        } else {\n-                            span_lint(cx, MATCH_BOOL, expr.span,\n-                                   \"you seem to be trying to match on a boolean expression. \\\n-                                   Consider using an if..else block\");\n-                        }\n+fn check_single_match(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+    if arms.len() == 2 &&\n+        // both of the arms have a single pattern and no guard\n+        arms[0].pats.len() == 1 && arms[0].guard.is_none() &&\n+        arms[1].pats.len() == 1 && arms[1].guard.is_none() &&\n+        // and the second pattern is a `_` wildcard: this is not strictly necessary,\n+        // since the exhaustiveness check will ensure the last one is a catch-all,\n+        // but in some cases, an explicit match is preferred to catch situations\n+        // when an enum is extended, so we don't consider these cases\n+        arms[1].pats[0].node == PatWild &&\n+        // we don't want any content in the second arm (unit or empty block)\n+        is_unit_expr(&arms[1].body) &&\n+        // finally, MATCH_BOOL doesn't apply here\n+        (cx.tcx.expr_ty(ex).sty != ty::TyBool || cx.current_level(MATCH_BOOL) == Allow)\n+    {\n+        span_help_and_lint(cx, SINGLE_MATCH, expr.span,\n+                           \"you seem to be trying to use match for destructuring a \\\n+                            single pattern. Consider using `if let`\",\n+                           &format!(\"try\\nif let {} = {} {}\",\n+                                    snippet(cx, arms[0].pats[0].span, \"..\"),\n+                                    snippet(cx, ex.span, \"..\"),\n+                                    expr_block(cx, &arms[0].body, None, \"..\")));\n+    }\n+}\n+\n+fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n+    // type of expression == bool\n+    if cx.tcx.expr_ty(ex).sty == ty::TyBool {\n+        if arms.len() == 2 && arms[0].pats.len() == 1 { // no guards\n+            let exprs = if let PatLit(ref arm_bool) = arms[0].pats[0].node {\n+                if let ExprLit(ref lit) = arm_bool.node {\n+                    match lit.node {\n+                        LitBool(true) => Some((&*arms[0].body, &*arms[1].body)),\n+                        LitBool(false) => Some((&*arms[1].body, &*arms[0].body)),\n+                        _ => None,\n+                    }\n+                } else { None }\n+            } else { None };\n+            if let Some((ref true_expr, ref false_expr)) = exprs {\n+                if !is_unit_expr(true_expr) {\n+                    if !is_unit_expr(false_expr) {\n+                        span_help_and_lint(cx, MATCH_BOOL, expr.span,\n+                            \"you seem to be trying to match on a boolean expression. \\\n+                           Consider using an if..else block:\",\n+                           &format!(\"try\\nif {} {} else {}\",\n+                                snippet(cx, ex.span, \"b\"),\n+                                expr_block(cx, true_expr, None, \"..\"),\n+                                expr_block(cx, false_expr, None, \"..\")));\n                     } else {\n-                        span_lint(cx, MATCH_BOOL, expr.span,\n+                        span_help_and_lint(cx, MATCH_BOOL, expr.span,\n                             \"you seem to be trying to match on a boolean expression. \\\n-                            Consider using an if..else block\");\n+                           Consider using an if..else block:\",\n+                           &format!(\"try\\nif {} {}\",\n+                                snippet(cx, ex.span, \"b\"),\n+                                expr_block(cx, true_expr, None, \"..\")));\n                     }\n+                } else if !is_unit_expr(false_expr) {\n+                    span_help_and_lint(cx, MATCH_BOOL, expr.span,\n+                        \"you seem to be trying to match on a boolean expression. \\\n+                       Consider using an if..else block:\",\n+                       &format!(\"try\\nif !{} {}\",\n+                            snippet(cx, ex.span, \"b\"),\n+                            expr_block(cx, false_expr, None, \"..\")));\n                 } else {\n                     span_lint(cx, MATCH_BOOL, expr.span,\n-                        \"you seem to be trying to match on a boolean expression. \\\n-                        Consider using an if..else block\");\n+                           \"you seem to be trying to match on a boolean expression. \\\n+                           Consider using an if..else block\");\n                 }\n+            } else {\n+                span_lint(cx, MATCH_BOOL, expr.span,\n+                    \"you seem to be trying to match on a boolean expression. \\\n+                    Consider using an if..else block\");\n             }\n+        } else {\n+            span_lint(cx, MATCH_BOOL, expr.span,\n+                \"you seem to be trying to match on a boolean expression. \\\n+                Consider using an if..else block\");\n+        }\n+    }\n+}\n \n-            // MATCH_OVERLAPPING_ARM\n-            if arms.len() >= 2 {\n-                let ranges = all_ranges(cx, arms);\n-                let overlap = match type_ranges(&ranges) {\n-                    TypedRanges::IntRanges(ranges) => overlaping(&ranges).map(|(start, end)| (start.span, end.span)),\n-                    TypedRanges::UintRanges(ranges) => overlaping(&ranges).map(|(start, end)| (start.span, end.span)),\n-                    TypedRanges::None => None,\n-                };\n-\n-                if let Some((start, end)) = overlap {\n-                    span_note_and_lint(cx, MATCH_OVERLAPPING_ARM, start,\n-                                       \"some ranges overlap\",\n-                                       end, \"overlaps with this\");\n-                }\n-            }\n+fn check_overlapping_arms(cx: &LateContext, arms: &[Arm]) {\n+    if arms.len() >= 2 {\n+        let ranges = all_ranges(cx, arms);\n+        let overlap = match type_ranges(&ranges) {\n+            TypedRanges::IntRanges(ranges) => overlaping(&ranges).map(|(start, end)| (start.span, end.span)),\n+            TypedRanges::UintRanges(ranges) => overlaping(&ranges).map(|(start, end)| (start.span, end.span)),\n+            TypedRanges::None => None,\n+        };\n+\n+        if let Some((start, end)) = overlap {\n+            span_note_and_lint(cx, MATCH_OVERLAPPING_ARM, start,\n+                               \"some ranges overlap\",\n+                               end, \"overlaps with this\");\n         }\n-        if let ExprMatch(ref ex, ref arms, source) = expr.node {\n-            // check preconditions for MATCH_REF_PATS\n-            if has_only_ref_pats(arms) {\n-                if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n-                    let template = match_template(cx, expr.span, source, \"\", inner);\n-                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n-                        \"you don't need to add `&` to both the expression \\\n-                         and the patterns: use `{}`\", template));\n-                } else {\n-                    let template = match_template(cx, expr.span, source, \"*\", ex);\n-                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n-                        \"instead of prefixing all patterns with `&`, you can dereference the \\\n-                         expression: `{}`\", template));\n-                }\n-            }\n+    }\n+}\n+\n+fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: MatchSource, expr: &Expr) {\n+    if has_only_ref_pats(arms) {\n+        if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n+            let template = match_template(cx, expr.span, source, \"\", inner);\n+            span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n+                \"you don't need to add `&` to both the expression \\\n+                 and the patterns: use `{}`\", template));\n+        } else {\n+            let template = match_template(cx, expr.span, source, \"*\", ex);\n+            span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n+                \"instead of prefixing all patterns with `&`, you can dereference the \\\n+                 expression: `{}`\", template));\n         }\n     }\n }"}]}