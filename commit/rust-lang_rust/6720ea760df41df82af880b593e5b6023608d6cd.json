{"sha": "6720ea760df41df82af880b593e5b6023608d6cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3MjBlYTc2MGRmNDFkZjgyYWY4ODBiNTkzZTViNjAyMzYwOGQ2Y2Q=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-01T18:32:40Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-01T18:33:17Z"}, "message": "rustc: Change methods in ty::t to use interior vectors", "tree": {"sha": "461da49b594b11f6d13c36e7b593fa1603c11c06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/461da49b594b11f6d13c36e7b593fa1603c11c06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6720ea760df41df82af880b593e5b6023608d6cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6720ea760df41df82af880b593e5b6023608d6cd", "html_url": "https://github.com/rust-lang/rust/commit/6720ea760df41df82af880b593e5b6023608d6cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6720ea760df41df82af880b593e5b6023608d6cd/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "172c5633c4fd6a3868ded1f6afdd5b519edb98ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/172c5633c4fd6a3868ded1f6afdd5b519edb98ed", "html_url": "https://github.com/rust-lang/rust/commit/172c5633c4fd6a3868ded1f6afdd5b519edb98ed"}], "stats": {"total": 91, "additions": 48, "deletions": 43}, "files": [{"sha": "f9df56bc6d735d50b4fe2a8f5505c9586156582e", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6720ea760df41df82af880b593e5b6023608d6cd/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6720ea760df41df82af880b593e5b6023608d6cd/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=6720ea760df41df82af880b593e5b6023608d6cd", "patch": "@@ -230,7 +230,7 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n         }\n         case ('O') {\n             assert (next(st) as char == '[');\n-            let vec[ty::method] methods = [];\n+            let ty::method[] methods = ~[];\n             while (peek(st) as char != ']') {\n                 auto proto;\n                 alt (next(st) as char) {\n@@ -243,12 +243,12 @@ fn parse_ty(@pstate st, str_def sd) -> ty::t {\n                 }\n                 auto func = parse_ty_fn(st, sd);\n                 methods +=\n-                    [rec(proto=proto,\n-                         ident=name,\n-                         inputs=func._0,\n-                         output=func._1,\n-                         cf=func._2,\n-                         constrs=func._3)];\n+                    ~[rec(proto=proto,\n+                          ident=name,\n+                          inputs=func._0,\n+                          output=func._1,\n+                          cf=func._2,\n+                          constrs=func._3)];\n             }\n             st.pos += 1u;\n             ret ty::mk_obj(st.tcx, methods);"}, {"sha": "7c8a525c923fcb9ad6db47a5c504c6ff65ec5284", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6720ea760df41df82af880b593e5b6023608d6cd/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6720ea760df41df82af880b593e5b6023608d6cd/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=6720ea760df41df82af880b593e5b6023608d6cd", "patch": "@@ -268,7 +268,7 @@ tag sty {\n     ty_rec(field[]);\n     ty_fn(ast::proto, arg[], t, controlflow, vec[@constr_def]);\n     ty_native_fn(ast::native_abi, arg[], t);\n-    ty_obj(vec[method]);\n+    ty_obj(method[]);\n     ty_res(def_id, t, vec[t]);\n     ty_var(int); // type variable\n     ty_param(uint); // fn/tag type param\n@@ -603,7 +603,7 @@ fn mk_native_fn(&ctxt cx, &ast::native_abi abi, &arg[] args, &t ty) -> t {\n     ret gen_ty(cx, ty_native_fn(abi, args, ty));\n }\n \n-fn mk_obj(&ctxt cx, &vec[method] meths) -> t {\n+fn mk_obj(&ctxt cx, &method[] meths) -> t {\n     ret gen_ty(cx, ty_obj(meths));\n }\n \n@@ -811,20 +811,20 @@ fn fold_ty(&ctxt cx, fold_mode fld, t ty_0) -> t {\n                                         fold_ty(cx, fld, ret_ty)), ty);\n         }\n         case (ty_obj(?methods)) {\n-            let vec[method] new_methods = [];\n+            let method[] new_methods = ~[];\n             for (method m in methods) {\n                 let arg[] new_args = ~[];\n                 for (arg a in m.inputs) {\n                     new_args += ~[rec(mode=a.mode,\n                                       ty=fold_ty(cx, fld, a.ty))];\n                 }\n                 new_methods +=\n-                    [rec(proto=m.proto,\n-                         ident=m.ident,\n-                         inputs=new_args,\n-                         output=fold_ty(cx, fld, m.output),\n-                         cf=m.cf,\n-                         constrs=m.constrs)];\n+                    ~[rec(proto=m.proto,\n+                          ident=m.ident,\n+                          inputs=new_args,\n+                          output=fold_ty(cx, fld, m.output),\n+                          cf=m.cf,\n+                          constrs=m.constrs)];\n             }\n             ty = copy_cname(cx, mk_obj(cx, new_methods), ty);\n         }\n@@ -1634,8 +1634,8 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_obj(?methods_a)) {\n             alt (b) {\n                 case (ty_obj(?methods_b)) {\n-                    auto len = vec::len[method](methods_a);\n-                    if (len != vec::len[method](methods_b)) { ret false; }\n+                    auto len = ivec::len[method](methods_a);\n+                    if (len != ivec::len[method](methods_b)) { ret false; }\n                     auto i = 0u;\n                     while (i < len) {\n                         auto m_a = methods_a.(i);\n@@ -1947,17 +1947,17 @@ fn field_idx(&session::session sess, &span sp, &ast::ident id,\n }\n \n fn method_idx(&session::session sess, &span sp, &ast::ident id,\n-              &vec[method] meths) -> uint {\n+              &method[] meths) -> uint {\n     let uint i = 0u;\n     for (method m in meths) { if (str::eq(m.ident, id)) { ret i; } i += 1u; }\n     sess.span_fatal(sp, \"unknown method '\" + id + \"' of obj\");\n }\n \n-fn sort_methods(&vec[method] meths) -> vec[method] {\n+fn sort_methods(&method[] meths) -> method[] {\n     fn method_lteq(&method a, &method b) -> bool {\n         ret str::lteq(a.ident, b.ident);\n     }\n-    ret std::sort::merge_sort[method](bind method_lteq(_, _), meths);\n+    ret std::sort::ivector::merge_sort[method](bind method_lteq(_, _), meths);\n }\n \n fn is_lval(&@ast::expr expr) -> bool {\n@@ -2197,12 +2197,12 @@ mod unify {\n         }\n     }\n     fn unify_obj(&@ctxt cx, &t expected, &t actual,\n-                 &vec[method] expected_meths, &vec[method] actual_meths) ->\n+                 &method[] expected_meths, &method[] actual_meths) ->\n        result {\n-        let vec[method] result_meths = [];\n+        let method[] result_meths = ~[];\n         let uint i = 0u;\n-        let uint expected_len = vec::len[method](expected_meths);\n-        let uint actual_len = vec::len[method](actual_meths);\n+        let uint expected_len = ivec::len[method](expected_meths);\n+        let uint actual_len = ivec::len[method](actual_meths);\n         if (expected_len != actual_len) { ret ures_err(terr_meth_count); }\n         while (i < expected_len) {\n             auto e_meth = expected_meths.(i);\n@@ -2220,10 +2220,10 @@ mod unify {\n                     alt (struct(cx.tcx, tfn)) {\n                         case (ty_fn(?proto, ?ins, ?out, ?cf, ?constrs)) {\n                             result_meths +=\n-                                [rec(inputs=ins,\n-                                     output=out,\n-                                     cf=cf,\n-                                     constrs=constrs with e_meth)];\n+                                ~[rec(inputs=ins,\n+                                      output=out,\n+                                      cf=cf,\n+                                      constrs=constrs with e_meth)];\n                         }\n                     }\n                 }"}, {"sha": "0b14ddd25dfde4309229adfe1d5b9d352bd34580", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6720ea760df41df82af880b593e5b6023608d6cd/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6720ea760df41df82af880b593e5b6023608d6cd/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=6720ea760df41df82af880b593e5b6023608d6cd", "patch": "@@ -336,7 +336,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n             cname = some(path_to_str(path));\n         }\n         case (ast::ty_obj(?meths)) {\n-            let vec[ty::method] tmeths = [];\n+            let ty::method[] tmeths = ~[];\n             for (ast::ty_method m in meths) {\n                 auto ins = ~[];\n                 for (ast::ty_arg ta in m.node.inputs) {\n@@ -355,7 +355,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n                         output=out,\n                         cf=m.node.cf,\n                         constrs=out_constrs);\n-                vec::push[ty::method](tmeths, new_m);\n+                tmeths += ~[new_m];\n             }\n             typ = ty::mk_obj(tcx, ty::sort_methods(tmeths));\n         }\n@@ -681,9 +681,12 @@ mod collect {\n             write::ty_only(cx.tcx, variant.node.id, result_ty);\n         }\n     }\n-    fn get_obj_method_types(&@ctxt cx, &ast::_obj object) -> vec[ty::method] {\n-        ret vec::map[@ast::method,\n-                     method](bind ty_of_method(cx, _), object.methods);\n+    fn get_obj_method_types(&@ctxt cx, &ast::_obj object) -> ty::method[] {\n+        auto meths = ~[];\n+        for (@ast::method am in object.methods) {\n+            meths += ~[ty_of_method(cx, am)];\n+        }\n+        ret meths;\n     }\n     fn convert(@ctxt cx, @mutable option::t[ast::native_abi] abi,\n                &@ast::item it) {\n@@ -2069,7 +2072,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                     let uint ix =\n                         ty::method_idx(fcx.ccx.tcx.sess, expr.span, field,\n                                        methods);\n-                    if (ix >= vec::len[ty::method](methods)) {\n+                    if (ix >= ivec::len[ty::method](methods)) {\n                         fcx.ccx.tcx.sess.span_fatal(expr.span,\n                                                   \"bad index on obj\");\n                     }\n@@ -2213,11 +2216,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                         constrs=out_constrs);\n             }\n             fn get_anon_obj_method_types(@crate_ctxt ccx,\n-                                         &ast::anon_obj anon_obj) ->\n-               vec[ty::method] {\n-                ret vec::map[@ast::method,\n-                             method](bind ty_of_method(ccx, _),\n-                                     anon_obj.methods);\n+                                         &ast::anon_obj anon_obj)\n+                -> ty::method[] {\n+                auto meths = ~[];\n+                for (@ast::method am in anon_obj.methods) {\n+                    meths += ~[ty_of_method(ccx, am)];\n+                }\n+                ret meths;\n             }\n             auto method_types = get_anon_obj_method_types(fcx.ccx, anon_obj);\n             auto ot = ty::mk_obj(fcx.ccx.tcx, ty::sort_methods(method_types));"}, {"sha": "b928aea4655e25ab888b43e2dc73650becad9b30", "filename": "src/comp/pretty/ppaux.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6720ea760df41df82af880b593e5b6023608d6cd/src%2Fcomp%2Fpretty%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6720ea760df41df82af880b593e5b6023608d6cd/src%2Fcomp%2Fpretty%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fppaux.rs?ref=6720ea760df41df82af880b593e5b6023608d6cd", "patch": "@@ -135,9 +135,9 @@ fn ty_to_str(&ctxt cx, &t typ) -> str {\n                            ast::return, []);\n         }\n         case (ty_obj(?meths)) {\n-            auto f = bind method_to_str(cx, _);\n-            auto m = vec::map[method, str](f, meths);\n-            s += \"obj {\\n\\t\" + str::connect(m, \"\\n\\t\") + \"\\n}\";\n+            auto strs = [];\n+            for (method m in meths) { strs += [method_to_str(cx, m)]; }\n+            s += \"obj {\\n\\t\" + str::connect(strs, \"\\n\\t\") + \"\\n}\";\n         }\n         case (ty_res(?id, _, _)) {\n             s += \"<resource#\" + istr(id._0) + \":\" + istr(id._1) + \">\";"}]}