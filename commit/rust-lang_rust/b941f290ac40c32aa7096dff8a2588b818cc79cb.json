{"sha": "b941f290ac40c32aa7096dff8a2588b818cc79cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NDFmMjkwYWM0MGMzMmFhNzA5NmRmZjhhMjU4OGI4MThjYzc5Y2I=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-01-19T08:03:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-01-19T08:03:26Z"}, "message": "Rollup merge of #57501 - petrochenkov:highvar, r=alexreg\n\nHigh priority resolutions for associated variants\n\nIn https://github.com/rust-lang/rust/pull/56225 variants were assigned lowest priority during name resolution to avoid crater run and potential breakage.\n\nThis PR changes the rules to give variants highest priority instead.\nSome motivation:\n- If variants (and their constructors) are treated as associated items, then they are obviously *inherent* associated items since they don't come from traits.\n- Inherent associated items have higher priority during resolution than associated items from traits.\n- The reason is that there is a way to disambiguate in favor of trait items (`<Type as Trait>::Ambiguous`), but there's no way to disambiguate in favor of inherent items, so they became unusable in case of ambiguities if they have low priority.\n- It's technically problematic to fallback from associated types to anything until lazy normalization (?) is implemented.\n\nCrater found some regressions from this change, but they are all in type positions, e.g.\n```rust\nfn f() -> Self::Ambiguos { ... } // Variant `Ambiguous` or associated type `Ambiguous`?\n```\n, so variants are not usable there right now, but they may become usable in the future if https://github.com/rust-lang/rfcs/pull/2593 is accepted.\nThis PR keeps code like this successfully resolving, but introduces a future-compatibility lint `ambiguous_associated_items` that recommends rewriting it as `<Self as Trait>::Ambiguous`.", "tree": {"sha": "c947e7dcff5b987bbb0a07968d48c8657c31a7c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c947e7dcff5b987bbb0a07968d48c8657c31a7c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b941f290ac40c32aa7096dff8a2588b818cc79cb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcQtnOCRBK7hj4Ov3rIwAAdHIIAAt7cNJdI/PUka95az+3wdxt\nCmTko/n5DTPRFAkl7R2ZNQnR5WFyJhR68Runt4nETrqgEKlzR8rsBR327XTWj5Nr\n446jfVaz0zLnDdZuNluhxV7HvOUH77tHLy0EBuokWpEu2kc2AWb56RWKtHyEEDUd\ns2URc9tCYSCh96M8Isgmg01fQs29E9ZnLckylMSmbjHI6C5oI+vnD5r8DSRhsD4W\njRGljUVTT4s7HcKI4MrSDwE5Qq9ATusNAxDG5aUSVxZ8DCPVIHNGv705WYeF6Rx2\nNDUvtwwPrxHMzDd+QzbdVRb2ITDZFYzdH2mgwU6eBAzr9nZygn2nicaVuotZoHw=\n=u3Kg\n-----END PGP SIGNATURE-----\n", "payload": "tree c947e7dcff5b987bbb0a07968d48c8657c31a7c2\nparent c0ad9429ab8b64808672695397adf9bf7547e4b6\nparent 01d0ae96188b99c367178a38906b7269e1ada244\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1547885006 +0100\ncommitter GitHub <noreply@github.com> 1547885006 +0100\n\nRollup merge of #57501 - petrochenkov:highvar, r=alexreg\n\nHigh priority resolutions for associated variants\n\nIn https://github.com/rust-lang/rust/pull/56225 variants were assigned lowest priority during name resolution to avoid crater run and potential breakage.\n\nThis PR changes the rules to give variants highest priority instead.\nSome motivation:\n- If variants (and their constructors) are treated as associated items, then they are obviously *inherent* associated items since they don't come from traits.\n- Inherent associated items have higher priority during resolution than associated items from traits.\n- The reason is that there is a way to disambiguate in favor of trait items (`<Type as Trait>::Ambiguous`), but there's no way to disambiguate in favor of inherent items, so they became unusable in case of ambiguities if they have low priority.\n- It's technically problematic to fallback from associated types to anything until lazy normalization (?) is implemented.\n\nCrater found some regressions from this change, but they are all in type positions, e.g.\n```rust\nfn f() -> Self::Ambiguos { ... } // Variant `Ambiguous` or associated type `Ambiguous`?\n```\n, so variants are not usable there right now, but they may become usable in the future if https://github.com/rust-lang/rfcs/pull/2593 is accepted.\nThis PR keeps code like this successfully resolving, but introduces a future-compatibility lint `ambiguous_associated_items` that recommends rewriting it as `<Self as Trait>::Ambiguous`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b941f290ac40c32aa7096dff8a2588b818cc79cb", "html_url": "https://github.com/rust-lang/rust/commit/b941f290ac40c32aa7096dff8a2588b818cc79cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b941f290ac40c32aa7096dff8a2588b818cc79cb/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0ad9429ab8b64808672695397adf9bf7547e4b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0ad9429ab8b64808672695397adf9bf7547e4b6", "html_url": "https://github.com/rust-lang/rust/commit/c0ad9429ab8b64808672695397adf9bf7547e4b6"}, {"sha": "01d0ae96188b99c367178a38906b7269e1ada244", "url": "https://api.github.com/repos/rust-lang/rust/commits/01d0ae96188b99c367178a38906b7269e1ada244", "html_url": "https://github.com/rust-lang/rust/commit/01d0ae96188b99c367178a38906b7269e1ada244"}], "stats": {"total": 328, "additions": 225, "deletions": 103}, "files": [{"sha": "a0bd4f01cd231d664527304fd2e190c2719ec5fd", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=b941f290ac40c32aa7096dff8a2588b818cc79cb", "patch": "@@ -368,6 +368,12 @@ declare_lint! {\n     report_in_external_macro: true\n }\n \n+declare_lint! {\n+    pub AMBIGUOUS_ASSOCIATED_ITEMS,\n+    Warn,\n+    \"ambiguous associated items\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// that are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -433,6 +439,7 @@ impl LintPass for HardwiredLints {\n             parser::QUESTION_MARK_MACRO_SEP,\n             parser::ILL_FORMED_ATTRIBUTE_INPUT,\n             DEPRECATED_IN_FUTURE,\n+            AMBIGUOUS_ASSOCIATED_ITEMS,\n         )\n     }\n }"}, {"sha": "71c859d8dbea71fb489d0ff3364c607d1b639f83", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=b941f290ac40c32aa7096dff8a2588b818cc79cb", "patch": "@@ -341,6 +341,11 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n             reference: \"issue #57571 <https://github.com/rust-lang/rust/issues/57571>\",\n             edition: None,\n         },\n+        FutureIncompatibleInfo {\n+            id: LintId::of(AMBIGUOUS_ASSOCIATED_ITEMS),\n+            reference: \"issue #57644 <https://github.com/rust-lang/rust/issues/57644>\",\n+            edition: None,\n+        },\n         ]);\n \n     // Register renamed and removed lints."}, {"sha": "534279e981d624cd465e31b4b78a30b6388b4020", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 96, "deletions": 66, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=b941f290ac40c32aa7096dff8a2588b818cc79cb", "patch": "@@ -10,6 +10,7 @@ use hir::HirVec;\n use lint;\n use middle::resolve_lifetime as rl;\n use namespace::Namespace;\n+use rustc::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::{GenericParamDef, GenericParamDefKind};\n@@ -1278,29 +1279,50 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     }\n \n     // Create a type from a path to an associated type.\n-    // For a path `A::B::C::D`, `ty` and `ty_path_def` are the type and def for `A::B::C`\n+    // For a path `A::B::C::D`, `qself_ty` and `qself_def` are the type and def for `A::B::C`\n     // and item_segment is the path segment for `D`. We return a type and a def for\n     // the whole path.\n-    // Will fail except for `T::A` and `Self::A`; i.e., if `ty`/`ty_path_def` are not a type\n+    // Will fail except for `T::A` and `Self::A`; i.e., if `qself_ty`/`qself_def` are not a type\n     // parameter or `Self`.\n-    pub fn associated_path_def_to_ty(&self,\n-                                     ref_id: ast::NodeId,\n-                                     span: Span,\n-                                     ty: Ty<'tcx>,\n-                                     ty_path_def: Def,\n-                                     item_segment: &hir::PathSegment)\n-                                     -> (Ty<'tcx>, Def)\n-    {\n+    pub fn associated_path_to_ty(\n+        &self,\n+        ref_id: ast::NodeId,\n+        span: Span,\n+        qself_ty: Ty<'tcx>,\n+        qself_def: Def,\n+        assoc_segment: &hir::PathSegment,\n+        permit_variants: bool,\n+    ) -> (Ty<'tcx>, Def) {\n         let tcx = self.tcx();\n-        let assoc_name = item_segment.ident;\n+        let assoc_ident = assoc_segment.ident;\n \n-        debug!(\"associated_path_def_to_ty: {:?}::{}\", ty, assoc_name);\n+        debug!(\"associated_path_to_ty: {:?}::{}\", qself_ty, assoc_ident);\n \n-        self.prohibit_generics(slice::from_ref(item_segment));\n+        self.prohibit_generics(slice::from_ref(assoc_segment));\n+\n+        // Check if we have an enum variant.\n+        let mut variant_resolution = None;\n+        if let ty::Adt(adt_def, _) = qself_ty.sty {\n+            if adt_def.is_enum() {\n+                let variant_def = adt_def.variants.iter().find(|vd| {\n+                    tcx.hygienic_eq(assoc_ident, vd.ident, adt_def.did)\n+                });\n+                if let Some(variant_def) = variant_def {\n+                    let def = Def::Variant(variant_def.did);\n+                    if permit_variants {\n+                        check_type_alias_enum_variants_enabled(tcx, span);\n+                        tcx.check_stability(variant_def.did, Some(ref_id), span);\n+                        return (qself_ty, def);\n+                    } else {\n+                        variant_resolution = Some(def);\n+                    }\n+                }\n+            }\n+        }\n \n         // Find the type of the associated item, and the trait where the associated\n         // item is declared.\n-        let bound = match (&ty.sty, ty_path_def) {\n+        let bound = match (&qself_ty.sty, qself_def) {\n             (_, Def::SelfTy(Some(_), Some(impl_def_id))) => {\n                 // `Self` in an impl of a trait -- we have a concrete self type and a\n                 // trait reference.\n@@ -1313,77 +1335,61 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 };\n \n                 let candidates = traits::supertraits(tcx, ty::Binder::bind(trait_ref))\n-                    .filter(|r| self.trait_defines_associated_type_named(r.def_id(), assoc_name));\n+                    .filter(|r| self.trait_defines_associated_type_named(r.def_id(), assoc_ident));\n \n-                match self.one_bound_for_assoc_type(candidates, \"Self\", assoc_name, span) {\n+                match self.one_bound_for_assoc_type(candidates, \"Self\", assoc_ident, span) {\n                     Ok(bound) => bound,\n                     Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n             (&ty::Param(_), Def::SelfTy(Some(param_did), None)) |\n             (&ty::Param(_), Def::TyParam(param_did)) => {\n-                match self.find_bound_for_assoc_item(param_did, assoc_name, span) {\n+                match self.find_bound_for_assoc_item(param_did, assoc_ident, span) {\n                     Ok(bound) => bound,\n                     Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n-            (&ty::Adt(adt_def, _substs), Def::Enum(_did)) => {\n-                let ty_str = ty.to_string();\n-                // Incorrect enum variant.\n-                let mut err = tcx.sess.struct_span_err(\n-                    span,\n-                    &format!(\"no variant `{}` on enum `{}`\", &assoc_name.as_str(), ty_str),\n-                );\n-                // Check if it was a typo.\n-                let input = adt_def.variants.iter().map(|variant| &variant.ident.name);\n-                if let Some(suggested_name) = find_best_match_for_name(\n-                    input,\n-                    &assoc_name.as_str(),\n-                    None,\n-                ) {\n-                    err.span_suggestion_with_applicability(\n+            _ => {\n+                if variant_resolution.is_some() {\n+                    // Variant in type position\n+                    let msg = format!(\"expected type, found variant `{}`\", assoc_ident);\n+                    tcx.sess.span_err(span, &msg);\n+                } else if qself_ty.is_enum() {\n+                    // Report as incorrect enum variant rather than ambiguous type.\n+                    let mut err = tcx.sess.struct_span_err(\n                         span,\n-                        \"did you mean\",\n-                        format!(\"{}::{}\", ty_str, suggested_name.to_string()),\n-                        Applicability::MaybeIncorrect,\n+                        &format!(\"no variant `{}` on enum `{}`\", &assoc_ident.as_str(), qself_ty),\n                     );\n-                } else {\n-                    err.span_label(span, \"unknown variant\");\n-                }\n-                err.emit();\n-                return (tcx.types.err, Def::Err);\n-            }\n-            _ => {\n-                // Check if we have an enum variant.\n-                match ty.sty {\n-                    ty::Adt(adt_def, _) if adt_def.is_enum() => {\n-                        let variant_def = adt_def.variants.iter().find(|vd| {\n-                            tcx.hygienic_eq(assoc_name, vd.ident, adt_def.did)\n-                        });\n-                        if let Some(variant_def) = variant_def {\n-                            check_type_alias_enum_variants_enabled(tcx, span);\n-\n-                            let def = Def::Variant(variant_def.did);\n-                            tcx.check_stability(def.def_id(), Some(ref_id), span);\n-                            return (ty, def);\n-                        }\n-                    },\n-                    _ => (),\n-                }\n-\n-                // Don't print `TyErr` to the user.\n-                if !ty.references_error() {\n+                    // Check if it was a typo.\n+                    let adt_def = qself_ty.ty_adt_def().expect(\"enum is not an ADT\");\n+                    if let Some(suggested_name) = find_best_match_for_name(\n+                        adt_def.variants.iter().map(|variant| &variant.ident.name),\n+                        &assoc_ident.as_str(),\n+                        None,\n+                    ) {\n+                        err.span_suggestion_with_applicability(\n+                            span,\n+                            \"did you mean\",\n+                            format!(\"{}::{}\", qself_ty, suggested_name),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        err.span_label(span, \"unknown variant\");\n+                    }\n+                    err.emit();\n+                } else if !qself_ty.references_error() {\n+                    // Don't print `TyErr` to the user.\n                     self.report_ambiguous_associated_type(span,\n-                                                          &ty.to_string(),\n+                                                          &qself_ty.to_string(),\n                                                           \"Trait\",\n-                                                          &assoc_name.as_str());\n+                                                          &assoc_ident.as_str());\n                 }\n                 return (tcx.types.err, Def::Err);\n             }\n         };\n \n         let trait_did = bound.def_id();\n-        let (assoc_ident, def_scope) = tcx.adjust_ident(assoc_name, trait_did, ref_id);\n+        let (assoc_ident, def_scope) = tcx.adjust_ident(assoc_ident, trait_did, ref_id);\n         let item = tcx.associated_items(trait_did).find(|i| {\n             Namespace::from(i.kind) == Namespace::Type &&\n                 i.ident.modern() == assoc_ident\n@@ -1394,11 +1400,35 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n         let def = Def::AssociatedTy(item.def_id);\n         if !item.vis.is_accessible_from(def_scope, tcx) {\n-            let msg = format!(\"{} `{}` is private\", def.kind_name(), assoc_name);\n+            let msg = format!(\"{} `{}` is private\", def.kind_name(), assoc_ident);\n             tcx.sess.span_err(span, &msg);\n         }\n         tcx.check_stability(item.def_id, Some(ref_id), span);\n \n+        if let Some(variant_def) = variant_resolution {\n+            let mut err = tcx.struct_span_lint_node(\n+                AMBIGUOUS_ASSOCIATED_ITEMS,\n+                ref_id,\n+                span,\n+                \"ambiguous associated item\",\n+            );\n+\n+            let mut could_refer_to = |def: Def, also| {\n+                let note_msg = format!(\"`{}` could{} refer to {} defined here\",\n+                                       assoc_ident, also, def.kind_name());\n+                err.span_note(tcx.def_span(def.def_id()), &note_msg);\n+            };\n+            could_refer_to(variant_def, \"\");\n+            could_refer_to(def, \" also\");\n+\n+            err.span_suggestion_with_applicability(\n+                span,\n+                \"use fully-qualified syntax\",\n+                format!(\"<{} as {}>::{}\", qself_ty, \"Trait\", assoc_ident),\n+                Applicability::HasPlaceholders,\n+            ).emit();\n+        }\n+\n         (ty, def)\n     }\n \n@@ -1773,7 +1803,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 } else {\n                     Def::Err\n                 };\n-                self.associated_path_def_to_ty(ast_ty.id, ast_ty.span, ty, def, segment).0\n+                self.associated_path_to_ty(ast_ty.id, ast_ty.span, ty, def, segment, false).0\n             }\n             hir::TyKind::Array(ref ty, ref length) => {\n                 let length_def_id = tcx.hir().local_def_id(length.id);"}, {"sha": "e71dc019471bdc3d2cf85fc0f0ce779561e89a2f", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 26, "deletions": 35, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b941f290ac40c32aa7096dff8a2588b818cc79cb", "patch": "@@ -408,45 +408,36 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n \n-        let mode = probe::Mode::Path;\n-        match self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n-                                  self_ty, expr_id, ProbeScope::TraitsInScope) {\n-            Ok(pick) => {\n-                debug!(\"resolve_ufcs: pick={:?}\", pick);\n-                if let Some(import_id) = pick.import_id {\n-                    let import_def_id = tcx.hir().local_def_id(import_id);\n-                    debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_def_id);\n-                    Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n-                                                .unwrap().insert(import_def_id);\n+        // Check if we have an enum variant.\n+        if let ty::Adt(adt_def, _) = self_ty.sty {\n+            if adt_def.is_enum() {\n+                let variant_def = adt_def.variants.iter().find(|vd| {\n+                    tcx.hygienic_eq(method_name, vd.ident, adt_def.did)\n+                });\n+                if let Some(variant_def) = variant_def {\n+                    check_type_alias_enum_variants_enabled(tcx, span);\n+\n+                    let def = Def::VariantCtor(variant_def.did, variant_def.ctor_kind);\n+                    tcx.check_stability(def.def_id(), Some(expr_id), span);\n+                    return Ok(def);\n                 }\n-\n-                let def = pick.item.def();\n-                debug!(\"resolve_ufcs: def={:?}\", def);\n-                tcx.check_stability(def.def_id(), Some(expr_id), span);\n-\n-                Ok(def)\n             }\n-            Err(err) => {\n-                // Check if we have an enum variant.\n-                match self_ty.sty {\n-                    ty::Adt(adt_def, _) if adt_def.is_enum() => {\n-                        let variant_def = adt_def.variants.iter().find(|vd| {\n-                            tcx.hygienic_eq(method_name, vd.ident, adt_def.did)\n-                        });\n-                        if let Some(variant_def) = variant_def {\n-                            check_type_alias_enum_variants_enabled(tcx, span);\n-\n-                            let def = Def::VariantCtor(variant_def.did, variant_def.ctor_kind);\n-                            tcx.check_stability(def.def_id(), Some(expr_id), span);\n-                            return Ok(def);\n-                        }\n-                    },\n-                    _ => (),\n-                }\n+        }\n \n-                Err(err)\n-            }\n+        let pick = self.probe_for_name(span, probe::Mode::Path, method_name, IsSuggestion(false),\n+                                       self_ty, expr_id, ProbeScope::TraitsInScope)?;\n+        debug!(\"resolve_ufcs: pick={:?}\", pick);\n+        if let Some(import_id) = pick.import_id {\n+            let import_def_id = tcx.hir().local_def_id(import_id);\n+            debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_def_id);\n+            Lrc::get_mut(&mut self.tables.borrow_mut().used_trait_imports)\n+                .unwrap().insert(import_def_id);\n         }\n+\n+        let def = pick.item.def();\n+        debug!(\"resolve_ufcs: def={:?}\", def);\n+        tcx.check_stability(def.def_id(), Some(expr_id), span);\n+        Ok(def)\n     }\n \n     /// Find item with name `item_name` defined in impl/trait `def_id`"}, {"sha": "22300f2ae11ed658960d060818ea6837f8f35507", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b941f290ac40c32aa7096dff8a2588b818cc79cb", "patch": "@@ -4724,8 +4724,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 } else {\n                     Def::Err\n                 };\n-                let (ty, def) = AstConv::associated_path_def_to_ty(self, node_id, path_span,\n-                                                                   ty, def, segment);\n+                let (ty, def) = AstConv::associated_path_to_ty(self, node_id, path_span,\n+                                                               ty, def, segment, true);\n \n                 // Write back the new resolution.\n                 let hir_id = self.tcx.hir().node_to_hir_id(node_id);"}, {"sha": "295f8acf62f8539c6f134391c233f07502a00ad7", "filename": "src/test/ui/type-alias-enum-variants-priority-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority-2.rs?ref=b941f290ac40c32aa7096dff8a2588b818cc79cb", "patch": "@@ -0,0 +1,13 @@\n+#![feature(type_alias_enum_variants)]\n+\n+enum E {\n+    V(u8)\n+}\n+\n+impl E {\n+    fn V() {}\n+}\n+\n+fn main() {\n+    <E>::V(); //~ ERROR this function takes 1 parameter but 0 parameters were supplied\n+}"}, {"sha": "c6ec96ebb7d3b6e0b24d7ddf6d2431a4bf5ccb44", "filename": "src/test/ui/type-alias-enum-variants-priority-2.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority-2.stderr?ref=b941f290ac40c32aa7096dff8a2588b818cc79cb", "patch": "@@ -0,0 +1,12 @@\n+error[E0061]: this function takes 1 parameter but 0 parameters were supplied\n+  --> $DIR/type-alias-enum-variants-priority-2.rs:12:5\n+   |\n+LL |     V(u8)\n+   |     ----- defined here\n+...\n+LL |     <E>::V(); //~ ERROR this function takes 1 parameter but 0 parameters were supplied\n+   |     ^^^^^^^^ expected 1 parameter\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0061`."}, {"sha": "33f96553b57f03a79b9d16c39edec315bb61710f", "filename": "src/test/ui/type-alias-enum-variants-priority-3.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority-3.rs?ref=b941f290ac40c32aa7096dff8a2588b818cc79cb", "patch": "@@ -0,0 +1,10 @@\n+#![feature(type_alias_enum_variants)]\n+\n+enum E {\n+    V\n+}\n+\n+fn check() -> <E>::V {}\n+//~^ ERROR expected type, found variant `V`\n+\n+fn main() {}"}, {"sha": "b3451542a2570ccd7634f2d9b185f92094688a80", "filename": "src/test/ui/type-alias-enum-variants-priority-3.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority-3.stderr?ref=b941f290ac40c32aa7096dff8a2588b818cc79cb", "patch": "@@ -0,0 +1,8 @@\n+error: expected type, found variant `V`\n+  --> $DIR/type-alias-enum-variants-priority-3.rs:7:15\n+   |\n+LL | fn check() -> <E>::V {}\n+   |               ^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "db1da2b12e256645b03babf708c1905f22943d8b", "filename": "src/test/ui/type-alias-enum-variants-priority.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority.rs?ref=b941f290ac40c32aa7096dff8a2588b818cc79cb", "patch": "@@ -0,0 +1,20 @@\n+#![feature(type_alias_enum_variants)]\n+#![deny(ambiguous_associated_items)]\n+\n+enum E {\n+    V\n+}\n+\n+trait Tr {\n+    type V;\n+    fn f() -> Self::V;\n+}\n+\n+impl Tr for E {\n+    type V = u8;\n+    fn f() -> Self::V { 0 }\n+    //~^ ERROR ambiguous associated item\n+    //~| WARN this was previously accepted\n+}\n+\n+fn main() {}"}, {"sha": "dcf7dc77ed5eab21fa4ab01eb343aaf198cb2129", "filename": "src/test/ui/type-alias-enum-variants-priority.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b941f290ac40c32aa7096dff8a2588b818cc79cb/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants-priority.stderr?ref=b941f290ac40c32aa7096dff8a2588b818cc79cb", "patch": "@@ -0,0 +1,26 @@\n+error: ambiguous associated item\n+  --> $DIR/type-alias-enum-variants-priority.rs:15:15\n+   |\n+LL |     fn f() -> Self::V { 0 }\n+   |               ^^^^^^^ help: use fully-qualified syntax: `<E as Trait>::V`\n+   |\n+note: lint level defined here\n+  --> $DIR/type-alias-enum-variants-priority.rs:2:9\n+   |\n+LL | #![deny(ambiguous_associated_items)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #57644 <https://github.com/rust-lang/rust/issues/57644>\n+note: `V` could refer to variant defined here\n+  --> $DIR/type-alias-enum-variants-priority.rs:5:5\n+   |\n+LL |     V\n+   |     ^\n+note: `V` could also refer to associated type defined here\n+  --> $DIR/type-alias-enum-variants-priority.rs:9:5\n+   |\n+LL |     type V;\n+   |     ^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}