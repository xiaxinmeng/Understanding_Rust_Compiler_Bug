{"sha": "c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxY2RhMDc5M2U0ZTdiOTJhNzNjYzEzZWU2ZTRhNmIxNGExYjYzM2Y=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2014-10-27T11:58:30Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2015-02-11T12:51:21Z"}, "message": "compile-fail tests.\n\nSome compile-fail tests illustrated cases to be rejected by dropck,\nincluding ones that check cyclic data cases designed to exposed bugs\nif they are actually tricked into running by an unsound analysis.\n\nE.g. these exposed bugs in earlier broken ways of handling `Vec<T>`.\n\n(Note that all the uses of `unsafe_destructor` are just placating the\nsimple analysis used for that feature, which will eventually go away\nonce we have put the dropck through its paces.)", "tree": {"sha": "8774860c56b98570ffe6e62f76317e5ec69a67b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8774860c56b98570ffe6e62f76317e5ec69a67b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f", "html_url": "https://github.com/rust-lang/rust/commit/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4459a438c282e953bb35afb9e5829fcaeca91bad", "url": "https://api.github.com/repos/rust-lang/rust/commits/4459a438c282e953bb35afb9e5829fcaeca91bad", "html_url": "https://github.com/rust-lang/rust/commit/4459a438c282e953bb35afb9e5829fcaeca91bad"}], "stats": {"total": 663, "additions": 663, "deletions": 0}, "files": [{"sha": "0836cd1695de38e62625eca6a46143a950d20949", "filename": "src/test/compile-fail/destructor-restrictions.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fdestructor-restrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fdestructor-restrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdestructor-restrictions.rs?ref=c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests the new destructor semantics.\n+\n+use std::cell::RefCell;\n+\n+fn main() {\n+    let b = {\n+        let a = Box::new(RefCell::new(4i8));\n+        *a.borrow() + 1i8    //~ ERROR `*a` does not live long enough\n+    };\n+    println!(\"{}\", b);\n+}"}, {"sha": "3aa2fae282693fd3b42bdfe69ae64e7012c6f11a", "filename": "src/test/compile-fail/dropck_arr_cycle_checked.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_arr_cycle_checked.rs?ref=c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f", "patch": "@@ -0,0 +1,115 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reject mixing cyclic structure and Drop when using fixed length\n+// arrays.\n+//\n+// (Compare against compile-fail/dropck_vec_cycle_checked.rs)\n+\n+#![feature(unsafe_destructor)]\n+\n+use std::cell::Cell;\n+use id::Id;\n+\n+mod s {\n+    #![allow(unstable)]\n+    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+\n+    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+\n+    pub fn next_count() -> usize {\n+        S_COUNT.fetch_add(1, Ordering::SeqCst) + 1\n+    }\n+}\n+\n+mod id {\n+    use s;\n+    #[derive(Debug)]\n+    pub struct Id {\n+        orig_count: usize,\n+        count: usize,\n+    }\n+\n+    impl Id {\n+        pub fn new() -> Id {\n+            let c = s::next_count();\n+            println!(\"building Id {}\", c);\n+            Id { orig_count: c, count: c }\n+        }\n+        pub fn count(&self) -> usize {\n+            println!(\"Id::count on {} returns {}\", self.orig_count, self.count);\n+            self.count\n+        }\n+    }\n+\n+    impl Drop for Id {\n+        fn drop(&mut self) {\n+            println!(\"dropping Id {}\", self.count);\n+            self.count = 0;\n+        }\n+    }\n+}\n+\n+trait HasId {\n+    fn count(&self) -> usize;\n+}\n+\n+#[derive(Debug)]\n+struct CheckId<T:HasId> {\n+    v: T\n+}\n+\n+#[allow(non_snake_case)]\n+fn CheckId<T:HasId>(t: T) -> CheckId<T> { CheckId{ v: t } }\n+\n+#[unsafe_destructor]\n+impl<T:HasId> Drop for CheckId<T> {\n+    fn drop(&mut self) {\n+        assert!(self.v.count() > 0);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct B<'a> {\n+    id: Id,\n+    a: [CheckId<Cell<Option<&'a B<'a>>>>; 2]\n+}\n+\n+impl<'a> HasId for Cell<Option<&'a B<'a>>> {\n+    fn count(&self) -> usize {\n+        match self.get() {\n+            None => 1,\n+            Some(b) => b.id.count(),\n+        }\n+    }\n+}\n+\n+impl<'a> B<'a> {\n+    fn new() -> B<'a> {\n+        B { id: Id::new(), a: [CheckId(Cell::new(None)), CheckId(Cell::new(None))] }\n+    }\n+}\n+\n+fn f() {\n+    let (b1, b2, b3);\n+    b1 = B::new();\n+    b2 = B::new();\n+    b3 = B::new();\n+    b1.a[0].v.set(Some(&b2)); //~ ERROR `b2` does not live long enough\n+    b1.a[1].v.set(Some(&b3)); //~ ERROR `b3` does not live long enough\n+    b2.a[0].v.set(Some(&b2)); //~ ERROR `b2` does not live long enough\n+    b2.a[1].v.set(Some(&b3)); //~ ERROR `b3` does not live long enough\n+    b3.a[0].v.set(Some(&b1)); //~ ERROR `b1` does not live long enough\n+    b3.a[1].v.set(Some(&b2)); //~ ERROR `b2` does not live long enough\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "b9df71322ad83a240b2d95ae5a0a2dd6cdf10e0a", "filename": "src/test/compile-fail/dropck_direct_cycle_with_drop.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fdropck_direct_cycle_with_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fdropck_direct_cycle_with_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_direct_cycle_with_drop.rs?ref=c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A simple example of an unsound mixing of cyclic structure and Drop.\n+//\n+// Each `D` has a name and an optional reference to another `D`\n+// sibling, but also implements a drop method that prints out its own\n+// name as well as the name of its sibling.\n+//\n+// By setting up a cyclic structure, the drop code cannot possibly\n+// work. Therefore this code must be rejected.\n+//\n+// (As it turns out, essentially any attempt to install a sibling here\n+//  will be rejected, regardless of whether it forms a cyclic\n+//  structure or not. This is because the use of the same lifetime\n+//  `'a` in `&'a D<'a>` cannot be satisfied when `D<'a>` implements\n+//  `Drop`.)\n+\n+#![feature(unsafe_destructor)]\n+\n+use std::cell::Cell;\n+\n+struct D<'a> {\n+    name: String,\n+    p: Cell<Option<&'a D<'a>>>,\n+}\n+\n+impl<'a> D<'a> {\n+    fn new(name: String) -> D<'a> { D { name: name, p: Cell::new(None) } }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for D<'a> {\n+    fn drop(&mut self) {\n+        println!(\"dropping {} whose sibling is {:?}\",\n+                 self.name, self.p.get().map(|d| &d.name));\n+    }\n+}\n+\n+fn g() {\n+    let (d1, d2) = (D::new(format!(\"d1\")), D::new(format!(\"d2\")));\n+    d1.p.set(Some(&d2)); //~ ERROR `d2` does not live long enough\n+    d2.p.set(Some(&d1)); //~ ERROR `d1` does not live long enough\n+}\n+\n+fn main() {\n+    g();\n+}"}, {"sha": "74e3c724b676daa75bec403ad02e31762476faed", "filename": "src/test/compile-fail/dropck_tarena_cycle_checked.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_cycle_checked.rs?ref=c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f", "patch": "@@ -0,0 +1,130 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reject mixing cyclic structure and Drop when using TypedArena.\n+//\n+// (Compare against compile-fail/dropck_vec_cycle_checked.rs)\n+//\n+// (Also compare against compile-fail/dropck_tarena_unsound_drop.rs,\n+//  which is a reduction of this code to more directly show the reason\n+//  for the error message we see here.)\n+\n+#![allow(unstable)]\n+#![feature(unsafe_destructor)]\n+\n+extern crate arena;\n+\n+use arena::TypedArena;\n+use std::cell::Cell;\n+use id::Id;\n+\n+mod s {\n+    #![allow(unstable)]\n+    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+\n+    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+\n+    pub fn next_count() -> usize {\n+        S_COUNT.fetch_add(1, Ordering::SeqCst) + 1\n+    }\n+}\n+\n+mod id {\n+    use s;\n+    #[derive(Debug)]\n+    pub struct Id {\n+        orig_count: usize,\n+        count: usize,\n+    }\n+\n+    impl Id {\n+        pub fn new() -> Id {\n+            let c = s::next_count();\n+            println!(\"building Id {}\", c);\n+            Id { orig_count: c, count: c }\n+        }\n+        pub fn count(&self) -> usize {\n+            println!(\"Id::count on {} returns {}\", self.orig_count, self.count);\n+            self.count\n+        }\n+    }\n+\n+    impl Drop for Id {\n+        fn drop(&mut self) {\n+            println!(\"dropping Id {}\", self.count);\n+            self.count = 0;\n+        }\n+    }\n+}\n+\n+trait HasId {\n+    fn count(&self) -> usize;\n+}\n+\n+#[derive(Debug)]\n+struct CheckId<T:HasId> {\n+    v: T\n+}\n+\n+#[allow(non_snake_case)]\n+fn CheckId<T:HasId>(t: T) -> CheckId<T> { CheckId{ v: t } }\n+\n+#[unsafe_destructor]\n+impl<T:HasId> Drop for CheckId<T> {\n+    fn drop(&mut self) {\n+        assert!(self.v.count() > 0);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct C<'a> {\n+    id: Id,\n+    v: Vec<CheckId<Cell<Option<&'a C<'a>>>>>,\n+}\n+\n+impl<'a> HasId for Cell<Option<&'a C<'a>>> {\n+    fn count(&self) -> usize {\n+        match self.get() {\n+            None => 1,\n+            Some(c) => c.id.count(),\n+        }\n+    }\n+}\n+\n+impl<'a> C<'a> {\n+    fn new() -> C<'a> {\n+        C { id: Id::new(), v: Vec::new() }\n+    }\n+}\n+\n+fn f<'a>(arena: &'a TypedArena<C<'a>>) {\n+    let c1 = arena.alloc(C::new());\n+    let c2 = arena.alloc(C::new());\n+    let c3 = arena.alloc(C::new());\n+\n+    c1.v.push(CheckId(Cell::new(None)));\n+    c1.v.push(CheckId(Cell::new(None)));\n+    c2.v.push(CheckId(Cell::new(None)));\n+    c2.v.push(CheckId(Cell::new(None)));\n+    c3.v.push(CheckId(Cell::new(None)));\n+    c3.v.push(CheckId(Cell::new(None)));\n+\n+    c1.v[0].v.set(Some(c2));\n+    c1.v[1].v.set(Some(c3));\n+    c2.v[0].v.set(Some(c2));\n+    c2.v[1].v.set(Some(c3));\n+    c3.v[0].v.set(Some(c1));\n+    c3.v[1].v.set(Some(c2));\n+}\n+\n+fn main() {\n+    let arena = TypedArena::new();\n+    f(&arena); //~ ERROR `arena` does not live long enough\n+}"}, {"sha": "64d77e97fa7f6f2f49def9a47c6a67bf20b54c9f", "filename": "src/test/compile-fail/dropck_tarena_unsound_drop.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_unsound_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_unsound_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_tarena_unsound_drop.rs?ref=c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that a arena (TypedArena) cannot carry elements whose drop\n+// methods might access borrowed data of lifetime that does not\n+// strictly outlive the arena itself.\n+//\n+// Compare against run-pass/dropck_tarena_sound_drop.rs, which shows a\n+// similar setup, but loosens `f` so that the struct `C<'a>` can be\n+// fed a lifetime longer than that of the arena.\n+//\n+// (Also compare against dropck_tarena_cycle_checked.rs, from which\n+// this was reduced to better understand its error message.)\n+\n+#![allow(unstable)]\n+#![feature(unsafe_destructor)]\n+\n+extern crate arena;\n+\n+use arena::TypedArena;\n+\n+trait HasId { fn count(&self) -> usize; }\n+\n+struct CheckId<T:HasId> { v: T }\n+\n+// In the code below, the impl of HasId for `&'a usize` does not\n+// actually access the borrowed data, but the point is that the\n+// interface to CheckId does not (and cannot) know that, and therefore\n+// when encountering the a value V of type CheckId<S>, we must\n+// conservatively force the type S to strictly outlive V.\n+#[unsafe_destructor]\n+impl<T:HasId> Drop for CheckId<T> {\n+    fn drop(&mut self) {\n+        assert!(self.v.count() > 0);\n+    }\n+}\n+\n+struct C<'a> { v: CheckId<&'a usize>, }\n+\n+impl<'a> HasId for &'a usize { fn count(&self) -> usize { 1 } }\n+\n+fn f<'a>(_arena: &'a TypedArena<C<'a>>) {}\n+\n+fn main() {\n+    let arena: TypedArena<C> = TypedArena::new();\n+    f(&arena); //~ ERROR `arena` does not live long enough\n+}"}, {"sha": "3f69c7d1a9c3ee1755f3bb3682fcf9b5be7ba572", "filename": "src/test/compile-fail/dropck_vec_cycle_checked.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_vec_cycle_checked.rs?ref=c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f", "patch": "@@ -0,0 +1,122 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reject mixing cyclic structure and Drop when using Vec.\n+//\n+// (Compare against compile-fail/dropck_arr_cycle_checked.rs)\n+\n+#![feature(unsafe_destructor)]\n+\n+use std::cell::Cell;\n+use id::Id;\n+\n+mod s {\n+    #![allow(unstable)]\n+    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+\n+    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+\n+    pub fn next_count() -> usize {\n+        S_COUNT.fetch_add(1, Ordering::SeqCst) + 1\n+    }\n+}\n+\n+mod id {\n+    use s;\n+    #[derive(Debug)]\n+    pub struct Id {\n+        orig_count: usize,\n+        count: usize,\n+    }\n+\n+    impl Id {\n+        pub fn new() -> Id {\n+            let c = s::next_count();\n+            println!(\"building Id {}\", c);\n+            Id { orig_count: c, count: c }\n+        }\n+        pub fn count(&self) -> usize {\n+            println!(\"Id::count on {} returns {}\", self.orig_count, self.count);\n+            self.count\n+        }\n+    }\n+\n+    impl Drop for Id {\n+        fn drop(&mut self) {\n+            println!(\"dropping Id {}\", self.count);\n+            self.count = 0;\n+        }\n+    }\n+}\n+\n+trait HasId {\n+    fn count(&self) -> usize;\n+}\n+\n+#[derive(Debug)]\n+struct CheckId<T:HasId> {\n+    v: T\n+}\n+\n+#[allow(non_snake_case)]\n+fn CheckId<T:HasId>(t: T) -> CheckId<T> { CheckId{ v: t } }\n+\n+#[unsafe_destructor]\n+impl<T:HasId> Drop for CheckId<T> {\n+    fn drop(&mut self) {\n+        assert!(self.v.count() > 0);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct C<'a> {\n+    id: Id,\n+    v: Vec<CheckId<Cell<Option<&'a C<'a>>>>>,\n+}\n+\n+impl<'a> HasId for Cell<Option<&'a C<'a>>> {\n+    fn count(&self) -> usize {\n+        match self.get() {\n+            None => 1,\n+            Some(c) => c.id.count(),\n+        }\n+    }\n+}\n+\n+impl<'a> C<'a> {\n+    fn new() -> C<'a> {\n+        C { id: Id::new(), v: Vec::new() }\n+    }\n+}\n+\n+fn f() {\n+    let (mut c1, mut c2, mut c3);\n+    c1 = C::new();\n+    c2 = C::new();\n+    c3 = C::new();\n+\n+    c1.v.push(CheckId(Cell::new(None)));\n+    c1.v.push(CheckId(Cell::new(None)));\n+    c2.v.push(CheckId(Cell::new(None)));\n+    c2.v.push(CheckId(Cell::new(None)));\n+    c3.v.push(CheckId(Cell::new(None)));\n+    c3.v.push(CheckId(Cell::new(None)));\n+\n+    c1.v[0].v.set(Some(&c2)); //~ ERROR `c2` does not live long enough\n+    c1.v[1].v.set(Some(&c3)); //~ ERROR `c3` does not live long enough\n+    c2.v[0].v.set(Some(&c2)); //~ ERROR `c2` does not live long enough\n+    c2.v[1].v.set(Some(&c3)); //~ ERROR `c3` does not live long enough\n+    c3.v[0].v.set(Some(&c1)); //~ ERROR `c1` does not live long enough\n+    c3.v[1].v.set(Some(&c2)); //~ ERROR `c2` does not live long enough\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "6aaf51278afd8ac1d1c77294b8789f617b90d83f", "filename": "src/test/compile-fail/vec-must-not-hide-type-from-dropck.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-must-not-hide-type-from-dropck.rs?ref=c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Checking that `Vec<T>` cannot hide lifetimes within `T` when `T`\n+// implements `Drop` and might access methods of values that have\n+// since been deallocated.\n+//\n+// In this case, the values in question hold (non-zero) unique-ids\n+// that zero themselves out when dropped, and are wrapped in another\n+// type with a destructor that asserts that the ids it references are\n+// indeed non-zero (i.e., effectively checking that the id's are not\n+// dropped while there are still any outstanding references).\n+//\n+// However, the values in question are also formed into a\n+// cyclic-structure, ensuring that there is no way for all of the\n+// conditions above to be satisfied, meaning that if the dropck is\n+// sound, it should reject this code.\n+\n+#![feature(unsafe_destructor)]\n+\n+use std::cell::Cell;\n+use id::Id;\n+\n+mod s {\n+    #![allow(unstable)]\n+    use std::sync::atomic::{AtomicUint, ATOMIC_UINT_INIT, Ordering};\n+\n+    static S_COUNT: AtomicUint = ATOMIC_UINT_INIT;\n+\n+    /// generates globally unique count (global across the current\n+    /// process, that is)\n+    pub fn next_count() -> usize {\n+        S_COUNT.fetch_add(1, Ordering::SeqCst) + 1\n+    }\n+}\n+\n+mod id {\n+    use s;\n+\n+    /// Id represents a globally unique identifier (global across the\n+    /// current process, that is). When dropped, it automatically\n+    /// clears its `count` field, but leaves `orig_count` untouched,\n+    /// so that if there are subsequent (erroneous) invocations of its\n+    /// method (which is unsound), we can observe it by seeing that\n+    /// the `count` is 0 while the `orig_count` is non-zero.\n+    #[derive(Debug)]\n+    pub struct Id {\n+        orig_count: usize,\n+        count: usize,\n+    }\n+\n+    impl Id {\n+        /// Creates an `Id` with a globally unique count.\n+        pub fn new() -> Id {\n+            let c = s::next_count();\n+            println!(\"building Id {}\", c);\n+            Id { orig_count: c, count: c }\n+        }\n+        /// returns the `count` of self; should be non-zero if\n+        /// everything is working.\n+        pub fn count(&self) -> usize {\n+            println!(\"Id::count on {} returns {}\", self.orig_count, self.count);\n+            self.count\n+        }\n+    }\n+\n+    impl Drop for Id {\n+        fn drop(&mut self) {\n+            println!(\"dropping Id {}\", self.count);\n+            self.count = 0;\n+        }\n+    }\n+}\n+\n+trait HasId {\n+    fn count(&self) -> usize;\n+}\n+\n+#[derive(Debug)]\n+struct CheckId<T:HasId> {\n+    v: T\n+}\n+\n+#[allow(non_snake_case)]\n+fn CheckId<T:HasId>(t: T) -> CheckId<T> { CheckId{ v: t } }\n+\n+#[unsafe_destructor]\n+impl<T:HasId> Drop for CheckId<T> {\n+    fn drop(&mut self) {\n+        assert!(self.v.count() > 0);\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct C<'a> {\n+    id: Id,\n+    v: Vec<CheckId<Cell<Option<&'a C<'a>>>>>,\n+}\n+\n+impl<'a> HasId for Cell<Option<&'a C<'a>>> {\n+    fn count(&self) -> usize {\n+        match self.get() {\n+            None => 1,\n+            Some(c) => c.id.count(),\n+        }\n+    }\n+}\n+\n+impl<'a> C<'a> {\n+    fn new() -> C<'a> {\n+        C { id: Id::new(), v: Vec::new() }\n+    }\n+}\n+\n+fn f() {\n+    let (mut c1, mut c2);\n+    c1 = C::new();\n+    c2 = C::new();\n+\n+    c1.v.push(CheckId(Cell::new(None)));\n+    c2.v.push(CheckId(Cell::new(None)));\n+    c1.v[0].v.set(Some(&c2)); //~ ERROR `c2` does not live long enough\n+    c2.v[0].v.set(Some(&c1)); //~ ERROR `c1` does not live long enough\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "a191b3e56c41754fd3274c0be3ecca3cb7c63e54", "filename": "src/test/compile-fail/vec_refs_data_with_early_death.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fvec_refs_data_with_early_death.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f/src%2Ftest%2Fcompile-fail%2Fvec_refs_data_with_early_death.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec_refs_data_with_early_death.rs?ref=c1cda0793e4e7b92a73cc13ee6e4a6b14a1b633f", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test is a simple example of code that violates the dropck\n+// rules: it pushes `&x` and `&y` into `v`, but the referenced data\n+// will be dropped before the vector itself is.\n+\n+// (In principle we know that `Vec` does not reference the data it\n+//  owns from within its drop code, apart from calling drop on each\n+//  element it owns; thus, for data like this, it seems like we could\n+//  loosen the restrictions here if we wanted. But it also is not\n+//  clear whether such loosening is terribly important.)\n+\n+fn main() {\n+    let mut v = Vec::new();\n+\n+    let x: i8 = 3;\n+    let y: i8 = 4;\n+\n+    v.push(&x); //~ ERROR `x` does not live long enough\n+    v.push(&y); //~ ERROR `y` does not live long enough\n+\n+    assert_eq!(v.as_slice(), [&3, &4]);\n+}"}]}