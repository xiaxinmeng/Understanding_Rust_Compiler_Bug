{"sha": "95c2ad37e141a62f184f49dc7a6f12840b67b826", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1YzJhZDM3ZTE0MWE2MmYxODRmNDlkYzdhNmYxMjg0MGI2N2I4MjY=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2019-05-26T12:15:38Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2019-05-26T12:15:38Z"}, "message": "Refactor rewrite_where_clause", "tree": {"sha": "16b59b6160e93192fb7a9a8949fc5746bfddd9e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16b59b6160e93192fb7a9a8949fc5746bfddd9e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95c2ad37e141a62f184f49dc7a6f12840b67b826", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95c2ad37e141a62f184f49dc7a6f12840b67b826", "html_url": "https://github.com/rust-lang/rust/commit/95c2ad37e141a62f184f49dc7a6f12840b67b826", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95c2ad37e141a62f184f49dc7a6f12840b67b826/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "264417e10d4c5fb079ebd807ccfc905fd8eb9386", "url": "https://api.github.com/repos/rust-lang/rust/commits/264417e10d4c5fb079ebd807ccfc905fd8eb9386", "html_url": "https://github.com/rust-lang/rust/commit/264417e10d4c5fb079ebd807ccfc905fd8eb9386"}], "stats": {"total": 205, "additions": 136, "deletions": 69}, "files": [{"sha": "d39a0bb528b31ff4c62329b43463c046d306785a", "filename": "src/items.rs", "status": "modified", "additions": 136, "deletions": 69, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/95c2ad37e141a62f184f49dc7a6f12840b67b826/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c2ad37e141a62f184f49dc7a6f12840b67b826/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=95c2ad37e141a62f184f49dc7a6f12840b67b826", "patch": "@@ -693,7 +693,7 @@ pub(crate) fn format_impl(\n         {\n             option.suppress_comma();\n             option.snuggle();\n-            option.compress_where();\n+            option.allow_single_line();\n         }\n \n         let misssing_span = mk_sp(self_ty.span.hi(), item.span.hi());\n@@ -708,7 +708,6 @@ pub(crate) fn format_impl(\n             where_span_end,\n             self_ty.span.hi(),\n             option,\n-            false,\n         )?;\n \n         // If there is no where-clause, we may have missing comments between the trait name and\n@@ -1068,7 +1067,6 @@ pub(crate) fn format_trait(\n                 None,\n                 pos_before_where,\n                 option,\n-                false,\n             )?;\n             // If the where-clause cannot fit on the same line,\n             // put the where-clause on a new line\n@@ -1376,7 +1374,7 @@ fn format_tuple_struct(\n             result.push_str(&generics_str);\n \n             let where_budget = context.budget(last_line_width(&result));\n-            let option = WhereClauseOption::new(true, false);\n+            let option = WhereClauseOption::new(true, WhereClauseSpace::Newline);\n             rewrite_where_clause(\n                 context,\n                 &generics.where_clause,\n@@ -1387,7 +1385,6 @@ fn format_tuple_struct(\n                 None,\n                 body_hi,\n                 option,\n-                false,\n             )?\n         }\n         None => \"\".to_owned(),\n@@ -1464,7 +1461,6 @@ fn rewrite_type_prefix(\n         None,\n         generics.span.hi(),\n         option,\n-        false,\n     )?;\n     result.push_str(&where_clause_str);\n \n@@ -2205,7 +2201,15 @@ fn rewrite_fn_base(\n \n     let is_args_multi_lined = arg_str.contains('\\n');\n \n-    let option = WhereClauseOption::new(!has_body, put_args_in_block && ret_str.is_empty());\n+    let space = if put_args_in_block && ret_str.is_empty() {\n+        WhereClauseSpace::Space\n+    } else {\n+        WhereClauseSpace::Newline\n+    };\n+    let mut option = WhereClauseOption::new(!has_body, space);\n+    if is_args_multi_lined {\n+        option.veto_single_line();\n+    }\n     let where_clause_str = rewrite_where_clause(\n         context,\n         where_clause,\n@@ -2216,7 +2220,6 @@ fn rewrite_fn_base(\n         Some(span.hi()),\n         pos_before_where,\n         option,\n-        is_args_multi_lined,\n     )?;\n     // If there are neither where-clause nor return type, we may be missing comments between\n     // args and `{`.\n@@ -2244,40 +2247,62 @@ fn rewrite_fn_base(\n     Some((result, force_new_line_for_brace))\n }\n \n+/// Kind of spaces to put before `where`.\n+#[derive(Copy, Clone)]\n+enum WhereClauseSpace {\n+    /// A single space.\n+    Space,\n+    /// A new line.\n+    Newline,\n+    /// Nothing.\n+    None,\n+}\n+\n #[derive(Copy, Clone)]\n struct WhereClauseOption {\n     suppress_comma: bool, // Force no trailing comma\n-    snuggle: bool,        // Do not insert newline before `where`\n-    compress_where: bool, // Try single line where-clause instead of vertical layout\n+    snuggle: WhereClauseSpace,\n+    allow_single_line: bool, // Try single line where-clause instead of vertical layout\n+    veto_single_line: bool,  // Disallow a single-line where-clause.\n }\n \n impl WhereClauseOption {\n-    fn new(suppress_comma: bool, snuggle: bool) -> WhereClauseOption {\n+    fn new(suppress_comma: bool, snuggle: WhereClauseSpace) -> WhereClauseOption {\n         WhereClauseOption {\n             suppress_comma,\n             snuggle,\n-            compress_where: false,\n+            allow_single_line: false,\n+            veto_single_line: false,\n         }\n     }\n \n     fn snuggled(current: &str) -> WhereClauseOption {\n         WhereClauseOption {\n             suppress_comma: false,\n-            snuggle: last_line_width(current) == 1,\n-            compress_where: false,\n+            snuggle: if last_line_width(current) == 1 {\n+                WhereClauseSpace::Space\n+            } else {\n+                WhereClauseSpace::Newline\n+            },\n+            allow_single_line: false,\n+            veto_single_line: false,\n         }\n     }\n \n     fn suppress_comma(&mut self) {\n         self.suppress_comma = true\n     }\n \n-    fn compress_where(&mut self) {\n-        self.compress_where = true\n+    fn allow_single_line(&mut self) {\n+        self.allow_single_line = true\n     }\n \n     fn snuggle(&mut self) {\n-        self.snuggle = true\n+        self.snuggle = WhereClauseSpace::Space\n+    }\n+\n+    fn veto_single_line(&mut self) {\n+        self.veto_single_line = true;\n     }\n }\n \n@@ -2467,25 +2492,104 @@ fn rewrite_where_clause_rfc_style(\n     span_end: Option<BytePos>,\n     span_end_before_where: BytePos,\n     where_clause_option: WhereClauseOption,\n-    is_args_multi_line: bool,\n ) -> Option<String> {\n+    let (where_keyword, allow_single_line) = rewrite_where_keyword(\n+        context,\n+        where_clause,\n+        shape,\n+        span_end_before_where,\n+        where_clause_option,\n+    )?;\n+\n+    // 1 = `,`\n+    let clause_shape = shape\n+        .block()\n+        .with_max_width(context.config)\n+        .block_left(context.config.tab_spaces())?\n+        .sub_width(1)?;\n+    let force_single_line = context.config.where_single_line()\n+        && where_clause.predicates.len() == 1\n+        && !where_clause_option.veto_single_line;\n+\n+    let preds_str = rewrite_bounds_on_where_clause(\n+        context,\n+        where_clause,\n+        clause_shape,\n+        terminator,\n+        span_end,\n+        where_clause_option,\n+        force_single_line,\n+    )?;\n+\n+    // 6 = `where `\n+    let clause_sep =\n+        if allow_single_line && !preds_str.contains('\\n') && 6 + preds_str.len() <= shape.width\n+            || force_single_line\n+        {\n+            Cow::from(\" \")\n+        } else {\n+            clause_shape.indent.to_string_with_newline(context.config)\n+        };\n+\n+    Some(format!(\"{}{}{}\", where_keyword, clause_sep, preds_str))\n+}\n+\n+/// Rewrite `where` and comment around it.\n+fn rewrite_where_keyword(\n+    context: &RewriteContext<'_>,\n+    where_clause: &ast::WhereClause,\n+    shape: Shape,\n+    span_end_before_where: BytePos,\n+    where_clause_option: WhereClauseOption,\n+) -> Option<(String, bool)> {\n     let block_shape = shape.block().with_max_width(context.config);\n+    // 1 = `,`\n+    let clause_shape = block_shape\n+        .block_left(context.config.tab_spaces())?\n+        .sub_width(1)?;\n+\n+    let comment_separator = |comment: &str, shape: Shape| {\n+        if comment.is_empty() {\n+            Cow::from(\"\")\n+        } else {\n+            shape.indent.to_string_with_newline(context.config)\n+        }\n+    };\n \n     let (span_before, span_after) =\n         missing_span_before_after_where(span_end_before_where, where_clause);\n     let (comment_before, comment_after) =\n         rewrite_comments_before_after_where(context, span_before, span_after, shape)?;\n \n-    let starting_newline = if where_clause_option.snuggle && comment_before.is_empty() {\n-        Cow::from(\" \")\n-    } else {\n-        block_shape.indent.to_string_with_newline(context.config)\n+    let starting_newline = match where_clause_option.snuggle {\n+        WhereClauseSpace::Space if comment_before.is_empty() => Cow::from(\" \"),\n+        WhereClauseSpace::None => Cow::from(\"\"),\n+        _ => block_shape.indent.to_string_with_newline(context.config),\n     };\n \n-    let clause_shape = block_shape.block_left(context.config.tab_spaces())?;\n-    // 1 = `,`\n-    let clause_shape = clause_shape.sub_width(1)?;\n-    // each clause on one line, trailing comma (except if suppress_comma)\n+    let newline_before_where = comment_separator(&comment_before, shape);\n+    let newline_after_where = comment_separator(&comment_after, clause_shape);\n+    let result = format!(\n+        \"{}{}{}where{}{}\",\n+        starting_newline, comment_before, newline_before_where, newline_after_where, comment_after\n+    );\n+    let allow_single_line = where_clause_option.allow_single_line\n+        && comment_before.is_empty()\n+        && comment_after.is_empty();\n+\n+    Some((result, allow_single_line))\n+}\n+\n+/// Rewrite bounds on a where clause.\n+fn rewrite_bounds_on_where_clause(\n+    context: &RewriteContext<'_>,\n+    where_clause: &ast::WhereClause,\n+    shape: Shape,\n+    terminator: &str,\n+    span_end: Option<BytePos>,\n+    where_clause_option: WhereClauseOption,\n+    force_single_line: bool,\n+) -> Option<String> {\n     let span_start = where_clause.predicates[0].span().lo();\n     // If we don't have the start of the next span, then use the end of the\n     // predicates, but that means we miss comments.\n@@ -2499,64 +2603,30 @@ fn rewrite_where_clause_rfc_style(\n         \",\",\n         |pred| pred.span().lo(),\n         |pred| pred.span().hi(),\n-        |pred| pred.rewrite(context, clause_shape),\n+        |pred| pred.rewrite(context, shape),\n         span_start,\n         span_end,\n         false,\n     );\n-    let where_single_line = context.config.where_single_line() && len == 1 && !is_args_multi_line;\n-    let comma_tactic = if where_clause_option.suppress_comma || where_single_line {\n+    let comma_tactic = if where_clause_option.suppress_comma || force_single_line {\n         SeparatorTactic::Never\n     } else {\n         context.config.trailing_comma()\n     };\n \n-    // shape should be vertical only and only if we have `where_single_line` option enabled\n+    // shape should be vertical only and only if we have `force_single_line` option enabled\n     // and the number of items of the where-clause is equal to 1\n-    let shape_tactic = if where_single_line {\n+    let shape_tactic = if force_single_line {\n         DefinitiveListTactic::Horizontal\n     } else {\n         DefinitiveListTactic::Vertical\n     };\n \n-    let fmt = ListFormatting::new(clause_shape, context.config)\n+    let fmt = ListFormatting::new(shape, context.config)\n         .tactic(shape_tactic)\n         .trailing_separator(comma_tactic)\n         .preserve_newline(true);\n-    let preds_str = write_list(&items.collect::<Vec<_>>(), &fmt)?;\n-\n-    let comment_separator = |comment: &str, shape: Shape| {\n-        if comment.is_empty() {\n-            Cow::from(\"\")\n-        } else {\n-            shape.indent.to_string_with_newline(context.config)\n-        }\n-    };\n-    let newline_before_where = comment_separator(&comment_before, shape);\n-    let newline_after_where = comment_separator(&comment_after, clause_shape);\n-\n-    // 6 = `where `\n-    let clause_sep = if where_clause_option.compress_where\n-        && comment_before.is_empty()\n-        && comment_after.is_empty()\n-        && !preds_str.contains('\\n')\n-        && 6 + preds_str.len() <= shape.width\n-        || where_single_line\n-    {\n-        Cow::from(\" \")\n-    } else {\n-        clause_shape.indent.to_string_with_newline(context.config)\n-    };\n-    Some(format!(\n-        \"{}{}{}where{}{}{}{}\",\n-        starting_newline,\n-        comment_before,\n-        newline_before_where,\n-        newline_after_where,\n-        comment_after,\n-        clause_sep,\n-        preds_str\n-    ))\n+    write_list(&items.collect::<Vec<_>>(), &fmt)\n }\n \n fn rewrite_where_clause(\n@@ -2569,7 +2639,6 @@ fn rewrite_where_clause(\n     span_end: Option<BytePos>,\n     span_end_before_where: BytePos,\n     where_clause_option: WhereClauseOption,\n-    is_args_multi_line: bool,\n ) -> Option<String> {\n     if where_clause.predicates.is_empty() {\n         return Some(String::new());\n@@ -2584,7 +2653,6 @@ fn rewrite_where_clause(\n             span_end,\n             span_end_before_where,\n             where_clause_option,\n-            is_args_multi_line,\n         );\n     }\n \n@@ -2742,7 +2810,6 @@ fn format_generics(\n             Some(span.hi()),\n             span_end_before_where,\n             option,\n-            false,\n         )?;\n         result.push_str(&where_clause_str);\n         ("}]}