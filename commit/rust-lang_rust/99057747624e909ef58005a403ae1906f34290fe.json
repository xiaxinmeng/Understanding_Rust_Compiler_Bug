{"sha": "99057747624e909ef58005a403ae1906f34290fe", "node_id": "C_kwDOAAsO6NoAKDk5MDU3NzQ3NjI0ZTkwOWVmNTgwMDVhNDAzYWUxOTA2ZjM0MjkwZmU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-16T17:42:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-16T17:42:05Z"}, "message": "Rollup merge of #96058 - euclio:flock-impls, r=nagisa\n\nseparate flock implementations into separate modules\n\nThe main benefit of doing this is that rustfmt will now format each of these modules.", "tree": {"sha": "17301f6318dfbe6a07e331f048411d966f67c627", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17301f6318dfbe6a07e331f048411d966f67c627"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99057747624e909ef58005a403ae1906f34290fe", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiWv/tCRBK7hj4Ov3rIwAANdsIAE1LW4wJiEh8Xvpp5k+U+X9b\n+88MSqG7MGVtEjl5nlnXlnCD+UZNkNxdNrDgL7TOw60BPpiDlznYUfQ2cmzyIOHh\nnSjkwXE3eLz3dw0sMaSM7z8+WAqDlbtGvmEmm8uKZ1XV9gcrBP4HYzljomuZavab\nbefsMN4spwN+gBE0ti61zLuKrtxXvZsapYwlJ8BoIL2flPXQJ/Fc8kKXljYdmFcF\n5zTxe6ewRJzMFqyl/dnD1mxC//lnR8BpfDUAEyW2LoyvFLtYwcBuQDHdK0w5q8HP\n0bFKnRhNvDUC/IdkflcWEM5DvSWfASliqTbSO/nomDtJCYfFtmHAtJ37lNL8HGI=\n=QCaQ\n-----END PGP SIGNATURE-----\n", "payload": "tree 17301f6318dfbe6a07e331f048411d966f67c627\nparent a84a811943c3f1986eaf82bbecc33201bc4ae8c9\nparent 219d81f19bd902e280fe6f5f40aded185db7ba0a\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1650130925 +0200\ncommitter GitHub <noreply@github.com> 1650130925 +0200\n\nRollup merge of #96058 - euclio:flock-impls, r=nagisa\n\nseparate flock implementations into separate modules\n\nThe main benefit of doing this is that rustfmt will now format each of these modules.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99057747624e909ef58005a403ae1906f34290fe", "html_url": "https://github.com/rust-lang/rust/commit/99057747624e909ef58005a403ae1906f34290fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99057747624e909ef58005a403ae1906f34290fe/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a84a811943c3f1986eaf82bbecc33201bc4ae8c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a84a811943c3f1986eaf82bbecc33201bc4ae8c9", "html_url": "https://github.com/rust-lang/rust/commit/a84a811943c3f1986eaf82bbecc33201bc4ae8c9"}, {"sha": "219d81f19bd902e280fe6f5f40aded185db7ba0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/219d81f19bd902e280fe6f5f40aded185db7ba0a", "html_url": "https://github.com/rust-lang/rust/commit/219d81f19bd902e280fe6f5f40aded185db7ba0a"}], "stats": {"total": 409, "additions": 194, "deletions": 215}, "files": [{"sha": "e395d8dbbbf8b2dea18c1f29a3cfdab2d21ffcd5", "filename": "compiler/rustc_data_structures/src/flock.rs", "status": "modified", "additions": 10, "deletions": 215, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/99057747624e909ef58005a403ae1906f34290fe/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99057747624e909ef58005a403ae1906f34290fe/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock.rs?ref=99057747624e909ef58005a403ae1906f34290fe", "patch": "@@ -7,225 +7,20 @@\n #![allow(non_camel_case_types)]\n #![allow(nonstandard_style)]\n \n-use std::fs::{File, OpenOptions};\n-use std::io;\n-use std::path::Path;\n-\n cfg_if! {\n-    // We use `flock` rather than `fcntl` on Linux, because WSL1 does not support\n-    // `fcntl`-style advisory locks properly (rust-lang/rust#72157).\n-    //\n-    // For other Unix targets we still use `fcntl` because it's more portable than\n-    // `flock`.\n     if #[cfg(target_os = \"linux\")] {\n-        use std::os::unix::prelude::*;\n-\n-        #[derive(Debug)]\n-        pub struct Lock {\n-            _file: File,\n-        }\n-\n-        impl Lock {\n-            pub fn new(p: &Path,\n-                       wait: bool,\n-                       create: bool,\n-                       exclusive: bool)\n-                       -> io::Result<Lock> {\n-                let file = OpenOptions::new()\n-                    .read(true)\n-                    .write(true)\n-                    .create(create)\n-                    .mode(libc::S_IRWXU as u32)\n-                    .open(p)?;\n-\n-                let mut operation = if exclusive {\n-                    libc::LOCK_EX\n-                } else {\n-                    libc::LOCK_SH\n-                };\n-                if !wait {\n-                    operation |= libc::LOCK_NB\n-                }\n-\n-                let ret = unsafe { libc::flock(file.as_raw_fd(), operation) };\n-                if ret == -1 {\n-                    Err(io::Error::last_os_error())\n-                } else {\n-                    Ok(Lock { _file: file })\n-                }\n-            }\n-\n-            pub fn error_unsupported(err: &io::Error) -> bool {\n-                matches!(err.raw_os_error(), Some(libc::ENOTSUP) | Some(libc::ENOSYS))\n-            }\n-        }\n-\n-        // Note that we don't need a Drop impl to execute `flock(fd, LOCK_UN)`. Lock acquired by\n-        // `flock` is associated with the file descriptor and closing the file release it\n-        // automatically.\n+        mod linux;\n+        use linux as imp;\n     } else if #[cfg(unix)] {\n-        use std::mem;\n-        use std::os::unix::prelude::*;\n-\n-        #[derive(Debug)]\n-        pub struct Lock {\n-            file: File,\n-        }\n-\n-        impl Lock {\n-            pub fn new(p: &Path,\n-                       wait: bool,\n-                       create: bool,\n-                       exclusive: bool)\n-                       -> io::Result<Lock> {\n-                let file = OpenOptions::new()\n-                    .read(true)\n-                    .write(true)\n-                    .create(create)\n-                    .mode(libc::S_IRWXU as u32)\n-                    .open(p)?;\n-\n-                let lock_type = if exclusive {\n-                    libc::F_WRLCK\n-                } else {\n-                    libc::F_RDLCK\n-                };\n-\n-                let mut flock: libc::flock = unsafe { mem::zeroed() };\n-                flock.l_type = lock_type as libc::c_short;\n-                flock.l_whence = libc::SEEK_SET as libc::c_short;\n-                flock.l_start = 0;\n-                flock.l_len = 0;\n-\n-                let cmd = if wait { libc::F_SETLKW } else { libc::F_SETLK };\n-                let ret = unsafe {\n-                    libc::fcntl(file.as_raw_fd(), cmd, &flock)\n-                };\n-                if ret == -1 {\n-                    Err(io::Error::last_os_error())\n-                } else {\n-                    Ok(Lock { file })\n-                }\n-            }\n-\n-            pub fn error_unsupported(err: &io::Error) -> bool {\n-                matches!(err.raw_os_error(), Some(libc::ENOTSUP) | Some(libc::ENOSYS))\n-            }\n-        }\n-\n-        impl Drop for Lock {\n-            fn drop(&mut self) {\n-                let mut flock: libc::flock = unsafe { mem::zeroed() };\n-                flock.l_type = libc::F_UNLCK as libc::c_short;\n-                flock.l_whence = libc::SEEK_SET as libc::c_short;\n-                flock.l_start = 0;\n-                flock.l_len = 0;\n-\n-                unsafe {\n-                    libc::fcntl(self.file.as_raw_fd(), libc::F_SETLK, &flock);\n-                }\n-            }\n-        }\n+        mod unix;\n+        use unix as imp;\n     } else if #[cfg(windows)] {\n-        use std::mem;\n-        use std::os::windows::prelude::*;\n-\n-        use winapi::shared::winerror::ERROR_INVALID_FUNCTION;\n-        use winapi::um::minwinbase::{OVERLAPPED, LOCKFILE_FAIL_IMMEDIATELY, LOCKFILE_EXCLUSIVE_LOCK};\n-        use winapi::um::fileapi::LockFileEx;\n-        use winapi::um::winnt::{FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE};\n-\n-        #[derive(Debug)]\n-        pub struct Lock {\n-            _file: File,\n-        }\n-\n-        impl Lock {\n-            pub fn new(p: &Path,\n-                       wait: bool,\n-                       create: bool,\n-                       exclusive: bool)\n-                       -> io::Result<Lock> {\n-                assert!(p.parent().unwrap().exists(),\n-                    \"Parent directory of lock-file must exist: {}\",\n-                    p.display());\n-\n-                let share_mode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE;\n-\n-                let mut open_options = OpenOptions::new();\n-                open_options.read(true)\n-                            .share_mode(share_mode);\n-\n-                if create {\n-                    open_options.create(true)\n-                                .write(true);\n-                }\n-\n-                debug!(\"attempting to open lock file `{}`\", p.display());\n-                let file = match open_options.open(p) {\n-                    Ok(file) => {\n-                        debug!(\"lock file opened successfully\");\n-                        file\n-                    }\n-                    Err(err) => {\n-                        debug!(\"error opening lock file: {}\", err);\n-                        return Err(err)\n-                    }\n-                };\n-\n-                let ret = unsafe {\n-                    let mut overlapped: OVERLAPPED = mem::zeroed();\n-\n-                    let mut dwFlags = 0;\n-                    if !wait {\n-                        dwFlags |= LOCKFILE_FAIL_IMMEDIATELY;\n-                    }\n-\n-                    if exclusive {\n-                        dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n-                    }\n-\n-                    debug!(\"attempting to acquire lock on lock file `{}`\",\n-                           p.display());\n-                    LockFileEx(file.as_raw_handle(),\n-                               dwFlags,\n-                               0,\n-                               0xFFFF_FFFF,\n-                               0xFFFF_FFFF,\n-                               &mut overlapped)\n-                };\n-                if ret == 0 {\n-                    let err = io::Error::last_os_error();\n-                    debug!(\"failed acquiring file lock: {}\", err);\n-                    Err(err)\n-                } else {\n-                    debug!(\"successfully acquired lock\");\n-                    Ok(Lock { _file: file })\n-                }\n-            }\n-\n-            pub fn error_unsupported(err: &io::Error) -> bool {\n-                err.raw_os_error() == Some(ERROR_INVALID_FUNCTION as i32)\n-            }\n-        }\n-\n-        // Note that we don't need a Drop impl on the Windows: The file is unlocked\n-        // automatically when it's closed.\n+        mod windows;\n+        use windows as imp;\n     } else {\n-        #[derive(Debug)]\n-        pub struct Lock(());\n-\n-        impl Lock {\n-            pub fn new(_p: &Path, _wait: bool, _create: bool, _exclusive: bool)\n-                -> io::Result<Lock>\n-            {\n-                let msg = \"file locks not supported on this platform\";\n-                Err(io::Error::new(io::ErrorKind::Other, msg))\n-            }\n-\n-            pub fn error_unsupported(_err: &io::Error) -> bool {\n-                true\n-            }\n-        }\n+        mod unsupported;\n+        use unsupported as imp;\n     }\n }\n+\n+pub use imp::Lock;"}, {"sha": "bb3ecfbc370c0b3bc0242259bd8191d785deb6a5", "filename": "compiler/rustc_data_structures/src/flock/linux.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/99057747624e909ef58005a403ae1906f34290fe/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Flinux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99057747624e909ef58005a403ae1906f34290fe/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Flinux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Flinux.rs?ref=99057747624e909ef58005a403ae1906f34290fe", "patch": "@@ -0,0 +1,40 @@\n+//! We use `flock` rather than `fcntl` on Linux, because WSL1 does not support\n+//! `fcntl`-style advisory locks properly (rust-lang/rust#72157). For other Unix\n+//! targets we still use `fcntl` because it's more portable than `flock`.\n+\n+use std::fs::{File, OpenOptions};\n+use std::io;\n+use std::os::unix::prelude::*;\n+use std::path::Path;\n+\n+#[derive(Debug)]\n+pub struct Lock {\n+    _file: File,\n+}\n+\n+impl Lock {\n+    pub fn new(p: &Path, wait: bool, create: bool, exclusive: bool) -> io::Result<Lock> {\n+        let file = OpenOptions::new()\n+            .read(true)\n+            .write(true)\n+            .create(create)\n+            .mode(libc::S_IRWXU as u32)\n+            .open(p)?;\n+\n+        let mut operation = if exclusive { libc::LOCK_EX } else { libc::LOCK_SH };\n+        if !wait {\n+            operation |= libc::LOCK_NB\n+        }\n+\n+        let ret = unsafe { libc::flock(file.as_raw_fd(), operation) };\n+        if ret == -1 { Err(io::Error::last_os_error()) } else { Ok(Lock { _file: file }) }\n+    }\n+\n+    pub fn error_unsupported(err: &io::Error) -> bool {\n+        matches!(err.raw_os_error(), Some(libc::ENOTSUP) | Some(libc::ENOSYS))\n+    }\n+}\n+\n+// Note that we don't need a Drop impl to execute `flock(fd, LOCK_UN)`. A lock acquired by\n+// `flock` is associated with the file descriptor and closing the file releases it\n+// automatically."}, {"sha": "4e5297d582e075d749a6c9e239db06ca0bd4e012", "filename": "compiler/rustc_data_structures/src/flock/unix.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/99057747624e909ef58005a403ae1906f34290fe/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99057747624e909ef58005a403ae1906f34290fe/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funix.rs?ref=99057747624e909ef58005a403ae1906f34290fe", "patch": "@@ -0,0 +1,51 @@\n+use std::fs::{File, OpenOptions};\n+use std::io;\n+use std::mem;\n+use std::os::unix::prelude::*;\n+use std::path::Path;\n+\n+#[derive(Debug)]\n+pub struct Lock {\n+    file: File,\n+}\n+\n+impl Lock {\n+    pub fn new(p: &Path, wait: bool, create: bool, exclusive: bool) -> io::Result<Lock> {\n+        let file = OpenOptions::new()\n+            .read(true)\n+            .write(true)\n+            .create(create)\n+            .mode(libc::S_IRWXU as u32)\n+            .open(p)?;\n+\n+        let lock_type = if exclusive { libc::F_WRLCK } else { libc::F_RDLCK };\n+\n+        let mut flock: libc::flock = unsafe { mem::zeroed() };\n+        flock.l_type = lock_type as libc::c_short;\n+        flock.l_whence = libc::SEEK_SET as libc::c_short;\n+        flock.l_start = 0;\n+        flock.l_len = 0;\n+\n+        let cmd = if wait { libc::F_SETLKW } else { libc::F_SETLK };\n+        let ret = unsafe { libc::fcntl(file.as_raw_fd(), cmd, &flock) };\n+        if ret == -1 { Err(io::Error::last_os_error()) } else { Ok(Lock { file }) }\n+    }\n+\n+    pub fn error_unsupported(err: &io::Error) -> bool {\n+        matches!(err.raw_os_error(), Some(libc::ENOTSUP) | Some(libc::ENOSYS))\n+    }\n+}\n+\n+impl Drop for Lock {\n+    fn drop(&mut self) {\n+        let mut flock: libc::flock = unsafe { mem::zeroed() };\n+        flock.l_type = libc::F_UNLCK as libc::c_short;\n+        flock.l_whence = libc::SEEK_SET as libc::c_short;\n+        flock.l_start = 0;\n+        flock.l_len = 0;\n+\n+        unsafe {\n+            libc::fcntl(self.file.as_raw_fd(), libc::F_SETLK, &flock);\n+        }\n+    }\n+}"}, {"sha": "9245fca373dfc4de7c0fda7dc50ff3dd97d96f3f", "filename": "compiler/rustc_data_structures/src/flock/unsupported.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/99057747624e909ef58005a403ae1906f34290fe/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funsupported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99057747624e909ef58005a403ae1906f34290fe/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funsupported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Funsupported.rs?ref=99057747624e909ef58005a403ae1906f34290fe", "patch": "@@ -0,0 +1,16 @@\n+use std::io;\n+use std::path::Path;\n+\n+#[derive(Debug)]\n+pub struct Lock(());\n+\n+impl Lock {\n+    pub fn new(_p: &Path, _wait: bool, _create: bool, _exclusive: bool) -> io::Result<Lock> {\n+        let msg = \"file locks not supported on this platform\";\n+        Err(io::Error::new(io::ErrorKind::Other, msg))\n+    }\n+\n+    pub fn error_unsupported(_err: &io::Error) -> bool {\n+        true\n+    }\n+}"}, {"sha": "43e6caaa18dcd1d6cf96f73cf6760ed9a195708d", "filename": "compiler/rustc_data_structures/src/flock/windows.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/99057747624e909ef58005a403ae1906f34290fe/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99057747624e909ef58005a403ae1906f34290fe/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fflock%2Fwindows.rs?ref=99057747624e909ef58005a403ae1906f34290fe", "patch": "@@ -0,0 +1,77 @@\n+use std::fs::{File, OpenOptions};\n+use std::io;\n+use std::mem;\n+use std::os::windows::prelude::*;\n+use std::path::Path;\n+\n+use winapi::shared::winerror::ERROR_INVALID_FUNCTION;\n+use winapi::um::fileapi::LockFileEx;\n+use winapi::um::minwinbase::{LOCKFILE_EXCLUSIVE_LOCK, LOCKFILE_FAIL_IMMEDIATELY, OVERLAPPED};\n+use winapi::um::winnt::{FILE_SHARE_DELETE, FILE_SHARE_READ, FILE_SHARE_WRITE};\n+\n+#[derive(Debug)]\n+pub struct Lock {\n+    _file: File,\n+}\n+\n+impl Lock {\n+    pub fn new(p: &Path, wait: bool, create: bool, exclusive: bool) -> io::Result<Lock> {\n+        assert!(\n+            p.parent().unwrap().exists(),\n+            \"Parent directory of lock-file must exist: {}\",\n+            p.display()\n+        );\n+\n+        let share_mode = FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE;\n+\n+        let mut open_options = OpenOptions::new();\n+        open_options.read(true).share_mode(share_mode);\n+\n+        if create {\n+            open_options.create(true).write(true);\n+        }\n+\n+        debug!(\"attempting to open lock file `{}`\", p.display());\n+        let file = match open_options.open(p) {\n+            Ok(file) => {\n+                debug!(\"lock file opened successfully\");\n+                file\n+            }\n+            Err(err) => {\n+                debug!(\"error opening lock file: {}\", err);\n+                return Err(err);\n+            }\n+        };\n+\n+        let ret = unsafe {\n+            let mut overlapped: OVERLAPPED = mem::zeroed();\n+\n+            let mut dwFlags = 0;\n+            if !wait {\n+                dwFlags |= LOCKFILE_FAIL_IMMEDIATELY;\n+            }\n+\n+            if exclusive {\n+                dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n+            }\n+\n+            debug!(\"attempting to acquire lock on lock file `{}`\", p.display());\n+            LockFileEx(file.as_raw_handle(), dwFlags, 0, 0xFFFF_FFFF, 0xFFFF_FFFF, &mut overlapped)\n+        };\n+        if ret == 0 {\n+            let err = io::Error::last_os_error();\n+            debug!(\"failed acquiring file lock: {}\", err);\n+            Err(err)\n+        } else {\n+            debug!(\"successfully acquired lock\");\n+            Ok(Lock { _file: file })\n+        }\n+    }\n+\n+    pub fn error_unsupported(err: &io::Error) -> bool {\n+        err.raw_os_error() == Some(ERROR_INVALID_FUNCTION as i32)\n+    }\n+}\n+\n+// Note that we don't need a Drop impl on Windows: The file is unlocked\n+// automatically when it's closed."}]}