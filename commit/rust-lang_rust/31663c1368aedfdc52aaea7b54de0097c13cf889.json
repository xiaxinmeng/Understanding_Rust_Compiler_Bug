{"sha": "31663c1368aedfdc52aaea7b54de0097c13cf889", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxNjYzYzEzNjhhZWRmZGM1MmFhZWE3YjU0ZGUwMDk3YzEzY2Y4ODk=", "commit": {"author": {"name": "Geobert Quach", "email": "geobert@protonmail.com", "date": "2019-10-04T17:32:14Z"}, "committer": {"name": "Geobert Quach", "email": "geobert@protonmail.com", "date": "2019-10-04T17:32:14Z"}, "message": "feat(assists): Address some PR comments", "tree": {"sha": "18db05965d78c7b445cb551b1e696125ed806734", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18db05965d78c7b445cb551b1e696125ed806734"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31663c1368aedfdc52aaea7b54de0097c13cf889", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31663c1368aedfdc52aaea7b54de0097c13cf889", "html_url": "https://github.com/rust-lang/rust/commit/31663c1368aedfdc52aaea7b54de0097c13cf889", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31663c1368aedfdc52aaea7b54de0097c13cf889/comments", "author": {"login": "Geobert", "id": 72570, "node_id": "MDQ6VXNlcjcyNTcw", "avatar_url": "https://avatars.githubusercontent.com/u/72570?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Geobert", "html_url": "https://github.com/Geobert", "followers_url": "https://api.github.com/users/Geobert/followers", "following_url": "https://api.github.com/users/Geobert/following{/other_user}", "gists_url": "https://api.github.com/users/Geobert/gists{/gist_id}", "starred_url": "https://api.github.com/users/Geobert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Geobert/subscriptions", "organizations_url": "https://api.github.com/users/Geobert/orgs", "repos_url": "https://api.github.com/users/Geobert/repos", "events_url": "https://api.github.com/users/Geobert/events{/privacy}", "received_events_url": "https://api.github.com/users/Geobert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Geobert", "id": 72570, "node_id": "MDQ6VXNlcjcyNTcw", "avatar_url": "https://avatars.githubusercontent.com/u/72570?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Geobert", "html_url": "https://github.com/Geobert", "followers_url": "https://api.github.com/users/Geobert/followers", "following_url": "https://api.github.com/users/Geobert/following{/other_user}", "gists_url": "https://api.github.com/users/Geobert/gists{/gist_id}", "starred_url": "https://api.github.com/users/Geobert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Geobert/subscriptions", "organizations_url": "https://api.github.com/users/Geobert/orgs", "repos_url": "https://api.github.com/users/Geobert/repos", "events_url": "https://api.github.com/users/Geobert/events{/privacy}", "received_events_url": "https://api.github.com/users/Geobert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6195096fb4af0158a2cd512e3c30b211366b36ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/6195096fb4af0158a2cd512e3c30b211366b36ab", "html_url": "https://github.com/rust-lang/rust/commit/6195096fb4af0158a2cd512e3c30b211366b36ab"}], "stats": {"total": 49, "additions": 24, "deletions": 25}, "files": [{"sha": "200aaa59ac4aebfd8b256cc8e0458c01154ef2ec", "filename": "crates/ra_assists/src/assists/raw_string.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/31663c1368aedfdc52aaea7b54de0097c13cf889/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31663c1368aedfdc52aaea7b54de0097c13cf889/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fraw_string.rs?ref=31663c1368aedfdc52aaea7b54de0097c13cf889", "patch": "@@ -12,40 +12,39 @@ pub(crate) fn make_raw_string(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n     let token = literal.token();\n     let text = token.text().as_str();\n     let usual_string_range = find_usual_string_range(text)?;\n+    let start_of_inside = usual_string_range.start().to_usize() + 1;\n+    let end_of_inside = usual_string_range.end().to_usize();\n+    let inside_str = &text[start_of_inside..end_of_inside];\n+    let mut unescaped = String::with_capacity(inside_str.len());\n+    let mut error = Ok(());\n+    rustc_lexer::unescape::unescape_str(\n+        inside_str,\n+        &mut |_, unescaped_char| match unescaped_char {\n+            Ok(c) => unescaped.push(c),\n+            Err(_) => error = Err(()),\n+        },\n+    );\n+    if error.is_err() {\n+        return None;\n+    }\n     ctx.add_action(AssistId(\"make_raw_string\"), \"make raw string\", |edit| {\n         edit.target(literal.syntax().text_range());\n-        let start_of_inside = usual_string_range.start().to_usize() + 1;\n-        let end_of_inside = usual_string_range.end().to_usize();\n-        let inside_str = &text[start_of_inside..end_of_inside];\n-        let mut unescaped = String::with_capacity(inside_str.len());\n-        let mut error = Ok(());\n-        rustc_lexer::unescape::unescape_str(inside_str, &mut |_, unescaped_char| {\n-            match unescaped_char {\n-                Ok(c) => unescaped.push(c),\n-                Err(_) => error = Err(()),\n-            }\n-        });\n-        if error.is_err() {\n-            eprintln!(\"Error unescaping string\");\n-        } else {\n-            let max_hash_streak = count_hashes(&unescaped);\n-            let mut hashes = String::with_capacity(max_hash_streak + 1);\n-            for _ in 0..hashes.capacity() {\n-                hashes.push('#');\n-            }\n-            edit.replace(\n-                literal.syntax().text_range(),\n-                format!(\"r{}\\\"{}\\\"{}\", hashes, unescaped, hashes),\n-            );\n+        let max_hash_streak = count_hashes(&unescaped);\n+        let mut hashes = String::with_capacity(max_hash_streak + 1);\n+        for _ in 0..hashes.capacity() {\n+            hashes.push('#');\n         }\n+        edit.replace(\n+            literal.syntax().text_range(),\n+            format!(\"r{}\\\"{}\\\"{}\", hashes, unescaped, hashes),\n+        );\n     });\n     ctx.build()\n }\n \n fn count_hashes(s: &str) -> usize {\n-    let indexes: Vec<_> = s.match_indices(\"\\\"#\").map(|(i, _)| i).collect();\n     let mut max_hash_streak = 0usize;\n-    for idx in indexes {\n+    for idx in s.match_indices(\"\\\"#\").map(|(i, _)| i) {\n         let (_, sub) = s.split_at(idx + 1);\n         let nb_hash = sub.chars().take_while(|c| *c == '#').count();\n         if nb_hash > max_hash_streak {"}]}