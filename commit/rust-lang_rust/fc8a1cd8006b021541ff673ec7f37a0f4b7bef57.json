{"sha": "fc8a1cd8006b021541ff673ec7f37a0f4b7bef57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjOGExY2Q4MDA2YjAyMTU0MWZmNjczZWM3ZjM3YTBmNGI3YmVmNTc=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-11-01T09:35:04Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-11-03T07:16:35Z"}, "message": "Introduce render module", "tree": {"sha": "b5153e990c97a86608ad69b4aacc2b2dd88f1614", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5153e990c97a86608ad69b4aacc2b2dd88f1614"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57", "html_url": "https://github.com/rust-lang/rust/commit/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "245e1b533b5be5ea4a917957fb02d7f57e6b4661", "url": "https://api.github.com/repos/rust-lang/rust/commits/245e1b533b5be5ea4a917957fb02d7f57e6b4661", "html_url": "https://github.com/rust-lang/rust/commit/245e1b533b5be5ea4a917957fb02d7f57e6b4661"}], "stats": {"total": 703, "additions": 457, "deletions": 246}, "files": [{"sha": "1ca5cf33dea9cd16153c1b03fd200d2e425e3d78", "filename": "crates/completion/src/completions.rs", "status": "modified", "additions": 14, "deletions": 246, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/crates%2Fcompletion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Fcompletions.rs?ref=fc8a1cd8006b021541ff673ec7f37a0f4b7bef57", "patch": "@@ -14,14 +14,15 @@ pub(crate) mod macro_in_item_position;\n pub(crate) mod trait_impl;\n pub(crate) mod mod_;\n \n-use hir::{HasAttrs, HasSource, HirDisplay, ModPath, Mutability, ScopeDef, StructKind, Type};\n-use itertools::Itertools;\n+use hir::{HasAttrs, HasSource, HirDisplay, ModPath, Mutability, ScopeDef, Type};\n use syntax::{ast::NameOwner, display::*};\n use test_utils::mark;\n \n use crate::{\n-    item::Builder, CompletionContext, CompletionItem, CompletionItemKind, CompletionKind,\n-    CompletionScore, RootDatabase,\n+    item::Builder,\n+    render::{EnumVariantRender, FunctionRender, MacroRender},\n+    CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, CompletionScore,\n+    RootDatabase,\n };\n \n /// Represents an in-progress set of completions being built.\n@@ -189,50 +190,14 @@ impl Completions {\n         name: Option<String>,\n         macro_: hir::MacroDef,\n     ) {\n-        // FIXME: Currently proc-macro do not have ast-node,\n-        // such that it does not have source\n-        if macro_.is_proc_macro() {\n-            return;\n-        }\n-\n         let name = match name {\n             Some(it) => it,\n             None => return,\n         };\n \n-        let ast_node = macro_.source(ctx.db).value;\n-        let detail = macro_label(&ast_node);\n-\n-        let docs = macro_.docs(ctx.db);\n-\n-        let mut builder = CompletionItem::new(\n-            CompletionKind::Reference,\n-            ctx.source_range(),\n-            &format!(\"{}!\", name),\n-        )\n-        .kind(CompletionItemKind::Macro)\n-        .set_documentation(docs.clone())\n-        .set_deprecated(is_deprecated(macro_, ctx.db))\n-        .detail(detail);\n-\n-        let needs_bang = ctx.use_item_syntax.is_none() && !ctx.is_macro_call;\n-        builder = match ctx.config.snippet_cap {\n-            Some(cap) if needs_bang => {\n-                let docs = docs.as_ref().map_or(\"\", |s| s.as_str());\n-                let (bra, ket) = guess_macro_braces(&name, docs);\n-                builder\n-                    .insert_snippet(cap, format!(\"{}!{}$0{}\", name, bra, ket))\n-                    .label(format!(\"{}!{}\u2026{}\", name, bra, ket))\n-                    .lookup_by(format!(\"{}!\", name))\n-            }\n-            None if needs_bang => builder.insert_text(format!(\"{}!\", name)),\n-            _ => {\n-                mark::hit!(dont_insert_macro_call_parens_unncessary);\n-                builder.insert_text(name)\n-            }\n-        };\n-\n-        self.add(builder.build());\n+        if let Some(item) = MacroRender::new(ctx.into(), name, macro_).render() {\n+            self.add(item);\n+        }\n     }\n \n     pub(crate) fn add_function(\n@@ -241,50 +206,9 @@ impl Completions {\n         func: hir::Function,\n         local_name: Option<String>,\n     ) {\n-        fn add_arg(arg: &str, ty: &Type, ctx: &CompletionContext) -> String {\n-            if let Some(derefed_ty) = ty.remove_ref() {\n-                for (name, local) in ctx.locals.iter() {\n-                    if name == arg && local.ty(ctx.db) == derefed_ty {\n-                        return (if ty.is_mutable_reference() { \"&mut \" } else { \"&\" }).to_string()\n-                            + &arg.to_string();\n-                    }\n-                }\n-            }\n-            arg.to_string()\n-        };\n-        let name = local_name.unwrap_or_else(|| func.name(ctx.db).to_string());\n-        let ast_node = func.source(ctx.db).value;\n-\n-        let mut builder =\n-            CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.clone())\n-                .kind(if func.self_param(ctx.db).is_some() {\n-                    CompletionItemKind::Method\n-                } else {\n-                    CompletionItemKind::Function\n-                })\n-                .set_documentation(func.docs(ctx.db))\n-                .set_deprecated(is_deprecated(func, ctx.db))\n-                .detail(function_declaration(&ast_node));\n-\n-        let params_ty = func.params(ctx.db);\n-        let params = ast_node\n-            .param_list()\n-            .into_iter()\n-            .flat_map(|it| it.params())\n-            .zip(params_ty)\n-            .flat_map(|(it, param_ty)| {\n-                if let Some(pat) = it.pat() {\n-                    let name = pat.to_string();\n-                    let arg = name.trim_start_matches(\"mut \").trim_start_matches('_');\n-                    return Some(add_arg(arg, param_ty.ty(), ctx));\n-                }\n-                None\n-            })\n-            .collect();\n+        let item = FunctionRender::new(ctx.into(), local_name, func).render();\n \n-        builder = builder.add_call_parens(ctx, name, Params::Named(params));\n-\n-        self.add(builder.build())\n+        self.add(item)\n     }\n \n     pub(crate) fn add_const(&mut self, ctx: &CompletionContext, constant: hir::Const) {\n@@ -325,7 +249,8 @@ impl Completions {\n         variant: hir::EnumVariant,\n         path: ModPath,\n     ) {\n-        self.add_enum_variant_impl(ctx, variant, None, Some(path))\n+        let item = EnumVariantRender::new(ctx.into(), None, variant, Some(path)).render();\n+        self.add(item);\n     }\n \n     pub(crate) fn add_enum_variant(\n@@ -334,63 +259,8 @@ impl Completions {\n         variant: hir::EnumVariant,\n         local_name: Option<String>,\n     ) {\n-        self.add_enum_variant_impl(ctx, variant, local_name, None)\n-    }\n-\n-    fn add_enum_variant_impl(\n-        &mut self,\n-        ctx: &CompletionContext,\n-        variant: hir::EnumVariant,\n-        local_name: Option<String>,\n-        path: Option<ModPath>,\n-    ) {\n-        let is_deprecated = is_deprecated(variant, ctx.db);\n-        let name = local_name.unwrap_or_else(|| variant.name(ctx.db).to_string());\n-        let (qualified_name, short_qualified_name) = match &path {\n-            Some(path) => {\n-                let full = path.to_string();\n-                let short =\n-                    path.segments[path.segments.len().saturating_sub(2)..].iter().join(\"::\");\n-                (full, short)\n-            }\n-            None => (name.to_string(), name.to_string()),\n-        };\n-        let detail_types = variant\n-            .fields(ctx.db)\n-            .into_iter()\n-            .map(|field| (field.name(ctx.db), field.signature_ty(ctx.db)));\n-        let variant_kind = variant.kind(ctx.db);\n-        let detail = match variant_kind {\n-            StructKind::Tuple | StructKind::Unit => format!(\n-                \"({})\",\n-                detail_types.map(|(_, t)| t.display(ctx.db).to_string()).format(\", \")\n-            ),\n-            StructKind::Record => format!(\n-                \"{{ {} }}\",\n-                detail_types\n-                    .map(|(n, t)| format!(\"{}: {}\", n, t.display(ctx.db).to_string()))\n-                    .format(\", \")\n-            ),\n-        };\n-        let mut res = CompletionItem::new(\n-            CompletionKind::Reference,\n-            ctx.source_range(),\n-            qualified_name.clone(),\n-        )\n-        .kind(CompletionItemKind::EnumVariant)\n-        .set_documentation(variant.docs(ctx.db))\n-        .set_deprecated(is_deprecated)\n-        .detail(detail);\n-\n-        if variant_kind == StructKind::Tuple {\n-            mark::hit!(inserts_parens_for_tuple_enums);\n-            let params = Params::Anonymous(variant.fields(ctx.db).len());\n-            res = res.add_call_parens(ctx, short_qualified_name, params)\n-        } else if path.is_some() {\n-            res = res.lookup_by(short_qualified_name);\n-        }\n-\n-        res.add_to(self);\n+        let item = EnumVariantRender::new(ctx.into(), local_name, variant, None).render();\n+        self.add(item);\n     }\n }\n \n@@ -434,112 +304,10 @@ fn compute_score(ctx: &CompletionContext, ty: &Type, name: &str) -> Option<Compl\n     compute_score_from_active(&active_type, &active_name, ty, name)\n }\n \n-enum Params {\n-    Named(Vec<String>),\n-    Anonymous(usize),\n-}\n-\n-impl Params {\n-    fn len(&self) -> usize {\n-        match self {\n-            Params::Named(xs) => xs.len(),\n-            Params::Anonymous(len) => *len,\n-        }\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.len() == 0\n-    }\n-}\n-\n-impl Builder {\n-    fn add_call_parens(mut self, ctx: &CompletionContext, name: String, params: Params) -> Builder {\n-        if !ctx.config.add_call_parenthesis {\n-            return self;\n-        }\n-        if ctx.use_item_syntax.is_some() {\n-            mark::hit!(no_parens_in_use_item);\n-            return self;\n-        }\n-        if ctx.is_pattern_call {\n-            mark::hit!(dont_duplicate_pattern_parens);\n-            return self;\n-        }\n-        if ctx.is_call {\n-            return self;\n-        }\n-\n-        // Don't add parentheses if the expected type is some function reference.\n-        if let Some(ty) = &ctx.expected_type {\n-            if ty.is_fn() {\n-                mark::hit!(no_call_parens_if_fn_ptr_needed);\n-                return self;\n-            }\n-        }\n-\n-        let cap = match ctx.config.snippet_cap {\n-            Some(it) => it,\n-            None => return self,\n-        };\n-        // If not an import, add parenthesis automatically.\n-        mark::hit!(inserts_parens_for_function_calls);\n-\n-        let (snippet, label) = if params.is_empty() {\n-            (format!(\"{}()$0\", name), format!(\"{}()\", name))\n-        } else {\n-            self = self.trigger_call_info();\n-            let snippet = match (ctx.config.add_call_argument_snippets, params) {\n-                (true, Params::Named(params)) => {\n-                    let function_params_snippet =\n-                        params.iter().enumerate().format_with(\", \", |(index, param_name), f| {\n-                            f(&format_args!(\"${{{}:{}}}\", index + 1, param_name))\n-                        });\n-                    format!(\"{}({})$0\", name, function_params_snippet)\n-                }\n-                _ => {\n-                    mark::hit!(suppress_arg_snippets);\n-                    format!(\"{}($0)\", name)\n-                }\n-            };\n-\n-            (snippet, format!(\"{}(\u2026)\", name))\n-        };\n-        self.lookup_by(name).label(label).insert_snippet(cap, snippet)\n-    }\n-}\n-\n fn is_deprecated(node: impl HasAttrs, db: &RootDatabase) -> bool {\n     node.attrs(db).by_key(\"deprecated\").exists()\n }\n \n-fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static str) {\n-    let mut votes = [0, 0, 0];\n-    for (idx, s) in docs.match_indices(&macro_name) {\n-        let (before, after) = (&docs[..idx], &docs[idx + s.len()..]);\n-        // Ensure to match the full word\n-        if after.starts_with('!')\n-            && !before.ends_with(|c: char| c == '_' || c.is_ascii_alphanumeric())\n-        {\n-            // It may have spaces before the braces like `foo! {}`\n-            match after[1..].chars().find(|&c| !c.is_whitespace()) {\n-                Some('{') => votes[0] += 1,\n-                Some('[') => votes[1] += 1,\n-                Some('(') => votes[2] += 1,\n-                _ => {}\n-            }\n-        }\n-    }\n-\n-    // Insert a space before `{}`.\n-    // We prefer the last one when some votes equal.\n-    let (_vote, (bra, ket)) = votes\n-        .iter()\n-        .zip(&[(\" {\", \"}\"), (\"[\", \"]\"), (\"(\", \")\")])\n-        .max_by_key(|&(&vote, _)| vote)\n-        .unwrap();\n-    (*bra, *ket)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use std::cmp::Reverse;"}, {"sha": "cb6e0554e9a7cededcf6cb4faf49451681b81c62", "filename": "crates/completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/crates%2Fcompletion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/crates%2Fcompletion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Flib.rs?ref=fc8a1cd8006b021541ff673ec7f37a0f4b7bef57", "patch": "@@ -7,6 +7,7 @@ mod patterns;\n mod generated_lint_completions;\n #[cfg(test)]\n mod test_utils;\n+mod render;\n \n mod completions;\n "}, {"sha": "66eb753b1ecee11aef8250748ef650c211ce8d4d", "filename": "crates/completion/src/render.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/crates%2Fcompletion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/crates%2Fcompletion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender.rs?ref=fc8a1cd8006b021541ff673ec7f37a0f4b7bef57", "patch": "@@ -0,0 +1,50 @@\n+//! `render` module provides utilities for rendering completion suggestions\n+//! into code pieces that will be presented to user.\n+\n+mod macro_;\n+mod function;\n+mod builder_ext;\n+mod enum_variant;\n+\n+use hir::HasAttrs;\n+use ide_db::RootDatabase;\n+use syntax::TextRange;\n+\n+use crate::{config::SnippetCap, CompletionContext};\n+\n+pub(crate) use crate::render::{\n+    enum_variant::EnumVariantRender, function::FunctionRender, macro_::MacroRender,\n+};\n+\n+#[derive(Debug)]\n+pub(crate) struct RenderContext<'a> {\n+    completion: &'a CompletionContext<'a>,\n+}\n+\n+impl<'a> RenderContext<'a> {\n+    pub fn new(completion: &'a CompletionContext<'a>) -> RenderContext<'a> {\n+        RenderContext { completion }\n+    }\n+\n+    pub fn snippet_cap(&self) -> Option<SnippetCap> {\n+        self.completion.config.snippet_cap.clone()\n+    }\n+\n+    pub fn db(&self) -> &'a RootDatabase {\n+        &self.completion.db\n+    }\n+\n+    pub fn source_range(&self) -> TextRange {\n+        self.completion.source_range()\n+    }\n+\n+    pub fn is_deprecated(&self, node: impl HasAttrs) -> bool {\n+        node.attrs(self.db()).by_key(\"deprecated\").exists()\n+    }\n+}\n+\n+impl<'a> From<&'a CompletionContext<'a>> for RenderContext<'a> {\n+    fn from(ctx: &'a CompletionContext<'a>) -> RenderContext<'a> {\n+        RenderContext::new(ctx)\n+    }\n+}"}, {"sha": "37b0d0459a63f011c76e312db0311dac08f9ecda", "filename": "crates/completion/src/render/builder_ext.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/crates%2Fcompletion%2Fsrc%2Frender%2Fbuilder_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/crates%2Fcompletion%2Fsrc%2Frender%2Fbuilder_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fbuilder_ext.rs?ref=fc8a1cd8006b021541ff673ec7f37a0f4b7bef57", "patch": "@@ -0,0 +1,94 @@\n+//! Extensions for `Builder` structure required for item rendering.\n+\n+use itertools::Itertools;\n+use test_utils::mark;\n+\n+use crate::{item::Builder, CompletionContext};\n+\n+pub(super) enum Params {\n+    Named(Vec<String>),\n+    Anonymous(usize),\n+}\n+\n+impl Params {\n+    pub(super) fn len(&self) -> usize {\n+        match self {\n+            Params::Named(xs) => xs.len(),\n+            Params::Anonymous(len) => *len,\n+        }\n+    }\n+\n+    pub(super) fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+}\n+\n+impl Builder {\n+    pub(super) fn should_add_parems(&self, ctx: &CompletionContext) -> bool {\n+        if !ctx.config.add_call_parenthesis {\n+            return false;\n+        }\n+        if ctx.use_item_syntax.is_some() {\n+            mark::hit!(no_parens_in_use_item);\n+            return false;\n+        }\n+        if ctx.is_pattern_call {\n+            mark::hit!(dont_duplicate_pattern_parens);\n+            return false;\n+        }\n+        if ctx.is_call {\n+            return false;\n+        }\n+\n+        // Don't add parentheses if the expected type is some function reference.\n+        if let Some(ty) = &ctx.expected_type {\n+            if ty.is_fn() {\n+                mark::hit!(no_call_parens_if_fn_ptr_needed);\n+                return false;\n+            }\n+        }\n+\n+        // Nothing prevents us from adding parentheses\n+        true\n+    }\n+\n+    pub(super) fn add_call_parens(\n+        mut self,\n+        ctx: &CompletionContext,\n+        name: String,\n+        params: Params,\n+    ) -> Builder {\n+        if !self.should_add_parems(ctx) {\n+            return self;\n+        }\n+\n+        let cap = match ctx.config.snippet_cap {\n+            Some(it) => it,\n+            None => return self,\n+        };\n+        // If not an import, add parenthesis automatically.\n+        mark::hit!(inserts_parens_for_function_calls);\n+\n+        let (snippet, label) = if params.is_empty() {\n+            (format!(\"{}()$0\", name), format!(\"{}()\", name))\n+        } else {\n+            self = self.trigger_call_info();\n+            let snippet = match (ctx.config.add_call_argument_snippets, params) {\n+                (true, Params::Named(params)) => {\n+                    let function_params_snippet =\n+                        params.iter().enumerate().format_with(\", \", |(index, param_name), f| {\n+                            f(&format_args!(\"${{{}:{}}}\", index + 1, param_name))\n+                        });\n+                    format!(\"{}({})$0\", name, function_params_snippet)\n+                }\n+                _ => {\n+                    mark::hit!(suppress_arg_snippets);\n+                    format!(\"{}($0)\", name)\n+                }\n+            };\n+\n+            (snippet, format!(\"{}(\u2026)\", name))\n+        };\n+        self.lookup_by(name).label(label).insert_snippet(cap, snippet)\n+    }\n+}"}, {"sha": "26cfdfeea701cc3d2f572b1f4101b1780f356868", "filename": "crates/completion/src/render/enum_variant.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fenum_variant.rs?ref=fc8a1cd8006b021541ff673ec7f37a0f4b7bef57", "patch": "@@ -0,0 +1,95 @@\n+use hir::{HasAttrs, HirDisplay, ModPath, StructKind};\n+use itertools::Itertools;\n+use test_utils::mark;\n+\n+use crate::{\n+    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    render::{builder_ext::Params, RenderContext},\n+};\n+\n+#[derive(Debug)]\n+pub(crate) struct EnumVariantRender<'a> {\n+    ctx: RenderContext<'a>,\n+    name: String,\n+    variant: hir::EnumVariant,\n+    path: Option<ModPath>,\n+    qualified_name: String,\n+    short_qualified_name: String,\n+    variant_kind: StructKind,\n+}\n+\n+impl<'a> EnumVariantRender<'a> {\n+    pub(crate) fn new(\n+        ctx: RenderContext<'a>,\n+        local_name: Option<String>,\n+        variant: hir::EnumVariant,\n+        path: Option<ModPath>,\n+    ) -> EnumVariantRender<'a> {\n+        let name = local_name.unwrap_or_else(|| variant.name(ctx.db()).to_string());\n+        let variant_kind = variant.kind(ctx.db());\n+\n+        let (qualified_name, short_qualified_name) = match &path {\n+            Some(path) => {\n+                let full = path.to_string();\n+                let short =\n+                    path.segments[path.segments.len().saturating_sub(2)..].iter().join(\"::\");\n+                (full, short)\n+            }\n+            None => (name.to_string(), name.to_string()),\n+        };\n+\n+        EnumVariantRender {\n+            ctx,\n+            name,\n+            variant,\n+            path,\n+            qualified_name,\n+            short_qualified_name,\n+            variant_kind,\n+        }\n+    }\n+\n+    pub(crate) fn render(self) -> CompletionItem {\n+        let mut builder = CompletionItem::new(\n+            CompletionKind::Reference,\n+            self.ctx.source_range(),\n+            self.qualified_name.clone(),\n+        )\n+        .kind(CompletionItemKind::EnumVariant)\n+        .set_documentation(self.variant.docs(self.ctx.db()))\n+        .set_deprecated(self.ctx.is_deprecated(self.variant))\n+        .detail(self.detail());\n+\n+        if self.variant_kind == StructKind::Tuple {\n+            mark::hit!(inserts_parens_for_tuple_enums);\n+            let params = Params::Anonymous(self.variant.fields(self.ctx.db()).len());\n+            builder =\n+                builder.add_call_parens(self.ctx.completion, self.short_qualified_name, params);\n+        } else if self.path.is_some() {\n+            builder = builder.lookup_by(self.short_qualified_name);\n+        }\n+\n+        builder.build()\n+    }\n+\n+    fn detail(&self) -> String {\n+        let detail_types = self\n+            .variant\n+            .fields(self.ctx.db())\n+            .into_iter()\n+            .map(|field| (field.name(self.ctx.db()), field.signature_ty(self.ctx.db())));\n+\n+        match self.variant_kind {\n+            StructKind::Tuple | StructKind::Unit => format!(\n+                \"({})\",\n+                detail_types.map(|(_, t)| t.display(self.ctx.db()).to_string()).format(\", \")\n+            ),\n+            StructKind::Record => format!(\n+                \"{{ {} }}\",\n+                detail_types\n+                    .map(|(n, t)| format!(\"{}: {}\", n, t.display(self.ctx.db()).to_string()))\n+                    .format(\", \")\n+            ),\n+        }\n+    }\n+}"}, {"sha": "16f15e22c5cd3257c8bc1b9866ef2ff966eb2003", "filename": "crates/completion/src/render/function.rs", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Ffunction.rs?ref=fc8a1cd8006b021541ff673ec7f37a0f4b7bef57", "patch": "@@ -0,0 +1,87 @@\n+use hir::{Documentation, HasAttrs, HasSource, Type};\n+use syntax::{ast::Fn, display::function_declaration};\n+\n+use crate::{\n+    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    render::{builder_ext::Params, RenderContext},\n+};\n+\n+#[derive(Debug)]\n+pub(crate) struct FunctionRender<'a> {\n+    ctx: RenderContext<'a>,\n+    name: String,\n+    fn_: hir::Function,\n+    ast_node: Fn,\n+}\n+\n+impl<'a> FunctionRender<'a> {\n+    pub(crate) fn new(\n+        ctx: RenderContext<'a>,\n+        local_name: Option<String>,\n+        fn_: hir::Function,\n+    ) -> FunctionRender<'a> {\n+        let name = local_name.unwrap_or_else(|| fn_.name(ctx.db()).to_string());\n+        let ast_node = fn_.source(ctx.db()).value;\n+\n+        FunctionRender { ctx, name, fn_, ast_node }\n+    }\n+\n+    pub(crate) fn render(self) -> CompletionItem {\n+        let params = self.params();\n+        CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), self.name.clone())\n+            .kind(self.kind())\n+            .set_documentation(self.docs())\n+            .set_deprecated(self.ctx.is_deprecated(self.fn_))\n+            .detail(self.detail())\n+            .add_call_parens(self.ctx.completion, self.name, params)\n+            .build()\n+    }\n+\n+    fn detail(&self) -> String {\n+        function_declaration(&self.ast_node)\n+    }\n+\n+    fn add_arg(&self, arg: &str, ty: &Type) -> String {\n+        if let Some(derefed_ty) = ty.remove_ref() {\n+            for (name, local) in self.ctx.completion.locals.iter() {\n+                if name == arg && local.ty(self.ctx.db()) == derefed_ty {\n+                    return (if ty.is_mutable_reference() { \"&mut \" } else { \"&\" }).to_string()\n+                        + &arg.to_string();\n+                }\n+            }\n+        }\n+        arg.to_string()\n+    }\n+\n+    fn params(&self) -> Params {\n+        let params_ty = self.fn_.params(self.ctx.db());\n+        let params = self\n+            .ast_node\n+            .param_list()\n+            .into_iter()\n+            .flat_map(|it| it.params())\n+            .zip(params_ty)\n+            .flat_map(|(it, param_ty)| {\n+                if let Some(pat) = it.pat() {\n+                    let name = pat.to_string();\n+                    let arg = name.trim_start_matches(\"mut \").trim_start_matches('_');\n+                    return Some(self.add_arg(arg, param_ty.ty()));\n+                }\n+                None\n+            })\n+            .collect();\n+        Params::Named(params)\n+    }\n+\n+    fn kind(&self) -> CompletionItemKind {\n+        if self.fn_.self_param(self.ctx.db()).is_some() {\n+            CompletionItemKind::Method\n+        } else {\n+            CompletionItemKind::Function\n+        }\n+    }\n+\n+    fn docs(&self) -> Option<Documentation> {\n+        self.fn_.docs(self.ctx.db())\n+    }\n+}"}, {"sha": "bcf94f47eae6854cc58f8398c73692974f37872b", "filename": "crates/completion/src/render/macro_.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc8a1cd8006b021541ff673ec7f37a0f4b7bef57/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcompletion%2Fsrc%2Frender%2Fmacro_.rs?ref=fc8a1cd8006b021541ff673ec7f37a0f4b7bef57", "patch": "@@ -0,0 +1,116 @@\n+use hir::{Documentation, HasAttrs, HasSource};\n+use syntax::display::macro_label;\n+use test_utils::mark;\n+\n+use crate::{\n+    item::{CompletionItem, CompletionItemKind, CompletionKind},\n+    render::RenderContext,\n+};\n+\n+#[derive(Debug)]\n+pub(crate) struct MacroRender<'a> {\n+    ctx: RenderContext<'a>,\n+    name: String,\n+    macro_: hir::MacroDef,\n+    docs: Option<Documentation>,\n+    bra: &'static str,\n+    ket: &'static str,\n+}\n+\n+impl<'a> MacroRender<'a> {\n+    pub(crate) fn new(\n+        ctx: RenderContext<'a>,\n+        name: String,\n+        macro_: hir::MacroDef,\n+    ) -> MacroRender<'a> {\n+        let docs = macro_.docs(ctx.db());\n+        let docs_str = docs.as_ref().map_or(\"\", |s| s.as_str());\n+        let (bra, ket) = guess_macro_braces(&name, docs_str);\n+\n+        MacroRender { ctx, name, macro_, docs, bra, ket }\n+    }\n+\n+    pub(crate) fn render(&self) -> Option<CompletionItem> {\n+        // FIXME: Currently proc-macro do not have ast-node,\n+        // such that it does not have source\n+        if self.macro_.is_proc_macro() {\n+            return None;\n+        }\n+\n+        let mut builder =\n+            CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), &self.label())\n+                .kind(CompletionItemKind::Macro)\n+                .set_documentation(self.docs.clone())\n+                .set_deprecated(self.ctx.is_deprecated(self.macro_))\n+                .detail(self.detail());\n+\n+        let needs_bang = self.needs_bang();\n+        builder = match self.ctx.snippet_cap() {\n+            Some(cap) if needs_bang => {\n+                let snippet = self.snippet();\n+                let lookup = self.lookup();\n+                builder.insert_snippet(cap, snippet).lookup_by(lookup)\n+            }\n+            None if needs_bang => builder.insert_text(self.banged_name()),\n+            _ => {\n+                mark::hit!(dont_insert_macro_call_parens_unncessary);\n+                builder.insert_text(&self.name)\n+            }\n+        };\n+\n+        Some(builder.build())\n+    }\n+\n+    fn needs_bang(&self) -> bool {\n+        self.ctx.completion.use_item_syntax.is_none() && !self.ctx.completion.is_macro_call\n+    }\n+\n+    fn label(&self) -> String {\n+        format!(\"{}!{}\u2026{}\", self.name, self.bra, self.ket)\n+    }\n+\n+    fn snippet(&self) -> String {\n+        format!(\"{}!{}$0{}\", self.name, self.bra, self.ket)\n+    }\n+\n+    fn lookup(&self) -> String {\n+        self.banged_name()\n+    }\n+\n+    fn banged_name(&self) -> String {\n+        format!(\"{}!\", self.name)\n+    }\n+\n+    fn detail(&self) -> String {\n+        let ast_node = self.macro_.source(self.ctx.db()).value;\n+        macro_label(&ast_node)\n+    }\n+}\n+\n+fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static str) {\n+    let mut votes = [0, 0, 0];\n+    for (idx, s) in docs.match_indices(&macro_name) {\n+        let (before, after) = (&docs[..idx], &docs[idx + s.len()..]);\n+        // Ensure to match the full word\n+        if after.starts_with('!')\n+            && !before.ends_with(|c: char| c == '_' || c.is_ascii_alphanumeric())\n+        {\n+            // It may have spaces before the braces like `foo! {}`\n+            match after[1..].chars().find(|&c| !c.is_whitespace()) {\n+                Some('{') => votes[0] += 1,\n+                Some('[') => votes[1] += 1,\n+                Some('(') => votes[2] += 1,\n+                _ => {}\n+            }\n+        }\n+    }\n+\n+    // Insert a space before `{}`.\n+    // We prefer the last one when some votes equal.\n+    let (_vote, (bra, ket)) = votes\n+        .iter()\n+        .zip(&[(\" {\", \"}\"), (\"[\", \"]\"), (\"(\", \")\")])\n+        .max_by_key(|&(&vote, _)| vote)\n+        .unwrap();\n+    (*bra, *ket)\n+}"}]}