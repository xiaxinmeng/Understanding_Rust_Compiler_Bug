{"sha": "8fec1a7aa776ed0f1373a1531b8665f4e35919f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmZWMxYTdhYTc3NmVkMGYxMzczYTE1MzFiODY2NWY0ZTM1OTE5ZjU=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-09T14:01:53Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-09T14:01:53Z"}, "message": "merge FnEvalContext into GlobalEvalContext", "tree": {"sha": "846e77fb169f4043057fb9bb48b8972c150caf97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/846e77fb169f4043057fb9bb48b8972c150caf97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fec1a7aa776ed0f1373a1531b8665f4e35919f5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXWXbRAAoJEFbW7qD8Z6xGC7oQAJUFZx5YI9pDcIuaC1yQ4x41\nW8IkQvVjZAKKhvVFcDY27Rs7+XIcZCByoq8JdTC/hv2Qli1XppB0xTemZ8ZNa5uu\ns8kG8f9nx6VWouoosDaBeqY45D6dB2XEZCVrReKYD2OM7ymN1oQEu75V+qiTfgWK\nX0rfahP2ghuTjOzyRmmE9hfmECXF6y7p3NwfapxEYSfUVH49KZbA7XSn+tm7VCli\nGBG3eA0htWJUIn5Yixk90/iYAhtwpIS5121vLv7QoQ4YPwEJBQOpaJQ66XFuBj1I\nBAvmpseAqFSaVqfPG+Kz9PNK5rVMblJ9V2Q+RZchKUsH/z7sCRUhr+9WscXrCeqz\n1qkomqcmRkLaikZOpzPbFhxhkVHdg5dllmoEX1o0NKIwXkee3Q3wQcfq+uRYpTMq\noEdSkwSWgsjX42D9VX5ri+7ivV9ydsfzTiHh6AQrSb8319+7Jba09Q8VWWnO3czS\nm28TIiQ4hSnlvT46XchoalndKRaFYGjqdsex1h2O4nl11GuRK/BM4ShU6tPSIb5v\nVn++bD40vewadocN8V55H3wYhmzdiRfwro3c5hZ1IjEZcDQoUBEWx1fpVabM2fsL\nXlS2rKjveDxL9GSUykOfpOkQf89RrI9Emg6xYMWahGgVCJ5j0+EHu4TZrLQt8dO9\nud/W62ojjGOUjtSAkopB\n=TF8O\n-----END PGP SIGNATURE-----", "payload": "tree 846e77fb169f4043057fb9bb48b8972c150caf97\nparent 05eaa522a5486ba20bb564bf2b37179124d0951c\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465480913 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465480913 +0200\n\nmerge FnEvalContext into GlobalEvalContext"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fec1a7aa776ed0f1373a1531b8665f4e35919f5", "html_url": "https://github.com/rust-lang/rust/commit/8fec1a7aa776ed0f1373a1531b8665f4e35919f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fec1a7aa776ed0f1373a1531b8665f4e35919f5/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05eaa522a5486ba20bb564bf2b37179124d0951c", "url": "https://api.github.com/repos/rust-lang/rust/commits/05eaa522a5486ba20bb564bf2b37179124d0951c", "html_url": "https://github.com/rust-lang/rust/commit/05eaa522a5486ba20bb564bf2b37179124d0951c"}], "stats": {"total": 166, "additions": 63, "deletions": 103}, "files": [{"sha": "33e7d49bc6dee7cce7e1458274be185f85a8b4c4", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 38, "deletions": 77, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/8fec1a7aa776ed0f1373a1531b8665f4e35919f5/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fec1a7aa776ed0f1373a1531b8665f4e35919f5/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=8fec1a7aa776ed0f1373a1531b8665f4e35919f5", "patch": "@@ -9,7 +9,7 @@ use rustc::ty::subst::{self, Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::util::nodemap::DefIdMap;\n use std::cell::RefCell;\n-use std::ops::{Deref, DerefMut};\n+use std::ops::Deref;\n use std::rc::Rc;\n use std::{iter, mem};\n use syntax::ast;\n@@ -39,26 +39,9 @@ struct GlobalEvalContext<'a, 'tcx: 'a> {\n \n     /// Precomputed statics, constants and promoteds\n     statics: HashMap<ConstantId<'tcx>, Pointer>,\n-}\n-\n-struct FnEvalContext<'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> {\n-    gecx: &'a mut GlobalEvalContext<'b, 'tcx>,\n \n     /// The virtual call stack.\n-    stack: Vec<Frame<'mir, 'tcx>>,\n-}\n-\n-impl<'a, 'b, 'mir, 'tcx> Deref for FnEvalContext<'a, 'b, 'mir, 'tcx> {\n-    type Target = GlobalEvalContext<'b, 'tcx>;\n-    fn deref(&self) -> &Self::Target {\n-        self.gecx\n-    }\n-}\n-\n-impl<'a, 'b, 'mir, 'tcx> DerefMut for FnEvalContext<'a, 'b, 'mir, 'tcx> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.gecx\n-    }\n+    stack: Vec<Frame<'a, 'tcx>>,\n }\n \n /// A stack frame.\n@@ -160,20 +143,19 @@ impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n                                    .bit_width()\n                                    .expect(\"Session::target::uint_type was usize\")/8),\n             statics: HashMap::new(),\n+            stack: Vec::new(),\n         }\n     }\n \n-    fn call(&mut self, mir: &mir::Mir<'tcx>, def_id: DefId) -> EvalResult<Option<Pointer>> {\n+    fn call(&mut self, mir: &'a mir::Mir<'tcx>, def_id: DefId) -> EvalResult<Option<Pointer>> {\n         let substs = self.tcx.mk_substs(subst::Substs::empty());\n         let return_ptr = self.alloc_ret_ptr(mir.return_ty, substs);\n \n-        let mut nested_fecx = FnEvalContext::new(self);\n+        self.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, None);\n \n-        nested_fecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, None);\n+        self.frame_mut().return_ptr = return_ptr;\n \n-        nested_fecx.frame_mut().return_ptr = return_ptr;\n-\n-        nested_fecx.run()?;\n+        self.run()?;\n         Ok(return_ptr)\n     }\n \n@@ -349,15 +331,6 @@ impl<'a, 'tcx> GlobalEvalContext<'a, 'tcx> {\n             ty.layout(&infcx).unwrap()\n         })\n     }\n-}\n-\n-impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n-    fn new(gecx: &'a mut GlobalEvalContext<'b, 'tcx>) -> Self {\n-        FnEvalContext {\n-            gecx: gecx,\n-            stack: Vec::new(),\n-        }\n-    }\n \n     #[inline(never)]\n     #[cold]\n@@ -399,7 +372,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         Ok(())\n     }\n \n-    fn push_stack_frame(&mut self, def_id: DefId, span: codemap::Span, mir: CachedMir<'mir, 'tcx>, substs: &'tcx Substs<'tcx>,\n+    fn push_stack_frame(&mut self, def_id: DefId, span: codemap::Span, mir: CachedMir<'a, 'tcx>, substs: &'tcx Substs<'tcx>,\n         return_ptr: Option<Pointer>)\n     {\n         let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n@@ -425,7 +398,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         });\n \n         let locals: Vec<Pointer> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n-            let size = self.type_size(ty);\n+            let size = self.type_size(ty, self.substs());\n             self.memory.allocate(size)\n         }).collect();\n \n@@ -459,7 +432,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             SwitchInt { ref discr, ref values, ref targets, .. } => {\n                 let discr_ptr = self.eval_lvalue(discr)?.to_ptr();\n                 let discr_size = self\n-                    .type_layout(self.lvalue_ty(discr))\n+                    .type_layout(self.lvalue_ty(discr), self.substs())\n                     .size(&self.tcx.data_layout)\n                     .bytes() as usize;\n                 let discr_val = self.memory.read_uint(discr_ptr, discr_size)?;\n@@ -512,7 +485,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                                 let name = self.tcx.item_name(def_id).as_str();\n                                 match fn_ty.sig.0.output {\n                                     ty::FnConverging(ty) => {\n-                                        let size = self.type_size(ty);\n+                                        let size = self.type_size(ty, self.substs());\n                                         let ret = return_ptr.unwrap();\n                                         self.call_intrinsic(&name, substs, args, ret, size)?\n                                     }\n@@ -523,7 +496,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                             Abi::C => {\n                                 match fn_ty.sig.0.output {\n                                     ty::FnConverging(ty) => {\n-                                        let size = self.type_size(ty);\n+                                        let size = self.type_size(ty, self.substs());\n                                         self.call_c_abi(def_id, args, return_ptr.unwrap(), size)?\n                                     }\n                                     ty::FnDiverging => unimplemented!(),\n@@ -553,7 +526,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                                     let last_arg = args.last().unwrap();\n                                     let last = self.eval_operand(last_arg)?;\n                                     let last_ty = self.operand_ty(last_arg);\n-                                    let last_layout = self.type_layout(last_ty);\n+                                    let last_layout = self.type_layout(last_ty, self.substs());\n                                     match (&last_ty.sty, last_layout) {\n                                         (&ty::TyTuple(fields),\n                                          &Layout::Univariant { ref variant, .. }) => {\n@@ -638,15 +611,15 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n         // Filling drop.\n         // FIXME(solson): Trait objects (with no static size) probably get filled, too.\n-        let size = self.type_size(ty);\n+        let size = self.type_size(ty, self.substs());\n         self.memory.drop_fill(ptr, size)?;\n \n         Ok(())\n     }\n \n     fn read_discriminant_value(&self, adt_ptr: Pointer, adt_ty: Ty<'tcx>) -> EvalResult<u64> {\n         use rustc::ty::layout::Layout::*;\n-        let adt_layout = self.type_layout(adt_ty);\n+        let adt_layout = self.type_layout(adt_ty, self.substs());\n \n         let discr_val = match *adt_layout {\n             General { discr, .. } | CEnum { discr, .. } => {\n@@ -699,7 +672,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             // FIXME(solson): Handle different integer types correctly.\n             \"add_with_overflow\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty);\n+                let size = self.type_size(ty, self.substs());\n                 let left = self.memory.read_int(args[0], size)?;\n                 let right = self.memory.read_int(args[1], size)?;\n                 let (n, overflowed) = unsafe {\n@@ -713,7 +686,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n             \"copy_nonoverlapping\" => {\n                 let elem_ty = *substs.types.get(subst::FnSpace, 0);\n-                let elem_size = self.type_size(elem_ty);\n+                let elem_size = self.type_size(elem_ty, self.substs());\n                 let src = self.memory.read_ptr(args[0])?;\n                 let dest = self.memory.read_ptr(args[1])?;\n                 let count = self.memory.read_isize(args[2])?;\n@@ -729,7 +702,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n             \"forget\" => {\n                 let arg_ty = *substs.types.get(subst::FnSpace, 0);\n-                let arg_size = self.type_size(arg_ty);\n+                let arg_size = self.type_size(arg_ty, self.substs());\n                 self.memory.drop_fill(args[0], arg_size)?;\n             }\n \n@@ -748,7 +721,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             // FIXME(solson): Handle different integer types correctly.\n             \"mul_with_overflow\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty);\n+                let size = self.type_size(ty, self.substs());\n                 let left = self.memory.read_int(args[0], size)?;\n                 let right = self.memory.read_int(args[1], size)?;\n                 let (n, overflowed) = unsafe {\n@@ -760,7 +733,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n             \"offset\" => {\n                 let pointee_ty = *substs.types.get(subst::FnSpace, 0);\n-                let pointee_size = self.type_size(pointee_ty) as isize;\n+                let pointee_size = self.type_size(pointee_ty, self.substs()) as isize;\n                 let ptr_arg = args[0];\n                 let offset = self.memory.read_isize(args[1])?;\n \n@@ -781,7 +754,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             // FIXME(solson): Handle different integer types correctly. Use primvals?\n             \"overflowing_sub\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty);\n+                let size = self.type_size(ty, self.substs());\n                 let left = self.memory.read_int(args[0], size)?;\n                 let right = self.memory.read_int(args[1], size)?;\n                 let n = left.wrapping_sub(right);\n@@ -790,20 +763,20 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n             \"size_of\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n-                let size = self.type_size(ty) as u64;\n+                let size = self.type_size(ty, self.substs()) as u64;\n                 self.memory.write_uint(dest, size, dest_size)?;\n             }\n \n             \"size_of_val\" => {\n                 let ty = *substs.types.get(subst::FnSpace, 0);\n                 if self.type_is_sized(ty) {\n-                    let size = self.type_size(ty) as u64;\n+                    let size = self.type_size(ty, self.substs()) as u64;\n                     self.memory.write_uint(dest, size, dest_size)?;\n                 } else {\n                     match ty.sty {\n                         ty::TySlice(_) | ty::TyStr => {\n                             let elem_ty = ty.sequence_element_type(self.tcx);\n-                            let elem_size = self.type_size(elem_ty) as u64;\n+                            let elem_size = self.type_size(elem_ty, self.substs()) as u64;\n                             let ptr_size = self.memory.pointer_size as isize;\n                             let n = self.memory.read_usize(args[0].offset(ptr_size))?;\n                             self.memory.write_uint(dest, n * elem_size, dest_size)?;\n@@ -911,7 +884,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n     {\n         let dest = self.eval_lvalue(lvalue)?.to_ptr();\n         let dest_ty = self.lvalue_ty(lvalue);\n-        let dest_layout = self.type_layout(dest_ty);\n+        let dest_layout = self.type_layout(dest_ty, self.substs());\n \n         use rustc::mir::repr::Rvalue::*;\n         match *rvalue {\n@@ -951,7 +924,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n                     Array { .. } => {\n                         let elem_size = match dest_ty.sty {\n-                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty) as u64,\n+                            ty::TyArray(elem_ty, _) => self.type_size(elem_ty, self.substs()) as u64,\n                             _ => panic!(\"tried to assign {:?} to non-array type {:?}\",\n                                         kind, dest_ty),\n                         };\n@@ -1029,7 +1002,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n             Repeat(ref operand, _) => {\n                 let (elem_size, length) = match dest_ty.sty {\n-                    ty::TyArray(elem_ty, n) => (self.type_size(elem_ty), n),\n+                    ty::TyArray(elem_ty, n) => (self.type_size(elem_ty, self.substs()), n),\n                     _ => panic!(\"tried to assign array-repeat to non-array type {:?}\", dest_ty),\n                 };\n \n@@ -1070,7 +1043,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n             }\n \n             Box(ty) => {\n-                let size = self.type_size(ty);\n+                let size = self.type_size(ty, self.substs());\n                 let ptr = self.memory.allocate(size);\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n@@ -1164,7 +1137,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n     }\n \n     fn get_field_offset(&self, ty: Ty<'tcx>, field_index: usize) -> EvalResult<Size> {\n-        let layout = self.type_layout(ty);\n+        let layout = self.type_layout(ty, self.substs());\n \n         use rustc::ty::layout::Layout::*;\n         match *layout {\n@@ -1229,13 +1202,13 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                     substs: substs,\n                     kind: ConstantKind::Global,\n                 };\n-                *self.gecx.statics.get(&cid).expect(\"static should have been cached (lvalue)\")\n+                *self.statics.get(&cid).expect(\"static should have been cached (lvalue)\")\n             },\n \n             Projection(ref proj) => {\n                 let base = self.eval_lvalue(&proj.base)?;\n                 let base_ty = self.lvalue_ty(&proj.base);\n-                let base_layout = self.type_layout(base_ty);\n+                let base_layout = self.type_layout(base_ty, self.substs());\n \n                 use rustc::mir::repr::ProjectionElem::*;\n                 match proj.elem {\n@@ -1296,7 +1269,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n                     Index(ref operand) => {\n                         let elem_size = match base_ty.sty {\n                             ty::TyArray(elem_ty, _) |\n-                            ty::TySlice(elem_ty) => self.type_size(elem_ty),\n+                            ty::TySlice(elem_ty) => self.type_size(elem_ty, self.substs()),\n                             _ => panic!(\"indexing expected an array or slice, got {:?}\", base_ty),\n                         };\n                         let n_ptr = self.eval_operand(operand)?;\n@@ -1313,34 +1286,22 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n     }\n \n     fn lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n-        self.monomorphize(self.mir().lvalue_ty(self.tcx, lvalue).to_ty(self.tcx))\n+        self.monomorphize(self.mir().lvalue_ty(self.tcx, lvalue).to_ty(self.tcx), self.substs())\n     }\n \n     fn operand_ty(&self, operand: &mir::Operand<'tcx>) -> Ty<'tcx> {\n-        self.monomorphize(self.mir().operand_ty(self.tcx, operand))\n-    }\n-\n-    fn monomorphize(&self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.gecx.monomorphize(ty, self.substs())\n+        self.monomorphize(self.mir().operand_ty(self.tcx, operand), self.substs())\n     }\n \n     fn move_(&mut self, src: Pointer, dest: Pointer, ty: Ty<'tcx>) -> EvalResult<()> {\n-        let size = self.type_size(ty);\n+        let size = self.type_size(ty, self.substs());\n         self.memory.copy(src, dest, size)?;\n         if self.type_needs_drop(ty) {\n             self.memory.drop_fill(src, size)?;\n         }\n         Ok(())\n     }\n \n-    fn type_size(&self, ty: Ty<'tcx>) -> usize {\n-        self.gecx.type_size(ty, self.substs())\n-    }\n-\n-    fn type_layout(&self, ty: Ty<'tcx>) -> &'tcx Layout {\n-        self.gecx.type_layout(ty, self.substs())\n-    }\n-\n     pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<PrimVal> {\n         use syntax::ast::{IntTy, UintTy};\n         let val = match (self.memory.pointer_size, &ty.sty) {\n@@ -1380,7 +1341,7 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         Ok(val)\n     }\n \n-    fn frame(&self) -> &Frame<'mir, 'tcx> {\n+    fn frame(&self) -> &Frame<'a, 'tcx> {\n         self.stack.last().expect(\"no call frames exist\")\n     }\n \n@@ -1389,11 +1350,11 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n         frame.mir.basic_block_data(frame.next_block)\n     }\n \n-    fn frame_mut(&mut self) -> &mut Frame<'mir, 'tcx> {\n+    fn frame_mut(&mut self) -> &mut Frame<'a, 'tcx> {\n         self.stack.last_mut().expect(\"no call frames exist\")\n     }\n \n-    fn mir(&self) -> CachedMir<'mir, 'tcx> {\n+    fn mir(&self) -> CachedMir<'a, 'tcx> {\n         self.frame().mir.clone()\n     }\n "}, {"sha": "836df7a8bf9ef635009825616564a5cdccf715e5", "filename": "src/interpreter/stepper.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8fec1a7aa776ed0f1373a1531b8665f4e35919f5/src%2Finterpreter%2Fstepper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fec1a7aa776ed0f1373a1531b8665f4e35919f5/src%2Finterpreter%2Fstepper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstepper.rs?ref=8fec1a7aa776ed0f1373a1531b8665f4e35919f5", "patch": "@@ -1,5 +1,4 @@\n use super::{\n-    FnEvalContext,\n     CachedMir,\n     TerminatorTarget,\n     ConstantId,\n@@ -15,67 +14,67 @@ use syntax::codemap::Span;\n use std::rc::Rc;\n use memory::Pointer;\n \n-pub struct Stepper<'fncx, 'a: 'fncx, 'b: 'a + 'mir, 'mir: 'fncx, 'tcx: 'b>{\n-    fncx: &'fncx mut FnEvalContext<'a, 'b, 'mir, 'tcx>,\n+pub struct Stepper<'fncx, 'a: 'fncx, 'tcx: 'a>{\n+    gecx: &'fncx mut GlobalEvalContext<'a, 'tcx>,\n \n     // a cache of the constants to be computed before the next statement/terminator\n     // this is an optimization, so we don't have to allocate a new vector for every statement\n-    constants: Vec<(ConstantId<'tcx>, Span, Pointer, CachedMir<'mir, 'tcx>)>,\n+    constants: Vec<(ConstantId<'tcx>, Span, Pointer, CachedMir<'a, 'tcx>)>,\n }\n \n-impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx> {\n-    pub(super) fn new(fncx: &'fncx mut FnEvalContext<'a, 'b, 'mir, 'tcx>) -> Self {\n+impl<'fncx, 'a, 'tcx> Stepper<'fncx, 'a, 'tcx> {\n+    pub(super) fn new(gecx: &'fncx mut GlobalEvalContext<'a, 'tcx>) -> Self {\n         Stepper {\n-            fncx: fncx,\n+            gecx: gecx,\n             constants: Vec::new(),\n         }\n     }\n \n     fn statement(&mut self, stmt: &mir::Statement<'tcx>) -> EvalResult<()> {\n         trace!(\"{:?}\", stmt);\n         let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n-        let result = self.fncx.eval_assignment(lvalue, rvalue);\n-        self.fncx.maybe_report(result)?;\n-        self.fncx.frame_mut().stmt += 1;\n+        let result = self.gecx.eval_assignment(lvalue, rvalue);\n+        self.gecx.maybe_report(result)?;\n+        self.gecx.frame_mut().stmt += 1;\n         Ok(())\n     }\n \n     fn terminator(&mut self, terminator: &mir::Terminator<'tcx>) -> EvalResult<()> {\n         // after a terminator we go to a new block\n-        self.fncx.frame_mut().stmt = 0;\n+        self.gecx.frame_mut().stmt = 0;\n         let term = {\n             trace!(\"{:?}\", terminator.kind);\n-            let result = self.fncx.eval_terminator(terminator);\n-            self.fncx.maybe_report(result)?\n+            let result = self.gecx.eval_terminator(terminator);\n+            self.gecx.maybe_report(result)?\n         };\n         match term {\n             TerminatorTarget::Return => {\n-                self.fncx.pop_stack_frame();\n+                self.gecx.pop_stack_frame();\n             },\n             TerminatorTarget::Block |\n-            TerminatorTarget::Call => trace!(\"// {:?}\", self.fncx.frame().next_block),\n+            TerminatorTarget::Call => trace!(\"// {:?}\", self.gecx.frame().next_block),\n         }\n         Ok(())\n     }\n \n     // returns true as long as there are more things to do\n     pub fn step(&mut self) -> EvalResult<bool> {\n-        if self.fncx.stack.is_empty() {\n+        if self.gecx.stack.is_empty() {\n             return Ok(false);\n         }\n \n-        let block = self.fncx.frame().next_block;\n-        let stmt = self.fncx.frame().stmt;\n-        let mir = self.fncx.mir();\n+        let block = self.gecx.frame().next_block;\n+        let stmt = self.gecx.frame().stmt;\n+        let mir = self.gecx.mir();\n         let basic_block = mir.basic_block_data(block);\n \n         if let Some(ref stmt) = basic_block.statements.get(stmt) {\n             assert!(self.constants.is_empty());\n             ConstantExtractor {\n                 span: stmt.span,\n-                substs: self.fncx.substs(),\n-                def_id: self.fncx.frame().def_id,\n-                gecx: self.fncx.gecx,\n+                substs: self.gecx.substs(),\n+                def_id: self.gecx.frame().def_id,\n+                gecx: self.gecx,\n                 constants: &mut self.constants,\n                 mir: &mir,\n             }.visit_statement(block, stmt);\n@@ -91,9 +90,9 @@ impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx\n         assert!(self.constants.is_empty());\n         ConstantExtractor {\n             span: terminator.span,\n-            substs: self.fncx.substs(),\n-            def_id: self.fncx.frame().def_id,\n-            gecx: self.fncx.gecx,\n+            substs: self.gecx.substs(),\n+            def_id: self.gecx.frame().def_id,\n+            gecx: self.gecx,\n             constants: &mut self.constants,\n             mir: &mir,\n         }.visit_terminator(block, terminator);\n@@ -109,7 +108,7 @@ impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx\n         assert!(!self.constants.is_empty());\n         for (cid, span, return_ptr, mir) in self.constants.drain(..) {\n             trace!(\"queuing a constant\");\n-            self.fncx.push_stack_frame(cid.def_id, span, mir, cid.substs, Some(return_ptr));\n+            self.gecx.push_stack_frame(cid.def_id, span, mir, cid.substs, Some(return_ptr));\n         }\n         // self.step() can't be \"done\", so it can't return false\n         assert!(self.step()?);"}]}