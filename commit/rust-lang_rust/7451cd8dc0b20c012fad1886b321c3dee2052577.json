{"sha": "7451cd8dc0b20c012fad1886b321c3dee2052577", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NTFjZDhkYzBiMjBjMDEyZmFkMTg4NmIzMjFjM2RlZTIwNTI1Nzc=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-01-28T05:04:50Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-02-07T09:41:30Z"}, "message": "Deduplicate mismatched delimiter errors\n\nDelay unmatched delimiter errors until after the parser has run to\ndeduplicate them when parsing and attempt recovering intelligently.", "tree": {"sha": "564bb3390199f080413ec319481f3f37fa345054", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/564bb3390199f080413ec319481f3f37fa345054"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7451cd8dc0b20c012fad1886b321c3dee2052577", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7451cd8dc0b20c012fad1886b321c3dee2052577", "html_url": "https://github.com/rust-lang/rust/commit/7451cd8dc0b20c012fad1886b321c3dee2052577", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7451cd8dc0b20c012fad1886b321c3dee2052577/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "825f355c7483746f3a17166f34dfabe3b2df1741", "url": "https://api.github.com/repos/rust-lang/rust/commits/825f355c7483746f3a17166f34dfabe3b2df1741", "html_url": "https://github.com/rust-lang/rust/commit/825f355c7483746f3a17166f34dfabe3b2df1741"}], "stats": {"total": 493, "additions": 335, "deletions": 158}, "files": [{"sha": "f04bd7b8f021b0858d965a7f87897e09d7f30f4e", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -674,8 +674,8 @@ impl EmitterWriter {\n         //   | |  something about `foo`\n         //   | something about `fn foo()`\n         annotations_position.sort_by(|a, b| {\n-            // Decreasing order\n-            a.1.len().cmp(&b.1.len()).reverse()\n+            // Decreasing order. When `a` and `b` are the same length, prefer `Primary`.\n+            (a.1.len(), !a.1.is_primary).cmp(&(b.1.len(), !b.1.is_primary)).reverse()\n         });\n \n         // Write the underlines."}, {"sha": "ecbc900215f7b66df79ab829a9c04641253e3031", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -436,7 +436,13 @@ impl cstore::CStore {\n \n         let source_file = sess.parse_sess.source_map().new_source_file(source_name, def.body);\n         let local_span = Span::new(source_file.start_pos, source_file.end_pos, NO_EXPANSION);\n-        let body = source_file_to_stream(&sess.parse_sess, source_file, None);\n+        let (body, errors) = source_file_to_stream(&sess.parse_sess, source_file, None);\n+        for err in errors {\n+            sess.struct_span_err(\n+                err.found_span,\n+                \"unclosed delimiter cstore\",\n+            ).emit();\n+        }\n \n         // Mark the attrs as used\n         let attrs = data.get_item_attrs(id.index, sess);"}, {"sha": "d3fc1c03634eaad45435bb63692c6bceb825e74a", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -33,6 +33,15 @@ impl Default for TokenAndSpan {\n     }\n }\n \n+#[derive(Clone, Debug)]\n+pub struct UnmatchedBrace {\n+    pub expected_delim: token::DelimToken,\n+    pub found_delim: token::DelimToken,\n+    pub found_span: Span,\n+    pub unclosed_span: Option<Span>,\n+    pub candidate_span: Option<Span>,\n+}\n+\n pub struct StringReader<'a> {\n     pub sess: &'a ParseSess,\n     /// The absolute offset within the source_map of the next character to read\n@@ -58,6 +67,7 @@ pub struct StringReader<'a> {\n     span_src_raw: Span,\n     /// Stack of open delimiters and their spans. Used for error message.\n     open_braces: Vec<(token::DelimToken, Span)>,\n+    crate unmatched_braces: Vec<UnmatchedBrace>,\n     /// The type and spans for all braces\n     ///\n     /// Used only for error recovery when arriving to EOF with mismatched braces.\n@@ -222,6 +232,7 @@ impl<'a> StringReader<'a> {\n             span: syntax_pos::DUMMY_SP,\n             span_src_raw: syntax_pos::DUMMY_SP,\n             open_braces: Vec::new(),\n+            unmatched_braces: Vec::new(),\n             matching_delim_spans: Vec::new(),\n             override_span,\n             last_unclosed_found_span: None,"}, {"sha": "0db36c84cdfeb532bfe7b3f7d0c033a4300d1c59", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -1,5 +1,5 @@\n use crate::print::pprust::token_to_string;\n-use crate::parse::lexer::StringReader;\n+use crate::parse::lexer::{StringReader, UnmatchedBrace};\n use crate::parse::{token, PResult};\n use crate::tokenstream::{DelimSpan, IsJoint::*, TokenStream, TokenTree, TreeAndJoint};\n \n@@ -101,38 +101,38 @@ impl<'a> StringReader<'a> {\n                     }\n                     // Incorrect delimiter.\n                     token::CloseDelim(other) => {\n-                        let token_str = token_to_string(&self.token);\n+                        let mut unclosed_delimiter = None;\n+                        let mut candidate = None;\n                         if self.last_unclosed_found_span != Some(self.span) {\n                             // do not complain about the same unclosed delimiter multiple times\n                             self.last_unclosed_found_span = Some(self.span);\n-                            let msg = format!(\"incorrect close delimiter: `{}`\", token_str);\n-                            let mut err = self.sess.span_diagnostic.struct_span_err(\n-                                self.span,\n-                                &msg,\n-                            );\n-                            err.span_label(self.span, \"incorrect close delimiter\");\n                             // This is a conservative error: only report the last unclosed\n                             // delimiter. The previous unclosed delimiters could actually be\n                             // closed! The parser just hasn't gotten to them yet.\n                             if let Some(&(_, sp)) = self.open_braces.last() {\n-                                err.span_label(sp, \"un-closed delimiter\");\n+                                unclosed_delimiter = Some(sp);\n                             };\n                             if let Some(current_padding) = sm.span_to_margin(self.span) {\n                                 for (brace, brace_span) in &self.open_braces {\n                                     if let Some(padding) = sm.span_to_margin(*brace_span) {\n                                         // high likelihood of these two corresponding\n                                         if current_padding == padding && brace == &other {\n-                                            err.span_label(\n-                                                *brace_span,\n-                                                \"close delimiter possibly meant for this\",\n-                                            );\n+                                            candidate = Some(*brace_span);\n                                         }\n                                     }\n                                 }\n                             }\n-                            err.emit();\n+                            let (tok, _) = self.open_braces.pop().unwrap();\n+                            self.unmatched_braces.push(UnmatchedBrace {\n+                                expected_delim: tok,\n+                                found_delim: other,\n+                                found_span: self.span,\n+                                unclosed_span: unclosed_delimiter,\n+                                candidate_span: candidate,\n+                            });\n+                        } else {\n+                            self.open_braces.pop();\n                         }\n-                        self.open_braces.pop().unwrap();\n \n                         // If the incorrect delimiter matches an earlier opening\n                         // delimiter, then don't consume it (it can be used to"}, {"sha": "52c7e774ab64a4d9607461482fccb288bb019168", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 40, "deletions": 17, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -9,6 +9,7 @@ use crate::parse::parser::Parser;\n use crate::symbol::Symbol;\n use crate::tokenstream::{TokenStream, TokenTree};\n use crate::diagnostics::plugin::ErrorMap;\n+use crate::print::pprust::token_to_string;\n \n use rustc_data_structures::sync::{Lrc, Lock};\n use syntax_pos::{Span, SourceFile, FileName, MultiSpan};\n@@ -136,15 +137,17 @@ pub fn parse_crate_attrs_from_source_str(name: FileName, source: String, sess: &\n     new_parser_from_source_str(sess, name, source).parse_inner_attributes()\n }\n \n-pub fn parse_stream_from_source_str(name: FileName, source: String, sess: &ParseSess,\n-                                    override_span: Option<Span>)\n-                                    -> TokenStream {\n+pub fn parse_stream_from_source_str(\n+    name: FileName,\n+    source: String,\n+    sess: &ParseSess,\n+    override_span: Option<Span>,\n+) -> (TokenStream, Vec<lexer::UnmatchedBrace>) {\n     source_file_to_stream(sess, sess.source_map().new_source_file(name, source), override_span)\n }\n \n /// Create a new parser from a source string\n-pub fn new_parser_from_source_str(sess: &ParseSess, name: FileName, source: String)\n-                                      -> Parser<'_> {\n+pub fn new_parser_from_source_str(sess: &ParseSess, name: FileName, source: String) -> Parser<'_> {\n     panictry_buffer!(&sess.span_diagnostic, maybe_new_parser_from_source_str(sess, name, source))\n }\n \n@@ -195,12 +198,14 @@ fn source_file_to_parser(sess: &ParseSess, source_file: Lrc<SourceFile>) -> Pars\n \n /// Given a source_file and config, return a parser. Returns any buffered errors from lexing the\n /// initial token stream.\n-fn maybe_source_file_to_parser(sess: &ParseSess, source_file: Lrc<SourceFile>)\n-    -> Result<Parser<'_>, Vec<Diagnostic>>\n-{\n+fn maybe_source_file_to_parser(\n+    sess: &ParseSess,\n+    source_file: Lrc<SourceFile>,\n+) -> Result<Parser<'_>, Vec<Diagnostic>> {\n     let end_pos = source_file.end_pos;\n-    let mut parser = stream_to_parser(sess, maybe_file_to_stream(sess, source_file, None)?);\n-\n+    let (stream, unclosed_delims) = maybe_file_to_stream(sess, source_file, None)?;\n+    let mut parser = stream_to_parser(sess, stream);\n+    parser.unclosed_delims = unclosed_delims;\n     if parser.token == token::Eof && parser.span.is_dummy() {\n         parser.span = Span::new(end_pos, end_pos, parser.span.ctxt());\n     }\n@@ -247,25 +252,43 @@ fn file_to_source_file(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n }\n \n /// Given a source_file, produce a sequence of token-trees\n-pub fn source_file_to_stream(sess: &ParseSess,\n-                             source_file: Lrc<SourceFile>,\n-                             override_span: Option<Span>) -> TokenStream {\n+pub fn source_file_to_stream(\n+    sess: &ParseSess,\n+    source_file: Lrc<SourceFile>,\n+    override_span: Option<Span>,\n+) -> (TokenStream, Vec<lexer::UnmatchedBrace>) {\n     panictry_buffer!(&sess.span_diagnostic, maybe_file_to_stream(sess, source_file, override_span))\n }\n \n /// Given a source file, produce a sequence of token-trees. Returns any buffered errors from\n /// parsing the token tream.\n-pub fn maybe_file_to_stream(sess: &ParseSess,\n-                            source_file: Lrc<SourceFile>,\n-                            override_span: Option<Span>) -> Result<TokenStream, Vec<Diagnostic>> {\n+pub fn maybe_file_to_stream(\n+    sess: &ParseSess,\n+    source_file: Lrc<SourceFile>,\n+    override_span: Option<Span>,\n+) -> Result<(TokenStream, Vec<lexer::UnmatchedBrace>), Vec<Diagnostic>> {\n     let mut srdr = lexer::StringReader::new_or_buffered_errs(sess, source_file, override_span)?;\n     srdr.real_token();\n \n     match srdr.parse_all_token_trees() {\n-        Ok(stream) => Ok(stream),\n+        Ok(stream) => Ok((stream, srdr.unmatched_braces)),\n         Err(err) => {\n             let mut buffer = Vec::with_capacity(1);\n             err.buffer(&mut buffer);\n+            for unmatched in srdr.unmatched_braces {\n+                let mut db = sess.span_diagnostic.struct_span_err(unmatched.found_span, &format!(\n+                    \"incorrect close delimiter: `{}`\",\n+                    token_to_string(&token::Token::CloseDelim(unmatched.found_delim)),\n+                ));\n+                db.span_label(unmatched.found_span, \"incorrect close delimiter\");\n+                if let Some(sp) = unmatched.candidate_span {\n+                    db.span_label(sp, \"close delimiter possibly meant for this\");\n+                }\n+                if let Some(sp) = unmatched.unclosed_span {\n+                    db.span_label(sp, \"un-closed delimiter\");\n+                }\n+                db.buffer(&mut buffer);\n+            }\n             Err(buffer)\n         }\n     }"}, {"sha": "2e605ab6544dfdb60127ab048ee896c584b92d83", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 196, "deletions": 65, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -35,7 +35,7 @@ use crate::ext::base::DummyResult;\n use crate::source_map::{self, SourceMap, Spanned, respan};\n use crate::errors::{self, Applicability, DiagnosticBuilder, DiagnosticId};\n use crate::parse::{self, SeqSep, classify, token};\n-use crate::parse::lexer::TokenAndSpan;\n+use crate::parse::lexer::{TokenAndSpan, UnmatchedBrace};\n use crate::parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use crate::parse::token::DelimToken;\n use crate::parse::{new_sub_parser_from_file, ParseSess, Directory, DirectoryOwnership};\n@@ -251,6 +251,8 @@ pub struct Parser<'a> {\n     ///\n     /// See the comments in the `parse_path_segment` function for more details.\n     crate unmatched_angle_bracket_count: u32,\n+    crate max_angle_bracket_count: u32,\n+    crate unclosed_delims: Vec<UnmatchedBrace>,\n }\n \n \n@@ -573,6 +575,8 @@ impl<'a> Parser<'a> {\n             desugar_doc_comments,\n             cfg_mods: true,\n             unmatched_angle_bracket_count: 0,\n+            max_angle_bracket_count: 0,\n+            unclosed_delims: Vec::new(),\n         };\n \n         let tok = parser.next_tok();\n@@ -642,11 +646,11 @@ impl<'a> Parser<'a> {\n \n     /// Expect and consume the token t. Signal an error if\n     /// the next token is not t.\n-    pub fn expect(&mut self, t: &token::Token) -> PResult<'a,  ()> {\n+    pub fn expect(&mut self, t: &token::Token) -> PResult<'a,  bool /* recovered */> {\n         if self.expected_tokens.is_empty() {\n             if self.token == *t {\n                 self.bump();\n-                Ok(())\n+                Ok(false)\n             } else {\n                 let token_str = pprust::token_to_string(t);\n                 let this_token_str = self.this_token_descr();\n@@ -661,6 +665,12 @@ impl<'a> Parser<'a> {\n                     self.sess.source_map().next_point(self.prev_span)\n                 };\n                 let label_exp = format!(\"expected `{}`\", token_str);\n+                match self.recover_closing_delimiter(&[t.clone()], err) {\n+                    Err(e) => err = e,\n+                    Ok(recovered) => {\n+                        return Ok(recovered);\n+                    }\n+                }\n                 let cm = self.sess.source_map();\n                 match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n                     (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n@@ -680,12 +690,62 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn recover_closing_delimiter(\n+        &mut self,\n+        tokens: &[token::Token],\n+        mut err: DiagnosticBuilder<'a>,\n+    ) -> PResult<'a, bool> {\n+        let mut pos = None;\n+        // we want to use the last closing delim that would apply\n+        for (i, unmatched) in self.unclosed_delims.iter().enumerate().rev() {\n+            if tokens.contains(&token::CloseDelim(unmatched.expected_delim))\n+                && Some(self.span) > unmatched.unclosed_span\n+            {\n+                pos = Some(i);\n+            }\n+        }\n+        match pos {\n+            Some(pos) => {\n+                // Recover and assume that the detected unclosed delimiter was meant for\n+                // this location. Emit the diagnostic and act as if the delimiter was\n+                // present for the parser's sake.\n+\n+                 // Don't attempt to recover from this unclosed delimiter more than once.\n+                let unmatched = self.unclosed_delims.remove(pos);\n+                let delim = TokenType::Token(token::CloseDelim(unmatched.expected_delim));\n+\n+                 // We want to suggest the inclusion of the closing delimiter where it makes\n+                // the most sense, which is immediately after the last token:\n+                //\n+                //  {foo(bar {}}\n+                //      -      ^ help: `)` may belong here\n+                //      |\n+                //      in order to close this...\n+                if let Some(sp) = unmatched.unclosed_span {\n+                    err.span_label(sp, \"in order to close this...\");\n+                }\n+                err.span_suggestion_short_with_applicability(\n+                    self.sess.source_map().next_point(self.prev_span),\n+                    &format!(\"{} may belong here\", delim.to_string()),\n+                    delim.to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                err.emit();\n+                // self.expected_tokens.clear();  // reduce errors\n+                Ok(true)\n+            }\n+            _ => Err(err),\n+        }\n+    }\n+\n     /// Expect next token to be edible or inedible token.  If edible,\n     /// then consume it; if inedible, then return without consuming\n     /// anything.  Signal a fatal error if next token is unexpected.\n-    pub fn expect_one_of(&mut self,\n-                         edible: &[token::Token],\n-                         inedible: &[token::Token]) -> PResult<'a,  ()>{\n+    pub fn expect_one_of(\n+        &mut self,\n+        edible: &[token::Token],\n+        inedible: &[token::Token],\n+    ) -> PResult<'a, bool /* recovered */> {\n         fn tokens_to_string(tokens: &[TokenType]) -> String {\n             let mut i = tokens.iter();\n             // This might be a sign we need a connect method on Iterator.\n@@ -705,10 +765,10 @@ impl<'a> Parser<'a> {\n         }\n         if edible.contains(&self.token) {\n             self.bump();\n-            Ok(())\n+            Ok(false)\n         } else if inedible.contains(&self.token) {\n             // leave it in the input\n-            Ok(())\n+            Ok(false)\n         } else {\n             let mut expected = edible.iter()\n                 .map(|x| TokenType::Token(x.clone()))\n@@ -759,6 +819,15 @@ impl<'a> Parser<'a> {\n             } else {\n                 label_sp\n             };\n+            match self.recover_closing_delimiter(&expected.iter().filter_map(|tt| match tt {\n+                TokenType::Token(t) => Some(t.clone()),\n+                _ => None,\n+            }).collect::<Vec<_>>(), err) {\n+                Err(e) => err = e,\n+                Ok(recovered) => {\n+                    return Ok(recovered);\n+                }\n+            }\n \n             let cm = self.sess.source_map();\n             match (cm.lookup_line(self.span.lo()), cm.lookup_line(sp.lo())) {\n@@ -1053,6 +1122,7 @@ impl<'a> Parser<'a> {\n         if ate {\n             // See doc comment for `unmatched_angle_bracket_count`.\n             self.unmatched_angle_bracket_count += 1;\n+            self.max_angle_bracket_count += 1;\n             debug!(\"eat_lt: (increment) count={:?}\", self.unmatched_angle_bracket_count);\n         }\n \n@@ -1093,14 +1163,30 @@ impl<'a> Parser<'a> {\n         };\n \n         match ate {\n-            Some(x) => {\n+            Some(_) => {\n                 // See doc comment for `unmatched_angle_bracket_count`.\n                 self.unmatched_angle_bracket_count -= 1;\n                 debug!(\"expect_gt: (decrement) count={:?}\", self.unmatched_angle_bracket_count);\n \n-                Ok(x)\n+                Ok(())\n             },\n-            None => self.unexpected(),\n+            None => {\n+                match (\n+                    &self.token,\n+                    self.unmatched_angle_bracket_count,\n+                    self.max_angle_bracket_count > 1,\n+                ) {\n+                    // (token::OpenDelim(_), 1, true) | (token::Semi, 1, true) => {\n+                    //     self.struct_span_err(\n+                    //         self.span,\n+                    //         &format!(\"expected `>`, found `{}`\", self.this_token_to_string()),\n+                    //     // ).span_suggestion_short_with_applicability(\n+                    //     ).emit();\n+                    //     Ok(())\n+                    // }\n+                    _ => self.unexpected(),\n+                }\n+            }\n         }\n     }\n \n@@ -1127,19 +1213,22 @@ impl<'a> Parser<'a> {\n                                   -> PResult<'a, Vec<T>> where\n         F: FnMut(&mut Parser<'a>) -> PResult<'a,  T>,\n     {\n-        let val = self.parse_seq_to_before_end(ket, sep, f)?;\n-        self.bump();\n+        let (val, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n+        if !recovered {\n+            self.bump();\n+        }\n         Ok(val)\n     }\n \n     /// Parse a sequence, not including the closing delimiter. The function\n     /// f must consume tokens until reaching the next separator or\n     /// closing bracket.\n-    pub fn parse_seq_to_before_end<T, F>(&mut self,\n-                                         ket: &token::Token,\n-                                         sep: SeqSep,\n-                                         f: F)\n-                                         -> PResult<'a, Vec<T>>\n+    pub fn parse_seq_to_before_end<T, F>(\n+        &mut self,\n+        ket: &token::Token,\n+        sep: SeqSep,\n+        f: F,\n+    ) -> PResult<'a, (Vec<T>, bool)>\n         where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>\n     {\n         self.parse_seq_to_before_tokens(&[ket], sep, TokenExpectType::Expect, f)\n@@ -1151,10 +1240,11 @@ impl<'a> Parser<'a> {\n         sep: SeqSep,\n         expect: TokenExpectType,\n         mut f: F,\n-    ) -> PResult<'a, Vec<T>>\n+    ) -> PResult<'a, (Vec<T>, bool /* recovered */)>\n         where F: FnMut(&mut Parser<'a>) -> PResult<'a, T>\n     {\n-        let mut first: bool = true;\n+        let mut first = true;\n+        let mut recovered = false;\n         let mut v = vec![];\n         while !kets.iter().any(|k| {\n                 match expect {\n@@ -1170,23 +1260,30 @@ impl<'a> Parser<'a> {\n                 if first {\n                     first = false;\n                 } else {\n-                    if let Err(mut e) = self.expect(t) {\n-                        // Attempt to keep parsing if it was a similar separator\n-                        if let Some(ref tokens) = t.similar_tokens() {\n-                            if tokens.contains(&self.token) {\n-                                self.bump();\n-                            }\n+                    match self.expect(t) {\n+                        Ok(false) => {}\n+                        Ok(true) => {\n+                            recovered = true;\n+                            break;\n                         }\n-                        e.emit();\n-                        // Attempt to keep parsing if it was an omitted separator\n-                        match f(self) {\n-                            Ok(t) => {\n-                                v.push(t);\n-                                continue;\n-                            },\n-                            Err(mut e) => {\n-                                e.cancel();\n-                                break;\n+                        Err(mut e) => {\n+                            // Attempt to keep parsing if it was a similar separator\n+                            if let Some(ref tokens) = t.similar_tokens() {\n+                                if tokens.contains(&self.token) {\n+                                    self.bump();\n+                                }\n+                            }\n+                            e.emit();\n+                            // Attempt to keep parsing if it was an omitted separator\n+                            match f(self) {\n+                                Ok(t) => {\n+                                    v.push(t);\n+                                    continue;\n+                                },\n+                                Err(mut e) => {\n+                                    e.cancel();\n+                                    break;\n+                                }\n                             }\n                         }\n                     }\n@@ -1205,23 +1302,26 @@ impl<'a> Parser<'a> {\n             v.push(t);\n         }\n \n-        Ok(v)\n+        Ok((v, recovered))\n     }\n \n     /// Parse a sequence, including the closing delimiter. The function\n     /// f must consume tokens until reaching the next separator or\n     /// closing bracket.\n-    fn parse_unspanned_seq<T, F>(&mut self,\n-                                     bra: &token::Token,\n-                                     ket: &token::Token,\n-                                     sep: SeqSep,\n-                                     f: F)\n-                                     -> PResult<'a, Vec<T>> where\n+    fn parse_unspanned_seq<T, F>(\n+        &mut self,\n+        bra: &token::Token,\n+        ket: &token::Token,\n+        sep: SeqSep,\n+        f: F,\n+    ) -> PResult<'a, Vec<T>> where\n         F: FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n     {\n         self.expect(bra)?;\n-        let result = self.parse_seq_to_before_end(ket, sep, f)?;\n-        self.eat(ket);\n+        let (result, recovered) = self.parse_seq_to_before_end(ket, sep, f)?;\n+        if !recovered {\n+            self.eat(ket);\n+        }\n         Ok(result)\n     }\n \n@@ -2273,7 +2373,10 @@ impl<'a> Parser<'a> {\n             // We use `style == PathStyle::Expr` to check if this is in a recursion or not. If\n             // it isn't, then we reset the unmatched angle bracket count as we're about to start\n             // parsing a new path.\n-            if style == PathStyle::Expr { self.unmatched_angle_bracket_count = 0; }\n+            if style == PathStyle::Expr {\n+                self.unmatched_angle_bracket_count = 0;\n+                self.max_angle_bracket_count = 0;\n+            }\n \n             let args = if self.eat_lt() {\n                 // `<'a, T, A = U>`\n@@ -2285,12 +2388,14 @@ impl<'a> Parser<'a> {\n             } else {\n                 // `(T, U) -> R`\n                 self.bump(); // `(`\n-                let inputs = self.parse_seq_to_before_tokens(\n+                let (inputs, recovered) = self.parse_seq_to_before_tokens(\n                     &[&token::CloseDelim(token::Paren)],\n                     SeqSep::trailing_allowed(token::Comma),\n                     TokenExpectType::Expect,\n                     |p| p.parse_ty())?;\n-                self.bump(); // `)`\n+                if !recovered {\n+                    self.bump(); // `)`\n+                }\n                 let span = lo.to(self.prev_span);\n                 let output = if self.eat(&token::RArrow) {\n                     Some(self.parse_ty_common(false, false)?)\n@@ -2496,17 +2601,23 @@ impl<'a> Parser<'a> {\n                 // (e,) is a tuple with only one field, e\n                 let mut es = vec![];\n                 let mut trailing_comma = false;\n+                let mut recovered = false;\n                 while self.token != token::CloseDelim(token::Paren) {\n                     es.push(self.parse_expr()?);\n-                    self.expect_one_of(&[], &[token::Comma, token::CloseDelim(token::Paren)])?;\n+                    recovered = self.expect_one_of(\n+                        &[],\n+                        &[token::Comma, token::CloseDelim(token::Paren)],\n+                    )?;\n                     if self.eat(&token::Comma) {\n                         trailing_comma = true;\n                     } else {\n                         trailing_comma = false;\n                         break;\n                     }\n                 }\n-                self.bump();\n+                if !recovered {\n+                    self.bump();\n+                }\n \n                 hi = self.prev_span;\n                 ex = if es.len() == 1 && !trailing_comma {\n@@ -2802,7 +2913,7 @@ impl<'a> Parser<'a> {\n \n             match self.expect_one_of(&[token::Comma],\n                                      &[token::CloseDelim(token::Brace)]) {\n-                Ok(()) => if let Some(f) = parsed_field.or(recovery_field) {\n+                Ok(_) => if let Some(f) = parsed_field.or(recovery_field) {\n                     // only include the field if there's no parse error for the field name\n                     fields.push(f);\n                 }\n@@ -6011,7 +6122,7 @@ impl<'a> Parser<'a> {\n \n         let sp = self.span;\n         let mut variadic = false;\n-        let args: Vec<Option<Arg>> =\n+        let (args, recovered): (Vec<Option<Arg>>, bool) =\n             self.parse_seq_to_before_end(\n                 &token::CloseDelim(token::Paren),\n                 SeqSep::trailing_allowed(token::Comma),\n@@ -6059,7 +6170,9 @@ impl<'a> Parser<'a> {\n                 }\n             )?;\n \n-        self.eat(&token::CloseDelim(token::Paren));\n+        if !recovered {\n+            self.eat(&token::CloseDelim(token::Paren));\n+        }\n \n         let args: Vec<_> = args.into_iter().filter_map(|x| x).collect();\n \n@@ -6204,24 +6317,26 @@ impl<'a> Parser<'a> {\n \n         // Parse the rest of the function parameter list.\n         let sep = SeqSep::trailing_allowed(token::Comma);\n-        let fn_inputs = if let Some(self_arg) = self_arg {\n+        let (fn_inputs, recovered) = if let Some(self_arg) = self_arg {\n             if self.check(&token::CloseDelim(token::Paren)) {\n-                vec![self_arg]\n+                (vec![self_arg], false)\n             } else if self.eat(&token::Comma) {\n                 let mut fn_inputs = vec![self_arg];\n-                fn_inputs.append(&mut self.parse_seq_to_before_end(\n-                    &token::CloseDelim(token::Paren), sep, parse_arg_fn)?\n-                );\n-                fn_inputs\n+                let (mut input, recovered) = self.parse_seq_to_before_end(\n+                    &token::CloseDelim(token::Paren), sep, parse_arg_fn)?;\n+                fn_inputs.append(&mut input);\n+                (fn_inputs, recovered)\n             } else {\n                 return self.unexpected();\n             }\n         } else {\n             self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)?\n         };\n \n-        // Parse closing paren and return type.\n-        self.expect(&token::CloseDelim(token::Paren))?;\n+        if !recovered {\n+            // Parse closing paren and return type.\n+            self.expect(&token::CloseDelim(token::Paren))?;\n+        }\n         Ok(P(FnDecl {\n             inputs: fn_inputs,\n             output: self.parse_ret_ty(true)?,\n@@ -6241,7 +6356,7 @@ impl<'a> Parser<'a> {\n                     SeqSep::trailing_allowed(token::Comma),\n                     TokenExpectType::NoExpect,\n                     |p| p.parse_fn_block_arg()\n-                )?;\n+                )?.0;\n                 self.expect_or()?;\n                 args\n             }\n@@ -8238,7 +8353,7 @@ impl<'a> Parser<'a> {\n             // eat a matched-delimiter token tree:\n             let (delim, tts) = self.expect_delimited_token_tree()?;\n             if delim != MacDelimiter::Brace {\n-                self.expect(&token::Semi)?\n+                self.expect(&token::Semi)?;\n             }\n \n             Ok(Some(respan(lo.to(self.prev_span), Mac_ { path: pth, tts, delim })))\n@@ -8383,11 +8498,27 @@ impl<'a> Parser<'a> {\n     /// entry point for the parser.\n     pub fn parse_crate_mod(&mut self) -> PResult<'a, Crate> {\n         let lo = self.span;\n-        Ok(ast::Crate {\n+        let krate = Ok(ast::Crate {\n             attrs: self.parse_inner_attributes()?,\n             module: self.parse_mod_items(&token::Eof, lo)?,\n             span: lo.to(self.span),\n-        })\n+        });\n+        for unmatched in &self.unclosed_delims {\n+            let mut err = self.struct_span_err(unmatched.found_span, &format!(\n+                \"incorrect close delimiter: `{}`\",\n+                pprust::token_to_string(&token::Token::CloseDelim(unmatched.found_delim)),\n+            ));\n+            err.span_label(unmatched.found_span, \"incorrect close delimiter\");\n+            if let Some(sp) = unmatched.candidate_span {\n+                err.span_label(sp, \"close delimiter possibly meant for this\");\n+            }\n+            if let Some(sp) = unmatched.unclosed_span {\n+                err.span_label(sp, \"un-closed delimiter\");\n+            }\n+            err.emit();\n+        }\n+        self.unclosed_delims.clear();\n+        krate\n     }\n \n     pub fn parse_optional_str(&mut self) -> Option<(Symbol, ast::StrStyle, Option<ast::Name>)> {"}, {"sha": "a0f3113a1cb7f9a139747c53d5e9135a0fb13633", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -487,8 +487,8 @@ impl Token {\n     /// Enables better error recovery when the wrong token is found.\n     crate fn similar_tokens(&self) -> Option<Vec<Token>> {\n         match *self {\n-            Comma => Some(vec![Dot, Lt]),\n-            Semi => Some(vec![Colon]),\n+            Comma => Some(vec![Dot, Lt, Semi]),\n+            Semi => Some(vec![Colon, Comma]),\n             _ => None\n         }\n     }\n@@ -545,7 +545,15 @@ impl Token {\n             // FIXME(#43081): Avoid this pretty-print + reparse hack\n             let source = pprust::token_to_string(self);\n             let filename = FileName::macro_expansion_source_code(&source);\n-            parse_stream_from_source_str(filename, source, sess, Some(span))\n+            let (tokens, errors) = parse_stream_from_source_str(\n+                filename, source, sess, Some(span));\n+            for err in errors {\n+                sess.span_diagnostic.struct_span_err(\n+                    err.found_span,\n+                    \"unclosed delimiter for_real\",\n+                ).emit();\n+            }\n+            tokens\n         });\n \n         // During early phases of the compiler the AST could get modified\n@@ -786,12 +794,18 @@ fn prepend_attrs(sess: &ParseSess,\n         let source = pprust::attr_to_string(attr);\n         let macro_filename = FileName::macro_expansion_source_code(&source);\n         if attr.is_sugared_doc {\n-            let stream = parse_stream_from_source_str(\n+            let (stream, errors) = parse_stream_from_source_str(\n                 macro_filename,\n                 source,\n                 sess,\n                 Some(span),\n             );\n+            for err in errors {\n+                sess.span_diagnostic.struct_span_err(\n+                    err.found_span,\n+                    \"unclosed delimiter attrs\",\n+                ).emit();\n+            }\n             builder.push(stream);\n             continue\n         }\n@@ -808,12 +822,18 @@ fn prepend_attrs(sess: &ParseSess,\n         // ... and for more complicated paths, fall back to a reparse hack that\n         // should eventually be removed.\n         } else {\n-            let stream = parse_stream_from_source_str(\n+            let (stream, errors) = parse_stream_from_source_str(\n                 macro_filename,\n                 source,\n                 sess,\n                 Some(span),\n             );\n+            for err in errors {\n+                sess.span_diagnostic.struct_span_err(\n+                    err.found_span,\n+                    \"unclosed delimiter attrs 2\",\n+                ).emit();\n+            }\n             brackets.push(stream);\n         }\n "}, {"sha": "ef291e2102b4c754c8becab4946ddce400e10a15", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -413,7 +413,7 @@ impl server::TokenStream for Rustc<'_> {\n             src.to_string(),\n             self.sess,\n             Some(self.call_site),\n-        )\n+        ).0\n     }\n     fn to_string(&mut self, stream: &Self::TokenStream) -> String {\n         stream.to_string()"}, {"sha": "76f7af38e776dcd3b1ca8260669ff958795e297d", "filename": "src/test/ui/parser-recovery-2.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fparser-recovery-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fparser-recovery-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser-recovery-2.stderr?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -1,3 +1,9 @@\n+error: unexpected token: `;`\n+  --> $DIR/parser-recovery-2.rs:12:15\n+   |\n+LL |     let x = y.;  //~ ERROR unexpected token\n+   |               ^\n+\n error: incorrect close delimiter: `)`\n   --> $DIR/parser-recovery-2.rs:8:5\n    |\n@@ -7,12 +13,6 @@ LL |         let x = foo(); //~ ERROR cannot find function `foo` in this scope\n LL |     ) //~ ERROR incorrect close delimiter: `)`\n    |     ^ incorrect close delimiter\n \n-error: unexpected token: `;`\n-  --> $DIR/parser-recovery-2.rs:12:15\n-   |\n-LL |     let x = y.;  //~ ERROR unexpected token\n-   |               ^\n-\n error[E0425]: cannot find function `foo` in this scope\n   --> $DIR/parser-recovery-2.rs:7:17\n    |"}, {"sha": "6fb63639d5f6040a9e6036690f0563f04343c216", "filename": "src/test/ui/parser/issue-10636-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fparser%2Fissue-10636-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fparser%2Fissue-10636-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-10636-2.rs?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -5,7 +5,7 @@ pub fn trace_option(option: Option<isize>) {\n     option.map(|some| 42;\n                           //~^ ERROR: expected one of\n \n-} //~ ERROR: incorrect close delimiter\n+}\n //~^ ERROR: expected expression, found `)`\n \n fn main() {}"}, {"sha": "670a116eb51f0601253c100e515d3185a7a7f4f8", "filename": "src/test/ui/parser/issue-10636-2.stderr", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fparser%2Fissue-10636-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fparser%2Fissue-10636-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-10636-2.stderr?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -1,25 +1,17 @@\n-error: incorrect close delimiter: `}`\n-  --> $DIR/issue-10636-2.rs:8:1\n-   |\n-LL | pub fn trace_option(option: Option<isize>) {\n-   |                                            - close delimiter possibly meant for this\n-LL |     option.map(|some| 42;\n-   |               - un-closed delimiter\n-...\n-LL | } //~ ERROR: incorrect close delimiter\n-   | ^ incorrect close delimiter\n-\n error: expected one of `)`, `,`, `.`, `?`, or an operator, found `;`\n   --> $DIR/issue-10636-2.rs:5:25\n    |\n LL |     option.map(|some| 42;\n-   |                         ^ expected one of `)`, `,`, `.`, `?`, or an operator here\n+   |               -         ^\n+   |               |         |\n+   |               |         help: `)` may belong here\n+   |               in order to close this...\n \n error: expected expression, found `)`\n   --> $DIR/issue-10636-2.rs:8:1\n    |\n-LL | } //~ ERROR: incorrect close delimiter\n+LL | }\n    | ^ expected expression\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "b383bc00f911d855624fcd2cea12a42a3c06606d", "filename": "src/test/ui/parser/issue-2354.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fparser%2Fissue-2354.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fparser%2Fissue-2354.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-2354.rs?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -1,4 +1,5 @@\n-fn foo() { //~ NOTE un-closed delimiter\n+fn foo() {\n+  //~^ NOTE un-closed delimiter\n   match Some(10) {\n   //~^ NOTE this delimiter might not be properly closed...\n       Some(y) => { panic!(); }"}, {"sha": "f1b0905d866006d2b069e29293d16558a011c8dc", "filename": "src/test/ui/parser/issue-2354.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fparser%2Fissue-2354.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fparser%2Fissue-2354.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-2354.stderr?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -1,8 +1,9 @@\n error: this file contains an un-closed delimiter\n-  --> $DIR/issue-2354.rs:15:66\n+  --> $DIR/issue-2354.rs:16:66\n    |\n-LL | fn foo() { //~ NOTE un-closed delimiter\n+LL | fn foo() {\n    |          - un-closed delimiter\n+LL |   //~^ NOTE un-closed delimiter\n LL |   match Some(10) {\n    |                  - this delimiter might not be properly closed...\n ...\n@@ -16,7 +17,7 @@ error[E0601]: `main` function not found in crate `issue_2354`\n    |\n    = note: the main function must be defined at the crate level but you have one or more functions named 'main' that are not defined at the crate level. Either move the definition or attach the `#[main]` attribute to override this behavior.\n note: here is a function named 'main'\n-  --> $DIR/issue-2354.rs:14:1\n+  --> $DIR/issue-2354.rs:15:1\n    |\n LL | fn main() {} //~ NOTE here is a function named 'main'\n    | ^^^^^^^^^^^^"}, {"sha": "abb0820979532e92d3c220f4e9c3cfef2ba1749b", "filename": "src/test/ui/parser/macro-mismatched-delim-paren-brace.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fparser%2Fmacro-mismatched-delim-paren-brace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fparser%2Fmacro-mismatched-delim-paren-brace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro-mismatched-delim-paren-brace.stderr?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -1,3 +1,9 @@\n+error: unexpected close delimiter: `}`\n+  --> $DIR/macro-mismatched-delim-paren-brace.rs:5:1\n+   |\n+LL | } //~ ERROR unexpected close delimiter: `}`\n+   | ^ unexpected close delimiter\n+\n error: incorrect close delimiter: `}`\n   --> $DIR/macro-mismatched-delim-paren-brace.rs:4:5\n    |\n@@ -7,11 +13,5 @@ LL |         bar, \"baz\", 1, 2.0\n LL |     } //~ ERROR incorrect close delimiter\n    |     ^ incorrect close delimiter\n \n-error: unexpected close delimiter: `}`\n-  --> $DIR/macro-mismatched-delim-paren-brace.rs:5:1\n-   |\n-LL | } //~ ERROR unexpected close delimiter: `}`\n-   | ^ unexpected close delimiter\n-\n error: aborting due to 2 previous errors\n "}, {"sha": "b1ca0bbfc57c10b125669ebad3718e8df0f8f0a7", "filename": "src/test/ui/resolve/token-error-correct-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.rs?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -17,7 +17,7 @@ pub mod raw {\n             //~| expected type `()`\n             //~| found type `std::result::Result<bool, std::io::Error>`\n             //~| expected one of\n-        } else { //~ ERROR: incorrect close delimiter: `}`\n+        } else {\n             //~^ ERROR: expected one of\n             //~| unexpected token\n             Ok(false);"}, {"sha": "fcc1c34d1fc538a5bc0629457e10166b6e76fd46", "filename": "src/test/ui/resolve/token-error-correct-3.stderr", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct-3.stderr?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -1,27 +1,19 @@\n-error: incorrect close delimiter: `}`\n-  --> $DIR/token-error-correct-3.rs:20:9\n-   |\n-LL |         if !is_directory(path.as_ref()) { //~ ERROR: cannot find function `is_directory`\n-   |                                         - close delimiter possibly meant for this\n-LL |             callback(path.as_ref(); //~ ERROR expected one of\n-   |                     - un-closed delimiter\n-...\n-LL |         } else { //~ ERROR: incorrect close delimiter: `}`\n-   |         ^ incorrect close delimiter\n-\n error: expected one of `)`, `,`, `.`, `?`, or an operator, found `;`\n   --> $DIR/token-error-correct-3.rs:14:35\n    |\n LL |             callback(path.as_ref(); //~ ERROR expected one of\n-   |                                   ^ expected one of `)`, `,`, `.`, `?`, or an operator here\n+   |                     -             ^\n+   |                     |             |\n+   |                     |             help: `)` may belong here\n+   |                     in order to close this...\n \n error: expected one of `.`, `;`, `?`, `}`, or an operator, found `)`\n   --> $DIR/token-error-correct-3.rs:20:9\n    |\n LL |             fs::create_dir_all(path.as_ref()).map(|()| true) //~ ERROR: mismatched types\n    |                                                             - expected one of `.`, `;`, `?`, `}`, or an operator here\n ...\n-LL |         } else { //~ ERROR: incorrect close delimiter: `}`\n+LL |         } else {\n    |         ^ unexpected token\n \n error[E0425]: cannot find function `is_directory` in this scope\n@@ -41,7 +33,7 @@ LL |             fs::create_dir_all(path.as_ref()).map(|()| true) //~ ERROR: mis\n    = note: expected type `()`\n               found type `std::result::Result<bool, std::io::Error>`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 4 previous errors\n \n Some errors occurred: E0308, E0425.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "48a247a5898ef727dee9893aa6a5e29f1a91a242", "filename": "src/test/ui/resolve/token-error-correct.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7451cd8dc0b20c012fad1886b321c3dee2052577/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Ftoken-error-correct.stderr?ref=7451cd8dc0b20c012fad1886b321c3dee2052577", "patch": "@@ -1,3 +1,9 @@\n+error: expected expression, found `;`\n+  --> $DIR/token-error-correct.rs:4:13\n+   |\n+LL |     foo(bar(;\n+   |             ^ expected expression\n+\n error: incorrect close delimiter: `}`\n   --> $DIR/token-error-correct.rs:6:1\n    |\n@@ -9,11 +15,5 @@ LL |     //~^ ERROR: expected expression, found `;`\n LL | }\n    | ^ incorrect close delimiter\n \n-error: expected expression, found `;`\n-  --> $DIR/token-error-correct.rs:4:13\n-   |\n-LL |     foo(bar(;\n-   |             ^ expected expression\n-\n error: aborting due to 2 previous errors\n "}]}