{"sha": "d664ca26357fad84b4bc48f903f4795d491ccfd1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2NjRjYTI2MzU3ZmFkODRiNGJjNDhmOTAzZjQ3OTVkNDkxY2NmZDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-28T03:21:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-28T03:21:29Z"}, "message": "auto merge of #10080 : brson/rust/sched_queue, r=brson\n\nRebase and update of #9710", "tree": {"sha": "0450d420bb1e359aecfc0a9d7a9e3fa8800476b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0450d420bb1e359aecfc0a9d7a9e3fa8800476b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d664ca26357fad84b4bc48f903f4795d491ccfd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d664ca26357fad84b4bc48f903f4795d491ccfd1", "html_url": "https://github.com/rust-lang/rust/commit/d664ca26357fad84b4bc48f903f4795d491ccfd1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d664ca26357fad84b4bc48f903f4795d491ccfd1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1200118271ae6f14847baa93d0bfc1d7750b3bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1200118271ae6f14847baa93d0bfc1d7750b3bb", "html_url": "https://github.com/rust-lang/rust/commit/a1200118271ae6f14847baa93d0bfc1d7750b3bb"}, {"sha": "a849c476f5a62bdf5af546b603a5d7038fcb5e52", "url": "https://api.github.com/repos/rust-lang/rust/commits/a849c476f5a62bdf5af546b603a5d7038fcb5e52", "html_url": "https://github.com/rust-lang/rust/commit/a849c476f5a62bdf5af546b603a5d7038fcb5e52"}], "stats": {"total": 551, "additions": 446, "deletions": 105}, "files": [{"sha": "91231430d2a0b8d8944f6c58e5348994556b4358", "filename": "src/etc/licenseck.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Fetc%2Flicenseck.py", "raw_url": "https://github.com/rust-lang/rust/raw/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Fetc%2Flicenseck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flicenseck.py?ref=d664ca26357fad84b4bc48f903f4795d491ccfd1", "patch": "@@ -76,6 +76,8 @@\n     \"rt/isaac/randport.cpp\", # public domain\n     \"rt/isaac/rand.h\", # public domain\n     \"rt/isaac/standard.h\", # public domain\n+    \"libstd/rt/mpsc_queue.rs\", # BSD\n+    \"libstd/rt/mpmc_bounded_queue.rs\", # BSD\n ]\n \n def check_license(name, contents):"}, {"sha": "10e457368f007e3e36ccdb8f2e33a2fd7105b192", "filename": "src/libstd/rt/message_queue.rs", "status": "modified", "additions": 11, "deletions": 49, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibstd%2Frt%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibstd%2Frt%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmessage_queue.rs?ref=d664ca26357fad84b4bc48f903f4795d491ccfd1", "patch": "@@ -11,83 +11,45 @@\n //! A concurrent queue that supports multiple producers and a\n //! single consumer.\n \n-use container::Container;\n use kinds::Send;\n use vec::OwnedVector;\n-use cell::Cell;\n-use option::*;\n-use unstable::sync::{UnsafeArc, LittleLock};\n+use option::Option;\n use clone::Clone;\n+use rt::mpsc_queue::Queue;\n \n pub struct MessageQueue<T> {\n-    priv state: UnsafeArc<State<T>>\n-}\n-\n-struct State<T> {\n-    count: uint,\n-    queue: ~[T],\n-    lock: LittleLock\n+    priv queue: Queue<T>\n }\n \n impl<T: Send> MessageQueue<T> {\n     pub fn new() -> MessageQueue<T> {\n         MessageQueue {\n-            state: UnsafeArc::new(State {\n-                count: 0,\n-                queue: ~[],\n-                lock: LittleLock::new()\n-            })\n+            queue: Queue::new()\n         }\n     }\n \n+    #[inline]\n     pub fn push(&mut self, value: T) {\n-        unsafe {\n-            let value = Cell::new(value);\n-            let state = self.state.get();\n-            do (*state).lock.lock {\n-                (*state).count += 1;\n-                (*state).queue.push(value.take());\n-            }\n-        }\n+        self.queue.push(value)\n     }\n \n+    #[inline]\n     pub fn pop(&mut self) -> Option<T> {\n-        unsafe {\n-            let state = self.state.get();\n-            do (*state).lock.lock {\n-                if !(*state).queue.is_empty() {\n-                    (*state).count += 1;\n-                    Some((*state).queue.shift())\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n+        self.queue.pop()\n     }\n \n     /// A pop that may sometimes miss enqueued elements, but is much faster\n     /// to give up without doing any synchronization\n+    #[inline]\n     pub fn casual_pop(&mut self) -> Option<T> {\n-        unsafe {\n-            let state = self.state.get();\n-            // NB: Unsynchronized check\n-            if (*state).count == 0 { return None; }\n-            do (*state).lock.lock {\n-                if !(*state).queue.is_empty() {\n-                    (*state).count += 1;\n-                    Some((*state).queue.shift())\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n+        self.queue.pop()\n     }\n }\n \n impl<T: Send> Clone for MessageQueue<T> {\n     fn clone(&self) -> MessageQueue<T> {\n         MessageQueue {\n-            state: self.state.clone()\n+            queue: self.queue.clone()\n         }\n     }\n }"}, {"sha": "d87580c83bfdbb866853a08264b48cd14ade1596", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=d664ca26357fad84b4bc48f903f4795d491ccfd1", "patch": "@@ -136,6 +136,12 @@ mod work_queue;\n /// A parallel queue.\n mod message_queue;\n \n+/// A mostly lock-free multi-producer, single consumer queue.\n+mod mpsc_queue;\n+\n+/// A lock-free multi-producer, multi-consumer bounded queue.\n+mod mpmc_bounded_queue;\n+\n /// A parallel data structure for tracking sleeping schedulers.\n mod sleeper_list;\n "}, {"sha": "2f61a4339833ac82e0d6e5ed45ebddaa5b7ab5b4", "filename": "src/libstd/rt/mpmc_bounded_queue.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmpmc_bounded_queue.rs?ref=d664ca26357fad84b4bc48f903f4795d491ccfd1", "patch": "@@ -0,0 +1,213 @@\n+/* Multi-producer/multi-consumer bounded queue\n+ * Copyright (c) 2010-2011 Dmitry Vyukov. All rights reserved.\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *    1. Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *    2. Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY DMITRY VYUKOV \"AS IS\" AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\n+ * SHALL DMITRY VYUKOV OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * The views and conclusions contained in the software and documentation are\n+ * those of the authors and should not be interpreted as representing official\n+ * policies, either expressed or implied, of Dmitry Vyukov.\n+ */\n+\n+// http://www.1024cores.net/home/lock-free-algorithms/queues/bounded-mpmc-queue\n+\n+use unstable::sync::UnsafeArc;\n+use unstable::atomics::{AtomicUint,Relaxed,Release,Acquire};\n+use option::*;\n+use vec;\n+use clone::Clone;\n+use kinds::Send;\n+use num::{Exponential,Algebraic,Round};\n+\n+struct Node<T> {\n+    sequence: AtomicUint,\n+    value: Option<T>,\n+}\n+\n+struct State<T> {\n+    pad0: [u8, ..64],\n+    buffer: ~[Node<T>],\n+    mask: uint,\n+    pad1: [u8, ..64],\n+    enqueue_pos: AtomicUint,\n+    pad2: [u8, ..64],\n+    dequeue_pos: AtomicUint,\n+    pad3: [u8, ..64],\n+}\n+\n+struct Queue<T> {\n+    priv state: UnsafeArc<State<T>>,\n+}\n+\n+impl<T: Send> State<T> {\n+    fn with_capacity(capacity: uint) -> State<T> {\n+        let capacity = if capacity < 2 || (capacity & (capacity - 1)) != 0 {\n+            if capacity < 2 {\n+                2u\n+            } else {\n+                // use next power of 2 as capacity\n+                2f64.pow(&((capacity as f64).log2().ceil())) as uint\n+            }\n+        } else {\n+            capacity\n+        };\n+        let buffer = do vec::from_fn(capacity) |i:uint| {\n+            Node{sequence:AtomicUint::new(i),value:None}\n+        };\n+        State{\n+            pad0: [0, ..64],\n+            buffer: buffer,\n+            mask: capacity-1,\n+            pad1: [0, ..64],\n+            enqueue_pos: AtomicUint::new(0),\n+            pad2: [0, ..64],\n+            dequeue_pos: AtomicUint::new(0),\n+            pad3: [0, ..64],\n+        }\n+    }\n+\n+    fn push(&mut self, value: T) -> bool {\n+        let mask = self.mask;\n+        let mut pos = self.enqueue_pos.load(Relaxed);\n+        loop {\n+            let node = &mut self.buffer[pos & mask];\n+            let seq = node.sequence.load(Acquire);\n+            let diff: int = seq as int - pos as int;\n+\n+            if diff == 0 {\n+                let enqueue_pos = self.enqueue_pos.compare_and_swap(pos, pos+1, Relaxed);\n+                if enqueue_pos == pos {\n+                    node.value = Some(value);\n+                    node.sequence.store(pos+1, Release);\n+                    break\n+                } else {\n+                    pos = enqueue_pos;\n+                }\n+            } else if (diff < 0) {\n+                return false\n+            } else {\n+                pos = self.enqueue_pos.load(Relaxed);\n+            }\n+        }\n+        true\n+    }\n+\n+    fn pop(&mut self) -> Option<T> {\n+        let mask = self.mask;\n+        let mut pos = self.dequeue_pos.load(Relaxed);\n+        loop {\n+            let node = &mut self.buffer[pos & mask];\n+            let seq = node.sequence.load(Acquire);\n+            let diff: int = seq as int - (pos + 1) as int;\n+            if diff == 0 {\n+                let dequeue_pos = self.dequeue_pos.compare_and_swap(pos, pos+1, Relaxed);\n+                if dequeue_pos == pos {\n+                    let value = node.value.take();\n+                    node.sequence.store(pos + mask + 1, Release);\n+                    return value\n+                } else {\n+                    pos = dequeue_pos;\n+                }\n+            } else if diff < 0 {\n+                return None\n+            } else {\n+                pos = self.dequeue_pos.load(Relaxed);\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: Send> Queue<T> {\n+    pub fn with_capacity(capacity: uint) -> Queue<T> {\n+        Queue{\n+            state: UnsafeArc::new(State::with_capacity(capacity))\n+        }\n+    }\n+\n+    pub fn push(&mut self, value: T) -> bool {\n+        unsafe { (*self.state.get()).push(value) }\n+    }\n+\n+    pub fn pop(&mut self) -> Option<T> {\n+        unsafe { (*self.state.get()).pop() }\n+    }\n+}\n+\n+impl<T: Send> Clone for Queue<T> {\n+    fn clone(&self) -> Queue<T> {\n+        Queue {\n+            state: self.state.clone()\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+    use option::*;\n+    use task;\n+    use comm;\n+    use super::Queue;\n+\n+    #[test]\n+    fn test() {\n+        let nthreads = 8u;\n+        let nmsgs = 1000u;\n+        let mut q = Queue::with_capacity(nthreads*nmsgs);\n+        assert_eq!(None, q.pop());\n+\n+        for _ in range(0, nthreads) {\n+            let (port, chan)  = comm::stream();\n+            chan.send(q.clone());\n+            do task::spawn_sched(task::SingleThreaded) {\n+                let mut q = port.recv();\n+                for i in range(0, nmsgs) {\n+                    assert!(q.push(i));\n+                }\n+            }\n+        }\n+\n+        let mut completion_ports = ~[];\n+        for _ in range(0, nthreads) {\n+            let (completion_port, completion_chan) = comm::stream();\n+            completion_ports.push(completion_port);\n+            let (port, chan)  = comm::stream();\n+            chan.send(q.clone());\n+            do task::spawn_sched(task::SingleThreaded) {\n+                let mut q = port.recv();\n+                let mut i = 0u;\n+                loop {\n+                    match q.pop() {\n+                        None => {},\n+                        Some(_) => {\n+                            i += 1;\n+                            if i == nmsgs { break }\n+                        }\n+                    }\n+                }\n+                completion_chan.send(i);\n+            }\n+        }\n+\n+        for completion_port in completion_ports.iter() {\n+            assert_eq!(nmsgs, completion_port.recv());\n+        }\n+    }\n+}"}, {"sha": "4f39a1df4fa53f1f041c5f15da739b0c13e1c7bc", "filename": "src/libstd/rt/mpsc_queue.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibstd%2Frt%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibstd%2Frt%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmpsc_queue.rs?ref=d664ca26357fad84b4bc48f903f4795d491ccfd1", "patch": "@@ -0,0 +1,205 @@\n+/* Multi-producer/single-consumer queue\n+ * Copyright (c) 2010-2011 Dmitry Vyukov. All rights reserved.\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *    1. Redistributions of source code must retain the above copyright notice,\n+ *       this list of conditions and the following disclaimer.\n+ *\n+ *    2. Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY DMITRY VYUKOV \"AS IS\" AND ANY EXPRESS OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\n+ * SHALL DMITRY VYUKOV OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * The views and conclusions contained in the software and documentation are\n+ * those of the authors and should not be interpreted as representing official\n+ * policies, either expressed or implied, of Dmitry Vyukov.\n+ */\n+\n+//! A mostly lock-free multi-producer, single consumer queue.\n+// http://www.1024cores.net/home/lock-free-algorithms/queues/intrusive-mpsc-node-based-queue\n+\n+use unstable::sync::UnsafeArc;\n+use unstable::atomics::{AtomicPtr,Relaxed,Release,Acquire};\n+use ptr::{mut_null, to_mut_unsafe_ptr};\n+use cast;\n+use option::*;\n+use clone::Clone;\n+use kinds::Send;\n+\n+struct Node<T> {\n+    next: AtomicPtr<Node<T>>,\n+    value: Option<T>,\n+}\n+\n+impl<T> Node<T> {\n+    fn empty() -> Node<T> {\n+        Node{next: AtomicPtr::new(mut_null()), value: None}\n+    }\n+\n+    fn with_value(value: T) -> Node<T> {\n+        Node{next: AtomicPtr::new(mut_null()), value: Some(value)}\n+    }\n+}\n+\n+struct State<T> {\n+    pad0: [u8, ..64],\n+    head: AtomicPtr<Node<T>>,\n+    pad1: [u8, ..64],\n+    stub: Node<T>,\n+    pad2: [u8, ..64],\n+    tail: *mut Node<T>,\n+    pad3: [u8, ..64],\n+}\n+\n+struct Queue<T> {\n+    priv state: UnsafeArc<State<T>>,\n+}\n+\n+impl<T: Send> Clone for Queue<T> {\n+    fn clone(&self) -> Queue<T> {\n+        Queue {\n+            state: self.state.clone()\n+        }\n+    }\n+}\n+\n+impl<T: Send> State<T> {\n+    pub fn new() -> State<T> {\n+        State{\n+            pad0: [0, ..64],\n+            head: AtomicPtr::new(mut_null()),\n+            pad1: [0, ..64],\n+            stub: Node::<T>::empty(),\n+            pad2: [0, ..64],\n+            tail: mut_null(),\n+            pad3: [0, ..64],\n+        }\n+    }\n+\n+    fn init(&mut self) {\n+        let stub = self.get_stub_unsafe();\n+        self.head.store(stub, Relaxed);\n+        self.tail = stub;\n+    }\n+\n+    fn get_stub_unsafe(&mut self) -> *mut Node<T> {\n+        to_mut_unsafe_ptr(&mut self.stub)\n+    }\n+\n+    fn push(&mut self, value: T) {\n+        unsafe {\n+            let node = cast::transmute(~Node::with_value(value));\n+            self.push_node(node);\n+        }\n+    }\n+\n+    fn push_node(&mut self, node: *mut Node<T>) {\n+        unsafe {\n+            (*node).next.store(mut_null(), Release);\n+            let prev = self.head.swap(node, Relaxed);\n+            (*prev).next.store(node, Release);\n+        }\n+    }\n+\n+    fn pop(&mut self) -> Option<T> {\n+        unsafe {\n+            let mut tail = self.tail;\n+            let mut next = (*tail).next.load(Acquire);\n+            let stub = self.get_stub_unsafe();\n+            if tail == stub {\n+                if mut_null() == next {\n+                    return None\n+                }\n+                self.tail = next;\n+                tail = next;\n+                next = (*next).next.load(Acquire);\n+            }\n+            if next != mut_null() {\n+                let tail: ~Node<T> = cast::transmute(tail);\n+                self.tail = next;\n+                return tail.value\n+            }\n+            let head = self.head.load(Relaxed);\n+            if tail != head {\n+                return None\n+            }\n+            self.push_node(stub);\n+            next = (*tail).next.load(Acquire);\n+            if next != mut_null() {\n+                let tail: ~Node<T> = cast::transmute(tail);\n+                self.tail = next;\n+                return tail.value\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<T: Send> Queue<T> {\n+    pub fn new() -> Queue<T> {\n+        unsafe {\n+            let q = Queue{state: UnsafeArc::new(State::new())};\n+            (*q.state.get()).init();\n+            q\n+        }\n+    }\n+\n+    pub fn push(&mut self, value: T) {\n+        unsafe { (*self.state.get()).push(value) }\n+    }\n+\n+    pub fn pop(&mut self) -> Option<T> {\n+        unsafe{ (*self.state.get()).pop() }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::*;\n+    use option::*;\n+    use task;\n+    use comm;\n+    use super::Queue;\n+\n+    #[test]\n+    fn test() {\n+        let nthreads = 8u;\n+        let nmsgs = 1000u;\n+        let mut q = Queue::new();\n+        assert_eq!(None, q.pop());\n+\n+        for _ in range(0, nthreads) {\n+            let (port, chan)  = comm::stream();\n+            chan.send(q.clone());\n+            do task::spawn_sched(task::SingleThreaded) {\n+                let mut q = port.recv();\n+                for i in range(0, nmsgs) {\n+                    q.push(i);\n+                }\n+            }\n+        }\n+\n+        let mut i = 0u;\n+        loop {\n+            match q.pop() {\n+                None => {},\n+                Some(_) => {\n+                    i += 1;\n+                    if i == nthreads*nmsgs { break }\n+                }\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "39c7431837f6eed810594a59217f4eaf34b2eb25", "filename": "src/libstd/rt/sleeper_list.rs", "status": "modified", "additions": 9, "deletions": 56, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibstd%2Frt%2Fsleeper_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d664ca26357fad84b4bc48f903f4795d491ccfd1/src%2Flibstd%2Frt%2Fsleeper_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsleeper_list.rs?ref=d664ca26357fad84b4bc48f903f4795d491ccfd1", "patch": "@@ -11,84 +11,37 @@\n //! Maintains a shared list of sleeping schedulers. Schedulers\n //! use this to wake each other up.\n \n-use container::Container;\n-use vec::OwnedVector;\n-use option::{Option, Some, None};\n-use cell::Cell;\n-use unstable::sync::{UnsafeArc, LittleLock};\n use rt::sched::SchedHandle;\n+use rt::mpmc_bounded_queue::Queue;\n+use option::*;\n use clone::Clone;\n \n pub struct SleeperList {\n-    priv state: UnsafeArc<State>\n-}\n-\n-struct State {\n-    count: uint,\n-    stack: ~[SchedHandle],\n-    lock: LittleLock\n+    priv q: Queue<SchedHandle>,\n }\n \n impl SleeperList {\n     pub fn new() -> SleeperList {\n-        SleeperList {\n-            state: UnsafeArc::new(State {\n-                count: 0,\n-                stack: ~[],\n-                lock: LittleLock::new()\n-            })\n-        }\n+        SleeperList{q: Queue::with_capacity(8*1024)}\n     }\n \n-    pub fn push(&mut self, handle: SchedHandle) {\n-        let handle = Cell::new(handle);\n-        unsafe {\n-            let state = self.state.get();\n-            do (*state).lock.lock {\n-                (*state).count += 1;\n-                (*state).stack.push(handle.take());\n-            }\n-        }\n+    pub fn push(&mut self, value: SchedHandle) {\n+        assert!(self.q.push(value))\n     }\n \n     pub fn pop(&mut self) -> Option<SchedHandle> {\n-        unsafe {\n-            let state = self.state.get();\n-            do (*state).lock.lock {\n-                if !(*state).stack.is_empty() {\n-                    (*state).count -= 1;\n-                    Some((*state).stack.pop())\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n+        self.q.pop()\n     }\n \n-    /// A pop that may sometimes miss enqueued elements, but is much faster\n-    /// to give up without doing any synchronization\n     pub fn casual_pop(&mut self) -> Option<SchedHandle> {\n-        unsafe {\n-            let state = self.state.get();\n-            // NB: Unsynchronized check\n-            if (*state).count == 0 { return None; }\n-            do (*state).lock.lock {\n-                if !(*state).stack.is_empty() {\n-                    // NB: count is also protected by the lock\n-                    (*state).count -= 1;\n-                    Some((*state).stack.pop())\n-                } else {\n-                    None\n-                }\n-            }\n-        }\n+        self.q.pop()\n     }\n }\n \n impl Clone for SleeperList {\n     fn clone(&self) -> SleeperList {\n         SleeperList {\n-            state: self.state.clone()\n+            q: self.q.clone()\n         }\n     }\n }"}]}