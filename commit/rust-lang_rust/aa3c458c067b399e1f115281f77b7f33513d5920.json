{"sha": "aa3c458c067b399e1f115281f77b7f33513d5920", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhM2M0NThjMDY3YjM5OWUxZjExNTI4MWY3N2I3ZjMzNTEzZDU5MjA=", "commit": {"author": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-02-03T09:57:45Z"}, "committer": {"name": "jumbatm", "email": "jumbatm@gmail.com", "date": "2020-02-11T09:50:21Z"}, "message": "Run RustFmt", "tree": {"sha": "5081cdfc940325fc27db35d1ad5a9af6d5ecb3ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5081cdfc940325fc27db35d1ad5a9af6d5ecb3ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa3c458c067b399e1f115281f77b7f33513d5920", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa3c458c067b399e1f115281f77b7f33513d5920", "html_url": "https://github.com/rust-lang/rust/commit/aa3c458c067b399e1f115281f77b7f33513d5920", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa3c458c067b399e1f115281f77b7f33513d5920/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f0430a163bb2f4fe6545064391606bb736e9e51", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f0430a163bb2f4fe6545064391606bb736e9e51", "html_url": "https://github.com/rust-lang/rust/commit/2f0430a163bb2f4fe6545064391606bb736e9e51"}], "stats": {"total": 187, "additions": 100, "deletions": 87}, "files": [{"sha": "23bbcb40c9434645ab7f74d34e57b17131f23d2c", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 52, "deletions": 37, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/aa3c458c067b399e1f115281f77b7f33513d5920/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3c458c067b399e1f115281f77b7f33513d5920/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=aa3c458c067b399e1f115281f77b7f33513d5920", "patch": "@@ -23,12 +23,12 @@\n \n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc::hir::map::Map;\n+use rustc::lint::LintDiagnosticBuilder;\n use rustc::traits::misc::can_type_implement_copy;\n use rustc::ty::{self, layout::VariantIdx, Ty, TyCtxt};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n-use rustc::lint::LintDiagnosticBuilder;\n use rustc_feature::Stability;\n use rustc_feature::{deprecated_attributes, AttributeGate, AttributeTemplate, AttributeType};\n use rustc_hir as hir;\n@@ -107,7 +107,9 @@ impl BoxPointers {\n     fn check_heap_type(&self, cx: &LateContext<'_, '_>, span: Span, ty: Ty<'_>) {\n         for leaf_ty in ty.walk() {\n             if leaf_ty.is_box() {\n-                cx.struct_span_lint(BOX_POINTERS, span, |lint| lint.build(&format!(\"type uses owned (Box type) pointers: {}\", ty)).emit());\n+                cx.struct_span_lint(BOX_POINTERS, span, |lint| {\n+                    lint.build(&format!(\"type uses owned (Box type) pointers: {}\", ty)).emit()\n+                });\n             }\n         }\n     }\n@@ -214,7 +216,12 @@ declare_lint! {\n declare_lint_pass!(UnsafeCode => [UNSAFE_CODE]);\n \n impl UnsafeCode {\n-    fn report_unsafe(&self, cx: &EarlyContext<'_>, span: Span, decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>)) {\n+    fn report_unsafe(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        span: Span,\n+        decorate: impl for<'a> FnOnce(LintDiagnosticBuilder<'a>),\n+    ) {\n         // This comes from a macro that has `#[allow_internal_unsafe]`.\n         if span.allows_unsafe() {\n             return;\n@@ -227,33 +234,40 @@ impl UnsafeCode {\n impl EarlyLintPass for UnsafeCode {\n     fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         if attr.check_name(sym::allow_internal_unsafe) {\n-            self.report_unsafe(\n-                cx,\n-                attr.span,\n-                |lint| lint.build(\"`allow_internal_unsafe` allows defining \\\n+            self.report_unsafe(cx, attr.span, |lint| {\n+                lint.build(\n+                    \"`allow_internal_unsafe` allows defining \\\n                                                macros using unsafe without triggering \\\n-                                               the `unsafe_code` lint at their call site\").emit(),\n-            );\n+                                               the `unsafe_code` lint at their call site\",\n+                )\n+                .emit()\n+            });\n         }\n     }\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if let ast::ExprKind::Block(ref blk, _) = e.kind {\n             // Don't warn about generated blocks; that'll just pollute the output.\n             if blk.rules == ast::BlockCheckMode::Unsafe(ast::UserProvided) {\n-                self.report_unsafe(cx, blk.span, |lint| lint.build(\"usage of an `unsafe` block\").emit());\n+                self.report_unsafe(cx, blk.span, |lint| {\n+                    lint.build(\"usage of an `unsafe` block\").emit()\n+                });\n             }\n         }\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, it: &ast::Item) {\n         match it.kind {\n             ast::ItemKind::Trait(_, ast::Unsafety::Unsafe, ..) => {\n-                self.report_unsafe(cx, it.span, |lint| lint.build(\"declaration of an `unsafe` trait\").emit())\n+                self.report_unsafe(cx, it.span, |lint| {\n+                    lint.build(\"declaration of an `unsafe` trait\").emit()\n+                })\n             }\n \n             ast::ItemKind::Impl { unsafety: ast::Unsafety::Unsafe, .. } => {\n-                self.report_unsafe(cx, it.span, |lint| lint.build(\"implementation of an `unsafe` trait\").emit())\n+                self.report_unsafe(cx, it.span, |lint| {\n+                    lint.build(\"implementation of an `unsafe` trait\").emit()\n+                })\n             }\n \n             _ => return,\n@@ -360,11 +374,9 @@ impl MissingDoc {\n \n         let has_doc = attrs.iter().any(|a| has_doc(a));\n         if !has_doc {\n-            cx.struct_span_lint(\n-                MISSING_DOCS,\n-                cx.tcx.sess.source_map().def_span(sp),\n-                |lint| lint.build(&format!(\"missing documentation for {}\", desc)).emit(),\n-            );\n+            cx.struct_span_lint(MISSING_DOCS, cx.tcx.sess.source_map().def_span(sp), |lint| {\n+                lint.build(&format!(\"missing documentation for {}\", desc)).emit()\n+            });\n         }\n     }\n }\n@@ -543,12 +555,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n             return;\n         }\n         if can_type_implement_copy(cx.tcx, param_env, ty).is_ok() {\n-            cx.struct_span_lint(\n-                MISSING_COPY_IMPLEMENTATIONS,\n-                item.span,\n-                |lint| lint.build(\"type could implement `Copy`; consider adding `impl \\\n-                          Copy`\").emit(),\n-            )\n+            cx.struct_span_lint(MISSING_COPY_IMPLEMENTATIONS, item.span, |lint| {\n+                lint.build(\n+                    \"type could implement `Copy`; consider adding `impl \\\n+                          Copy`\",\n+                )\n+                .emit()\n+            })\n         }\n     }\n }\n@@ -597,15 +610,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n         }\n \n         if !self.impling_types.as_ref().unwrap().contains(&item.hir_id) {\n-            cx.struct_span_lint(\n-                MISSING_DEBUG_IMPLEMENTATIONS,\n-                item.span,\n-                |lint| lint.build(&format!(\n+            cx.struct_span_lint(MISSING_DEBUG_IMPLEMENTATIONS, item.span, |lint| {\n+                lint.build(&format!(\n                     \"type does not implement `{}`; consider adding `#[derive(Debug)]` \\\n                      or a manual implementation\",\n                     cx.tcx.def_path_str(debug)\n-                )).emit(),\n-            );\n+                ))\n+                .emit()\n+            });\n         }\n     }\n }\n@@ -903,7 +915,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n         match get_transmute_from_to(cx, expr).map(|(ty1, ty2)| (&ty1.kind, &ty2.kind)) {\n             Some((&ty::Ref(_, _, from_mt), &ty::Ref(_, _, to_mt))) => {\n                 if to_mt == hir::Mutability::Mut && from_mt == hir::Mutability::Not {\n-                    cx.struct_span_lint(MUTABLE_TRANSMUTES, expr.span, |lint| lint.build(msg).emit());\n+                    cx.struct_span_lint(MUTABLE_TRANSMUTES, expr.span, |lint| {\n+                        lint.build(msg).emit()\n+                    });\n                 }\n             }\n             _ => (),\n@@ -953,7 +967,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n         if attr.check_name(sym::feature) {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n-                    ctx.struct_span_lint(UNSTABLE_FEATURES, item.span(), |lint| lint.build(\"unstable feature\").emit());\n+                    ctx.struct_span_lint(UNSTABLE_FEATURES, item.span(), |lint| {\n+                        lint.build(\"unstable feature\").emit()\n+                    });\n                 }\n             }\n         }\n@@ -1235,15 +1251,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TrivialConstraints {\n                     ConstEvaluatable(..) => continue,\n                 };\n                 if predicate.is_global() {\n-                    cx.struct_span_lint(\n-                        TRIVIAL_BOUNDS,\n-                        span,\n-                        |lint| lint.build(&format!(\n+                    cx.struct_span_lint(TRIVIAL_BOUNDS, span, |lint| {\n+                        lint.build(&format!(\n                             \"{} bound {} does not depend on any type \\\n                                 or lifetime parameters\",\n                             predicate_kind_name, predicate\n-                        )).emit(),\n-                    );\n+                        ))\n+                        .emit()\n+                    });\n                 }\n             }\n         }"}, {"sha": "a636e7540fb0da7c6e266aeb971b360ce074c4d1", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa3c458c067b399e1f115281f77b7f33513d5920/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3c458c067b399e1f115281f77b7f33513d5920/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=aa3c458c067b399e1f115281f77b7f33513d5920", "patch": "@@ -37,7 +37,13 @@ struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n     fn check_id(&mut self, id: ast::NodeId) {\n         for early_lint in self.context.buffered.take(id) {\n-            let rustc_session::lint::BufferedEarlyLint { span, msg, node_id: _, lint_id: _, diagnostic } = early_lint;\n+            let rustc_session::lint::BufferedEarlyLint {\n+                span,\n+                msg,\n+                node_id: _,\n+                lint_id: _,\n+                diagnostic,\n+            } = early_lint;\n             self.context.lookup_with_diagnostics(\n                 early_lint.lint_id.lint,\n                 Some(span),"}, {"sha": "5ffa9c1747fa90f748a00693c05543e535100065", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/aa3c458c067b399e1f115281f77b7f33513d5920/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3c458c067b399e1f115281f77b7f33513d5920/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=aa3c458c067b399e1f115281f77b7f33513d5920", "patch": "@@ -266,11 +266,9 @@ fn lint_int_literal<'a, 'tcx>(\n             }\n         }\n \n-        cx.struct_span_lint(\n-            OVERFLOWING_LITERALS,\n-            e.span,\n-            |lint| lint.build(&format!(\"literal out of range for `{}`\", t.name_str())).emit(),\n-        );\n+        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n+            lint.build(&format!(\"literal out of range for `{}`\", t.name_str())).emit()\n+        });\n     }\n }\n \n@@ -321,11 +319,9 @@ fn lint_uint_literal<'a, 'tcx>(\n             report_bin_hex_error(cx, e, attr::IntType::UnsignedInt(t), repr_str, lit_val, false);\n             return;\n         }\n-        cx.struct_span_lint(\n-            OVERFLOWING_LITERALS,\n-            e.span,\n-            |lint| lint.build(&format!(\"literal out of range for `{}`\", t.name_str())).emit(),\n-        );\n+        cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n+            lint.build(&format!(\"literal out of range for `{}`\", t.name_str())).emit()\n+        });\n     }\n }\n \n@@ -355,11 +351,9 @@ fn lint_literal<'a, 'tcx>(\n                 _ => bug!(),\n             };\n             if is_infinite == Ok(true) {\n-                cx.struct_span_lint(\n-                    OVERFLOWING_LITERALS,\n-                    e.span,\n-                    |lint| lint.build(&format!(\"literal out of range for `{}`\", t.name_str())).emit(),\n-                );\n+                cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n+                    lint.build(&format!(\"literal out of range for `{}`\", t.name_str())).emit()\n+                });\n             }\n         }\n         _ => {}\n@@ -377,11 +371,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n             hir::ExprKind::Binary(binop, ref l, ref r) => {\n                 if is_comparison(binop) && !check_limits(cx, binop, &l, &r) {\n-                    cx.struct_span_lint(\n-                        UNUSED_COMPARISONS,\n-                        e.span,\n-                        |lint| lint.build(\"comparison is useless due to type limits\").emit(),\n-                    );\n+                    cx.struct_span_lint(UNUSED_COMPARISONS, e.span, |lint| {\n+                        lint.build(\"comparison is useless due to type limits\").emit()\n+                    });\n                 }\n             }\n             hir::ExprKind::Lit(ref lit) => lint_literal(cx, self, e, lit),\n@@ -1058,11 +1050,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 cx.struct_span_lint(\n                     VARIANT_SIZE_DIFFERENCES,\n                     enum_definition.variants[largest_index].span,\n-                    |lint| lint.build(&format!(\n-                        \"enum variant is more than three times \\\n+                    |lint| {\n+                        lint.build(&format!(\n+                            \"enum variant is more than three times \\\n                                           larger ({} bytes) than the next largest\",\n-                        largest\n-                    )).emit(),\n+                            largest\n+                        ))\n+                        .emit()\n+                    },\n                 );\n             }\n         }"}, {"sha": "9cf5ff42c5771dd5541ce85be599575598d615b1", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aa3c458c067b399e1f115281f77b7f33513d5920/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3c458c067b399e1f115281f77b7f33513d5920/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=aa3c458c067b399e1f115281f77b7f33513d5920", "patch": "@@ -104,11 +104,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         };\n \n         if let Some(must_use_op) = must_use_op {\n-            cx.struct_span_lint(\n-                UNUSED_MUST_USE,\n-                expr.span,\n-                |lint| lint.build(&format!(\"unused {} that must be used\", must_use_op)).emit(),\n-            );\n+            cx.struct_span_lint(UNUSED_MUST_USE, expr.span, |lint| {\n+                lint.build(&format!(\"unused {} that must be used\", must_use_op)).emit()\n+            });\n             op_warned = true;\n         }\n \n@@ -247,7 +245,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n     fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt<'_>) {\n         if let hir::StmtKind::Semi(ref expr) = s.kind {\n             if let hir::ExprKind::Path(_) = expr.kind {\n-                cx.struct_span_lint(PATH_STATEMENTS, s.span, |lint| lint.build(\"path statement with no effect\").emit());\n+                cx.struct_span_lint(PATH_STATEMENTS, s.span, |lint| {\n+                    lint.build(\"path statement with no effect\").emit()\n+                });\n             }\n         }\n     }\n@@ -288,7 +288,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n \n         if !attr::is_used(attr) {\n             debug!(\"emitting warning for: {:?}\", attr);\n-            cx.struct_span_lint(UNUSED_ATTRIBUTES, attr.span, |lint| lint.build(\"unused attribute\").emit());\n+            cx.struct_span_lint(UNUSED_ATTRIBUTES, attr.span, |lint| {\n+                lint.build(\"unused attribute\").emit()\n+            });\n             // Is it a builtin attribute that must be used at the crate level?\n             if attr_info.map_or(false, |(_, ty, ..)| ty == &AttributeType::CrateLevel) {\n                 cx.struct_span_lint(UNUSED_ATTRIBUTES, attr.span, |lint| {\n@@ -637,9 +639,9 @@ impl UnusedImportBraces {\n                 ast::UseTreeKind::Nested(_) => return,\n             };\n \n-            cx.struct_span_lint(UNUSED_IMPORT_BRACES, item.span, |lint|\n-            lint.build(&format!(\"braces around {} is unnecessary\", node_name)).emit()\n-            );\n+            cx.struct_span_lint(UNUSED_IMPORT_BRACES, item.span, |lint| {\n+                lint.build(&format!(\"braces around {} is unnecessary\", node_name)).emit()\n+            });\n         }\n     }\n }"}, {"sha": "ecffd615e71c007b29301db7d3f0200ab286dfe9", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aa3c458c067b399e1f115281f77b7f33513d5920/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa3c458c067b399e1f115281f77b7f33513d5920/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=aa3c458c067b399e1f115281f77b7f33513d5920", "patch": "@@ -102,24 +102,19 @@ impl CheckAttrVisitor<'tcx> {\n             // accidentally, to to be compatible with crates depending on them, we can't throw an\n             // error here.\n             Target::AssocConst => {\n-                self.tcx\n-                    .struct_span_lint_hir(\n-                        UNUSED_ATTRIBUTES,\n-                        hir_id,\n-                        attr.span,\n-                        |lint| {\n-                            lint.build(\"`#[inline]` is ignored on constants\")\n-                            .warn(\n-                                \"this was previously accepted by the compiler but is \\\n+                self.tcx.struct_span_lint_hir(UNUSED_ATTRIBUTES, hir_id, attr.span, |lint| {\n+                    lint.build(\"`#[inline]` is ignored on constants\")\n+                        .warn(\n+                            \"this was previously accepted by the compiler but is \\\n                                being phased out; it will become a hard error in \\\n                                a future release!\",\n-                            )\n-                            .note(\n-                                \"see issue #65833 <https://github.com/rust-lang/rust/issues/65833> \\\n+                        )\n+                        .note(\n+                            \"see issue #65833 <https://github.com/rust-lang/rust/issues/65833> \\\n                                  for more information\",\n-                            )\n-                            .emit();\n-                        });\n+                        )\n+                        .emit();\n+                });\n                 true\n             }\n             _ => {"}]}