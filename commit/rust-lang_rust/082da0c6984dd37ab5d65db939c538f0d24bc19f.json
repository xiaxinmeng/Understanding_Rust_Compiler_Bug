{"sha": "082da0c6984dd37ab5d65db939c538f0d24bc19f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MmRhMGM2OTg0ZGQzN2FiNWQ2NWRiOTM5YzUzOGYwZDI0YmMxOWY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-25T08:59:09Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-05-26T09:08:03Z"}, "message": "rename Scalar::Bits to Scalar::Raw and bits field to data", "tree": {"sha": "fed02d73e6e1418494f1ccd2ea252c8381689a0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fed02d73e6e1418494f1ccd2ea252c8381689a0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/082da0c6984dd37ab5d65db939c538f0d24bc19f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/082da0c6984dd37ab5d65db939c538f0d24bc19f", "html_url": "https://github.com/rust-lang/rust/commit/082da0c6984dd37ab5d65db939c538f0d24bc19f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/082da0c6984dd37ab5d65db939c538f0d24bc19f/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "572892c324cde896df0c4a1e9ed4896b1832a4fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/572892c324cde896df0c4a1e9ed4896b1832a4fd", "html_url": "https://github.com/rust-lang/rust/commit/572892c324cde896df0c4a1e9ed4896b1832a4fd"}], "stats": {"total": 200, "additions": 93, "deletions": 107}, "files": [{"sha": "988bd5302412ef62889690939351905f15c23704", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -388,11 +388,11 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n                 val.offset.bytes() as u128\n             }\n \n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, type_size.bytes());\n-                debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n+                debug_assert_eq!(truncate(data, Size::from_bytes(size.into())), data,\n                     \"Unexpected value of size {} when writing to memory\", size);\n-                bits\n+                data\n             },\n         };\n "}, {"sha": "c6099adcc34165d13cdc900ce699c6752688ad38", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -87,11 +87,11 @@ impl<'tcx> ConstValue<'tcx> {\n          RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub enum Scalar<Tag=(), Id=AllocId> {\n     /// The raw bytes of a simple value.\n-    Bits {\n-        /// The first `size` bytes are the value.\n+    Raw {\n+        /// The first `size` bytes of `data` are the value.\n         /// Do not try to read less or more bytes than that. The remaining bytes must be 0.\n+        data: u128,\n         size: u8,\n-        bits: u128,\n     },\n \n     /// A pointer into an `Allocation`. An `Allocation` in the `memory` module has a list of\n@@ -108,16 +108,16 @@ impl<Tag: fmt::Debug, Id: fmt::Debug> fmt::Debug for Scalar<Tag, Id> {\n         match self {\n             Scalar::Ptr(ptr) =>\n                 write!(f, \"{:?}\", ptr),\n-            &Scalar::Bits { bits, size } => {\n+            &Scalar::Raw { data, size } => {\n                 if size == 0 {\n-                    assert_eq!(bits, 0, \"ZST value must be 0\");\n+                    assert_eq!(data, 0, \"ZST value must be 0\");\n                     write!(f, \"<ZST>\")\n                 } else {\n-                    assert_eq!(truncate(bits, Size::from_bytes(size as u64)), bits,\n-                            \"Scalar value {:#x} exceeds size of {} bytes\", bits, size);\n+                    assert_eq!(truncate(data, Size::from_bytes(size as u64)), data,\n+                            \"Scalar value {:#x} exceeds size of {} bytes\", data, size);\n                     // Format as hex number wide enough to fit any value of the given `size`.\n-                    // So bits=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n-                    write!(f, \"0x{:>0width$x}\", bits, width=(size*2) as usize)\n+                    // So data=20, size=1 will be \"0x14\", but with size=4 it'll be \"0x00000014\".\n+                    write!(f, \"0x{:>0width$x}\", data, width=(size*2) as usize)\n                 }\n             }\n         }\n@@ -128,7 +128,7 @@ impl<Tag> fmt::Display for Scalar<Tag> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n             Scalar::Ptr(_) => write!(f, \"a pointer\"),\n-            Scalar::Bits { bits, .. } => write!(f, \"{}\", bits),\n+            Scalar::Raw { data, .. } => write!(f, \"{}\", data),\n         }\n     }\n }\n@@ -138,7 +138,7 @@ impl<'tcx> Scalar<()> {\n     pub fn with_tag<Tag>(self, new_tag: Tag) -> Scalar<Tag> {\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.with_tag(new_tag)),\n-            Scalar::Bits { bits, size } => Scalar::Bits { bits, size },\n+            Scalar::Raw { data, size } => Scalar::Raw { data, size },\n         }\n     }\n \n@@ -155,31 +155,31 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn erase_tag(self) -> Scalar {\n         match self {\n             Scalar::Ptr(ptr) => Scalar::Ptr(ptr.erase_tag()),\n-            Scalar::Bits { bits, size } => Scalar::Bits { bits, size },\n+            Scalar::Raw { data, size } => Scalar::Raw { data, size },\n         }\n     }\n \n     #[inline]\n     pub fn ptr_null(cx: &impl HasDataLayout) -> Self {\n-        Scalar::Bits {\n-            bits: 0,\n+        Scalar::Raw {\n+            data: 0,\n             size: cx.data_layout().pointer_size.bytes() as u8,\n         }\n     }\n \n     #[inline]\n     pub fn zst() -> Self {\n-        Scalar::Bits { bits: 0, size: 0 }\n+        Scalar::Raw { data: 0, size: 0 }\n     }\n \n     #[inline]\n     pub fn ptr_offset(self, i: Size, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let dl = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Ok(Scalar::Bits {\n-                    bits: dl.offset(bits as u64, i.bytes())? as u128,\n+                Ok(Scalar::Raw {\n+                    data: dl.offset(data as u64, i.bytes())? as u128,\n                     size,\n                 })\n             }\n@@ -191,10 +191,10 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn ptr_wrapping_offset(self, i: Size, cx: &impl HasDataLayout) -> Self {\n         let dl = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Scalar::Bits {\n-                    bits: dl.overflowing_offset(bits as u64, i.bytes()).0 as u128,\n+                Scalar::Raw {\n+                    data: dl.overflowing_offset(data as u64, i.bytes()).0 as u128,\n                     size,\n                 }\n             }\n@@ -206,10 +206,10 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn ptr_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let dl = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, dl.pointer_size().bytes());\n-                Ok(Scalar::Bits {\n-                    bits: dl.signed_offset(bits as u64, i)? as u128,\n+                Ok(Scalar::Raw {\n+                    data: dl.signed_offset(data as u64, i)? as u128,\n                     size,\n                 })\n             }\n@@ -221,10 +221,10 @@ impl<'tcx, Tag> Scalar<Tag> {\n     pub fn ptr_wrapping_signed_offset(self, i: i64, cx: &impl HasDataLayout) -> Self {\n         let dl = cx.data_layout();\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, dl.pointer_size.bytes());\n-                Scalar::Bits {\n-                    bits: dl.overflowing_signed_offset(bits as u64, i128::from(i)).0 as u128,\n+                Scalar::Raw {\n+                    data: dl.overflowing_signed_offset(data as u64, i128::from(i)).0 as u128,\n                     size,\n                 }\n             }\n@@ -237,9 +237,9 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn get_ptr_offset(self, cx: &impl HasDataLayout) -> Size {\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, cx.pointer_size().bytes());\n-                Size::from_bytes(bits as u64)\n+                Size::from_bytes(data as u64)\n             }\n             Scalar::Ptr(ptr) => ptr.offset,\n         }\n@@ -248,30 +248,30 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn is_null_ptr(self, cx: &impl HasDataLayout) -> bool {\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, cx.data_layout().pointer_size.bytes());\n-                bits == 0\n+                data == 0\n             },\n             Scalar::Ptr(_) => false,\n         }\n     }\n \n     #[inline]\n     pub fn from_bool(b: bool) -> Self {\n-        Scalar::Bits { bits: b as u128, size: 1 }\n+        Scalar::Raw { data: b as u128, size: 1 }\n     }\n \n     #[inline]\n     pub fn from_char(c: char) -> Self {\n-        Scalar::Bits { bits: c as u128, size: 4 }\n+        Scalar::Raw { data: c as u128, size: 4 }\n     }\n \n     #[inline]\n     pub fn from_uint(i: impl Into<u128>, size: Size) -> Self {\n         let i = i.into();\n         debug_assert_eq!(truncate(i, size), i,\n                          \"Unsigned value {} does not fit in {} bits\", i, size.bits());\n-        Scalar::Bits { bits: i, size: size.bytes() as u8 }\n+        Scalar::Raw { data: i, size: size.bytes() as u8 }\n     }\n \n     #[inline]\n@@ -281,26 +281,26 @@ impl<'tcx, Tag> Scalar<Tag> {\n         let truncated = truncate(i as u128, size);\n         debug_assert_eq!(sign_extend(truncated, size) as i128, i,\n                          \"Signed value {} does not fit in {} bits\", i, size.bits());\n-        Scalar::Bits { bits: truncated, size: size.bytes() as u8 }\n+        Scalar::Raw { data: truncated, size: size.bytes() as u8 }\n     }\n \n     #[inline]\n     pub fn from_f32(f: f32) -> Self {\n-        Scalar::Bits { bits: f.to_bits() as u128, size: 4 }\n+        Scalar::Raw { data: f.to_bits() as u128, size: 4 }\n     }\n \n     #[inline]\n     pub fn from_f64(f: f64) -> Self {\n-        Scalar::Bits { bits: f.to_bits() as u128, size: 8 }\n+        Scalar::Raw { data: f.to_bits() as u128, size: 8 }\n     }\n \n     #[inline]\n     pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n         match self {\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(target_size.bytes(), size as u64);\n                 assert_ne!(size, 0, \"to_bits cannot be used with zsts\");\n-                Ok(bits)\n+                Ok(data)\n             }\n             Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n         }\n@@ -309,16 +309,16 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer<Tag>> {\n         match self {\n-            Scalar::Bits { bits: 0, .. } => err!(InvalidNullPointerUsage),\n-            Scalar::Bits { .. } => err!(ReadBytesAsPointer),\n+            Scalar::Raw { data: 0, .. } => err!(InvalidNullPointerUsage),\n+            Scalar::Raw { .. } => err!(ReadBytesAsPointer),\n             Scalar::Ptr(p) => Ok(p),\n         }\n     }\n \n     #[inline]\n     pub fn is_bits(self) -> bool {\n         match self {\n-            Scalar::Bits { .. } => true,\n+            Scalar::Raw { .. } => true,\n             _ => false,\n         }\n     }\n@@ -333,8 +333,8 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n         match self {\n-            Scalar::Bits { bits: 0, size: 1 } => Ok(false),\n-            Scalar::Bits { bits: 1, size: 1 } => Ok(true),\n+            Scalar::Raw { data: 0, size: 1 } => Ok(false),\n+            Scalar::Raw { data: 1, size: 1 } => Ok(true),\n             _ => err!(InvalidBool),\n         }\n     }"}, {"sha": "e2a8cd6b17df62c0ba3b38295f3adf5d5a2a0beb", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -1669,10 +1669,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                         .map(|&u| {\n                             tcx.mk_const(ty::Const {\n                                 val: ConstValue::Scalar(\n-                                    Scalar::Bits {\n-                                        bits: u,\n-                                        size: size.bytes() as u8,\n-                                    }.into(),\n+                                    Scalar::from_uint(u, size).into(),\n                                 ),\n                                 ty: switch_ty,\n                             }).to_string().into()"}, {"sha": "92de3e28d19035467e858af53fbba8d1837dd3ae", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -1001,7 +1001,7 @@ impl<'tcx> CommonConsts<'tcx> {\n \n         CommonConsts {\n             err: mk_const(ty::Const {\n-                val: ConstValue::Scalar(Scalar::Bits { bits: 0, size: 0 }),\n+                val: ConstValue::Scalar(Scalar::zst()),\n                 ty: types.err,\n             }),\n         }"}, {"sha": "eae05bab2a43587f51f3e99f7c49587fc04152b7", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -845,34 +845,34 @@ pub trait PrettyPrinter<'gcx: 'tcx, 'tcx>:\n             p!(write(\"{}\", name));\n             return Ok(self);\n         }\n-        if let ConstValue::Scalar(Scalar::Bits { bits, .. }) = ct.val {\n+        if let ConstValue::Scalar(Scalar::Raw { data, .. }) = ct.val {\n             match ct.ty.sty {\n                 ty::Bool => {\n-                    p!(write(\"{}\", if bits == 0 { \"false\" } else { \"true\" }));\n+                    p!(write(\"{}\", if data == 0 { \"false\" } else { \"true\" }));\n                     return Ok(self);\n                 },\n                 ty::Float(ast::FloatTy::F32) => {\n-                    p!(write(\"{}f32\", Single::from_bits(bits)));\n+                    p!(write(\"{}f32\", Single::from_bits(data)));\n                     return Ok(self);\n                 },\n                 ty::Float(ast::FloatTy::F64) => {\n-                    p!(write(\"{}f64\", Double::from_bits(bits)));\n+                    p!(write(\"{}f64\", Double::from_bits(data)));\n                     return Ok(self);\n                 },\n                 ty::Uint(ui) => {\n-                    p!(write(\"{}{}\", bits, ui));\n+                    p!(write(\"{}{}\", data, ui));\n                     return Ok(self);\n                 },\n                 ty::Int(i) =>{\n                     let ty = self.tcx().lift_to_global(&ct.ty).unwrap();\n                     let size = self.tcx().layout_of(ty::ParamEnv::empty().and(ty))\n                         .unwrap()\n                         .size;\n-                    p!(write(\"{}{}\", sign_extend(bits, size) as i128, i));\n+                    p!(write(\"{}{}\", sign_extend(data, size) as i128, i));\n                     return Ok(self);\n                 },\n                 ty::Char => {\n-                    p!(write(\"{:?}\", ::std::char::from_u32(bits as u32).unwrap()));\n+                    p!(write(\"{:?}\", ::std::char::from_u32(data as u32).unwrap()));\n                     return Ok(self);\n                 }\n                 _ => {},"}, {"sha": "75d227d8067c3c088348f5a54ea98702b9a9bdce", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -613,7 +613,7 @@ where\n         (ConstValue::Placeholder(p1), ConstValue::Placeholder(p2)) if p1 == p2 => {\n             Ok(a)\n         }\n-        (ConstValue::Scalar(Scalar::Bits { .. }), _) if a == b => {\n+        (ConstValue::Scalar(Scalar::Raw { .. }), _) if a == b => {\n             Ok(a)\n         }\n         (ConstValue::ByRef(..), _) => {"}, {"sha": "e3c1e6bc22faf6ef85ef612b7a7f9d28ff9c5874", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -3,7 +3,7 @@\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::infer::canonical::Canonical;\n-use crate::mir::interpret::{ConstValue, truncate};\n+use crate::mir::interpret::ConstValue;\n use crate::middle::region;\n use polonius_engine::Atom;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -2232,14 +2232,12 @@ impl<'tcx> Const<'tcx> {\n         let size = tcx.layout_of(ty).unwrap_or_else(|e| {\n             panic!(\"could not compute layout for {:?}: {:?}\", ty, e)\n         }).size;\n-        let truncated = truncate(bits, size);\n-        assert_eq!(truncated, bits, \"from_bits called with untruncated value\");\n-        Self::from_scalar(tcx, Scalar::Bits { bits, size: size.bytes() as u8 }, ty.value)\n+        Self::from_scalar(tcx, Scalar::from_uint(bits, size), ty.value)\n     }\n \n     #[inline]\n     pub fn zero_sized(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n-        Self::from_scalar(tcx, Scalar::Bits { bits: 0, size: 0 }, ty)\n+        Self::from_scalar(tcx, Scalar::zst(), ty)\n     }\n \n     #[inline]"}, {"sha": "c713362440d97140b8d185fe00c76049d2942ed4", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -294,13 +294,13 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     ) -> &'ll Value {\n         let bitsize = if layout.is_bool() { 1 } else { layout.value.size(self).bits() };\n         match cv {\n-            Scalar::Bits { size: 0, .. } => {\n+            Scalar::Raw { size: 0, .. } => {\n                 assert_eq!(0, layout.value.size(self).bytes());\n                 self.const_undef(self.type_ix(0))\n             },\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, layout.value.size(self).bytes());\n-                let llval = self.const_uint_big(self.type_ix(bitsize), bits);\n+                let llval = self.const_uint_big(self.type_ix(bitsize), data);\n                 if layout.value == layout::Pointer {\n                     unsafe { llvm::LLVMConstIntToPtr(llval, llty) }\n                 } else {"}, {"sha": "370b76520fc1a0580148de5605fdb83c0652ec2f", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -115,7 +115,7 @@ fn op_to_const<'tcx>(\n                     ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n                     ptr.offset.bytes(),\n                 ),\n-                Scalar::Bits { .. } => (\n+                Scalar::Raw { .. } => (\n                     ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\", ())),\n                     0,\n                 ),"}, {"sha": "0f5c696f7f9f3bc2a819cc77e4e9121bc350bd9f", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -1,5 +1,5 @@\n use syntax::ast;\n-use rustc::ty::{self, Ty, TyCtxt, ParamEnv};\n+use rustc::ty::{self, Ty, TyCtxt, ParamEnv, layout::Size};\n use syntax_pos::symbol::Symbol;\n use rustc::mir::interpret::{ConstValue, Scalar};\n \n@@ -23,10 +23,7 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n         trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n         let result = truncate(n, width);\n         trace!(\"trunc result: {}\", result);\n-        Ok(ConstValue::Scalar(Scalar::Bits {\n-            bits: result,\n-            size: width.bytes() as u8,\n-        }))\n+        Ok(ConstValue::Scalar(Scalar::from_uint(result, width)))\n     };\n \n     use rustc::mir::interpret::*;\n@@ -50,10 +47,7 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n             let id = tcx.allocate_bytes(data);\n             ConstValue::Scalar(Scalar::Ptr(id.into()))\n         },\n-        LitKind::Byte(n) => ConstValue::Scalar(Scalar::Bits {\n-            bits: n as u128,\n-            size: 1,\n-        }),\n+        LitKind::Byte(n) => ConstValue::Scalar(Scalar::from_uint(n, Size::from_bytes(1))),\n         LitKind::Int(n, _) if neg => {\n             let n = n as i128;\n             let n = n.overflowing_neg().0;\n@@ -84,7 +78,7 @@ fn parse_float<'tcx>(\n     let num = num.as_str();\n     use rustc_apfloat::ieee::{Single, Double};\n     use rustc_apfloat::Float;\n-    let (bits, size) = match fty {\n+    let (data, size) = match fty {\n         ast::FloatTy::F32 => {\n             num.parse::<f32>().map_err(|_| ())?;\n             let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n@@ -107,5 +101,6 @@ fn parse_float<'tcx>(\n         }\n     };\n \n-    Ok(ConstValue::Scalar(Scalar::Bits { bits, size }))\n+    // We trust that `data` is properly truncated.\n+    Ok(ConstValue::Scalar(Scalar::Raw { data, size }))\n }"}, {"sha": "e0667f17fd1ff6b43421bf4b03f8583bb513e9fa", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -137,22 +137,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n \n         match val {\n             Scalar::Ptr(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 debug_assert_eq!(size as u64, src_layout.size.bytes());\n-                debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n+                debug_assert_eq!(truncate(data, Size::from_bytes(size.into())), data,\n                     \"Unexpected value of size {} before casting\", size);\n \n                 let res = match src_layout.ty.sty {\n-                    Float(fty) => self.cast_from_float(bits, fty, dest_layout.ty)?,\n-                    _ => self.cast_from_int(bits, src_layout, dest_layout)?,\n+                    Float(fty) => self.cast_from_float(data, fty, dest_layout.ty)?,\n+                    _ => self.cast_from_int(data, src_layout, dest_layout)?,\n                 };\n \n                 // Sanity check\n                 match res {\n                     Scalar::Ptr(_) => bug!(\"Fabricated a ptr value from an int...?\"),\n-                    Scalar::Bits { bits, size } => {\n+                    Scalar::Raw { data, size } => {\n                         debug_assert_eq!(size as u64, dest_layout.size.bytes());\n-                        debug_assert_eq!(truncate(bits, Size::from_bytes(size.into())), bits,\n+                        debug_assert_eq!(truncate(data, Size::from_bytes(size.into())), data,\n                             \"Unexpected value of size {} after casting\", size);\n                     }\n                 }"}, {"sha": "7009649ae55324a5d563e7257e39830691769e27", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -12,7 +12,6 @@ use std::borrow::Cow;\n \n use rustc::ty::{self, Instance, ParamEnv, query::TyCtxtAt};\n use rustc::ty::layout::{Align, TargetDataLayout, Size, HasDataLayout};\n-pub use rustc::mir::interpret::{truncate, write_target_uint, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n \n use syntax::ast::Mutability;\n@@ -255,15 +254,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 let align = self.check_bounds_ptr(ptr, InboundsCheck::MaybeDead)?;\n                 (ptr.offset.bytes(), align)\n             }\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, self.pointer_size().bytes());\n-                assert!(bits < (1u128 << self.pointer_size().bits()));\n+                assert!(data < (1u128 << self.pointer_size().bits()));\n                 // check this is not NULL\n-                if bits == 0 {\n+                if data == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n                 // the \"base address\" is 0 and hence always aligned\n-                (bits as u64, required_align)\n+                (data as u64, required_align)\n             }\n         };\n         // Check alignment"}, {"sha": "d4ccccfbfb87681641b3d5a26abee60c10ba43ad", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -649,7 +649,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                         }\n                         (dataful_variant.as_u32() as u128, dataful_variant)\n                     },\n-                    ScalarMaybeUndef::Scalar(Scalar::Bits { bits: raw_discr, size }) => {\n+                    ScalarMaybeUndef::Scalar(Scalar::Raw { data: raw_discr, size }) => {\n                         assert_eq!(size as u64, discr_val.layout.size.bytes());\n                         let adjusted_discr = raw_discr.wrapping_sub(niche_start)\n                             .wrapping_add(variants_start);"}, {"sha": "6a22fde360c5c69816b8c80ce066af766cfcafd2", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -686,7 +686,7 @@ where\n                 Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Ptr(_))) =>\n                     assert_eq!(self.pointer_size(), dest.layout.size,\n                         \"Size mismatch when writing pointer\"),\n-                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { size, .. })) =>\n+                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Raw { size, .. })) =>\n                     assert_eq!(Size::from_bytes(size.into()), dest.layout.size,\n                         \"Size mismatch when writing bits\"),\n                 Immediate::Scalar(ScalarMaybeUndef::Undef) => {}, // undef can have any size"}, {"sha": "c0bc7ce6b39ad09af7c5d7e790fef386c4f68a78", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -186,9 +186,9 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for Scalar\n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n         match self {\n             Scalar::Ptr(p) => Scalar::Ptr(p.snapshot(ctx)),\n-            Scalar::Bits{ size, bits } => Scalar::Bits {\n+            Scalar::Raw{ size, data } => Scalar::Raw {\n+                data: *data,\n                 size: *size,\n-                bits: *bits,\n             },\n         }\n     }"}, {"sha": "c2ecc38808b35d409fa4d1fdec3698482b0afa73", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -509,9 +509,9 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n                     );\n                 }\n             }\n-            Scalar::Bits { bits, size } => {\n+            Scalar::Raw { data, size } => {\n                 assert_eq!(size as u64, op.layout.size.bytes());\n-                bits\n+                data\n             }\n         };\n         // Now compare. This is slightly subtle because this is a special \"wrap-around\" range."}, {"sha": "6b580ce5459175a2416571d74bb53df21296fdd4", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082da0c6984dd37ab5d65db939c538f0d24bc19f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=082da0c6984dd37ab5d65db939c538f0d24bc19f", "patch": "@@ -378,10 +378,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some(\n                     ImmTy {\n                         imm: Immediate::Scalar(\n-                            Scalar::Bits {\n-                                bits: n as u128,\n-                                size: self.tcx.data_layout.pointer_size.bytes() as u8,\n-                            }.into()\n+                            Scalar::from_uint(n, self.tcx.data_layout.pointer_size).into()\n                         ),\n                         layout: self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n                     }.into()\n@@ -700,18 +697,18 @@ impl<'b, 'a, 'tcx> MutVisitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                                     .eval_operand(len, source_info)\n                                     .expect(\"len must be const\");\n                                 let len = match self.ecx.read_scalar(len) {\n-                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n-                                        bits, ..\n-                                    })) => bits,\n+                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Raw {\n+                                        data, ..\n+                                    })) => data,\n                                     other => bug!(\"const len not primitive: {:?}\", other),\n                                 };\n                                 let index = self\n                                     .eval_operand(index, source_info)\n                                     .expect(\"index must be const\");\n                                 let index = match self.ecx.read_scalar(index) {\n-                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Bits {\n-                                        bits, ..\n-                                    })) => bits,\n+                                    Ok(ScalarMaybeUndef::Scalar(Scalar::Raw {\n+                                        data, ..\n+                                    })) => data,\n                                     other => bug!(\"const index not primitive: {:?}\", other),\n                                 };\n                                 format!("}]}