{"sha": "edb5214b29cd7de06dd10f673986d38e568b077c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkYjUyMTRiMjljZDdkZTA2ZGQxMGY2NzM5ODZkMzhlNTY4YjA3N2M=", "commit": {"author": {"name": "Jack O'Connor", "email": "oconnor663@gmail.com", "date": "2019-08-01T16:04:28Z"}, "committer": {"name": "Jack O'Connor", "email": "oconnor663@gmail.com", "date": "2019-08-06T14:15:11Z"}, "message": "avoid unnecessary reservations in std::io::Take::read_to_end\n\nPrevously the `read_to_end` implementation for `std::io::Take` used its\nown `limit` as a cap on the `reservation_size`. However, that could\nstill result in an over-allocation like this:\n\n1. Call `reader.take(5).read_to_end(&mut vec)`.\n2. `read_to_end_with_reservation` reserves 5 bytes and calls `read`.\n3. `read` writes 5 bytes.\n4. `read_to_end_with_reservation` reserves 5 bytes and calls `read`.\n5. `read` writes 0 bytes.\n6. The read loop ends with `vec` having length 5 and capacity 10.\n\nThe reservation of 5 bytes was correct for the read at step 2 but\nunnecessary for the read at step 4. By that second read, `Take::limit`\nis 0, but the `read_to_end_with_reservation` loop is still using the\nsame `reservation_size` it started with.\n\nSolve this by having `read_to_end_with_reservation` take a closure,\nwhich lets it get a fresh `reservation_size` for each read. This is an\nimplementation detail which doesn't affect any public API.", "tree": {"sha": "4ab0f9081437c130d2bb82fb297e226512fb7b03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ab0f9081437c130d2bb82fb297e226512fb7b03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/edb5214b29cd7de06dd10f673986d38e568b077c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/edb5214b29cd7de06dd10f673986d38e568b077c", "html_url": "https://github.com/rust-lang/rust/commit/edb5214b29cd7de06dd10f673986d38e568b077c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/edb5214b29cd7de06dd10f673986d38e568b077c/comments", "author": {"login": "oconnor663", "id": 860932, "node_id": "MDQ6VXNlcjg2MDkzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/860932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oconnor663", "html_url": "https://github.com/oconnor663", "followers_url": "https://api.github.com/users/oconnor663/followers", "following_url": "https://api.github.com/users/oconnor663/following{/other_user}", "gists_url": "https://api.github.com/users/oconnor663/gists{/gist_id}", "starred_url": "https://api.github.com/users/oconnor663/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oconnor663/subscriptions", "organizations_url": "https://api.github.com/users/oconnor663/orgs", "repos_url": "https://api.github.com/users/oconnor663/repos", "events_url": "https://api.github.com/users/oconnor663/events{/privacy}", "received_events_url": "https://api.github.com/users/oconnor663/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oconnor663", "id": 860932, "node_id": "MDQ6VXNlcjg2MDkzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/860932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oconnor663", "html_url": "https://github.com/oconnor663", "followers_url": "https://api.github.com/users/oconnor663/followers", "following_url": "https://api.github.com/users/oconnor663/following{/other_user}", "gists_url": "https://api.github.com/users/oconnor663/gists{/gist_id}", "starred_url": "https://api.github.com/users/oconnor663/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oconnor663/subscriptions", "organizations_url": "https://api.github.com/users/oconnor663/orgs", "repos_url": "https://api.github.com/users/oconnor663/repos", "events_url": "https://api.github.com/users/oconnor663/events{/privacy}", "received_events_url": "https://api.github.com/users/oconnor663/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8996328ebf34aa73e83a1db326767c11041f811d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8996328ebf34aa73e83a1db326767c11041f811d", "html_url": "https://github.com/rust-lang/rust/commit/8996328ebf34aa73e83a1db326767c11041f811d"}], "stats": {"total": 66, "additions": 58, "deletions": 8}, "files": [{"sha": "5060f368229bb848821664e8fe48baadc9a227fe", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/edb5214b29cd7de06dd10f673986d38e568b077c/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/edb5214b29cd7de06dd10f673986d38e568b077c/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=edb5214b29cd7de06dd10f673986d38e568b077c", "patch": "@@ -353,20 +353,25 @@ fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n // Because we're extending the buffer with uninitialized data for trusted\n // readers, we need to make sure to truncate that if any of this panics.\n fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n-    read_to_end_with_reservation(r, buf, 32)\n+    read_to_end_with_reservation(r, buf, |_| 32)\n }\n \n-fn read_to_end_with_reservation<R: Read + ?Sized>(r: &mut R,\n-                                                  buf: &mut Vec<u8>,\n-                                                  reservation_size: usize) -> Result<usize>\n+fn read_to_end_with_reservation<R, F>(\n+    r: &mut R,\n+    buf: &mut Vec<u8>,\n+    mut reservation_size: F,\n+) -> Result<usize>\n+where\n+    R: Read + ?Sized,\n+    F: FnMut(&R) -> usize,\n {\n     let start_len = buf.len();\n     let mut g = Guard { len: buf.len(), buf: buf };\n     let ret;\n     loop {\n         if g.len == g.buf.len() {\n             unsafe {\n-                g.buf.reserve(reservation_size);\n+                g.buf.reserve(reservation_size(r));\n                 let capacity = g.buf.capacity();\n                 g.buf.set_len(capacity);\n                 r.initializer().initialize(&mut g.buf[g.len..]);\n@@ -2253,9 +2258,10 @@ impl<T: Read> Read for Take<T> {\n     }\n \n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n-        let reservation_size = cmp::min(self.limit, 32) as usize;\n-\n-        read_to_end_with_reservation(self, buf, reservation_size)\n+        // Pass in a reservation_size closure that respects the current value\n+        // of limit for each read. If we hit the read limit, this prevents the\n+        // final zero-byte read from allocating again.\n+        read_to_end_with_reservation(self, buf, |self_| cmp::min(self_.limit, 32) as usize)\n     }\n }\n \n@@ -2378,6 +2384,7 @@ impl<B: BufRead> Iterator for Lines<B> {\n \n #[cfg(test)]\n mod tests {\n+    use crate::cmp;\n     use crate::io::prelude::*;\n     use super::{Cursor, SeekFrom, repeat};\n     use crate::io::{self, IoSlice, IoSliceMut};\n@@ -2651,6 +2658,49 @@ mod tests {\n         Ok(())\n     }\n \n+    // A simple example reader which uses the default implementation of\n+    // read_to_end.\n+    struct ExampleSliceReader<'a> {\n+        slice: &'a [u8],\n+    }\n+\n+    impl<'a> Read for ExampleSliceReader<'a> {\n+        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+            let len = cmp::min(self.slice.len(), buf.len());\n+            buf[..len].copy_from_slice(&self.slice[..len]);\n+            self.slice = &self.slice[len..];\n+            Ok(len)\n+        }\n+    }\n+\n+    #[test]\n+    fn test_read_to_end_capacity() -> io::Result<()> {\n+        let input = &b\"foo\"[..];\n+\n+        // read_to_end() generally needs to over-allocate, both for efficiency\n+        // and so that it can distinguish EOF. Assert that this is the case\n+        // with this simple ExampleSliceReader struct, which uses the default\n+        // implementation of read_to_end. Even though vec1 is allocated with\n+        // exactly enough capacity for the read, read_to_end will allocate more\n+        // space here.\n+        let mut vec1 = Vec::with_capacity(input.len());\n+        ExampleSliceReader { slice: input }.read_to_end(&mut vec1)?;\n+        assert_eq!(vec1.len(), input.len());\n+        assert!(vec1.capacity() > input.len(), \"allocated more\");\n+\n+        // However, std::io::Take includes an implementation of read_to_end\n+        // that will not allocate when the limit has already been reached. In\n+        // this case, vec2 never grows.\n+        let mut vec2 = Vec::with_capacity(input.len());\n+        ExampleSliceReader { slice: input }\n+            .take(input.len() as u64)\n+            .read_to_end(&mut vec2)?;\n+        assert_eq!(vec2.len(), input.len());\n+        assert_eq!(vec2.capacity(), input.len(), \"did not allocate more\");\n+\n+        Ok(())\n+    }\n+\n     #[test]\n     fn io_slice_mut_advance() {\n         let mut buf1 = [1; 8];"}]}