{"sha": "a1885cdba38a63448ceec02f951ddc0844d0ff38", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExODg1Y2RiYTM4YTYzNDQ4Y2VlYzAyZjk1MWRkYzA4NDRkMGZmMzg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-13T19:46:20Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-05-22T17:20:12Z"}, "message": "Restore the old behavior of the rustdoc keyword check + Fix rebase", "tree": {"sha": "8c45eb2a7169a49b8a6e66fc3193c8d99ffc7632", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c45eb2a7169a49b8a6e66fc3193c8d99ffc7632"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1885cdba38a63448ceec02f951ddc0844d0ff38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1885cdba38a63448ceec02f951ddc0844d0ff38", "html_url": "https://github.com/rust-lang/rust/commit/a1885cdba38a63448ceec02f951ddc0844d0ff38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1885cdba38a63448ceec02f951ddc0844d0ff38/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c389a39c9728d5c912a9ce1bc4c04eb1a3f31fe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c389a39c9728d5c912a9ce1bc4c04eb1a3f31fe8", "html_url": "https://github.com/rust-lang/rust/commit/c389a39c9728d5c912a9ce1bc4c04eb1a3f31fe8"}], "stats": {"total": 85, "additions": 44, "deletions": 41}, "files": [{"sha": "7a8d5d3bb9a67f62371634229a26fe85c0f6f4ac", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=a1885cdba38a63448ceec02f951ddc0844d0ff38", "patch": "@@ -8,7 +8,7 @@ use crate::ty::{self, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n use crate::ty::subst::{Kind, Subst, UnpackedKind};\n use crate::mir::interpret::ConstValue;\n use rustc_target::spec::abi::Abi;\n-use syntax::symbol::{keywords, InternedString};\n+use syntax::symbol::{kw, InternedString};\n \n use std::cell::Cell;\n use std::fmt::{self, Write as _};\n@@ -1140,16 +1140,16 @@ impl<F: fmt::Write> PrettyPrinter<'gcx, 'tcx> for FmtPrinter<'_, 'gcx, 'tcx, F>\n \n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                data.name.as_symbol() != keywords::Invalid.name() &&\n-                data.name.as_symbol() != keywords::UnderscoreLifetime.name()\n+                data.name.as_symbol() != kw::Invalid &&\n+                data.name.as_symbol() != kw::UnderscoreLifetime\n             }\n \n             ty::ReLateBound(_, br) |\n             ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n             ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n-                    if name.as_symbol() != keywords::Invalid.name() &&\n-                       name.as_symbol() != keywords::UnderscoreLifetime.name() {\n+                    if name.as_symbol() != kw::Invalid &&\n+                       name.as_symbol() != kw::UnderscoreLifetime {\n                         return true;\n                     }\n                 }\n@@ -1205,7 +1205,7 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, '_, F> {\n         // `explain_region()` or `note_and_explain_region()`.\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                if data.name.as_symbol() != keywords::Invalid.name() {\n+                if data.name.as_symbol() != kw::Invalid {\n                     p!(write(\"{}\", data.name));\n                     return Ok(self);\n                 }\n@@ -1214,8 +1214,8 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, '_, F> {\n             ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n             ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n-                    if name.as_symbol() != keywords::Invalid.name() &&\n-                       name.as_symbol() != keywords::UnderscoreLifetime.name() {\n+                    if name.as_symbol() != kw::Invalid &&\n+                       name.as_symbol() != kw::UnderscoreLifetime {\n                         p!(write(\"{}\", name));\n                         return Ok(self);\n                     }"}, {"sha": "b9cd30694f6e8efe5f4f4b6687dfc8ad2d0a0b5f", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=a1885cdba38a63448ceec02f951ddc0844d0ff38", "patch": "@@ -19,7 +19,7 @@ use syntax::{\n     mut_visit::{self, MutVisitor},\n     parse::ParseSess,\n     ptr::P,\n-    symbol::{keywords, Symbol, sym}\n+    symbol::{kw, sym, Symbol}\n };\n use syntax_pos::Span;\n \n@@ -116,8 +116,7 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n \n         // We will generate a new submodule. To `use` the static from that module, we need to get\n         // the `super::...` path.\n-        let super_path =\n-            f.cx.path(f.span, vec![Ident::with_empty_ctxt(keywords::Super.name()), f.global]);\n+        let super_path = f.cx.path(f.span, vec![Ident::with_empty_ctxt(kw::Super), f.global]);\n \n         // Generate the items in the submodule\n         let mut items = vec!["}, {"sha": "46cd66fe58546d0ae79df7a3fb0d24f5ef9dee82", "filename": "src/librustc_plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibrustc_plugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibrustc_plugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fload.rs?ref=a1885cdba38a63448ceec02f951ddc0844d0ff38", "patch": "@@ -11,7 +11,7 @@ use std::mem;\n use std::path::PathBuf;\n use syntax::ast;\n use syntax::span_err;\n-use syntax::symbol::{Symbol, keywords, sym};\n+use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::{Span, DUMMY_SP};\n \n /// Pointer to a registrar function.\n@@ -58,7 +58,7 @@ pub fn load_plugins(sess: &Session,\n             for plugin in plugins {\n                 // plugins must have a name and can't be key = value\n                 let name = plugin.name_or_empty();\n-                if name != keywords::Invalid.name() && !plugin.is_value_str() {\n+                if name != kw::Invalid && !plugin.is_value_str() {\n                     let args = plugin.meta_item_list().map(ToOwned::to_owned);\n                     loader.load_plugin(plugin.span(), name, args.unwrap_or_default());\n                 } else {"}, {"sha": "c0ff7b310b5815e0a6d9767f63b5e02e91cf6137", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=a1885cdba38a63448ceec02f951ddc0844d0ff38", "patch": "@@ -707,7 +707,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 has_errors = true;\n \n                 if let SingleImport { source, ref source_bindings, .. } = import.subclass {\n-                    if source.name == keywords::SelfLower.name() {\n+                    if source.name == kw::SelfLower {\n                         // Silence `unresolved import` error if E0429 is already emitted\n                         if let Err(Determined) = source_bindings.value_ns.get() {\n                             continue;"}, {"sha": "e5b44077fc993ab15d4582f2b67065f99032b693", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=a1885cdba38a63448ceec02f951ddc0844d0ff38", "patch": "@@ -15,6 +15,7 @@ use syntax::source_map::{SourceMap, FilePathMapping};\n use syntax::parse::lexer::{self, TokenAndSpan};\n use syntax::parse::token;\n use syntax::parse;\n+use syntax::symbol::{kw, sym};\n use syntax_pos::{Span, FileName};\n \n /// Highlights `src`, returning the HTML output.\n@@ -325,16 +326,15 @@ impl<'a> Classifier<'a> {\n \n             // Keywords are also included in the identifier set.\n             token::Ident(ident, is_raw) => {\n-                match &*ident.as_str() {\n-                    \"ref\" | \"mut\" if !is_raw => Class::RefKeyWord,\n+                match ident.name {\n+                    kw::Ref | kw::Mut if !is_raw => Class::RefKeyWord,\n \n-                    \"self\" | \"Self\" => Class::Self_,\n-                    \"false\" | \"true\" if !is_raw => Class::Bool,\n+                    kw::SelfLower | kw::SelfUpper => Class::Self_,\n+                    kw::False | kw::True if !is_raw => Class::Bool,\n \n-                    \"Option\" | \"Result\" => Class::PreludeTy,\n-                    \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n+                    sym::Option | sym::Result => Class::PreludeTy,\n+                    sym::Some | sym::None | sym::Ok | sym::Err => Class::PreludeVal,\n \n-                    \"$crate\" => Class::KeyWord,\n                     _ if tas.tok.is_reserved_ident() => Class::KeyWord,\n \n                     _ => {"}, {"sha": "ae0bd1aafa8f159393fce8482bc54eb47e314e27", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=a1885cdba38a63448ceec02f951ddc0844d0ff38", "patch": "@@ -44,7 +44,7 @@ pub fn render<T: fmt::Display, S: fmt::Display>(\n     <meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">\\\n     <meta name=\\\"generator\\\" content=\\\"rustdoc\\\">\\\n     <meta name=\\\"description\\\" content=\\\"{description}\\\">\\\n-    <meta name=\\\"keywords\\\" content=\\\"{kw}\\\">\\\n+    <meta name=\\\"keywords\\\" content=\\\"{keywords}\\\">\\\n     <title>{title}</title>\\\n     <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{static_root_path}normalize{suffix}.css\\\">\\\n     <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{static_root_path}rustdoc{suffix}.css\\\" \\"}, {"sha": "a97c094418dfbe65f007d2e7b034474c65d297eb", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=a1885cdba38a63448ceec02f951ddc0844d0ff38", "patch": "@@ -22,7 +22,7 @@ use crate::parse::parser::Parser;\n use crate::parse::{self, ParseSess, PResult};\n use crate::parse::token::{self, Token};\n use crate::ptr::P;\n-use crate::symbol::{kw, sym, Symbol};\n+use crate::symbol::{sym, Symbol};\n use crate::ThinVec;\n use crate::tokenstream::{TokenStream, TokenTree, DelimSpan};\n use crate::GLOBALS;\n@@ -206,7 +206,7 @@ impl MetaItem {\n         }\n     }\n     pub fn name_or_empty(&self) -> Symbol {\n-        self.ident().unwrap_or(Ident.invalid()).name\n+        self.ident().unwrap_or(Ident::invalid()).name\n     }\n \n     // #[attribute(name = \"value\")]"}, {"sha": "37c49112dcaaceb22dcd42b1841620734fc2435c", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=a1885cdba38a63448ceec02f951ddc0844d0ff38", "patch": "@@ -13,7 +13,7 @@ use crate::parse::{Directory, ParseSess};\n use crate::parse::parser::Parser;\n use crate::parse::token::{self, NtTT};\n use crate::parse::token::Token::*;\n-use crate::symbol::{Symbol, keywords, sym};\n+use crate::symbol::{Symbol, kw, sym};\n use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n \n use errors::FatalError;\n@@ -1046,8 +1046,8 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                 match *tok {\n                     TokenTree::Token(_, ref tok) => match *tok {\n                         FatArrow | Comma | Eq | BinOp(token::Or) => IsInFollow::Yes,\n-                        Ident(i, false) if i.name == keywords::If.name() ||\n-                                           i.name == keywords::In.name() => IsInFollow::Yes,\n+                        Ident(i, false) if i.name == kw::If ||\n+                                           i.name == kw::In => IsInFollow::Yes,\n                         _ => IsInFollow::No(tokens),\n                     },\n                     _ => IsInFollow::No(tokens),\n@@ -1064,8 +1064,8 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                         OpenDelim(token::DelimToken::Bracket) |\n                         Comma | FatArrow | Colon | Eq | Gt | BinOp(token::Shr) | Semi |\n                         BinOp(token::Or) => IsInFollow::Yes,\n-                        Ident(i, false) if i.name == keywords::As.name() ||\n-                                           i.name == keywords::Where.name() => IsInFollow::Yes,\n+                        Ident(i, false) if i.name == kw::As ||\n+                                           i.name == kw::Where => IsInFollow::Yes,\n                         _ => IsInFollow::No(tokens),\n                     },\n                     TokenTree::MetaVarDecl(_, _, frag) if frag.name == sym::block =>\n@@ -1092,7 +1092,7 @@ fn is_in_follow(tok: &quoted::TokenTree, frag: &str) -> IsInFollow {\n                 match *tok {\n                     TokenTree::Token(_, ref tok) => match *tok {\n                         Comma => IsInFollow::Yes,\n-                        Ident(i, is_raw) if is_raw || i.name != keywords::Priv.name() =>\n+                        Ident(i, is_raw) if is_raw || i.name != kw::Priv =>\n                             IsInFollow::Yes,\n                         ref tok => if tok.can_begin_type() {\n                             IsInFollow::Yes"}, {"sha": "57a6656140f004a8f9de1e730b7a4a62ba56183d", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a1885cdba38a63448ceec02f951ddc0844d0ff38", "patch": "@@ -22,7 +22,7 @@ use crate::source_map::Spanned;\n use crate::edition::{ALL_EDITIONS, Edition};\n use crate::visit::{self, FnKind, Visitor};\n use crate::parse::{token, ParseSess};\n-use crate::symbol::{Symbol, keywords, sym};\n+use crate::symbol::{Symbol, kw, sym};\n use crate::tokenstream::TokenTree;\n \n use errors::{DiagnosticBuilder, Handler};\n@@ -1948,7 +1948,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n     fn visit_item(&mut self, i: &'a ast::Item) {\n         match i.node {\n             ast::ItemKind::Const(_,_) => {\n-                if i.ident.name == keywords::Underscore.name() {\n+                if i.ident.name == kw::Underscore {\n                     gate_feature_post!(&self, underscore_const_names, i.span,\n                                         \"naming constants with `_` is unstable\");\n                 }"}, {"sha": "d48fcbbd6720d96e4b27581e7e0d69e4af5544d9", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=a1885cdba38a63448ceec02f951ddc0844d0ff38", "patch": "@@ -6,7 +6,7 @@ use crate::parse::PResult;\n use crate::parse::Parser;\n use crate::print::pprust;\n use crate::ptr::P;\n-use crate::symbol::keywords;\n+use crate::symbol::kw;\n use crate::ThinVec;\n use errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::Span;\n@@ -405,7 +405,7 @@ impl<'a> Parser<'a> {\n \n     /// Recover from `pub` keyword in places where it seems _reasonable_ but isn't valid.\n     crate fn eat_bad_pub(&mut self) {\n-        if self.token.is_keyword(keywords::Pub) {\n+        if self.token.is_keyword(kw::Pub) {\n             match self.parse_visibility(false) {\n                 Ok(vis) => {\n                     self.diagnostic()"}, {"sha": "f277f0522b8e5cefa58a65d4f284e65a0f16e6ae", "filename": "src/libsyntax/parse/literal.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fliteral.rs?ref=a1885cdba38a63448ceec02f951ddc0844d0ff38", "patch": "@@ -43,8 +43,8 @@ impl LitKind {\n \n         Some(match lit {\n             token::Bool(i) => {\n-                assert!(i == keywords::True.name() || i == keywords::False.name());\n-                LitKind::Bool(i == keywords::True.name())\n+                assert!(i == kw::True || i == kw::False);\n+                LitKind::Bool(i == kw::True)\n             }\n             token::Byte(i) => {\n                 match unescape_byte(&i.as_str()) {\n@@ -156,8 +156,8 @@ impl LitKind {\n             }\n             LitKind::FloatUnsuffixed(symbol) => (token::Lit::Float(symbol), None),\n             LitKind::Bool(value) => {\n-                let kw = if value { keywords::True } else { keywords::False };\n-                (token::Lit::Bool(kw.name()), None)\n+                let kw = if value { kw::True } else { kw::False };\n+                (token::Lit::Bool(kw), None)\n             }\n             LitKind::Err(val) => (token::Lit::Err(val), None),\n         }\n@@ -175,8 +175,7 @@ impl Lit {\n         diag: Option<(Span, &Handler)>,\n     ) -> Option<Lit> {\n         let (token, suffix) = match *token {\n-            token::Ident(ident, false) if ident.name == keywords::True.name() ||\n-                                          ident.name == keywords::False.name() =>\n+            token::Ident(ident, false) if ident.name == kw::True || ident.name == kw::False =>\n                 (token::Bool(ident.name), None),\n             token::Literal(token, suffix) =>\n                 (token, suffix),"}, {"sha": "d1e11da4e7cc26175b4270c8b9b376db03708f4e", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=a1885cdba38a63448ceec02f951ddc0844d0ff38", "patch": "@@ -215,7 +215,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n                    tests: Vec<Ident>,\n                    tested_submods: Vec<(Ident, Ident)>)\n                    -> (P<ast::Item>, Ident) {\n-    let super_ = Ident::with_empty_ctxt(keywords::Super.name());\n+    let super_ = Ident::with_empty_ctxt(kw::Super);\n \n     let items = tests.into_iter().map(|r| {\n         cx.ext_cx.item_use_simple(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public),"}, {"sha": "070bb1d8ef70494ef4c6f6247a213c1b4f44665c", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1885cdba38a63448ceec02f951ddc0844d0ff38/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=a1885cdba38a63448ceec02f951ddc0844d0ff38", "patch": "@@ -951,6 +951,11 @@ impl Symbol {\n     fn is_unused_keyword_2018(self) -> bool {\n         self >= kw::Async && self <= kw::Try\n     }\n+\n+    /// Used for sanity checking rustdoc keyword sections.\n+    pub fn is_doc_keyword(self) -> bool {\n+        self <= kw::Union\n+    }\n }\n \n impl Ident {"}]}