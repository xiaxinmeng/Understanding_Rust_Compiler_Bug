{"sha": "d386481fac65e988fa4d13c1bc8d4ddb2bc490c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzODY0ODFmYWM2NWU5ODhmYTRkMTNjMWJjOGQ0ZGRiMmJjNDkwYzY=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-02-24T23:53:59Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-08T21:59:20Z"}, "message": "Fix some tests", "tree": {"sha": "8557145c14606093a4ce75938e9b884ea4f01a90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8557145c14606093a4ce75938e9b884ea4f01a90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d386481fac65e988fa4d13c1bc8d4ddb2bc490c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d386481fac65e988fa4d13c1bc8d4ddb2bc490c6", "html_url": "https://github.com/rust-lang/rust/commit/d386481fac65e988fa4d13c1bc8d4ddb2bc490c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d386481fac65e988fa4d13c1bc8d4ddb2bc490c6/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "582cee2cdf5355b681f14bbb33bd5c431c284d87", "url": "https://api.github.com/repos/rust-lang/rust/commits/582cee2cdf5355b681f14bbb33bd5c431c284d87", "html_url": "https://github.com/rust-lang/rust/commit/582cee2cdf5355b681f14bbb33bd5c431c284d87"}], "stats": {"total": 192, "additions": 143, "deletions": 49}, "files": [{"sha": "e33fc4b78addd6184c4f8cdf41f9765d6b1e689c", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d386481fac65e988fa4d13c1bc8d4ddb2bc490c6/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d386481fac65e988fa4d13c1bc8d4ddb2bc490c6/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=d386481fac65e988fa4d13c1bc8d4ddb2bc490c6", "patch": "@@ -97,7 +97,7 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n         .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n         .into_iter()\n         .map(|import| {\n-            let proposed_def = match import.item_to_import() {\n+            let proposed_def = match import.item_to_display() {\n                 hir::ItemInNs::Types(id) => ScopeDef::ModuleDef(id.into()),\n                 hir::ItemInNs::Values(id) => ScopeDef::ModuleDef(id.into()),\n                 hir::ItemInNs::Macros(id) => ScopeDef::MacroDef(id.into()),\n@@ -809,7 +809,7 @@ fn main() {\n     #[test]\n     fn unresolved_assoc_item_container() {\n         check_edit(\n-            \"Item\",\n+            \"TEST_ASSOC\",\n             r#\"\n mod foo {\n     pub struct Item;\n@@ -820,7 +820,7 @@ mod foo {\n }\n \n fn main() {\n-    Item::TEST_A$0;\n+    Item::TEST_A$0\n }\n \"#,\n             r#\"\n@@ -844,7 +844,7 @@ fn main() {\n     #[test]\n     fn unresolved_assoc_item_container_with_path() {\n         check_edit(\n-            \"Item\",\n+            \"TEST_ASSOC\",\n             r#\"\n mod foo {\n     pub mod bar {\n@@ -857,7 +857,7 @@ mod foo {\n }\n \n fn main() {\n-    bar::Item::TEST_A$0;\n+    bar::Item::TEST_A$0\n }\n \"#,\n             r#\"\n@@ -876,6 +876,61 @@ mod foo {\n fn main() {\n     bar::Item::TEST_ASSOC\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unresolved_assoc_item_container_and_trait_with_path() {\n+        check_edit(\n+            \"TEST_ASSOC\",\n+            r#\"\n+mod foo {\n+    pub mod bar {\n+        pub trait SomeTrait {\n+            const TEST_ASSOC: usize;\n+        }\n+    }\n+\n+    pub mod baz {\n+        use super::bar::SomeTrait;\n+\n+        pub struct Item;\n+\n+        impl SomeTrait for Item {\n+            const TEST_ASSOC: usize = 3;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    baz::Item::TEST_A$0\n+}\n+\"#,\n+            r#\"\n+use foo::{bar::SomeTrait, baz};\n+\n+mod foo {\n+    pub mod bar {\n+        pub trait SomeTrait {\n+            const TEST_ASSOC: usize;\n+        }\n+    }\n+\n+    pub mod baz {\n+        use super::bar::SomeTrait;\n+\n+        pub struct Item;\n+\n+        impl SomeTrait for Item {\n+            const TEST_ASSOC: usize = 3;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    baz::Item::TEST_ASSOC\n+}\n \"#,\n         );\n     }"}, {"sha": "4bddc3957d6458557fba12e680ecafaaa0e79e6d", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d386481fac65e988fa4d13c1bc8d4ddb2bc490c6/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d386481fac65e988fa4d13c1bc8d4ddb2bc490c6/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=d386481fac65e988fa4d13c1bc8d4ddb2bc490c6", "patch": "@@ -13,7 +13,10 @@ mod builder_ext;\n use hir::{\n     AsAssocItem, Documentation, HasAttrs, HirDisplay, ModuleDef, Mutability, ScopeDef, Type,\n };\n-use ide_db::{helpers::SnippetCap, RootDatabase, SymbolKind};\n+use ide_db::{\n+    helpers::{item_name, SnippetCap},\n+    RootDatabase, SymbolKind,\n+};\n use syntax::TextRange;\n \n use crate::{\n@@ -56,7 +59,7 @@ pub(crate) fn render_resolution_with_import<'a>(\n         ScopeDef::ModuleDef(ModuleDef::Function(f)) => f.name(ctx.completion.db).to_string(),\n         ScopeDef::ModuleDef(ModuleDef::Const(c)) => c.name(ctx.completion.db)?.to_string(),\n         ScopeDef::ModuleDef(ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db).to_string(),\n-        _ => import_edit.import.display_path().segments().last()?.to_string(),\n+        _ => item_name(ctx.db(), import_edit.import.item_to_display())?.to_string(),\n     };\n     Render::new(ctx).render_resolution(local_name, Some(import_edit), resolution).map(|mut item| {\n         item.completion_kind = CompletionKind::Magic;"}, {"sha": "3c95d3cffa78d20f935f1338e3b10e3aaf9983c8", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d386481fac65e988fa4d13c1bc8d4ddb2bc490c6/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d386481fac65e988fa4d13c1bc8d4ddb2bc490c6/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=d386481fac65e988fa4d13c1bc8d4ddb2bc490c6", "patch": "@@ -2,11 +2,19 @@\n pub mod insert_use;\n pub mod import_assets;\n \n-use hir::{Crate, Enum, Module, ScopeDef, Semantics, Trait};\n+use hir::{Crate, Enum, ItemInNs, MacroDef, Module, ModuleDef, Name, ScopeDef, Semantics, Trait};\n use syntax::ast::{self, make};\n \n use crate::RootDatabase;\n \n+pub fn item_name(db: &RootDatabase, item: ItemInNs) -> Option<Name> {\n+    match item {\n+        ItemInNs::Types(module_def_id) => ModuleDef::from(module_def_id).name(db),\n+        ItemInNs::Values(module_def_id) => ModuleDef::from(module_def_id).name(db),\n+        ItemInNs::Macros(macro_def_id) => MacroDef::from(macro_def_id).name(db),\n+    }\n+}\n+\n /// Converts the mod path struct into its ast representation.\n pub fn mod_path_to_ast(path: &hir::ModPath) -> ast::Path {\n     let _p = profile::span(\"mod_path_to_ast\");"}, {"sha": "3d79f97711c694406d11a3108bd803d432b31796", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 69, "deletions": 41, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/d386481fac65e988fa4d13c1bc8d4ddb2bc490c6/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d386481fac65e988fa4d13c1bc8d4ddb2bc490c6/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=d386481fac65e988fa4d13c1bc8d4ddb2bc490c6", "patch": "@@ -1,8 +1,8 @@\n //! Look up accessible paths for items.\n use either::Either;\n use hir::{\n-    AsAssocItem, AssocItem, Crate, ItemInNs, MacroDef, ModPath, Module, ModuleDef, Name,\n-    PrefixKind, Semantics,\n+    AsAssocItem, AssocItem, AssocItemContainer, Crate, ItemInNs, MacroDef, ModPath, Module,\n+    ModuleDef, PathResolution, PrefixKind, Semantics, Type,\n };\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode};\n@@ -12,6 +12,8 @@ use crate::{\n     RootDatabase,\n };\n \n+use super::item_name;\n+\n #[derive(Debug)]\n pub enum ImportCandidate {\n     // A path, qualified (`std::collections::HashMap`) or not (`HashMap`).\n@@ -28,7 +30,7 @@ pub enum ImportCandidate {\n \n #[derive(Debug)]\n pub struct TraitImportCandidate {\n-    pub receiver_ty: hir::Type,\n+    pub receiver_ty: Type,\n     pub name: NameToImport,\n }\n \n@@ -62,7 +64,7 @@ impl NameToImport {\n #[derive(Debug)]\n pub struct ImportAssets {\n     import_candidate: ImportCandidate,\n-    module_with_candidate: hir::Module,\n+    module_with_candidate: Module,\n }\n \n impl ImportAssets {\n@@ -104,7 +106,7 @@ impl ImportAssets {\n \n     pub fn for_fuzzy_method_call(\n         module_with_method_call: Module,\n-        receiver_ty: hir::Type,\n+        receiver_ty: Type,\n         fuzzy_method_name: String,\n     ) -> Option<Self> {\n         Some(Self {\n@@ -184,7 +186,7 @@ impl ImportAssets {\n     fn search_for(\n         &self,\n         sema: &Semantics<RootDatabase>,\n-        prefixed: Option<hir::PrefixKind>,\n+        prefixed: Option<PrefixKind>,\n     ) -> Vec<LocatedImport> {\n         let current_crate = self.module_with_candidate.krate();\n \n@@ -223,7 +225,7 @@ impl ImportAssets {\n     fn applicable_defs(\n         &self,\n         db: &RootDatabase,\n-        prefixed: Option<hir::PrefixKind>,\n+        prefixed: Option<PrefixKind>,\n         unfiltered_defs: impl Iterator<Item = Either<ModuleDef, MacroDef>>,\n     ) -> FxHashSet<LocatedImport> {\n         let current_crate = self.module_with_candidate.krate();\n@@ -266,10 +268,10 @@ fn path_applicable_imports(\n             let (assoc_original, candidate) = match def {\n                 Either::Left(module_def) => match module_def.as_assoc_item(db) {\n                     Some(assoc_item) => match assoc_item.container(db) {\n-                        hir::AssocItemContainer::Trait(trait_) => {\n+                        AssocItemContainer::Trait(trait_) => {\n                             (Some(module_def), ItemInNs::from(ModuleDef::from(trait_)))\n                         }\n-                        hir::AssocItemContainer::Impl(impl_) => (\n+                        AssocItemContainer::Impl(impl_) => (\n                             Some(module_def),\n                             ItemInNs::from(ModuleDef::from(impl_.target_ty(db).as_adt()?)),\n                         ),\n@@ -296,6 +298,7 @@ fn path_applicable_imports(\n     };\n \n     // TODO kb need to remove turbofish from the qualifier, maybe use the segments instead?\n+    // TODO kb sorting is changed now, return back?\n     let unresolved_qualifier_string = unresolved_qualifier.to_string();\n     let unresolved_first_segment_string = unresolved_first_segment.to_string();\n \n@@ -305,38 +308,35 @@ fn path_applicable_imports(\n             candidate_path_string.contains(&unresolved_qualifier_string)\n                 && candidate_path_string.contains(&unresolved_first_segment_string)\n         })\n-        // TODO kb need to adjust the return type: I get the results rendered rather badly\n         .filter_map(|(candidate_path, (assoc_original, candidate))| {\n-            if let Some(assoc_original) = assoc_original {\n-                if item_name(db, candidate)?.to_string() == unresolved_first_segment_string {\n-                    return Some(LocatedImport::new(\n-                        candidate_path.clone(),\n-                        ItemInNs::from(assoc_original),\n-                        Some((candidate_path, candidate)),\n-                    ));\n-                }\n-            }\n+            let found_segment_resolution = item_name(db, candidate)\n+                .map(|name| name.to_string() == unresolved_first_segment_string)\n+                .unwrap_or(false);\n+            let (import_path, item_to_import) = if found_segment_resolution {\n+                (candidate_path.clone(), candidate)\n+            } else {\n+                let matching_module =\n+                    module_with_matching_name(db, &unresolved_first_segment_string, candidate)?;\n+                let module_item = ItemInNs::from(ModuleDef::from(matching_module));\n+                (import_path_locator(module_item)?, module_item)\n+            };\n \n-            let matching_module =\n-                module_with_matching_name(db, &unresolved_first_segment_string, candidate)?;\n-            let item = ItemInNs::from(ModuleDef::from(matching_module));\n-            Some(LocatedImport::new(\n-                import_path_locator(item)?,\n-                item,\n-                Some((candidate_path, candidate)),\n-            ))\n+            Some(match assoc_original {\n+                Some(assoc_original) => LocatedImport::new(\n+                    import_path.clone(),\n+                    item_to_import,\n+                    Some((import_path, ItemInNs::from(assoc_original))),\n+                ),\n+                None => LocatedImport::new(\n+                    import_path,\n+                    item_to_import,\n+                    if found_segment_resolution { None } else { Some((candidate_path, candidate)) },\n+                ),\n+            })\n         })\n         .collect()\n }\n \n-fn item_name(db: &RootDatabase, item: ItemInNs) -> Option<Name> {\n-    match item {\n-        ItemInNs::Types(module_def_id) => ModuleDef::from(module_def_id).name(db),\n-        ItemInNs::Values(module_def_id) => ModuleDef::from(module_def_id).name(db),\n-        ItemInNs::Macros(macro_def_id) => MacroDef::from(macro_def_id).name(db),\n-    }\n-}\n-\n fn item_module(db: &RootDatabase, item: ItemInNs) -> Option<Module> {\n     match item {\n         ItemInNs::Types(module_def_id) => ModuleDef::from(module_def_id).module(db),\n@@ -404,10 +404,20 @@ fn trait_applicable_items(\n                     }\n \n                     let item = ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?));\n+                    let item_path = import_path_locator(item)?;\n+\n+                    let assoc_item = assoc_to_item(assoc);\n+                    let assoc_item_path = match assoc.container(db) {\n+                        AssocItemContainer::Trait(_) => item_path.clone(),\n+                        AssocItemContainer::Impl(impl_) => import_path_locator(ItemInNs::from(\n+                            ModuleDef::from(impl_.target_ty(db).as_adt()?),\n+                        ))?,\n+                    };\n+\n                     located_imports.insert(LocatedImport::new(\n-                        import_path_locator(item)?,\n+                        item_path,\n                         item,\n-                        None,\n+                        Some((assoc_item_path, assoc_item)),\n                     ));\n                 }\n                 None::<()>\n@@ -423,10 +433,20 @@ fn trait_applicable_items(\n                 let assoc = function.as_assoc_item(db)?;\n                 if required_assoc_items.contains(&assoc) {\n                     let item = ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?));\n+                    let item_path = import_path_locator(item)?;\n+\n+                    let assoc_item = assoc_to_item(assoc);\n+                    let assoc_item_path = match assoc.container(db) {\n+                        AssocItemContainer::Trait(_) => item_path.clone(),\n+                        AssocItemContainer::Impl(impl_) => import_path_locator(ItemInNs::from(\n+                            ModuleDef::from(impl_.target_ty(db).as_adt()?),\n+                        ))?,\n+                    };\n+\n                     located_imports.insert(LocatedImport::new(\n-                        import_path_locator(item)?,\n+                        item_path,\n                         item,\n-                        None,\n+                        Some((assoc_item_path, assoc_item)),\n                     ));\n                 }\n                 None::<()>\n@@ -437,11 +457,19 @@ fn trait_applicable_items(\n     located_imports\n }\n \n+fn assoc_to_item(assoc: AssocItem) -> ItemInNs {\n+    match assoc {\n+        AssocItem::Function(f) => ItemInNs::from(ModuleDef::from(f)),\n+        AssocItem::Const(c) => ItemInNs::from(ModuleDef::from(c)),\n+        AssocItem::TypeAlias(t) => ItemInNs::from(ModuleDef::from(t)),\n+    }\n+}\n+\n fn get_mod_path(\n     db: &RootDatabase,\n     item_to_search: ItemInNs,\n     module_with_candidate: &Module,\n-    prefixed: Option<hir::PrefixKind>,\n+    prefixed: Option<PrefixKind>,\n ) -> Option<ModPath> {\n     if let Some(prefix_kind) = prefixed {\n         module_with_candidate.find_use_path_prefixed(db, item_to_search, prefix_kind)\n@@ -509,7 +537,7 @@ fn path_import_candidate(\n                     return None;\n                 }\n             }\n-            Some(hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path))) => {\n+            Some(PathResolution::Def(ModuleDef::Adt(assoc_item_path))) => {\n                 ImportCandidate::TraitAssocItem(TraitImportCandidate {\n                     receiver_ty: assoc_item_path.ty(sema.db),\n                     name,"}]}