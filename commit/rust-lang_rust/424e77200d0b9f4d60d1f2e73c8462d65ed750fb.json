{"sha": "424e77200d0b9f4d60d1f2e73c8462d65ed750fb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNGU3NzIwMGQwYjlmNGQ2MGQxZjJlNzNjODQ2MmQ2NWVkNzUwZmI=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-08-05T20:17:41Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-08-05T20:17:41Z"}, "message": "Add error code check in librustc_const_eval/diagnostics.rs", "tree": {"sha": "c0843ceeb7ff1b55c18aacdb0dfecf1841178667", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0843ceeb7ff1b55c18aacdb0dfecf1841178667"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/424e77200d0b9f4d60d1f2e73c8462d65ed750fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/424e77200d0b9f4d60d1f2e73c8462d65ed750fb", "html_url": "https://github.com/rust-lang/rust/commit/424e77200d0b9f4d60d1f2e73c8462d65ed750fb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/424e77200d0b9f4d60d1f2e73c8462d65ed750fb/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c02363852e6ce41cf2da1b43a32cb7780a9b067", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c02363852e6ce41cf2da1b43a32cb7780a9b067", "html_url": "https://github.com/rust-lang/rust/commit/4c02363852e6ce41cf2da1b43a32cb7780a9b067"}], "stats": {"total": 48, "additions": 26, "deletions": 22}, "files": [{"sha": "9cdc76f25a63f1a6b77cc446269daa3054b592f7", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 26, "deletions": 22, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/424e77200d0b9f4d60d1f2e73c8462d65ed750fb/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/424e77200d0b9f4d60d1f2e73c8462d65ed750fb/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=424e77200d0b9f4d60d1f2e73c8462d65ed750fb", "patch": "@@ -25,8 +25,8 @@ one is too specific or the ordering is incorrect.\n \n For example, the following `match` block has too many arms:\n \n-```compile_fail\n-match foo {\n+```compile_fail,E0001\n+match Some(0) {\n     Some(bar) => {/* ... */}\n     None => {/* ... */}\n     _ => {/* ... */} // All possible cases have already been handled\n@@ -108,7 +108,7 @@ one or more possible inputs to a match expression. Guaranteed matches are\n required in order to assign values to match expressions, or alternatively,\n determine the flow of execution. Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0004\n enum Terminator {\n     HastaLaVistaBaby,\n     TalkToMyHand,\n@@ -153,7 +153,7 @@ E0005: r##\"\n Patterns used to bind names must be irrefutable, that is, they must guarantee\n that a name will be extracted in all cases. Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0005\n let x = Some(1);\n let Some(y) = x;\n // error: refutable pattern in local binding: `None` not covered\n@@ -187,7 +187,7 @@ like the following is invalid as it requires the entire `Option<String>` to be\n moved into a variable called `op_string` while simultaneously requiring the\n inner `String` to be moved into a variable called `s`.\n \n-```compile_fail\n+```compile_fail,E0007\n let x = Some(\"s\".to_string());\n \n match x {\n@@ -205,7 +205,7 @@ name is bound by move in a pattern, it should also be moved to wherever it is\n referenced in the pattern guard code. Doing so however would prevent the name\n from being available in the body of the match arm. Consider the following:\n \n-```compile_fail\n+```compile_fail,E0008\n match Some(\"hi\".to_string()) {\n     Some(s) if s.len() == 0 => {}, // use s.\n     _ => {},\n@@ -229,7 +229,7 @@ match Some(\"hi\".to_string()) {\n Though this example seems innocuous and easy to solve, the problem becomes clear\n when it encounters functions which consume the value:\n \n-```compile_fail\n+```compile_fail,E0008\n struct A{}\n \n impl A {\n@@ -283,7 +283,7 @@ This limitation may be removed in a future version of Rust.\n \n Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0009\n struct X { x: (), }\n \n let x = Some((X { x: () }, X { x: () }));\n@@ -351,25 +351,25 @@ An if-let pattern attempts to match the pattern, and enters the body if the\n match was successful. If the match is irrefutable (when it cannot fail to\n match), use a regular `let`-binding instead. For instance:\n \n-```compile_fail\n+```compile_fail,E0162\n struct Irrefutable(i32);\n let irr = Irrefutable(0);\n \n // This fails to compile because the match is irrefutable.\n if let Irrefutable(x) = irr {\n     // This body will always be executed.\n-    foo(x);\n+    // ...\n }\n ```\n \n Try this instead:\n \n-```ignore\n+```\n struct Irrefutable(i32);\n let irr = Irrefutable(0);\n \n let Irrefutable(x) = irr;\n-foo(x);\n+println!(\"{}\", x);\n ```\n \"##,\n \n@@ -378,7 +378,7 @@ A while-let pattern attempts to match the pattern, and enters the body if the\n match was successful. If the match is irrefutable (when it cannot fail to\n match), use a regular `let`-binding inside a `loop` instead. For instance:\n \n-```compile_fail\n+```compile_fail,E0165\n struct Irrefutable(i32);\n let irr = Irrefutable(0);\n \n@@ -455,7 +455,7 @@ that a name will be extracted in all cases. Instead of pattern matching the\n loop variable, consider using a `match` or `if let` inside the loop body. For\n instance:\n \n-```compile_fail\n+```compile_fail,E0297\n let xs : Vec<Option<i32>> = vec!(Some(1), None);\n \n // This fails because `None` is not covered.\n@@ -497,7 +497,7 @@ on which the match depends in such a way, that the match would not be\n exhaustive. For instance, the following would not match any arm if mutable\n borrows were allowed:\n \n-```compile_fail\n+```compile_fail,E0301\n match Some(()) {\n     None => { },\n     option if option.take().is_none() => {\n@@ -515,10 +515,10 @@ on which the match depends in such a way, that the match would not be\n exhaustive. For instance, the following would not match any arm if assignments\n were allowed:\n \n-```compile_fail\n+```compile_fail,E0302\n match Some(()) {\n     None => { },\n-    option if { option = None; false } { },\n+    option if { option = None; false } => { },\n     Some(_) => { } // When the previous match failed, the option became `None`.\n }\n ```\n@@ -529,14 +529,18 @@ In certain cases it is possible for sub-bindings to violate memory safety.\n Updates to the borrow checker in a future version of Rust may remove this\n restriction, but for now patterns must be rewritten without sub-bindings.\n \n-```ignore\n-// Before.\n+Before:\n+\n+```compile_fail,E0303\n match Some(\"hi\".to_string()) {\n     ref op_string_ref @ Some(s) => {},\n     None => {},\n }\n+```\n+\n+After:\n \n-// After.\n+```\n match Some(\"hi\".to_string()) {\n     Some(ref s) => {\n         let op_string_ref = &Some(s);\n@@ -556,7 +560,7 @@ This error indicates that the compiler was unable to sensibly evaluate an\n constant expression that had to be evaluated. Attempting to divide by 0\n or causing integer overflow are two ways to induce this error. For example:\n \n-```compile_fail\n+```compile_fail,E0080\n enum Enum {\n     X = (1 << 500),\n     Y = (1 / 0)\n@@ -575,7 +579,7 @@ E0306: r##\"\n In an array literal `[x; N]`, `N` is the number of elements in the array. This\n must be an unsigned integer. Erroneous code example:\n \n-```compile_fail\n+```compile_fail,E0306\n let x = [0i32; true]; // error: expected positive integer for repeat count,\n                       //        found boolean\n ```"}]}