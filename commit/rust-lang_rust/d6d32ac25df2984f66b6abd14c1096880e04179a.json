{"sha": "d6d32ac25df2984f66b6abd14c1096880e04179a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2ZDMyYWMyNWRmMjk4NGY2NmI2YWJkMTRjMTA5Njg4MGUwNDE3OWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-04T17:01:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-04T17:01:24Z"}, "message": "Auto merge of #56723 - oli-obk:lazy_const, r=nikomatsakis\n\nDon't emit `Unevaluated` from `const_eval`\n\ncc @eddyb @RalfJung", "tree": {"sha": "ba5b87359920b6fc256feb68ef6bb700ca44537f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba5b87359920b6fc256feb68ef6bb700ca44537f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6d32ac25df2984f66b6abd14c1096880e04179a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6d32ac25df2984f66b6abd14c1096880e04179a", "html_url": "https://github.com/rust-lang/rust/commit/d6d32ac25df2984f66b6abd14c1096880e04179a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6d32ac25df2984f66b6abd14c1096880e04179a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae167c91aa9abefcd4a9697b5560330ef18e2e3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae167c91aa9abefcd4a9697b5560330ef18e2e3e", "html_url": "https://github.com/rust-lang/rust/commit/ae167c91aa9abefcd4a9697b5560330ef18e2e3e"}, {"sha": "03b892860da5aff7a10cf4ca1364dbcacb95bfcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/03b892860da5aff7a10cf4ca1364dbcacb95bfcd", "html_url": "https://github.com/rust-lang/rust/commit/03b892860da5aff7a10cf4ca1364dbcacb95bfcd"}], "stats": {"total": 1070, "additions": 486, "deletions": 584}, "files": [{"sha": "9f9ded51e37ee3fae68e952940e809f2e6d28855", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -119,6 +119,11 @@ impl<T> Default for TypedArena<T> {\n }\n \n impl<T> TypedArena<T> {\n+    pub fn in_arena(&self, ptr: *const T) -> bool {\n+        let ptr = ptr as *const T as *mut T;\n+\n+        self.chunks.borrow().iter().any(|chunk| chunk.start() <= ptr && ptr < chunk.end())\n+    }\n     /// Allocates an object in the `TypedArena`, returning a reference to it.\n     #[inline]\n     pub fn alloc(&self, object: T) -> &mut T {"}, {"sha": "57a53d3f09a2ec8691309de2759c48ea1103abae", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -301,7 +301,6 @@ impl_stable_hash_for!(struct ty::FieldDef {\n \n impl_stable_hash_for!(\n     impl<'tcx> for enum mir::interpret::ConstValue<'tcx> [ mir::interpret::ConstValue ] {\n-        Unevaluated(def_id, substs),\n         Scalar(val),\n         ScalarPair(a, b),\n         ByRef(id, alloc, offset),\n@@ -378,6 +377,11 @@ impl_stable_hash_for!(struct ty::Const<'tcx> {\n     val\n });\n \n+impl_stable_hash_for!(impl<'tcx> for enum ty::LazyConst<'tcx> [ty::LazyConst] {\n+    Unevaluated(did, substs),\n+    Evaluated(c)\n+});\n+\n impl_stable_hash_for!(enum mir::interpret::ErrorHandled {\n     Reported,\n     TooGeneric"}, {"sha": "c3fe5d773ab16e4c4d55d44e5b69b827da3d53f0", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -37,7 +37,7 @@ impl ErrorHandled {\n }\n \n pub type ConstEvalRawResult<'tcx> = Result<RawConst<'tcx>, ErrorHandled>;\n-pub type ConstEvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ErrorHandled>;\n+pub type ConstEvalResult<'tcx> = Result<ty::Const<'tcx>, ErrorHandled>;\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ConstEvalErr<'tcx> {"}, {"sha": "26a8e63254008d7de9226e0ae14f83a5f788a793", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -1,7 +1,6 @@\n use std::fmt;\n \n-use crate::ty::{Ty, subst::Substs, layout::{HasDataLayout, Size}};\n-use crate::hir::def_id::DefId;\n+use crate::ty::{Ty, layout::{HasDataLayout, Size}};\n \n use super::{EvalResult, Pointer, PointerArithmetic, Allocation, AllocId, sign_extend, truncate};\n \n@@ -18,12 +17,6 @@ pub struct RawConst<'tcx> {\n /// matches the LocalValue optimizations for easy conversions between Value and ConstValue.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n pub enum ConstValue<'tcx> {\n-    /// Never returned from the `const_eval` query, but the HIR contains these frequently in order\n-    /// to allow HIR creation to happen for everything before needing to be able to run constant\n-    /// evaluation\n-    /// FIXME: The query should then return a type that does not even have this variant.\n-    Unevaluated(DefId, &'tcx Substs<'tcx>),\n-\n     /// Used only for types with layout::abi::Scalar ABI and ZSTs\n     ///\n     /// Not using the enum `Value` to encode that this must not be `Undef`\n@@ -43,7 +36,6 @@ impl<'tcx> ConstValue<'tcx> {\n     #[inline]\n     pub fn try_to_scalar(&self) -> Option<Scalar> {\n         match *self {\n-            ConstValue::Unevaluated(..) |\n             ConstValue::ByRef(..) |\n             ConstValue::ScalarPair(..) => None,\n             ConstValue::Scalar(val) => Some(val),"}, {"sha": "a1a6e890b1292de4691455187d3226128c357283", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -1666,7 +1666,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n                             ),\n                             ty: switch_ty,\n                         };\n-                        fmt_const_val(&mut s, &c).unwrap();\n+                        fmt_const_val(&mut s, c).unwrap();\n                         s.into()\n                     }).chain(iter::once(\"otherwise\".into()))\n                     .collect()\n@@ -2154,7 +2154,9 @@ impl<'tcx> Operand<'tcx> {\n             span,\n             ty,\n             user_ty: None,\n-            literal: ty::Const::zero_sized(tcx, ty),\n+            literal: tcx.intern_lazy_const(\n+                ty::LazyConst::Evaluated(ty::Const::zero_sized(ty)),\n+            ),\n         })\n     }\n \n@@ -2457,7 +2459,7 @@ pub struct Constant<'tcx> {\n     /// Needed for NLL to impose user-given type constraints.\n     pub user_ty: Option<UserTypeAnnotationIndex>,\n \n-    pub literal: &'tcx ty::Const<'tcx>,\n+    pub literal: &'tcx ty::LazyConst<'tcx>,\n }\n \n /// A collection of projections into user types.\n@@ -2655,12 +2657,20 @@ newtype_index! {\n impl<'tcx> Debug for Constant<'tcx> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         write!(fmt, \"const \")?;\n-        fmt_const_val(fmt, self.literal)\n+        fmt_lazy_const_val(fmt, self.literal)\n+    }\n+}\n+\n+/// Write a `ConstValue` in a way closer to the original source code than the `Debug` output.\n+pub fn fmt_lazy_const_val(f: &mut impl Write, const_val: &ty::LazyConst<'_>) -> fmt::Result {\n+    match *const_val {\n+        ty::LazyConst::Unevaluated(..) => write!(f, \"{:?}\", const_val),\n+        ty::LazyConst::Evaluated(c) => fmt_const_val(f, c),\n     }\n }\n \n /// Write a `ConstValue` in a way closer to the original source code than the `Debug` output.\n-pub fn fmt_const_val(f: &mut impl Write, const_val: &ty::Const<'_>) -> fmt::Result {\n+pub fn fmt_const_val(f: &mut impl Write, const_val: ty::Const<'_>) -> fmt::Result {\n     use ty::TyKind::*;\n     let value = const_val.val;\n     let ty = const_val.ty;"}, {"sha": "a0fae3aa927ce3f5f6d72eca981e9c453a44ea41", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -233,7 +233,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_const(&mut self,\n-                           constant: & $($mutability)* &'tcx ty::Const<'tcx>,\n+                           constant: & $($mutability)* &'tcx ty::LazyConst<'tcx>,\n                            _: Location) {\n                 self.super_const(constant);\n             }\n@@ -892,7 +892,7 @@ macro_rules! make_mir_visitor {\n             fn super_region(&mut self, _region: & $($mutability)* ty::Region<'tcx>) {\n             }\n \n-            fn super_const(&mut self, _const: & $($mutability)* &'tcx ty::Const<'tcx>) {\n+            fn super_const(&mut self, _const: & $($mutability)* &'tcx ty::LazyConst<'tcx>) {\n             }\n \n             fn super_substs(&mut self, _substs: & $($mutability)* &'tcx Substs<'tcx>) {"}, {"sha": "c0f50ecd288247bfbc1a8ac6e3ebb7c07aaffbf5", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -418,9 +418,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     Some(format!(\"[{}]\", self.tcx.type_of(def.did).to_string())),\n                 ));\n                 let tcx = self.tcx;\n-                if let Some(len) = len.val.try_to_scalar().and_then(|scalar| {\n-                    scalar.to_usize(&tcx).ok()\n-                }) {\n+                if let Some(len) = len.assert_usize(tcx) {\n                     flags.push((\n                         \"_Self\".to_owned(),\n                         Some(format!(\"[{}; {}]\", self.tcx.type_of(def.did).to_string(), len)),"}, {"sha": "bec45046cb93ed7091a13a5afb718093e7ea1363", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -15,7 +15,6 @@ use super::util;\n use hir::def_id::DefId;\n use infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use infer::type_variable::TypeVariableOrigin;\n-use mir::interpret::ConstValue;\n use mir::interpret::{GlobalId};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::ast::Ident;\n@@ -394,8 +393,8 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n         }\n     }\n \n-    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n+    fn fold_const(&mut self, constant: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+        if let ty::LazyConst::Unevaluated(def_id, substs) = *constant {\n             let tcx = self.selcx.tcx().global_tcx();\n             if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n                 if substs.needs_infer() || substs.has_placeholders() {\n@@ -407,8 +406,9 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                             promoted: None\n                         };\n                         if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                            let evaluated = evaluated.subst(self.tcx(), substs);\n-                            return self.fold_const(evaluated);\n+                            let substs = tcx.lift_to_global(&substs).unwrap();\n+                            let evaluated = evaluated.subst(tcx, substs);\n+                            return tcx.intern_lazy_const(ty::LazyConst::Evaluated(evaluated));\n                         }\n                     }\n                 } else {\n@@ -420,7 +420,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n                                 promoted: None\n                             };\n                             if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return self.fold_const(evaluated)\n+                                return tcx.intern_lazy_const(ty::LazyConst::Evaluated(evaluated));\n                             }\n                         }\n                     }"}, {"sha": "be05445cfc61a47069363c562958266050ad4630", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -5,7 +5,7 @@\n use infer::at::At;\n use infer::canonical::OriginalQueryValues;\n use infer::{InferCtxt, InferOk};\n-use mir::interpret::{ConstValue, GlobalId};\n+use mir::interpret::GlobalId;\n use traits::project::Normalized;\n use traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use ty::fold::{TypeFoldable, TypeFolder};\n@@ -188,8 +188,8 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n         }\n     }\n \n-    fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n+    fn fold_const(&mut self, constant: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+        if let ty::LazyConst::Unevaluated(def_id, substs) = *constant {\n             let tcx = self.infcx.tcx.global_tcx();\n             if let Some(param_env) = self.tcx().lift_to_global(&self.param_env) {\n                 if substs.needs_infer() || substs.has_placeholders() {\n@@ -201,8 +201,9 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                             promoted: None,\n                         };\n                         if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                            let evaluated = evaluated.subst(self.tcx(), substs);\n-                            return self.fold_const(evaluated);\n+                            let substs = tcx.lift_to_global(&substs).unwrap();\n+                            let evaluated = evaluated.subst(tcx, substs);\n+                            return tcx.intern_lazy_const(ty::LazyConst::Evaluated(evaluated));\n                         }\n                     }\n                 } else {\n@@ -214,7 +215,7 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for QueryNormalizer<'cx, 'gcx, 'tcx\n                                 promoted: None,\n                             };\n                             if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return self.fold_const(evaluated)\n+                                return tcx.intern_lazy_const(ty::LazyConst::Evaluated(evaluated));\n                             }\n                         }\n                     }"}, {"sha": "e0e4d9c362a6ca0c1cc3690b357bad71851572ce", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -247,12 +247,12 @@ pub fn decode_canonical_var_infos<'a, 'tcx, D>(decoder: &mut D)\n }\n \n #[inline]\n-pub fn decode_const<'a, 'tcx, D>(decoder: &mut D)\n-                                 -> Result<&'tcx ty::Const<'tcx>, D::Error>\n+pub fn decode_lazy_const<'a, 'tcx, D>(decoder: &mut D)\n+                                 -> Result<&'tcx ty::LazyConst<'tcx>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n {\n-    Ok(decoder.tcx().mk_const(Decodable::decode(decoder)?))\n+    Ok(decoder.tcx().intern_lazy_const(Decodable::decode(decoder)?))\n }\n \n #[inline]\n@@ -389,10 +389,10 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n-            impl<$($typaram),*> SpecializedDecoder<&'tcx $crate::ty::Const<'tcx>>\n+            impl<$($typaram),*> SpecializedDecoder<&'tcx $crate::ty::LazyConst<'tcx>>\n             for $DecoderName<$($typaram),*> {\n-                fn specialized_decode(&mut self) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n-                    decode_const(self)\n+                fn specialized_decode(&mut self) -> Result<&'tcx ty::LazyConst<'tcx>, Self::Error> {\n+                    decode_lazy_const(self)\n                 }\n             }\n "}, {"sha": "6c377941dad1966526bbeb794e22aa189ecf363a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 60, "deletions": 232, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -29,7 +29,7 @@ use traits;\n use traits::{Clause, Clauses, GoalKind, Goal, Goals};\n use ty::{self, Ty, TypeAndMut};\n use ty::{TyS, TyKind, List};\n-use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorSubsts, Region, Const};\n+use ty::{AdtKind, AdtDef, ClosureSubsts, GeneratorSubsts, Region, Const, LazyConst};\n use ty::{PolyFnSig, InferTy, ParamTy, ProjectionTy, ExistentialPredicate, Predicate};\n use ty::RegionKind;\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n@@ -122,7 +122,6 @@ pub struct CtxtInterners<'tcx> {\n     region: InternedSet<'tcx, RegionKind>,\n     existential_predicates: InternedSet<'tcx, List<ExistentialPredicate<'tcx>>>,\n     predicates: InternedSet<'tcx, List<Predicate<'tcx>>>,\n-    const_: InternedSet<'tcx, Const<'tcx>>,\n     clauses: InternedSet<'tcx, List<Clause<'tcx>>>,\n     goal: InternedSet<'tcx, GoalKind<'tcx>>,\n     goal_list: InternedSet<'tcx, List<Goal<'tcx>>>,\n@@ -140,7 +139,6 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             existential_predicates: Default::default(),\n             canonical_var_infos: Default::default(),\n             predicates: Default::default(),\n-            const_: Default::default(),\n             clauses: Default::default(),\n             goal: Default::default(),\n             goal_list: Default::default(),\n@@ -1063,32 +1061,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_arenas.adt_def.alloc(def)\n     }\n \n-    pub fn alloc_byte_array(self, bytes: &[u8]) -> &'gcx [u8] {\n-        if bytes.is_empty() {\n-            &[]\n-        } else {\n-            self.global_interners.arena.alloc_slice(bytes)\n-        }\n-    }\n-\n-    pub fn alloc_const_slice(self, values: &[&'tcx ty::Const<'tcx>])\n-                             -> &'tcx [&'tcx ty::Const<'tcx>] {\n-        if values.is_empty() {\n-            &[]\n-        } else {\n-            self.interners.arena.alloc_slice(values)\n-        }\n-    }\n-\n-    pub fn alloc_name_const_slice(self, values: &[(ast::Name, &'tcx ty::Const<'tcx>)])\n-                                  -> &'tcx [(ast::Name, &'tcx ty::Const<'tcx>)] {\n-        if values.is_empty() {\n-            &[]\n-        } else {\n-            self.interners.arena.alloc_slice(values)\n-        }\n-    }\n-\n     pub fn intern_const_alloc(\n         self,\n         alloc: Allocation,\n@@ -1112,6 +1084,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n+    pub fn intern_lazy_const(self, c: ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n+        self.global_interners.arena.alloc(c)\n+    }\n+\n     pub fn intern_layout(self, layout: LayoutDetails) -> &'gcx LayoutDetails {\n         self.layout_interner.borrow_mut().intern(layout, |layout| {\n             self.global_arenas.layout.alloc(layout)\n@@ -1725,218 +1701,69 @@ pub trait Lift<'tcx>: fmt::Debug {\n     fn lift_to_tcx<'a, 'gcx>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Self::Lifted>;\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for Ty<'a> {\n-    type Lifted = Ty<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Ty<'tcx>> {\n-        if tcx.interners.arena.in_arena(*self as *const _) {\n-            return Some(unsafe { mem::transmute(*self) });\n-        }\n-        // Also try in the global tcx if we're not that.\n-        if !tcx.is_global() {\n-            self.lift_to_tcx(tcx.global_tcx())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for Region<'a> {\n-    type Lifted = Region<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Region<'tcx>> {\n-        if tcx.interners.arena.in_arena(*self as *const _) {\n-            return Some(unsafe { mem::transmute(*self) });\n-        }\n-        // Also try in the global tcx if we're not that.\n-        if !tcx.is_global() {\n-            self.lift_to_tcx(tcx.global_tcx())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for Goal<'a> {\n-    type Lifted = Goal<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Goal<'tcx>> {\n-        if tcx.interners.arena.in_arena(*self as *const _) {\n-            return Some(unsafe { mem::transmute(*self) });\n-        }\n-        // Also try in the global tcx if we're not that.\n-        if !tcx.is_global() {\n-            self.lift_to_tcx(tcx.global_tcx())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for &'a List<Goal<'a>> {\n-    type Lifted = &'tcx List<Goal<'tcx>>;\n-    fn lift_to_tcx<'b, 'gcx>(\n-        &self,\n-        tcx: TyCtxt<'b, 'gcx, 'tcx>,\n-    ) -> Option<&'tcx List<Goal<'tcx>>> {\n-        if self.is_empty() {\n-            return Some(List::empty());\n-        }\n-\n-        if tcx.interners.arena.in_arena(*self as *const _) {\n-            return Some(unsafe { mem::transmute(*self) });\n-        }\n-        // Also try in the global tcx if we're not that.\n-        if !tcx.is_global() {\n-            self.lift_to_tcx(tcx.global_tcx())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for &'a List<Clause<'a>> {\n-    type Lifted = &'tcx List<Clause<'tcx>>;\n-    fn lift_to_tcx<'b, 'gcx>(\n-        &self,\n-        tcx: TyCtxt<'b, 'gcx, 'tcx>,\n-    ) -> Option<&'tcx List<Clause<'tcx>>> {\n-        if self.is_empty() {\n-            return Some(List::empty());\n-        }\n-\n-        if tcx.interners.arena.in_arena(*self as *const _) {\n-            return Some(unsafe { mem::transmute(*self) });\n-        }\n-        // Also try in the global tcx if we're not that.\n-        if !tcx.is_global() {\n-            self.lift_to_tcx(tcx.global_tcx())\n-        } else {\n-            None\n-        }\n-    }\n-}\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Const<'a> {\n-    type Lifted = &'tcx Const<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Const<'tcx>> {\n-        if tcx.interners.arena.in_arena(*self as *const _) {\n-            return Some(unsafe { mem::transmute(*self) });\n-        }\n-        // Also try in the global tcx if we're not that.\n-        if !tcx.is_global() {\n-            self.lift_to_tcx(tcx.global_tcx())\n-        } else {\n-            None\n+macro_rules! nop_lift {\n+    ($ty:ty => $lifted:ty) => {\n+        impl<'a, 'tcx> Lift<'tcx> for $ty {\n+            type Lifted = $lifted;\n+            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+                if tcx.interners.arena.in_arena(*self as *const _) {\n+                    return Some(unsafe { mem::transmute(*self) });\n+                }\n+                // Also try in the global tcx if we're not that.\n+                if !tcx.is_global() {\n+                    self.lift_to_tcx(tcx.global_tcx())\n+                } else {\n+                    None\n+                }\n+            }\n         }\n-    }\n+    };\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a Substs<'a> {\n-    type Lifted = &'tcx Substs<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<&'tcx Substs<'tcx>> {\n-        if self.len() == 0 {\n-            return Some(List::empty());\n-        }\n-        if tcx.interners.arena.in_arena(&self[..] as *const _) {\n-            return Some(unsafe { mem::transmute(*self) });\n-        }\n-        // Also try in the global tcx if we're not that.\n-        if !tcx.is_global() {\n-            self.lift_to_tcx(tcx.global_tcx())\n-        } else {\n-            None\n+macro_rules! nop_list_lift {\n+    ($ty:ty => $lifted:ty) => {\n+        impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {\n+            type Lifted = &'tcx List<$lifted>;\n+            fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+                        if self.is_empty() {\n+                    return Some(List::empty());\n+                }\n+                if tcx.interners.arena.in_arena(*self as *const _) {\n+                    return Some(unsafe { mem::transmute(*self) });\n+                }\n+                // Also try in the global tcx if we're not that.\n+                if !tcx.is_global() {\n+                    self.lift_to_tcx(tcx.global_tcx())\n+                } else {\n+                    None\n+                }\n+            }\n         }\n-    }\n+    };\n }\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a List<Ty<'a>> {\n-    type Lifted = &'tcx List<Ty<'tcx>>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-                             -> Option<&'tcx List<Ty<'tcx>>> {\n-        if self.len() == 0 {\n-            return Some(List::empty());\n-        }\n-        if tcx.interners.arena.in_arena(*self as *const _) {\n-            return Some(unsafe { mem::transmute(*self) });\n-        }\n-        // Also try in the global tcx if we're not that.\n-        if !tcx.is_global() {\n-            self.lift_to_tcx(tcx.global_tcx())\n-        } else {\n-            None\n-        }\n-    }\n-}\n+nop_lift!{Ty<'a> => Ty<'tcx>}\n+nop_lift!{Region<'a> => Region<'tcx>}\n+nop_lift!{Goal<'a> => Goal<'tcx>}\n+nop_lift!{&'a LazyConst<'a> => &'tcx LazyConst<'tcx>}\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a List<ExistentialPredicate<'a>> {\n-    type Lifted = &'tcx List<ExistentialPredicate<'tcx>>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-        -> Option<&'tcx List<ExistentialPredicate<'tcx>>> {\n-        if self.is_empty() {\n-            return Some(List::empty());\n-        }\n-        if tcx.interners.arena.in_arena(*self as *const _) {\n-            return Some(unsafe { mem::transmute(*self) });\n-        }\n-        // Also try in the global tcx if we're not that.\n-        if !tcx.is_global() {\n-            self.lift_to_tcx(tcx.global_tcx())\n-        } else {\n-            None\n-        }\n-    }\n-}\n+nop_list_lift!{Goal<'a> => Goal<'tcx>}\n+nop_list_lift!{Clause<'a> => Clause<'tcx>}\n+nop_list_lift!{Ty<'a> => Ty<'tcx>}\n+nop_list_lift!{ExistentialPredicate<'a> => ExistentialPredicate<'tcx>}\n+nop_list_lift!{Predicate<'a> => Predicate<'tcx>}\n+nop_list_lift!{CanonicalVarInfo => CanonicalVarInfo}\n+nop_list_lift!{ProjectionKind<'a> => ProjectionKind<'tcx>}\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a List<Predicate<'a>> {\n-    type Lifted = &'tcx List<Predicate<'tcx>>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n-        -> Option<&'tcx List<Predicate<'tcx>>> {\n-        if self.is_empty() {\n-            return Some(List::empty());\n-        }\n-        if tcx.interners.arena.in_arena(*self as *const _) {\n-            return Some(unsafe { mem::transmute(*self) });\n-        }\n-        // Also try in the global tcx if we're not that.\n-        if !tcx.is_global() {\n-            self.lift_to_tcx(tcx.global_tcx())\n-        } else {\n-            None\n-        }\n-    }\n-}\n+// this is the impl for `&'a Substs<'a>`\n+nop_list_lift!{Kind<'a> => Kind<'tcx>}\n \n-impl<'a, 'tcx> Lift<'tcx> for &'a List<CanonicalVarInfo> {\n-    type Lifted = &'tcx List<CanonicalVarInfo>;\n+impl<'a, 'tcx> Lift<'tcx> for &'a mir::interpret::Allocation {\n+    type Lifted = &'tcx mir::interpret::Allocation;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        if self.len() == 0 {\n-            return Some(List::empty());\n-        }\n-        if tcx.interners.arena.in_arena(*self as *const _) {\n-            return Some(unsafe { mem::transmute(*self) });\n-        }\n-        // Also try in the global tcx if we're not that.\n-        if !tcx.is_global() {\n-            self.lift_to_tcx(tcx.global_tcx())\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for &'a List<ProjectionKind<'a>> {\n-    type Lifted = &'tcx List<ProjectionKind<'tcx>>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        if self.len() == 0 {\n-            return Some(List::empty());\n-        }\n-        if tcx.interners.arena.in_arena(*self as *const _) {\n-            return Some(unsafe { mem::transmute(*self) });\n-        }\n-        // Also try in the global tcx if we're not that.\n-        if !tcx.is_global() {\n-            self.lift_to_tcx(tcx.global_tcx())\n-        } else {\n-            None\n-        }\n+        assert!(tcx.global_arenas.const_allocs.in_arena(*self as *const _));\n+        Some(unsafe { mem::transmute(*self) })\n     }\n }\n \n@@ -2497,7 +2324,6 @@ pub fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n \n direct_interners!('tcx,\n     region: mk_region(|r: &RegionKind| r.keep_in_local_tcx()) -> RegionKind,\n-    const_: mk_const(|c: &Const<'_>| keep_local(&c.ty) || keep_local(&c.val)) -> Const<'tcx>,\n     goal: mk_goal(|c: &GoalKind<'_>| keep_local(c)) -> GoalKind<'tcx>\n );\n \n@@ -2683,7 +2509,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     #[inline]\n     pub fn mk_array(self, ty: Ty<'tcx>, n: u64) -> Ty<'tcx> {\n-        self.mk_ty(Array(ty, ty::Const::from_usize(self, n)))\n+        self.mk_ty(Array(ty, self.intern_lazy_const(\n+            ty::LazyConst::Evaluated(ty::Const::from_usize(self.global_tcx(), n))\n+        )))\n     }\n \n     #[inline]"}, {"sha": "0d6d9f91eb4e47af44c8182faa40e50f20518357", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -157,11 +157,12 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n \n             ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.item_path_str(def.did)).into(),\n             ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.item_path_str(def_id)).into(),\n-            ty::Array(_, n) => {\n-                match n.assert_usize(tcx) {\n+            ty::Array(_, n) => match n {\n+                ty::LazyConst::Evaluated(n) => match n.assert_usize(tcx) {\n                     Some(n) => format!(\"array of {} elements\", n).into(),\n                     None => \"array\".into(),\n-                }\n+                },\n+                ty::LazyConst::Unevaluated(..) => \"array\".into(),\n             }\n             ty::Slice(_) => \"slice\".into(),\n             ty::RawPtr(_) => \"*-ptr\".into(),"}, {"sha": "4fa13a01d5a927d77a8ac6884a97e8700b2f57ac", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -1,4 +1,3 @@\n-use mir::interpret::ConstValue;\n use ty::subst::Substs;\n use ty::{self, Ty, TypeFlags, TypeFoldable};\n \n@@ -173,7 +172,10 @@ impl FlagComputation {\n \n             &ty::Array(tt, len) => {\n                 self.add_ty(tt);\n-                self.add_const(len);\n+                if let ty::LazyConst::Unevaluated(_, substs) = len {\n+                    self.add_flags(TypeFlags::HAS_PROJECTION);\n+                    self.add_substs(substs);\n+                }\n             }\n \n             &ty::Slice(tt) => {\n@@ -230,14 +232,6 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_const(&mut self, constant: &ty::Const<'_>) {\n-        self.add_ty(constant.ty);\n-        if let ConstValue::Unevaluated(_, substs) = constant.val {\n-            self.add_flags(TypeFlags::HAS_PROJECTION);\n-            self.add_substs(substs);\n-        }\n-    }\n-\n     fn add_existential_projection(&mut self, projection: &ty::ExistentialProjection<'_>) {\n         self.add_substs(projection.substs);\n         self.add_ty(projection.ty);"}, {"sha": "4495e9654c984d6df19f3e713976975ae30f567c", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -29,7 +29,6 @@\n //! These methods return true to indicate that the visitor has found what it is looking for\n //! and does not need to visit anything else.\n \n-use mir::interpret::ConstValue;\n use hir::def_id::DefId;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n \n@@ -164,7 +163,7 @@ pub trait TypeFolder<'gcx: 'tcx, 'tcx> : Sized {\n         r.super_fold_with(self)\n     }\n \n-    fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n+    fn fold_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> &'tcx ty::LazyConst<'tcx> {\n         c.super_fold_with(self)\n     }\n }\n@@ -182,7 +181,7 @@ pub trait TypeVisitor<'tcx> : Sized {\n         r.super_visit_with(self)\n     }\n \n-    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n+    fn visit_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> bool {\n         c.super_visit_with(self)\n     }\n }\n@@ -864,8 +863,8 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         flags.intersects(self.flags)\n     }\n \n-    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n-        if let ConstValue::Unevaluated(..) = c.val {\n+    fn visit_const(&mut self, c: &'tcx ty::LazyConst<'tcx>) -> bool {\n+        if let ty::LazyConst::Unevaluated(..) = c {\n             let projection_flags = TypeFlags::HAS_NORMALIZABLE_PROJECTION |\n                 TypeFlags::HAS_PROJECTION;\n             if projection_flags.intersects(self.flags) {"}, {"sha": "6dfc9681cfd864eceac0ed00877a922e1990abdd", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -1,6 +1,6 @@\n use ty::context::TyCtxt;\n use ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n-use ty::{DefId, Substs};\n+use ty::{self, DefId, Substs};\n use ty::{AdtKind, Visibility};\n use ty::TyKind::*;\n \n@@ -213,11 +213,14 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             }\n \n             Array(ty, len) => {\n-                match len.assert_usize(tcx) {\n-                    // If the array is definitely non-empty, it's uninhabited if\n-                    // the type of its elements is uninhabited.\n-                    Some(n) if n != 0 => ty.uninhabited_from(tcx),\n-                    _ => DefIdForest::empty()\n+                match len {\n+                    ty::LazyConst::Unevaluated(..) => DefIdForest::empty(),\n+                    ty::LazyConst::Evaluated(len) => match len.assert_usize(tcx) {\n+                        // If the array is definitely non-empty, it's uninhabited if\n+                        // the type of its elements is uninhabited.\n+                        Some(n) if n != 0 => ty.uninhabited_from(tcx),\n+                        _ => DefIdForest::empty()\n+                    },\n                 }\n             }\n "}, {"sha": "20167bd41fb871a9b6539d478e9e2b03efe73674", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -59,7 +59,7 @@ pub use self::sty::{InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n pub use self::sty::{ClosureSubsts, GeneratorSubsts, UpvarSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TyKind, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n-pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const};\n+pub use self::sty::{ExistentialProjection, PolyExistentialProjection, Const, LazyConst};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid};"}, {"sha": "af6f5a00dee5c914d3a269001525db7a2cc0302e", "filename": "src/librustc/ty/query/keys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fkeys.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -136,7 +136,7 @@ impl<'tcx> Key for ty::PolyTraitRef<'tcx>{\n     }\n }\n \n-impl<'tcx> Key for &'tcx ty::Const<'tcx> {\n+impl<'tcx> Key for ty::Const<'tcx> {\n     fn query_crate(&self) -> CrateNum {\n         LOCAL_CRATE\n     }"}, {"sha": "6d310a9500a620bea1477d73a685e63f96fc5443", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -5,7 +5,6 @@\n //! subtyping, type equality, etc.\n \n use hir::def_id::DefId;\n-use mir::interpret::ConstValue;\n use ty::subst::{Kind, UnpackedKind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::error::{ExpectedFound, TypeError};\n@@ -480,14 +479,9 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         (&ty::Array(a_t, sz_a), &ty::Array(b_t, sz_b)) =>\n         {\n             let t = relation.relate(&a_t, &b_t)?;\n-            assert_eq!(sz_a.ty, tcx.types.usize);\n-            assert_eq!(sz_b.ty, tcx.types.usize);\n-            let to_u64 = |x: &'tcx ty::Const<'tcx>| -> Result<u64, ErrorReported> {\n-                if let Some(s) = x.assert_usize(tcx) {\n-                    return Ok(s);\n-                }\n-                match x.val {\n-                    ConstValue::Unevaluated(def_id, substs) => {\n+            let to_u64 = |x: ty::LazyConst<'tcx>| -> Result<u64, ErrorReported> {\n+                match x {\n+                    ty::LazyConst::Unevaluated(def_id, substs) => {\n                         // FIXME(eddyb) get the right param_env.\n                         let param_env = ty::ParamEnv::empty();\n                         if let Some(substs) = tcx.lift_to_global(&substs) {\n@@ -513,14 +507,14 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n                             \"array length could not be evaluated\");\n                         Err(ErrorReported)\n                     }\n-                    _ => {\n+                    ty::LazyConst::Evaluated(c) => c.assert_usize(tcx).ok_or_else(|| {\n                         tcx.sess.delay_span_bug(DUMMY_SP,\n-                            &format!(\"arrays should not have {:?} as length\", x));\n-                        Err(ErrorReported)\n-                    }\n+                            \"array length could not be evaluated\");\n+                        ErrorReported\n+                    })\n                 }\n             };\n-            match (to_u64(sz_a), to_u64(sz_b)) {\n+            match (to_u64(*sz_a), to_u64(*sz_b)) {\n                 (Ok(sz_a_u64), Ok(sz_b_u64)) => {\n                     if sz_a_u64 == sz_b_u64 {\n                         Ok(tcx.mk_ty(ty::Array(t, sz_a)))"}, {"sha": "258470bf6f86002f13d92cfa8cb3766a4790470c", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 48, "deletions": 21, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -486,6 +486,26 @@ BraceStructLiftImpl! {\n     }\n }\n \n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for ty::Const<'a> {\n+        type Lifted = ty::Const<'tcx>;\n+        val, ty\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ConstValue<'a> {\n+    type Lifted = ConstValue<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            ConstValue::Scalar(x) => Some(ConstValue::Scalar(x)),\n+            ConstValue::ScalarPair(x, y) => Some(ConstValue::ScalarPair(x, y)),\n+            ConstValue::ByRef(x, alloc, z) => Some(ConstValue::ByRef(\n+                x, alloc.lift_to_tcx(tcx)?, z,\n+            )),\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n //\n@@ -1014,47 +1034,54 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::LazyConst<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            ConstValue::Scalar(v) => ConstValue::Scalar(v),\n-            ConstValue::ScalarPair(a, b) => ConstValue::ScalarPair(a, b),\n-            ConstValue::ByRef(id, alloc, offset) => ConstValue::ByRef(id, alloc, offset),\n-            ConstValue::Unevaluated(def_id, substs) => {\n-                ConstValue::Unevaluated(def_id, substs.fold_with(folder))\n+        let new = match self {\n+            ty::LazyConst::Evaluated(v) => ty::LazyConst::Evaluated(v.fold_with(folder)),\n+            ty::LazyConst::Unevaluated(def_id, substs) => {\n+                ty::LazyConst::Unevaluated(*def_id, substs.fold_with(folder))\n             }\n-        }\n+        };\n+        folder.tcx().intern_lazy_const(new)\n+    }\n+\n+    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        folder.fold_const(*self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match *self {\n-            ConstValue::Scalar(_) |\n-            ConstValue::ScalarPair(_, _) |\n-            ConstValue::ByRef(_, _, _) => false,\n-            ConstValue::Unevaluated(_, substs) => substs.visit_with(visitor),\n+            ty::LazyConst::Evaluated(c) => c.visit_with(visitor),\n+            ty::LazyConst::Unevaluated(_, substs) => substs.visit_with(visitor),\n         }\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        visitor.visit_const(self)\n+    }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for ty::Const<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let ty = self.ty.fold_with(folder);\n         let val = self.val.fold_with(folder);\n-        folder.tcx().mk_const(ty::Const {\n+        ty::Const {\n             ty,\n             val\n-        })\n-    }\n-\n-    fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_const(*self)\n+        }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.ty.visit_with(visitor) || self.val.visit_with(visitor)\n     }\n+}\n \n-    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        visitor.visit_const(self)\n+impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n+        *self\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n+        false\n     }\n }"}, {"sha": "ebaf6a73e34d4b2ba3ef78ecf3e602544d95a946", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -113,7 +113,7 @@ pub enum TyKind<'tcx> {\n     Str,\n \n     /// An array with the given length. Written as `[T; n]`.\n-    Array(Ty<'tcx>, &'tcx ty::Const<'tcx>),\n+    Array(Ty<'tcx>, &'tcx ty::LazyConst<'tcx>),\n \n     /// The pointee of an array slice.  Written as `[T]`.\n     Slice(Ty<'tcx>),\n@@ -2020,6 +2020,32 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq, Ord, PartialOrd)]\n+/// Used in the HIR by using `Unevaluated` everywhere and later normalizing to `Evaluated` if the\n+/// code is monomorphic enough for that.\n+pub enum LazyConst<'tcx> {\n+    Unevaluated(DefId, &'tcx Substs<'tcx>),\n+    Evaluated(Const<'tcx>),\n+}\n+\n+impl<'tcx> LazyConst<'tcx> {\n+    pub fn map_evaluated<R>(self, f: impl FnOnce(Const<'tcx>) -> Option<R>) -> Option<R> {\n+        match self {\n+            LazyConst::Evaluated(c) => f(c),\n+            LazyConst::Unevaluated(..) => None,\n+        }\n+    }\n+\n+    pub fn assert_usize(self, tcx: TyCtxt<'_, '_, '_>) -> Option<u64> {\n+        self.map_evaluated(|c| c.assert_usize(tcx))\n+    }\n+\n+    #[inline]\n+    pub fn unwrap_usize(&self, tcx: TyCtxt<'_, '_, '_>) -> u64 {\n+        self.assert_usize(tcx).expect(\"expected `LazyConst` to contain a usize\")\n+    }\n+}\n+\n /// Typed constant value.\n #[derive(Copy, Clone, Debug, Hash, RustcEncodable, RustcDecodable, Eq, PartialEq, Ord, PartialOrd)]\n pub struct Const<'tcx> {\n@@ -2029,67 +2055,45 @@ pub struct Const<'tcx> {\n }\n \n impl<'tcx> Const<'tcx> {\n-    pub fn unevaluated(\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        def_id: DefId,\n-        substs: &'tcx Substs<'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> &'tcx Self {\n-        tcx.mk_const(Const {\n-            val: ConstValue::Unevaluated(def_id, substs),\n-            ty,\n-        })\n-    }\n-\n-    #[inline]\n-    pub fn from_const_value(\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n-        val: ConstValue<'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> &'tcx Self {\n-        tcx.mk_const(Const {\n-            val,\n-            ty,\n-        })\n-    }\n-\n     #[inline]\n     pub fn from_scalar(\n-        tcx: TyCtxt<'_, '_, 'tcx>,\n         val: Scalar,\n         ty: Ty<'tcx>,\n-    ) -> &'tcx Self {\n-        Self::from_const_value(tcx, ConstValue::Scalar(val), ty)\n+    ) -> Self {\n+        Self {\n+            val: ConstValue::Scalar(val),\n+            ty,\n+        }\n     }\n \n     #[inline]\n     pub fn from_bits(\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         bits: u128,\n         ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n-    ) -> &'tcx Self {\n+    ) -> Self {\n         let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).unwrap_or_else(|e| {\n             panic!(\"could not compute layout for {:?}: {:?}\", ty, e)\n         }).size;\n         let shift = 128 - size.bits();\n         let truncated = (bits << shift) >> shift;\n         assert_eq!(truncated, bits, \"from_bits called with untruncated value\");\n-        Self::from_scalar(tcx, Scalar::Bits { bits, size: size.bytes() as u8 }, ty.value)\n+        Self::from_scalar(Scalar::Bits { bits, size: size.bytes() as u8 }, ty.value)\n     }\n \n     #[inline]\n-    pub fn zero_sized(tcx: TyCtxt<'_, '_, 'tcx>, ty: Ty<'tcx>) -> &'tcx Self {\n-        Self::from_scalar(tcx, Scalar::Bits { bits: 0, size: 0 }, ty)\n+    pub fn zero_sized(ty: Ty<'tcx>) -> Self {\n+        Self::from_scalar(Scalar::Bits { bits: 0, size: 0 }, ty)\n     }\n \n     #[inline]\n-    pub fn from_bool(tcx: TyCtxt<'_, '_, 'tcx>, v: bool) -> &'tcx Self {\n+    pub fn from_bool(tcx: TyCtxt<'_, '_, 'tcx>, v: bool) -> Self {\n         Self::from_bits(tcx, v as u128, ParamEnv::empty().and(tcx.types.bool))\n     }\n \n     #[inline]\n-    pub fn from_usize(tcx: TyCtxt<'_, '_, 'tcx>, n: u64) -> &'tcx Self {\n+    pub fn from_usize(tcx: TyCtxt<'_, '_, 'tcx>, n: u64) -> Self {\n         Self::from_bits(tcx, n as u128, ParamEnv::empty().and(tcx.types.usize))\n     }\n \n@@ -2155,4 +2159,4 @@ impl<'tcx> Const<'tcx> {\n     }\n }\n \n-impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Const<'tcx> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx LazyConst<'tcx> {}"}, {"sha": "6887d092fcd6208a2700595d9002268de2d1dcb3", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -1,7 +1,6 @@\n //! An iterator over the type substructure.\n //! WARNING: this does not keep track of the region depth.\n \n-use mir::interpret::ConstValue;\n use ty::{self, Ty};\n use smallvec::{self, SmallVec};\n \n@@ -75,7 +74,9 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         ty::Placeholder(..) | ty::Bound(..) | ty::Foreign(..) => {\n         }\n         ty::Array(ty, len) => {\n-            push_const(stack, len);\n+            if let ty::LazyConst::Unevaluated(_, substs) = len {\n+                stack.extend(substs.types().rev());\n+            }\n             stack.push(ty);\n         }\n         ty::Slice(ty) => {\n@@ -128,10 +129,3 @@ fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n         }\n     }\n }\n-\n-fn push_const<'tcx>(stack: &mut TypeWalkerStack<'tcx>, constant: &'tcx ty::Const<'tcx>) {\n-    if let ConstValue::Unevaluated(_, substs) = constant.val {\n-        stack.extend(substs.types().rev());\n-    }\n-    stack.push(constant.ty);\n-}"}, {"sha": "517cfd9edfaf9fbeac50d7fca0e6b67f52a06e89", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -1,5 +1,4 @@\n use hir::def_id::DefId;\n-use mir::interpret::ConstValue;\n use infer::InferCtxt;\n use ty::subst::Substs;\n use traits;\n@@ -202,11 +201,10 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Pushes the obligations required for a constant value to be WF\n+    /// Pushes the obligations required for an array length to be WF\n     /// into `self.out`.\n-    fn compute_const(&mut self, constant: &'tcx ty::Const<'tcx>) {\n-        self.require_sized(constant.ty, traits::ConstSized);\n-        if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n+    fn compute_array_len(&mut self, constant: ty::LazyConst<'tcx>) {\n+        if let ty::LazyConst::Unevaluated(def_id, substs) = constant {\n             let obligations = self.nominal_obligations(def_id, substs);\n             self.out.extend(obligations);\n \n@@ -260,8 +258,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n                 ty::Array(subty, len) => {\n                     self.require_sized(subty, traits::SliceOrArrayElem);\n-                    assert_eq!(len.ty, self.infcx.tcx.types.usize);\n-                    self.compute_const(len);\n+                    self.compute_array_len(*len);\n                 }\n \n                 ty::Tuple(ref tys) => {"}, {"sha": "37bc9397d904bf9a69b39a5c7dea01948ad38348", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -1,6 +1,5 @@\n use hir::def_id::DefId;\n use hir::map::definitions::DefPathData;\n-use mir::interpret::ConstValue;\n use middle::region;\n use ty::subst::{self, Subst};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n@@ -1412,12 +1411,12 @@ define_print! {\n                 }),\n                 Array(ty, sz) => {\n                     print!(f, cx, write(\"[\"), print(ty), write(\"; \"))?;\n-                    match sz.val {\n-                        ConstValue::Unevaluated(_def_id, _substs) => {\n+                    match sz {\n+                        ty::LazyConst::Unevaluated(_def_id, _substs) => {\n                             write!(f, \"_\")?;\n                         }\n-                        _ => ty::tls::with(|tcx| {\n-                            write!(f, \"{}\", sz.unwrap_usize(tcx))\n+                        ty::LazyConst::Evaluated(c) => ty::tls::with(|tcx| {\n+                            write!(f, \"{}\", c.unwrap_usize(tcx))\n                         })?,\n                     }\n                     write!(f, \"]\")"}, {"sha": "e6d6ef1d7a38b35aebb87984e7b6410381eefe14", "filename": "src/librustc_codegen_ssa/mir/constant.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fconstant.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -2,7 +2,7 @@ use rustc::mir::interpret::ErrorHandled;\n use rustc_mir::const_eval::const_field;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::mir::interpret::{GlobalId, ConstValue};\n+use rustc::mir::interpret::GlobalId;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout;\n use syntax::source_map::Span;\n@@ -14,10 +14,10 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     fn fully_evaluate(\n         &mut self,\n         bx: &Bx,\n-        constant: &'tcx ty::Const<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, ErrorHandled> {\n-        match constant.val {\n-            ConstValue::Unevaluated(def_id, ref substs) => {\n+        constant: &'tcx ty::LazyConst<'tcx>,\n+    ) -> Result<ty::Const<'tcx>, ErrorHandled> {\n+        match *constant {\n+            ty::LazyConst::Unevaluated(def_id, ref substs) => {\n                 let tcx = bx.tcx();\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let instance = ty::Instance::resolve(tcx, param_env, def_id, substs).unwrap();\n@@ -27,15 +27,15 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 };\n                 tcx.const_eval(param_env.and(cid))\n             },\n-            _ => Ok(constant),\n+            ty::LazyConst::Evaluated(constant) => Ok(constant),\n         }\n     }\n \n     pub fn eval_mir_constant(\n         &mut self,\n         bx: &Bx,\n         constant: &mir::Constant<'tcx>,\n-    ) -> Result<&'tcx ty::Const<'tcx>, ErrorHandled> {\n+    ) -> Result<ty::Const<'tcx>, ErrorHandled> {\n         let c = self.monomorphize(&constant.literal);\n         self.fully_evaluate(bx, c)\n     }\n@@ -46,7 +46,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx: &Bx,\n         span: Span,\n         ty: Ty<'tcx>,\n-        constant: Result<&'tcx ty::Const<'tcx>, ErrorHandled>,\n+        constant: Result<ty::Const<'tcx>, ErrorHandled>,\n     ) -> (Bx::Value, Ty<'tcx>) {\n         constant\n             .and_then(|c| {"}, {"sha": "2026e042ef0eb652b8a9992848e2a021822fb538", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n \n     pub fn from_const<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         bx: &mut Bx,\n-        val: &'tcx ty::Const<'tcx>\n+        val: ty::Const<'tcx>\n     ) -> Result<Self, ErrorHandled> {\n         let layout = bx.cx().layout_of(val.ty);\n \n@@ -76,7 +76,6 @@ impl<'a, 'tcx: 'a, V: CodegenObject> OperandRef<'tcx, V> {\n         }\n \n         let val = match val.val {\n-            ConstValue::Unevaluated(..) => bug!(),\n             ConstValue::Scalar(x) => {\n                 let scalar = match layout.abi {\n                     layout::Abi::Scalar(ref x) => x,"}, {"sha": "ad8abe16415ed5c7e3652451e1b06242b86ecd29", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -1380,7 +1380,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n         if let TerminatorKind::Call {\n             func: Operand::Constant(box Constant {\n-                literal: ty::Const { ty: &ty::TyS { sty: ty::TyKind::FnDef(id, _), ..  }, ..  },\n+                literal: ty::LazyConst::Evaluated(ty::Const {\n+                    ty: &ty::TyS { sty: ty::TyKind::FnDef(id, _), ..  },\n+                    ..\n+                }),\n                 ..\n             }),\n             args,"}, {"sha": "63bf6faed40d462b1b65eba022ef64aef6f1e12f", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -468,13 +468,13 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                             Terminator {\n                                 kind: TerminatorKind::Call {\n                                     func: Operand::Constant(box Constant {\n-                                        literal: Const {\n+                                        literal: ty::LazyConst::Evaluated(Const {\n                                             ty: &TyS {\n                                                 sty: TyKind::FnDef(id, substs),\n                                                 ..\n                                             },\n                                             ..\n-                                        },\n+                                        }),\n                                         ..\n                                     }),\n                                     .."}, {"sha": "5c24da7621b2d827626fd7b7d799d0a0841a50d2", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"visit_region: region={:?}\", region);\n     }\n \n-    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _location: Location) {\n+    fn visit_const(&mut self, constant: &mut &'tcx ty::LazyConst<'tcx>, _location: Location) {\n         *constant = self.renumber_regions(&*constant);\n     }\n "}, {"sha": "180aa1907e8d140eafa62076edc8b17217f20611", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -382,6 +382,11 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             constant, location\n         );\n \n+        let literal = match constant.literal {\n+            ty::LazyConst::Evaluated(lit) => lit,\n+            ty::LazyConst::Unevaluated(..) => return,\n+        };\n+\n         // FIXME(#46702) -- We need some way to get the predicates\n         // associated with the \"pre-evaluated\" form of the\n         // constant. For example, consider that the constant\n@@ -390,7 +395,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         // constraints on `'a` and `'b`. These constraints\n         // would be lost if we just look at the normalized\n         // value.\n-        if let ty::FnDef(def_id, substs) = constant.literal.ty.sty {\n+        if let ty::FnDef(def_id, substs) = literal.ty.sty {\n             let tcx = self.tcx();\n             let type_checker = &mut self.cx;\n \n@@ -411,10 +416,10 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             );\n         }\n \n-        debug!(\"sanitize_constant: expected_ty={:?}\", constant.literal.ty);\n+        debug!(\"sanitize_constant: expected_ty={:?}\", literal.ty);\n \n         if let Err(terr) = self.cx.eq_types(\n-            constant.literal.ty,\n+            literal.ty,\n             constant.ty,\n             location.to_locations(),\n             ConstraintCategory::Boring,\n@@ -424,7 +429,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 constant,\n                 \"constant {:?} should have type {:?} but has {:?} ({:?})\",\n                 constant,\n-                constant.literal.ty,\n+                literal.ty,\n                 constant.ty,\n                 terr,\n             );"}, {"sha": "a66da50c484379cb0be70f52c1b946b23ffa6f77", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -270,11 +270,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             span: expr_span,\n                             ty: this.hir.tcx().types.u32,\n                             user_ty: None,\n-                            literal: ty::Const::from_bits(\n-                                this.hir.tcx(),\n-                                0,\n-                                ty::ParamEnv::empty().and(this.hir.tcx().types.u32),\n-                            ),\n+                            literal: this.hir.tcx().intern_lazy_const(ty::LazyConst::Evaluated(\n+                                ty::Const::from_bits(\n+                                    this.hir.tcx(),\n+                                    0,\n+                                    ty::ParamEnv::empty().and(this.hir.tcx().types.u32),\n+                                ),\n+                            )),\n                         }));\n                         box AggregateKind::Generator(closure_id, substs, movability)\n                     }"}, {"sha": "409b6c038ab69200e57853778e68a0e22df08835", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -658,12 +658,12 @@ enum TestKind<'tcx> {\n     SwitchInt {\n         switch_ty: Ty<'tcx>,\n         options: Vec<u128>,\n-        indices: FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+        indices: FxHashMap<ty::Const<'tcx>, usize>,\n     },\n \n     // test for equality\n     Eq {\n-        value: &'tcx ty::Const<'tcx>,\n+        value: ty::Const<'tcx>,\n         ty: Ty<'tcx>,\n     },\n "}, {"sha": "aae3de68aaae08996e1c853bd2532b5291374d66", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                      candidate: &Candidate<'pat, 'tcx>,\n                                      switch_ty: Ty<'tcx>,\n                                      options: &mut Vec<u128>,\n-                                     indices: &mut FxHashMap<&'tcx ty::Const<'tcx>, usize>)\n+                                     indices: &mut FxHashMap<ty::Const<'tcx>, usize>)\n                                      -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {\n@@ -302,6 +302,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     }\n                     let eq_def_id = self.hir.tcx().lang_items().eq_trait().unwrap();\n                     let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, &[ty.into()]);\n+                    let method = self.hir.tcx().intern_lazy_const(ty::LazyConst::Evaluated(method));\n \n                     // take the argument by reference\n                     let region_scope = self.topmost_scope();\n@@ -657,7 +658,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            (&TestKind::Range(range), &PatternKind::Constant { ref value }) => {\n+            (&TestKind::Range(range), &PatternKind::Constant { value }) => {\n                 if self.const_range_contains(range, value) == Some(false) {\n                     // `value` is not contained in the testing range,\n                     // so `value` can be matched only if this test fails.\n@@ -786,7 +787,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn const_range_contains(\n         &self,\n         range: PatternRange<'tcx>,\n-        value: &'tcx ty::Const<'tcx>,\n+        value: ty::Const<'tcx>,\n     ) -> Option<bool> {\n         use std::cmp::Ordering::*;\n \n@@ -806,9 +807,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn values_not_contained_in_range(\n         &self,\n         range: PatternRange<'tcx>,\n-        indices: &FxHashMap<&'tcx ty::Const<'tcx>, usize>,\n+        indices: &FxHashMap<ty::Const<'tcx>, usize>,\n     ) -> Option<bool> {\n-        for val in indices.keys() {\n+        for &val in indices.keys() {\n             if self.const_range_contains(range, val)? {\n                 return Some(false);\n             }"}, {"sha": "c849c022428407be55903d1ee267f53f8a0f4305", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -27,13 +27,13 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn literal_operand(&mut self,\n                            span: Span,\n                            ty: Ty<'tcx>,\n-                           literal: &'tcx ty::Const<'tcx>)\n+                           literal: ty::Const<'tcx>)\n                            -> Operand<'tcx> {\n         let constant = box Constant {\n             span,\n             ty,\n             user_ty: None,\n-            literal,\n+            literal: self.hir.tcx().intern_lazy_const(ty::LazyConst::Evaluated(literal)),\n         };\n         Operand::Constant(constant)\n     }"}, {"sha": "727b769cf4d4443931087f8ea7ef25e716fc81d7", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'gcx: 'tcx, 'tcx> MutVisitor<'tcx> for GlobalizeMir<'a, 'gcx> {\n         }\n     }\n \n-    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _: Location) {\n+    fn visit_const(&mut self, constant: &mut &'tcx ty::LazyConst<'tcx>, _: Location) {\n         if let Some(lifted) = self.tcx.lift(constant) {\n             *constant = lifted;\n         } else {"}, {"sha": "01177e5e49a0ef1042e70f421ee6f1e4471b2c57", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -95,7 +95,7 @@ pub fn op_to_const<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n     op: OpTy<'tcx>,\n     may_normalize: bool,\n-) -> EvalResult<'tcx, &'tcx ty::Const<'tcx>> {\n+) -> EvalResult<'tcx, ty::Const<'tcx>> {\n     // We do not normalize just any data.  Only scalar layout and fat pointers.\n     let normalize = may_normalize\n         && match op.layout.abi {\n@@ -134,14 +134,16 @@ pub fn op_to_const<'tcx>(\n         Ok(Immediate::ScalarPair(a, b)) =>\n             ConstValue::ScalarPair(a.not_undef()?, b.not_undef()?),\n     };\n-    Ok(ty::Const::from_const_value(ecx.tcx.tcx, val, op.layout.ty))\n+    Ok(ty::Const { val, ty: op.layout.ty })\n }\n-pub fn const_to_op<'tcx>(\n+\n+pub fn lazy_const_to_op<'tcx>(\n     ecx: &CompileTimeEvalContext<'_, '_, 'tcx>,\n-    cnst: &ty::Const<'tcx>,\n+    cnst: ty::LazyConst<'tcx>,\n+    ty: ty::Ty<'tcx>,\n ) -> EvalResult<'tcx, OpTy<'tcx>> {\n-    let op = ecx.const_value_to_op(cnst.val)?;\n-    Ok(OpTy { op, layout: ecx.layout_of(cnst.ty)? })\n+    let op = ecx.const_value_to_op(cnst)?;\n+    Ok(OpTy { op, layout: ecx.layout_of(ty)? })\n }\n \n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n@@ -508,13 +510,13 @@ pub fn const_field<'a, 'tcx>(\n     instance: ty::Instance<'tcx>,\n     variant: Option<VariantIdx>,\n     field: mir::Field,\n-    value: &'tcx ty::Const<'tcx>,\n+    value: ty::Const<'tcx>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n     trace!(\"const_field: {:?}, {:?}, {:?}\", instance, field, value);\n     let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let result = (|| {\n         // get the operand again\n-        let op = const_to_op(&ecx, value)?;\n+        let op = lazy_const_to_op(&ecx, ty::LazyConst::Evaluated(value), value.ty)?;\n         // downcast\n         let down = match variant {\n             None => op,\n@@ -537,11 +539,11 @@ pub fn const_variant_index<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     instance: ty::Instance<'tcx>,\n-    val: &'tcx ty::Const<'tcx>,\n+    val: ty::Const<'tcx>,\n ) -> EvalResult<'tcx, VariantIdx> {\n     trace!(\"const_variant_index: {:?}, {:?}\", instance, val);\n     let ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n-    let op = const_to_op(&ecx, val)?;\n+    let op = lazy_const_to_op(&ecx, ty::LazyConst::Evaluated(val), val.ty)?;\n     Ok(ecx.read_discriminant(op)?.1)\n }\n "}, {"sha": "37d741d2606d52630542cbd26703df1240634eb2", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -14,7 +14,7 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     ty: Ty<'tcx>,\n     neg: bool,\n-) -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {\n+) -> Result<ty::Const<'tcx>, LitToConstError> {\n     use syntax::ast::*;\n \n     let trunc = |n| {\n@@ -64,7 +64,7 @@ crate fn lit_to_const<'a, 'gcx, 'tcx>(\n         LitKind::Bool(b) => ConstValue::Scalar(Scalar::from_bool(b)),\n         LitKind::Char(c) => ConstValue::Scalar(Scalar::from_char(c)),\n     };\n-    Ok(ty::Const::from_const_value(tcx, lit, ty))\n+    Ok(ty::Const { val: lit, ty })\n }\n \n fn parse_float<'tcx>("}, {"sha": "532e6783f2f2bc38dd49aa1f5b7b202732ee9994", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -356,7 +356,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprKind::Lit(ref lit) => ExprKind::Literal {\n-            literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, false),\n+            literal: cx.tcx.intern_lazy_const(ty::LazyConst::Evaluated(\n+                cx.const_eval_literal(&lit.node, expr_ty, lit.span, false)\n+            )),\n             user_ty: None,\n         },\n \n@@ -454,7 +456,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             } else {\n                 if let hir::ExprKind::Lit(ref lit) = arg.node {\n                     ExprKind::Literal {\n-                        literal: cx.const_eval_literal(&lit.node, expr_ty, lit.span, true),\n+                        literal: cx.tcx.intern_lazy_const(ty::LazyConst::Evaluated(\n+                            cx.const_eval_literal(&lit.node, expr_ty, lit.span, true)\n+                        )),\n                         user_ty: None,\n                     }\n                 } else {\n@@ -711,24 +715,22 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         temp_lifetime,\n                         ty: var_ty,\n                         span: expr.span,\n-                        kind: ExprKind::Literal { literal, user_ty: None },\n+                        kind: ExprKind::Literal {\n+                            literal: cx.tcx.intern_lazy_const(literal),\n+                            user_ty: None\n+                        },\n                     }.to_ref();\n-                    let offset = mk_const(ty::Const::from_bits(\n+                    let offset = mk_const(ty::LazyConst::Evaluated(ty::Const::from_bits(\n                         cx.tcx,\n                         offset as u128,\n                         cx.param_env.and(var_ty),\n-                    ));\n+                    )));\n                     match did {\n                         Some(did) => {\n                             // in case we are offsetting from a computed discriminant\n                             // and not the beginning of discriminants (which is always `0`)\n                             let substs = Substs::identity_for_item(cx.tcx(), did);\n-                            let lhs = mk_const(ty::Const::unevaluated(\n-                                cx.tcx(),\n-                                did,\n-                                substs,\n-                                var_ty,\n-                            ));\n+                            let lhs = mk_const(ty::LazyConst::Unevaluated(did, substs));\n                             let bin = ExprKind::Binary {\n                                 op: BinOp::Add,\n                                 lhs,\n@@ -868,7 +870,9 @@ fn method_callee<'a, 'gcx, 'tcx>(\n         ty,\n         span,\n         kind: ExprKind::Literal {\n-            literal: ty::Const::zero_sized(cx.tcx(), ty),\n+            literal: cx.tcx().intern_lazy_const(ty::LazyConst::Evaluated(\n+                ty::Const::zero_sized(ty)\n+            )),\n             user_ty,\n         },\n     }\n@@ -928,10 +932,9 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n             debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n-                literal: ty::Const::zero_sized(\n-                    cx.tcx,\n+                literal: cx.tcx.intern_lazy_const(ty::LazyConst::Evaluated(ty::Const::zero_sized(\n                     cx.tables().node_id_to_type(expr.hir_id),\n-                ),\n+                ))),\n                 user_ty,\n             }\n         },\n@@ -941,12 +944,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n             debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n-                literal: ty::Const::unevaluated(\n-                    cx.tcx,\n-                    def_id,\n-                    substs,\n-                    cx.tables().node_id_to_type(expr.hir_id),\n-                ),\n+                literal: cx.tcx.intern_lazy_const(ty::LazyConst::Unevaluated(def_id, substs)),\n                 user_ty,\n             }\n         },"}, {"sha": "6113d88e09591a07c4cb4442f7e2d59347d94680", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -108,8 +108,8 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.tcx.types.usize\n     }\n \n-    pub fn usize_literal(&mut self, value: u64) -> &'tcx ty::Const<'tcx> {\n-        ty::Const::from_usize(self.tcx, value)\n+    pub fn usize_literal(&mut self, value: u64) -> &'tcx ty::LazyConst<'tcx> {\n+        self.tcx.intern_lazy_const(ty::LazyConst::Evaluated(ty::Const::from_usize(self.tcx, value)))\n     }\n \n     pub fn bool_ty(&mut self) -> Ty<'tcx> {\n@@ -120,12 +120,12 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         self.tcx.mk_unit()\n     }\n \n-    pub fn true_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n-        ty::Const::from_bool(self.tcx, true)\n+    pub fn true_literal(&mut self) -> &'tcx ty::LazyConst<'tcx> {\n+        self.tcx.intern_lazy_const(ty::LazyConst::Evaluated(ty::Const::from_bool(self.tcx, true)))\n     }\n \n-    pub fn false_literal(&mut self) -> &'tcx ty::Const<'tcx> {\n-        ty::Const::from_bool(self.tcx, false)\n+    pub fn false_literal(&mut self) -> &'tcx ty::LazyConst<'tcx> {\n+        self.tcx.intern_lazy_const(ty::LazyConst::Evaluated(ty::Const::from_bool(self.tcx, false)))\n     }\n \n     pub fn const_eval_literal(\n@@ -134,7 +134,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         ty: Ty<'tcx>,\n         sp: Span,\n         neg: bool,\n-    ) -> &'tcx ty::Const<'tcx> {\n+    ) -> ty::Const<'tcx> {\n         trace!(\"const_eval_literal: {:#?}, {:?}, {:?}, {:?}\", lit, ty, sp, neg);\n \n         match lit_to_const(lit, self.tcx, ty, neg) {\n@@ -169,14 +169,14 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n                         method_name: &str,\n                         self_ty: Ty<'tcx>,\n                         params: &[Kind<'tcx>])\n-                        -> (Ty<'tcx>, &'tcx ty::Const<'tcx>) {\n+                        -> (Ty<'tcx>, ty::Const<'tcx>) {\n         let method_name = Symbol::intern(method_name);\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n             if item.kind == ty::AssociatedKind::Method && item.ident.name == method_name {\n                 let method_ty = self.tcx.type_of(item.def_id);\n                 let method_ty = method_ty.subst(self.tcx, substs);\n-                return (method_ty, ty::Const::zero_sized(self.tcx, method_ty));\n+                return (method_ty, ty::Const::zero_sized(method_ty));\n             }\n         }\n "}, {"sha": "676b98457489f81d76bf62982e99cf35b926e7f2", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -9,7 +9,7 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::Canonical;\n use rustc::middle::region;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{AdtDef, UpvarSubsts, Region, Ty, Const, UserTypeAnnotation};\n+use rustc::ty::{AdtDef, UpvarSubsts, Region, Ty, Const, LazyConst, UserTypeAnnotation};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir;\n use syntax::ast;\n@@ -288,7 +288,7 @@ pub enum ExprKind<'tcx> {\n         movability: Option<hir::GeneratorMovability>,\n     },\n     Literal {\n-        literal: &'tcx Const<'tcx>,\n+        literal: &'tcx LazyConst<'tcx>,\n         user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n     },\n     InlineAsm {"}, {"sha": "b25d47b390175ba7790049a1cef72ecf1803234a", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 39, "deletions": 26, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -223,7 +223,7 @@ impl<'a, 'tcx> LiteralExpander<'a, 'tcx> {\n                 assert_eq!(t, u);\n                 ConstValue::ScalarPair(\n                     Scalar::Ptr(p),\n-                    n.val.try_to_scalar().unwrap(),\n+                    n.map_evaluated(|val| val.val.try_to_scalar()).unwrap(),\n                 )\n             },\n             // fat pointers stay the same\n@@ -251,11 +251,10 @@ impl<'a, 'tcx> PatternFolder<'tcx> for LiteralExpander<'a, 'tcx> {\n                         subpattern: Pattern {\n                             ty: rty,\n                             span: pat.span,\n-                            kind: box PatternKind::Constant { value: Const::from_const_value(\n-                                self.tcx,\n-                                self.fold_const_value_deref(*val, rty, crty),\n-                                rty,\n-                            ) },\n+                            kind: box PatternKind::Constant { value: Const {\n+                                val: self.fold_const_value_deref(val, rty, crty),\n+                                ty: rty,\n+                            } },\n                         }\n                     }\n                 }\n@@ -420,7 +419,7 @@ pub enum Constructor<'tcx> {\n     /// Enum variants.\n     Variant(DefId),\n     /// Literal values.\n-    ConstantValue(&'tcx ty::Const<'tcx>),\n+    ConstantValue(ty::Const<'tcx>),\n     /// Ranges of literal values (`2...5` and `2..5`).\n     ConstantRange(u128, u128, Ty<'tcx>, RangeEnd),\n     /// Array patterns of length n.\n@@ -1396,7 +1395,7 @@ fn constructor_sub_pattern_tys<'a, 'tcx: 'a>(cx: &MatchCheckCtxt<'a, 'tcx>,\n fn slice_pat_covered_by_const<'tcx>(\n     tcx: TyCtxt<'_, 'tcx, '_>,\n     _span: Span,\n-    const_val: &ty::Const<'tcx>,\n+    const_val: ty::Const<'tcx>,\n     prefix: &[Pattern<'tcx>],\n     slice: &Option<Pattern<'tcx>>,\n     suffix: &[Pattern<'tcx>]\n@@ -1751,23 +1750,37 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                     // necessarily point to memory, they are usually just integers. The only time\n                     // they should be pointing to memory is when they are subslices of nonzero\n                     // slices\n-                    let (opt_ptr, n, ty) = match (value.val, &value.ty.sty) {\n-                        (ConstValue::ByRef(id, alloc, offset), ty::TyKind::Array(t, n)) => (\n-                            Some((\n-                                Pointer::new(id, offset),\n-                                alloc,\n-                            )),\n-                            n.unwrap_usize(cx.tcx),\n-                            t,\n-                        ),\n-                        (ConstValue::ScalarPair(ptr, n), ty::TyKind::Slice(t)) => (\n-                            ptr.to_ptr().ok().map(|ptr| (\n-                                ptr,\n-                                cx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n-                            )),\n-                            n.to_bits(cx.tcx.data_layout.pointer_size).unwrap() as u64,\n-                            t,\n-                        ),\n+                    let (opt_ptr, n, ty) = match value.ty.sty {\n+                        ty::TyKind::Array(t, n) => {\n+                            match value.val {\n+                                ConstValue::ByRef(id, alloc, offset) => (\n+                                    Some((Pointer::new(id, offset), alloc)),\n+                                    n.unwrap_usize(cx.tcx),\n+                                    t,\n+                                ),\n+                                _ => span_bug!(\n+                                    pat.span,\n+                                    \"array pattern is {:?}\", value,\n+                                ),\n+                            }\n+                        },\n+                        ty::TyKind::Slice(t) => {\n+                            match value.val {\n+                                ConstValue::ScalarPair(ptr, n) => (\n+                                    ptr.to_ptr().ok().map(|ptr| (\n+                                        ptr,\n+                                        cx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                                    )),\n+                                    n.to_bits(cx.tcx.data_layout.pointer_size).unwrap() as u64,\n+                                    t,\n+                                ),\n+                                _ => span_bug!(\n+                                    pat.span,\n+                                    \"slice pattern constant must be scalar pair but is {:?}\",\n+                                    value,\n+                                ),\n+                            }\n+                        },\n                         _ => span_bug!(\n                             pat.span,\n                             \"unexpected const-val {:?} with ctor {:?}\",\n@@ -1787,7 +1800,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n                                         &cx.tcx, ptr, layout.size,\n                                     ).ok()?;\n                                     let scalar = scalar.not_undef().ok()?;\n-                                    let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n+                                    let value = ty::Const::from_scalar(scalar, ty);\n                                     let pattern = Pattern {\n                                         ty,\n                                         span: pat.span,"}, {"sha": "f52aeded19ae797bb6117786b2167543b846b8ef", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -123,7 +123,7 @@ pub enum PatternKind<'tcx> {\n     },\n \n     Constant {\n-        value: &'tcx ty::Const<'tcx>,\n+        value: ty::Const<'tcx>,\n     },\n \n     Range(PatternRange<'tcx>),\n@@ -147,8 +147,8 @@ pub enum PatternKind<'tcx> {\n \n #[derive(Clone, Copy, Debug, PartialEq)]\n pub struct PatternRange<'tcx> {\n-    pub lo: &'tcx ty::Const<'tcx>,\n-    pub hi: &'tcx ty::Const<'tcx>,\n+    pub lo: ty::Const<'tcx>,\n+    pub hi: ty::Const<'tcx>,\n     pub ty: Ty<'tcx>,\n     pub end: RangeEnd,\n }\n@@ -857,7 +857,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     fn const_to_pat(\n         &self,\n         instance: ty::Instance<'tcx>,\n-        cv: &'tcx ty::Const<'tcx>,\n+        cv: ty::Const<'tcx>,\n         id: hir::HirId,\n         span: Span,\n     ) -> Pattern<'tcx> {\n@@ -1018,7 +1018,7 @@ macro_rules! CloneImpls {\n }\n \n CloneImpls!{ <'tcx>\n-    Span, Field, Mutability, ast::Name, ast::NodeId, usize, &'tcx ty::Const<'tcx>,\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ty::Const<'tcx>,\n     Region<'tcx>, Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n     &'tcx Substs<'tcx>, &'tcx Kind<'tcx>, UserTypeAnnotation<'tcx>,\n     UserTypeProjection<'tcx>, PatternTypeProjection<'tcx>\n@@ -1140,8 +1140,8 @@ impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n \n pub fn compare_const_vals<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    a: &'tcx ty::Const<'tcx>,\n-    b: &'tcx ty::Const<'tcx>,\n+    a: ty::Const<'tcx>,\n+    b: ty::Const<'tcx>,\n     ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Option<Ordering> {\n     trace!(\"compare_const_vals: {:?}, {:?}\", a, b);"}, {"sha": "04e0955ad617263f3dcbbaf3c4ead5dcfbbed905", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -3,7 +3,7 @@\n \n use std::convert::TryInto;\n \n-use rustc::mir;\n+use rustc::{mir, ty};\n use rustc::ty::layout::{self, Size, LayoutOf, TyLayout, HasDataLayout, IntegerExt, VariantIdx};\n \n use rustc::mir::interpret::{\n@@ -517,7 +517,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     let ty = self.monomorphize(mir_op.ty(self.mir(), *self.tcx), self.substs());\n                     self.layout_of(ty)\n                 })?;\n-                let op = self.const_value_to_op(constant.literal.val)?;\n+                let op = self.const_value_to_op(*constant.literal)?;\n                 OpTy { op, layout }\n             }\n         };\n@@ -540,17 +540,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     // `eval_operand`, ideally).\n     pub(crate) fn const_value_to_op(\n         &self,\n-        val: ConstValue<'tcx>,\n+        val: ty::LazyConst<'tcx>,\n     ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n         trace!(\"const_value_to_op: {:?}\", val);\n-        match val {\n-            ConstValue::Unevaluated(def_id, substs) => {\n+        let val = match val {\n+            ty::LazyConst::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n-                Ok(*OpTy::from(self.const_eval_raw(GlobalId {\n+                return Ok(*OpTy::from(self.const_eval_raw(GlobalId {\n                     instance,\n                     promoted: None,\n-                })?))\n-            }\n+                })?));\n+            },\n+            ty::LazyConst::Evaluated(c) => c,\n+        };\n+        match val.val {\n             ConstValue::ByRef(id, alloc, offset) => {\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen -- and for `static mut`, we copy on demand anyway."}, {"sha": "eabfd47c9fb9033016e7ad70a19dc2c5189450d9", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -381,7 +381,7 @@ fn collect_items_rec<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let param_env = ty::ParamEnv::reveal_all();\n \n             if let Ok(val) = tcx.const_eval(param_env.and(cid)) {\n-                collect_const(tcx, val, instance.substs, &mut neighbors);\n+                collect_const(tcx, val, &mut neighbors);\n             }\n         }\n         MonoItem::Fn(instance) => {\n@@ -583,10 +583,10 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n         self.super_rvalue(rvalue, location);\n     }\n \n-    fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, location: Location) {\n+    fn visit_const(&mut self, constant: &&'tcx ty::LazyConst<'tcx>, location: Location) {\n         debug!(\"visiting const {:?} @ {:?}\", *constant, location);\n \n-        collect_const(self.tcx, constant, self.param_substs, self.output);\n+        collect_lazy_const(self.tcx, constant, self.param_substs, self.output);\n \n         self.super_const(constant);\n     }\n@@ -987,7 +987,7 @@ impl<'b, 'a, 'v> ItemLikeVisitor<'v> for RootCollector<'b, 'a, 'v> {\n                 let param_env = ty::ParamEnv::reveal_all();\n \n                 if let Ok(val) = self.tcx.const_eval(param_env.and(cid)) {\n-                    collect_const(self.tcx, val, instance.substs, &mut self.output);\n+                    collect_const(self.tcx, val, &mut self.output);\n                 }\n             }\n             hir::ItemKind::Fn(..) => {\n@@ -1198,7 +1198,7 @@ fn collect_neighbours<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             promoted: Some(i),\n         };\n         match tcx.const_eval(param_env.and(cid)) {\n-            Ok(val) => collect_const(tcx, val, instance.substs, output),\n+            Ok(val) => collect_const(tcx, val, output),\n             Err(ErrorHandled::Reported) => {},\n             Err(ErrorHandled::TooGeneric) => span_bug!(\n                 mir.promoted[i].span, \"collection encountered polymorphic constant\",\n@@ -1216,43 +1216,48 @@ fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     output\n }\n \n-fn collect_const<'a, 'tcx>(\n+fn collect_lazy_const<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    constant: &ty::Const<'tcx>,\n+    constant: &ty::LazyConst<'tcx>,\n     param_substs: &'tcx Substs<'tcx>,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n-    debug!(\"visiting const {:?}\", *constant);\n+    let (def_id, substs) = match *constant {\n+        ty::LazyConst::Evaluated(c) => return collect_const(tcx, c, output),\n+        ty::LazyConst::Unevaluated(did, substs) => (did, substs),\n+    };\n+    let param_env = ty::ParamEnv::reveal_all();\n+    let substs = tcx.subst_and_normalize_erasing_regions(\n+        param_substs,\n+        param_env,\n+        &substs,\n+    );\n+    let instance = ty::Instance::resolve(tcx,\n+                                        param_env,\n+                                        def_id,\n+                                        substs).unwrap();\n+\n+    let cid = GlobalId {\n+        instance,\n+        promoted: None,\n+    };\n+    match tcx.const_eval(param_env.and(cid)) {\n+        Ok(val) => collect_const(tcx, val, output),\n+        Err(ErrorHandled::Reported) => {},\n+        Err(ErrorHandled::TooGeneric) => span_bug!(\n+            tcx.def_span(def_id), \"collection encountered polymorphic constant\",\n+        ),\n+    }\n+}\n \n-    let val = match constant.val {\n-        ConstValue::Unevaluated(def_id, substs) => {\n-            let param_env = ty::ParamEnv::reveal_all();\n-            let substs = tcx.subst_and_normalize_erasing_regions(\n-                param_substs,\n-                param_env,\n-                &substs,\n-            );\n-            let instance = ty::Instance::resolve(tcx,\n-                                                param_env,\n-                                                def_id,\n-                                                substs).unwrap();\n+fn collect_const<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    constant: ty::Const<'tcx>,\n+    output: &mut Vec<MonoItem<'tcx>>,\n+) {\n+    debug!(\"visiting const {:?}\", constant);\n \n-            let cid = GlobalId {\n-                instance,\n-                promoted: None,\n-            };\n-            match tcx.const_eval(param_env.and(cid)) {\n-                Ok(val) => val.val,\n-                Err(ErrorHandled::Reported) => return,\n-                Err(ErrorHandled::TooGeneric) => span_bug!(\n-                    tcx.def_span(def_id), \"collection encountered polymorphic constant\",\n-                ),\n-            }\n-        },\n-        _ => constant.val,\n-    };\n-    match val {\n-        ConstValue::Unevaluated(..) => bug!(\"const eval yielded unevaluated const\"),\n+    match constant.val {\n         ConstValue::ScalarPair(Scalar::Ptr(a), Scalar::Ptr(b)) => {\n             collect_miri(tcx, a.alloc_id, output);\n             collect_miri(tcx, b.alloc_id, output);"}, {"sha": "751815eab287bf03b3554218c6126cf410a4e1e2", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -459,7 +459,9 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             span: self.span,\n             ty: func_ty,\n             user_ty: None,\n-            literal: ty::Const::zero_sized(self.tcx, func_ty),\n+            literal: tcx.intern_lazy_const(ty::LazyConst::Evaluated(\n+                ty::Const::zero_sized(func_ty),\n+            )),\n         });\n \n         let ref_loc = self.make_place(\n@@ -519,7 +521,9 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             span: self.span,\n             ty: self.tcx.types.usize,\n             user_ty: None,\n-            literal: ty::Const::from_usize(self.tcx, value),\n+            literal: self.tcx.intern_lazy_const(ty::LazyConst::Evaluated(\n+                ty::Const::from_usize(self.tcx, value),\n+            )),\n         }\n     }\n \n@@ -755,7 +759,9 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 span,\n                 ty,\n                 user_ty: None,\n-                literal: ty::Const::zero_sized(tcx, ty),\n+                literal: tcx.intern_lazy_const(ty::LazyConst::Evaluated(\n+                    ty::Const::zero_sized(ty)\n+                )),\n              }),\n              vec![rcvr])\n         }"}, {"sha": "03d6d3868c9f0440c31cb42a15ece29a20cf7a6b", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -20,7 +20,8 @@ use rustc::ty::layout::{\n \n use interpret::{self, EvalContext, ScalarMaybeUndef, Immediate, OpTy, MemoryKind};\n use const_eval::{\n-    CompileTimeInterpreter, const_to_op, error_to_const_error, eval_promoted, mk_borrowck_eval_cx\n+    CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_borrowck_eval_cx,\n+    lazy_const_to_op,\n };\n use transform::{MirPass, MirSource};\n \n@@ -255,7 +256,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = source_info.span;\n-        match const_to_op(&self.ecx, c.literal) {\n+        match lazy_const_to_op(&self.ecx, *c.literal, c.ty) {\n             Ok(op) => {\n                 Some((op, c.span))\n             },"}, {"sha": "06e16de8b43bcd0130718f1f9cba6442cd1d5c0e", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -533,7 +533,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             span,\n             ty: self.tcx.types.bool,\n             user_ty: None,\n-            literal: ty::Const::from_bool(self.tcx, val),\n+            literal: self.tcx.intern_lazy_const(ty::LazyConst::Evaluated(\n+                ty::Const::from_bool(self.tcx, val),\n+            )),\n         })))\n     }\n "}, {"sha": "b464b7d65e4661b614e9ede69093bf3843eb2a10", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -32,7 +32,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n         *region = self.tcx.types.re_erased;\n     }\n \n-    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _: Location) {\n+    fn visit_const(&mut self, constant: &mut &'tcx ty::LazyConst<'tcx>, _: Location) {\n         *constant = self.tcx.erase_regions(constant);\n     }\n "}, {"sha": "808c3aad2920102dc155af6a38cadb1535d1d1db", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -171,11 +171,11 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n             span: source_info.span,\n             ty: self.tcx.types.u32,\n             user_ty: None,\n-            literal: ty::Const::from_bits(\n+            literal: self.tcx.intern_lazy_const(ty::LazyConst::Evaluated(ty::Const::from_bits(\n                 self.tcx,\n                 state_disc.into(),\n                 ty::ParamEnv::empty().and(self.tcx.types.u32)\n-            ),\n+            ))),\n         });\n         Statement {\n             source_info,\n@@ -717,7 +717,9 @@ fn insert_panic_block<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             span: mir.span,\n             ty: tcx.types.bool,\n             user_ty: None,\n-            literal: ty::Const::from_bool(tcx, false),\n+            literal: tcx.intern_lazy_const(ty::LazyConst::Evaluated(\n+                ty::Const::from_bool(tcx, false),\n+            )),\n         }),\n         expected: true,\n         msg: message,"}, {"sha": "a04dd5bb5970f4045f29bc3ffcd1944778f9f1ba", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -11,7 +11,6 @@ use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi::Abi;\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::mir::interpret::ConstValue;\n use rustc::traits::{self, TraitEngine};\n use rustc::ty::{self, TyCtxt, Ty, TypeFoldable};\n use rustc::ty::cast::CastTy;\n@@ -625,20 +624,20 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n             }\n             Operand::Constant(ref constant) => {\n-                if let ConstValue::Unevaluated(def_id, _) = constant.literal.val {\n+                if let ty::LazyConst::Unevaluated(def_id, _) = constant.literal {\n                     // Don't peek inside trait associated constants.\n-                    if self.tcx.trait_of_item(def_id).is_some() {\n-                        self.add_type(constant.literal.ty);\n+                    if self.tcx.trait_of_item(*def_id).is_some() {\n+                        self.add_type(constant.ty);\n                     } else {\n-                        let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(def_id);\n+                        let (bits, _) = self.tcx.at(constant.span).mir_const_qualif(*def_id);\n \n                         let qualif = Qualif::from_bits(bits).expect(\"invalid mir_const_qualif\");\n                         self.add(qualif);\n \n                         // Just in case the type is more specific than\n                         // the definition, e.g., impl associated const\n                         // with type parameters, take it into account.\n-                        self.qualif.restrict(constant.literal.ty, self.tcx, self.param_env);\n+                        self.qualif.restrict(constant.ty, self.tcx, self.param_env);\n                     }\n                 }\n             }"}, {"sha": "abaea709463838cfdfbeb9a553866acbbeae0eb4", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -30,11 +30,12 @@ impl MirPass for SimplifyBranches {\n                     discr: Operand::Constant(ref c), switch_ty, ref values, ref targets, ..\n                 } => {\n                     let switch_ty = ParamEnv::empty().and(switch_ty);\n-                    if let Some(constint) = c.literal.assert_bits(tcx, switch_ty) {\n+                    let constant = c.literal.map_evaluated(|c| c.assert_bits(tcx, switch_ty));\n+                    if let Some(constant) = constant {\n                         let (otherwise, targets) = targets.split_last().unwrap();\n                         let mut ret = TerminatorKind::Goto { target: *otherwise };\n                         for (&v, t) in values.iter().zip(targets.iter()) {\n-                            if v == constint {\n+                            if v == constant {\n                                 ret = TerminatorKind::Goto { target: *t };\n                                 break;\n                             }\n@@ -46,9 +47,8 @@ impl MirPass for SimplifyBranches {\n                 },\n                 TerminatorKind::Assert {\n                     target, cond: Operand::Constant(ref c), expected, ..\n-                } if (c.literal.assert_bool(tcx) == Some(true)) == expected => {\n-                    TerminatorKind::Goto { target }\n-                },\n+                } if (c.literal.map_evaluated(|e| e.assert_bool(tcx)) == Some(true)) == expected =>\n+                    TerminatorKind::Goto { target },\n                 TerminatorKind::FalseEdges { real_target, .. } => {\n                     TerminatorKind::Goto { target: real_target }\n                 },"}, {"sha": "8b55a4424ae293f211f2264efeacf4db3b4a143e", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -963,7 +963,9 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             span: self.source_info.span,\n             ty: self.tcx().types.usize,\n             user_ty: None,\n-            literal: ty::Const::from_usize(self.tcx(), val.into()),\n+            literal: self.tcx().intern_lazy_const(ty::LazyConst::Evaluated(\n+                ty::Const::from_usize(self.tcx(), val.into())\n+            )),\n         })\n     }\n "}, {"sha": "fca208b340d2ac5e8a240eb557a17a1246b652d5", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -399,12 +399,21 @@ impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ExtraComments<'cx, 'gcx, 'tcx> {\n         self.push(&format!(\"+ literal: {:?}\", literal));\n     }\n \n-    fn visit_const(&mut self, constant: &&'tcx ty::Const<'tcx>, _: Location) {\n+    fn visit_const(&mut self, constant: &&'tcx ty::LazyConst<'tcx>, _: Location) {\n         self.super_const(constant);\n-        let ty::Const { ty, val, .. } = constant;\n-        self.push(\"ty::Const\");\n-        self.push(&format!(\"+ ty: {:?}\", ty));\n-        self.push(&format!(\"+ val: {:?}\", val));\n+        match constant {\n+            ty::LazyConst::Evaluated(constant) => {\n+                let ty::Const { ty, val, .. } = constant;\n+                self.push(\"ty::Const\");\n+                self.push(&format!(\"+ ty: {:?}\", ty));\n+                self.push(&format!(\"+ val: {:?}\", val));\n+            },\n+            ty::LazyConst::Unevaluated(did, substs) => {\n+                self.push(\"ty::LazyConst::Unevaluated\");\n+                self.push(&format!(\"+ did: {:?}\", did));\n+                self.push(&format!(\"+ substs: {:?}\", substs));\n+            },\n+        }\n     }\n \n     fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {"}, {"sha": "71f4945fd648df3f7f51096e3a70883a83e6766d", "filename": "src/librustc_traits/chalk_context/program_clauses.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Fprogram_clauses.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -239,7 +239,7 @@ fn wf_clause_for_slice<'tcx>(tcx: ty::TyCtxt<'_, '_, 'tcx>) -> Clauses<'tcx> {\n \n fn wf_clause_for_array<'tcx>(\n     tcx: ty::TyCtxt<'_, '_, 'tcx>,\n-    length: &'tcx ty::Const<'tcx>\n+    length: &'tcx ty::LazyConst<'tcx>\n ) -> Clauses<'tcx> {\n     let ty = generic_types::bound(tcx, 0);\n     let array_ty = tcx.mk_ty(ty::Array(ty, length));"}, {"sha": "e018aa3b26d91c985e3c2311a950651b78e55b54", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -1772,7 +1772,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             hir::TyKind::Array(ref ty, ref length) => {\n                 let length_def_id = tcx.hir().local_def_id(length.id);\n                 let substs = Substs::identity_for_item(tcx, length_def_id);\n-                let length = ty::Const::unevaluated(tcx, length_def_id, substs, tcx.types.usize);\n+                let length = ty::LazyConst::Unevaluated(length_def_id, substs);\n+                let length = tcx.intern_lazy_const(length);\n                 let array_ty = tcx.mk_ty(ty::Array(self.ast_ty_to_ty(&ty), length));\n                 self.normalize_ty(ast_ty.span, array_ty)\n             }"}, {"sha": "b2ea170697737bba90d4b4e42ad76cb50d1160bf", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -4472,7 +4472,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if element_ty.references_error() {\n                     tcx.types.err\n                 } else if let Ok(count) = count {\n-                    tcx.mk_ty(ty::Array(t, count))\n+                    tcx.mk_ty(ty::Array(t, tcx.intern_lazy_const(ty::LazyConst::Evaluated(count))))\n                 } else {\n                     tcx.types.err\n                 }"}, {"sha": "3aa752b35adcf5c45275f9c1edb7efcd45176380", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6d32ac25df2984f66b6abd14c1096880e04179a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d6d32ac25df2984f66b6abd14c1096880e04179a", "patch": "@@ -13,7 +13,6 @@ use rustc_data_structures::sync::Lrc;\n use rustc_target::spec::abi::Abi;\n use rustc_typeck::hir_ty_to_ty;\n use rustc::infer::region_constraints::{RegionConstraintData, Constraint};\n-use rustc::mir::interpret::ConstValue;\n use rustc::middle::resolve_lifetime as rl;\n use rustc::middle::lang_items;\n use rustc::middle::stability;\n@@ -2420,10 +2419,10 @@ impl Clean<Type> for hir::Ty {\n                     instance: ty::Instance::new(def_id, substs),\n                     promoted: None\n                 };\n-                let length = cx.tcx.const_eval(param_env.and(cid)).unwrap_or_else(|_| {\n-                    ty::Const::unevaluated(cx.tcx, def_id, substs, cx.tcx.types.usize)\n-                });\n-                let length = print_const(cx, length);\n+                let length = match cx.tcx.const_eval(param_env.and(cid)) {\n+                    Ok(length) => print_const(cx, ty::LazyConst::Evaluated(length)),\n+                    Err(_) => \"_\".to_string(),\n+                };\n                 Array(box ty.clean(cx), length)\n             },\n             TyKind::Tup(ref tys) => Tuple(tys.clean(cx)),\n@@ -2583,15 +2582,15 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n             ty::Str => Primitive(PrimitiveType::Str),\n             ty::Slice(ty) => Slice(box ty.clean(cx)),\n             ty::Array(ty, n) => {\n-                let mut n = cx.tcx.lift(&n).expect(\"array lift failed\");\n-                if let ConstValue::Unevaluated(def_id, substs) = n.val {\n+                let mut n = *cx.tcx.lift(&n).expect(\"array lift failed\");\n+                if let ty::LazyConst::Unevaluated(def_id, substs) = n {\n                     let param_env = cx.tcx.param_env(def_id);\n                     let cid = GlobalId {\n                         instance: ty::Instance::new(def_id, substs),\n                         promoted: None\n                     };\n                     if let Ok(new_n) = cx.tcx.const_eval(param_env.and(cid)) {\n-                        n = new_n;\n+                        n = ty::LazyConst::Evaluated(new_n);\n                     }\n                 };\n                 let n = print_const(cx, n);\n@@ -3691,16 +3690,16 @@ fn name_from_pat(p: &hir::Pat) -> String {\n     }\n }\n \n-fn print_const(cx: &DocContext, n: &ty::Const) -> String {\n-    match n.val {\n-        ConstValue::Unevaluated(def_id, _) => {\n+fn print_const(cx: &DocContext, n: ty::LazyConst) -> String {\n+    match n {\n+        ty::LazyConst::Unevaluated(def_id, _) => {\n             if let Some(node_id) = cx.tcx.hir().as_local_node_id(def_id) {\n                 print_const_expr(cx, cx.tcx.hir().body_owned_by(node_id))\n             } else {\n                 inline::print_inlined_const(cx, def_id)\n             }\n         },\n-        _ => {\n+        ty::LazyConst::Evaluated(n) => {\n             let mut s = String::new();\n             ::rustc::mir::fmt_const_val(&mut s, n).expect(\"fmt_const_val failed\");\n             // array lengths are obviously usize"}]}