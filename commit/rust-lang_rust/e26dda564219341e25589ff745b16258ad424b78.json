{"sha": "e26dda564219341e25589ff745b16258ad424b78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyNmRkYTU2NDIxOTM0MWUyNTU4OWZmNzQ1YjE2MjU4YWQ0MjRiNzg=", "commit": {"author": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2021-08-05T23:15:22Z"}, "committer": {"name": "Chris Denton", "email": "christophersdenton@gmail.com", "date": "2021-08-08T21:11:30Z"}, "message": "Implement modern Windows arg parsing\n\nAs derived from extensive testing of `argv` in a C/C++ application.\n\nCo-Authored-By: Jane Lusby <jlusby42@gmail.com>", "tree": {"sha": "076e9b4fc6f7e80f5b0f72c46921c06f502cf350", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/076e9b4fc6f7e80f5b0f72c46921c06f502cf350"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e26dda564219341e25589ff745b16258ad424b78", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE+p/jD6jrzmnSIWJLcTRy8vRWJ94FAmEQSIIACgkQcTRy8vRW\nJ94PLA//cwCLsuehOax7VV7fSgh/F6W4IG54OEB70NJGs8wCSJpzcgtH7vJ/6O/M\nD7NWK7DNsVMQ1egrYBw3cLTMcCzfMh81Ll5LUbfOf8P5kSl2vq5UI5y70/NvA9ir\n4sxJIzKtquTC1w8+5TC8kClc7l6w23KGHCADiOUKci73oXO6P3mCA9xx+JiBOwTj\n3nBj04b3YKvUlRNq9TjPCdjOkjqYPisQD25yB6enWfGK/lB2ebZGjNo7XaeJ1nNd\nSXrG+K6Pk3SVhL4R805H6S7by89YjBUtHa7bxhPXD0P7ZmomiCr8sQ9AkT4QTNKR\n+oBkzi753xmjWPN4X5rskmTW+40M9wv6Q4G8Ad1qYiC5SYmdpYDFoaMXfrcONdSl\n7zj9iPXML0jsHip6dm0g//S4VBLE2s3Qt3Gw9OPj73CcnyK7+5vkXyuGAMt7E5eA\nVF6NADmkVAvxe3XxFGgcyxnrZK/P58zDYc10NWzwk8RAHHQXj9EQSKaLvEa/0im/\nfms03LAVNHWpo6KS46tkTpsKWNK7Uz+wVLeOSj8vbJ2fxldGM/cuDP1+JDWiFkkb\nFSyIRScLWTU1QMugMlUMxOC7uoefPVPZ/t1NJXkTHbm/oGLBr0qTgdL8We8moYpF\nr6AerX0OmLn92zJDKxDgsDqzArUvzZ+VHYHztCtAkJdGlyVNIgQ=\n=4qKN\n-----END PGP SIGNATURE-----", "payload": "tree 076e9b4fc6f7e80f5b0f72c46921c06f502cf350\nparent 565a51973a4f64f522e66c8af87bad339c966f31\nauthor Chris Denton <christophersdenton@gmail.com> 1628205322 +0100\ncommitter Chris Denton <christophersdenton@gmail.com> 1628457090 +0100\n\nImplement modern Windows arg parsing\n\nAs derived from extensive testing of `argv` in a C/C++ application.\n\nCo-Authored-By: Jane Lusby <jlusby42@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e26dda564219341e25589ff745b16258ad424b78", "html_url": "https://github.com/rust-lang/rust/commit/e26dda564219341e25589ff745b16258ad424b78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e26dda564219341e25589ff745b16258ad424b78/comments", "author": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ChrisDenton", "id": 4459874, "node_id": "MDQ6VXNlcjQ0NTk4NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4459874?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ChrisDenton", "html_url": "https://github.com/ChrisDenton", "followers_url": "https://api.github.com/users/ChrisDenton/followers", "following_url": "https://api.github.com/users/ChrisDenton/following{/other_user}", "gists_url": "https://api.github.com/users/ChrisDenton/gists{/gist_id}", "starred_url": "https://api.github.com/users/ChrisDenton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ChrisDenton/subscriptions", "organizations_url": "https://api.github.com/users/ChrisDenton/orgs", "repos_url": "https://api.github.com/users/ChrisDenton/repos", "events_url": "https://api.github.com/users/ChrisDenton/events{/privacy}", "received_events_url": "https://api.github.com/users/ChrisDenton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "565a51973a4f64f522e66c8af87bad339c966f31", "url": "https://api.github.com/repos/rust-lang/rust/commits/565a51973a4f64f522e66c8af87bad339c966f31", "html_url": "https://github.com/rust-lang/rust/commit/565a51973a4f64f522e66c8af87bad339c966f31"}], "stats": {"total": 260, "additions": 154, "deletions": 106}, "files": [{"sha": "4a9405905dc32786d01fb61a8d263b178a7030ac", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e26dda564219341e25589ff745b16258ad424b78/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26dda564219341e25589ff745b16258ad424b78/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=e26dda564219341e25589ff745b16258ad424b78", "patch": "@@ -253,6 +253,7 @@\n #![feature(const_ip)]\n #![feature(const_ipv4)]\n #![feature(const_ipv6)]\n+#![feature(const_option)]\n #![feature(const_raw_ptr_deref)]\n #![feature(const_socketaddr)]\n #![feature(container_error_extra)]"}, {"sha": "3919025b0800663c3b37e749daa27b8ba47915d0", "filename": "library/std/src/sys/windows/args.rs", "status": "modified", "additions": 152, "deletions": 105, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/e26dda564219341e25589ff745b16258ad424b78/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26dda564219341e25589ff745b16258ad424b78/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs?ref=e26dda564219341e25589ff745b16258ad424b78", "patch": "@@ -1,23 +1,30 @@\n-#![allow(dead_code)] // runtime init functions not used during testing\n+//! The Windows command line is just a string\n+//! <https://docs.microsoft.com/en-us/archive/blogs/larryosterman/the-windows-command-line-is-just-a-string>\n+//!\n+//! This module implements the parsing necessary to turn that string into a list of arguments.\n \n #[cfg(test)]\n mod tests;\n \n use crate::ffi::OsString;\n use crate::fmt;\n+use crate::marker::PhantomData;\n+use crate::num::NonZeroU16;\n use crate::os::windows::prelude::*;\n use crate::path::PathBuf;\n-use crate::slice;\n+use crate::ptr::NonNull;\n use crate::sys::c;\n use crate::sys::windows::os::current_exe;\n use crate::vec;\n \n use core::iter;\n \n pub fn args() -> Args {\n+    // SAFETY: `GetCommandLineW` returns a pointer to a null terminated UTF-16\n+    // string so it's safe for `WStrUnits` to use.\n     unsafe {\n         let lp_cmd_line = c::GetCommandLineW();\n-        let parsed_args_list = parse_lp_cmd_line(lp_cmd_line as *const u16, || {\n+        let parsed_args_list = parse_lp_cmd_line(WStrUnits::new(lp_cmd_line), || {\n             current_exe().map(PathBuf::into_os_string).unwrap_or_else(|_| OsString::new())\n         });\n \n@@ -28,129 +35,120 @@ pub fn args() -> Args {\n /// Implements the Windows command-line argument parsing algorithm.\n ///\n /// Microsoft's documentation for the Windows CLI argument format can be found at\n-/// <https://docs.microsoft.com/en-us/previous-versions//17w5ykft(v=vs.85)>.\n+/// <https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=msvc-160#parsing-c-command-line-arguments>\n ///\n-/// Windows includes a function to do this in shell32.dll,\n-/// but linking with that DLL causes the process to be registered as a GUI application.\n+/// A more in-depth explanation is here:\n+/// <https://daviddeley.com/autohotkey/parameters/parameters.htm#WIN>\n+///\n+/// Windows includes a function to do command line parsing in shell32.dll.\n+/// However, this is not used for two reasons:\n+///\n+/// 1. Linking with that DLL causes the process to be registered as a GUI application.\n /// GUI applications add a bunch of overhead, even if no windows are drawn. See\n /// <https://randomascii.wordpress.com/2018/12/03/a-not-called-function-can-cause-a-5x-slowdown/>.\n ///\n-/// This function was tested for equivalence to the shell32.dll implementation in\n-/// Windows 10 Pro v1803, using an exhaustive test suite available at\n-/// <https://gist.github.com/notriddle/dde431930c392e428055b2dc22e638f5> or\n-/// <https://paste.gg/p/anonymous/47d6ed5f5bd549168b1c69c799825223>.\n-unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(\n-    lp_cmd_line: *const u16,\n+/// 2. It does not follow the modern C/C++ argv rules outlined in the first two links above.\n+///\n+/// This function was tested for equivalence to the C/C++ parsing rules using an\n+/// extensive test suite available at\n+/// <https://github.com/ChrisDenton/winarg/tree/std>.\n+fn parse_lp_cmd_line<'a, F: Fn() -> OsString>(\n+    lp_cmd_line: Option<WStrUnits<'a>>,\n     exe_name: F,\n ) -> Vec<OsString> {\n-    const BACKSLASH: u16 = '\\\\' as u16;\n-    const QUOTE: u16 = '\"' as u16;\n-    const TAB: u16 = '\\t' as u16;\n-    const SPACE: u16 = ' ' as u16;\n+    const BACKSLASH: NonZeroU16 = NonZeroU16::new(b'\\\\' as u16).unwrap();\n+    const QUOTE: NonZeroU16 = NonZeroU16::new(b'\"' as u16).unwrap();\n+    const TAB: NonZeroU16 = NonZeroU16::new(b'\\t' as u16).unwrap();\n+    const SPACE: NonZeroU16 = NonZeroU16::new(b' ' as u16).unwrap();\n+\n     let mut ret_val = Vec::new();\n-    if lp_cmd_line.is_null() || *lp_cmd_line == 0 {\n+    // If the cmd line pointer is null or it points to an empty string then\n+    // return the name of the executable as argv[0].\n+    if lp_cmd_line.as_ref().and_then(|cmd| cmd.peek()).is_none() {\n         ret_val.push(exe_name());\n         return ret_val;\n     }\n-    let mut cmd_line = {\n-        let mut end = 0;\n-        while *lp_cmd_line.offset(end) != 0 {\n-            end += 1;\n-        }\n-        slice::from_raw_parts(lp_cmd_line, end as usize)\n-    };\n+    let mut code_units = lp_cmd_line.unwrap();\n+\n     // The executable name at the beginning is special.\n-    cmd_line = match cmd_line[0] {\n-        // The executable name ends at the next quote mark,\n-        // no matter what.\n-        QUOTE => {\n-            let args = {\n-                let mut cut = cmd_line[1..].splitn(2, |&c| c == QUOTE);\n-                if let Some(exe) = cut.next() {\n-                    ret_val.push(OsString::from_wide(exe));\n-                }\n-                cut.next()\n-            };\n-            if let Some(args) = args {\n-                args\n-            } else {\n-                return ret_val;\n-            }\n-        }\n-        // Implement quirk: when they say whitespace here,\n-        // they include the entire ASCII control plane:\n-        // \"However, if lpCmdLine starts with any amount of whitespace, CommandLineToArgvW\n-        // will consider the first argument to be an empty string. Excess whitespace at the\n-        // end of lpCmdLine is ignored.\"\n-        0..=SPACE => {\n-            ret_val.push(OsString::new());\n-            &cmd_line[1..]\n-        }\n-        // The executable name ends at the next whitespace,\n-        // no matter what.\n-        _ => {\n-            let args = {\n-                let mut cut = cmd_line.splitn(2, |&c| c > 0 && c <= SPACE);\n-                if let Some(exe) = cut.next() {\n-                    ret_val.push(OsString::from_wide(exe));\n-                }\n-                cut.next()\n-            };\n-            if let Some(args) = args {\n-                args\n-            } else {\n-                return ret_val;\n-            }\n+    let mut in_quotes = false;\n+    let mut cur = Vec::new();\n+    for w in &mut code_units {\n+        match w {\n+            // A quote mark always toggles `in_quotes` no matter what because\n+            // there are no escape characters when parsing the executable name.\n+            QUOTE => in_quotes = !in_quotes,\n+            // If not `in_quotes` then whitespace ends argv[0].\n+            SPACE | TAB if !in_quotes => break,\n+            // In all other cases the code unit is taken literally.\n+            _ => cur.push(w.get()),\n         }\n-    };\n+    }\n+    // Skip whitespace.\n+    code_units.advance_while(|w| w == SPACE || w == TAB);\n+    ret_val.push(OsString::from_wide(&cur));\n+\n+    // Parse the arguments according to these rules:\n+    // * All code units are taken literally except space, tab, quote and backslash.\n+    // * When not `in_quotes`, space and tab separate arguments. Consecutive spaces and tabs are\n+    // treated as a single separator.\n+    // * A space or tab `in_quotes` is taken literally.\n+    // * A quote toggles `in_quotes` mode unless it's escaped. An escaped quote is taken literally.\n+    // * A quote can be escaped if preceded by an odd number of backslashes.\n+    // * If any number of backslashes is immediately followed by a quote then the number of\n+    // backslashes is halved (rounding down).\n+    // * Backslashes not followed by a quote are all taken literally.\n+    // * If `in_quotes` then a quote can also be escaped using another quote\n+    // (i.e. two consecutive quotes become one literal quote).\n     let mut cur = Vec::new();\n     let mut in_quotes = false;\n-    let mut was_in_quotes = false;\n-    let mut backslash_count: usize = 0;\n-    for &c in cmd_line {\n-        match c {\n-            // backslash\n-            BACKSLASH => {\n-                backslash_count += 1;\n-                was_in_quotes = false;\n+    while let Some(w) = code_units.next() {\n+        match w {\n+            // If not `in_quotes`, a space or tab ends the argument.\n+            SPACE | TAB if !in_quotes => {\n+                ret_val.push(OsString::from_wide(&cur[..]));\n+                cur.truncate(0);\n+\n+                // Skip whitespace.\n+                code_units.advance_while(|w| w == SPACE || w == TAB);\n             }\n-            QUOTE if backslash_count % 2 == 0 => {\n-                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count / 2));\n-                backslash_count = 0;\n-                if was_in_quotes {\n-                    cur.push('\"' as u16);\n-                    was_in_quotes = false;\n+            // Backslashes can escape quotes or backslashes but only if consecutive backslashes are followed by a quote.\n+            BACKSLASH => {\n+                let backslash_count = code_units.advance_while(|w| w == BACKSLASH) + 1;\n+                if code_units.peek() == Some(QUOTE) {\n+                    cur.extend(iter::repeat(BACKSLASH.get()).take(backslash_count / 2));\n+                    // The quote is escaped if there are an odd number of backslashes.\n+                    if backslash_count % 2 == 1 {\n+                        code_units.next();\n+                        cur.push(QUOTE.get());\n+                    }\n                 } else {\n-                    was_in_quotes = in_quotes;\n-                    in_quotes = !in_quotes;\n+                    // If there is no quote on the end then there is no escaping.\n+                    cur.extend(iter::repeat(BACKSLASH.get()).take(backslash_count));\n                 }\n             }\n-            QUOTE if backslash_count % 2 != 0 => {\n-                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count / 2));\n-                backslash_count = 0;\n-                was_in_quotes = false;\n-                cur.push(b'\"' as u16);\n-            }\n-            SPACE | TAB if !in_quotes => {\n-                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n-                if !cur.is_empty() || was_in_quotes {\n-                    ret_val.push(OsString::from_wide(&cur[..]));\n-                    cur.truncate(0);\n+            // If `in_quotes` and not backslash escaped (see above) then a quote either\n+            // unsets `in_quote` or is escaped by another quote.\n+            QUOTE if in_quotes => match code_units.peek() {\n+                // Two consecutive quotes when `in_quotes` produces one literal quote.\n+                Some(QUOTE) => {\n+                    cur.push(QUOTE.get());\n+                    code_units.next();\n                 }\n-                backslash_count = 0;\n-                was_in_quotes = false;\n-            }\n-            _ => {\n-                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n-                backslash_count = 0;\n-                was_in_quotes = false;\n-                cur.push(c);\n-            }\n+                // Otherwise set `in_quotes`.\n+                Some(_) => in_quotes = false,\n+                // The end of the command line.\n+                // Push `cur` even if empty, which we do by breaking while `in_quotes` is still set.\n+                None => break,\n+            },\n+            // If not `in_quotes` and not BACKSLASH escaped (see above) then a quote sets `in_quote`.\n+            QUOTE => in_quotes = true,\n+            // Everything else is always taken literally.\n+            _ => cur.push(w.get()),\n         }\n     }\n-    cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n-    // include empty quoted strings at the end of the arguments list\n-    if !cur.is_empty() || was_in_quotes || in_quotes {\n+    // Push the final argument, if any.\n+    if !cur.is_empty() || in_quotes {\n         ret_val.push(OsString::from_wide(&cur[..]));\n     }\n     ret_val\n@@ -187,3 +185,52 @@ impl ExactSizeIterator for Args {\n         self.parsed_args_list.len()\n     }\n }\n+\n+/// A safe iterator over a LPWSTR\n+/// (aka a pointer to a series of UTF-16 code units terminated by a NULL).\n+struct WStrUnits<'a> {\n+    // The pointer must never be null...\n+    lpwstr: NonNull<u16>,\n+    // ...and the memory it points to must be valid for this lifetime.\n+    lifetime: PhantomData<&'a [u16]>,\n+}\n+impl WStrUnits<'_> {\n+    /// Create the iterator. Returns `None` if `lpwstr` is null.\n+    ///\n+    /// SAFETY: `lpwstr` must point to a null-terminated wide string that lives\n+    /// at least as long as the lifetime of this struct.\n+    unsafe fn new(lpwstr: *const u16) -> Option<Self> {\n+        Some(Self { lpwstr: NonNull::new(lpwstr as _)?, lifetime: PhantomData })\n+    }\n+    fn peek(&self) -> Option<NonZeroU16> {\n+        // SAFETY: It's always safe to read the current item because we don't\n+        // ever move out of the array's bounds.\n+        unsafe { NonZeroU16::new(*self.lpwstr.as_ptr()) }\n+    }\n+    /// Advance the iterator while `predicate` returns true.\n+    /// Returns the number of items it advanced by.\n+    fn advance_while<P: FnMut(NonZeroU16) -> bool>(&mut self, mut predicate: P) -> usize {\n+        let mut counter = 0;\n+        while let Some(w) = self.peek() {\n+            if !predicate(w) {\n+                break;\n+            }\n+            counter += 1;\n+            self.next();\n+        }\n+        counter\n+    }\n+}\n+impl Iterator for WStrUnits<'_> {\n+    // This can never return zero as that marks the end of the string.\n+    type Item = NonZeroU16;\n+    fn next(&mut self) -> Option<NonZeroU16> {\n+        // SAFETY: If NULL is reached we immediately return.\n+        // Therefore it's safe to advance the pointer after that.\n+        unsafe {\n+            let next = self.peek()?;\n+            self.lpwstr = NonNull::new_unchecked(self.lpwstr.as_ptr().add(1));\n+            Some(next)\n+        }\n+    }\n+}"}, {"sha": "023186c7a9067d14aa8be79284117ddbe60a3909", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e26dda564219341e25589ff745b16258ad424b78/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e26dda564219341e25589ff745b16258ad424b78/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=e26dda564219341e25589ff745b16258ad424b78", "patch": "@@ -781,7 +781,7 @@ extern \"system\" {\n     pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n     pub fn SetFileAttributesW(lpFileName: LPCWSTR, dwFileAttributes: DWORD) -> BOOL;\n     pub fn SetLastError(dwErrCode: DWORD);\n-    pub fn GetCommandLineW() -> *mut LPCWSTR;\n+    pub fn GetCommandLineW() -> LPWSTR;\n     pub fn GetTempPathW(nBufferLength: DWORD, lpBuffer: LPCWSTR) -> DWORD;\n     pub fn GetCurrentProcess() -> HANDLE;\n     pub fn GetCurrentThread() -> HANDLE;"}]}