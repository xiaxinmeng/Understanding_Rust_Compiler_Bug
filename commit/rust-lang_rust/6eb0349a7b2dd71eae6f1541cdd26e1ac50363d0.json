{"sha": "6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlYjAzNDlhN2IyZGQ3MWVhZTZmMTU0MWNkZDI2ZTFhYzUwMzYzZDA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-25T22:28:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-25T22:28:48Z"}, "message": "Merge #5068\n\n5068: Prep dynamic reload r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "fe3b2a9c5e1facf36807730129be1a66a827b79a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe3b2a9c5e1facf36807730129be1a66a827b79a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe9SUgCRBK7hj4Ov3rIwAAdHIIACStRNXT7JMAOm/0Mbew2Fqv\nt4mC9VZ3KPcaCASq9YdolbhrOPkncEtoOX3A9yQghM7XvxettpyDQyjfzWnwcTK7\nfVIPmrkHinAL0uf8bi5RX1vavh3+OP49a8FvCVMeq52z0vwlU0iF0AtFDa5L7Ojl\nwCw5rLTME7VDa7NNCE3LKgEyUn92uBkVASanj8ajxTivRATO6igYFQpze8z+/GZi\nxplPvBWkP5PTD/rz6MfXG26kZIOoZDzTAE3bAIB0YXEE6VEkMqcmu81lNszP7zws\n1ekgz0RSZ7Njrt7f3efuI4YXxOLH/h3AJ1j3ZSV+Ig9Hiua2XTujks1jWsoVDBQ=\n=E7Ln\n-----END PGP SIGNATURE-----\n", "payload": "tree fe3b2a9c5e1facf36807730129be1a66a827b79a\nparent 3615347fcebebaa58a5cbf675ae062aae149d9c3\nparent e70f7dc10c622e0ffec4b264235ad203b4047171\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593124128 +0000\ncommitter GitHub <noreply@github.com> 1593124128 +0000\n\nMerge #5068\n\n5068: Prep dynamic reload r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0", "html_url": "https://github.com/rust-lang/rust/commit/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3615347fcebebaa58a5cbf675ae062aae149d9c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/3615347fcebebaa58a5cbf675ae062aae149d9c3", "html_url": "https://github.com/rust-lang/rust/commit/3615347fcebebaa58a5cbf675ae062aae149d9c3"}, {"sha": "e70f7dc10c622e0ffec4b264235ad203b4047171", "url": "https://api.github.com/repos/rust-lang/rust/commits/e70f7dc10c622e0ffec4b264235ad203b4047171", "html_url": "https://github.com/rust-lang/rust/commit/e70f7dc10c622e0ffec4b264235ad203b4047171"}], "stats": {"total": 598, "additions": 309, "deletions": 289}, "files": [{"sha": "b1250f2fe0ab23887346301e1cc4e6ac17b6f93b", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0", "patch": "@@ -9,7 +9,7 @@ use ra_ide::{AnalysisChange, AnalysisHost};\n use ra_project_model::{CargoConfig, ProcMacroClient, ProjectManifest, ProjectWorkspace};\n use vfs::{loader::Handle, AbsPath};\n \n-use crate::global_state::{ProjectFolders, SourceRootConfig};\n+use crate::reload::{ProjectFolders, SourceRootConfig};\n \n pub fn load_cargo(\n     root: &Path,"}, {"sha": "6b17ce18ba05ab01719a1cc20674f880d6ee50d6", "filename": "crates/rust-analyzer/src/config.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fconfig.rs?ref=6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0", "patch": "@@ -30,7 +30,7 @@ pub struct Config {\n \n     pub cargo: CargoConfig,\n     pub rustfmt: RustfmtConfig,\n-    pub check: Option<FlycheckConfig>,\n+    pub flycheck: Option<FlycheckConfig>,\n \n     pub inlay_hints: InlayHintsConfig,\n     pub completion: CompletionConfig,\n@@ -147,7 +147,7 @@ impl Config {\n \n             cargo: CargoConfig::default(),\n             rustfmt: RustfmtConfig::Rustfmt { extra_args: Vec::new() },\n-            check: Some(FlycheckConfig::CargoCommand {\n+            flycheck: Some(FlycheckConfig::CargoCommand {\n                 command: \"check\".to_string(),\n                 all_targets: true,\n                 all_features: false,\n@@ -227,22 +227,22 @@ impl Config {\n \n         if let Some(false) = get(value, \"/checkOnSave/enable\") {\n             // check is disabled\n-            self.check = None;\n+            self.flycheck = None;\n         } else {\n             // check is enabled\n             match get::<Vec<String>>(value, \"/checkOnSave/overrideCommand\") {\n                 // first see if the user has completely overridden the command\n                 Some(mut args) if !args.is_empty() => {\n                     let command = args.remove(0);\n-                    self.check = Some(FlycheckConfig::CustomCommand {\n+                    self.flycheck = Some(FlycheckConfig::CustomCommand {\n                         command,\n                         args,\n                     });\n                 }\n                 // otherwise configure command customizations\n                 _ => {\n                     if let Some(FlycheckConfig::CargoCommand { command, extra_args, all_targets, all_features, features })\n-                        = &mut self.check\n+                        = &mut self.flycheck\n                     {\n                         set(value, \"/checkOnSave/extraArgs\", extra_args);\n                         set(value, \"/checkOnSave/command\", command);"}, {"sha": "891fdb96d1de90976d6aaddc265a76ecdde236ee", "filename": "crates/rust-analyzer/src/dispatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fdispatch.rs?ref=6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0", "patch": "@@ -59,7 +59,7 @@ impl<'a> RequestDispatcher<'a> {\n             }\n         };\n \n-        self.global_state.task_pool.0.spawn({\n+        self.global_state.task_pool.handle.spawn({\n             let world = self.global_state.snapshot();\n             move || {\n                 let result = f(world, params);"}, {"sha": "17de2a075abd2172f89a2589c443cdcc7d3395ac", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 39, "deletions": 188, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0", "patch": "@@ -3,24 +3,25 @@\n //!\n //! Each tick provides an immutable snapshot of the state as `WorldSnapshot`.\n \n-use std::{convert::TryFrom, sync::Arc};\n+use std::sync::Arc;\n \n use crossbeam_channel::{unbounded, Receiver, Sender};\n-use flycheck::{FlycheckConfig, FlycheckHandle};\n+use flycheck::FlycheckHandle;\n use lsp_types::Url;\n use parking_lot::RwLock;\n-use ra_db::{CrateId, SourceRoot, VfsPath};\n-use ra_ide::{Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId};\n+use ra_db::{CrateId, VfsPath};\n+use ra_ide::{Analysis, AnalysisChange, AnalysisHost, FileId};\n use ra_project_model::{CargoWorkspace, ProcMacroClient, ProjectWorkspace, Target};\n use stdx::format_to;\n-use vfs::{file_set::FileSetConfig, loader::Handle, AbsPath, AbsPathBuf};\n+use vfs::loader::Handle as _;\n \n use crate::{\n-    config::{Config, FilesWatcher},\n+    config::Config,\n     diagnostics::{CheckFixes, DiagnosticCollection},\n     from_proto,\n     line_endings::LineEndings,\n     main_loop::{ReqQueue, Task},\n+    reload::SourceRootConfig,\n     request_metrics::{LatestRequests, RequestMetrics},\n     show_message,\n     thread_pool::TaskPool,\n@@ -29,26 +30,6 @@ use crate::{\n };\n use rustc_hash::{FxHashMap, FxHashSet};\n \n-fn create_flycheck(\n-    workspaces: &[ProjectWorkspace],\n-    config: &FlycheckConfig,\n-) -> Option<(FlycheckHandle, Receiver<flycheck::Message>)> {\n-    // FIXME: Figure out the multi-workspace situation\n-    workspaces.iter().find_map(move |w| match w {\n-        ProjectWorkspace::Cargo { cargo, .. } => {\n-            let (sender, receiver) = unbounded();\n-            let sender = Box::new(move |msg| sender.send(msg).unwrap());\n-            let cargo_project_root = cargo.workspace_root().to_path_buf();\n-            let flycheck = FlycheckHandle::spawn(sender, config.clone(), cargo_project_root.into());\n-            Some((flycheck, receiver))\n-        }\n-        ProjectWorkspace::Json { .. } => {\n-            log::warn!(\"Cargo check watching only supported for cargo workspaces, disabling\");\n-            None\n-        }\n-    })\n-}\n-\n #[derive(Eq, PartialEq)]\n pub(crate) enum Status {\n     Loading,\n@@ -61,28 +42,35 @@ impl Default for Status {\n     }\n }\n \n+// Enforces drop order\n+pub(crate) struct Handle<H, C> {\n+    pub(crate) handle: H,\n+    pub(crate) receiver: C,\n+}\n+\n /// `GlobalState` is the primary mutable state of the language server\n ///\n /// The most interesting components are `vfs`, which stores a consistent\n /// snapshot of the file systems, and `analysis_host`, which stores our\n /// incremental salsa database.\n+///\n+/// Note that this struct has more than on impl in various modules!\n pub(crate) struct GlobalState {\n     sender: Sender<lsp_server::Message>,\n+    pub(crate) task_pool: Handle<TaskPool<Task>, Receiver<Task>>,\n+    pub(crate) loader: Handle<Box<dyn vfs::loader::Handle>, Receiver<vfs::loader::Message>>,\n+    pub(crate) flycheck: Option<Handle<FlycheckHandle, Receiver<flycheck::Message>>>,\n     pub(crate) config: Config,\n-    pub(crate) task_pool: (TaskPool<Task>, Receiver<Task>),\n     pub(crate) analysis_host: AnalysisHost,\n-    pub(crate) loader: Box<dyn vfs::loader::Handle>,\n-    pub(crate) task_receiver: Receiver<vfs::loader::Message>,\n-    pub(crate) flycheck: Option<(FlycheckHandle, Receiver<flycheck::Message>)>,\n     pub(crate) diagnostics: DiagnosticCollection,\n     pub(crate) mem_docs: FxHashSet<VfsPath>,\n     pub(crate) vfs: Arc<RwLock<(vfs::Vfs, FxHashMap<FileId, LineEndings>)>>,\n     pub(crate) status: Status,\n     pub(crate) req_queue: ReqQueue,\n+    pub(crate) source_root_config: SourceRootConfig,\n+    pub(crate) proc_macro_client: ProcMacroClient,\n+    pub(crate) workspaces: Arc<Vec<ProjectWorkspace>>,\n     latest_requests: Arc<RwLock<LatestRequests>>,\n-    source_root_config: SourceRootConfig,\n-    _proc_macro_client: ProcMacroClient,\n-    workspaces: Arc<Vec<ProjectWorkspace>>,\n }\n \n /// An immutable snapshot of the world's state at a point in time.\n@@ -98,102 +86,40 @@ pub(crate) struct GlobalStateSnapshot {\n impl GlobalState {\n     pub(crate) fn new(\n         sender: Sender<lsp_server::Message>,\n-        workspaces: Vec<ProjectWorkspace>,\n         lru_capacity: Option<usize>,\n         config: Config,\n-        req_queue: ReqQueue,\n     ) -> GlobalState {\n-        let mut change = AnalysisChange::new();\n-\n-        let project_folders = ProjectFolders::new(&workspaces);\n-\n-        let (task_sender, task_receiver) = unbounded::<vfs::loader::Message>();\n-        let mut vfs = vfs::Vfs::default();\n-\n-        let proc_macro_client = match &config.proc_macro_srv {\n-            None => ProcMacroClient::dummy(),\n-            Some((path, args)) => match ProcMacroClient::extern_process(path.into(), args) {\n-                Ok(it) => it,\n-                Err(err) => {\n-                    log::error!(\n-                        \"Failed to run ra_proc_macro_srv from path {}, error: {:?}\",\n-                        path.display(),\n-                        err\n-                    );\n-                    ProcMacroClient::dummy()\n-                }\n-            },\n+        let loader = {\n+            let (sender, receiver) = unbounded::<vfs::loader::Message>();\n+            let handle =\n+                vfs_notify::NotifyHandle::spawn(Box::new(move |msg| sender.send(msg).unwrap()));\n+            let handle = Box::new(handle) as Box<dyn vfs::loader::Handle>;\n+            Handle { handle, receiver }\n         };\n \n-        let mut loader = {\n-            let loader = vfs_notify::NotifyHandle::spawn(Box::new(move |msg| {\n-                task_sender.send(msg).unwrap()\n-            }));\n-            Box::new(loader)\n-        };\n-        let watch = match config.files.watcher {\n-            FilesWatcher::Client => vec![],\n-            FilesWatcher::Notify => project_folders.watch,\n-        };\n-        loader.set_config(vfs::loader::Config { load: project_folders.load, watch });\n-\n-        // Create crate graph from all the workspaces\n-        let mut crate_graph = CrateGraph::default();\n-        let mut load = |path: &AbsPath| {\n-            let contents = loader.load_sync(path);\n-            let path = vfs::VfsPath::from(path.to_path_buf());\n-            vfs.set_file_contents(path.clone(), contents);\n-            vfs.file_id(&path)\n-        };\n-        for ws in workspaces.iter() {\n-            crate_graph.extend(ws.to_crate_graph(\n-                config.cargo.target.as_deref(),\n-                &proc_macro_client,\n-                &mut load,\n-            ));\n-        }\n-        change.set_crate_graph(crate_graph);\n-\n-        let flycheck = config.check.as_ref().and_then(|c| create_flycheck(&workspaces, c));\n-\n-        let mut analysis_host = AnalysisHost::new(lru_capacity);\n-        analysis_host.apply_change(change);\n-\n         let task_pool = {\n             let (sender, receiver) = unbounded();\n-            (TaskPool::new(sender), receiver)\n+            let handle = TaskPool::new(sender);\n+            Handle { handle, receiver }\n         };\n \n-        let mut res = GlobalState {\n+        GlobalState {\n             sender,\n-            config,\n             task_pool,\n-            analysis_host,\n             loader,\n-            task_receiver,\n-            flycheck,\n+            config,\n+            analysis_host: AnalysisHost::new(lru_capacity),\n+            flycheck: None,\n             diagnostics: Default::default(),\n             mem_docs: FxHashSet::default(),\n-            vfs: Arc::new(RwLock::new((vfs, FxHashMap::default()))),\n+            vfs: Arc::new(RwLock::new((vfs::Vfs::default(), FxHashMap::default()))),\n             status: Status::default(),\n-            req_queue,\n+            req_queue: ReqQueue::default(),\n+            source_root_config: SourceRootConfig::default(),\n+            proc_macro_client: ProcMacroClient::dummy(),\n+            workspaces: Arc::new(Vec::new()),\n             latest_requests: Default::default(),\n-            source_root_config: project_folders.source_root_config,\n-            _proc_macro_client: proc_macro_client,\n-            workspaces: Arc::new(workspaces),\n-        };\n-        res.process_changes();\n-        res\n-    }\n-\n-    pub(crate) fn update_configuration(&mut self, config: Config) {\n-        self.analysis_host.update_lru_capacity(config.lru_capacity);\n-        if config.check != self.config.check {\n-            self.flycheck =\n-                config.check.as_ref().and_then(|it| create_flycheck(&self.workspaces, it));\n         }\n-\n-        self.config = config;\n     }\n \n     pub(crate) fn process_changes(&mut self) -> bool {\n@@ -266,7 +192,7 @@ impl GlobalState {\n             self.send(response.into());\n         }\n     }\n-    pub(crate) fn show_message(&mut self, typ: lsp_types::MessageType, message: String) {\n+    pub(crate) fn show_message(&self, typ: lsp_types::MessageType, message: String) {\n         show_message(typ, message, &self.sender)\n     }\n }\n@@ -343,78 +269,3 @@ pub(crate) fn file_id_to_url(vfs: &vfs::Vfs, id: FileId) -> Url {\n     let path = path.as_path().unwrap();\n     url_from_abs_path(&path)\n }\n-\n-#[derive(Default)]\n-pub(crate) struct ProjectFolders {\n-    pub(crate) load: Vec<vfs::loader::Entry>,\n-    pub(crate) watch: Vec<usize>,\n-    pub(crate) source_root_config: SourceRootConfig,\n-}\n-\n-impl ProjectFolders {\n-    pub(crate) fn new(workspaces: &[ProjectWorkspace]) -> ProjectFolders {\n-        let mut res = ProjectFolders::default();\n-        let mut fsc = FileSetConfig::builder();\n-        let mut local_filesets = vec![];\n-\n-        for root in workspaces.iter().flat_map(|it| it.to_roots()) {\n-            let path = root.path().to_owned();\n-\n-            let mut file_set_roots: Vec<VfsPath> = vec![];\n-\n-            let entry = if root.is_member() {\n-                vfs::loader::Entry::local_cargo_package(path.to_path_buf())\n-            } else {\n-                vfs::loader::Entry::cargo_package_dependency(path.to_path_buf())\n-            };\n-            res.load.push(entry);\n-            if root.is_member() {\n-                res.watch.push(res.load.len() - 1);\n-            }\n-\n-            if let Some(out_dir) = root.out_dir() {\n-                let out_dir = AbsPathBuf::try_from(out_dir.to_path_buf()).unwrap();\n-                res.load.push(vfs::loader::Entry::rs_files_recursively(out_dir.clone()));\n-                if root.is_member() {\n-                    res.watch.push(res.load.len() - 1);\n-                }\n-                file_set_roots.push(out_dir.into());\n-            }\n-            file_set_roots.push(path.to_path_buf().into());\n-\n-            if root.is_member() {\n-                local_filesets.push(fsc.len());\n-            }\n-            fsc.add_file_set(file_set_roots)\n-        }\n-\n-        let fsc = fsc.build();\n-        res.source_root_config = SourceRootConfig { fsc, local_filesets };\n-\n-        res\n-    }\n-}\n-\n-#[derive(Default, Debug)]\n-pub(crate) struct SourceRootConfig {\n-    pub(crate) fsc: FileSetConfig,\n-    pub(crate) local_filesets: Vec<usize>,\n-}\n-\n-impl SourceRootConfig {\n-    pub(crate) fn partition(&self, vfs: &vfs::Vfs) -> Vec<SourceRoot> {\n-        self.fsc\n-            .partition(vfs)\n-            .into_iter()\n-            .enumerate()\n-            .map(|(idx, file_set)| {\n-                let is_local = self.local_filesets.contains(&idx);\n-                if is_local {\n-                    SourceRoot::new_local(file_set)\n-                } else {\n-                    SourceRoot::new_library(file_set)\n-                }\n-            })\n-            .collect()\n-    }\n-}"}, {"sha": "a24dfe58c63bcc6bd128fc60affc73f333a54047", "filename": "crates/rust-analyzer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/crates%2Frust-analyzer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Flib.rs?ref=6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0", "patch": "@@ -18,6 +18,7 @@ macro_rules! eprintln {\n }\n \n mod global_state;\n+mod reload;\n mod main_loop;\n mod dispatch;\n mod handlers;"}, {"sha": "d4879283dc3ff9d0942b389e3afe9debe61921a2", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 21, "deletions": 94, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0", "patch": "@@ -11,17 +11,14 @@ use lsp_types::{notification::Notification as _, request::Request as _};\n use ra_db::VfsPath;\n use ra_ide::{Canceled, FileId};\n use ra_prof::profile;\n-use ra_project_model::{PackageRoot, ProjectWorkspace};\n \n use crate::{\n-    config::{Config, FilesWatcher, LinkedProject},\n+    config::Config,\n     dispatch::{NotificationDispatcher, RequestDispatcher},\n     from_proto,\n     global_state::{file_id_to_url, GlobalState, Status},\n     handlers, lsp_ext,\n-    lsp_utils::{\n-        apply_document_changes, is_canceled, notification_is, notification_new, show_message,\n-    },\n+    lsp_utils::{apply_document_changes, is_canceled, notification_is, notification_new},\n     Result,\n };\n \n@@ -47,81 +44,8 @@ pub fn main_loop(config: Config, connection: Connection) -> Result<()> {\n         SetThreadPriority(thread, thread_priority_above_normal);\n     }\n \n-    let global_state = {\n-        let workspaces = {\n-            if config.linked_projects.is_empty() && config.notifications.cargo_toml_not_found {\n-                show_message(\n-                    lsp_types::MessageType::Error,\n-                    \"rust-analyzer failed to discover workspace\".to_string(),\n-                    &connection.sender,\n-                );\n-            };\n-\n-            config\n-                .linked_projects\n-                .iter()\n-                .filter_map(|project| match project {\n-                    LinkedProject::ProjectManifest(manifest) => {\n-                        ra_project_model::ProjectWorkspace::load(\n-                            manifest.clone(),\n-                            &config.cargo,\n-                            config.with_sysroot,\n-                        )\n-                        .map_err(|err| {\n-                            log::error!(\"failed to load workspace: {:#}\", err);\n-                            show_message(\n-                                lsp_types::MessageType::Error,\n-                                format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n-                                &connection.sender,\n-                            );\n-                        })\n-                        .ok()\n-                    }\n-                    LinkedProject::InlineJsonProject(it) => {\n-                        Some(ra_project_model::ProjectWorkspace::Json { project: it.clone() })\n-                    }\n-                })\n-                .collect::<Vec<_>>()\n-        };\n-\n-        let mut req_queue = ReqQueue::default();\n-\n-        if let FilesWatcher::Client = config.files.watcher {\n-            let registration_options = lsp_types::DidChangeWatchedFilesRegistrationOptions {\n-                watchers: workspaces\n-                    .iter()\n-                    .flat_map(ProjectWorkspace::to_roots)\n-                    .filter(PackageRoot::is_member)\n-                    .map(|root| format!(\"{}/**/*.rs\", root.path().display()))\n-                    .map(|glob_pattern| lsp_types::FileSystemWatcher { glob_pattern, kind: None })\n-                    .collect(),\n-            };\n-            let registration = lsp_types::Registration {\n-                id: \"file-watcher\".to_string(),\n-                method: \"workspace/didChangeWatchedFiles\".to_string(),\n-                register_options: Some(serde_json::to_value(registration_options).unwrap()),\n-            };\n-            let params = lsp_types::RegistrationParams { registrations: vec![registration] };\n-            let request = req_queue.outgoing.register(\n-                lsp_types::request::RegisterCapability::METHOD.to_string(),\n-                params,\n-                DO_NOTHING,\n-            );\n-            connection.sender.send(request.into()).unwrap();\n-        }\n-\n-        GlobalState::new(\n-            connection.sender.clone(),\n-            workspaces,\n-            config.lru_capacity,\n-            config,\n-            req_queue,\n-        )\n-    };\n-\n-    log::info!(\"server initialized, serving requests\");\n-    global_state.run(connection.receiver)?;\n-    Ok(())\n+    GlobalState::new(connection.sender.clone(), config.lru_capacity, config)\n+        .run(connection.receiver)\n }\n \n enum Event {\n@@ -176,36 +100,39 @@ impl GlobalState {\n             recv(inbox) -> msg =>\n                 msg.ok().map(Event::Lsp),\n \n-            recv(self.task_pool.1) -> task =>\n+            recv(self.task_pool.receiver) -> task =>\n                 Some(Event::Task(task.unwrap())),\n \n-            recv(self.task_receiver) -> task =>\n+            recv(self.loader.receiver) -> task =>\n                 Some(Event::Vfs(task.unwrap())),\n \n-            recv(self.flycheck.as_ref().map_or(&never(), |it| &it.1)) -> task =>\n+            recv(self.flycheck.as_ref().map_or(&never(), |it| &it.receiver)) -> task =>\n                 Some(Event::Flycheck(task.unwrap())),\n         }\n     }\n \n     fn run(mut self, inbox: Receiver<lsp_server::Message>) -> Result<()> {\n+        self.reload();\n+\n         while let Some(event) = self.next_event(&inbox) {\n             if let Event::Lsp(lsp_server::Message::Notification(not)) = &event {\n                 if not.method == lsp_types::notification::Exit::METHOD {\n                     return Ok(());\n                 }\n             }\n-            self.loop_turn(event)?\n+            self.handle_event(event)?\n         }\n+\n         Err(\"client exited without proper shutdown sequence\")?\n     }\n \n-    fn loop_turn(&mut self, event: Event) -> Result<()> {\n+    fn handle_event(&mut self, event: Event) -> Result<()> {\n         let loop_start = Instant::now();\n         // NOTE: don't count blocking select! call as a loop-turn time\n-        let _p = profile(\"main_loop_inner/loop-turn\");\n+        let _p = profile(\"GlobalState::handle_event\");\n \n-        log::info!(\"loop turn = {:?}\", event);\n-        let queue_count = self.task_pool.0.len();\n+        log::info!(\"handle_event({:?})\", event);\n+        let queue_count = self.task_pool.handle.len();\n         if queue_count > 0 {\n             log::info!(\"queued count = {}\", queue_count);\n         }\n@@ -306,7 +233,7 @@ impl GlobalState {\n         let state_changed = self.process_changes();\n         if became_ready {\n             if let Some(flycheck) = &self.flycheck {\n-                flycheck.0.update();\n+                flycheck.handle.update();\n             }\n         }\n \n@@ -443,7 +370,7 @@ impl GlobalState {\n                         log::error!(\"orphan DidCloseTextDocument: {}\", path)\n                     }\n                     if let Some(path) = path.as_path() {\n-                        this.loader.invalidate(path.to_path_buf());\n+                        this.loader.handle.invalidate(path.to_path_buf());\n                     }\n                 }\n                 let params = lsp_types::PublishDiagnosticsParams {\n@@ -457,7 +384,7 @@ impl GlobalState {\n             })?\n             .on::<lsp_types::notification::DidSaveTextDocument>(|this, _params| {\n                 if let Some(flycheck) = &this.flycheck {\n-                    flycheck.0.update();\n+                    flycheck.handle.update();\n                 }\n                 Ok(())\n             })?\n@@ -500,7 +427,7 @@ impl GlobalState {\n             .on::<lsp_types::notification::DidChangeWatchedFiles>(|this, params| {\n                 for change in params.changes {\n                     if let Ok(path) = from_proto::abs_path(&change.uri) {\n-                        this.loader.invalidate(path);\n+                        this.loader.handle.invalidate(path);\n                     }\n                 }\n                 Ok(())\n@@ -513,7 +440,7 @@ impl GlobalState {\n         if self.config.publish_diagnostics {\n             let snapshot = self.snapshot();\n             let subscriptions = subscriptions.clone();\n-            self.task_pool.0.spawn(move || {\n+            self.task_pool.handle.spawn(move || {\n                 let diagnostics = subscriptions\n                     .into_iter()\n                     .filter_map(|file_id| {\n@@ -531,7 +458,7 @@ impl GlobalState {\n                 Task::Diagnostics(diagnostics)\n             })\n         }\n-        self.task_pool.0.spawn({\n+        self.task_pool.handle.spawn({\n             let subs = subscriptions;\n             let snap = self.snapshot();\n             move || {"}, {"sha": "a22d3e26234ae81bda8d7f54344246497e388948", "filename": "crates/rust-analyzer/src/reload.rs", "status": "added", "additions": 241, "deletions": 0, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0/crates%2Frust-analyzer%2Fsrc%2Freload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Freload.rs?ref=6eb0349a7b2dd71eae6f1541cdd26e1ac50363d0", "patch": "@@ -0,0 +1,241 @@\n+//! Project loading & configuration updates\n+use std::sync::Arc;\n+\n+use crossbeam_channel::unbounded;\n+use flycheck::FlycheckHandle;\n+use lsp_types::request::Request;\n+use ra_db::{CrateGraph, SourceRoot, VfsPath};\n+use ra_ide::AnalysisChange;\n+use ra_project_model::{PackageRoot, ProcMacroClient, ProjectWorkspace};\n+use vfs::{file_set::FileSetConfig, AbsPath};\n+\n+use crate::{\n+    config::{Config, FilesWatcher, LinkedProject},\n+    global_state::{GlobalState, Handle},\n+};\n+\n+impl GlobalState {\n+    pub(crate) fn update_configuration(&mut self, new_config: Config) {\n+        self.analysis_host.update_lru_capacity(new_config.lru_capacity);\n+        if new_config.flycheck != self.config.flycheck {\n+            self.reload_flycheck();\n+        }\n+        self.config = new_config;\n+    }\n+    pub(crate) fn reload(&mut self) {\n+        let workspaces = {\n+            if self.config.linked_projects.is_empty()\n+                && self.config.notifications.cargo_toml_not_found\n+            {\n+                self.show_message(\n+                    lsp_types::MessageType::Error,\n+                    \"rust-analyzer failed to discover workspace\".to_string(),\n+                );\n+            };\n+\n+            self.config\n+                .linked_projects\n+                .iter()\n+                .filter_map(|project| match project {\n+                    LinkedProject::ProjectManifest(manifest) => {\n+                        ra_project_model::ProjectWorkspace::load(\n+                            manifest.clone(),\n+                            &self.config.cargo,\n+                            self.config.with_sysroot,\n+                        )\n+                        .map_err(|err| {\n+                            log::error!(\"failed to load workspace: {:#}\", err);\n+                            self.show_message(\n+                                lsp_types::MessageType::Error,\n+                                format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n+                            );\n+                        })\n+                        .ok()\n+                    }\n+                    LinkedProject::InlineJsonProject(it) => {\n+                        Some(ra_project_model::ProjectWorkspace::Json { project: it.clone() })\n+                    }\n+                })\n+                .collect::<Vec<_>>()\n+        };\n+\n+        if let FilesWatcher::Client = self.config.files.watcher {\n+            let registration_options = lsp_types::DidChangeWatchedFilesRegistrationOptions {\n+                watchers: workspaces\n+                    .iter()\n+                    .flat_map(ProjectWorkspace::to_roots)\n+                    .filter(PackageRoot::is_member)\n+                    .map(|root| format!(\"{}/**/*.rs\", root.path().display()))\n+                    .map(|glob_pattern| lsp_types::FileSystemWatcher { glob_pattern, kind: None })\n+                    .collect(),\n+            };\n+            let registration = lsp_types::Registration {\n+                id: \"file-watcher\".to_string(),\n+                method: \"workspace/didChangeWatchedFiles\".to_string(),\n+                register_options: Some(serde_json::to_value(registration_options).unwrap()),\n+            };\n+            let params = lsp_types::RegistrationParams { registrations: vec![registration] };\n+            let request = self.req_queue.outgoing.register(\n+                lsp_types::request::RegisterCapability::METHOD.to_string(),\n+                params,\n+                |_, _| (),\n+            );\n+            self.send(request.into());\n+        }\n+\n+        let mut change = AnalysisChange::new();\n+\n+        let project_folders = ProjectFolders::new(&workspaces);\n+\n+        self.proc_macro_client = match &self.config.proc_macro_srv {\n+            None => ProcMacroClient::dummy(),\n+            Some((path, args)) => match ProcMacroClient::extern_process(path.into(), args) {\n+                Ok(it) => it,\n+                Err(err) => {\n+                    log::error!(\n+                        \"Failed to run ra_proc_macro_srv from path {}, error: {:?}\",\n+                        path.display(),\n+                        err\n+                    );\n+                    ProcMacroClient::dummy()\n+                }\n+            },\n+        };\n+        let watch = match self.config.files.watcher {\n+            FilesWatcher::Client => vec![],\n+            FilesWatcher::Notify => project_folders.watch,\n+        };\n+        self.loader.handle.set_config(vfs::loader::Config { load: project_folders.load, watch });\n+\n+        // Create crate graph from all the workspaces\n+        let crate_graph = {\n+            let mut crate_graph = CrateGraph::default();\n+            let vfs = &mut self.vfs.write().0;\n+            let loader = &mut self.loader;\n+            let mut load = |path: &AbsPath| {\n+                let contents = loader.handle.load_sync(path);\n+                let path = vfs::VfsPath::from(path.to_path_buf());\n+                vfs.set_file_contents(path.clone(), contents);\n+                vfs.file_id(&path)\n+            };\n+            for ws in workspaces.iter() {\n+                crate_graph.extend(ws.to_crate_graph(\n+                    self.config.cargo.target.as_deref(),\n+                    &self.proc_macro_client,\n+                    &mut load,\n+                ));\n+            }\n+\n+            crate_graph\n+        };\n+        change.set_crate_graph(crate_graph);\n+\n+        self.source_root_config = project_folders.source_root_config;\n+        self.workspaces = Arc::new(workspaces);\n+\n+        self.analysis_host.apply_change(change);\n+        self.process_changes();\n+        self.reload_flycheck();\n+    }\n+\n+    fn reload_flycheck(&mut self) {\n+        let config = match self.config.flycheck.clone() {\n+            Some(it) => it,\n+            None => {\n+                self.flycheck = None;\n+                return;\n+            }\n+        };\n+\n+        // FIXME: Figure out the multi-workspace situation\n+        self.flycheck = self.workspaces.iter().find_map(move |w| match w {\n+            ProjectWorkspace::Cargo { cargo, .. } => {\n+                let (sender, receiver) = unbounded();\n+                let sender = Box::new(move |msg| sender.send(msg).unwrap());\n+                let cargo_project_root = cargo.workspace_root().to_path_buf();\n+                let handle =\n+                    FlycheckHandle::spawn(sender, config.clone(), cargo_project_root.into());\n+                Some(Handle { handle, receiver })\n+            }\n+            ProjectWorkspace::Json { .. } => {\n+                log::warn!(\"Cargo check watching only supported for cargo workspaces, disabling\");\n+                None\n+            }\n+        })\n+    }\n+}\n+\n+#[derive(Default)]\n+pub(crate) struct ProjectFolders {\n+    pub(crate) load: Vec<vfs::loader::Entry>,\n+    pub(crate) watch: Vec<usize>,\n+    pub(crate) source_root_config: SourceRootConfig,\n+}\n+\n+impl ProjectFolders {\n+    pub(crate) fn new(workspaces: &[ProjectWorkspace]) -> ProjectFolders {\n+        let mut res = ProjectFolders::default();\n+        let mut fsc = FileSetConfig::builder();\n+        let mut local_filesets = vec![];\n+\n+        for root in workspaces.iter().flat_map(|it| it.to_roots()) {\n+            let path = root.path().to_owned();\n+\n+            let mut file_set_roots: Vec<VfsPath> = vec![];\n+\n+            let entry = if root.is_member() {\n+                vfs::loader::Entry::local_cargo_package(path.to_path_buf())\n+            } else {\n+                vfs::loader::Entry::cargo_package_dependency(path.to_path_buf())\n+            };\n+            res.load.push(entry);\n+            if root.is_member() {\n+                res.watch.push(res.load.len() - 1);\n+            }\n+\n+            if let Some(out_dir) = root.out_dir() {\n+                let out_dir = out_dir.to_path_buf();\n+                res.load.push(vfs::loader::Entry::rs_files_recursively(out_dir.clone()));\n+                if root.is_member() {\n+                    res.watch.push(res.load.len() - 1);\n+                }\n+                file_set_roots.push(out_dir.into());\n+            }\n+            file_set_roots.push(path.to_path_buf().into());\n+\n+            if root.is_member() {\n+                local_filesets.push(fsc.len());\n+            }\n+            fsc.add_file_set(file_set_roots)\n+        }\n+\n+        let fsc = fsc.build();\n+        res.source_root_config = SourceRootConfig { fsc, local_filesets };\n+\n+        res\n+    }\n+}\n+\n+#[derive(Default, Debug)]\n+pub(crate) struct SourceRootConfig {\n+    pub(crate) fsc: FileSetConfig,\n+    pub(crate) local_filesets: Vec<usize>,\n+}\n+\n+impl SourceRootConfig {\n+    pub(crate) fn partition(&self, vfs: &vfs::Vfs) -> Vec<SourceRoot> {\n+        self.fsc\n+            .partition(vfs)\n+            .into_iter()\n+            .enumerate()\n+            .map(|(idx, file_set)| {\n+                let is_local = self.local_filesets.contains(&idx);\n+                if is_local {\n+                    SourceRoot::new_local(file_set)\n+                } else {\n+                    SourceRoot::new_library(file_set)\n+                }\n+            })\n+            .collect()\n+    }\n+}"}]}