{"sha": "0f57564f78207946fdb09e0cddc21a55966b1bc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNTc1NjRmNzgyMDc5NDZmZGIwOWUwY2RkYzIxYTU1OTY2YjFiYzU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-12T18:36:36Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-12T18:36:36Z"}, "message": "Merge #1266\n\n1266: Chalk integration / method resolution fixes r=matklad a=flodiebold\n\n - fix impl blocks with unresolved target trait being treated as inherent impls\r\n - add traits from prelude for method resolution, and deduplicate them\r\n - blacklist some traits from being considered in where clauses, namely `Send`, `Sync`, `Sized`, and the `Fn` traits. We don't handle these correctly yet for several reasons, and this makes us much less likely to run into cases where Chalk gets very slow (because these usually only happen if there is no solution, and that's more likely to happen for these traits).\r\n - when there's an errored where clause, return just that one (since it will be always false anyway). This also makes things easier on Chalk ;)\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "e8aa2948b2bb301f453307c35311634cda5de43b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8aa2948b2bb301f453307c35311634cda5de43b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f57564f78207946fdb09e0cddc21a55966b1bc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f57564f78207946fdb09e0cddc21a55966b1bc5", "html_url": "https://github.com/rust-lang/rust/commit/0f57564f78207946fdb09e0cddc21a55966b1bc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f57564f78207946fdb09e0cddc21a55966b1bc5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "02ba107bbf24b1d09e61f76bb64b7355076744c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/02ba107bbf24b1d09e61f76bb64b7355076744c4", "html_url": "https://github.com/rust-lang/rust/commit/02ba107bbf24b1d09e61f76bb64b7355076744c4"}, {"sha": "bc59f83991a6444ff2f2364b0e942e8a82943b6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc59f83991a6444ff2f2364b0e942e8a82943b6d", "html_url": "https://github.com/rust-lang/rust/commit/bc59f83991a6444ff2f2364b0e942e8a82943b6d"}], "stats": {"total": 109, "additions": 83, "deletions": 26}, "files": [{"sha": "2fb219908e1dbc46ddc0ff7eed92f462db9fbe7c", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0f57564f78207946fdb09e0cddc21a55966b1bc5/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f57564f78207946fdb09e0cddc21a55966b1bc5/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=0f57564f78207946fdb09e0cddc21a55966b1bc5", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n \n use ra_syntax::ast;\n \n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     ModuleDef, Trait,\n@@ -193,19 +193,18 @@ impl Resolver {\n         names\n     }\n \n-    pub(crate) fn traits_in_scope<'a>(&'a self) -> impl Iterator<Item = Trait> + 'a {\n-        // FIXME prelude\n-        self.scopes\n-            .iter()\n-            .rev()\n-            .flat_map(|scope| {\n-                match scope {\n-                    Scope::ModuleScope(m) => Some(m.crate_def_map[m.module_id].scope.traits()),\n-                    _ => None,\n+    pub(crate) fn traits_in_scope(&self, db: &impl HirDatabase) -> FxHashSet<Trait> {\n+        let mut traits = FxHashSet::default();\n+        for scope in &self.scopes {\n+            if let Scope::ModuleScope(m) = scope {\n+                if let Some(prelude) = m.crate_def_map.prelude() {\n+                    let prelude_def_map = db.crate_def_map(prelude.krate);\n+                    traits.extend(prelude_def_map[prelude.module_id].scope.traits());\n                 }\n-                .into_iter()\n-            })\n-            .flatten()\n+                traits.extend(m.crate_def_map[m.module_id].scope.traits());\n+            }\n+        }\n+        traits\n     }\n \n     fn module(&self) -> Option<(&CrateDefMap, CrateModuleId)> {"}, {"sha": "34817a5ecd5c9b37fac5562d380f566ffd6889f6", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f57564f78207946fdb09e0cddc21a55966b1bc5/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f57564f78207946fdb09e0cddc21a55966b1bc5/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=0f57564f78207946fdb09e0cddc21a55966b1bc5", "patch": "@@ -75,11 +75,13 @@ impl CrateImplBlocks {\n \n             let target_ty = impl_block.target_ty(db);\n \n-            if let Some(tr) = impl_block.target_trait_ref(db) {\n-                self.impls_by_trait\n-                    .entry(tr.trait_)\n-                    .or_insert_with(Vec::new)\n-                    .push((module.module_id, impl_id));\n+            if impl_block.target_trait(db).is_some() {\n+                if let Some(tr) = impl_block.target_trait_ref(db) {\n+                    self.impls_by_trait\n+                        .entry(tr.trait_)\n+                        .or_insert_with(Vec::new)\n+                        .push((module.module_id, impl_id));\n+                }\n             } else {\n                 if let Some(target_ty_fp) = TyFingerprint::for_impl(&target_ty) {\n                     self.impls\n@@ -183,7 +185,7 @@ fn iterate_trait_method_candidates<T>(\n     mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n ) -> Option<T> {\n     let krate = resolver.krate()?;\n-    'traits: for t in resolver.traits_in_scope() {\n+    'traits: for t in resolver.traits_in_scope(db) {\n         let data = t.trait_data(db);\n         // we'll be lazy about checking whether the type implements the\n         // trait, but if we find out it doesn't, we'll skip the rest of the"}, {"sha": "978cc2587fa2f6fca526cb6fa72a3c2e9e25ea05", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0f57564f78207946fdb09e0cddc21a55966b1bc5/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f57564f78207946fdb09e0cddc21a55966b1bc5/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=0f57564f78207946fdb09e0cddc21a55966b1bc5", "patch": "@@ -2501,6 +2501,35 @@ fn test() { (&S).foo()<|>; }\n     assert_eq!(t, \"u128\");\n }\n \n+#[test]\n+fn method_resolution_trait_from_prelude() {\n+    let (mut db, pos) = MockDatabase::with_position(\n+        r#\"\n+//- /main.rs\n+struct S;\n+impl Clone for S {}\n+\n+fn test() {\n+    S.clone()<|>;\n+}\n+\n+//- /lib.rs\n+#[prelude_import] use foo::*;\n+\n+mod foo {\n+    trait Clone {\n+        fn clone(&self) -> Self;\n+    }\n+}\n+\"#,\n+    );\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", [\"other_crate\"]),\n+        \"other_crate\": (\"/lib.rs\", []),\n+    });\n+    assert_eq!(\"S\", type_at_pos(&db, pos));\n+}\n+\n #[test]\n fn method_resolution_where_clause_for_unknown_trait() {\n     // The blanket impl shouldn't apply because we can't even resolve UnknownTrait\n@@ -2620,22 +2649,22 @@ fn method_resolution_slow() {\n     let t = type_at(\n         r#\"\n //- /main.rs\n-trait Send {}\n+trait SendX {}\n \n-struct S1; impl Send for S1;\n-struct S2; impl Send for S2;\n+struct S1; impl SendX for S1;\n+struct S2; impl SendX for S2;\n struct U1;\n \n trait Trait { fn method(self); }\n \n struct X1<A, B> {}\n-impl<A, B> Send for X1<A, B> where A: Send, B: Send {}\n+impl<A, B> SendX for X1<A, B> where A: SendX, B: SendX {}\n \n struct S<B, C> {}\n \n-trait Fn {}\n+trait FnX {}\n \n-impl<B, C> Trait for S<B, C> where C: Fn, B: Send {}\n+impl<B, C> Trait for S<B, C> where C: FnX, B: SendX {}\n \n fn test() { (S {}).method()<|>; }\n \"#,"}, {"sha": "78440b258bcaf2f1311fc67576087dd794dd9adc", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f57564f78207946fdb09e0cddc21a55966b1bc5/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f57564f78207946fdb09e0cddc21a55966b1bc5/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=0f57564f78207946fdb09e0cddc21a55966b1bc5", "patch": "@@ -190,6 +190,14 @@ fn make_binders<T>(value: T, num_vars: usize) -> chalk_ir::Binders<T> {\n     }\n }\n \n+fn blacklisted_trait(db: &impl HirDatabase, trait_: Trait) -> bool {\n+    let name = trait_.name(db).unwrap_or_else(crate::Name::missing).to_string();\n+    match &*name {\n+        \"Send\" | \"Sync\" | \"Sized\" | \"Fn\" | \"FnMut\" | \"FnOnce\" => true,\n+        _ => false,\n+    }\n+}\n+\n fn convert_where_clauses(\n     db: &impl HirDatabase,\n     def: GenericDef,\n@@ -198,6 +206,19 @@ fn convert_where_clauses(\n     let generic_predicates = db.generic_predicates(def);\n     let mut result = Vec::with_capacity(generic_predicates.len());\n     for pred in generic_predicates.iter() {\n+        if pred.is_error() {\n+            // HACK: Return just the single predicate (which is always false\n+            // anyway), otherwise Chalk can easily get into slow situations\n+            return vec![pred.clone().subst(substs).to_chalk(db)];\n+        }\n+        match pred {\n+            GenericPredicate::Implemented(trait_ref) => {\n+                if blacklisted_trait(db, trait_ref.trait_) {\n+                    continue;\n+                }\n+            }\n+            _ => {}\n+        }\n         result.push(pred.clone().subst(substs).to_chalk(db));\n     }\n     result\n@@ -230,6 +251,7 @@ where\n             return Arc::new(TraitDatum { binders: make_binders(trait_datum_bound, 1) });\n         }\n         let trait_: Trait = from_chalk(self.db, trait_id);\n+        debug!(\"trait {:?} = {:?}\", trait_id, trait_.name(self.db));\n         let generic_params = trait_.generic_params(self.db);\n         let bound_vars = Substs::bound_vars(&generic_params);\n         let trait_ref = trait_.trait_ref(self.db).subst(&bound_vars).to_chalk(self.db);\n@@ -250,6 +272,7 @@ where\n     fn struct_datum(&self, struct_id: chalk_ir::StructId) -> Arc<StructDatum> {\n         debug!(\"struct_datum {:?}\", struct_id);\n         let type_ctor = from_chalk(self.db, struct_id);\n+        debug!(\"struct {:?} = {:?}\", struct_id, type_ctor);\n         // FIXME might be nicer if we can create a fake GenericParams for the TypeCtor\n         // FIXME extract this to a method on Ty\n         let (num_params, where_clauses, upstream) = match type_ctor {\n@@ -358,7 +381,11 @@ where\n         if trait_id == UNKNOWN_TRAIT {\n             return Vec::new();\n         }\n-        let trait_ = from_chalk(self.db, trait_id);\n+        let trait_: Trait = from_chalk(self.db, trait_id);\n+        let blacklisted = blacklisted_trait(self.db, trait_);\n+        if blacklisted {\n+            return Vec::new();\n+        }\n         let result: Vec<_> = self\n             .db\n             .impls_for_trait(self.krate, trait_)"}]}