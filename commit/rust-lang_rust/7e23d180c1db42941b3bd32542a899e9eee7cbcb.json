{"sha": "7e23d180c1db42941b3bd32542a899e9eee7cbcb", "node_id": "C_kwDOAAsO6NoAKDdlMjNkMTgwYzFkYjQyOTQxYjNiZDMyNTQyYTg5OWU5ZWVlN2NiY2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-20T10:46:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-20T10:46:13Z"}, "message": "Auto merge of #109993 - scottmcm:transmute-niches, r=oli-obk\n\n`assume` value ranges in `transmute`\n\nFixes #109958", "tree": {"sha": "5e7cc488177b0c0d49221cb75f0d89d291946de2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e7cc488177b0c0d49221cb75f0d89d291946de2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e23d180c1db42941b3bd32542a899e9eee7cbcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e23d180c1db42941b3bd32542a899e9eee7cbcb", "html_url": "https://github.com/rust-lang/rust/commit/7e23d180c1db42941b3bd32542a899e9eee7cbcb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e23d180c1db42941b3bd32542a899e9eee7cbcb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "url": "https://api.github.com/repos/rust-lang/rust/commits/13fc33e3f299f475a0c64d9a5f052bedf3eccc11", "html_url": "https://github.com/rust-lang/rust/commit/13fc33e3f299f475a0c64d9a5f052bedf3eccc11"}, {"sha": "baf98e7515c4736821f99a263e777fd4a7f18cbf", "url": "https://api.github.com/repos/rust-lang/rust/commits/baf98e7515c4736821f99a263e777fd4a7f18cbf", "html_url": "https://github.com/rust-lang/rust/commit/baf98e7515c4736821f99a263e777fd4a7f18cbf"}], "stats": {"total": 387, "additions": 371, "deletions": 16}, "files": [{"sha": "bd11d47500a55474168b33162cb90a5374ebd8c9", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 67, "deletions": 5, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7e23d180c1db42941b3bd32542a899e9eee7cbcb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e23d180c1db42941b3bd32542a899e9eee7cbcb/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=7e23d180c1db42941b3bd32542a899e9eee7cbcb", "patch": "@@ -12,6 +12,7 @@ use rustc_middle::mir::Operand;\n use rustc_middle::ty::cast::{CastTy, IntTy};\n use rustc_middle::ty::layout::{HasTyCtxt, LayoutOf, TyAndLayout};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, Ty, TyCtxt};\n+use rustc_session::config::OptLevel;\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_target::abi::{self, FIRST_VARIANT};\n \n@@ -231,10 +232,16 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         (ScalarOrZst::Scalar(in_scalar), ScalarOrZst::Scalar(out_scalar))\n                             if in_scalar.size(self.cx) == out_scalar.size(self.cx) =>\n                         {\n+                            let operand_bty = bx.backend_type(operand.layout);\n                             let cast_bty = bx.backend_type(cast);\n-                            Some(OperandValue::Immediate(\n-                                self.transmute_immediate(bx, imm, in_scalar, out_scalar, cast_bty),\n-                            ))\n+                            Some(OperandValue::Immediate(self.transmute_immediate(\n+                                bx,\n+                                imm,\n+                                in_scalar,\n+                                operand_bty,\n+                                out_scalar,\n+                                cast_bty,\n+                            )))\n                         }\n                         _ => None,\n                     }\n@@ -250,11 +257,13 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     && in_a.size(self.cx) == out_a.size(self.cx)\n                     && in_b.size(self.cx) == out_b.size(self.cx)\n                 {\n+                    let in_a_ibty = bx.scalar_pair_element_backend_type(operand.layout, 0, false);\n+                    let in_b_ibty = bx.scalar_pair_element_backend_type(operand.layout, 1, false);\n                     let out_a_ibty = bx.scalar_pair_element_backend_type(cast, 0, false);\n                     let out_b_ibty = bx.scalar_pair_element_backend_type(cast, 1, false);\n                     Some(OperandValue::Pair(\n-                        self.transmute_immediate(bx, imm_a, in_a, out_a, out_a_ibty),\n-                        self.transmute_immediate(bx, imm_b, in_b, out_b, out_b_ibty),\n+                        self.transmute_immediate(bx, imm_a, in_a, in_a_ibty, out_a, out_a_ibty),\n+                        self.transmute_immediate(bx, imm_b, in_b, in_b_ibty, out_b, out_b_ibty),\n                     ))\n                 } else {\n                     None\n@@ -273,13 +282,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx: &mut Bx,\n         mut imm: Bx::Value,\n         from_scalar: abi::Scalar,\n+        from_backend_ty: Bx::Type,\n         to_scalar: abi::Scalar,\n         to_backend_ty: Bx::Type,\n     ) -> Bx::Value {\n         debug_assert_eq!(from_scalar.size(self.cx), to_scalar.size(self.cx));\n \n         use abi::Primitive::*;\n         imm = bx.from_immediate(imm);\n+\n+        // When scalars are passed by value, there's no metadata recording their\n+        // valid ranges. For example, `char`s are passed as just `i32`, with no\n+        // way for LLVM to know that they're 0x10FFFF at most. Thus we assume\n+        // the range of the input value too, not just the output range.\n+        self.assume_scalar_range(bx, imm, from_scalar, from_backend_ty);\n+\n         imm = match (from_scalar.primitive(), to_scalar.primitive()) {\n             (Int(..) | F32 | F64, Int(..) | F32 | F64) => bx.bitcast(imm, to_backend_ty),\n             (Pointer(..), Pointer(..)) => bx.pointercast(imm, to_backend_ty),\n@@ -294,10 +311,55 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 bx.bitcast(int_imm, to_backend_ty)\n             }\n         };\n+        self.assume_scalar_range(bx, imm, to_scalar, to_backend_ty);\n         imm = bx.to_immediate_scalar(imm, to_scalar);\n         imm\n     }\n \n+    fn assume_scalar_range(\n+        &self,\n+        bx: &mut Bx,\n+        imm: Bx::Value,\n+        scalar: abi::Scalar,\n+        backend_ty: Bx::Type,\n+    ) {\n+        if matches!(self.cx.sess().opts.optimize, OptLevel::No | OptLevel::Less)\n+            // For now, the critical niches are all over `Int`eger values.\n+            // Should floating-point values or pointers ever get more complex\n+            // niches, then this code will probably want to handle them too.\n+            || !matches!(scalar.primitive(), abi::Primitive::Int(..))\n+            || scalar.is_always_valid(self.cx)\n+        {\n+            return;\n+        }\n+\n+        let abi::WrappingRange { start, end } = scalar.valid_range(self.cx);\n+\n+        if start <= end {\n+            if start > 0 {\n+                let low = bx.const_uint_big(backend_ty, start);\n+                let cmp = bx.icmp(IntPredicate::IntUGE, imm, low);\n+                bx.assume(cmp);\n+            }\n+\n+            let type_max = scalar.size(self.cx).unsigned_int_max();\n+            if end < type_max {\n+                let high = bx.const_uint_big(backend_ty, end);\n+                let cmp = bx.icmp(IntPredicate::IntULE, imm, high);\n+                bx.assume(cmp);\n+            }\n+        } else {\n+            let low = bx.const_uint_big(backend_ty, start);\n+            let cmp_low = bx.icmp(IntPredicate::IntUGE, imm, low);\n+\n+            let high = bx.const_uint_big(backend_ty, end);\n+            let cmp_high = bx.icmp(IntPredicate::IntULE, imm, high);\n+\n+            let or = bx.or(cmp_low, cmp_high);\n+            bx.assume(or);\n+        }\n+    }\n+\n     pub fn codegen_rvalue_unsized(\n         &mut self,\n         bx: &mut Bx,"}, {"sha": "69e9b1d12062ea8f1d9178039331d82fb7ff58b6", "filename": "tests/codegen/intrinsics/transmute-niched.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/7e23d180c1db42941b3bd32542a899e9eee7cbcb/tests%2Fcodegen%2Fintrinsics%2Ftransmute-niched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e23d180c1db42941b3bd32542a899e9eee7cbcb/tests%2Fcodegen%2Fintrinsics%2Ftransmute-niched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute-niched.rs?ref=7e23d180c1db42941b3bd32542a899e9eee7cbcb", "patch": "@@ -0,0 +1,184 @@\n+// revisions: OPT DBG\n+// [OPT] compile-flags: -C opt-level=3 -C no-prepopulate-passes\n+// [DBG] compile-flags: -C opt-level=0 -C no-prepopulate-passes\n+// only-64bit (so I don't need to worry about usize)\n+// min-llvm-version: 15.0 # this test assumes `ptr`s\n+\n+#![crate_type = \"lib\"]\n+\n+use std::mem::transmute;\n+use std::num::NonZeroU32;\n+\n+#[repr(u8)]\n+pub enum SmallEnum {\n+    A = 10,\n+    B = 11,\n+    C = 12,\n+}\n+\n+// CHECK-LABEL: @check_to_enum(\n+#[no_mangle]\n+pub unsafe fn check_to_enum(x: i8) -> SmallEnum {\n+    // OPT: %0 = icmp uge i8 %x, 10\n+    // OPT: call void @llvm.assume(i1 %0)\n+    // OPT: %1 = icmp ule i8 %x, 12\n+    // OPT: call void @llvm.assume(i1 %1)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: ret i8 %x\n+\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_from_enum(\n+#[no_mangle]\n+pub unsafe fn check_from_enum(x: SmallEnum) -> i8 {\n+    // OPT: %0 = icmp uge i8 %x, 10\n+    // OPT: call void @llvm.assume(i1 %0)\n+    // OPT: %1 = icmp ule i8 %x, 12\n+    // OPT: call void @llvm.assume(i1 %1)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: ret i8 %x\n+\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_to_ordering(\n+#[no_mangle]\n+pub unsafe fn check_to_ordering(x: u8) -> std::cmp::Ordering {\n+    // OPT: %0 = icmp uge i8 %x, -1\n+    // OPT: %1 = icmp ule i8 %x, 1\n+    // OPT: %2 = or i1 %0, %1\n+    // OPT: call void @llvm.assume(i1 %2)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: ret i8 %x\n+\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_from_ordering(\n+#[no_mangle]\n+pub unsafe fn check_from_ordering(x: std::cmp::Ordering) -> u8 {\n+    // OPT: %0 = icmp uge i8 %x, -1\n+    // OPT: %1 = icmp ule i8 %x, 1\n+    // OPT: %2 = or i1 %0, %1\n+    // OPT: call void @llvm.assume(i1 %2)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: ret i8 %x\n+\n+    transmute(x)\n+}\n+\n+#[repr(i32)]\n+pub enum Minus100ToPlus100 {\n+    A = -100,\n+    B = -90,\n+    C = -80,\n+    D = -70,\n+    E = -60,\n+    F = -50,\n+    G = -40,\n+    H = -30,\n+    I = -20,\n+    J = -10,\n+    K = 0,\n+    L = 10,\n+    M = 20,\n+    N = 30,\n+    O = 40,\n+    P = 50,\n+    Q = 60,\n+    R = 70,\n+    S = 80,\n+    T = 90,\n+    U = 100,\n+}\n+\n+// CHECK-LABEL: @check_enum_from_char(\n+#[no_mangle]\n+pub unsafe fn check_enum_from_char(x: char) -> Minus100ToPlus100 {\n+    // OPT: %0 = icmp ule i32 %x, 1114111\n+    // OPT: call void @llvm.assume(i1 %0)\n+    // OPT: %1 = icmp uge i32 %x, -100\n+    // OPT: %2 = icmp ule i32 %x, 100\n+    // OPT: %3 = or i1 %1, %2\n+    // OPT: call void @llvm.assume(i1 %3)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: ret i32 %x\n+\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_enum_to_char(\n+#[no_mangle]\n+pub unsafe fn check_enum_to_char(x: Minus100ToPlus100) -> char {\n+    // OPT: %0 = icmp uge i32 %x, -100\n+    // OPT: %1 = icmp ule i32 %x, 100\n+    // OPT: %2 = or i1 %0, %1\n+    // OPT: call void @llvm.assume(i1 %2)\n+    // OPT: %3 = icmp ule i32 %x, 1114111\n+    // OPT: call void @llvm.assume(i1 %3)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: ret i32 %x\n+\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_swap_pair(\n+#[no_mangle]\n+pub unsafe fn check_swap_pair(x: (char, NonZeroU32)) -> (NonZeroU32, char) {\n+    // OPT: %0 = icmp ule i32 %x.0, 1114111\n+    // OPT: call void @llvm.assume(i1 %0)\n+    // OPT: %1 = icmp uge i32 %x.0, 1\n+    // OPT: call void @llvm.assume(i1 %1)\n+    // OPT: %2 = icmp uge i32 %x.1, 1\n+    // OPT: call void @llvm.assume(i1 %2)\n+    // OPT: %3 = icmp ule i32 %x.1, 1114111\n+    // OPT: call void @llvm.assume(i1 %3)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: %[[P1:.+]] = insertvalue { i32, i32 } poison, i32 %x.0, 0\n+    // CHECK: %[[P2:.+]] = insertvalue { i32, i32 } %[[P1]], i32 %x.1, 1\n+    // CHECK: ret { i32, i32 } %[[P2]]\n+\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_bool_from_ordering(\n+#[no_mangle]\n+pub unsafe fn check_bool_from_ordering(x: std::cmp::Ordering) -> bool {\n+    // OPT: %0 = icmp uge i8 %x, -1\n+    // OPT: %1 = icmp ule i8 %x, 1\n+    // OPT: %2 = or i1 %0, %1\n+    // OPT: call void @llvm.assume(i1 %2)\n+    // OPT: %3 = icmp ule i8 %x, 1\n+    // OPT: call void @llvm.assume(i1 %3)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: %[[R:.+]] = trunc i8 %x to i1\n+    // CHECK: ret i1 %[[R]]\n+\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_bool_to_ordering(\n+#[no_mangle]\n+pub unsafe fn check_bool_to_ordering(x: bool) -> std::cmp::Ordering {\n+    // CHECK: %0 = zext i1 %x to i8\n+    // OPT: %1 = icmp ule i8 %0, 1\n+    // OPT: call void @llvm.assume(i1 %1)\n+    // OPT: %2 = icmp uge i8 %0, -1\n+    // OPT: %3 = icmp ule i8 %0, 1\n+    // OPT: %4 = or i1 %2, %3\n+    // OPT: call void @llvm.assume(i1 %4)\n+    // DBG-NOT: icmp\n+    // DBG-NOT: assume\n+    // CHECK: ret i8 %0\n+\n+    transmute(x)\n+}"}, {"sha": "51c000b82ea8ae89b4afa447ad70cfc4ed904ccc", "filename": "tests/codegen/intrinsics/transmute.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e23d180c1db42941b3bd32542a899e9eee7cbcb/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e23d180c1db42941b3bd32542a899e9eee7cbcb/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs?ref=7e23d180c1db42941b3bd32542a899e9eee7cbcb", "patch": "@@ -169,17 +169,17 @@ pub unsafe fn check_aggregate_from_bool(x: bool) -> Aggregate8 {\n #[no_mangle]\n pub unsafe fn check_byte_to_bool(x: u8) -> bool {\n     // CHECK-NOT: alloca\n-    // CHECK: %0 = trunc i8 %x to i1\n-    // CHECK: ret i1 %0\n+    // CHECK: %[[R:.+]] = trunc i8 %x to i1\n+    // CHECK: ret i1 %[[R]]\n     transmute(x)\n }\n \n // CHECK-LABEL: @check_byte_from_bool(\n #[no_mangle]\n pub unsafe fn check_byte_from_bool(x: bool) -> u8 {\n     // CHECK-NOT: alloca\n-    // CHECK: %0 = zext i1 %x to i8\n-    // CHECK: ret i8 %0\n+    // CHECK: %[[R:.+]] = zext i1 %x to i8\n+    // CHECK: ret i8 %[[R:.+]]\n     transmute(x)\n }\n "}, {"sha": "461dd550cd7e879c1cb7d49787bd12404710bab1", "filename": "tests/codegen/transmute-optimized.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/7e23d180c1db42941b3bd32542a899e9eee7cbcb/tests%2Fcodegen%2Ftransmute-optimized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e23d180c1db42941b3bd32542a899e9eee7cbcb/tests%2Fcodegen%2Ftransmute-optimized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ftransmute-optimized.rs?ref=7e23d180c1db42941b3bd32542a899e9eee7cbcb", "patch": "@@ -0,0 +1,109 @@\n+// compile-flags: -O -Z merge-functions=disabled\n+// min-llvm-version: 15.0 # this test uses `ptr`s\n+// ignore-debug\n+\n+#![crate_type = \"lib\"]\n+\n+// This tests that LLVM can optimize based on the niches in the source or\n+// destination types for transmutes.\n+\n+#[repr(u32)]\n+pub enum AlwaysZero32 { X = 0 }\n+\n+// CHECK-LABEL: i32 @issue_109958(i32\n+#[no_mangle]\n+pub fn issue_109958(x: AlwaysZero32) -> i32 {\n+    // CHECK: ret i32 0\n+    unsafe { std::mem::transmute(x) }\n+}\n+\n+// CHECK-LABEL: i1 @reference_is_null(ptr\n+#[no_mangle]\n+pub fn reference_is_null(x: &i32) -> bool {\n+    // CHECK: ret i1 false\n+    let p: *const i32 = unsafe { std::mem::transmute(x) };\n+    p.is_null()\n+}\n+\n+// CHECK-LABEL: i1 @non_null_is_null(ptr\n+#[no_mangle]\n+pub fn non_null_is_null(x: std::ptr::NonNull<i32>) -> bool {\n+    // CHECK: ret i1 false\n+    let p: *const i32 = unsafe { std::mem::transmute(x) };\n+    p.is_null()\n+}\n+\n+// CHECK-LABEL: i1 @non_zero_is_null(\n+#[no_mangle]\n+pub fn non_zero_is_null(x: std::num::NonZeroUsize) -> bool {\n+    // CHECK: ret i1 false\n+    let p: *const i32 = unsafe { std::mem::transmute(x) };\n+    p.is_null()\n+}\n+\n+// CHECK-LABEL: i1 @non_null_is_zero(ptr\n+#[no_mangle]\n+pub fn non_null_is_zero(x: std::ptr::NonNull<i32>) -> bool {\n+    // CHECK: ret i1 false\n+    let a: isize = unsafe { std::mem::transmute(x) };\n+    a == 0\n+}\n+\n+// CHECK-LABEL: i1 @bool_ordering_is_ge(i1\n+#[no_mangle]\n+pub fn bool_ordering_is_ge(x: bool) -> bool {\n+    // CHECK: ret i1 true\n+    let y: std::cmp::Ordering = unsafe { std::mem::transmute(x) };\n+    y.is_ge()\n+}\n+\n+// CHECK-LABEL: i1 @ordering_is_ge_then_transmute_to_bool(i8\n+#[no_mangle]\n+pub fn ordering_is_ge_then_transmute_to_bool(x: std::cmp::Ordering) -> bool {\n+    let r = x.is_ge();\n+    let _: bool = unsafe { std::mem::transmute(x) };\n+    r\n+}\n+\n+// CHECK-LABEL: i32 @normal_div(i32\n+#[no_mangle]\n+pub fn normal_div(a: u32, b: u32) -> u32 {\n+    // CHECK: call core::panicking::panic\n+    a / b\n+}\n+\n+// CHECK-LABEL: i32 @div_transmute_nonzero(i32\n+#[no_mangle]\n+pub fn div_transmute_nonzero(a: u32, b: std::num::NonZeroI32) -> u32 {\n+    // CHECK-NOT: call core::panicking::panic\n+    // CHECK: %[[R:.+]] = udiv i32 %a, %b\n+    // CHECK-NEXT: ret i32 %[[R]]\n+    // CHECK-NOT: call core::panicking::panic\n+    let d: u32 = unsafe { std::mem::transmute(b) };\n+    a / d\n+}\n+\n+#[repr(i8)]\n+pub enum OneTwoThree { One = 1, Two = 2, Three = 3 }\n+\n+// CHECK-LABEL: i8 @ordering_transmute_onetwothree(i8\n+#[no_mangle]\n+pub unsafe fn ordering_transmute_onetwothree(x: std::cmp::Ordering) -> OneTwoThree {\n+    // CHECK: ret i8 1\n+    std::mem::transmute(x)\n+}\n+\n+// CHECK-LABEL: i8 @onetwothree_transmute_ordering(i8\n+#[no_mangle]\n+pub unsafe fn onetwothree_transmute_ordering(x: OneTwoThree) -> std::cmp::Ordering {\n+    // CHECK: ret i8 1\n+    std::mem::transmute(x)\n+}\n+\n+// CHECK-LABEL: i1 @char_is_negative(i32\n+#[no_mangle]\n+pub fn char_is_negative(c: char) -> bool {\n+    // CHECK: ret i1 false\n+    let x: i32 = unsafe { std::mem::transmute(c) };\n+    x < 0\n+}"}, {"sha": "a0894a505c7c6330c2a5dda3f953635fa6de9237", "filename": "tests/codegen/transmute-scalar.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e23d180c1db42941b3bd32542a899e9eee7cbcb/tests%2Fcodegen%2Ftransmute-scalar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e23d180c1db42941b3bd32542a899e9eee7cbcb/tests%2Fcodegen%2Ftransmute-scalar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Ftransmute-scalar.rs?ref=7e23d180c1db42941b3bd32542a899e9eee7cbcb", "patch": "@@ -1,4 +1,4 @@\n-// compile-flags: -O -C no-prepopulate-passes\n+// compile-flags: -C opt-level=0 -C no-prepopulate-passes\n // min-llvm-version: 15.0 # this test assumes `ptr`s and thus no `pointercast`s\n \n #![crate_type = \"lib\"]\n@@ -10,46 +10,46 @@\n // However, `bitcast`s and `ptrtoint`s and `inttoptr`s are still worth doing when\n // that allows us to avoid the `alloca`s entirely; see `rvalue_creates_operand`.\n \n-// CHECK-LABEL: define{{.*}}i32 @f32_to_bits(float noundef %x)\n+// CHECK-LABEL: define{{.*}}i32 @f32_to_bits(float %x)\n // CHECK: %0 = bitcast float %x to i32\n // CHECK-NEXT: ret i32 %0\n #[no_mangle]\n pub fn f32_to_bits(x: f32) -> u32 {\n     unsafe { std::mem::transmute(x) }\n }\n \n-// CHECK-LABEL: define{{.*}}i8 @bool_to_byte(i1 noundef zeroext %b)\n+// CHECK-LABEL: define{{.*}}i8 @bool_to_byte(i1 zeroext %b)\n // CHECK: %0 = zext i1 %b to i8\n // CHECK-NEXT: ret i8 %0\n #[no_mangle]\n pub fn bool_to_byte(b: bool) -> u8 {\n     unsafe { std::mem::transmute(b) }\n }\n \n-// CHECK-LABEL: define{{.*}}noundef zeroext i1 @byte_to_bool(i8 noundef %byte)\n+// CHECK-LABEL: define{{.*}}zeroext i1 @byte_to_bool(i8 %byte)\n // CHECK: %0 = trunc i8 %byte to i1\n // CHECK-NEXT: ret i1 %0\n #[no_mangle]\n pub unsafe fn byte_to_bool(byte: u8) -> bool {\n     std::mem::transmute(byte)\n }\n \n-// CHECK-LABEL: define{{.*}}ptr @ptr_to_ptr(ptr noundef %p)\n+// CHECK-LABEL: define{{.*}}ptr @ptr_to_ptr(ptr %p)\n // CHECK: ret ptr %p\n #[no_mangle]\n pub fn ptr_to_ptr(p: *mut u16) -> *mut u8 {\n     unsafe { std::mem::transmute(p) }\n }\n \n-// CHECK: define{{.*}}[[USIZE:i[0-9]+]] @ptr_to_int(ptr noundef %p)\n+// CHECK: define{{.*}}[[USIZE:i[0-9]+]] @ptr_to_int(ptr %p)\n // CHECK: %0 = ptrtoint ptr %p to [[USIZE]]\n // CHECK-NEXT: ret [[USIZE]] %0\n #[no_mangle]\n pub fn ptr_to_int(p: *mut u16) -> usize {\n     unsafe { std::mem::transmute(p) }\n }\n \n-// CHECK: define{{.*}}ptr @int_to_ptr([[USIZE]] noundef %i)\n+// CHECK: define{{.*}}ptr @int_to_ptr([[USIZE]] %i)\n // CHECK: %0 = inttoptr [[USIZE]] %i to ptr\n // CHECK-NEXT: ret ptr %0\n #[no_mangle]"}]}