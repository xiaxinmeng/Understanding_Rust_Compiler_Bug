{"sha": "af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "node_id": "C_kwDOAAsO6NoAKGFmMmYwZTZiN2NlYjZhNDM0NGQ4M2ZjMzlhZTgwMzIwZTliOWU4NTE", "commit": {"author": {"name": "Cormac Relf", "email": "web@cormacrelf.net", "date": "2021-10-13T05:39:06Z"}, "committer": {"name": "Cormac Relf", "email": "web@cormacrelf.net", "date": "2021-12-13T03:02:19Z"}, "message": "let-else: add hir::Let and type check it like a hir::Local\n\nunify typeck of hir::Local and hir::Let\nremove extraneous pub(crate/super)", "tree": {"sha": "e4da8a483852ac165990acad88573177cfd21a21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e4da8a483852ac165990acad88573177cfd21a21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "html_url": "https://github.com/rust-lang/rust/commit/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/comments", "author": {"login": "cormacrelf", "id": 378760, "node_id": "MDQ6VXNlcjM3ODc2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/378760?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cormacrelf", "html_url": "https://github.com/cormacrelf", "followers_url": "https://api.github.com/users/cormacrelf/followers", "following_url": "https://api.github.com/users/cormacrelf/following{/other_user}", "gists_url": "https://api.github.com/users/cormacrelf/gists{/gist_id}", "starred_url": "https://api.github.com/users/cormacrelf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cormacrelf/subscriptions", "organizations_url": "https://api.github.com/users/cormacrelf/orgs", "repos_url": "https://api.github.com/users/cormacrelf/repos", "events_url": "https://api.github.com/users/cormacrelf/events{/privacy}", "received_events_url": "https://api.github.com/users/cormacrelf/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cormacrelf", "id": 378760, "node_id": "MDQ6VXNlcjM3ODc2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/378760?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cormacrelf", "html_url": "https://github.com/cormacrelf", "followers_url": "https://api.github.com/users/cormacrelf/followers", "following_url": "https://api.github.com/users/cormacrelf/following{/other_user}", "gists_url": "https://api.github.com/users/cormacrelf/gists{/gist_id}", "starred_url": "https://api.github.com/users/cormacrelf/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cormacrelf/subscriptions", "organizations_url": "https://api.github.com/users/cormacrelf/orgs", "repos_url": "https://api.github.com/users/cormacrelf/repos", "events_url": "https://api.github.com/users/cormacrelf/events{/privacy}", "received_events_url": "https://api.github.com/users/cormacrelf/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0a4c7d1e48c39a73119eb9107d402d60c83293b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0a4c7d1e48c39a73119eb9107d402d60c83293b", "html_url": "https://github.com/rust-lang/rust/commit/a0a4c7d1e48c39a73119eb9107d402d60c83293b"}], "stats": {"total": 252, "additions": 160, "deletions": 92}, "files": [{"sha": "4eab936f85fa066bf13cfd80bbbdabac580fc890", "filename": "compiler/rustc_ast_lowering/src/block.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fblock.rs?ref=af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "patch": "@@ -2,7 +2,6 @@ use crate::{ImplTraitContext, ImplTraitPosition, LoweringContext};\n use rustc_ast::{AttrVec, Block, BlockCheckMode, Expr, Local, LocalKind, Stmt, StmtKind};\n use rustc_hir as hir;\n use rustc_session::parse::feature_err;\n-use rustc_span::symbol::Ident;\n use rustc_span::{sym, DesugaringKind};\n \n use smallvec::SmallVec;\n@@ -39,8 +38,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     let hir_id = self.lower_node_id(s.id);\n                     match &local.kind {\n                         LocalKind::InitElse(init, els) => {\n-                            let (s, e) = self.lower_let_else(hir_id, local, init, els, tail);\n-                            stmts.push(s);\n+                            let e = self.lower_let_else(hir_id, local, init, els, tail);\n                             expr = Some(e);\n                             // remaining statements are in let-else expression\n                             break;\n@@ -125,36 +123,25 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         init: &Expr,\n         els: &Block,\n         tail: &[Stmt],\n-    ) -> (hir::Stmt<'hir>, &'hir hir::Expr<'hir>) {\n+    ) -> &'hir hir::Expr<'hir> {\n         let ty = local\n             .ty\n             .as_ref()\n             .map(|t| self.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Binding)));\n         let span = self.lower_span(local.span);\n         let span = self.mark_span_with_reason(DesugaringKind::LetElse, span, None);\n-        let init = Some(self.lower_expr(init));\n-        let val = Ident::with_dummy_span(sym::val);\n-        let (pat, val_id) =\n-            self.pat_ident_binding_mode(span, val, hir::BindingAnnotation::Unannotated);\n+        let init = self.lower_expr(init);\n         let local_hir_id = self.lower_node_id(local.id);\n         self.lower_attrs(local_hir_id, &local.attrs);\n-        // first statement which basically exists for the type annotation\n-        let stmt = {\n-            let local = self.arena.alloc(hir::Local {\n+        let let_expr = {\n+            let lex = self.arena.alloc(hir::Let {\n                 hir_id: local_hir_id,\n+                pat: self.lower_pat(&local.pat),\n                 ty,\n-                pat,\n                 init,\n                 span,\n-                source: hir::LocalSource::Normal,\n             });\n-            let kind = hir::StmtKind::Local(local);\n-            hir::Stmt { hir_id: stmt_hir_id, kind, span }\n-        };\n-        let let_expr = {\n-            let scrutinee = self.expr_ident(span, val, val_id);\n-            let let_kind = hir::ExprKind::Let(self.lower_pat(&local.pat), scrutinee, span);\n-            self.arena.alloc(self.expr(span, let_kind, AttrVec::new()))\n+            self.arena.alloc(self.expr(span, hir::ExprKind::Let(lex), AttrVec::new()))\n         };\n         let then_expr = {\n             let (stmts, expr) = self.lower_stmts(tail);\n@@ -167,7 +154,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         };\n         self.alias_attrs(else_expr.hir_id, local_hir_id);\n         let if_expr = self.arena.alloc(hir::Expr {\n-            hir_id: self.next_id(),\n+            hir_id: stmt_hir_id,\n             span,\n             kind: hir::ExprKind::If(let_expr, then_expr, Some(else_expr)),\n         });\n@@ -180,6 +167,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             )\n             .emit();\n         }\n-        (stmt, if_expr)\n+        if_expr\n     }\n }"}, {"sha": "d88292e0b908454efe06a80ad26ffb815cfcc4e3", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "patch": "@@ -92,11 +92,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let ohs = self.lower_expr(ohs);\n                     hir::ExprKind::AddrOf(k, m, ohs)\n                 }\n-                ExprKind::Let(ref pat, ref scrutinee, span) => hir::ExprKind::Let(\n-                    self.lower_pat(pat),\n-                    self.lower_expr(scrutinee),\n-                    self.lower_span(span),\n-                ),\n+                ExprKind::Let(ref pat, ref scrutinee, span) => {\n+                    hir::ExprKind::Let(self.arena.alloc(hir::Let {\n+                        hir_id: self.next_id(),\n+                        span: self.lower_span(span),\n+                        pat: self.lower_pat(pat),\n+                        ty: None,\n+                        init: self.lower_expr(scrutinee),\n+                    }))\n+                }\n                 ExprKind::If(ref cond, ref then, ref else_opt) => {\n                     self.lower_expr_if(cond, then, else_opt.as_deref())\n                 }"}, {"sha": "edad00ed6a2fe0ce03de074dc48a0d3473d3c547", "filename": "compiler/rustc_hir/src/arena.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Farena.rs?ref=af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "patch": "@@ -20,6 +20,7 @@ macro_rules! arena_types {\n             [] generic_bound: rustc_hir::GenericBound<'tcx>,\n             [] generic_param: rustc_hir::GenericParam<'tcx>,\n             [] expr: rustc_hir::Expr<'tcx>,\n+            [] let_expr: rustc_hir::Let<'tcx>,\n             [] expr_field: rustc_hir::ExprField<'tcx>,\n             [] pat_field: rustc_hir::PatField<'tcx>,\n             [] fn_decl: rustc_hir::FnDecl<'tcx>,"}, {"sha": "4cf7a5b1264c5f54083f9b9ebf8e1ba88cefed84", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "patch": "@@ -1176,10 +1176,24 @@ pub struct Arm<'hir> {\n     pub body: &'hir Expr<'hir>,\n }\n \n+/// Represents a `let <pat>[: <ty>] = <expr>` expression (not a Local), occurring in an `if-let` or\n+/// `let-else`, evaluating to a boolean. Typically the pattern is refutable.\n+///\n+/// In an if-let, imagine it as `if (let <pat> = <expr>) { ... }`; in a let-else, it is part of the\n+/// desugaring to if-let. Only let-else supports the type annotation at present.\n+#[derive(Debug, HashStable_Generic)]\n+pub struct Let<'hir> {\n+    pub hir_id: HirId,\n+    pub span: Span,\n+    pub pat: &'hir Pat<'hir>,\n+    pub ty: Option<&'hir Ty<'hir>>,\n+    pub init: &'hir Expr<'hir>,\n+}\n+\n #[derive(Debug, HashStable_Generic)]\n pub enum Guard<'hir> {\n     If(&'hir Expr<'hir>),\n-    // FIXME use ExprKind::Let for this.\n+    // FIXME use hir::Let for this.\n     IfLet(&'hir Pat<'hir>, &'hir Expr<'hir>),\n }\n \n@@ -1696,7 +1710,7 @@ pub enum ExprKind<'hir> {\n     ///\n     /// These are not `Local` and only occur as expressions.\n     /// The `let Some(x) = foo()` in `if let Some(x) = foo()` is an example of `Let(..)`.\n-    Let(&'hir Pat<'hir>, &'hir Expr<'hir>, Span),\n+    Let(&'hir Let<'hir>),\n     /// An `if` block, with an optional else block.\n     ///\n     /// I.e., `if <expr> { <expr> } else { <expr> }`."}, {"sha": "afe4f8e1417b45338a6c2977ff240a35d5313e2b", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "patch": "@@ -389,6 +389,9 @@ pub trait Visitor<'v>: Sized {\n     fn visit_expr(&mut self, ex: &'v Expr<'v>) {\n         walk_expr(self, ex)\n     }\n+    fn visit_let_expr(&mut self, lex: &'v Let<'v>) {\n+        walk_let_expr(self, lex)\n+    }\n     fn visit_ty(&mut self, t: &'v Ty<'v>) {\n         walk_ty(self, t)\n     }\n@@ -1126,6 +1129,14 @@ pub fn walk_anon_const<'v, V: Visitor<'v>>(visitor: &mut V, constant: &'v AnonCo\n     visitor.visit_nested_body(constant.body);\n }\n \n+pub fn walk_let_expr<'v, V: Visitor<'v>>(visitor: &mut V, let_expr: &'v Let<'v>) {\n+    // match the visit order in walk_local\n+    visitor.visit_expr(let_expr.init);\n+    visitor.visit_id(let_expr.hir_id);\n+    visitor.visit_pat(let_expr.pat);\n+    walk_list!(visitor, visit_ty, let_expr.ty);\n+}\n+\n pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>) {\n     visitor.visit_id(expression.hir_id);\n     match expression.kind {\n@@ -1172,10 +1183,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n         ExprKind::DropTemps(ref subexpression) => {\n             visitor.visit_expr(subexpression);\n         }\n-        ExprKind::Let(ref pat, ref expr, _) => {\n-            visitor.visit_expr(expr);\n-            visitor.visit_pat(pat);\n-        }\n+        ExprKind::Let(ref let_expr) => visitor.visit_let_expr(let_expr),\n         ExprKind::If(ref cond, ref then, ref else_opt) => {\n             visitor.visit_expr(cond);\n             visitor.visit_expr(then);"}, {"sha": "44f2328b309edf5f84e27484653b47b9ee7bb911", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "patch": "@@ -1101,13 +1101,17 @@ impl<'a> State<'a> {\n     }\n \n     /// Print a `let pat = expr` expression.\n-    fn print_let(&mut self, pat: &hir::Pat<'_>, expr: &hir::Expr<'_>) {\n-        self.word(\"let \");\n+    fn print_let(&mut self, pat: &hir::Pat<'_>, ty: Option<&hir::Ty<'_>>, init: &hir::Expr<'_>) {\n+        self.word_space(\"let\");\n         self.print_pat(pat);\n+        if let Some(ty) = ty {\n+            self.word_space(\":\");\n+            self.print_type(ty);\n+        }\n         self.space();\n         self.word_space(\"=\");\n-        let npals = || parser::needs_par_as_let_scrutinee(expr.precedence().order());\n-        self.print_expr_cond_paren(expr, Self::cond_needs_par(expr) || npals())\n+        let npals = || parser::needs_par_as_let_scrutinee(init.precedence().order());\n+        self.print_expr_cond_paren(init, Self::cond_needs_par(init) || npals())\n     }\n \n     // Does `expr` need parentheses when printed in a condition position?\n@@ -1462,8 +1466,8 @@ impl<'a> State<'a> {\n                 // Print `}`:\n                 self.bclose_maybe_open(expr.span, true);\n             }\n-            hir::ExprKind::Let(ref pat, ref scrutinee, _) => {\n-                self.print_let(pat, scrutinee);\n+            hir::ExprKind::Let(hir::Let { pat, ty, init, .. }) => {\n+                self.print_let(pat, *ty, init);\n             }\n             hir::ExprKind::If(ref test, ref blk, ref elseopt) => {\n                 self.print_if(&test, &blk, elseopt.as_ref().map(|e| &**e));"}, {"sha": "092fe131174703b32343eb75f608ed07900fd302", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "patch": "@@ -605,9 +605,10 @@ impl<'tcx> Cx<'tcx> {\n                 },\n                 Err(err) => bug!(\"invalid loop id for continue: {}\", err),\n             },\n-            hir::ExprKind::Let(ref pat, ref expr, _) => {\n-                ExprKind::Let { expr: self.mirror_expr(expr), pat: self.pattern_from_hir(pat) }\n-            }\n+            hir::ExprKind::Let(let_expr) => ExprKind::Let {\n+                expr: self.mirror_expr(let_expr.init),\n+                pat: self.pattern_from_hir(let_expr.pat),\n+            },\n             hir::ExprKind::If(cond, then, else_opt) => ExprKind::If {\n                 if_then_scope: region::Scope {\n                     id: then.hir_id.local_id,"}, {"sha": "7a4fd6ffc4adef9d1a6f186860b4eb44b4ab870a", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "patch": "@@ -64,7 +64,9 @@ impl<'tcx> Visitor<'tcx> for MatchVisitor<'_, '_, 'tcx> {\n         intravisit::walk_expr(self, ex);\n         match &ex.kind {\n             hir::ExprKind::Match(scrut, arms, source) => self.check_match(scrut, arms, *source),\n-            hir::ExprKind::Let(pat, scrut, span) => self.check_let(pat, scrut, *span),\n+            hir::ExprKind::Let(hir::Let { pat, init, span, .. }) => {\n+                self.check_let(pat, init, *span)\n+            }\n             _ => {}\n         }\n     }\n@@ -148,9 +150,9 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         }\n     }\n \n-    fn check_let(&mut self, pat: &'tcx hir::Pat<'tcx>, expr: &hir::Expr<'_>, span: Span) {\n+    fn check_let(&mut self, pat: &'tcx hir::Pat<'tcx>, scrutinee: &hir::Expr<'_>, span: Span) {\n         self.check_patterns(pat, Refutable);\n-        let mut cx = self.new_cx(expr.hir_id);\n+        let mut cx = self.new_cx(scrutinee.hir_id);\n         let tpat = self.lower_pattern(&mut cx, pat, &mut false);\n         check_let_reachability(&mut cx, pat.hir_id, tpat, span);\n     }"}, {"sha": "4ae1e5cee925e7625517b7d07a2eb4b4eec02420", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "patch": "@@ -429,8 +429,8 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n                 intravisit::walk_expr(self, expr);\n             }\n \n-            hir::ExprKind::Let(ref pat, ..) => {\n-                self.add_from_pat(pat);\n+            hir::ExprKind::Let(let_expr) => {\n+                self.add_from_pat(let_expr.pat);\n                 intravisit::walk_expr(self, expr);\n             }\n \n@@ -856,9 +856,9 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 })\n             }\n \n-            hir::ExprKind::Let(ref pat, ref scrutinee, _) => {\n-                let succ = self.propagate_through_expr(scrutinee, succ);\n-                self.define_bindings_in_pat(pat, succ)\n+            hir::ExprKind::Let(let_expr) => {\n+                let succ = self.propagate_through_expr(let_expr.init, succ);\n+                self.define_bindings_in_pat(let_expr.pat, succ)\n             }\n \n             // Note that labels have been resolved, so we don't need to look\n@@ -1401,8 +1401,8 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n             }\n         }\n \n-        hir::ExprKind::Let(ref pat, ..) => {\n-            this.check_unused_vars_in_pat(pat, None, |_, _, _, _| {});\n+        hir::ExprKind::Let(let_expr) => {\n+            this.check_unused_vars_in_pat(let_expr.pat, None, |_, _, _, _| {});\n         }\n \n         // no correctness conditions related to liveness"}, {"sha": "fd30723dcda420016226d97ecd97e9efabfc73c5", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "patch": "@@ -300,7 +300,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             ExprKind::Ret(ref expr_opt) => self.check_expr_return(expr_opt.as_deref(), expr),\n-            ExprKind::Let(pat, let_expr, _) => self.check_expr_let(let_expr, pat),\n+            ExprKind::Let(let_expr) => self.check_expr_let(let_expr),\n             ExprKind::Loop(body, _, source, _) => {\n                 self.check_expr_loop(body, source, expected, expr)\n             }\n@@ -1048,10 +1048,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn check_expr_let(&self, expr: &'tcx hir::Expr<'tcx>, pat: &'tcx hir::Pat<'tcx>) -> Ty<'tcx> {\n-        self.warn_if_unreachable(expr.hir_id, expr.span, \"block in `let` expression\");\n-        let expr_ty = self.demand_scrutinee_type(expr, pat.contains_explicit_ref_binding(), false);\n-        self.check_pat_top(pat, expr_ty, Some(expr.span), true);\n+    fn check_expr_let(&self, let_expr: &'tcx hir::Let<'tcx>) -> Ty<'tcx> {\n+        // for let statements, this is done in check_stmt\n+        let init = let_expr.init;\n+        self.warn_if_unreachable(init.hir_id, init.span, \"block in `let` expression\");\n+        // otherwise check exactly as a let statement\n+        self.check_decl(let_expr.into());\n+        // but return a bool, for this is a boolean expression\n         self.tcx.types.bool\n     }\n "}, {"sha": "f3f3f99e4eb7fe75ec59836612be5948db0dc14f", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "patch": "@@ -1,5 +1,6 @@\n use crate::astconv::AstConv;\n use crate::check::coercion::CoerceMany;\n+use crate::check::gather_locals::Declaration;\n use crate::check::method::MethodCallee;\n use crate::check::Expectation::*;\n use crate::check::TupleArgumentsFlag::*;\n@@ -538,16 +539,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     pub fn check_decl_initializer(\n         &self,\n-        local: &'tcx hir::Local<'tcx>,\n+        hir_id: hir::HirId,\n+        pat: &'tcx hir::Pat<'tcx>,\n         init: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         // FIXME(tschottdorf): `contains_explicit_ref_binding()` must be removed\n         // for #42640 (default match binding modes).\n         //\n         // See #44848.\n-        let ref_bindings = local.pat.contains_explicit_ref_binding();\n+        let ref_bindings = pat.contains_explicit_ref_binding();\n \n-        let local_ty = self.local_ty(init.span, local.hir_id).revealed_ty;\n+        let local_ty = self.local_ty(init.span, hir_id).revealed_ty;\n         if let Some(m) = ref_bindings {\n             // Somewhat subtle: if we have a `ref` binding in the pattern,\n             // we want to avoid introducing coercions for the RHS. This is\n@@ -565,29 +567,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    /// Type check a `let` statement.\n-    pub fn check_decl_local(&self, local: &'tcx hir::Local<'tcx>) {\n+    pub(in super::super) fn check_decl(&self, decl: Declaration<'tcx>) {\n         // Determine and write the type which we'll check the pattern against.\n-        let ty = self.local_ty(local.span, local.hir_id).decl_ty;\n-        self.write_ty(local.hir_id, ty);\n+        let decl_ty = self.local_ty(decl.span, decl.hir_id).decl_ty;\n+        self.write_ty(decl.hir_id, decl_ty);\n \n         // Type check the initializer.\n-        if let Some(ref init) = local.init {\n-            let init_ty = self.check_decl_initializer(local, &init);\n-            self.overwrite_local_ty_if_err(local, ty, init_ty);\n+        if let Some(ref init) = decl.init {\n+            let init_ty = self.check_decl_initializer(decl.hir_id, decl.pat, &init);\n+            self.overwrite_local_ty_if_err(decl.hir_id, decl.pat, decl_ty, init_ty);\n         }\n \n         // Does the expected pattern type originate from an expression and what is the span?\n-        let (origin_expr, ty_span) = match (local.ty, local.init) {\n+        let (origin_expr, ty_span) = match (decl.ty, decl.init) {\n             (Some(ty), _) => (false, Some(ty.span)), // Bias towards the explicit user type.\n             (_, Some(init)) => (true, Some(init.span)), // No explicit type; so use the scrutinee.\n             _ => (false, None), // We have `let $pat;`, so the expected type is unconstrained.\n         };\n \n         // Type check the pattern. Override if necessary to avoid knock-on errors.\n-        self.check_pat_top(&local.pat, ty, ty_span, origin_expr);\n-        let pat_ty = self.node_ty(local.pat.hir_id);\n-        self.overwrite_local_ty_if_err(local, ty, pat_ty);\n+        self.check_pat_top(&decl.pat, decl_ty, ty_span, origin_expr);\n+        let pat_ty = self.node_ty(decl.pat.hir_id);\n+        self.overwrite_local_ty_if_err(decl.hir_id, decl.pat, decl_ty, pat_ty);\n+    }\n+\n+    /// Type check a `let` statement.\n+    pub fn check_decl_local(&self, local: &'tcx hir::Local<'tcx>) {\n+        self.check_decl(local.into());\n     }\n \n     pub fn check_stmt(&self, stmt: &'tcx hir::Stmt<'tcx>, is_last: bool) {\n@@ -891,17 +897,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn overwrite_local_ty_if_err(\n         &self,\n-        local: &'tcx hir::Local<'tcx>,\n+        hir_id: hir::HirId,\n+        pat: &'tcx hir::Pat<'tcx>,\n         decl_ty: Ty<'tcx>,\n         ty: Ty<'tcx>,\n     ) {\n         if ty.references_error() {\n             // Override the types everywhere with `err()` to avoid knock on errors.\n-            self.write_ty(local.hir_id, ty);\n-            self.write_ty(local.pat.hir_id, ty);\n+            self.write_ty(hir_id, ty);\n+            self.write_ty(pat.hir_id, ty);\n             let local_ty = LocalTy { decl_ty, revealed_ty: ty };\n-            self.locals.borrow_mut().insert(local.hir_id, local_ty);\n-            self.locals.borrow_mut().insert(local.pat.hir_id, local_ty);\n+            self.locals.borrow_mut().insert(hir_id, local_ty);\n+            self.locals.borrow_mut().insert(pat.hir_id, local_ty);\n         }\n     }\n "}, {"sha": "839bd56b396ef1911b30a34635101bfa22c2130e", "filename": "compiler/rustc_typeck/src/check/gather_locals.rs", "status": "modified", "additions": 51, "deletions": 14, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgather_locals.rs?ref=af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "patch": "@@ -7,6 +7,31 @@ use rustc_middle::ty::Ty;\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n \n+/// A declaration is an abstraction of [hir::Local] and [hir::Let].\n+///\n+/// It must have a hir_id, as this is how we connect gather_locals to the check functions.\n+pub(super) struct Declaration<'a> {\n+    pub hir_id: hir::HirId,\n+    pub pat: &'a hir::Pat<'a>,\n+    pub ty: Option<&'a hir::Ty<'a>>,\n+    pub span: Span,\n+    pub init: Option<&'a hir::Expr<'a>>,\n+}\n+\n+impl<'a> From<&'a hir::Local<'a>> for Declaration<'a> {\n+    fn from(local: &'a hir::Local<'a>) -> Self {\n+        let hir::Local { hir_id, pat, ty, span, init, .. } = *local;\n+        Declaration { hir_id, pat, ty, span, init }\n+    }\n+}\n+\n+impl<'a> From<&'a hir::Let<'a>> for Declaration<'a> {\n+    fn from(let_expr: &'a hir::Let<'a>) -> Self {\n+        let hir::Let { hir_id, pat, ty, span, init } = *let_expr;\n+        Declaration { hir_id, pat, ty, span, init: Some(init) }\n+    }\n+}\n+\n pub(super) struct GatherLocalsVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     // parameters are special cases of patterns, but we want to handle them as\n@@ -41,18 +66,12 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx> {\n             }\n         }\n     }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n-    type Map = intravisit::ErasedMap<'tcx>;\n-\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n \n-    // Add explicitly-declared locals.\n-    fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n-        let local_ty = match local.ty {\n+    /// Allocates a [LocalTy] for a declaration, which may have a type annotation. If it does have\n+    /// a type annotation, then the LocalTy stored will be the resolved type. This may be found\n+    /// again during type checking by querying [FnCtxt::local_ty] for the same hir_id.\n+    fn declare(&mut self, decl: Declaration<'tcx>) {\n+        let local_ty = match decl.ty {\n             Some(ref ty) => {\n                 let o_ty = self.fcx.to_ty(&ty);\n \n@@ -68,16 +87,34 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n             }\n             None => None,\n         };\n-        self.assign(local.span, local.hir_id, local_ty);\n+        self.assign(decl.span, decl.hir_id, local_ty);\n \n         debug!(\n             \"local variable {:?} is assigned type {}\",\n-            local.pat,\n-            self.fcx.ty_to_string(&*self.fcx.locals.borrow().get(&local.hir_id).unwrap().decl_ty)\n+            decl.pat,\n+            self.fcx.ty_to_string(&*self.fcx.locals.borrow().get(&decl.hir_id).unwrap().decl_ty)\n         );\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx> {\n+    type Map = intravisit::ErasedMap<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    // Add explicitly-declared locals.\n+    fn visit_local(&mut self, local: &'tcx hir::Local<'tcx>) {\n+        self.declare(local.into());\n         intravisit::walk_local(self, local);\n     }\n \n+    fn visit_let_expr(&mut self, let_expr: &'tcx hir::Let<'tcx>) {\n+        self.declare(let_expr.into());\n+        intravisit::walk_let_expr(self, let_expr);\n+    }\n+\n     fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n         let old_outermost_fn_param_pat = self.outermost_fn_param_pat.replace(param.ty_span);\n         intravisit::walk_param(self, param);"}, {"sha": "bd09f4b4dcba42e1dc7cdc1d2c1e15735545ff0f", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=af2f0e6b7ceb6a4344d83fc39ae80320e9b9e851", "patch": "@@ -229,8 +229,8 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 }\n             }\n \n-            hir::ExprKind::Let(pat, ref expr, _) => {\n-                self.walk_local(expr, pat, |t| t.borrow_expr(expr, ty::ImmBorrow));\n+            hir::ExprKind::Let(hir::Let { pat, init, .. }) => {\n+                self.walk_local(init, pat, |t| t.borrow_expr(init, ty::ImmBorrow));\n             }\n \n             hir::ExprKind::Match(ref discr, arms, _) => {"}]}