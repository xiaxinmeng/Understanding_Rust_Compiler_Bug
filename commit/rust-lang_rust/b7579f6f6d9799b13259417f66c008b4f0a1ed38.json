{"sha": "b7579f6f6d9799b13259417f66c008b4f0a1ed38", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3NTc5ZjZmNmQ5Nzk5YjEzMjU5NDE3ZjY2YzAwOGI0ZjBhMWVkMzg=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-05-25T07:16:25Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-05-25T07:16:25Z"}, "message": "Merge pull request #75 from nrc/structs\n\nStructs", "tree": {"sha": "507c849e12708c2fbb11ce5879eeafe825456f79", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/507c849e12708c2fbb11ce5879eeafe825456f79"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7579f6f6d9799b13259417f66c008b4f0a1ed38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7579f6f6d9799b13259417f66c008b4f0a1ed38", "html_url": "https://github.com/rust-lang/rust/commit/b7579f6f6d9799b13259417f66c008b4f0a1ed38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7579f6f6d9799b13259417f66c008b4f0a1ed38/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3856880f6c40649d3bb9a330c65de79db6c56a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3856880f6c40649d3bb9a330c65de79db6c56a4", "html_url": "https://github.com/rust-lang/rust/commit/c3856880f6c40649d3bb9a330c65de79db6c56a4"}, {"sha": "46818d405a9f2fb3cb0da42b5567b638862b4f3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/46818d405a9f2fb3cb0da42b5567b638862b4f3f", "html_url": "https://github.com/rust-lang/rust/commit/46818d405a9f2fb3cb0da42b5567b638862b4f3f"}], "stats": {"total": 297, "additions": 288, "deletions": 9}, "files": [{"sha": "8e6c376209f338f7702d5eb2f29600ae2c8cf2ef", "filename": "src/config.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=b7579f6f6d9799b13259417f66c008b4f0a1ed38", "patch": "@@ -19,11 +19,12 @@ pub struct Config {\n     pub newline_style: ::NewlineStyle,\n     pub fn_brace_style: ::BraceStyle,\n     pub fn_return_indent: ::ReturnIndent,\n+    pub struct_trailing_comma: bool,\n+    pub struct_lit_trailing_comma: ::lists::SeparatorTactic,\n }\n \n impl Config {\n     fn from_toml(toml: &str) -> Config {\n-        println!(\"About to parse: {}\", toml);\n         let parsed = toml.parse().unwrap();\n         toml::decode(parsed).unwrap()\n     }"}, {"sha": "e8c74879b597df5a017be5d3c040a4ad5a556b03", "filename": "src/default.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Fdefault.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Fdefault.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdefault.toml?ref=b7579f6f6d9799b13259417f66c008b4f0a1ed38", "patch": "@@ -5,3 +5,5 @@ tab_spaces = 4\n newline_style = \"Unix\"\n fn_brace_style = \"SameLineWhere\"\n fn_return_indent = \"WithArgs\"\n+struct_trailing_comma = true\n+struct_lit_trailing_comma = \"Vertical\""}, {"sha": "4b32301fe9142cae5fe179bbff8adaf068ed7c17", "filename": "src/expr.rs", "status": "modified", "additions": 68, "deletions": 1, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=b7579f6f6d9799b13259417f66c008b4f0a1ed38", "patch": "@@ -13,7 +13,9 @@ use utils::*;\n use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n \n use syntax::{ast, ptr};\n-use syntax::codemap::{Span, Pos};\n+use syntax::codemap::{Pos, Span};\n+use syntax::parse::token;\n+use syntax::print::pprust;\n \n use MIN_STRING;\n \n@@ -134,6 +136,64 @@ impl<'a> FmtVisitor<'a> {\n         format!(\"({})\", subexpr_str)\n     }\n \n+    fn rewrite_struct_lit(&mut self,\n+                          path: &ast::Path,\n+                          fields: &[ast::Field],\n+                          base: Option<&ast::Expr>,\n+                          width: usize,\n+                          offset: usize)\n+        -> String\n+    {\n+        debug!(\"rewrite_struct_lit: width {}, offset {}\", width, offset);\n+        assert!(fields.len() > 0 || base.is_some());\n+\n+        let path_str = pprust::path_to_string(path);\n+        // Foo { a: Foo } - indent is +3, width is -5.\n+        let indent = offset + path_str.len() + 3;\n+        let budget = width - (path_str.len() + 5);\n+\n+        let mut field_strs: Vec<_> =\n+            fields.iter().map(|f| self.rewrite_field(f, budget, indent)).collect();\n+        if let Some(expr) = base {\n+            // Another 2 on the width/indent for the ..\n+            field_strs.push(format!(\"..{}\", self.rewrite_expr(expr, budget - 2, indent + 2)))\n+        }\n+\n+        // FIXME comments\n+        let field_strs: Vec<_> = field_strs.into_iter().map(|s| (s, String::new())).collect();\n+        let tactics = if field_strs.iter().any(|&(ref s, _)| s.contains('\\n')) {\n+            ListTactic::Vertical\n+        } else {\n+            ListTactic::HorizontalVertical\n+        };\n+        let fmt = ListFormatting {\n+            tactic: tactics,\n+            separator: \",\",\n+            trailing_separator: if base.is_some() {\n+                    SeparatorTactic::Never\n+                } else {\n+                    config!(struct_lit_trailing_comma)\n+                },\n+            indent: indent,\n+            h_width: budget,\n+            v_width: budget,\n+        };\n+        let fields_str = write_list(&field_strs, &fmt);\n+        format!(\"{} {{ {} }}\", path_str, fields_str)\n+\n+        // FIXME if the usual multi-line layout is too wide, we should fall back to\n+        // Foo {\n+        //     a: ...,\n+        // }\n+    }\n+\n+    fn rewrite_field(&mut self, field: &ast::Field, width: usize, offset: usize) -> String {\n+        let name = &token::get_ident(field.ident.node);\n+        let overhead = name.len() + 2;\n+        let expr = self.rewrite_expr(&field.expr, width - overhead, offset + overhead);\n+        format!(\"{}: {}\", name, expr)\n+    }\n+\n     pub fn rewrite_expr(&mut self, expr: &ast::Expr, width: usize, offset: usize) -> String {\n         match expr.node {\n             ast::Expr_::ExprLit(ref l) => {\n@@ -152,6 +212,13 @@ impl<'a> FmtVisitor<'a> {\n             ast::Expr_::ExprParen(ref subexpr) => {\n                 return self.rewrite_paren(subexpr, width, offset);\n             }\n+            ast::Expr_::ExprStruct(ref path, ref fields, ref base) => {\n+                return self.rewrite_struct_lit(path,\n+                                               fields,\n+                                               base.as_ref().map(|e| &**e),\n+                                               width,\n+                                               offset);\n+            }\n             _ => {}\n         }\n "}, {"sha": "cab3fa452e49fd21903a6996fb6af9be44217fa2", "filename": "src/imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=b7579f6f6d9799b13259417f66c008b4f0a1ed38", "patch": "@@ -47,7 +47,7 @@ impl<'a> FmtVisitor<'a> {\n                             path: &ast::Path,\n                             path_list: &[ast::PathListItem],\n                             visibility: ast::Visibility) -> String {\n-        let path_str = pprust::path_to_string(&path);\n+        let path_str = pprust::path_to_string(path);\n \n         let vis = match visibility {\n             ast::Public => \"pub \","}, {"sha": "55613ab1bb843f71b99608267b0fc0dfa2510a19", "filename": "src/items.rs", "status": "renamed", "additions": 128, "deletions": 3, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=b7579f6f6d9799b13259417f66c008b4f0a1ed38", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Formatting top-level items - functions, structs, enums, traits, impls.\n+\n use {ReturnIndent, BraceStyle};\n use utils::make_indent;\n use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n@@ -123,7 +125,7 @@ impl<'a> FmtVisitor<'a> {\n         let generics_indent = indent + result.len();\n         result.push_str(&self.rewrite_generics(generics,\n                                                generics_indent,\n-                                               span_for_return(&fd.output)));\n+                                               span_for_return(&fd.output).lo));\n \n         let ret_str = self.rewrite_return(&fd.output);\n \n@@ -388,7 +390,130 @@ impl<'a> FmtVisitor<'a> {\n         }\n     }\n \n-    fn rewrite_generics(&self, generics: &ast::Generics, indent: usize, ret_span: Span) -> String {\n+    pub fn visit_struct(&mut self,\n+                        ident: ast::Ident,\n+                        vis: ast::Visibility,\n+                        struct_def: &ast::StructDef,\n+                        generics: &ast::Generics,\n+                        span: Span)\n+    {\n+        let header_str = self.struct_header(ident, vis);\n+        self.changes.push_str_span(span, &header_str);\n+\n+        if struct_def.fields.len() == 0 {\n+            assert!(generics.where_clause.predicates.len() == 0,\n+                    \"No-field struct with where clause?\");\n+            assert!(generics.lifetimes.len() == 0, \"No-field struct with generics?\");\n+            assert!(generics.ty_params.len() == 0, \"No-field struct with generics?\");\n+\n+            self.changes.push_str_span(span, \";\");\n+            return;\n+        }\n+\n+        let mut generics_buf = String::new();\n+        let generics_str = self.rewrite_generics(generics, self.block_indent, struct_def.fields[0].span.lo);\n+        generics_buf.push_str(&generics_str);\n+\n+        if generics.where_clause.predicates.len() > 0 {\n+            generics_buf.push_str(&self.rewrite_where_clause(&generics.where_clause,\n+                                                             self.block_indent,\n+                                                             struct_def.fields[0].span.lo));\n+            generics_buf.push_str(&make_indent(self.block_indent));\n+            generics_buf.push_str(\"\\n{\");\n+\n+        } else {\n+            generics_buf.push_str(\" {\");\n+        }\n+        self.changes.push_str_span(span, &generics_buf);\n+\n+        let struct_snippet = self.snippet(span);\n+        // FIXME this will give incorrect results if there is a { in a commet.\n+        self.last_pos = span.lo + BytePos(struct_snippet.find('{').unwrap() as u32 + 1);\n+\n+        self.block_indent += config!(tab_spaces);\n+        for (i, f) in struct_def.fields.iter().enumerate() {\n+            self.visit_field(f, i == struct_def.fields.len() - 1, span.lo, &struct_snippet);\n+        }\n+        self.block_indent -= config!(tab_spaces);\n+\n+        self.format_missing_with_indent(span.lo + BytePos(struct_snippet.rfind('}').unwrap() as u32));\n+        self.changes.push_str_span(span, \"}\");\n+    }\n+\n+    fn struct_header(&self,\n+                     ident: ast::Ident,\n+                     vis: ast::Visibility)\n+        -> String\n+    {\n+        let vis = if vis == ast::Visibility::Public {\n+            \"pub \"\n+        } else {\n+            \"\"\n+        };\n+\n+        format!(\"{}struct {}\", vis, &token::get_ident(ident))\n+    }\n+\n+    // Field of a struct\n+    fn visit_field(&mut self,\n+                   field: &ast::StructField,\n+                   last_field: bool,\n+                   // These two args are for missing spans hacks.\n+                   struct_start: BytePos,\n+                   struct_snippet: &str)\n+    {\n+        if self.visit_attrs(&field.node.attrs) {\n+            return;\n+        }\n+        self.format_missing_with_indent(field.span.lo);\n+\n+        let name = match field.node.kind {\n+            ast::StructFieldKind::NamedField(ident, _) => Some(token::get_ident(ident)),\n+            ast::StructFieldKind::UnnamedField(_) => None,\n+        };\n+        let vis = match field.node.kind {\n+            ast::StructFieldKind::NamedField(_, vis) |\n+            ast::StructFieldKind::UnnamedField(vis) => if vis == ast::Visibility::Public {\n+                \"pub \"\n+            } else {\n+                \"\"\n+            }\n+        };\n+        let typ = pprust::ty_to_string(&field.node.ty);\n+\n+        let mut field_str = match name {\n+            Some(name) => {\n+                let budget = config!(ideal_width) - self.block_indent;\n+                // 3 is being conservative and assuming that there will be a trailing comma.\n+                if self.block_indent + vis.len() + name.len() + typ.len() + 3 > budget {\n+                    format!(\"{}{}:\\n{}{}\",\n+                            vis,\n+                            name,\n+                            &make_indent(self.block_indent + config!(tab_spaces)),\n+                            typ)\n+                } else {\n+                    format!(\"{}{}: {}\", vis, name, typ)\n+                }\n+            }\n+            None => format!(\"{}{}\", vis, typ),\n+        };\n+        if !last_field || config!(struct_trailing_comma) {\n+            field_str.push(',');\n+        }\n+        self.changes.push_str_span(field.span, &field_str);\n+\n+        // This hack makes sure we only add comments etc. after the comma, and\n+        // makes sure we don't repeat any commas.\n+        let hi = field.span.hi;\n+        // FIXME a comma in a comment will break this hack.\n+        let comma_pos = match struct_snippet[(hi.0 - struct_start.0) as usize..].find(',') {\n+            Some(i) => i,\n+            None => 0,\n+        };\n+        self.last_pos = hi + BytePos(comma_pos as u32 + 1);\n+    }\n+\n+    fn rewrite_generics(&self, generics: &ast::Generics, indent: usize, span_end: BytePos) -> String {\n         // FIXME convert bounds to where clauses where they get too big or if\n         // there is a where clause at all.\n         let mut result = String::new();\n@@ -422,7 +547,7 @@ impl<'a> FmtVisitor<'a> {\n                                                    \">\",\n                                                    |sp| sp.lo,\n                                                    |sp| sp.hi,\n-                                                   ret_span.lo);\n+                                                   span_end);\n \n         // If there are // comments, keep them multi-line.\n         let mut list_tactic = ListTactic::HorizontalVertical;", "previous_filename": "src/functions.rs"}, {"sha": "1a690b4945aeee6dd3e4d109803b6d289b737530", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b7579f6f6d9799b13259417f66c008b4f0a1ed38", "patch": "@@ -50,7 +50,7 @@ use visitor::FmtVisitor;\n mod config;\n mod changes;\n mod visitor;\n-mod functions;\n+mod items;\n mod missed_spans;\n mod lists;\n mod utils;"}, {"sha": "58e810fce205d845279b07a30dfdf61710a64388", "filename": "src/lists.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=b7579f6f6d9799b13259417f66c008b4f0a1ed38", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use utils::make_indent;\n+use rustc_serialize::{Decodable, Decoder};\n \n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n pub enum ListTactic {\n@@ -29,6 +30,19 @@ pub enum SeparatorTactic {\n     Vertical,\n }\n \n+// TODO could use a macro for all these Decodable impls.\n+impl Decodable for SeparatorTactic {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+        let s = try!(d.read_str());\n+        match &*s {\n+            \"Always\" => Ok(SeparatorTactic::Always),\n+            \"Never\" => Ok(SeparatorTactic::Never),\n+            \"Vertical\" => Ok(SeparatorTactic::Vertical),\n+            _ => Err(d.error(\"Bad variant\")),\n+        }\n+    }\n+}\n+\n // TODO having some helpful ctors for ListFormatting would be nice.\n pub struct ListFormatting<'a> {\n     pub tactic: ListTactic,"}, {"sha": "256c1e6e13230557cce28f068472db2f1b5d368f", "filename": "src/visitor.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7579f6f6d9799b13259417f66c008b4f0a1ed38/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=b7579f6f6d9799b13259417f66c008b4f0a1ed38", "patch": "@@ -180,6 +180,15 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                 self.changes.push_str_span(item.span, &new_str);\n                 self.last_pos = item.span.hi;\n             }\n+            ast::Item_::ItemStruct(ref def, ref generics) => {\n+                self.format_missing_with_indent(item.span.lo);\n+                self.visit_struct(item.ident,\n+                                  item.vis,\n+                                  def,\n+                                  generics,\n+                                  item.span);\n+                self.last_pos = item.span.hi;\n+            }\n             _ => {\n                 visit::walk_item(self, item);\n             }\n@@ -252,7 +261,7 @@ impl<'a> FmtVisitor<'a> {\n     }\n \n     // Returns true if we should skip the following item.\n-    fn visit_attrs(&mut self, attrs: &[ast::Attribute]) -> bool {\n+    pub fn visit_attrs(&mut self, attrs: &[ast::Attribute]) -> bool {\n         if attrs.len() == 0 {\n             return false;\n         }"}, {"sha": "50329b258d14ca907568e995ac11f5a2b10ad69b", "filename": "tests/idem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7579f6f6d9799b13259417f66c008b4f0a1ed38/tests%2Fidem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7579f6f6d9799b13259417f66c008b4f0a1ed38/tests%2Fidem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fidem.rs?ref=b7579f6f6d9799b13259417f66c008b4f0a1ed38", "patch": "@@ -57,7 +57,7 @@ fn idempotent_tests() {\n \n // Compare output to input.\n fn print_mismatches(result: HashMap<String, String>) {\n-    for (file_name, fmt_text) in result {\n+    for (_, fmt_text) in result {\n         println!(\"{}\", fmt_text);\n     }\n }"}, {"sha": "1d32171d7d095e562e2bba6ab59f11d1878db2e3", "filename": "tests/idem/struct_lits.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b7579f6f6d9799b13259417f66c008b4f0a1ed38/tests%2Fidem%2Fstruct_lits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7579f6f6d9799b13259417f66c008b4f0a1ed38/tests%2Fidem%2Fstruct_lits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fidem%2Fstruct_lits.rs?ref=b7579f6f6d9799b13259417f66c008b4f0a1ed38", "patch": "@@ -0,0 +1,24 @@\n+// Struct literal expressions.\n+\n+fn main() {\n+    let x = Bar;\n+\n+    // Comment\n+    let y = Foo { a: x };\n+\n+    Foo { a: Bar, b: foo() };\n+\n+    Foo { a: foo(), b: bar(), ..something };\n+\n+    Foooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: foo(), b: bar() };\n+    Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: foo(),\n+                                                                               b: bar(), };\n+\n+    Fooooooooooooooooooooooooooooooooooooooooooooooooooooo { a: foo(),\n+                                                             b: bar(),\n+                                                             c: bar(),\n+                                                             d: bar(),\n+                                                             e: bar(),\n+                                                             f: bar(),\n+                                                             ..baz() };\n+}"}, {"sha": "0852b5c31990adbdbf9e4f98528a5d5bfc51be92", "filename": "tests/idem/structs.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b7579f6f6d9799b13259417f66c008b4f0a1ed38/tests%2Fidem%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7579f6f6d9799b13259417f66c008b4f0a1ed38/tests%2Fidem%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fidem%2Fstructs.rs?ref=b7579f6f6d9799b13259417f66c008b4f0a1ed38", "patch": "@@ -0,0 +1,37 @@\n+\n+/// A Doc comment\n+#[AnAttribute]\n+pub struct Foo {\n+    #[rustfmt_skip]\n+    f :   SomeType, // Comment beside a field\n+    f: SomeType, // Comment beside a field\n+    // Comment on a field\n+    #[AnAttribute]\n+    g: SomeOtherType,\n+    /// A doc comment on a field\n+    h: AThirdType,\n+}\n+\n+struct Bar;\n+\n+// With a where clause and generics.\n+pub struct Foo<'a, Y: Baz>\n+    where X: Whatever\n+{\n+    f: SomeType, // Comment beside a field\n+}\n+\n+struct Baz {\n+    a: A, // Comment A\n+    b: B, // Comment B\n+    c: C, // Comment C\n+}\n+\n+struct Baz {\n+    // Comment A\n+    a: A,\n+    // Comment B\n+    b: B,\n+    // Comment C\n+    c: C,\n+}"}]}