{"sha": "d595b113584f8f446957469951fd5d31adc2a44e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1OTViMTEzNTg0ZjhmNDQ2OTU3NDY5OTUxZmQ1ZDMxYWRjMmE0NGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-10T19:56:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-10T19:56:15Z"}, "message": "Auto merge of #60708 - Centril:rollup-j5smdo0, r=Centril\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #60529 (RFC 2008: Uninhabitedness fixes for enum variants and tests)\n - #60620 (Fix a couple of FIXMEs in ext::tt::transcribe)\n - #60659 (Tweak `Symbol` and `InternedString`)\n - #60692 (Extend #60676 test for nested mut patterns.)\n - #60697 (add regression test for #60629)\n - #60701 (Update mailmap for mati865)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d10ce3919c64959afcebbcd361097565f80ccd64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d10ce3919c64959afcebbcd361097565f80ccd64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d595b113584f8f446957469951fd5d31adc2a44e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d595b113584f8f446957469951fd5d31adc2a44e", "html_url": "https://github.com/rust-lang/rust/commit/d595b113584f8f446957469951fd5d31adc2a44e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d595b113584f8f446957469951fd5d31adc2a44e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cff1bdbd77d29a28a94ff9f5bf1e1c84e5bb6259", "url": "https://api.github.com/repos/rust-lang/rust/commits/cff1bdbd77d29a28a94ff9f5bf1e1c84e5bb6259", "html_url": "https://github.com/rust-lang/rust/commit/cff1bdbd77d29a28a94ff9f5bf1e1c84e5bb6259"}, {"sha": "329275a06f53c2655a59c0dbdd65af365fcdd746", "url": "https://api.github.com/repos/rust-lang/rust/commits/329275a06f53c2655a59c0dbdd65af365fcdd746", "html_url": "https://github.com/rust-lang/rust/commit/329275a06f53c2655a59c0dbdd65af365fcdd746"}], "stats": {"total": 1151, "additions": 1106, "deletions": 45}, "files": [{"sha": "63a49cd413287437a4f57c13ec5479d330d6438f", "filename": ".mailmap", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -155,6 +155,8 @@ Mark Sinclair <mark.edward.x@gmail.com> =Mark Sinclair <=125axel125@gmail.com>\n Markus Westerlind <marwes91@gmail.com> Markus <marwes91@gmail.com>\n Martin Hafskjold Thoresen <martinhath@gmail.com>\n Matej Lach <matej.lach@gmail.com> Matej \u013dach <matej.lach@gmail.com>\n+Mateusz Miku\u0142a <matti@marinelayer.io> <mati865@gmail.com>\n+Mateusz Miku\u0142a <matti@marinelayer.io> <mati865@users.noreply.github.com>\n Matt Brubeck <mbrubeck@limpet.net> <mbrubeck@cs.hmc.edu>\n Matthew Auld <matthew.auld@intel.com>\n Matthew McPherrin <matthew@mcpherrin.ca> <matt@mcpherrin.ca>"}, {"sha": "be1d973c2cdd58363b7c15e855daffacb60c0c31", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -113,9 +113,14 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         substs: SubstsRef<'tcx>) -> DefIdForest\n     {\n-        DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n-            v.uninhabited_from(tcx, substs, self.adt_kind())\n-        }))\n+        // Non-exhaustive ADTs from other crates are always considered inhabited.\n+        if self.is_variant_list_non_exhaustive() && !self.did.is_local() {\n+            DefIdForest::empty()\n+        } else {\n+            DefIdForest::intersection(tcx, self.variants.iter().map(|v| {\n+                v.uninhabited_from(tcx, substs, self.adt_kind())\n+            }))\n+        }\n     }\n }\n \n@@ -134,9 +139,14 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n             AdtKind::Enum => true,\n             AdtKind::Struct => false,\n         };\n-        DefIdForest::union(tcx, self.fields.iter().map(|f| {\n-            f.uninhabited_from(tcx, substs, is_enum)\n-        }))\n+        // Non-exhaustive variants from other crates are always considered inhabited.\n+        if self.is_field_list_non_exhaustive() && !self.def_id.is_local() {\n+            DefIdForest::empty()\n+        } else {\n+            DefIdForest::union(tcx, self.fields.iter().map(|f| {\n+                f.uninhabited_from(tcx, substs, is_enum)\n+            }))\n+        }\n     }\n }\n "}, {"sha": "fd4416fc2b7632acfd07a8efc5d50dc3cf108c19", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -388,6 +388,18 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn is_non_exhaustive_variant<'p>(&self, pattern: &'p Pattern<'tcx>) -> bool\n+        where 'a: 'p\n+    {\n+        match *pattern.kind {\n+            PatternKind::Variant { adt_def, variant_index, .. } => {\n+                let ref variant = adt_def.variants[variant_index];\n+                variant.is_field_list_non_exhaustive()\n+            }\n+            _ => false,\n+        }\n+    }\n+\n     fn is_non_exhaustive_enum(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n             ty::Adt(adt_def, ..) => adt_def.is_variant_list_non_exhaustive(),\n@@ -1097,10 +1109,17 @@ pub fn is_useful<'p, 'a: 'p, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n     debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v[0]);\n \n     if let Some(constructors) = pat_constructors(cx, v[0], pcx) {\n-        debug!(\"is_useful - expanding constructors: {:#?}\", constructors);\n-        split_grouped_constructors(cx.tcx, constructors, matrix, pcx.ty).into_iter().map(|c|\n-            is_useful_specialized(cx, matrix, v, c, pcx.ty, witness)\n-        ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n+        let is_declared_nonexhaustive = cx.is_non_exhaustive_variant(v[0]) && !cx.is_local(pcx.ty);\n+        debug!(\"is_useful - expanding constructors: {:#?}, is_declared_nonexhaustive: {:?}\",\n+               constructors, is_declared_nonexhaustive);\n+\n+        if is_declared_nonexhaustive {\n+            Useful\n+        } else {\n+            split_grouped_constructors(cx.tcx, constructors, matrix, pcx.ty).into_iter().map(|c|\n+                is_useful_specialized(cx, matrix, v, c, pcx.ty, witness)\n+            ).find(|result| result.is_useful()).unwrap_or(NotUseful)\n+        }\n     } else {\n         debug!(\"is_useful - expanding wildcard\");\n "}, {"sha": "8c7155e1df351ed6417bb85eae7916de6aabb0d2", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -208,7 +208,11 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                                     .map(|variant| variant.ident)\n                                     .collect();\n                             }\n-                            def.variants.is_empty()\n+\n+                            let is_non_exhaustive_and_non_local =\n+                                def.is_variant_list_non_exhaustive() && !def.did.is_local();\n+\n+                            !(is_non_exhaustive_and_non_local) && def.variants.is_empty()\n                         },\n                         _ => false\n                     }"}, {"sha": "e3586c1854c1775b083dea9015106be62b7c7506", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -170,10 +170,9 @@ pub fn transcribe(\n                     }\n \n                     LockstepIterSize::Contradiction(ref msg) => {\n-                        // FIXME: this should be impossible. I (mark-i-m) believe it would\n-                        // represent a bug in the macro_parser.\n-                        // FIXME #2887 blame macro invoker instead\n-                        cx.span_fatal(seq.span(), &msg[..]);\n+                        // This should never happen because the macro parser should generate\n+                        // properly-sized matches for all meta-vars.\n+                        cx.span_bug(seq.span(), &msg[..]);\n                     }\n \n                     LockstepIterSize::Constraint(len, _) => {\n@@ -188,14 +187,13 @@ pub fn transcribe(\n                         // Is the repetition empty?\n                         if len == 0 {\n                             if seq.op == quoted::KleeneOp::OneOrMore {\n-                                // FIXME: this should be impossible because we check for this in\n-                                // macro_parser.rs\n-                                // FIXME #2887 blame invoker\n-                                cx.span_fatal(sp.entire(), \"this must repeat at least once\");\n+                                // This should be impossible because the macro parser would not\n+                                // match the given macro arm.\n+                                cx.span_bug(sp.entire(), \"this must repeat at least once\");\n                             }\n                         } else {\n                             // 0 is the initial counter (we have done 0 repretitions so far). `len`\n-                            //   is the total number of reptitions we should generate.\n+                            // is the total number of reptitions we should generate.\n                             repeats.push((0, len));\n \n                             // The first time we encounter the sequence we push it to the stack. It"}, {"sha": "d0ba09af30b061cbd1e3084851b0f848000fd075", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 60, "deletions": 24, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -344,9 +344,22 @@ impl Decodable for Ident {\n     }\n }\n \n-/// A symbol is an interned or gensymed string. The use of `newtype_index!` means\n-/// that `Option<Symbol>` only takes up 4 bytes, because `newtype_index!` reserves\n-/// the last 256 values for tagging purposes.\n+/// A symbol is an interned or gensymed string. A gensym is a symbol that is\n+/// never equal to any other symbol. E.g.:\n+/// ```\n+/// assert_eq!(Symbol::intern(\"x\"), Symbol::intern(\"x\"))\n+/// assert_ne!(Symbol::gensym(\"x\"), Symbol::intern(\"x\"))\n+/// assert_ne!(Symbol::gensym(\"x\"), Symbol::gensym(\"x\"))\n+/// ```\n+/// Conceptually, a gensym can be thought of as a normal symbol with an\n+/// invisible unique suffix. Gensyms are useful when creating new identifiers\n+/// that must not match any existing identifiers, e.g. during macro expansion\n+/// and syntax desugaring.\n+///\n+/// Internally, a Symbol is implemented as an index, and all operations\n+/// (including hashing, equality, and ordering) operate on that index. The use\n+/// of `newtype_index!` means that `Option<Symbol>` only takes up 4 bytes,\n+/// because `newtype_index!` reserves the last 256 values for tagging purposes.\n ///\n /// Note that `Symbol` cannot directly be a `newtype_index!` because it implements\n /// `fmt::Debug`, `Encodable`, and `Decodable` in special ways.\n@@ -367,10 +380,6 @@ impl Symbol {\n         with_interner(|interner| interner.intern(string))\n     }\n \n-    pub fn interned(self) -> Self {\n-        with_interner(|interner| interner.interned(self))\n-    }\n-\n     /// Gensyms a new `usize`, using the current interner.\n     pub fn gensym(string: &str) -> Self {\n         with_interner(|interner| interner.gensym(string))\n@@ -380,6 +389,7 @@ impl Symbol {\n         with_interner(|interner| interner.gensymed(self))\n     }\n \n+    // WARNING: this function is deprecated and will be removed in the future.\n     pub fn is_gensymed(self) -> bool {\n         with_interner(|interner| interner.is_gensymed(self))\n     }\n@@ -488,11 +498,11 @@ impl Interner {\n         name\n     }\n \n-    pub fn interned(&self, symbol: Symbol) -> Symbol {\n+    fn interned(&self, symbol: Symbol) -> Symbol {\n         if (symbol.0.as_usize()) < self.strings.len() {\n             symbol\n         } else {\n-            self.interned(self.gensyms[(SymbolIndex::MAX_AS_U32 - symbol.0.as_u32()) as usize])\n+            self.gensyms[(SymbolIndex::MAX_AS_U32 - symbol.0.as_u32()) as usize]\n         }\n     }\n \n@@ -510,10 +520,15 @@ impl Interner {\n         symbol.0.as_usize() >= self.strings.len()\n     }\n \n+    // Get the symbol as a string. `Symbol::as_str()` should be used in\n+    // preference to this function.\n     pub fn get(&self, symbol: Symbol) -> &str {\n         match self.strings.get(symbol.0.as_usize()) {\n             Some(string) => string,\n-            None => self.get(self.gensyms[(SymbolIndex::MAX_AS_U32 - symbol.0.as_u32()) as usize]),\n+            None => {\n+                let symbol = self.gensyms[(SymbolIndex::MAX_AS_U32 - symbol.0.as_u32()) as usize];\n+                self.strings[symbol.0.as_usize()]\n+            }\n         }\n     }\n }\n@@ -611,11 +626,17 @@ fn with_interner<T, F: FnOnce(&mut Interner) -> T>(f: F) -> T {\n     GLOBALS.with(|globals| f(&mut *globals.symbol_interner.lock()))\n }\n \n-/// Represents a string stored in the interner. Because the interner outlives any thread\n-/// which uses this type, we can safely treat `string` which points to interner data,\n-/// as an immortal string, as long as this type never crosses between threads.\n-// FIXME: ensure that the interner outlives any thread which uses `LocalInternedString`,\n-// by creating a new thread right after constructing the interner.\n+/// An alternative to `Symbol` and `InternedString`, useful when the chars\n+/// within the symbol need to be accessed. It is best used for temporary\n+/// values.\n+///\n+/// Because the interner outlives any thread which uses this type, we can\n+/// safely treat `string` which points to interner data, as an immortal string,\n+/// as long as this type never crosses between threads.\n+//\n+// FIXME: ensure that the interner outlives any thread which uses\n+// `LocalInternedString`, by creating a new thread right after constructing the\n+// interner.\n #[derive(Clone, Copy, Hash, PartialOrd, Eq, Ord)]\n pub struct LocalInternedString {\n     string: &'static str,\n@@ -708,7 +729,19 @@ impl Encodable for LocalInternedString {\n     }\n }\n \n-/// Represents a string stored in the string interner.\n+/// An alternative to `Symbol` that is focused on string contents. It has two\n+/// main differences to `Symbol`.\n+///\n+/// First, its implementations of `Hash`, `PartialOrd` and `Ord` work with the\n+/// string chars rather than the symbol integer. This is useful when hash\n+/// stability is required across compile sessions, or a guaranteed sort\n+/// ordering is required.\n+///\n+/// Second, gensym-ness is irrelevant. E.g.:\n+/// ```\n+/// assert_ne!(Symbol::gensym(\"x\"), Symbol::gensym(\"x\"))\n+/// assert_eq!(Symbol::gensym(\"x\").as_interned_str(), Symbol::gensym(\"x\").as_interned_str())\n+/// ```\n #[derive(Clone, Copy, Eq)]\n pub struct InternedString {\n     symbol: Symbol,\n@@ -725,6 +758,15 @@ impl InternedString {\n         unsafe { f(&*str) }\n     }\n \n+    fn with2<F: FnOnce(&str, &str) -> R, R>(self, other: &InternedString, f: F) -> R {\n+        let (self_str, other_str) = with_interner(|interner| {\n+            (interner.get(self.symbol) as *const str,\n+             interner.get(other.symbol) as *const str)\n+        });\n+        // This is safe for the same reason that `with` is safe.\n+        unsafe { f(&*self_str, &*other_str) }\n+    }\n+\n     pub fn as_symbol(self) -> Symbol {\n         self.symbol\n     }\n@@ -745,7 +787,7 @@ impl PartialOrd<InternedString> for InternedString {\n         if self.symbol == other.symbol {\n             return Some(Ordering::Equal);\n         }\n-        self.with(|self_str| other.with(|other_str| self_str.partial_cmp(other_str)))\n+        self.with2(other, |self_str, other_str| self_str.partial_cmp(other_str))\n     }\n }\n \n@@ -754,7 +796,7 @@ impl Ord for InternedString {\n         if self.symbol == other.symbol {\n             return Ordering::Equal;\n         }\n-        self.with(|self_str| other.with(|other_str| self_str.cmp(&other_str)))\n+        self.with2(other, |self_str, other_str| self_str.cmp(other_str))\n     }\n }\n \n@@ -794,12 +836,6 @@ impl<'a> PartialEq<InternedString> for &'a String {\n     }\n }\n \n-impl std::convert::From<InternedString> for String {\n-    fn from(val: InternedString) -> String {\n-        val.as_symbol().to_string()\n-    }\n-}\n-\n impl fmt::Debug for InternedString {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.with(|str| fmt::Debug::fmt(&str, f))"}, {"sha": "4807af4b3cf708f9e415ef900868f06e773ab531", "filename": "src/test/incremental/issue-60629.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fincremental%2Fissue-60629.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fincremental%2Fissue-60629.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-60629.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,10 @@\n+// revisions:rpass1 rpass2\n+\n+struct A;\n+\n+#[cfg(rpass2)]\n+impl From<A> for () {\n+    fn from(_: A) {}\n+}\n+\n+fn main() {}"}, {"sha": "ecb80803383b4c5bd253f3186426ae003b281cab", "filename": "src/test/ui/async-await/issue-60674.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Fasync-await%2Fissue-60674.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Fasync-await%2Fissue-60674.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-60674.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -11,4 +11,10 @@ extern crate issue_60674;\n #[issue_60674::attr]\n async fn f(mut x: u8) {}\n \n+#[issue_60674::attr]\n+async fn g((mut x, y, mut z): (u8, u8, u8)) {}\n+\n+#[issue_60674::attr]\n+async fn g(mut x: u8, (a, mut b, c): (u8, u8, u8), y: u8) {}\n+\n fn main() {}"}, {"sha": "86c3591b3afc0138df9329ed9df78cbbf0ce2dae", "filename": "src/test/ui/async-await/issue-60674.stdout", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Fasync-await%2Fissue-60674.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Fasync-await%2Fissue-60674.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-60674.stdout?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -1 +1,3 @@\n async fn f(mut x: u8) { }\n+async fn g((mut x, y, mut z): (u8, u8, u8)) { }\n+async fn g(mut x: u8, (a, mut b, c): (u8, u8, u8), y: u8) { }"}, {"sha": "260c2e04d74f78a9bf6dfa188df0c03a3bb19bc0", "filename": "src/test/ui/pattern/const-pat-ice.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fconst-pat-ice.stderr?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -1,4 +1,4 @@\n-thread 'rustc' panicked at 'assertion failed: rows.iter().all(|r| r.len() == v.len())', src/librustc_mir/hair/pattern/_match.rs:1071:5\n+thread 'rustc' panicked at 'assertion failed: rows.iter().all(|r| r.len() == v.len())', src/librustc_mir/hair/pattern/_match.rs:1083:5\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n error: internal compiler error: unexpected panic"}, {"sha": "8cb9a8cf1f6133463e5a318a387d6301b4181f8e", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/auxiliary/uninhabited.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fauxiliary%2Funinhabited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fauxiliary%2Funinhabited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fauxiliary%2Funinhabited.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,33 @@\n+#![crate_type = \"rlib\"]\n+#![feature(never_type)]\n+#![feature(non_exhaustive)]\n+\n+#[non_exhaustive]\n+pub enum UninhabitedEnum {\n+}\n+\n+#[non_exhaustive]\n+pub struct UninhabitedStruct {\n+    _priv: !,\n+}\n+\n+#[non_exhaustive]\n+pub struct UninhabitedTupleStruct(!);\n+\n+pub enum UninhabitedVariants {\n+    #[non_exhaustive] Tuple(!),\n+    #[non_exhaustive] Struct { x: ! }\n+}\n+\n+pub enum PartiallyInhabitedVariants {\n+    Tuple(u8),\n+    #[non_exhaustive] Struct { x: ! }\n+}\n+\n+pub struct IndirectUninhabitedEnum(UninhabitedEnum);\n+\n+pub struct IndirectUninhabitedStruct(UninhabitedStruct);\n+\n+pub struct IndirectUninhabitedTupleStruct(UninhabitedTupleStruct);\n+\n+pub struct IndirectUninhabitedVariants(UninhabitedVariants);"}, {"sha": "80b9dc4c1c338c80be9addad9ade8cf503adb9ac", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/coercions.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,38 @@\n+// aux-build:uninhabited.rs\n+#![feature(never_type)]\n+\n+extern crate uninhabited;\n+\n+use uninhabited::{\n+    UninhabitedEnum,\n+    UninhabitedStruct,\n+    UninhabitedTupleStruct,\n+    UninhabitedVariants,\n+};\n+\n+// This test checks that uninhabited non-exhaustive types cannot coerce to any type, as the never\n+// type can.\n+\n+struct A;\n+\n+fn can_coerce_never_type_to_anything(x: !) -> A {\n+    x\n+}\n+\n+fn cannot_coerce_empty_enum_to_anything(x: UninhabitedEnum) -> A {\n+    x //~ ERROR mismatched types\n+}\n+\n+fn cannot_coerce_empty_tuple_struct_to_anything(x: UninhabitedTupleStruct) -> A {\n+    x //~ ERROR mismatched types\n+}\n+\n+fn cannot_coerce_empty_struct_to_anything(x: UninhabitedStruct) -> A {\n+    x //~ ERROR mismatched types\n+}\n+\n+fn cannot_coerce_enum_with_empty_variants_to_anything(x: UninhabitedVariants) -> A {\n+    x //~ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "d05ee1d39ec3555b3db7b9e1131b74f703d628c8", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/coercions.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions.stderr?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,47 @@\n+error[E0308]: mismatched types\n+  --> $DIR/coercions.rs:23:5\n+   |\n+LL | fn cannot_coerce_empty_enum_to_anything(x: UninhabitedEnum) -> A {\n+   |                                                                - expected `A` because of return type\n+LL |     x\n+   |     ^ expected struct `A`, found enum `uninhabited::UninhabitedEnum`\n+   |\n+   = note: expected type `A`\n+              found type `uninhabited::UninhabitedEnum`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coercions.rs:27:5\n+   |\n+LL | fn cannot_coerce_empty_tuple_struct_to_anything(x: UninhabitedTupleStruct) -> A {\n+   |                                                                               - expected `A` because of return type\n+LL |     x\n+   |     ^ expected struct `A`, found struct `uninhabited::UninhabitedTupleStruct`\n+   |\n+   = note: expected type `A`\n+              found type `uninhabited::UninhabitedTupleStruct`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coercions.rs:31:5\n+   |\n+LL | fn cannot_coerce_empty_struct_to_anything(x: UninhabitedStruct) -> A {\n+   |                                                                    - expected `A` because of return type\n+LL |     x\n+   |     ^ expected struct `A`, found struct `uninhabited::UninhabitedStruct`\n+   |\n+   = note: expected type `A`\n+              found type `uninhabited::UninhabitedStruct`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coercions.rs:35:5\n+   |\n+LL | fn cannot_coerce_enum_with_empty_variants_to_anything(x: UninhabitedVariants) -> A {\n+   |                                                                                  - expected `A` because of return type\n+LL |     x\n+   |     ^ expected struct `A`, found enum `uninhabited::UninhabitedVariants`\n+   |\n+   = note: expected type `A`\n+              found type `uninhabited::UninhabitedVariants`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "803a542f8aa4bab15c265892f401c7e6143eb4ce", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/coercions_same_crate.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions_same_crate.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,46 @@\n+#![feature(never_type)]\n+#![feature(non_exhaustive)]\n+\n+#[non_exhaustive]\n+pub enum UninhabitedEnum {\n+}\n+\n+#[non_exhaustive]\n+pub struct UninhabitedTupleStruct(!);\n+\n+#[non_exhaustive]\n+pub struct UninhabitedStruct {\n+    _priv: !,\n+}\n+\n+pub enum UninhabitedVariants {\n+    #[non_exhaustive] Tuple(!),\n+    #[non_exhaustive] Struct { x: ! }\n+}\n+\n+struct A;\n+\n+// This test checks that uninhabited non-exhaustive types defined in the same crate cannot coerce\n+// to any type, as the never type can.\n+\n+fn can_coerce_never_type_to_anything(x: !) -> A {\n+    x\n+}\n+\n+fn cannot_coerce_empty_enum_to_anything(x: UninhabitedEnum) -> A {\n+    x //~ ERROR mismatched types\n+}\n+\n+fn cannot_coerce_empty_tuple_struct_to_anything(x: UninhabitedTupleStruct) -> A {\n+    x //~ ERROR mismatched types\n+}\n+\n+fn cannot_coerce_empty_struct_to_anything(x: UninhabitedStruct) -> A {\n+    x //~ ERROR mismatched types\n+}\n+\n+fn cannot_coerce_enum_with_empty_variants_to_anything(x: UninhabitedVariants) -> A {\n+    x //~ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "8f6b709bb1f3405925437227873e9a96283c716b", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/coercions_same_crate.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fcoercions_same_crate.stderr?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,47 @@\n+error[E0308]: mismatched types\n+  --> $DIR/coercions_same_crate.rs:31:5\n+   |\n+LL | fn cannot_coerce_empty_enum_to_anything(x: UninhabitedEnum) -> A {\n+   |                                                                - expected `A` because of return type\n+LL |     x\n+   |     ^ expected struct `A`, found enum `UninhabitedEnum`\n+   |\n+   = note: expected type `A`\n+              found type `UninhabitedEnum`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coercions_same_crate.rs:35:5\n+   |\n+LL | fn cannot_coerce_empty_tuple_struct_to_anything(x: UninhabitedTupleStruct) -> A {\n+   |                                                                               - expected `A` because of return type\n+LL |     x\n+   |     ^ expected struct `A`, found struct `UninhabitedTupleStruct`\n+   |\n+   = note: expected type `A`\n+              found type `UninhabitedTupleStruct`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coercions_same_crate.rs:39:5\n+   |\n+LL | fn cannot_coerce_empty_struct_to_anything(x: UninhabitedStruct) -> A {\n+   |                                                                    - expected `A` because of return type\n+LL |     x\n+   |     ^ expected struct `A`, found struct `UninhabitedStruct`\n+   |\n+   = note: expected type `A`\n+              found type `UninhabitedStruct`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coercions_same_crate.rs:43:5\n+   |\n+LL | fn cannot_coerce_enum_with_empty_variants_to_anything(x: UninhabitedVariants) -> A {\n+   |                                                                                  - expected `A` because of return type\n+LL |     x\n+   |     ^ expected struct `A`, found enum `UninhabitedVariants`\n+   |\n+   = note: expected type `A`\n+              found type `UninhabitedVariants`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "98a7fdbc5049abe48cf39a87ded6105a243d1ab5", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,36 @@\n+// aux-build:uninhabited.rs\n+#![feature(never_type)]\n+\n+extern crate uninhabited;\n+\n+use uninhabited::{\n+    IndirectUninhabitedEnum,\n+    IndirectUninhabitedStruct,\n+    IndirectUninhabitedTupleStruct,\n+    IndirectUninhabitedVariants,\n+};\n+\n+struct A;\n+\n+// This test checks that an empty match on a non-exhaustive uninhabited type through a level of\n+// indirection from an extern crate will not compile.\n+\n+fn cannot_empty_match_on_empty_enum_to_anything(x: IndirectUninhabitedEnum) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_empty_struct_to_anything(x: IndirectUninhabitedStruct) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_empty_tuple_struct_to_anything(x: IndirectUninhabitedTupleStruct) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_enum_with_empty_variants_struct_to_anything(\n+    x: IndirectUninhabitedVariants,\n+) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn main() {}"}, {"sha": "af82022e1da99d39b005897809fda741ac2608fc", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match.stderr?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,35 @@\n+error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedEnum` of type `uninhabited::IndirectUninhabitedEnum` is not handled\n+  --> $DIR/indirect_match.rs:19:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedStruct` of type `uninhabited::IndirectUninhabitedStruct` is not handled\n+  --> $DIR/indirect_match.rs:23:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedTupleStruct` of type `uninhabited::IndirectUninhabitedTupleStruct` is not handled\n+  --> $DIR/indirect_match.rs:27:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedVariants` of type `uninhabited::IndirectUninhabitedVariants` is not handled\n+  --> $DIR/indirect_match.rs:33:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "3c8d495e12cb6ef35528cc3e306c3391e3170654", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_same_crate.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,52 @@\n+#![feature(never_type)]\n+#![feature(non_exhaustive)]\n+\n+#[non_exhaustive]\n+pub enum UninhabitedEnum {\n+}\n+\n+#[non_exhaustive]\n+pub struct UninhabitedStruct {\n+    _priv: !,\n+}\n+\n+#[non_exhaustive]\n+pub struct UninhabitedTupleStruct(!);\n+\n+pub enum UninhabitedVariants {\n+    #[non_exhaustive] Tuple(!),\n+    #[non_exhaustive] Struct { x: ! }\n+}\n+\n+pub struct IndirectUninhabitedEnum(UninhabitedEnum);\n+\n+pub struct IndirectUninhabitedStruct(UninhabitedStruct);\n+\n+pub struct IndirectUninhabitedTupleStruct(UninhabitedTupleStruct);\n+\n+pub struct IndirectUninhabitedVariants(UninhabitedVariants);\n+\n+struct A;\n+\n+// This test checks that an empty match on a non-exhaustive uninhabited type through a level of\n+// indirection from the defining crate will not compile without `#![feature(exhaustive_patterns)]`.\n+\n+fn cannot_empty_match_on_empty_enum_to_anything(x: IndirectUninhabitedEnum) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_empty_struct_to_anything(x: IndirectUninhabitedStruct) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_empty_tuple_struct_to_anything(x: IndirectUninhabitedTupleStruct) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_enum_with_empty_variants_struct_to_anything(\n+    x: IndirectUninhabitedVariants,\n+) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn main() {}"}, {"sha": "27b120792d6d1ee89c55f1fd9cb4f16216fb3ae3", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_same_crate.stderr", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_same_crate.stderr?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,59 @@\n+error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedEnum` of type `IndirectUninhabitedEnum` is not handled\n+  --> $DIR/indirect_match_same_crate.rs:35:11\n+   |\n+LL | pub struct IndirectUninhabitedEnum(UninhabitedEnum);\n+   | ----------------------------------------------------\n+   | |          |\n+   | |          variant not covered\n+   | `IndirectUninhabitedEnum` defined here\n+...\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedStruct` of type `IndirectUninhabitedStruct` is not handled\n+  --> $DIR/indirect_match_same_crate.rs:39:11\n+   |\n+LL | pub struct IndirectUninhabitedStruct(UninhabitedStruct);\n+   | --------------------------------------------------------\n+   | |          |\n+   | |          variant not covered\n+   | `IndirectUninhabitedStruct` defined here\n+...\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedTupleStruct` of type `IndirectUninhabitedTupleStruct` is not handled\n+  --> $DIR/indirect_match_same_crate.rs:43:11\n+   |\n+LL | pub struct IndirectUninhabitedTupleStruct(UninhabitedTupleStruct);\n+   | ------------------------------------------------------------------\n+   | |          |\n+   | |          variant not covered\n+   | `IndirectUninhabitedTupleStruct` defined here\n+...\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: pattern `IndirectUninhabitedVariants` of type `IndirectUninhabitedVariants` is not handled\n+  --> $DIR/indirect_match_same_crate.rs:49:11\n+   |\n+LL | pub struct IndirectUninhabitedVariants(UninhabitedVariants);\n+   | ------------------------------------------------------------\n+   | |          |\n+   | |          variant not covered\n+   | `IndirectUninhabitedVariants` defined here\n+...\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "be86519ecb159cdf961f06dfeb856d4d906dc0dc", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_with_exhaustive_patterns.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,40 @@\n+// aux-build:uninhabited.rs\n+#![deny(unreachable_patterns)]\n+#![feature(exhaustive_patterns)]\n+#![feature(never_type)]\n+\n+extern crate uninhabited;\n+\n+use uninhabited::{\n+    IndirectUninhabitedEnum,\n+    IndirectUninhabitedStruct,\n+    IndirectUninhabitedTupleStruct,\n+    IndirectUninhabitedVariants,\n+};\n+\n+struct A;\n+\n+// This test checks that an empty match on a non-exhaustive uninhabited type through a level of\n+// indirection from an extern crate will not compile. In particular, this enables the\n+// `exhaustive_patterns` feature as this can change the branch used in the compiler to determine\n+// this.\n+\n+fn cannot_empty_match_on_empty_enum_to_anything(x: IndirectUninhabitedEnum) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_empty_struct_to_anything(x: IndirectUninhabitedStruct) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_empty_tuple_struct_to_anything(x: IndirectUninhabitedTupleStruct) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_enum_with_empty_variants_struct_to_anything(\n+    x: IndirectUninhabitedVariants,\n+) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn main() {}"}, {"sha": "17a8d01007205972ccf42cdfa594a23907d7b9ad", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_with_exhaustive_patterns.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns.stderr?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,35 @@\n+error[E0004]: non-exhaustive patterns: type `uninhabited::IndirectUninhabitedEnum` is non-empty\n+  --> $DIR/indirect_match_with_exhaustive_patterns.rs:23:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: type `uninhabited::IndirectUninhabitedStruct` is non-empty\n+  --> $DIR/indirect_match_with_exhaustive_patterns.rs:27:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: type `uninhabited::IndirectUninhabitedTupleStruct` is non-empty\n+  --> $DIR/indirect_match_with_exhaustive_patterns.rs:31:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: type `uninhabited::IndirectUninhabitedVariants` is non-empty\n+  --> $DIR/indirect_match_with_exhaustive_patterns.rs:37:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "5dbd38e07df0251945c22899f348b0c5aa85ede9", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/indirect_match_with_exhaustive_patterns_same_crate.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Findirect_match_with_exhaustive_patterns_same_crate.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,58 @@\n+// compile-pass\n+// skip-codegen\n+#![deny(unreachable_patterns)]\n+#![feature(exhaustive_patterns)]\n+#![feature(never_type)]\n+#![feature(non_exhaustive)]\n+\n+#[non_exhaustive]\n+pub enum UninhabitedEnum {\n+}\n+\n+#[non_exhaustive]\n+pub struct UninhabitedStruct {\n+    _priv: !,\n+}\n+\n+#[non_exhaustive]\n+pub struct UninhabitedTupleStruct(!);\n+\n+pub enum UninhabitedVariants {\n+    #[non_exhaustive] Tuple(!),\n+    #[non_exhaustive] Struct { x: ! }\n+}\n+\n+pub struct IndirectUninhabitedEnum(UninhabitedEnum);\n+\n+pub struct IndirectUninhabitedStruct(UninhabitedStruct);\n+\n+pub struct IndirectUninhabitedTupleStruct(UninhabitedTupleStruct);\n+\n+pub struct IndirectUninhabitedVariants(UninhabitedVariants);\n+\n+struct A;\n+\n+// This test checks that an empty match on a non-exhaustive uninhabited type from the defining crate\n+// will compile. In particular, this enables the `exhaustive_patterns` feature as this can\n+// change the branch used in the compiler to determine this.\n+// Codegen is skipped because tests with long names can cause issues on Windows CI, see #60648.\n+\n+fn cannot_empty_match_on_empty_enum_to_anything(x: IndirectUninhabitedEnum) -> A {\n+    match x {}\n+}\n+\n+fn cannot_empty_match_on_empty_struct_to_anything(x: IndirectUninhabitedStruct) -> A {\n+    match x {}\n+}\n+\n+fn cannot_empty_match_on_empty_tuple_struct_to_anything(x: IndirectUninhabitedTupleStruct) -> A {\n+    match x {}\n+}\n+\n+fn cannot_empty_match_on_enum_with_empty_variants_struct_to_anything(\n+    x: IndirectUninhabitedVariants,\n+) -> A {\n+    match x {}\n+}\n+\n+fn main() {}"}, {"sha": "e54098d4d48b958fae8839616e29b6b9460b1bcb", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,34 @@\n+// aux-build:uninhabited.rs\n+#![feature(never_type)]\n+\n+extern crate uninhabited;\n+\n+use uninhabited::{\n+    UninhabitedEnum,\n+    UninhabitedStruct,\n+    UninhabitedTupleStruct,\n+    UninhabitedVariants,\n+};\n+\n+struct A;\n+\n+// This test checks that an empty match on a non-exhaustive uninhabited type from an extern crate\n+// will not compile.\n+\n+fn cannot_empty_match_on_empty_enum_to_anything(x: UninhabitedEnum) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_empty_struct_to_anything(x: UninhabitedStruct) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_empty_tuple_struct_to_anything(x: UninhabitedTupleStruct) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_enum_with_empty_variants_struct_to_anything(x: UninhabitedVariants) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn main() {}"}, {"sha": "de39688f45a4de2500f9b1a190f41426adbc7bed", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch.stderr?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,35 @@\n+error[E0004]: non-exhaustive patterns: type `uninhabited::UninhabitedEnum` is non-empty\n+  --> $DIR/match.rs:19:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: pattern `UninhabitedStruct` of type `uninhabited::UninhabitedStruct` is not handled\n+  --> $DIR/match.rs:23:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: pattern `UninhabitedTupleStruct` of type `uninhabited::UninhabitedTupleStruct` is not handled\n+  --> $DIR/match.rs:27:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: multiple patterns of type `uninhabited::UninhabitedVariants` are not handled\n+  --> $DIR/match.rs:31:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "6405dd3bd65b73048d0d63be75d0a94f068e4f87", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_same_crate.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,42 @@\n+#![feature(never_type)]\n+#![feature(non_exhaustive)]\n+\n+#[non_exhaustive]\n+pub enum UninhabitedEnum {\n+}\n+\n+#[non_exhaustive]\n+pub struct UninhabitedStruct {\n+    _priv: !,\n+}\n+\n+#[non_exhaustive]\n+pub struct UninhabitedTupleStruct(!);\n+\n+pub enum UninhabitedVariants {\n+    #[non_exhaustive] Tuple(!),\n+    #[non_exhaustive] Struct { x: ! }\n+}\n+\n+struct A;\n+\n+// This test checks that an empty match on a non-exhaustive uninhabited type from the defining crate\n+// will compile.\n+\n+fn cannot_empty_match_on_empty_enum_to_anything(x: UninhabitedEnum) -> A {\n+    match x {}\n+}\n+\n+fn cannot_empty_match_on_empty_struct_to_anything(x: UninhabitedStruct) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_empty_tuple_struct_to_anything(x: UninhabitedTupleStruct) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_enum_with_empty_variants_struct_to_anything(x: UninhabitedVariants) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn main() {}"}, {"sha": "410285a39a945eba9687ed7c4953af30c9255fad", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_same_crate.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_same_crate.stderr?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,49 @@\n+error[E0004]: non-exhaustive patterns: pattern `UninhabitedStruct` of type `UninhabitedStruct` is not handled\n+  --> $DIR/match_same_crate.rs:31:11\n+   |\n+LL |   pub struct UninhabitedStruct {\n+   |   -          ----------------- variant not covered\n+   |  _|\n+   | |\n+LL | |     _priv: !,\n+LL | | }\n+   | |_- `UninhabitedStruct` defined here\n+...\n+LL |       match x {}\n+   |             ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: pattern `UninhabitedTupleStruct` of type `UninhabitedTupleStruct` is not handled\n+  --> $DIR/match_same_crate.rs:35:11\n+   |\n+LL | pub struct UninhabitedTupleStruct(!);\n+   | -------------------------------------\n+   | |          |\n+   | |          variant not covered\n+   | `UninhabitedTupleStruct` defined here\n+...\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: multiple patterns of type `UninhabitedVariants` are not handled\n+  --> $DIR/match_same_crate.rs:39:11\n+   |\n+LL | / pub enum UninhabitedVariants {\n+LL | |     #[non_exhaustive] Tuple(!),\n+   | |                       ----- variant not covered\n+LL | |     #[non_exhaustive] Struct { x: ! }\n+   | |                       ------ variant not covered\n+LL | | }\n+   | |_- `UninhabitedVariants` defined here\n+...\n+LL |       match x {}\n+   |             ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "900dfff652ea6db465a898b8aa5088dabf79d4b2", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_with_exhaustive_patterns.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,37 @@\n+// aux-build:uninhabited.rs\n+#![deny(unreachable_patterns)]\n+#![feature(exhaustive_patterns)]\n+#![feature(never_type)]\n+\n+extern crate uninhabited;\n+\n+use uninhabited::{\n+    UninhabitedEnum,\n+    UninhabitedStruct,\n+    UninhabitedTupleStruct,\n+    UninhabitedVariants,\n+};\n+\n+struct A;\n+\n+// This test checks that an empty match on a non-exhaustive uninhabited type from an extern crate\n+// will not compile. In particular, this enables the `exhaustive_patterns` feature as this can\n+// change the branch used in the compiler to determine this.\n+\n+fn cannot_empty_match_on_empty_enum_to_anything(x: UninhabitedEnum) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_empty_struct_to_anything(x: UninhabitedStruct) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_empty_tuple_struct_to_anything(x: UninhabitedTupleStruct) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn cannot_empty_match_on_enum_with_empty_variants_struct_to_anything(x: UninhabitedVariants) -> A {\n+    match x {} //~ ERROR non-exhaustive patterns\n+}\n+\n+fn main() {}"}, {"sha": "48a888bc50be0b2f4fa91904eb9e31f87433e199", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_with_exhaustive_patterns.stderr", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns.stderr?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,35 @@\n+error[E0004]: non-exhaustive patterns: type `uninhabited::UninhabitedEnum` is non-empty\n+  --> $DIR/match_with_exhaustive_patterns.rs:22:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: type `uninhabited::UninhabitedStruct` is non-empty\n+  --> $DIR/match_with_exhaustive_patterns.rs:26:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: type `uninhabited::UninhabitedTupleStruct` is non-empty\n+  --> $DIR/match_with_exhaustive_patterns.rs:30:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error[E0004]: non-exhaustive patterns: type `uninhabited::UninhabitedVariants` is non-empty\n+  --> $DIR/match_with_exhaustive_patterns.rs:34:11\n+   |\n+LL |     match x {}\n+   |           ^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0004`."}, {"sha": "74922d4bcb5d546f274e71533f955174af2d20c1", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/match_with_exhaustive_patterns_same_crate.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fmatch_with_exhaustive_patterns_same_crate.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,48 @@\n+// compile-pass\n+// skip-codegen\n+#![deny(unreachable_patterns)]\n+#![feature(exhaustive_patterns)]\n+#![feature(never_type)]\n+#![feature(non_exhaustive)]\n+\n+#[non_exhaustive]\n+pub enum UninhabitedEnum {\n+}\n+\n+#[non_exhaustive]\n+pub struct UninhabitedStruct {\n+    _priv: !,\n+}\n+\n+#[non_exhaustive]\n+pub struct UninhabitedTupleStruct(!);\n+\n+pub enum UninhabitedVariants {\n+    #[non_exhaustive] Tuple(!),\n+    #[non_exhaustive] Struct { x: ! }\n+}\n+\n+struct A;\n+\n+// This test checks that an empty match on a non-exhaustive uninhabited type from the defining crate\n+// will compile. In particular, this enables the `exhaustive_patterns` feature as this can\n+// change the branch used in the compiler to determine this.\n+// Codegen is skipped because tests with long names can cause issues on Windows CI, see #60648.\n+\n+fn cannot_empty_match_on_empty_enum_to_anything(x: UninhabitedEnum) -> A {\n+    match x {}\n+}\n+\n+fn cannot_empty_match_on_empty_struct_to_anything(x: UninhabitedStruct) -> A {\n+    match x {}\n+}\n+\n+fn cannot_empty_match_on_empty_tuple_struct_to_anything(x: UninhabitedTupleStruct) -> A {\n+    match x {}\n+}\n+\n+fn cannot_empty_match_on_enum_with_empty_variants_struct_to_anything(x: UninhabitedVariants) -> A {\n+    match x {}\n+}\n+\n+fn main() {}"}, {"sha": "97061310d19e29e17f6a26049304f09194b8a86f", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/patterns.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,59 @@\n+// aux-build:uninhabited.rs\n+// compile-pass\n+#![deny(unreachable_patterns)]\n+#![feature(exhaustive_patterns)]\n+\n+extern crate uninhabited;\n+\n+use uninhabited::{\n+    PartiallyInhabitedVariants,\n+    UninhabitedEnum,\n+    UninhabitedStruct,\n+    UninhabitedTupleStruct,\n+    UninhabitedVariants,\n+};\n+\n+fn uninhabited_enum() -> Option<UninhabitedEnum> {\n+    None\n+}\n+\n+fn uninhabited_variant() -> Option<UninhabitedVariants> {\n+    None\n+}\n+\n+fn partially_inhabited_variant() -> PartiallyInhabitedVariants {\n+    PartiallyInhabitedVariants::Tuple(3)\n+}\n+\n+fn uninhabited_struct() -> Option<UninhabitedStruct> {\n+    None\n+}\n+\n+fn uninhabited_tuple_struct() -> Option<UninhabitedTupleStruct> {\n+    None\n+}\n+\n+// This test checks that non-exhaustive types that would normally be considered uninhabited within\n+// the defining crate are not considered uninhabited from extern crates.\n+\n+fn main() {\n+    match uninhabited_enum() {\n+        Some(_x) => (), // This line would normally error.\n+        None => (),\n+    }\n+\n+    match uninhabited_variant() {\n+        Some(_x) => (), // This line would normally error.\n+        None => (),\n+    }\n+\n+    // This line would normally error.\n+    while let PartiallyInhabitedVariants::Struct { x, .. } = partially_inhabited_variant() {\n+    }\n+\n+    while let Some(_x) = uninhabited_struct() { // This line would normally error.\n+    }\n+\n+    while let Some(_x) = uninhabited_tuple_struct() { // This line would normally error.\n+    }\n+}"}, {"sha": "302a35cab5f904b959dc1f19c407b97054d9cf74", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/patterns_same_crate.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns_same_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns_same_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns_same_crate.rs?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,71 @@\n+#![deny(unreachable_patterns)]\n+#![feature(exhaustive_patterns)]\n+#![feature(never_type)]\n+#![feature(non_exhaustive)]\n+\n+#[non_exhaustive]\n+pub enum UninhabitedEnum {\n+}\n+\n+#[non_exhaustive]\n+pub struct UninhabitedTupleStruct(!);\n+\n+#[non_exhaustive]\n+pub struct UninhabitedStruct {\n+    _priv: !,\n+}\n+\n+pub enum UninhabitedVariants {\n+    #[non_exhaustive] Tuple(!),\n+    #[non_exhaustive] Struct { x: ! }\n+}\n+\n+pub enum PartiallyInhabitedVariants {\n+    Tuple(u8),\n+    #[non_exhaustive] Struct { x: ! }\n+}\n+\n+fn uninhabited_enum() -> Option<UninhabitedEnum> {\n+    None\n+}\n+\n+fn uninhabited_variant() -> Option<UninhabitedVariants> {\n+    None\n+}\n+\n+fn partially_inhabited_variant() -> PartiallyInhabitedVariants {\n+    PartiallyInhabitedVariants::Tuple(3)\n+}\n+\n+fn uninhabited_struct() -> Option<UninhabitedStruct> {\n+    None\n+}\n+\n+fn uninhabited_tuple_struct() -> Option<UninhabitedTupleStruct> {\n+    None\n+}\n+\n+// This test checks that non-exhaustive types that would normally be considered uninhabited within\n+// the defining crate are still considered uninhabited.\n+\n+fn main() {\n+    match uninhabited_enum() {\n+        Some(_x) => (), //~ ERROR unreachable pattern\n+        None => (),\n+    }\n+\n+    match uninhabited_variant() {\n+        Some(_x) => (), //~ ERROR unreachable pattern\n+        None => (),\n+    }\n+\n+    while let PartiallyInhabitedVariants::Struct { x } = partially_inhabited_variant() {\n+        //~^ ERROR unreachable pattern\n+    }\n+\n+    while let Some(_x) = uninhabited_struct() { //~ ERROR unreachable pattern\n+    }\n+\n+    while let Some(_x) = uninhabited_tuple_struct() { //~ ERROR unreachable pattern\n+    }\n+}"}, {"sha": "72f37d9a60ba8623f233ba737799abfd41bdd5b8", "filename": "src/test/ui/rfc-2008-non-exhaustive/uninhabited/patterns_same_crate.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns_same_crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d595b113584f8f446957469951fd5d31adc2a44e/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns_same_crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Funinhabited%2Fpatterns_same_crate.stderr?ref=d595b113584f8f446957469951fd5d31adc2a44e", "patch": "@@ -0,0 +1,38 @@\n+error: unreachable pattern\n+  --> $DIR/patterns_same_crate.rs:53:9\n+   |\n+LL |         Some(_x) => (),\n+   |         ^^^^^^^^\n+   |\n+note: lint level defined here\n+  --> $DIR/patterns_same_crate.rs:1:9\n+   |\n+LL | #![deny(unreachable_patterns)]\n+   |         ^^^^^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/patterns_same_crate.rs:58:9\n+   |\n+LL |         Some(_x) => (),\n+   |         ^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/patterns_same_crate.rs:62:15\n+   |\n+LL |     while let PartiallyInhabitedVariants::Struct { x } = partially_inhabited_variant() {\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/patterns_same_crate.rs:66:15\n+   |\n+LL |     while let Some(_x) = uninhabited_struct() {\n+   |               ^^^^^^^^\n+\n+error: unreachable pattern\n+  --> $DIR/patterns_same_crate.rs:69:15\n+   |\n+LL |     while let Some(_x) = uninhabited_tuple_struct() {\n+   |               ^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}]}