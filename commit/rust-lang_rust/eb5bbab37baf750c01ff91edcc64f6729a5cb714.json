{"sha": "eb5bbab37baf750c01ff91edcc64f6729a5cb714", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNWJiYWIzN2JhZjc1MGMwMWZmOTFlZGNjNjRmNjcyOWE1Y2I3MTQ=", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-08-17T08:23:51Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2021-08-26T09:14:31Z"}, "message": "optimize `HasTypeFlagsVisitor`", "tree": {"sha": "b7071fce05f74724246c751c174d927c1e61698e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7071fce05f74724246c751c174d927c1e61698e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb5bbab37baf750c01ff91edcc64f6729a5cb714", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb5bbab37baf750c01ff91edcc64f6729a5cb714", "html_url": "https://github.com/rust-lang/rust/commit/eb5bbab37baf750c01ff91edcc64f6729a5cb714", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb5bbab37baf750c01ff91edcc64f6729a5cb714/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "977124590eb6a2230e168eed6391d6f70bfedaaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/977124590eb6a2230e168eed6391d6f70bfedaaf", "html_url": "https://github.com/rust-lang/rust/commit/977124590eb6a2230e168eed6391d6f70bfedaaf"}], "stats": {"total": 114, "additions": 81, "deletions": 33}, "files": [{"sha": "a04b0a7ef61363b39226653c0a3a8df3981d36f6", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 81, "deletions": 33, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/eb5bbab37baf750c01ff91edcc64f6729a5cb714/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb5bbab37baf750c01ff91edcc64f6729a5cb714/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=eb5bbab37baf750c01ff91edcc64f6729a5cb714", "patch": "@@ -1128,26 +1128,20 @@ struct HasTypeFlagsVisitor<'tcx> {\n impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor<'tcx> {\n     type BreakTy = FoundFlags;\n     fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n-        self.tcx\n+        bug!(\"we shouldn't call this method as we manually look at ct substs\");\n     }\n \n     #[inline]\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        debug!(\n-            \"HasTypeFlagsVisitor: t={:?} t.flags={:?} self.flags={:?}\",\n-            t,\n-            t.flags(),\n-            self.flags\n-        );\n-        if t.flags().intersects(self.flags) {\n+        let flags = t.flags();\n+        debug!(\"HasTypeFlagsVisitor: t={:?} flags={:?} self.flags={:?}\", t, flags, self.flags);\n+        if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n-        } else if t.flags().intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS)\n-            && self.flags.intersects(TypeFlags::MAY_NEED_DEFAULT_CONST_SUBSTS)\n-            && self.tcx.is_some()\n-        {\n-            t.super_visit_with(self)\n         } else {\n-            ControlFlow::CONTINUE\n+            match flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n+                true if self.tcx.is_some() => UnknownConstSubstsVisitor::search(&self, t),\n+                _ => ControlFlow::CONTINUE,\n+            }\n         }\n     }\n \n@@ -1168,13 +1162,11 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor<'tcx> {\n         debug!(\"HasTypeFlagsVisitor: c={:?} c.flags={:?} self.flags={:?}\", c, flags, self.flags);\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n-        } else if flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS)\n-            && self.flags.intersects(TypeFlags::MAY_NEED_DEFAULT_CONST_SUBSTS)\n-            && self.tcx.is_some()\n-        {\n-            c.super_visit_with(self)\n         } else {\n-            ControlFlow::CONTINUE\n+            match flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n+                true if self.tcx.is_some() => UnknownConstSubstsVisitor::search(&self, c),\n+                _ => ControlFlow::CONTINUE,\n+            }\n         }\n     }\n \n@@ -1184,28 +1176,84 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor<'tcx> {\n         debug!(\"HasTypeFlagsVisitor: uv={:?} uv.flags={:?} self.flags={:?}\", uv, flags, self.flags);\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n-        } else if flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS)\n-            && self.flags.intersects(TypeFlags::MAY_NEED_DEFAULT_CONST_SUBSTS)\n-            && self.tcx.is_some()\n-        {\n-            uv.super_visit_with(self)\n         } else {\n-            ControlFlow::CONTINUE\n+            match flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n+                true if self.tcx.is_some() => UnknownConstSubstsVisitor::search(&self, uv),\n+                _ => ControlFlow::CONTINUE,\n+            }\n         }\n     }\n \n     #[inline]\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let flags = predicate.inner.flags;\n         debug!(\n-            \"HasTypeFlagsVisitor: predicate={:?} predicate.flags={:?} self.flags={:?}\",\n-            predicate, predicate.inner.flags, self.flags\n+            \"HasTypeFlagsVisitor: predicate={:?} flags={:?} self.flags={:?}\",\n+            predicate, flags, self.flags\n         );\n-        if predicate.inner.flags.intersects(self.flags) {\n+        if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n-        } else if predicate.inner.flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS)\n-            && self.flags.intersects(TypeFlags::MAY_NEED_DEFAULT_CONST_SUBSTS)\n-            && self.tcx.is_some()\n-        {\n+        } else {\n+            match flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n+                true if self.tcx.is_some() => UnknownConstSubstsVisitor::search(&self, predicate),\n+                _ => ControlFlow::CONTINUE,\n+            }\n+        }\n+    }\n+}\n+\n+struct UnknownConstSubstsVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    flags: ty::TypeFlags,\n+}\n+\n+impl<'tcx> UnknownConstSubstsVisitor<'tcx> {\n+    /// This is fairly cold and we don't want to\n+    /// bloat the size of the `HasTypeFlagsVisitor`.\n+    #[inline(never)]\n+    pub fn search<T: TypeFoldable<'tcx>>(\n+        visitor: &HasTypeFlagsVisitor<'tcx>,\n+        v: T,\n+    ) -> ControlFlow<FoundFlags> {\n+        if visitor.flags.intersects(TypeFlags::MAY_NEED_DEFAULT_CONST_SUBSTS) {\n+            v.super_visit_with(&mut UnknownConstSubstsVisitor {\n+                tcx: visitor.tcx.unwrap(),\n+                flags: visitor.flags,\n+            })\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for UnknownConstSubstsVisitor<'tcx> {\n+    type BreakTy = FoundFlags;\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        bug!(\"we shouldn't call this method as we manually look at ct substs\");\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if t.flags().intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n+            t.super_visit_with(self)\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+\n+    #[inline]\n+    fn visit_unevaluated_const(&mut self, uv: ty::Unevaluated<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if uv.substs_.is_none() {\n+            self.tcx\n+                .default_anon_const_substs(uv.def.did)\n+                .visit_with(&mut HasTypeFlagsVisitor { tcx: Some(self.tcx), flags: self.flags })\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+\n+    #[inline]\n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if predicate.inner.flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n             predicate.super_visit_with(self)\n         } else {\n             ControlFlow::CONTINUE"}]}