{"sha": "13efaf0481275dba18f1d18f4b59b664b2d2031a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzZWZhZjA0ODEyNzVkYmExOGYxZDE4ZjRiNTliNjY0YjJkMjAzMWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-07-17T20:16:14Z"}, "committer": {"name": "Sean Griffin", "email": "sean@seantheprogrammer.com", "date": "2018-03-01T15:04:26Z"}, "message": "add universes to type inference variables", "tree": {"sha": "82951154d7dd0e27e1a2422706a47b947e3ced23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82951154d7dd0e27e1a2422706a47b947e3ced23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13efaf0481275dba18f1d18f4b59b664b2d2031a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13efaf0481275dba18f1d18f4b59b664b2d2031a", "html_url": "https://github.com/rust-lang/rust/commit/13efaf0481275dba18f1d18f4b59b664b2d2031a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13efaf0481275dba18f1d18f4b59b664b2d2031a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sgrif", "id": 1529387, "node_id": "MDQ6VXNlcjE1MjkzODc=", "avatar_url": "https://avatars.githubusercontent.com/u/1529387?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sgrif", "html_url": "https://github.com/sgrif", "followers_url": "https://api.github.com/users/sgrif/followers", "following_url": "https://api.github.com/users/sgrif/following{/other_user}", "gists_url": "https://api.github.com/users/sgrif/gists{/gist_id}", "starred_url": "https://api.github.com/users/sgrif/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sgrif/subscriptions", "organizations_url": "https://api.github.com/users/sgrif/orgs", "repos_url": "https://api.github.com/users/sgrif/repos", "events_url": "https://api.github.com/users/sgrif/events{/privacy}", "received_events_url": "https://api.github.com/users/sgrif/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "44d992984acd4f736743b103467e19e907d8d4c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/44d992984acd4f736743b103467e19e907d8d4c5", "html_url": "https://github.com/rust-lang/rust/commit/44d992984acd4f736743b103467e19e907d8d4c5"}], "stats": {"total": 187, "additions": 132, "deletions": 55}, "files": [{"sha": "eb26f0c1188bf639bf8c0b31aa40a8c85e7cdf40", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -600,7 +600,8 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n             return anon_defn.concrete_ty;\n         }\n         let span = tcx.def_span(def_id);\n-        let ty_var = infcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n+        let ty_var = infcx.next_ty_var(ty::UniverseIndex::ROOT,\n+                                       TypeVariableOrigin::TypeInference(span));\n \n         let predicates_of = tcx.predicates_of(def_id);\n         let bounds = predicates_of.instantiate(tcx, substs);"}, {"sha": "469cb4591124e1b68c994fd483f62c19758f1c58", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -407,7 +407,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                             drop(variables);\n                             self.relate(&u, &u)\n                         }\n-                        TypeVariableValue::Unknown { .. } => {\n+                        TypeVariableValue::Unknown { universe } => {\n                             match self.ambient_variance {\n                                 // Invariant: no need to make a fresh type variable.\n                                 ty::Invariant => return Ok(t),\n@@ -424,7 +424,7 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n                             }\n \n                             let origin = *variables.var_origin(vid);\n-                            let new_var_id = variables.new_var(false, origin);\n+                            let new_var_id = variables.new_var(universe, false, origin);\n                             let u = self.tcx().mk_var(new_var_id);\n                             debug!(\"generalize: replacing original vid={:?} with new={:?}\",\n                                    vid, u);"}, {"sha": "48eb253415cdf07172abb3e66a6575fdac7f9eb9", "filename": "src/librustc/infer/fudge.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffudge.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -141,7 +141,11 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFudger<'a, 'gcx, 'tcx> {\n                         // This variable was created during the\n                         // fudging. Recreate it with a fresh variable\n                         // here.\n-                        self.infcx.next_ty_var(origin)\n+                        //\n+                        // The ROOT universe is fine because we only\n+                        // ever invoke this routine at the\n+                        // \"item-level\" of inference.\n+                        self.infcx.next_ty_var(ty::UniverseIndex::ROOT, origin)\n                     }\n                 }\n             }"}, {"sha": "c4722f9a7f96cb39d86cdbbad25092baceeb2133", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -88,13 +88,17 @@ pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n         // is (e.g.) `Box<i32>`. A more obvious solution might be to\n         // iterate on the subtype obligations that are returned, but I\n         // think this suffices. -nmatsakis\n-        (&ty::TyInfer(TyVar(..)), _) => {\n-            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n+        (&ty::TyInfer(TyVar(a_vid)), _) => {\n+            let universe = infcx.type_variables.borrow_mut().probe(a_vid).universe().unwrap();\n+            let v = infcx.next_ty_var(universe,\n+                                      TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, b, a)?;\n             Ok(v)\n         }\n-        (_, &ty::TyInfer(TyVar(..))) => {\n-            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n+        (_, &ty::TyInfer(TyVar(b_vid))) => {\n+            let universe = infcx.type_variables.borrow_mut().probe(b_vid).universe().unwrap();\n+            let v = infcx.next_ty_var(universe,\n+                                      TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;\n             Ok(v)\n         }"}, {"sha": "58026007320d027e4c473f30f180a02d2ec09e65", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -1015,18 +1015,22 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n+    pub fn next_ty_var_id(&self,\n+                          universe: ty::UniverseIndex,\n+                          diverging: bool,\n+                          origin: TypeVariableOrigin)\n+                          -> TyVid {\n         self.type_variables\n             .borrow_mut()\n-            .new_var(diverging, origin)\n+            .new_var(universe, diverging, origin)\n     }\n \n-    pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(false, origin))\n+    pub fn next_ty_var(&self, universe: ty::UniverseIndex, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(universe, false, origin))\n     }\n \n-    pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(true, origin))\n+    pub fn next_diverging_ty_var(&self, universe: ty::UniverseIndex, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(universe, true, origin))\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n@@ -1081,12 +1085,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// use an inference variable for `C` with `[T, U]`\n     /// as the substitutions for the default, `(T, U)`.\n     pub fn type_var_for_def(&self,\n+                            universe: ty::UniverseIndex,\n                             span: Span,\n                             def: &ty::TypeParameterDef)\n                             -> Ty<'tcx> {\n         let ty_var_id = self.type_variables\n                             .borrow_mut()\n-                            .new_var(false,\n+                            .new_var(universe,\n+                                     false,\n                                      TypeVariableOrigin::TypeParameterDefinition(span, def.name));\n \n         self.tcx.mk_var(ty_var_id)\n@@ -1095,13 +1101,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// Given a set of generics defined on a type or impl, returns a substitution mapping each\n     /// type/region parameter to a fresh inference variable.\n     pub fn fresh_substs_for_item(&self,\n+                                 universe: ty::UniverseIndex,\n                                  span: Span,\n                                  def_id: DefId)\n                                  -> &'tcx Substs<'tcx> {\n         Substs::for_item(self.tcx, def_id, |def, _| {\n             self.region_var_for_def(span, def)\n         }, |def, _| {\n-            self.type_var_for_def(span, def)\n+            self.type_var_for_def(universe, span, def)\n         })\n     }\n "}, {"sha": "5daac988f80b76e49143bd7815f7081c1813fbda", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -12,6 +12,7 @@ use syntax::ast;\n use syntax_pos::Span;\n use ty::{self, Ty};\n \n+use std::cmp;\n use std::marker::PhantomData;\n use std::u32;\n use rustc_data_structures::fx::FxHashMap;\n@@ -81,17 +82,33 @@ struct TypeVariableData {\n #[derive(Copy, Clone, Debug)]\n pub enum TypeVariableValue<'tcx> {\n     Known { value: Ty<'tcx> },\n-    Unknown,\n+    Unknown { universe: ty::UniverseIndex },\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum ProbeTyValue<'tcx> {\n+    Ty(Ty<'tcx>),\n+    Vid(ty::TyVid),\n }\n \n impl<'tcx> TypeVariableValue<'tcx> {\n+    /// If this value is known, returns the type it is known to be.\n+    /// Otherwise, `None`.\n     pub fn known(&self) -> Option<Ty<'tcx>> {\n         match *self {\n             TypeVariableValue::Unknown { .. } => None,\n             TypeVariableValue::Known { value } => Some(value),\n         }\n     }\n \n+    /// If this value is unknown, returns the universe, otherwise `None`.\n+    pub fn universe(&self) -> Option<ty::UniverseIndex> {\n+        match *self {\n+            TypeVariableValue::Unknown { universe } => Some(universe),\n+            TypeVariableValue::Known { .. } => None,\n+        }\n+    }\n+\n     pub fn is_unknown(&self) -> bool {\n         match *self {\n             TypeVariableValue::Unknown { .. } => true,\n@@ -178,10 +195,11 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     ///   The code in this module doesn't care, but it can be useful\n     ///   for improving error messages.\n     pub fn new_var(&mut self,\n+                   universe: ty::UniverseIndex,\n                    diverging: bool,\n                    origin: TypeVariableOrigin)\n                    -> ty::TyVid {\n-        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown);\n+        let eq_key = self.eq_relations.new_key(TypeVariableValue::Unknown { universe });\n \n         let sub_key = self.sub_relations.new_key(());\n         assert_eq!(eq_key.vid, sub_key);\n@@ -388,8 +406,12 @@ impl<'tcx> ut::UnifyValue for TypeVariableValue<'tcx> {\n             (&TypeVariableValue::Known { .. }, &TypeVariableValue::Unknown { .. }) => Ok(*value1),\n             (&TypeVariableValue::Unknown { .. }, &TypeVariableValue::Known { .. }) => Ok(*value2),\n \n-            // If both sides are *unknown*, it hardly matters, does it?\n-            (&TypeVariableValue::Unknown, &TypeVariableValue::Unknown) => Ok(*value1),\n+            // If both sides are unknown, we need to pick the most restrictive universe.\n+            (&TypeVariableValue::Unknown { universe: universe1 },\n+             &TypeVariableValue::Unknown { universe: universe2 }) => {\n+                let universe = cmp::min(universe1, universe2);\n+                Ok(TypeVariableValue::Unknown { universe })\n+            }\n         }\n     }\n }"}, {"sha": "183b1a5470e5ac0a7aa5cdb65f27f99f3aa778cc", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -92,7 +92,9 @@ fn with_fresh_ty_vars<'cx, 'gcx, 'tcx>(selcx: &mut SelectionContext<'cx, 'gcx, '\n                                        -> ty::ImplHeader<'tcx>\n {\n     let tcx = selcx.tcx();\n-    let impl_substs = selcx.infcx().fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+    let impl_substs = selcx.infcx().fresh_substs_for_item(param_env.universe,\n+                                                          DUMMY_SP,\n+                                                          impl_def_id);\n \n     let header = ty::ImplHeader {\n         impl_def_id,"}, {"sha": "dba23c22647f8048b2590dcc6091b6cbf6d45f19", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -292,7 +292,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         self.tcx.for_each_relevant_impl(\n             trait_ref.def_id, trait_self_ty, |def_id| {\n-                let impl_substs = self.fresh_substs_for_item(obligation.cause.span, def_id);\n+                let impl_substs = self.fresh_substs_for_item(param_env.universe,\n+                                                             obligation.cause.span,\n+                                                             def_id);\n                 let impl_trait_ref = tcx\n                     .impl_trait_ref(def_id)\n                     .unwrap()\n@@ -1194,6 +1196,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                            -> bool {\n         struct ParamToVarFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n             infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n+            param_env: ty::ParamEnv<'tcx>,\n             var_map: FxHashMap<Ty<'tcx>, Ty<'tcx>>\n         }\n \n@@ -1203,9 +1206,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::TyParam(ty::ParamTy {name, ..}) = ty.sty {\n                     let infcx = self.infcx;\n-                    self.var_map.entry(ty).or_insert_with(||\n-                        infcx.next_ty_var(\n-                            TypeVariableOrigin::TypeParameterDefinition(DUMMY_SP, name)))\n+                    let param_env = self.param_env;\n+                    self.var_map\n+                        .entry(ty)\n+                        .or_insert_with(|| {\n+                            let origin = TypeVariableOrigin::TypeParameterDefinition(DUMMY_SP,\n+                                                                                     name);\n+                            infcx.next_ty_var(param_env.universe, origin)\n+                        })\n                 } else {\n                     ty.super_fold_with(self)\n                 }\n@@ -1217,6 +1225,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n             let cleaned_pred = pred.fold_with(&mut ParamToVarFolder {\n                 infcx: self,\n+                param_env,\n                 var_map: FxHashMap()\n             });\n "}, {"sha": "3fe72344e8feac6727952529cb4c24a3e4aafcb0", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -469,6 +469,7 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             let tcx = selcx.infcx().tcx;\n             let def_id = projection_ty.item_def_id;\n             let ty_var = selcx.infcx().next_ty_var(\n+                param_env.universe,\n                 TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n             let projection = ty::Binder(ty::ProjectionPredicate {\n                 projection_ty,\n@@ -789,6 +790,7 @@ fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tc\n     let tcx = selcx.infcx().tcx;\n     let def_id = projection_ty.item_def_id;\n     let new_value = selcx.infcx().next_ty_var(\n+        param_env.universe,\n         TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n     Normalized {\n         value: new_value,"}, {"sha": "9e24a4e6afacf5dcf91299035127957e63556db1", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -3111,7 +3111,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             snapshot);\n         let skol_obligation_trait_ref = skol_obligation.trait_ref;\n \n-        let impl_substs = self.infcx.fresh_substs_for_item(obligation.cause.span,\n+        let impl_substs = self.infcx.fresh_substs_for_item(obligation.param_env.universe,\n+                                                           obligation.cause.span,\n                                                            impl_def_id);\n \n         let impl_trait_ref = impl_trait_ref.subst(self.tcx(),"}, {"sha": "5dfeb1bb4292842aeeac36f187fbefa62d69a5af", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -221,7 +221,7 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        target_impl: DefId)\n                                        -> Result<&'tcx Substs<'tcx>, ()> {\n     let selcx = &mut SelectionContext::new(&infcx);\n-    let target_substs = infcx.fresh_substs_for_item(DUMMY_SP, target_impl);\n+    let target_substs = infcx.fresh_substs_for_item(param_env.universe, DUMMY_SP, target_impl);\n     let (target_trait_ref, mut obligations) = impl_trait_ref_and_oblig(selcx,\n                                                                        param_env,\n                                                                        target_impl,"}, {"sha": "da66a2e52e81f78eab943e69936e635f74953753", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -329,6 +329,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let element_tys_iter = (0..max_len).map(|_| self.next_ty_var(\n                     // FIXME: MiscVariable for now, obtaining the span and name information\n                     //       from all tuple elements isn't trivial.\n+                    ty::UniverseIndex::ROOT,\n                     TypeVariableOrigin::TypeInference(pat.span)));\n                 let element_tys = tcx.mk_type_list(element_tys_iter);\n                 let pat_ty = tcx.mk_ty(ty::TyTuple(element_tys, false));\n@@ -339,7 +340,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 pat_ty\n             }\n             PatKind::Box(ref inner) => {\n-                let inner_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(inner.span));\n+                let inner_ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                                TypeVariableOrigin::TypeInference(inner.span));\n                 let uniq_ty = tcx.mk_box(inner_ty);\n \n                 if self.check_dereferencable(pat.span, expected, &inner) {\n@@ -372,6 +374,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         }\n                         _ => {\n                             let inner_ty = self.next_ty_var(\n+                                ty::UniverseIndex::ROOT,\n                                 TypeVariableOrigin::TypeInference(inner.span));\n                             let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n                             let region = self.next_region_var(infer::PatternRegion(pat.span));\n@@ -630,7 +633,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n             // ...but otherwise we want to use any supertype of the\n             // discriminant. This is sort of a workaround, see note (*) in\n             // `check_pat` for some details.\n-            discrim_ty = self.next_ty_var(TypeVariableOrigin::TypeInference(discrim.span));\n+            discrim_ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                          TypeVariableOrigin::TypeInference(discrim.span));\n             self.check_expr_has_type_or_error(discrim, discrim_ty);\n         };\n \n@@ -691,7 +695,8 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 // arm for inconsistent arms or to the whole match when a `()` type\n                 // is required).\n                 Expectation::ExpectHasType(ety) if ety != self.tcx.mk_nil() => ety,\n-                _ => self.next_ty_var(TypeVariableOrigin::MiscVariable(expr.span)),\n+                _ => self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                      TypeVariableOrigin::MiscVariable(expr.span)),\n             };\n             CoerceMany::with_coercion_sites(coerce_first, arms)\n         };"}, {"sha": "5e0c47f18bf5ac5c862de440daebdfae09e55a4b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -110,7 +110,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             |_, _| span_bug!(expr.span, \"closure has region param\"),\n             |_, _| {\n                 self.infcx\n-                    .next_ty_var(TypeVariableOrigin::ClosureSynthetic(expr.span))\n+                    .next_ty_var(ty::UniverseIndex::ROOT,\n+                                 TypeVariableOrigin::ClosureSynthetic(expr.span))\n             },\n         );\n         let substs = ty::ClosureSubsts { substs };"}, {"sha": "e2d6817697e8fd87de5180e03b262d5d6648e87c", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -177,6 +177,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 // micro-optimization: no need for this if `b` is\n                 // already resolved in some way.\n                 let diverging_ty = self.next_diverging_ty_var(\n+                    ty::UniverseIndex::ROOT,\n                     TypeVariableOrigin::AdjustmentType(self.cause.span));\n                 self.unify_and(&b, &diverging_ty, simple(Adjust::NeverToAny))\n             } else {\n@@ -510,7 +511,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n         // We only have the latter, so we use an inference variable\n         // for the former and let type inference do the rest.\n         let origin = TypeVariableOrigin::MiscVariable(self.cause.span);\n-        let coerce_target = self.next_ty_var(origin);\n+        let coerce_target = self.next_ty_var(ty::UniverseIndex::ROOT, origin);\n         let mut coercion = self.unify_and(coerce_target, target, |target| {\n             let unsize = Adjustment {\n                 kind: Adjust::Unsize,"}, {"sha": "165cfe6604e8b0ec1905fa60ace5500718a8f509", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -90,7 +90,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n \n         let drop_impl_span = tcx.def_span(drop_impl_did);\n         let fresh_impl_substs =\n-            infcx.fresh_substs_for_item(drop_impl_span, drop_impl_did);\n+            infcx.fresh_substs_for_item(ty::UniverseIndex::ROOT, drop_impl_span, drop_impl_did);\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         let cause = &ObligationCause::misc(drop_impl_span, drop_impl_node_id);"}, {"sha": "b777ac30920cdab16abe9270f40ae89f1231cbd6", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -259,7 +259,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 // the process we will unify the transformed-self-type\n                 // of the method with the actual type in order to\n                 // unify some of these variables.\n-                self.fresh_substs_for_item(self.span, trait_def_id)\n+                self.fresh_substs_for_item(ty::UniverseIndex::ROOT, self.span, trait_def_id)\n             }\n \n             probe::WhereClausePick(ref poly_trait_ref) => {\n@@ -336,7 +336,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             {\n                 self.to_ty(ast_ty)\n             } else {\n-                self.type_var_for_def(self.span, def)\n+                self.type_var_for_def(ty::UniverseIndex::ROOT, self.span, def)\n             }\n         })\n     }"}, {"sha": "af86570309dfd9a0df5cec5a6f3d508158c288e6", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -255,7 +255,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             } else if let Some(ref input_types) = opt_input_types {\n                 input_types[def.index as usize - 1]\n             } else {\n-                self.type_var_for_def(span, def)\n+                self.type_var_for_def(ty::UniverseIndex::ROOT, span, def)\n             }\n         });\n "}, {"sha": "c95ead285594b8bf3d5eeee0e5e27f4bc7414d88", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -730,7 +730,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             Def::Method(def_id) => {\n                 let fty = self.tcx.fn_sig(def_id);\n                 self.probe(|_| {\n-                    let substs = self.fresh_substs_for_item(self.span, method.def_id);\n+                    let substs = self.fresh_substs_for_item(ty::UniverseIndex::ROOT,\n+                                                            self.span,\n+                                                            method.def_id);\n                     let fty = fty.subst(self.tcx, substs);\n                     let (fty, _) = self.replace_late_bound_regions_with_fresh_var(\n                         self.span, infer::FnCall, &fty);\n@@ -1309,7 +1311,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 if i < substs.len() {\n                     substs.type_at(i)\n                 } else {\n-                    self.type_var_for_def(self.span, def)\n+                    self.type_var_for_def(ty::UniverseIndex::ROOT, self.span, def)\n                 }\n             });\n             xform_fn_sig.subst(self.tcx, substs)\n@@ -1326,6 +1328,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                          def_id,\n                          |_, _| self.tcx.types.re_erased,\n                          |_, _| self.next_ty_var(\n+                             ty::UniverseIndex::ROOT,\n                              TypeVariableOrigin::SubstitutionPlaceholder(\n                                  self.tcx.def_span(def_id))))\n     }"}, {"sha": "5c20490f8230316b392c527d50de33a9f69c5c20", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -54,7 +54,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.autoderef(span, ty).any(|(ty, _)| {\n                     self.probe(|_| {\n                         let fn_once_substs = tcx.mk_substs_trait(ty,\n-                            &[self.next_ty_var(TypeVariableOrigin::MiscVariable(span))]);\n+                            &[self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                               TypeVariableOrigin::MiscVariable(span))]);\n                         let trait_ref = ty::TraitRef::new(fn_once, fn_once_substs);\n                         let poly_trait_ref = trait_ref.to_poly_trait_ref();\n                         let obligation ="}, {"sha": "a7001acc495a3d2aee22d3d6df15b035ec529ac4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -362,7 +362,8 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     /// hard constraint exists, creates a fresh type variable.\n     fn coercion_target_type(self, fcx: &FnCtxt<'a, 'gcx, 'tcx>, span: Span) -> Ty<'tcx> {\n         self.only_has_type(fcx)\n-            .unwrap_or_else(|| fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span)))\n+            .unwrap_or_else(|| fcx.next_ty_var(ty::UniverseIndex::ROOT,\n+                                               TypeVariableOrigin::MiscVariable(span)))\n     }\n }\n \n@@ -921,7 +922,8 @@ impl<'a, 'gcx, 'tcx> GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n         match ty_opt {\n             None => {\n                 // infer the variable's type\n-                let var_ty = self.fcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n+                let var_ty = self.fcx.next_ty_var(ty::UniverseIndex::ROOT,\n+                                                  TypeVariableOrigin::TypeInference(span));\n                 self.fcx.locals.borrow_mut().insert(nid, var_ty);\n                 var_ty\n             }\n@@ -1025,7 +1027,8 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     let span = body.value.span;\n \n     if body.is_generator && can_be_generator.is_some() {\n-        let yield_ty = fcx.next_ty_var(TypeVariableOrigin::TypeInference(span));\n+        let yield_ty = fcx.next_ty_var(fcx.next_ty_var(ty::UniverseIndex::ROOT,\n+                                                       TypeVariableOrigin::TypeInference(span)));\n         fcx.require_type_is_sized(yield_ty, span, traits::SizedYieldType);\n         fcx.yield_ty = Some(yield_ty);\n     }\n@@ -1058,7 +1061,8 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     // This ensures that all nested generators appear before the entry of this generator.\n     // resolve_generator_interiors relies on this property.\n     let gen_ty = if can_be_generator.is_some() && body.is_generator {\n-        let witness = fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span));\n+        let witness = fcx.next_ty_var(ty::UniverseIndex::ROOT,\n+                                      TypeVariableOrigin::MiscVariable(span));\n         let interior = ty::GeneratorInterior {\n             witness,\n             movable: can_be_generator.unwrap() == hir::GeneratorMovability::Movable,\n@@ -1096,6 +1100,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     let mut actual_return_ty = coercion.complete(&fcx);\n     if actual_return_ty.is_never() {\n         actual_return_ty = fcx.next_diverging_ty_var(\n+            ty::UniverseIndex::ROOT,\n             TypeVariableOrigin::DivergingFn(span));\n     }\n     fcx.demand_suptype(span, ret_ty, actual_return_ty);\n@@ -1687,13 +1692,14 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n-        self.next_ty_var(TypeVariableOrigin::TypeInference(span))\n+        self.next_ty_var(ty::UniverseIndex::ROOT,\n+                         TypeVariableOrigin::TypeInference(span))\n     }\n \n     fn ty_infer_for_def(&self,\n                         ty_param_def: &ty::TypeParameterDef,\n                         span: Span) -> Ty<'tcx> {\n-        self.type_var_for_def(span, ty_param_def)\n+        self.type_var_for_def(ty::UniverseIndex::ROOT, span, ty_param_def)\n     }\n \n     fn projected_ty_from_poly_trait_ref(&self,\n@@ -2315,7 +2321,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // If some lookup succeeds, write callee into table and extract index/element\n             // type from the method signature.\n             // If some lookup succeeded, install method in table\n-            let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_expr.span));\n+            let input_ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                            TypeVariableOrigin::AutoDeref(base_expr.span));\n             let method = self.try_overloaded_place_op(\n                 expr.span, self_ty, &[input_ty], needs, PlaceOp::Index);\n \n@@ -2754,6 +2761,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             assert!(!self.tables.borrow().adjustments().contains_key(expr.hir_id),\n                     \"expression with never type wound up being adjusted\");\n             let adj_ty = self.next_diverging_ty_var(\n+                ty::UniverseIndex::ROOT,\n                 TypeVariableOrigin::AdjustmentType(expr.span));\n             self.apply_adjustments(expr, vec![Adjustment {\n                 kind: Adjust::NeverToAny,\n@@ -2831,7 +2839,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let ity = self.tcx.type_of(did);\n         debug!(\"impl_self_ty: ity={:?}\", ity);\n \n-        let substs = self.fresh_substs_for_item(span, did);\n+        let substs = self.fresh_substs_for_item(ty::UniverseIndex::ROOT, span, did);\n         let substd_ty = self.instantiate_type_scheme(span, &substs, &ity);\n \n         TypeAndSubsts { substs: substs, ty: substd_ty }\n@@ -3971,7 +3979,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n               let element_ty = if !args.is_empty() {\n                   let coerce_to = uty.unwrap_or_else(\n-                      || self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span)));\n+                      || self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                          TypeVariableOrigin::TypeInference(expr.span)));\n                   let mut coerce = CoerceMany::with_coercion_sites(coerce_to, args);\n                   assert_eq!(self.diverges.get(), Diverges::Maybe);\n                   for e in args {\n@@ -3981,7 +3990,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   }\n                   coerce.complete(self)\n               } else {\n-                  self.next_ty_var(TypeVariableOrigin::TypeInference(expr.span))\n+                  self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                   TypeVariableOrigin::TypeInference(expr.span))\n               };\n               tcx.mk_array(element_ty, args.len() as u64)\n           }\n@@ -4011,7 +4021,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     (uty, uty)\n                 }\n                 None => {\n-                    let t: Ty = self.next_ty_var(TypeVariableOrigin::MiscVariable(element.span));\n+                    let t: Ty = self.next_ty_var(ty::UniverseIndex::ROOT,\n+                                                 TypeVariableOrigin::MiscVariable(element.span));\n                     let element_ty = self.check_expr_has_type_or_error(&element, t);\n                     (element_ty, t)\n                 }\n@@ -4792,7 +4803,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // Handle Self first, so we can adjust the index to match the AST.\n                 if has_self && i == 0 {\n                     return opt_self_ty.unwrap_or_else(|| {\n-                        self.type_var_for_def(span, def)\n+                        self.type_var_for_def(ty::UniverseIndex::ROOT, span, def)\n                     });\n                 }\n                 i -= has_self as usize;\n@@ -4825,7 +4836,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // This can also be reached in some error cases:\n                 // We prefer to use inference variables instead of\n                 // TyError to let type inference recover somewhat.\n-                self.type_var_for_def(span, def)\n+                self.type_var_for_def(ty::UniverseIndex::ROOT, span, def)\n             }\n         });\n "}, {"sha": "12791107ebb412234f4232964daba0664e2ce153", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13efaf0481275dba18f1d18f4b59b664b2d2031a/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=13efaf0481275dba18f1d18f4b59b664b2d2031a", "patch": "@@ -174,8 +174,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // trait matching creating lifetime constraints that are too strict.\n         // E.g. adding `&'a T` and `&'b T`, given `&'x T: Add<&'x T>`, will result\n         // in `&'a T <: &'x T` and `&'b T <: &'x T`, instead of `'a = 'b = 'x`.\n-        let lhs_ty = self.check_expr_coercable_to_type_with_needs(lhs_expr,\n-            self.next_ty_var(TypeVariableOrigin::MiscVariable(lhs_expr.span)),\n+        let lhs_ty = self.check_expr_coercable_to_type_with_needs(\n+            lhs_expr,\n+            self.next_ty_var(ty::UniverseIndex::ROOT,\n+                             TypeVariableOrigin::MiscVariable(lhs_expr.span)),\n             lhs_needs);\n         let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n \n@@ -185,7 +187,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // using this variable as the expected type, which sometimes lets\n         // us do better coercions than we would be able to do otherwise,\n         // particularly for things like `String + &String`.\n-        let rhs_ty_var = self.next_ty_var(TypeVariableOrigin::MiscVariable(rhs_expr.span));\n+        let rhs_ty_var = self.next_ty_var(ty::UniverseIndex::ROOT,\n+                         TypeVariableOrigin::MiscVariable(rhs_expr.span));\n \n         let result = self.lookup_op_method(lhs_ty, &[rhs_ty_var], Op::Binary(op, is_assign));\n "}]}