{"sha": "a82755e24102bea85be450e0b210d45b05b9f246", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4Mjc1NWUyNDEwMmJlYTg1YmU0NTBlMGIyMTBkNDViMDViOWYyNDY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-26T16:16:54Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-03-26T16:16:54Z"}, "message": "Merge #1059\n\n1059: Typed ids r=matklad a=matklad\n\njust some type-safety and refactorings. \r\n\r\ncloses https://github.com/rust-analyzer/rust-analyzer/issues/1054\r\n\r\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "52f347ddfc4586e3dfa4467827b211d1684aaa74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52f347ddfc4586e3dfa4467827b211d1684aaa74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a82755e24102bea85be450e0b210d45b05b9f246", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a82755e24102bea85be450e0b210d45b05b9f246", "html_url": "https://github.com/rust-lang/rust/commit/a82755e24102bea85be450e0b210d45b05b9f246", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a82755e24102bea85be450e0b210d45b05b9f246/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "96acf4f7ec4257af0d5fd0415b31ab6757b475ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/96acf4f7ec4257af0d5fd0415b31ab6757b475ad", "html_url": "https://github.com/rust-lang/rust/commit/96acf4f7ec4257af0d5fd0415b31ab6757b475ad"}, {"sha": "1325a31e34a3b4bf5104a743bcb8217ef5c4f3cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/1325a31e34a3b4bf5104a743bcb8217ef5c4f3cd", "html_url": "https://github.com/rust-lang/rust/commit/1325a31e34a3b4bf5104a743bcb8217ef5c4f3cd"}], "stats": {"total": 442, "additions": 233, "deletions": 209}, "files": [{"sha": "624c25c4d6f3cbafbff772e49c0a8d49438abcfa", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=a82755e24102bea85be450e0b210d45b05b9f246", "patch": "@@ -13,7 +13,7 @@ use crate::{\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n     generics::GenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n-    ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeId},\n+    ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeAliasId},\n     impl_block::ImplBlock,\n     resolve::Resolver,\n     diagnostics::DiagnosticSink,\n@@ -672,7 +672,7 @@ impl Docs for Trait {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TypeAlias {\n-    pub(crate) id: TypeId,\n+    pub(crate) id: TypeAliasId,\n }\n \n impl TypeAlias {"}, {"sha": "0edb8ade5b39a1209c35c02ed7f4b32da78f4902", "filename": "crates/ra_hir/src/code_model_impl/module.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_impl%2Fmodule.rs?ref=a82755e24102bea85be450e0b210d45b05b9f246", "patch": "@@ -1,27 +1,26 @@\n use ra_db::FileId;\n-use ra_syntax::{ast, TreeArc, AstNode};\n+use ra_syntax::{ast, TreeArc};\n \n use crate::{\n-    Module, ModuleSource, Name,\n+    Module, ModuleSource, Name, AstId,\n     nameres::{CrateModuleId, ImportId},\n     HirDatabase, DefDatabase,\n-    HirFileId, SourceItemId,\n+    HirFileId,\n };\n \n impl ModuleSource {\n     pub(crate) fn new(\n         db: &impl DefDatabase,\n         file_id: Option<FileId>,\n-        decl_id: Option<SourceItemId>,\n+        decl_id: Option<AstId<ast::Module>>,\n     ) -> ModuleSource {\n         match (file_id, decl_id) {\n             (Some(file_id), _) => {\n                 let source_file = db.parse(file_id);\n                 ModuleSource::SourceFile(source_file)\n             }\n             (None, Some(item_id)) => {\n-                let module = db.file_item(item_id);\n-                let module = ast::Module::cast(&*module).unwrap();\n+                let module = item_id.to_node(db);\n                 assert!(module.item_list().is_some(), \"expected inline module\");\n                 ModuleSource::Module(module.to_owned())\n             }\n@@ -55,7 +54,7 @@ impl Module {\n         let decl_id = def_map[self.module_id].declaration;\n         let file_id = def_map[self.module_id].definition;\n         let module_source = ModuleSource::new(db, file_id, decl_id);\n-        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id);\n+        let file_id = file_id.map(HirFileId::from).unwrap_or_else(|| decl_id.unwrap().file_id());\n         (file_id, module_source)\n     }\n \n@@ -65,9 +64,8 @@ impl Module {\n     ) -> Option<(HirFileId, TreeArc<ast::Module>)> {\n         let def_map = db.crate_def_map(self.krate);\n         let decl = def_map[self.module_id].declaration?;\n-        let syntax_node = db.file_item(decl);\n-        let ast = ast::Module::cast(&syntax_node).unwrap().to_owned();\n-        Some((decl.file_id, ast))\n+        let ast = decl.to_node(db);\n+        Some((decl.file_id(), ast))\n     }\n \n     pub(crate) fn import_source_impl("}, {"sha": "1470058480af8d950d6e139003fa93fb4ace5bd6", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=a82755e24102bea85be450e0b210d45b05b9f246", "patch": "@@ -4,7 +4,7 @@ use ra_syntax::{SyntaxNode, TreeArc, SourceFile};\n use ra_db::{SourceDatabase, salsa};\n \n use crate::{\n-    HirFileId, MacroDefId, SourceFileItems, SourceItemId, Crate, Module, HirInterner,\n+    HirFileId, MacroDefId, AstIdMap, ErasedFileAstId, Crate, Module, HirInterner,\n     Function, FnSignature, ExprScopes, TypeAlias,\n     Struct, Enum, StructField,\n     Const, ConstSignature, Static,\n@@ -22,7 +22,7 @@ pub trait DefDatabase: SourceDatabase + AsRef<HirInterner> {\n     #[salsa::invoke(crate::ids::macro_def_query)]\n     fn macro_def(&self, macro_id: MacroDefId) -> Option<Arc<mbe::MacroRules>>;\n \n-    #[salsa::invoke(HirFileId::hir_parse)]\n+    #[salsa::invoke(HirFileId::hir_parse_query)]\n     fn hir_parse(&self, file_id: HirFileId) -> TreeArc<SourceFile>;\n \n     #[salsa::invoke(crate::adt::StructData::struct_data_query)]\n@@ -34,11 +34,11 @@ pub trait DefDatabase: SourceDatabase + AsRef<HirInterner> {\n     #[salsa::invoke(crate::traits::TraitData::trait_data_query)]\n     fn trait_data(&self, t: Trait) -> Arc<TraitData>;\n \n-    #[salsa::invoke(crate::source_id::SourceFileItems::file_items_query)]\n-    fn file_items(&self, file_id: HirFileId) -> Arc<SourceFileItems>;\n+    #[salsa::invoke(crate::source_id::AstIdMap::ast_id_map_query)]\n+    fn ast_id_map(&self, file_id: HirFileId) -> Arc<AstIdMap>;\n \n-    #[salsa::invoke(crate::source_id::SourceFileItems::file_item_query)]\n-    fn file_item(&self, source_item_id: SourceItemId) -> TreeArc<SyntaxNode>;\n+    #[salsa::invoke(crate::source_id::AstIdMap::file_item_query)]\n+    fn ast_id_to_node(&self, file_id: HirFileId, ast_id: ErasedFileAstId) -> TreeArc<SyntaxNode>;\n \n     #[salsa::invoke(RawItems::raw_items_query)]\n     fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;"}, {"sha": "eb9939df790f57b05fda1413fbe52bb453c611c8", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 31, "deletions": 44, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=a82755e24102bea85be450e0b210d45b05b9f246", "patch": "@@ -1,5 +1,4 @@\n use std::{\n-    marker::PhantomData,\n     hash::{Hash, Hasher},\n     sync::Arc,\n };\n@@ -10,7 +9,7 @@ use ra_arena::{RawId, ArenaId, impl_arena_id};\n use mbe::MacroRules;\n \n use crate::{\n-    Module, DefDatabase, SourceItemId, SourceFileItemId,\n+    Module, DefDatabase, AstId, FileAstId,\n };\n \n #[derive(Debug, Default)]\n@@ -22,7 +21,7 @@ pub struct HirInterner {\n     consts: LocationInterner<ItemLoc<ast::ConstDef>, ConstId>,\n     statics: LocationInterner<ItemLoc<ast::StaticDef>, StaticId>,\n     traits: LocationInterner<ItemLoc<ast::TraitDef>, TraitId>,\n-    types: LocationInterner<ItemLoc<ast::TypeAliasDef>, TypeId>,\n+    types: LocationInterner<ItemLoc<ast::TypeAliasDef>, TypeAliasId>,\n }\n \n impl HirInterner {\n@@ -68,7 +67,7 @@ impl HirFileId {\n             HirFileIdRepr::File(file_id) => file_id,\n             HirFileIdRepr::Macro(macro_call_id) => {\n                 let loc = macro_call_id.loc(db);\n-                loc.source_item_id.file_id.original_file(db)\n+                loc.ast_id.file_id().original_file(db)\n             }\n         }\n     }\n@@ -83,7 +82,10 @@ impl HirFileId {\n         }\n     }\n \n-    pub(crate) fn hir_parse(db: &impl DefDatabase, file_id: HirFileId) -> TreeArc<SourceFile> {\n+    pub(crate) fn hir_parse_query(\n+        db: &impl DefDatabase,\n+        file_id: HirFileId,\n+    ) -> TreeArc<SourceFile> {\n         match file_id.0 {\n             HirFileIdRepr::File(file_id) => db.parse(file_id),\n             HirFileIdRepr::Macro(macro_call_id) => {\n@@ -96,8 +98,7 @@ impl HirFileId {\n \n fn parse_macro(db: &impl DefDatabase, macro_call_id: MacroCallId) -> Option<TreeArc<SourceFile>> {\n     let loc = macro_call_id.loc(db);\n-    let syntax = db.file_item(loc.source_item_id);\n-    let macro_call = ast::MacroCall::cast(&syntax).unwrap();\n+    let macro_call = loc.ast_id.to_node(db);\n     let (macro_arg, _) = macro_call.token_tree().and_then(mbe::ast_to_token_tree)?;\n \n     let macro_rules = db.macro_def(loc.def)?;\n@@ -124,15 +125,10 @@ impl From<MacroCallId> for HirFileId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum MacroDefId {\n-    MacroByExample { source_item_id: SourceItemId },\n-}\n+pub struct MacroDefId(pub(crate) AstId<ast::MacroCall>);\n \n pub(crate) fn macro_def_query(db: &impl DefDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n-    let syntax_node = match id {\n-        MacroDefId::MacroByExample { source_item_id } => db.file_item(source_item_id),\n-    };\n-    let macro_call = ast::MacroCall::cast(&syntax_node).unwrap();\n+    let macro_call = id.0.to_node(db);\n     let arg = macro_call.token_tree()?;\n     let (tt, _) = mbe::ast_to_token_tree(arg)?;\n     let rules = MacroRules::parse(&tt).ok()?;\n@@ -148,7 +144,7 @@ impl_arena_id!(MacroCallId);\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct MacroCallLoc {\n     pub(crate) def: MacroDefId,\n-    pub(crate) source_item_id: SourceItemId,\n+    pub(crate) ast_id: AstId<ast::MacroCall>,\n }\n \n impl MacroCallId {\n@@ -158,7 +154,6 @@ impl MacroCallId {\n }\n \n impl MacroCallLoc {\n-    #[allow(unused)]\n     pub(crate) fn id(&self, db: &impl AsRef<HirInterner>) -> MacroCallId {\n         db.as_ref().macros.loc2id(&self)\n     }\n@@ -167,26 +162,25 @@ impl MacroCallLoc {\n #[derive(Debug)]\n pub struct ItemLoc<N: AstNode> {\n     pub(crate) module: Module,\n-    raw: SourceItemId,\n-    _ty: PhantomData<N>,\n+    ast_id: AstId<N>,\n }\n \n impl<N: AstNode> PartialEq for ItemLoc<N> {\n     fn eq(&self, other: &Self) -> bool {\n-        self.module == other.module && self.raw == other.raw\n+        self.module == other.module && self.ast_id == other.ast_id\n     }\n }\n impl<N: AstNode> Eq for ItemLoc<N> {}\n impl<N: AstNode> Hash for ItemLoc<N> {\n     fn hash<H: Hasher>(&self, hasher: &mut H) {\n         self.module.hash(hasher);\n-        self.raw.hash(hasher);\n+        self.ast_id.hash(hasher);\n     }\n }\n \n impl<N: AstNode> Clone for ItemLoc<N> {\n     fn clone(&self) -> ItemLoc<N> {\n-        ItemLoc { module: self.module, raw: self.raw, _ty: PhantomData }\n+        ItemLoc { module: self.module, ast_id: self.ast_id }\n     }\n }\n \n@@ -213,26 +207,19 @@ impl<'a, DB: DefDatabase> LocationCtx<&'a DB> {\n pub(crate) trait AstItemDef<N: AstNode>: ArenaId + Clone {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<N>, Self>;\n     fn from_ast(ctx: LocationCtx<&impl DefDatabase>, ast: &N) -> Self {\n-        let items = ctx.db.file_items(ctx.file_id);\n-        let item_id = items.id_of(ctx.file_id, ast.syntax());\n-        Self::from_source_item_id_unchecked(ctx, item_id)\n+        let items = ctx.db.ast_id_map(ctx.file_id);\n+        let item_id = items.ast_id(ast);\n+        Self::from_ast_id(ctx, item_id)\n     }\n-    fn from_source_item_id_unchecked(\n-        ctx: LocationCtx<&impl DefDatabase>,\n-        item_id: SourceFileItemId,\n-    ) -> Self {\n-        let raw = SourceItemId { file_id: ctx.file_id, item_id };\n-        let loc = ItemLoc { module: ctx.module, raw, _ty: PhantomData };\n-\n+    fn from_ast_id(ctx: LocationCtx<&impl DefDatabase>, ast_id: FileAstId<N>) -> Self {\n+        let loc = ItemLoc { module: ctx.module, ast_id: ast_id.with_file_id(ctx.file_id) };\n         Self::interner(ctx.db.as_ref()).loc2id(&loc)\n     }\n     fn source(self, db: &impl DefDatabase) -> (HirFileId, TreeArc<N>) {\n         let int = Self::interner(db.as_ref());\n         let loc = int.id2loc(self);\n-        let syntax = db.file_item(loc.raw);\n-        let ast =\n-            N::cast(&syntax).unwrap_or_else(|| panic!(\"invalid ItemLoc: {:?}\", loc.raw)).to_owned();\n-        (loc.raw.file_id, ast)\n+        let ast = loc.ast_id.to_node(db);\n+        (loc.ast_id.file_id(), ast)\n     }\n     fn module(self, db: &impl DefDatabase) -> Module {\n         let int = Self::interner(db.as_ref());\n@@ -242,7 +229,7 @@ pub(crate) trait AstItemDef<N: AstNode>: ArenaId + Clone {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct FunctionId(RawId);\n+pub(crate) struct FunctionId(RawId);\n impl_arena_id!(FunctionId);\n impl AstItemDef<ast::FnDef> for FunctionId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::FnDef>, Self> {\n@@ -251,7 +238,7 @@ impl AstItemDef<ast::FnDef> for FunctionId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct StructId(RawId);\n+pub(crate) struct StructId(RawId);\n impl_arena_id!(StructId);\n impl AstItemDef<ast::StructDef> for StructId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::StructDef>, Self> {\n@@ -260,7 +247,7 @@ impl AstItemDef<ast::StructDef> for StructId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct EnumId(RawId);\n+pub(crate) struct EnumId(RawId);\n impl_arena_id!(EnumId);\n impl AstItemDef<ast::EnumDef> for EnumId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::EnumDef>, Self> {\n@@ -269,7 +256,7 @@ impl AstItemDef<ast::EnumDef> for EnumId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct ConstId(RawId);\n+pub(crate) struct ConstId(RawId);\n impl_arena_id!(ConstId);\n impl AstItemDef<ast::ConstDef> for ConstId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::ConstDef>, Self> {\n@@ -278,7 +265,7 @@ impl AstItemDef<ast::ConstDef> for ConstId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct StaticId(RawId);\n+pub(crate) struct StaticId(RawId);\n impl_arena_id!(StaticId);\n impl AstItemDef<ast::StaticDef> for StaticId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::StaticDef>, Self> {\n@@ -287,7 +274,7 @@ impl AstItemDef<ast::StaticDef> for StaticId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TraitId(RawId);\n+pub(crate) struct TraitId(RawId);\n impl_arena_id!(TraitId);\n impl AstItemDef<ast::TraitDef> for TraitId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::TraitDef>, Self> {\n@@ -296,9 +283,9 @@ impl AstItemDef<ast::TraitDef> for TraitId {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct TypeId(RawId);\n-impl_arena_id!(TypeId);\n-impl AstItemDef<ast::TypeAliasDef> for TypeId {\n+pub(crate) struct TypeAliasId(RawId);\n+impl_arena_id!(TypeAliasId);\n+impl AstItemDef<ast::TypeAliasDef> for TypeAliasId {\n     fn interner(interner: &HirInterner) -> &LocationInterner<ItemLoc<ast::TypeAliasDef>, Self> {\n         &interner.types\n     }"}, {"sha": "7c603bbd3e77a1ad70e14701ce7719fe8547c49e", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=a82755e24102bea85be450e0b210d45b05b9f246", "patch": "@@ -48,13 +48,13 @@ mod marks;\n use crate::{\n     db::{HirDatabase, DefDatabase},\n     name::{AsName, KnownName},\n-    source_id::SourceFileItemId,\n+    source_id::{FileAstId, AstId},\n };\n \n pub use self::{\n     path::{Path, PathKind},\n     name::Name,\n-    source_id::{SourceFileItems, SourceItemId},\n+    source_id::{AstIdMap, ErasedFileAstId},\n     ids::{HirFileId, MacroDefId, MacroCallId, MacroCallLoc, HirInterner},\n     nameres::{PerNs, Namespace},\n     ty::{Ty, ApplicationTy, TypeCtor, Substs, display::HirDisplay},"}, {"sha": "67b9d698605e581a54b3f8465f06f5d793b417d3", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=a82755e24102bea85be450e0b210d45b05b9f246", "patch": "@@ -59,13 +59,15 @@ use rustc_hash::FxHashMap;\n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_db::{FileId, Edition};\n use test_utils::tested_by;\n+use ra_syntax::ast;\n \n use crate::{\n-    ModuleDef, Name, Crate, Module, SourceItemId,\n+    ModuleDef, Name, Crate, Module,\n     DefDatabase, Path, PathKind, HirFileId, Trait,\n     ids::MacroDefId,\n     diagnostics::DiagnosticSink,\n     nameres::diagnostics::DefDiagnostic,\n+    AstId,\n };\n \n pub(crate) use self::raw::{RawItems, ImportId, ImportSourceMap};\n@@ -106,7 +108,7 @@ pub(crate) struct ModuleData {\n     pub(crate) children: FxHashMap<Name, CrateModuleId>,\n     pub(crate) scope: ModuleScope,\n     /// None for root\n-    pub(crate) declaration: Option<SourceItemId>,\n+    pub(crate) declaration: Option<AstId<ast::Module>>,\n     /// None for inline modules.\n     ///\n     /// Note that non-inline modules, by definition, live inside non-macro file.\n@@ -225,7 +227,7 @@ impl CrateDefMap {\n     pub(crate) fn find_module_by_source(\n         &self,\n         file_id: HirFileId,\n-        decl_id: Option<SourceItemId>,\n+        decl_id: Option<AstId<ast::Module>>,\n     ) -> Option<CrateModuleId> {\n         let (module_id, _module_data) = self.modules.iter().find(|(_module_id, module_data)| {\n             if decl_id.is_some() {\n@@ -429,10 +431,10 @@ impl CrateDefMap {\n \n mod diagnostics {\n     use relative_path::RelativePathBuf;\n-    use ra_syntax::{AstPtr, AstNode, ast};\n+    use ra_syntax::{AstPtr, ast};\n \n     use crate::{\n-        SourceItemId, DefDatabase,\n+        AstId, DefDatabase,\n         nameres::CrateModuleId,\n         diagnostics::{DiagnosticSink, UnresolvedModule},\n };\n@@ -441,7 +443,7 @@ mod diagnostics {\n     pub(super) enum DefDiagnostic {\n         UnresolvedModule {\n             module: CrateModuleId,\n-            declaration: SourceItemId,\n+            declaration: AstId<ast::Module>,\n             candidate: RelativePathBuf,\n         },\n     }\n@@ -458,16 +460,14 @@ mod diagnostics {\n                     if *module != target_module {\n                         return;\n                     }\n-                    let syntax = db.file_item(*declaration);\n-                    let decl = ast::Module::cast(&syntax).unwrap();\n+                    let decl = declaration.to_node(db);\n                     sink.push(UnresolvedModule {\n-                        file: declaration.file_id,\n+                        file: declaration.file_id(),\n                         decl: AstPtr::new(&decl),\n                         candidate: candidate.clone(),\n                     })\n                 }\n             }\n         }\n     }\n-\n }"}, {"sha": "39cadc94aab3101bcdafaeb9383ff2a5869cbbdb", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 30, "deletions": 39, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=a82755e24102bea85be450e0b210d45b05b9f246", "patch": "@@ -3,10 +3,11 @@ use rustc_hash::FxHashMap;\n use relative_path::RelativePathBuf;\n use test_utils::tested_by;\n use ra_db::FileId;\n+use ra_syntax::ast;\n \n use crate::{\n     Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n-    DefDatabase, HirFileId, Name, Path, SourceItemId,\n+    DefDatabase, HirFileId, Name, Path,\n     KnownName,\n     nameres::{\n         Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode,\n@@ -15,6 +16,7 @@ use crate::{\n         raw,\n     },\n     ids::{AstItemDef, LocationCtx, MacroCallLoc, MacroCallId, MacroDefId},\n+    AstId,\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {\n@@ -51,7 +53,7 @@ struct DefCollector<DB> {\n     def_map: CrateDefMap,\n     glob_imports: FxHashMap<CrateModuleId, Vec<(CrateModuleId, raw::ImportId)>>,\n     unresolved_imports: Vec<(CrateModuleId, raw::ImportId, raw::ImportData)>,\n-    unexpanded_macros: Vec<(CrateModuleId, SourceItemId, Path)>,\n+    unexpanded_macros: Vec<(CrateModuleId, AstId<ast::MacroCall>, Path)>,\n     global_macro_scope: FxHashMap<Name, MacroDefId>,\n }\n \n@@ -293,7 +295,7 @@ where\n         let mut macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n         let mut resolved = Vec::new();\n         let mut res = ReachedFixedPoint::Yes;\n-        macros.retain(|(module_id, source_item_id, path)| {\n+        macros.retain(|(module_id, ast_id, path)| {\n             if path.segments.len() != 2 {\n                 return true;\n             }\n@@ -309,8 +311,7 @@ where\n             res = ReachedFixedPoint::No;\n             let def_map = self.db.crate_def_map(krate);\n             if let Some(macro_id) = def_map.public_macros.get(&path.segments[1].name).cloned() {\n-                let call_id =\n-                    MacroCallLoc { def: macro_id, source_item_id: *source_item_id }.id(self.db);\n+                let call_id = MacroCallLoc { def: macro_id, ast_id: *ast_id }.id(self.db);\n                 resolved.push((*module_id, call_id));\n             }\n             false\n@@ -364,12 +365,9 @@ where\n     fn collect_module(&mut self, module: &raw::ModuleData) {\n         match module {\n             // inline module, just recurse\n-            raw::ModuleData::Definition { name, items, source_item_id } => {\n-                let module_id = self.push_child_module(\n-                    name.clone(),\n-                    source_item_id.with_file_id(self.file_id),\n-                    None,\n-                );\n+            raw::ModuleData::Definition { name, items, ast_id } => {\n+                let module_id =\n+                    self.push_child_module(name.clone(), ast_id.with_file_id(self.file_id), None);\n                 ModCollector {\n                     def_collector: &mut *self.def_collector,\n                     module_id,\n@@ -379,13 +377,12 @@ where\n                 .collect(&*items);\n             }\n             // out of line module, resovle, parse and recurse\n-            raw::ModuleData::Declaration { name, source_item_id } => {\n-                let source_item_id = source_item_id.with_file_id(self.file_id);\n+            raw::ModuleData::Declaration { name, ast_id } => {\n+                let ast_id = ast_id.with_file_id(self.file_id);\n                 let is_root = self.def_collector.def_map.modules[self.module_id].parent.is_none();\n                 match resolve_submodule(self.def_collector.db, self.file_id, name, is_root) {\n                     Ok(file_id) => {\n-                        let module_id =\n-                            self.push_child_module(name.clone(), source_item_id, Some(file_id));\n+                        let module_id = self.push_child_module(name.clone(), ast_id, Some(file_id));\n                         let raw_items = self.def_collector.db.raw_items(file_id.into());\n                         ModCollector {\n                             def_collector: &mut *self.def_collector,\n@@ -398,7 +395,7 @@ where\n                     Err(candidate) => self.def_collector.def_map.diagnostics.push(\n                         DefDiagnostic::UnresolvedModule {\n                             module: self.module_id,\n-                            declaration: source_item_id,\n+                            declaration: ast_id,\n                             candidate,\n                         },\n                     ),\n@@ -410,7 +407,7 @@ where\n     fn push_child_module(\n         &mut self,\n         name: Name,\n-        declaration: SourceItemId,\n+        declaration: AstId<ast::Module>,\n         definition: Option<FileId>,\n     ) -> CrateModuleId {\n         let modules = &mut self.def_collector.def_map.modules;\n@@ -432,23 +429,24 @@ where\n     fn define_def(&mut self, def: &raw::DefData) {\n         let module = Module { krate: self.def_collector.def_map.krate, module_id: self.module_id };\n         let ctx = LocationCtx::new(self.def_collector.db, module, self.file_id.into());\n-        macro_rules! id {\n-            () => {\n-                AstItemDef::from_source_item_id_unchecked(ctx, def.source_item_id)\n+\n+        macro_rules! def {\n+            ($kind:ident, $ast_id:ident) => {\n+                $kind { id: AstItemDef::from_ast_id(ctx, $ast_id) }.into()\n             };\n         }\n         let name = def.name.clone();\n         let def: PerNs<ModuleDef> = match def.kind {\n-            raw::DefKind::Function => PerNs::values(Function { id: id!() }.into()),\n-            raw::DefKind::Struct => {\n-                let s = Struct { id: id!() }.into();\n+            raw::DefKind::Function(ast_id) => PerNs::values(def!(Function, ast_id)),\n+            raw::DefKind::Struct(ast_id) => {\n+                let s = def!(Struct, ast_id);\n                 PerNs::both(s, s)\n             }\n-            raw::DefKind::Enum => PerNs::types(Enum { id: id!() }.into()),\n-            raw::DefKind::Const => PerNs::values(Const { id: id!() }.into()),\n-            raw::DefKind::Static => PerNs::values(Static { id: id!() }.into()),\n-            raw::DefKind::Trait => PerNs::types(Trait { id: id!() }.into()),\n-            raw::DefKind::TypeAlias => PerNs::types(TypeAlias { id: id!() }.into()),\n+            raw::DefKind::Enum(ast_id) => PerNs::types(def!(Enum, ast_id)),\n+            raw::DefKind::Const(ast_id) => PerNs::values(def!(Const, ast_id)),\n+            raw::DefKind::Static(ast_id) => PerNs::values(def!(Static, ast_id)),\n+            raw::DefKind::Trait(ast_id) => PerNs::types(def!(Trait, ast_id)),\n+            raw::DefKind::TypeAlias(ast_id) => PerNs::types(def!(TypeAlias, ast_id)),\n         };\n         let resolution = Resolution { def, import: None };\n         self.def_collector.update(self.module_id, None, &[(name, resolution)])\n@@ -458,34 +456,27 @@ where\n         // Case 1: macro rules, define a macro in crate-global mutable scope\n         if is_macro_rules(&mac.path) {\n             if let Some(name) = &mac.name {\n-                let macro_id = MacroDefId::MacroByExample {\n-                    source_item_id: mac.source_item_id.with_file_id(self.file_id),\n-                };\n+                let macro_id = MacroDefId(mac.ast_id.with_file_id(self.file_id));\n                 self.def_collector.define_macro(name.clone(), macro_id, mac.export)\n             }\n             return;\n         }\n \n-        let source_item_id = SourceItemId { file_id: self.file_id, item_id: mac.source_item_id };\n+        let ast_id = mac.ast_id.with_file_id(self.file_id);\n \n         // Case 2: try to expand macro_rules from this crate, triggering\n         // recursive item collection.\n         if let Some(&macro_id) =\n             mac.path.as_ident().and_then(|name| self.def_collector.global_macro_scope.get(name))\n         {\n-            let macro_call_id =\n-                MacroCallLoc { def: macro_id, source_item_id }.id(self.def_collector.db);\n+            let macro_call_id = MacroCallLoc { def: macro_id, ast_id }.id(self.def_collector.db);\n \n             self.def_collector.collect_macro_expansion(self.module_id, macro_call_id);\n             return;\n         }\n \n         // Case 3: path to a macro from another crate, expand during name resolution\n-        self.def_collector.unexpanded_macros.push((\n-            self.module_id,\n-            source_item_id,\n-            mac.path.clone(),\n-        ))\n+        self.def_collector.unexpanded_macros.push((self.module_id, ast_id, mac.path.clone()))\n     }\n }\n "}, {"sha": "0936229acf4082eb90cffade53fb3612bd800654", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=a82755e24102bea85be450e0b210d45b05b9f246", "patch": "@@ -12,7 +12,7 @@ use ra_syntax::{\n \n use crate::{\n     DefDatabase, Name, AsName, Path, HirFileId, ModuleSource,\n-    SourceFileItemId, SourceFileItems,\n+    AstIdMap, FileAstId,\n };\n \n /// `RawItems` is a set of top-level items in a file (except for impls).\n@@ -60,7 +60,7 @@ impl RawItems {\n     ) -> (Arc<RawItems>, Arc<ImportSourceMap>) {\n         let mut collector = RawItemsCollector {\n             raw_items: RawItems::default(),\n-            source_file_items: db.file_items(file_id.into()),\n+            source_ast_id_map: db.ast_id_map(file_id.into()),\n             source_map: ImportSourceMap::default(),\n         };\n         let source_file = db.hir_parse(file_id);\n@@ -115,8 +115,8 @@ impl_arena_id!(Module);\n \n #[derive(Debug, PartialEq, Eq)]\n pub(super) enum ModuleData {\n-    Declaration { name: Name, source_item_id: SourceFileItemId },\n-    Definition { name: Name, source_item_id: SourceFileItemId, items: Vec<RawItem> },\n+    Declaration { name: Name, ast_id: FileAstId<ast::Module> },\n+    Definition { name: Name, ast_id: FileAstId<ast::Module>, items: Vec<RawItem> },\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -138,20 +138,19 @@ impl_arena_id!(Def);\n \n #[derive(Debug, PartialEq, Eq)]\n pub(super) struct DefData {\n-    pub(super) source_item_id: SourceFileItemId,\n     pub(super) name: Name,\n     pub(super) kind: DefKind,\n }\n \n #[derive(Debug, PartialEq, Eq, Clone, Copy)]\n pub(super) enum DefKind {\n-    Function,\n-    Struct,\n-    Enum,\n-    Const,\n-    Static,\n-    Trait,\n-    TypeAlias,\n+    Function(FileAstId<ast::FnDef>),\n+    Struct(FileAstId<ast::StructDef>),\n+    Enum(FileAstId<ast::EnumDef>),\n+    Const(FileAstId<ast::ConstDef>),\n+    Static(FileAstId<ast::StaticDef>),\n+    Trait(FileAstId<ast::TraitDef>),\n+    TypeAlias(FileAstId<ast::TypeAliasDef>),\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -160,15 +159,15 @@ impl_arena_id!(Macro);\n \n #[derive(Debug, PartialEq, Eq)]\n pub(super) struct MacroData {\n-    pub(super) source_item_id: SourceFileItemId,\n+    pub(super) ast_id: FileAstId<ast::MacroCall>,\n     pub(super) path: Path,\n     pub(super) name: Option<Name>,\n     pub(super) export: bool,\n }\n \n struct RawItemsCollector {\n     raw_items: RawItems,\n-    source_file_items: Arc<SourceFileItems>,\n+    source_ast_id_map: Arc<AstIdMap>,\n     source_map: ImportSourceMap,\n }\n \n@@ -200,18 +199,31 @@ impl RawItemsCollector {\n                 // impls don't participate in name resolution\n                 return;\n             }\n-            ast::ModuleItemKind::StructDef(it) => (DefKind::Struct, it.name()),\n-            ast::ModuleItemKind::EnumDef(it) => (DefKind::Enum, it.name()),\n-            ast::ModuleItemKind::FnDef(it) => (DefKind::Function, it.name()),\n-            ast::ModuleItemKind::TraitDef(it) => (DefKind::Trait, it.name()),\n-            ast::ModuleItemKind::TypeAliasDef(it) => (DefKind::TypeAlias, it.name()),\n-            ast::ModuleItemKind::ConstDef(it) => (DefKind::Const, it.name()),\n-            ast::ModuleItemKind::StaticDef(it) => (DefKind::Static, it.name()),\n+            ast::ModuleItemKind::StructDef(it) => {\n+                (DefKind::Struct(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::EnumDef(it) => {\n+                (DefKind::Enum(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::FnDef(it) => {\n+                (DefKind::Function(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::TraitDef(it) => {\n+                (DefKind::Trait(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::TypeAliasDef(it) => {\n+                (DefKind::TypeAlias(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::ConstDef(it) => {\n+                (DefKind::Const(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n+            ast::ModuleItemKind::StaticDef(it) => {\n+                (DefKind::Static(self.source_ast_id_map.ast_id(it)), it.name())\n+            }\n         };\n         if let Some(name) = name {\n             let name = name.as_name();\n-            let source_item_id = self.source_file_items.id_of_unchecked(item.syntax());\n-            let def = self.raw_items.defs.alloc(DefData { name, kind, source_item_id });\n+            let def = self.raw_items.defs.alloc(DefData { name, kind });\n             self.push_item(current_module, RawItem::Def(def))\n         }\n     }\n@@ -221,18 +233,17 @@ impl RawItemsCollector {\n             Some(it) => it.as_name(),\n             None => return,\n         };\n-        let source_item_id = self.source_file_items.id_of_unchecked(module.syntax());\n+        let ast_id = self.source_ast_id_map.ast_id(module);\n         if module.has_semi() {\n-            let item =\n-                self.raw_items.modules.alloc(ModuleData::Declaration { name, source_item_id });\n+            let item = self.raw_items.modules.alloc(ModuleData::Declaration { name, ast_id });\n             self.push_item(current_module, RawItem::Module(item));\n             return;\n         }\n \n         if let Some(item_list) = module.item_list() {\n             let item = self.raw_items.modules.alloc(ModuleData::Definition {\n                 name,\n-                source_item_id,\n+                ast_id,\n                 items: Vec::new(),\n             });\n             self.process_module(Some(item), item_list);\n@@ -286,9 +297,9 @@ impl RawItemsCollector {\n         };\n \n         let name = m.name().map(|it| it.as_name());\n-        let source_item_id = self.source_file_items.id_of_unchecked(m.syntax());\n+        let ast_id = self.source_ast_id_map.ast_id(m);\n         let export = m.has_atom_attr(\"macro_export\");\n-        let m = self.raw_items.macros.alloc(MacroData { source_item_id, path, name, export });\n+        let m = self.raw_items.macros.alloc(MacroData { ast_id, path, name, export });\n         self.push_item(current_module, RawItem::Macro(m));\n     }\n "}, {"sha": "9dae4c3d1de4d5684a3b6c9ce57581c36a099eec", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=a82755e24102bea85be450e0b210d45b05b9f246", "patch": "@@ -13,10 +13,10 @@ use ra_syntax::{\n };\n \n use crate::{\n-    HirDatabase, Function, Struct, Enum, SourceItemId,\n+    HirDatabase, Function, Struct, Enum,\n     AsName, Module, HirFileId, Crate, Trait, Resolver,\n     ids::LocationCtx,\n-    expr\n+    expr, AstId\n };\n \n /// Locates the module by `FileId`. Picks topmost module in the file.\n@@ -54,8 +54,8 @@ fn module_from_inline(\n ) -> Option<Module> {\n     assert!(!module.has_semi());\n     let file_id = file_id.into();\n-    let file_items = db.file_items(file_id);\n-    let item_id = file_items.id_of(file_id, module.syntax()).with_file_id(file_id);\n+    let ast_id_map = db.ast_id_map(file_id);\n+    let item_id = ast_id_map.ast_id(module).with_file_id(file_id);\n     module_from_source(db, file_id, Some(item_id))\n }\n \n@@ -75,7 +75,7 @@ pub fn module_from_child_node(\n fn module_from_source(\n     db: &impl HirDatabase,\n     file_id: HirFileId,\n-    decl_id: Option<SourceItemId>,\n+    decl_id: Option<AstId<ast::Module>>,\n ) -> Option<Module> {\n     let source_root_id = db.file_source_root(file_id.as_original_file());\n     db.source_root_crates(source_root_id).iter().map(|&crate_id| Crate { crate_id }).find_map("}, {"sha": "0a8fb6d3285ad68d998664812a51f457df0fc9a2", "filename": "crates/ra_hir/src/source_id.rs", "status": "modified", "additions": 97, "deletions": 60, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_id.rs?ref=a82755e24102bea85be450e0b210d45b05b9f246", "patch": "@@ -1,59 +1,122 @@\n-use std::sync::Arc;\n+use std::{marker::PhantomData, sync::Arc, hash::{Hash, Hasher}};\n \n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_syntax::{SyntaxNodePtr, TreeArc, SyntaxNode, SourceFile, AstNode, ast};\n \n use crate::{HirFileId, DefDatabase};\n \n-/// Identifier of item within a specific file. This is stable over reparses, so\n-/// it's OK to use it as a salsa key/value.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub(crate) struct SourceFileItemId(RawId);\n-impl_arena_id!(SourceFileItemId);\n+/// `AstId` points to an AST node in any file.\n+///\n+/// It is stable across reparses, and can be used as salsa key/value.\n+#[derive(Debug)]\n+pub(crate) struct AstId<N: AstNode> {\n+    file_id: HirFileId,\n+    file_ast_id: FileAstId<N>,\n+}\n+\n+impl<N: AstNode> Clone for AstId<N> {\n+    fn clone(&self) -> AstId<N> {\n+        *self\n+    }\n+}\n+impl<N: AstNode> Copy for AstId<N> {}\n+\n+impl<N: AstNode> PartialEq for AstId<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.file_id, self.file_ast_id) == (other.file_id, other.file_ast_id)\n+    }\n+}\n+impl<N: AstNode> Eq for AstId<N> {}\n+impl<N: AstNode> Hash for AstId<N> {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        (self.file_id, self.file_ast_id).hash(hasher);\n+    }\n+}\n+\n+impl<N: AstNode> AstId<N> {\n+    pub(crate) fn file_id(&self) -> HirFileId {\n+        self.file_id\n+    }\n+\n+    pub(crate) fn to_node(&self, db: &impl DefDatabase) -> TreeArc<N> {\n+        let syntax_node = db.ast_id_to_node(self.file_id, self.file_ast_id.raw);\n+        N::cast(&syntax_node).unwrap().to_owned()\n+    }\n+}\n+\n+/// `AstId` points to an AST node in a specific file.\n+#[derive(Debug)]\n+pub(crate) struct FileAstId<N: AstNode> {\n+    raw: ErasedFileAstId,\n+    _ty: PhantomData<N>,\n+}\n+\n+impl<N: AstNode> Clone for FileAstId<N> {\n+    fn clone(&self) -> FileAstId<N> {\n+        *self\n+    }\n+}\n+impl<N: AstNode> Copy for FileAstId<N> {}\n \n-impl SourceFileItemId {\n-    pub(crate) fn with_file_id(self, file_id: HirFileId) -> SourceItemId {\n-        SourceItemId { file_id, item_id: self }\n+impl<N: AstNode> PartialEq for FileAstId<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.raw == other.raw\n+    }\n+}\n+impl<N: AstNode> Eq for FileAstId<N> {}\n+impl<N: AstNode> Hash for FileAstId<N> {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        self.raw.hash(hasher);\n     }\n }\n \n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct SourceItemId {\n-    pub(crate) file_id: HirFileId,\n-    pub(crate) item_id: SourceFileItemId,\n+impl<N: AstNode> FileAstId<N> {\n+    pub(crate) fn with_file_id(self, file_id: HirFileId) -> AstId<N> {\n+        AstId { file_id, file_ast_id: self }\n+    }\n }\n \n-/// Maps items' `SyntaxNode`s to `SourceFileItemId`s and back.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ErasedFileAstId(RawId);\n+impl_arena_id!(ErasedFileAstId);\n+\n+/// Maps items' `SyntaxNode`s to `ErasedFileAstId`s and back.\n #[derive(Debug, PartialEq, Eq)]\n-pub struct SourceFileItems {\n-    file_id: HirFileId,\n-    arena: Arena<SourceFileItemId, SyntaxNodePtr>,\n+pub struct AstIdMap {\n+    arena: Arena<ErasedFileAstId, SyntaxNodePtr>,\n }\n \n-impl SourceFileItems {\n-    pub(crate) fn file_items_query(\n-        db: &impl DefDatabase,\n-        file_id: HirFileId,\n-    ) -> Arc<SourceFileItems> {\n+impl AstIdMap {\n+    pub(crate) fn ast_id_map_query(db: &impl DefDatabase, file_id: HirFileId) -> Arc<AstIdMap> {\n         let source_file = db.hir_parse(file_id);\n-        Arc::new(SourceFileItems::from_source_file(&source_file, file_id))\n+        Arc::new(AstIdMap::from_source_file(&source_file))\n     }\n \n     pub(crate) fn file_item_query(\n         db: &impl DefDatabase,\n-        source_item_id: SourceItemId,\n+        file_id: HirFileId,\n+        ast_id: ErasedFileAstId,\n     ) -> TreeArc<SyntaxNode> {\n-        let source_file = db.hir_parse(source_item_id.file_id);\n-        db.file_items(source_item_id.file_id)[source_item_id.item_id]\n-            .to_node(&source_file)\n-            .to_owned()\n+        let source_file = db.hir_parse(file_id);\n+        db.ast_id_map(file_id).arena[ast_id].to_node(&source_file).to_owned()\n     }\n \n-    pub(crate) fn from_source_file(\n-        source_file: &SourceFile,\n-        file_id: HirFileId,\n-    ) -> SourceFileItems {\n-        let mut res = SourceFileItems { file_id, arena: Arena::default() };\n+    pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> FileAstId<N> {\n+        let ptr = SyntaxNodePtr::new(item.syntax());\n+        let raw = match self.arena.iter().find(|(_id, i)| **i == ptr) {\n+            Some((it, _)) => it,\n+            None => panic!(\n+                \"Can't find {:?} in AstIdMap:\\n{:?}\",\n+                item.syntax(),\n+                self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n+            ),\n+        };\n+\n+        FileAstId { raw, _ty: PhantomData }\n+    }\n+\n+    fn from_source_file(source_file: &SourceFile) -> AstIdMap {\n+        let mut res = AstIdMap { arena: Arena::default() };\n         // By walking the tree in bread-first order we make sure that parents\n         // get lower ids then children. That is, adding a new child does not\n         // change parent's id. This means that, say, adding a new function to a\n@@ -68,35 +131,9 @@ impl SourceFileItems {\n         res\n     }\n \n-    fn alloc(&mut self, item: &SyntaxNode) -> SourceFileItemId {\n+    fn alloc(&mut self, item: &SyntaxNode) -> ErasedFileAstId {\n         self.arena.alloc(SyntaxNodePtr::new(item))\n     }\n-    pub(crate) fn id_of(&self, file_id: HirFileId, item: &SyntaxNode) -> SourceFileItemId {\n-        assert_eq!(\n-            self.file_id, file_id,\n-            \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n-            self.file_id, file_id\n-        );\n-        self.id_of_unchecked(item)\n-    }\n-    pub(crate) fn id_of_unchecked(&self, item: &SyntaxNode) -> SourceFileItemId {\n-        let ptr = SyntaxNodePtr::new(item);\n-        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| **i == ptr) {\n-            return id;\n-        }\n-        panic!(\n-            \"Can't find {:?} in SourceFileItems:\\n{:?}\",\n-            item,\n-            self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n-        );\n-    }\n-}\n-\n-impl std::ops::Index<SourceFileItemId> for SourceFileItems {\n-    type Output = SyntaxNodePtr;\n-    fn index(&self, idx: SourceFileItemId) -> &SyntaxNodePtr {\n-        &self.arena[idx]\n-    }\n }\n \n /// Walks the subtree in bfs order, calling `f` for each node."}, {"sha": "a4a086931bc0c4ff6897f0320cd8cf54fdb3a7b3", "filename": "crates/ra_ide_api/src/change.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a82755e24102bea85be450e0b210d45b05b9f246/crates%2Fra_ide_api%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fchange.rs?ref=a82755e24102bea85be450e0b210d45b05b9f246", "patch": "@@ -220,8 +220,8 @@ impl RootDatabase {\n         self.query(ra_db::ParseQuery).sweep(sweep);\n \n         self.query(hir::db::HirParseQuery).sweep(sweep);\n-        self.query(hir::db::FileItemsQuery).sweep(sweep);\n-        self.query(hir::db::FileItemQuery).sweep(sweep);\n+        self.query(hir::db::AstIdMapQuery).sweep(sweep);\n+        self.query(hir::db::AstIdToNodeQuery).sweep(sweep);\n \n         self.query(hir::db::RawItemsWithSourceMapQuery).sweep(sweep);\n         self.query(hir::db::BodyWithSourceMapQuery).sweep(sweep);"}]}