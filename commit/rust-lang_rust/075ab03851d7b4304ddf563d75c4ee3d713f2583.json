{"sha": "075ab03851d7b4304ddf563d75c4ee3d713f2583", "node_id": "C_kwDOAAsO6NoAKDA3NWFiMDM4NTFkN2I0MzA0ZGRmNTYzZDc1YzRlZTNkNzEzZjI1ODM", "commit": {"author": {"name": "Dorian Scheidt", "email": "dorian.scheidt@gmail.com", "date": "2022-04-30T17:29:55Z"}, "committer": {"name": "Dorian Scheidt", "email": "dorian.scheidt@gmail.com", "date": "2022-07-13T19:54:10Z"}, "message": "fix: Support generics in extract_function assist\n\nThis change attempts to resolve issue #7636: Extract into Function does not\ncreate a generic function with constraints when extracting generic code.\n\nIn `FunctionBody::analyze_container`, we now traverse the `ancestors` in search\nof `AnyHasGenericParams`, and attach any `GenericParamList`s and `WhereClause`s\nwe find to the `ContainerInfo`.\n\nLater, in `format_function`, we collect all the `GenericParam`s and\n`WherePred`s from the container, and filter them to keep only types matching\n`TypeParam`s used within the newly extracted function body or param list. We\ncan then include the new `GenericParamList` and `WhereClause` in the new\nfunction definition.\n\nThis change only impacts `TypeParam`s. `LifetimeParam`s and `ConstParam`s are\nout of scope for this change.", "tree": {"sha": "184f52f93df83f9ad7bebc121bb69b0f3b9efc13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/184f52f93df83f9ad7bebc121bb69b0f3b9efc13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/075ab03851d7b4304ddf563d75c4ee3d713f2583", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/075ab03851d7b4304ddf563d75c4ee3d713f2583", "html_url": "https://github.com/rust-lang/rust/commit/075ab03851d7b4304ddf563d75c4ee3d713f2583", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/075ab03851d7b4304ddf563d75c4ee3d713f2583/comments", "author": {"login": "DorianListens", "id": 5692947, "node_id": "MDQ6VXNlcjU2OTI5NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5692947?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DorianListens", "html_url": "https://github.com/DorianListens", "followers_url": "https://api.github.com/users/DorianListens/followers", "following_url": "https://api.github.com/users/DorianListens/following{/other_user}", "gists_url": "https://api.github.com/users/DorianListens/gists{/gist_id}", "starred_url": "https://api.github.com/users/DorianListens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DorianListens/subscriptions", "organizations_url": "https://api.github.com/users/DorianListens/orgs", "repos_url": "https://api.github.com/users/DorianListens/repos", "events_url": "https://api.github.com/users/DorianListens/events{/privacy}", "received_events_url": "https://api.github.com/users/DorianListens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DorianListens", "id": 5692947, "node_id": "MDQ6VXNlcjU2OTI5NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/5692947?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DorianListens", "html_url": "https://github.com/DorianListens", "followers_url": "https://api.github.com/users/DorianListens/followers", "following_url": "https://api.github.com/users/DorianListens/following{/other_user}", "gists_url": "https://api.github.com/users/DorianListens/gists{/gist_id}", "starred_url": "https://api.github.com/users/DorianListens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DorianListens/subscriptions", "organizations_url": "https://api.github.com/users/DorianListens/orgs", "repos_url": "https://api.github.com/users/DorianListens/repos", "events_url": "https://api.github.com/users/DorianListens/events{/privacy}", "received_events_url": "https://api.github.com/users/DorianListens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "794ecd58a32dfd9fdab0596b181133d4d2ae4b6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/794ecd58a32dfd9fdab0596b181133d4d2ae4b6f", "html_url": "https://github.com/rust-lang/rust/commit/794ecd58a32dfd9fdab0596b181133d4d2ae4b6f"}], "stats": {"total": 443, "additions": 436, "deletions": 7}, "files": [{"sha": "86124b68b51bf53c6ec84479bc84fb20aa033692", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/075ab03851d7b4304ddf563d75c4ee3d713f2583/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075ab03851d7b4304ddf563d75c4ee3d713f2583/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=075ab03851d7b4304ddf563d75c4ee3d713f2583", "patch": "@@ -3307,6 +3307,15 @@ impl Type {\n         let tys = hir_ty::replace_errors_with_variables(&(self.ty.clone(), to.ty.clone()));\n         hir_ty::could_coerce(db, self.env.clone(), &tys)\n     }\n+\n+    pub fn as_type_param(&self, db: &dyn HirDatabase) -> Option<TypeParam> {\n+        match self.ty.kind(Interner) {\n+            TyKind::Placeholder(p) => Some(TypeParam {\n+                id: TypeParamId::from_unchecked(hir_ty::from_placeholder_idx(db, *p)),\n+            }),\n+            _ => None,\n+        }\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "aa1c3a548c97040dbbf12181ec7f82a56bf73eda", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 427, "deletions": 7, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/075ab03851d7b4304ddf563d75c4ee3d713f2583/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/075ab03851d7b4304ddf563d75c4ee3d713f2583/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=075ab03851d7b4304ddf563d75c4ee3d713f2583", "patch": "@@ -2,7 +2,9 @@ use std::iter;\n \n use ast::make;\n use either::Either;\n-use hir::{HasSource, HirDisplay, InFile, Local, ModuleDef, Semantics, TypeInfo};\n+use hir::{\n+    HasSource, HirDisplay, InFile, Local, ModuleDef, PathResolution, Semantics, TypeInfo, TypeParam,\n+};\n use ide_db::{\n     defs::{Definition, NameRefClass},\n     famous_defs::FamousDefs,\n@@ -18,7 +20,7 @@ use syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n-        AstNode,\n+        AstNode, HasGenericParams,\n     },\n     match_ast, ted, SyntaxElement,\n     SyntaxKind::{self, COMMENT},\n@@ -294,6 +296,8 @@ struct ContainerInfo {\n     parent_loop: Option<SyntaxNode>,\n     /// The function's return type, const's type etc.\n     ret_type: Option<hir::Type>,\n+    generic_param_lists: Vec<ast::GenericParamList>,\n+    where_clauses: Vec<ast::WhereClause>,\n }\n \n /// Control flow that is exported from extracted function\n@@ -517,6 +521,24 @@ impl FunctionBody {\n         }\n     }\n \n+    fn descendants(&self) -> impl Iterator<Item = SyntaxNode> {\n+        match self {\n+            FunctionBody::Expr(expr) => expr.syntax().descendants(),\n+            FunctionBody::Span { parent, .. } => parent.syntax().descendants(),\n+        }\n+    }\n+\n+    fn descendant_paths(&self) -> impl Iterator<Item = ast::Path> {\n+        self.descendants().filter_map(|node| {\n+            match_ast! {\n+                match node {\n+                    ast::Path(it) => Some(it),\n+                    _ => None\n+                }\n+            }\n+        })\n+    }\n+\n     fn from_expr(expr: ast::Expr) -> Option<Self> {\n         match expr {\n             ast::Expr::BreakExpr(it) => it.expr().map(Self::Expr),\n@@ -731,6 +753,7 @@ impl FunctionBody {\n                 parent_loop.get_or_insert(loop_.syntax().clone());\n             }\n         };\n+\n         let (is_const, expr, ty) = loop {\n             let anc = ancestors.next()?;\n             break match_ast! {\n@@ -798,7 +821,19 @@ impl FunctionBody {\n             container_tail.zip(self.tail_expr()).map_or(false, |(container_tail, body_tail)| {\n                 container_tail.syntax().text_range().contains_range(body_tail.syntax().text_range())\n             });\n-        Some(ContainerInfo { is_in_tail, is_const, parent_loop, ret_type: ty })\n+\n+        let parent = self.parent()?;\n+        let generic_param_lists = parent_generic_param_lists(&parent);\n+        let where_clauses = parent_where_clauses(&parent);\n+\n+        Some(ContainerInfo {\n+            is_in_tail,\n+            is_const,\n+            parent_loop,\n+            ret_type: ty,\n+            generic_param_lists,\n+            where_clauses,\n+        })\n     }\n \n     fn return_ty(&self, ctx: &AssistContext) -> Option<RetType> {\n@@ -955,6 +990,26 @@ impl FunctionBody {\n     }\n }\n \n+fn parent_where_clauses(parent: &SyntaxNode) -> Vec<ast::WhereClause> {\n+    let mut where_clause: Vec<ast::WhereClause> = parent\n+        .ancestors()\n+        .filter_map(ast::AnyHasGenericParams::cast)\n+        .filter_map(|it| it.where_clause())\n+        .collect();\n+    where_clause.reverse();\n+    where_clause\n+}\n+\n+fn parent_generic_param_lists(parent: &SyntaxNode) -> Vec<ast::GenericParamList> {\n+    let mut generic_param_list: Vec<ast::GenericParamList> = parent\n+        .ancestors()\n+        .filter_map(ast::AnyHasGenericParams::cast)\n+        .filter_map(|it| it.generic_param_list())\n+        .collect();\n+    generic_param_list.reverse();\n+    generic_param_list\n+}\n+\n /// checks if relevant var is used with `&mut` access inside body\n fn has_exclusive_usages(ctx: &AssistContext, usages: &LocalUsages, body: &FunctionBody) -> bool {\n     usages\n@@ -1362,37 +1417,154 @@ fn format_function(\n     let const_kw = if fun.mods.is_const { \"const \" } else { \"\" };\n     let async_kw = if fun.control_flow.is_async { \"async \" } else { \"\" };\n     let unsafe_kw = if fun.control_flow.is_unsafe { \"unsafe \" } else { \"\" };\n+    let (generic_params, where_clause) = make_generic_params_and_where_clause(ctx, fun);\n     match ctx.config.snippet_cap {\n         Some(_) => format_to!(\n             fn_def,\n-            \"\\n\\n{}{}{}{}fn $0{}{}\",\n+            \"\\n\\n{}{}{}{}fn $0{}\",\n             new_indent,\n             const_kw,\n             async_kw,\n             unsafe_kw,\n             fun.name,\n-            params\n         ),\n         None => format_to!(\n             fn_def,\n-            \"\\n\\n{}{}{}{}fn {}{}\",\n+            \"\\n\\n{}{}{}{}fn {}\",\n             new_indent,\n             const_kw,\n             async_kw,\n             unsafe_kw,\n             fun.name,\n-            params\n         ),\n     }\n+\n+    if let Some(generic_params) = generic_params {\n+        format_to!(fn_def, \"{}\", generic_params);\n+    }\n+\n+    format_to!(fn_def, \"{}\", params);\n+\n     if let Some(ret_ty) = ret_ty {\n         format_to!(fn_def, \" {}\", ret_ty);\n     }\n+\n+    if let Some(where_clause) = where_clause {\n+        format_to!(fn_def, \" {}\", where_clause);\n+    }\n+\n     format_to!(fn_def, \" {}\", body);\n \n     fn_def\n }\n \n+fn make_generic_params_and_where_clause(\n+    ctx: &AssistContext,\n+    fun: &Function,\n+) -> (Option<ast::GenericParamList>, Option<ast::WhereClause>) {\n+    let used_type_params = fun.type_params(ctx);\n+\n+    let generic_param_list = make_generic_param_list(ctx, fun, &used_type_params);\n+    let where_clause = make_where_clause(ctx, fun, &used_type_params);\n+\n+    (generic_param_list, where_clause)\n+}\n+\n+fn make_generic_param_list(\n+    ctx: &AssistContext,\n+    fun: &Function,\n+    used_type_params: &[TypeParam],\n+) -> Option<ast::GenericParamList> {\n+    let mut generic_params = fun\n+        .mods\n+        .generic_param_lists\n+        .iter()\n+        .flat_map(|parent_params| {\n+            parent_params\n+                .generic_params()\n+                .filter(|param| param_is_required(ctx, param, used_type_params))\n+        })\n+        .peekable();\n+\n+    if generic_params.peek().is_some() {\n+        Some(make::generic_param_list(generic_params))\n+    } else {\n+        None\n+    }\n+}\n+\n+fn param_is_required(\n+    ctx: &AssistContext,\n+    param: &ast::GenericParam,\n+    used_type_params: &[TypeParam],\n+) -> bool {\n+    match param {\n+        ast::GenericParam::ConstParam(_) | ast::GenericParam::LifetimeParam(_) => false,\n+        ast::GenericParam::TypeParam(type_param) => match &ctx.sema.to_def(type_param) {\n+            Some(def) => used_type_params.contains(def),\n+            _ => false,\n+        },\n+    }\n+}\n+\n+fn make_where_clause(\n+    ctx: &AssistContext,\n+    fun: &Function,\n+    used_type_params: &[TypeParam],\n+) -> Option<ast::WhereClause> {\n+    let mut predicates = fun\n+        .mods\n+        .where_clauses\n+        .iter()\n+        .flat_map(|parent_where_clause| {\n+            parent_where_clause\n+                .predicates()\n+                .filter(|pred| pred_is_required(ctx, pred, used_type_params))\n+        })\n+        .peekable();\n+\n+    if predicates.peek().is_some() {\n+        Some(make::where_clause(predicates))\n+    } else {\n+        None\n+    }\n+}\n+\n+fn pred_is_required(\n+    ctx: &AssistContext,\n+    pred: &ast::WherePred,\n+    used_type_params: &[TypeParam],\n+) -> bool {\n+    match resolved_type_param(ctx, pred) {\n+        Some(it) => used_type_params.contains(&it),\n+        None => false,\n+    }\n+}\n+\n+fn resolved_type_param(ctx: &AssistContext, pred: &ast::WherePred) -> Option<TypeParam> {\n+    let path = match pred.ty()? {\n+        ast::Type::PathType(path_type) => path_type.path(),\n+        _ => None,\n+    }?;\n+\n+    match ctx.sema.resolve_path(&path)? {\n+        PathResolution::TypeParam(type_param) => Some(type_param),\n+        _ => None,\n+    }\n+}\n+\n impl Function {\n+    /// Collect all the `TypeParam`s used in the `body` and `params`.\n+    fn type_params(&self, ctx: &AssistContext) -> Vec<TypeParam> {\n+        let type_params_in_descendant_paths =\n+            self.body.descendant_paths().filter_map(|it| match ctx.sema.resolve_path(&it) {\n+                Some(PathResolution::TypeParam(type_param)) => Some(type_param),\n+                _ => None,\n+            });\n+        let type_params_in_params = self.params.iter().filter_map(|p| p.ty.as_type_param(ctx.db()));\n+        type_params_in_descendant_paths.chain(type_params_in_params).collect()\n+    }\n+\n     fn make_param_list(&self, ctx: &AssistContext, module: hir::Module) -> ast::ParamList {\n         let self_param = self.self_param.clone();\n         let params = self.params.iter().map(|param| param.to_param(ctx, module));\n@@ -4872,6 +5044,254 @@ fn parent(factor: i32) {\n fn $0fun_name(v: &[i32; 3], factor: i32) {\n     v.iter().map(|it| it * factor);\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn preserve_generics() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func<T: Debug>(i: T) {\n+    $0foo(i);$0\n+}\n+\"#,\n+            r#\"\n+fn func<T: Debug>(i: T) {\n+    fun_name(i);\n+}\n+\n+fn $0fun_name<T: Debug>(i: T) {\n+    foo(i);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn preserve_generics_from_body() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func<T: Default>() -> T {\n+    $0T::default()$0\n+}\n+\"#,\n+            r#\"\n+fn func<T: Default>() -> T {\n+    fun_name()\n+}\n+\n+fn $0fun_name<T: Default>() -> T {\n+    T::default()\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn filter_unused_generics() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func<T: Debug, U: Copy>(i: T, u: U) {\n+    bar(u);\n+    $0foo(i);$0\n+}\n+\"#,\n+            r#\"\n+fn func<T: Debug, U: Copy>(i: T, u: U) {\n+    bar(u);\n+    fun_name(i);\n+}\n+\n+fn $0fun_name<T: Debug>(i: T) {\n+    foo(i);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn empty_generic_param_list() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func<T: Debug>(t: T, i: u32) {\n+    bar(t);\n+    $0foo(i);$0\n+}\n+\"#,\n+            r#\"\n+fn func<T: Debug>(t: T, i: u32) {\n+    bar(t);\n+    fun_name(i);\n+}\n+\n+fn $0fun_name(i: u32) {\n+    foo(i);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn preserve_where_clause() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func<T>(i: T) where T: Debug {\n+    $0foo(i);$0\n+}\n+\"#,\n+            r#\"\n+fn func<T>(i: T) where T: Debug {\n+    fun_name(i);\n+}\n+\n+fn $0fun_name<T>(i: T) where T: Debug {\n+    foo(i);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn filter_unused_where_clause() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+fn func<T, U>(i: T, u: U) where T: Debug, U: Copy {\n+    bar(u);\n+    $0foo(i);$0\n+}\n+\"#,\n+            r#\"\n+fn func<T, U>(i: T, u: U) where T: Debug, U: Copy {\n+    bar(u);\n+    fun_name(i);\n+}\n+\n+fn $0fun_name<T>(i: T) where T: Debug {\n+    foo(i);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn nested_generics() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct<T: Into<i32>>(T);\n+impl <T: Into<i32> + Copy> Struct<T> {\n+    fn func<V: Into<i32>>(&self, v: V) -> i32 {\n+        let t = self.0;\n+        $0t.into() + v.into()$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct<T: Into<i32>>(T);\n+impl <T: Into<i32> + Copy> Struct<T> {\n+    fn func<V: Into<i32>>(&self, v: V) -> i32 {\n+        let t = self.0;\n+        fun_name(t, v)\n+    }\n+}\n+\n+fn $0fun_name<T: Into<i32> + Copy, V: Into<i32>>(t: T, v: V) -> i32 {\n+    t.into() + v.into()\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn filters_unused_nested_generics() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct<T: Into<i32>, U: Debug>(T, U);\n+impl <T: Into<i32> + Copy, U: Debug> Struct<T, U> {\n+    fn func<V: Into<i32>>(&self, v: V) -> i32 {\n+        let t = self.0;\n+        $0t.into() + v.into()$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct<T: Into<i32>, U: Debug>(T, U);\n+impl <T: Into<i32> + Copy, U: Debug> Struct<T, U> {\n+    fn func<V: Into<i32>>(&self, v: V) -> i32 {\n+        let t = self.0;\n+        fun_name(t, v)\n+    }\n+}\n+\n+fn $0fun_name<T: Into<i32> + Copy, V: Into<i32>>(t: T, v: V) -> i32 {\n+    t.into() + v.into()\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn nested_where_clauses() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct<T>(T) where T: Into<i32>;\n+impl <T> Struct<T> where T: Into<i32> + Copy {\n+    fn func<V>(&self, v: V) -> i32 where V: Into<i32> {\n+        let t = self.0;\n+        $0t.into() + v.into()$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct<T>(T) where T: Into<i32>;\n+impl <T> Struct<T> where T: Into<i32> + Copy {\n+    fn func<V>(&self, v: V) -> i32 where V: Into<i32> {\n+        let t = self.0;\n+        fun_name(t, v)\n+    }\n+}\n+\n+fn $0fun_name<T, V>(t: T, v: V) -> i32 where T: Into<i32> + Copy, V: Into<i32> {\n+    t.into() + v.into()\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn filters_unused_nested_where_clauses() {\n+        check_assist(\n+            extract_function,\n+            r#\"\n+struct Struct<T, U>(T, U) where T: Into<i32>, U: Debug;\n+impl <T, U> Struct<T, U> where T: Into<i32> + Copy, U: Debug {\n+    fn func<V>(&self, v: V) -> i32 where V: Into<i32> {\n+        let t = self.0;\n+        $0t.into() + v.into()$0\n+    }\n+}\n+\"#,\n+            r#\"\n+struct Struct<T, U>(T, U) where T: Into<i32>, U: Debug;\n+impl <T, U> Struct<T, U> where T: Into<i32> + Copy, U: Debug {\n+    fn func<V>(&self, v: V) -> i32 where V: Into<i32> {\n+        let t = self.0;\n+        fun_name(t, v)\n+    }\n+}\n+\n+fn $0fun_name<T, V>(t: T, v: V) -> i32 where T: Into<i32> + Copy, V: Into<i32> {\n+    t.into() + v.into()\n+}\n \"#,\n         );\n     }"}]}