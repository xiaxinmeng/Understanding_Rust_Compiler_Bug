{"sha": "b31998ec93c1738642fd1557b419fa651bb6b543", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMTk5OGVjOTNjMTczODY0MmZkMTU1N2I0MTlmYTY1MWJiNmI1NDM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-21T17:41:56Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-21T17:41:56Z"}, "message": "Merge remote-tracking branch 'origin/master' into gen", "tree": {"sha": "c9461144895ec8d0f937fd16b7f5fbf2942e6706", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9461144895ec8d0f937fd16b7f5fbf2942e6706"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b31998ec93c1738642fd1557b419fa651bb6b543", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b31998ec93c1738642fd1557b419fa651bb6b543", "html_url": "https://github.com/rust-lang/rust/commit/b31998ec93c1738642fd1557b419fa651bb6b543", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b31998ec93c1738642fd1557b419fa651bb6b543/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf3ebcc98788d805f96b171362d272c93e0a50a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf3ebcc98788d805f96b171362d272c93e0a50a0", "html_url": "https://github.com/rust-lang/rust/commit/bf3ebcc98788d805f96b171362d272c93e0a50a0"}, {"sha": "757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "url": "https://api.github.com/repos/rust-lang/rust/commits/757b7ac2abd69d97ba196b76f0bbf78c377aaea9", "html_url": "https://github.com/rust-lang/rust/commit/757b7ac2abd69d97ba196b76f0bbf78c377aaea9"}], "stats": {"total": 2282, "additions": 719, "deletions": 1563}, "files": [{"sha": "c424ca7ab009e147204c599a94cae2ba1b9da97e", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -415,4 +415,4 @@ are:\n [tlgba]: http://tomlee.co/2014/04/a-more-detailed-tour-of-the-rust-compiler/\n [ro]: http://www.rustaceans.org/\n [rctd]: ./src/test/COMPILER_TESTS.md\n-[cheatsheet]: https://buildbot.rust-lang.org/homu/\n+[cheatsheet]: https://buildbot2.rust-lang.org/homu/"}, {"sha": "d615037b632d7e3c258c3b1c5593b37f87490561", "filename": "src/etc/platform-intrinsics/powerpc.json", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fpowerpc.json?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -121,6 +121,41 @@\n             \"llvm\": \"vavg{0.kind}{0.data_type_short}\",\n             \"ret\": \"i(8-32)\",\n             \"args\": [\"0\", \"0\"]\n+        },\n+        {\n+            \"intrinsic\": \"packs{0.kind}{1.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vpk{0.kind}{1.data_type_short}{0.kind}s\",\n+            \"ret\": \"i(8-16)\",\n+            \"args\": [\"0W\", \"1\"]\n+        },\n+        {\n+            \"intrinsic\": \"packsu{1.kind}{1.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vpk{1.kind}{1.data_type_short}{0.kind}s\",\n+            \"ret\": \"u(8-16)\",\n+            \"args\": [\"0Ws\", \"1\"]\n+        },\n+        {\n+            \"intrinsic\": \"packpx\",\n+            \"width\": [128],\n+            \"llvm\": \"vpkpx\",\n+            \"ret\": \"s16\",\n+            \"args\": [\"s32\", \"s32\"]\n+        },\n+        {\n+            \"intrinsic\": \"unpackl{1.kind}{1.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vupkl{1.kind}{1.data_type_short}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0N\"]\n+        },\n+        {\n+            \"intrinsic\": \"unpackh{1.kind}{1.data_type_short}\",\n+            \"width\": [128],\n+            \"llvm\": \"vupkh{1.kind}{1.data_type_short}\",\n+            \"ret\": \"s(16-32)\",\n+            \"args\": [\"0N\"]\n         }\n     ]\n }"}, {"sha": "1f5a28755e301ac581e2048011e4e0ff3da482ef", "filename": "src/jemalloc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fjemalloc?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -1 +1 @@\n-Subproject commit 11bfb0dcf85f7aa92abd30524bb1e42e18d108c6\n+Subproject commit 1f5a28755e301ac581e2048011e4e0ff3da482ef"}, {"sha": "578d90c5ba9bbb413d982bc5e5ce3204d376998c", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -211,7 +211,7 @@\n //!\n //! - [`fmt::Display`][`Display`] implementations assert that the type can be faithfully\n //!   represented as a UTF-8 string at all times. It is **not** expected that\n-//!   all types implement the `Display` trait.\n+//!   all types implement the [`Display`] trait.\n //! - [`fmt::Debug`][`Debug`] implementations should be implemented for **all** public types.\n //!   Output will typically represent the internal state as faithfully as possible.\n //!   The purpose of the [`Debug`] trait is to facilitate debugging Rust code. In"}, {"sha": "96bd6273c9484b15a20b3b2a2b354e3806eff6b5", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -38,7 +38,7 @@\n //! let message = s + \" world!\";\n //! ```\n //!\n-//! If you have a vector of valid UTF-8 bytes, you can make a `String` out of\n+//! If you have a vector of valid UTF-8 bytes, you can make a [`String`] out of\n //! it. You can do the reverse too.\n //!\n //! ```\n@@ -155,17 +155,14 @@ use boxed::Box;\n /// takes_str(&s);\n /// ```\n ///\n-/// [`&str`]: ../../std/primitive.str.html\n-/// [`Deref`]: ../../std/ops/trait.Deref.html\n-///\n /// This will create a [`&str`] from the `String` and pass it in. This\n /// conversion is very inexpensive, and so generally, functions will accept\n /// [`&str`]s as arguments unless they need a `String` for some specific\n /// reason.\n ///\n /// In certain cases Rust doesn't have enough information to make this\n-/// conversion, known as `Deref` coercion. In the following example a string\n-/// slice `&'a str` implements the trait `TraitExample`, and the function\n+/// conversion, known as [`Deref`] coercion. In the following example a string\n+/// slice [`&'a str`][`&str`] implements the trait `TraitExample`, and the function\n /// `example_func` takes anything that implements the trait. In this case Rust\n /// would need to make two implicit conversions, which Rust doesn't have the\n /// means to do. For that reason, the following example will not compile.\n@@ -185,13 +182,13 @@ use boxed::Box;\n ///\n /// There are two options that would work instead. The first would be to\n /// change the line `example_func(&example_string);` to\n-/// `example_func(example_string.as_str());`, using the method `as_str()`\n+/// `example_func(example_string.as_str());`, using the method [`as_str()`]\n /// to explicitly extract the string slice containing the string. The second\n /// way changes `example_func(&example_string);` to\n /// `example_func(&*example_string);`. In this case we are dereferencing a\n-/// `String` to a `str`, then referencing the `str` back to `&str`. The\n-/// second way is more idiomatic, however both work to do the conversion\n-/// explicitly rather than relying on the implicit conversion.\n+/// `String` to a [`str`][`&str`], then referencing the [`str`][`&str`] back to\n+/// [`&str`]. The second way is more idiomatic, however both work to do the\n+/// conversion explicitly rather than relying on the implicit conversion.\n ///\n /// # Representation\n ///\n@@ -287,6 +284,10 @@ use boxed::Box;\n /// ```\n ///\n /// Here, there's no need to allocate more memory inside the loop.\n+///\n+/// [`&str`]: ../../std/primitive.str.html\n+/// [`Deref`]: ../../std/ops/trait.Deref.html\n+/// [`as_str()`]: struct.String.html#method.as_str\n #[derive(PartialOrd, Eq, Ord)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct String {\n@@ -443,32 +444,22 @@ impl String {\n     /// requires that it is valid UTF-8. `from_utf8()` checks to ensure that\n     /// the bytes are valid UTF-8, and then does the conversion.\n     ///\n-    /// [`&str`]: ../../std/primitive.str.html\n-    /// [`u8`]: ../../std/primitive.u8.html\n-    /// [`Vec<u8>`]: ../../std/vec/struct.Vec.html\n-    ///\n     /// If you are sure that the byte slice is valid UTF-8, and you don't want\n     /// to incur the overhead of the validity check, there is an unsafe version\n     /// of this function, [`from_utf8_unchecked`], which has the same behavior\n     /// but skips the check.\n     ///\n-    /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n-    ///\n     /// This method will take care to not copy the vector, for efficiency's\n     /// sake.\n     ///\n-    /// If you need a `&str` instead of a `String`, consider\n+    /// If you need a [`&str`] instead of a `String`, consider\n     /// [`str::from_utf8`].\n     ///\n-    /// [`str::from_utf8`]: ../../std/str/fn.from_utf8.html\n-    ///\n     /// The inverse of this method is [`as_bytes`].\n     ///\n-    /// [`as_bytes`]: #method.as_bytes\n-    ///\n     /// # Errors\n     ///\n-    /// Returns `Err` if the slice is not UTF-8 with a description as to why the\n+    /// Returns [`Err`] if the slice is not UTF-8 with a description as to why the\n     /// provided bytes are not UTF-8. The vector you moved in is also included.\n     ///\n     /// # Examples\n@@ -497,7 +488,14 @@ impl String {\n     /// See the docs for [`FromUtf8Error`] for more details on what you can do\n     /// with this error.\n     ///\n+    /// [`from_utf8_unchecked`]: struct.String.html#method.from_utf8_unchecked\n+    /// [`&str`]: ../../std/primitive.str.html\n+    /// [`u8`]: ../../std/primitive.u8.html\n+    /// [`Vec<u8>`]: ../../std/vec/struct.Vec.html\n+    /// [`str::from_utf8`]: ../../std/str/fn.from_utf8.html\n+    /// [`as_bytes`]: struct.String.html#method.as_bytes\n     /// [`FromUtf8Error`]: struct.FromUtf8Error.html\n+    /// [`Err`]: ../../stdresult/enum.Result.html#variant.Err\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_utf8(vec: Vec<u8>) -> Result<String, FromUtf8Error> {\n@@ -594,9 +592,11 @@ impl String {\n         Cow::Owned(res)\n     }\n \n-    /// Decode a UTF-16 encoded vector `v` into a `String`, returning `Err`\n+    /// Decode a UTF-16 encoded vector `v` into a `String`, returning [`Err`]\n     /// if `v` contains any invalid data.\n     ///\n+    /// [`Err`]: ../../std/result/enum.Result.htlm#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -618,7 +618,7 @@ impl String {\n         decode_utf16(v.iter().cloned()).collect::<Result<_, _>>().map_err(|_| FromUtf16Error(()))\n     }\n \n-    /// Decode a UTF-16 encoded vector `v` into a string, replacing\n+    /// Decode a UTF-16 encoded slice `v` into a `String`, replacing\n     /// invalid data with the replacement character (U+FFFD).\n     ///\n     /// # Examples\n@@ -800,11 +800,12 @@ impl String {\n     /// If you do not want this \"at least\" behavior, see the [`reserve_exact`]\n     /// method.\n     ///\n-    /// [`reserve_exact`]: #method.reserve_exact\n-    ///\n     /// # Panics\n     ///\n-    /// Panics if the new capacity overflows `usize`.\n+    /// Panics if the new capacity overflows [`usize`].\n+    ///\n+    /// [`reserve_exact`]: struct.String.html#method.reserve_exact\n+    /// [`usize`]: ../../std/primitive.usize.html\n     ///\n     /// # Examples\n     ///\n@@ -909,7 +910,9 @@ impl String {\n         self.vec.shrink_to_fit()\n     }\n \n-    /// Appends the given `char` to the end of this `String`.\n+    /// Appends the given [`char`] to the end of this `String`.\n+    ///\n+    /// [`char`]: ../../std/primitive.char.html\n     ///\n     /// # Examples\n     ///\n@@ -990,7 +993,9 @@ impl String {\n \n     /// Removes the last character from the string buffer and returns it.\n     ///\n-    /// Returns `None` if this `String` is empty.\n+    /// Returns [`None`] if this `String` is empty.\n+    ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// # Examples\n     ///\n@@ -1019,7 +1024,7 @@ impl String {\n         Some(ch)\n     }\n \n-    /// Removes a `char` from this `String` at a byte position and returns it.\n+    /// Removes a [`char`] from this `String` at a byte position and returns it.\n     ///\n     /// This is an `O(n)` operation, as it requires copying every element in the\n     /// buffer.\n@@ -1389,7 +1394,7 @@ impl String {\n     /// replaces with the given string, and yields the removed chars.\n     /// The given string doesn\u2019t need to be the same length as the range.\n     ///\n-    /// Note: The element range is removed when the `Splice` is dropped,\n+    /// Note: The element range is removed when the [`Splice`] is dropped,\n     /// even if the iterator is not consumed until the end.\n     ///\n     /// # Panics\n@@ -1398,6 +1403,7 @@ impl String {\n     /// boundary, or if they're out of bounds.\n     ///\n     /// [`char`]: ../../std/primitive.char.html\n+    /// [`Splice`]: ../../std/string/struct.Splice.html\n     ///\n     /// # Examples\n     ///\n@@ -1450,10 +1456,13 @@ impl String {\n         }\n     }\n \n-    /// Converts this `String` into a `Box<str>`.\n+    /// Converts this `String` into a [`Box`]`<`[`str`]`>`.\n     ///\n     /// This will drop any excess capacity.\n     ///\n+    /// [`Box`]: ../../std/boxed/struct.Box.html\n+    /// [`str`]: ../../std/primitive.str.html\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:"}, {"sha": "41193f6a41f89a434fb6f1537987739622851674", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -93,29 +93,7 @@ fn main() {\n        .env(\"AR\", &ar)\n        .env(\"RANLIB\", format!(\"{} s\", ar.display()));\n \n-    if target.contains(\"windows\") {\n-        // A bit of history here, this used to be --enable-lazy-lock added in\n-        // #14006 which was filed with jemalloc in jemalloc/jemalloc#83 which\n-        // was also reported to MinGW:\n-        //\n-        //  http://sourceforge.net/p/mingw-w64/bugs/395/\n-        //\n-        // When updating jemalloc to 4.0, however, it was found that binaries\n-        // would exit with the status code STATUS_RESOURCE_NOT_OWNED indicating\n-        // that a thread was unlocking a mutex it never locked. Disabling this\n-        // \"lazy lock\" option seems to fix the issue, but it was enabled by\n-        // default for MinGW targets in 13473c7 for jemalloc.\n-        //\n-        // As a result of all that, force disabling lazy lock on Windows, and\n-        // after reading some code it at least *appears* that the initialization\n-        // of mutexes is otherwise ok in jemalloc, so shouldn't cause problems\n-        // hopefully...\n-        //\n-        // tl;dr: make windows behave like other platforms by disabling lazy\n-        //        locking, but requires passing an option due to a historical\n-        //        default with jemalloc.\n-        cmd.arg(\"--disable-lazy-lock\");\n-    } else if target.contains(\"ios\") {\n+    if target.contains(\"ios\") {\n         cmd.arg(\"--disable-tls\");\n     } else if target.contains(\"android\") {\n         // We force android to have prefixed symbols because apparently"}, {"sha": "6b9281d2b2f0ebb94838814b1e8ace2de4b7035b", "filename": "src/libcompiler_builtins", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -1 +1 @@\n-Subproject commit 5e49856003f33aa5781a0edca148be21025e18e7\n+Subproject commit 6b9281d2b2f0ebb94838814b1e8ace2de4b7035b"}, {"sha": "b44738b795db36a0aaa4f9e94cc5c216ff6264b8", "filename": "src/libcore/array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -89,7 +89,7 @@ macro_rules! __impl_slice_eq2 {\n     }\n }\n \n-// macro for implementing n-ary tuple functions and operations\n+// macro for implementing n-element array functions and operations\n macro_rules! array_impls {\n     ($($N:expr)+) => {\n         $("}, {"sha": "7c009114afefb969570137a2081e4cc688d2d432", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -605,7 +605,7 @@ pub trait Iterator {\n     /// closure returns [`None`], it will try again, and call the closure on the\n     /// next element, seeing if it will return [`Some`].\n     ///\n-    /// Why `filter_map` and not just [`filter`].[`map`]? The key is in this\n+    /// Why `filter_map` and not just [`filter`] and [`map`]? The key is in this\n     /// part:\n     ///\n     /// [`filter`]: #method.filter"}, {"sha": "ea064ca5c39fe0539804ab0536e519e538000cc3", "filename": "src/libcore/result.rs", "status": "modified", "additions": 73, "deletions": 27, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -244,9 +244,12 @@ use fmt;\n use iter::{FromIterator, FusedIterator, TrustedLen};\n use ops;\n \n-/// `Result` is a type that represents either success (`Ok`) or failure (`Err`).\n+/// `Result` is a type that represents either success ([`Ok`]) or failure ([`Err`]).\n ///\n /// See the [`std::result`](index.html) module documentation for details.\n+///\n+/// [`Ok`]: enum.Result.html#variant.Ok\n+/// [`Err`]: enum.Result.html#variant.Err\n #[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -269,7 +272,9 @@ impl<T, E> Result<T, E> {\n     // Querying the contained values\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Returns `true` if the result is `Ok`.\n+    /// Returns `true` if the result is [`Ok`].\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n     ///\n     /// # Examples\n     ///\n@@ -291,7 +296,9 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Returns `true` if the result is `Err`.\n+    /// Returns `true` if the result is [`Err`].\n+    ///\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -433,10 +440,13 @@ impl<T, E> Result<T, E> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a\n-    /// contained `Ok` value, leaving an `Err` value untouched.\n+    /// contained [`Ok`] value, leaving an [`Err`] value untouched.\n     ///\n     /// This function can be used to compose the results of two functions.\n     ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// Print the numbers on each line of a string multiplied by two.\n@@ -461,11 +471,14 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a\n-    /// contained `Err` value, leaving an `Ok` value untouched.\n+    /// contained [`Err`] value, leaving an [`Ok`] value untouched.\n     ///\n     /// This function can be used to pass through a successful result while handling\n     /// an error.\n     ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -546,7 +559,10 @@ impl<T, E> Result<T, E> {\n     // Boolean operations on the values, eager and lazy\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n+    /// Returns `res` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -578,7 +594,10 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n+    /// Calls `op` if the result is [`Ok`], otherwise returns the [`Err`] value of `self`.\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// This function can be used for control flow based on `Result` values.\n     ///\n@@ -604,7 +623,10 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n+    /// Returns `res` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -636,10 +658,13 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Calls `op` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n+    /// Calls `op` if the result is [`Err`], otherwise returns the [`Ok`] value of `self`.\n     ///\n     /// This function can be used for control flow based on result values.\n     ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -662,9 +687,12 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an `Ok`.\n+    /// Unwraps a result, yielding the content of an [`Ok`].\n     /// Else, it returns `optb`.\n     ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -686,8 +714,11 @@ impl<T, E> Result<T, E> {\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an `Ok`.\n-    /// If the value is an `Err` then it calls `op` with its value.\n+    /// Unwraps a result, yielding the content of an [`Ok`].\n+    /// If the value is an [`Err`] then it calls `op` with its value.\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -710,12 +741,15 @@ impl<T, E> Result<T, E> {\n }\n \n impl<T, E: fmt::Debug> Result<T, E> {\n-    /// Unwraps a result, yielding the content of an `Ok`.\n+    /// Unwraps a result, yielding the content of an [`Ok`].\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the value is an `Err`, with a panic message provided by the\n-    /// `Err`'s value.\n+    /// Panics if the value is an [`Err`], with a panic message provided by the\n+    /// [`Err`]'s value.\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -739,12 +773,15 @@ impl<T, E: fmt::Debug> Result<T, E> {\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an `Ok`.\n+    /// Unwraps a result, yielding the content of an [`Ok`].\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the value is an `Err`, with a panic message including the\n-    /// passed message, and the content of the `Err`.\n+    /// Panics if the value is an [`Err`], with a panic message including the\n+    /// passed message, and the content of the [`Err`].\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -765,12 +802,16 @@ impl<T, E: fmt::Debug> Result<T, E> {\n }\n \n impl<T: fmt::Debug, E> Result<T, E> {\n-    /// Unwraps a result, yielding the content of an `Err`.\n+    /// Unwraps a result, yielding the content of an [`Err`].\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the value is an `Ok`, with a custom panic message provided\n-    /// by the `Ok`'s value.\n+    /// Panics if the value is an [`Ok`], with a custom panic message provided\n+    /// by the [`Ok`]'s value.\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n+    ///\n     ///\n     /// # Examples\n     ///\n@@ -792,12 +833,15 @@ impl<T: fmt::Debug, E> Result<T, E> {\n         }\n     }\n \n-    /// Unwraps a result, yielding the content of an `Err`.\n+    /// Unwraps a result, yielding the content of an [`Err`].\n     ///\n     /// # Panics\n     ///\n-    /// Panics if the value is an `Ok`, with a panic message including the\n-    /// passed message, and the content of the `Ok`.\n+    /// Panics if the value is an [`Ok`], with a panic message including the\n+    /// passed message, and the content of the [`Ok`].\n+    ///\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     ///\n     /// # Examples\n     ///\n@@ -820,16 +864,16 @@ impl<T: fmt::Debug, E> Result<T, E> {\n impl<T: Default, E> Result<T, E> {\n     /// Returns the contained value or a default\n     ///\n-    /// Consumes the `self` argument then, if `Ok`, returns the contained\n-    /// value, otherwise if `Err`, returns the default value for that\n+    /// Consumes the `self` argument then, if [`Ok`], returns the contained\n+    /// value, otherwise if [`Err`], returns the default value for that\n     /// type.\n     ///\n     /// # Examples\n     ///\n     /// Convert a string to an integer, turning poorly-formed strings\n     /// into 0 (the default value for integers). [`parse`] converts\n     /// a string to any other type that implements [`FromStr`], returning an\n-    /// `Err` on error.\n+    /// [`Err`] on error.\n     ///\n     /// ```\n     /// let good_year_from_input = \"1909\";\n@@ -843,6 +887,8 @@ impl<T: Default, E> Result<T, E> {\n     ///\n     /// [`parse`]: ../../std/primitive.str.html#method.parse\n     /// [`FromStr`]: ../../std/str/trait.FromStr.html\n+    /// [`Ok`]: enum.Result.html#variant.Ok\n+    /// [`Err`]: enum.Result.html#variant.Err\n     #[inline]\n     #[stable(feature = \"result_unwrap_or_default\", since = \"1.16.0\")]\n     pub fn unwrap_or_default(self) -> T {"}, {"sha": "d8e825f9a73abf65539981b97fa3222a25b362f7", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -59,7 +59,7 @@ use syntax::ast::*;\n use syntax::errors;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n-use syntax::codemap::{self, respan, Spanned};\n+use syntax::codemap::{self, respan, Spanned, CompilerDesugaringKind};\n use syntax::std_inject;\n use syntax::symbol::{Symbol, keywords};\n use syntax::util::small_vector::SmallVector;\n@@ -418,12 +418,14 @@ impl<'a> LoweringContext<'a> {\n         Symbol::gensym(s)\n     }\n \n-    fn allow_internal_unstable(&self, reason: &'static str, mut span: Span) -> Span {\n+    fn allow_internal_unstable(&self, reason: CompilerDesugaringKind, mut span: Span)\n+        -> Span\n+    {\n         let mark = Mark::fresh(Mark::root());\n         mark.set_expn_info(codemap::ExpnInfo {\n             call_site: span,\n             callee: codemap::NameAndSpan {\n-                format: codemap::CompilerDesugaring(Symbol::intern(reason)),\n+                format: codemap::CompilerDesugaring(reason),\n                 span: Some(span),\n                 allow_internal_unstable: true,\n                 allow_internal_unsafe: false,\n@@ -1802,7 +1804,8 @@ impl<'a> LoweringContext<'a> {\n                 let move_val_init = [\"intrinsics\", \"move_val_init\"];\n                 let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n \n-                let unstable_span = self.allow_internal_unstable(\"<-\", e.span);\n+                let unstable_span =\n+                    self.allow_internal_unstable(CompilerDesugaringKind::BackArrow, e.span);\n                 let make_call = |this: &mut LoweringContext, p, args| {\n                     let path = P(this.expr_std_path(unstable_span, p, ThinVec::new()));\n                     P(this.expr_call(e.span, path, args))\n@@ -2030,12 +2033,14 @@ impl<'a> LoweringContext<'a> {\n                     e1.iter().map(|e| (\"start\", e)).chain(e2.iter().map(|e| (\"end\", e)))\n                     .map(|(s, e)| {\n                         let expr = P(self.lower_expr(&e));\n-                        let unstable_span = self.allow_internal_unstable(\"...\", e.span);\n+                        let unstable_span =\n+                            self.allow_internal_unstable(CompilerDesugaringKind::DotFill, e.span);\n                         self.field(Symbol::intern(s), expr, unstable_span)\n                     }).collect::<P<[hir::Field]>>();\n \n                 let is_unit = fields.is_empty();\n-                let unstable_span = self.allow_internal_unstable(\"...\", e.span);\n+                let unstable_span =\n+                    self.allow_internal_unstable(CompilerDesugaringKind::DotFill, e.span);\n                 let struct_path =\n                     iter::once(\"ops\").chain(iter::once(path))\n                     .collect::<Vec<_>>();\n@@ -2384,7 +2389,8 @@ impl<'a> LoweringContext<'a> {\n                 //                 return Try::from_error(From::from(err)),\n                 // }\n \n-                let unstable_span = self.allow_internal_unstable(\"?\", e.span);\n+                let unstable_span =\n+                    self.allow_internal_unstable(CompilerDesugaringKind::QuestionMark, e.span);\n \n                 // Try::into_result(<expr>)\n                 let discr = {"}, {"sha": "45d94033be0745a921343852205957d81b34470a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -42,6 +42,7 @@ use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenStream;\n use syntax::util::ThinVec;\n+use ty::AdtKind;\n \n use rustc_data_structures::indexed_vec;\n \n@@ -1796,6 +1797,15 @@ impl Item_ {\n             ItemDefaultImpl(..) => \"item\",\n         }\n     }\n+\n+    pub fn adt_kind(&self) -> Option<AdtKind> {\n+        match *self {\n+            ItemStruct(..) => Some(AdtKind::Struct),\n+            ItemUnion(..) => Some(AdtKind::Union),\n+            ItemEnum(..) => Some(AdtKind::Enum),\n+            _ => None,\n+        }\n+    }\n }\n \n /// A reference from an trait to one of its associated items. This"}, {"sha": "8281d4716c4cec7d2c49f6cbb92ed44c22634cb9", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -899,9 +899,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             infer::LateBoundRegion(_, br, infer::HigherRankedType) => {\n                 format!(\" for lifetime parameter {}in generic type\", br_string(br))\n             }\n-            infer::LateBoundRegion(_, br, infer::AssocTypeProjection(type_name)) => {\n+            infer::LateBoundRegion(_, br, infer::AssocTypeProjection(def_id)) => {\n                 format!(\" for lifetime parameter {}in trait containing associated type `{}`\",\n-                        br_string(br), type_name)\n+                        br_string(br), self.tcx.associated_item(def_id).name)\n             }\n             infer::EarlyBoundRegion(_, name) => {\n                 format!(\" for lifetime parameter `{}`\","}, {"sha": "27c6a4c5cf291546b6412f590897870674c79d26", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -274,7 +274,7 @@ pub enum LateBoundRegionConversionTime {\n     HigherRankedType,\n \n     /// when projecting an associated type\n-    AssocTypeProjection(ast::Name), // FIXME(tschottdorf): should contain DefId, not Name\n+    AssocTypeProjection(DefId),\n }\n \n /// Reasons to create a region inference variable"}, {"sha": "4d1374b69b85cdde7e26555543b7e03ae72a284a", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -121,10 +121,10 @@ pub enum FindLintError {\n \n pub enum CheckLintNameResult<'a> {\n     Ok(&'a [LintId]),\n-    // Lint doesn't exist\n+    /// Lint doesn't exist\n     NoLint,\n-    // The lint is either renamed or removed. This is the warning\n-    // message.\n+    /// The lint is either renamed or removed. This is the warning\n+    /// message.\n     Warning(String),\n }\n \n@@ -253,7 +253,7 @@ impl LintStore {\n         }\n     }\n \n-    // Checks the validity of lint names derived from the command line\n+    /// Checks the validity of lint names derived from the command line\n     pub fn check_lint_name_cmdline(&self,\n                                    sess: &Session,\n                                    lint_name: &str,"}, {"sha": "0e7bfc8cd0d86cd9d408997ec623cdef5890bf8b", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -1112,8 +1112,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ObligationCauseCode::StructInitializerSized => {\n                 err.note(\"structs must have a statically known size to be initialized\");\n             }\n-            ObligationCauseCode::FieldSized => {\n-                err.note(\"only the last field of a struct may have a dynamically sized type\");\n+            ObligationCauseCode::FieldSized(ref item) => {\n+                match *item {\n+                    AdtKind::Struct => {\n+                        err.note(\"only the last field of a struct may have a dynamically \\\n+                                  sized type\");\n+                    }\n+                    AdtKind::Union => {\n+                        err.note(\"no field of a union may have a dynamically sized type\");\n+                    }\n+                    AdtKind::Enum => {\n+                        err.note(\"no field of an enum variant may have a dynamically sized type\");\n+                    }\n+                }\n             }\n             ObligationCauseCode::ConstSized => {\n                 err.note(\"constant expressions must have a statically known size\");\n@@ -1155,8 +1166,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn suggest_new_overflow_limit(&self, err: &mut DiagnosticBuilder) {\n         let current_limit = self.tcx.sess.recursion_limit.get();\n         let suggested_limit = current_limit * 2;\n-        err.help(&format!(\n-                          \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n+        err.help(&format!(\"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n                           suggested_limit));\n     }\n }"}, {"sha": "228c9761756a8e99079552737b7775ccf6c4178f", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -20,7 +20,7 @@ use hir::def_id::DefId;\n use middle::region::RegionMaps;\n use middle::free_region::FreeRegionMap;\n use ty::subst::Substs;\n-use ty::{self, Ty, TyCtxt, TypeFoldable, ToPredicate};\n+use ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n use infer::{InferCtxt};\n \n@@ -133,7 +133,7 @@ pub enum ObligationCauseCode<'tcx> {\n     RepeatVec,\n \n     /// Types of fields (other than the last) in a struct must be sized.\n-    FieldSized,\n+    FieldSized(AdtKind),\n \n     /// Constant expressions must be sized.\n     ConstSized,"}, {"sha": "3fc47476ce9ada767d30e12f8c2c8442bd5d39d6", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -207,7 +207,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::ReturnType(id) => Some(super::ReturnType(id)),\n             super::SizedReturnType => Some(super::SizedReturnType),\n             super::RepeatVec => Some(super::RepeatVec),\n-            super::FieldSized => Some(super::FieldSized),\n+            super::FieldSized(item) => Some(super::FieldSized(item)),\n             super::ConstSized => Some(super::ConstSized),\n             super::SharedStatic => Some(super::SharedStatic),\n             super::BuiltinDerivedObligation(ref cause) => {\n@@ -527,7 +527,7 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::SizedReturnType |\n             super::ReturnNoExpression |\n             super::RepeatVec |\n-            super::FieldSized |\n+            super::FieldSized(_) |\n             super::ConstSized |\n             super::SharedStatic |\n             super::BlockTailExpression(_) |\n@@ -575,7 +575,7 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::SizedReturnType |\n             super::ReturnNoExpression |\n             super::RepeatVec |\n-            super::FieldSized |\n+            super::FieldSized(_) |\n             super::ConstSized |\n             super::SharedStatic |\n             super::BlockTailExpression(_) |"}, {"sha": "e17fce5a2ec0a276d5409af7ecea393a3edd257b", "filename": "src/librustc_allocator/lib.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_allocator%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_allocator%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![deny(warnings)]\n+\n #![feature(rustc_private)]\n \n extern crate rustc;\n@@ -22,69 +24,58 @@ pub static ALLOCATOR_METHODS: &[AllocatorMethod] = &[\n         name: \"alloc\",\n         inputs: &[AllocatorTy::Layout],\n         output: AllocatorTy::ResultPtr,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"oom\",\n         inputs: &[AllocatorTy::AllocErr],\n         output: AllocatorTy::Bang,\n-        is_unsafe: false,\n     },\n     AllocatorMethod {\n         name: \"dealloc\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout],\n         output: AllocatorTy::Unit,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"usable_size\",\n         inputs: &[AllocatorTy::LayoutRef],\n         output: AllocatorTy::UsizePair,\n-        is_unsafe: false,\n     },\n     AllocatorMethod {\n         name: \"realloc\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n         output: AllocatorTy::ResultPtr,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"alloc_zeroed\",\n         inputs: &[AllocatorTy::Layout],\n         output: AllocatorTy::ResultPtr,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"alloc_excess\",\n         inputs: &[AllocatorTy::Layout],\n         output: AllocatorTy::ResultExcess,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"realloc_excess\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n         output: AllocatorTy::ResultExcess,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"grow_in_place\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n         output: AllocatorTy::ResultUnit,\n-        is_unsafe: true,\n     },\n     AllocatorMethod {\n         name: \"shrink_in_place\",\n         inputs: &[AllocatorTy::Ptr, AllocatorTy::Layout, AllocatorTy::Layout],\n         output: AllocatorTy::ResultUnit,\n-        is_unsafe: true,\n     },\n ];\n \n pub struct AllocatorMethod {\n     pub name: &'static str,\n     pub inputs: &'static [AllocatorTy],\n     pub output: AllocatorTy,\n-    pub is_unsafe: bool,\n }\n \n pub enum AllocatorTy {"}, {"sha": "1b42fa03a4fb621e3957708aac4424e122c4c670", "filename": "src/librustc_back/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_back%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_back%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fdynamic_lib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -12,9 +12,8 @@\n //!\n //! A simple wrapper over the platform's dynamic library facilities\n \n-use std::env;\n-use std::ffi::{CString, OsString};\n-use std::path::{Path, PathBuf};\n+use std::ffi::CString;\n+use std::path::Path;\n \n pub struct DynamicLibrary {\n     handle: *mut u8\n@@ -43,24 +42,6 @@ impl DynamicLibrary {\n         }\n     }\n \n-    /// Prepends a path to this process's search path for dynamic libraries\n-    pub fn prepend_search_path(path: &Path) {\n-        let mut search_path = DynamicLibrary::search_path();\n-        search_path.insert(0, path.to_path_buf());\n-        env::set_var(DynamicLibrary::envvar(), &DynamicLibrary::create_path(&search_path));\n-    }\n-\n-    /// From a slice of paths, create a new vector which is suitable to be an\n-    /// environment variable for this platforms dylib search path.\n-    pub fn create_path(path: &[PathBuf]) -> OsString {\n-        let mut newvar = OsString::new();\n-        for (i, path) in path.iter().enumerate() {\n-            if i > 0 { newvar.push(DynamicLibrary::separator()); }\n-            newvar.push(path);\n-        }\n-        return newvar;\n-    }\n-\n     /// Returns the environment variable for this process's dynamic library\n     /// search path\n     pub fn envvar() -> &'static str {\n@@ -75,19 +56,6 @@ impl DynamicLibrary {\n         }\n     }\n \n-    fn separator() -> &'static str {\n-        if cfg!(windows) { \";\" } else { \":\" }\n-    }\n-\n-    /// Returns the current search path for dynamic libraries being used by this\n-    /// process\n-    pub fn search_path() -> Vec<PathBuf> {\n-        match env::var_os(DynamicLibrary::envvar()) {\n-            Some(var) => env::split_paths(&var).collect(),\n-            None => Vec::new(),\n-        }\n-    }\n-\n     /// Accesses the value at the symbol of the dynamic library.\n     pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<*mut T, String> {\n         // This function should have a lifetime constraint of 'a on"}, {"sha": "c7915d4de72fe6d37607045f82b8a2a6f33de49e", "filename": "src/librustc_back/target/redox_base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fredox_base.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use {LinkerFlavor, PanicStrategy};\n+use LinkerFlavor;\n use target::{LinkArgs, TargetOptions};\n use std::default::Default;\n \n@@ -37,7 +37,6 @@ pub fn opts() -> TargetOptions {\n         target_family: None,\n         linker_is_gnu: true,\n         has_elf_tls: true,\n-        panic_strategy: PanicStrategy::Abort,\n         .. Default::default()\n     }\n }"}, {"sha": "8ffaddd7c29f2634cfd44c6a5fbbdc503b2409e6", "filename": "src/librustc_back/tempdir.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_back%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_back%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftempdir.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -95,15 +95,6 @@ impl TempDir {\n         self.path.as_ref().unwrap()\n     }\n \n-    /// Close and remove the temporary directory\n-    ///\n-    /// Although `TempDir` removes the directory on drop, in the destructor\n-    /// any errors are ignored. To detect errors cleaning up the temporary\n-    /// directory, call `close` instead.\n-    pub fn close(mut self) -> io::Result<()> {\n-        self.cleanup_dir()\n-    }\n-\n     fn cleanup_dir(&mut self) -> io::Result<()> {\n         match self.path {\n             Some(ref p) => fs::remove_dir_all(p),"}, {"sha": "24c85429dabfaa015b14d9e0458d2ee03b30ece9", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -113,37 +113,6 @@ pub fn gather_move_from_expr<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n     gather_move(bccx, move_data, move_error_collector, move_info);\n }\n \n-pub fn gather_match_variant<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n-                                      move_data: &MoveData<'tcx>,\n-                                      _move_error_collector: &mut MoveErrorCollector<'tcx>,\n-                                      move_pat: &hir::Pat,\n-                                      cmt: mc::cmt<'tcx>,\n-                                      mode: euv::MatchMode) {\n-    let tcx = bccx.tcx;\n-    debug!(\"gather_match_variant(move_pat={}, cmt={:?}, mode={:?})\",\n-           move_pat.id, cmt, mode);\n-\n-    let opt_lp = opt_loan_path(&cmt);\n-    match opt_lp {\n-        Some(lp) => {\n-            match lp.kind {\n-                LpDowncast(ref base_lp, _) =>\n-                    move_data.add_variant_match(\n-                        tcx, lp.clone(), move_pat.id, base_lp.clone(), mode),\n-                _ => bug!(\"should only call gather_match_variant \\\n-                           for cat_downcast cmt\"),\n-            }\n-        }\n-        None => {\n-            // We get None when input to match is non-path (e.g.\n-            // temporary result like a function call). Since no\n-            // loan-path is being matched, no need to record a\n-            // downcast.\n-            return;\n-        }\n-    }\n-}\n-\n pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       move_data: &MoveData<'tcx>,\n                                       move_error_collector: &mut MoveErrorCollector<'tcx>,"}, {"sha": "68bffb90f4da829a43a06282af47485ecaaa2eb8", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -93,12 +93,6 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n                matched_pat,\n                cmt,\n                mode);\n-\n-        if let Categorization::Downcast(..) = cmt.cat {\n-            gather_moves::gather_match_variant(\n-                self.bccx, &self.move_data, &mut self.move_error_collector,\n-                matched_pat, cmt, mode);\n-        }\n     }\n \n     fn consume_pat(&mut self,"}, {"sha": "b86c6a4dd1d35d31b553aa5ba1e60b87e41e60a1", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -713,15 +713,6 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         err.emit();\n     }\n \n-    pub fn span_err(&self, s: Span, m: &str) {\n-        self.tcx.sess.span_err(s, m);\n-    }\n-\n-    pub fn struct_span_err<S: Into<MultiSpan>>(&self, s: S, m: &str)\n-                                              -> DiagnosticBuilder<'a> {\n-        self.tcx.sess.struct_span_err(s, m)\n-    }\n-\n     pub fn struct_span_err_with_code<S: Into<MultiSpan>>(&self,\n                                                          s: S,\n                                                          msg: &str,"}, {"sha": "217bd6e6ca1ca5294de0d21a7f1b16be99caaf02", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -53,10 +53,6 @@ pub struct MoveData<'tcx> {\n     /// kill move bits.\n     pub path_assignments: RefCell<Vec<Assignment>>,\n \n-    /// Enum variant matched within a pattern on some match arm, like\n-    /// `SomeStruct{ f: Variant1(x, y) } => ...`\n-    pub variant_matches: RefCell<Vec<VariantMatch>>,\n-\n     /// Assignments to a variable or path, like `x = foo`, but not `x += foo`.\n     pub assignee_ids: RefCell<NodeSet>,\n }\n@@ -161,21 +157,6 @@ pub struct Assignment {\n     pub assignee_id: ast::NodeId,\n }\n \n-#[derive(Copy, Clone)]\n-pub struct VariantMatch {\n-    /// downcast to the variant.\n-    pub path: MovePathIndex,\n-\n-    /// path being downcast to the variant.\n-    pub base_path: MovePathIndex,\n-\n-    /// id where variant's pattern occurs\n-    pub id: ast::NodeId,\n-\n-    /// says if variant established by move (and why), by copy, or by borrow.\n-    pub mode: euv::MatchMode\n-}\n-\n #[derive(Clone, Copy)]\n pub struct MoveDataFlowOperator;\n \n@@ -215,7 +196,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n             moves: RefCell::new(Vec::new()),\n             path_assignments: RefCell::new(Vec::new()),\n             var_assignments: RefCell::new(Vec::new()),\n-            variant_matches: RefCell::new(Vec::new()),\n             assignee_ids: RefCell::new(NodeSet()),\n         }\n     }\n@@ -485,31 +465,6 @@ impl<'a, 'tcx> MoveData<'tcx> {\n         }\n     }\n \n-    /// Adds a new record for a match of `base_lp`, downcast to\n-    /// variant `lp`, that occurs at location `pattern_id`.  (One\n-    /// should be able to recover the span info from the\n-    /// `pattern_id` and the hir_map, I think.)\n-    pub fn add_variant_match(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                             lp: Rc<LoanPath<'tcx>>,\n-                             pattern_id: ast::NodeId,\n-                             base_lp: Rc<LoanPath<'tcx>>,\n-                             mode: euv::MatchMode) {\n-        debug!(\"add_variant_match(lp={:?}, pattern_id={})\",\n-               lp, pattern_id);\n-\n-        let path_index = self.move_path(tcx, lp.clone());\n-        let base_path_index = self.move_path(tcx, base_lp.clone());\n-\n-        let variant_match = VariantMatch {\n-            path: path_index,\n-            base_path: base_path_index,\n-            id: pattern_id,\n-            mode,\n-        };\n-\n-        self.variant_matches.borrow_mut().push(variant_match);\n-    }\n-\n     /// Adds the gen/kills for the various moves and\n     /// assignments into the provided data flow contexts.\n     /// Moves are generated by moves and killed by assignments and"}, {"sha": "7a77939faa3e7a4b430b4205a7f22dba88fc8181", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -37,11 +37,10 @@ extern crate core; // for NonZero\n \n pub use borrowck::check_crate;\n pub use borrowck::build_borrowck_dataflow_data_for_fn;\n-pub use borrowck::{AnalysisData, BorrowckCtxt};\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n-pub mod diagnostics;\n+mod diagnostics;\n \n mod borrowck;\n "}, {"sha": "3483752d4ff01854731ae29423e3867f429595db", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -41,7 +41,7 @@ extern crate syntax_pos;\n \n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n-pub mod diagnostics;\n+mod diagnostics;\n \n mod eval;\n mod _match;"}, {"sha": "b67048939e43eb1592bc6c378aeeb02634b207a2", "filename": "src/librustc_const_math/float.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_const_math%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_const_math%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ffloat.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -37,13 +37,6 @@ impl ConstFloat {\n         self.ty.ty_to_string()\n     }\n \n-    pub fn is_nan(&self) -> bool {\n-        match self.ty {\n-            ast::FloatTy::F32 => Single::from_bits(self.bits).is_nan(),\n-            ast::FloatTy::F64 => Double::from_bits(self.bits).is_nan(),\n-        }\n-    }\n-\n     /// Compares the values if they are of the same type\n     pub fn try_cmp(self, rhs: Self) -> Result<Ordering, ConstMathErr> {\n         match (self.ty, rhs.ty) {"}, {"sha": "6b8bf8df0d33f0832e24aeefc673c946c1276982", "filename": "src/librustc_data_structures/blake2b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fblake2b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fblake2b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fblake2b.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -24,7 +24,7 @@ use std::mem;\n use std::slice;\n \n #[repr(C)]\n-pub struct Blake2bCtx {\n+struct Blake2bCtx {\n     b: [u8; 128],\n     h: [u64; 8],\n     t: [u64; 2],"}, {"sha": "90670517f5967e5b9d3d0e27a94b1c65e49e1c5f", "filename": "src/librustc_data_structures/control_flow_graph/dominators/mod.rs", "status": "modified", "additions": 2, "deletions": 77, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fdominators%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -134,56 +134,10 @@ impl<Node: Idx> Dominators<Node> {\n         self.dominators(node).any(|n| n == dom)\n     }\n \n-    pub fn mutual_dominator_node(&self, node1: Node, node2: Node) -> Node {\n-        assert!(self.is_reachable(node1),\n-                \"node {:?} is not reachable\",\n-                node1);\n-        assert!(self.is_reachable(node2),\n-                \"node {:?} is not reachable\",\n-                node2);\n-        intersect::<Node>(&self.post_order_rank,\n-                          &self.immediate_dominators,\n-                          node1,\n-                          node2)\n-    }\n-\n-    pub fn mutual_dominator<I>(&self, iter: I) -> Option<Node>\n-        where I: IntoIterator<Item = Node>\n-    {\n-        let mut iter = iter.into_iter();\n-        iter.next()\n-            .map(|dom| iter.fold(dom, |dom, node| self.mutual_dominator_node(dom, node)))\n-    }\n-\n-    pub fn all_immediate_dominators(&self) -> &IndexVec<Node, Option<Node>> {\n+    #[cfg(test)]\n+    fn all_immediate_dominators(&self) -> &IndexVec<Node, Option<Node>> {\n         &self.immediate_dominators\n     }\n-\n-    pub fn dominator_tree(&self) -> DominatorTree<Node> {\n-        let elem: Vec<Node> = Vec::new();\n-        let mut children: IndexVec<Node, Vec<Node>> =\n-            IndexVec::from_elem_n(elem, self.immediate_dominators.len());\n-        let mut root = None;\n-        for (index, immed_dom) in self.immediate_dominators.iter().enumerate() {\n-            let node = Node::new(index);\n-            match *immed_dom {\n-                None => {\n-                    // node not reachable\n-                }\n-                Some(immed_dom) => {\n-                    if node == immed_dom {\n-                        root = Some(node);\n-                    } else {\n-                        children[immed_dom].push(node);\n-                    }\n-                }\n-            }\n-        }\n-        DominatorTree {\n-            root: root.unwrap(),\n-            children,\n-        }\n-    }\n }\n \n pub struct Iter<'dom, Node: Idx + 'dom> {\n@@ -215,38 +169,9 @@ pub struct DominatorTree<N: Idx> {\n }\n \n impl<Node: Idx> DominatorTree<Node> {\n-    pub fn root(&self) -> Node {\n-        self.root\n-    }\n-\n     pub fn children(&self, node: Node) -> &[Node] {\n         &self.children[node]\n     }\n-\n-    pub fn iter_children_of(&self, node: Node) -> IterChildrenOf<Node> {\n-        IterChildrenOf {\n-            tree: self,\n-            stack: vec![node],\n-        }\n-    }\n-}\n-\n-pub struct IterChildrenOf<'iter, Node: Idx + 'iter> {\n-    tree: &'iter DominatorTree<Node>,\n-    stack: Vec<Node>,\n-}\n-\n-impl<'iter, Node: Idx> Iterator for IterChildrenOf<'iter, Node> {\n-    type Item = Node;\n-\n-    fn next(&mut self) -> Option<Node> {\n-        if let Some(node) = self.stack.pop() {\n-            self.stack.extend(self.tree.children(node));\n-            Some(node)\n-        } else {\n-            None\n-        }\n-    }\n }\n \n impl<Node: Idx> fmt::Debug for DominatorTree<Node> {"}, {"sha": "2d70b4063426d6f983707cc6e2a4cc092b5f7888", "filename": "src/librustc_data_structures/control_flow_graph/iterate/mod.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -47,22 +47,6 @@ fn post_order_walk<G: ControlFlowGraph>(graph: &G,\n     result.push(node);\n }\n \n-pub fn pre_order_walk<G: ControlFlowGraph>(graph: &G,\n-                                           node: G::Node,\n-                                           result: &mut Vec<G::Node>,\n-                                           visited: &mut IndexVec<G::Node, bool>) {\n-    if visited[node] {\n-        return;\n-    }\n-    visited[node] = true;\n-\n-    result.push(node);\n-\n-    for successor in graph.successors(node) {\n-        pre_order_walk(graph, successor, result, visited);\n-    }\n-}\n-\n pub fn reverse_post_order<G: ControlFlowGraph>(graph: &G, start_node: G::Node) -> Vec<G::Node> {\n     let mut vec = post_order_from(graph, start_node);\n     vec.reverse();"}, {"sha": "100881ddfdd7706f25fc75a11af4fedcc5d09d4b", "filename": "src/librustc_data_structures/control_flow_graph/iterate/test.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fiterate%2Ftest.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use super::super::test::TestGraph;\n-use super::super::transpose::TransposedGraph;\n \n use super::*;\n \n@@ -20,22 +19,3 @@ fn diamond_post_order() {\n     let result = post_order_from(&graph, 0);\n     assert_eq!(result, vec![3, 1, 2, 0]);\n }\n-\n-\n-#[test]\n-fn rev_post_order_inner_loop() {\n-    // 0 -> 1 ->     2     -> 3 -> 5\n-    //      ^     ^    v      |\n-    //      |     6 <- 4      |\n-    //      +-----------------+\n-    let graph = TestGraph::new(0,\n-                               &[(0, 1), (1, 2), (2, 3), (3, 5), (3, 1), (2, 4), (4, 6), (6, 2)]);\n-\n-    let rev_graph = TransposedGraph::new(&graph);\n-\n-    let result = post_order_from_to(&rev_graph, 6, Some(2));\n-    assert_eq!(result, vec![4, 6]);\n-\n-    let result = post_order_from_to(&rev_graph, 3, Some(1));\n-    assert_eq!(result, vec![4, 6, 2, 3]);\n-}"}, {"sha": "7bf776675c6a0ad4f3482538b8457798e03a22d6", "filename": "src/librustc_data_structures/control_flow_graph/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -9,13 +9,10 @@\n // except according to those terms.\n \n use super::indexed_vec::Idx;\n-pub use std::slice::Iter;\n \n pub mod dominators;\n pub mod iterate;\n-pub mod reachable;\n mod reference;\n-pub mod transpose;\n \n #[cfg(test)]\n mod test;"}, {"sha": "24210ebb95d3d14f97724a1cf197014ee9c43244", "filename": "src/librustc_data_structures/control_flow_graph/reachable/mod.rs", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bf3ebcc98788d805f96b171362d272c93e0a50a0/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf3ebcc98788d805f96b171362d272c93e0a50a0/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Fmod.rs?ref=bf3ebcc98788d805f96b171362d272c93e0a50a0", "patch": "@@ -1,62 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Compute reachability using a simple dataflow propagation.\n-//! Store end-result in a big NxN bit matrix.\n-\n-use super::ControlFlowGraph;\n-use super::super::bitvec::BitVector;\n-use super::iterate::reverse_post_order;\n-use super::super::indexed_vec::{IndexVec, Idx};\n-\n-#[cfg(test)]\n-mod test;\n-\n-pub fn reachable<G: ControlFlowGraph>(graph: &G) -> Reachability<G::Node> {\n-    let reverse_post_order = reverse_post_order(graph, graph.start_node());\n-    reachable_given_rpo(graph, &reverse_post_order)\n-}\n-\n-pub fn reachable_given_rpo<G: ControlFlowGraph>(graph: &G,\n-                                                reverse_post_order: &[G::Node])\n-                                                -> Reachability<G::Node> {\n-    let mut reachability = Reachability::new(graph);\n-    let mut changed = true;\n-    while changed {\n-        changed = false;\n-        for &node in reverse_post_order.iter().rev() {\n-            // every node can reach itself\n-            changed |= reachability.bits[node].insert(node.index());\n-\n-            // and every pred can reach everything node can reach\n-            for pred in graph.predecessors(node) {\n-                let nodes_bits = reachability.bits[node].clone();\n-                changed |= reachability.bits[pred].insert_all(&nodes_bits);\n-            }\n-        }\n-    }\n-    reachability\n-}\n-\n-pub struct Reachability<Node: Idx> {\n-    bits: IndexVec<Node, BitVector>,\n-}\n-\n-impl<Node: Idx> Reachability<Node> {\n-    fn new<G: ControlFlowGraph>(graph: &G) -> Self {\n-        let num_nodes = graph.num_nodes();\n-        Reachability { bits: IndexVec::from_elem_n(BitVector::new(num_nodes), num_nodes) }\n-    }\n-\n-    pub fn can_reach(&self, source: Node, target: Node) -> bool {\n-        let bit: usize = target.index();\n-        self.bits[source].contains(bit)\n-    }\n-}"}, {"sha": "ef45deeaafc78f30268c29af743f4509de58125a", "filename": "src/librustc_data_structures/control_flow_graph/reachable/test.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bf3ebcc98788d805f96b171362d272c93e0a50a0/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf3ebcc98788d805f96b171362d272c93e0a50a0/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Freachable%2Ftest.rs?ref=bf3ebcc98788d805f96b171362d272c93e0a50a0", "patch": "@@ -1,50 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use super::super::test::TestGraph;\n-\n-use super::*;\n-\n-#[test]\n-fn test1() {\n-    // 0 -> 1 -> 2 -> 3\n-    //      ^    v\n-    //      6 <- 4 -> 5\n-    let graph = TestGraph::new(0, &[(0, 1), (1, 2), (2, 3), (2, 4), (4, 5), (4, 6), (6, 1)]);\n-    let reachable = reachable(&graph);\n-    assert!((0..6).all(|i| reachable.can_reach(0, i)));\n-    assert!((1..6).all(|i| reachable.can_reach(1, i)));\n-    assert!((1..6).all(|i| reachable.can_reach(2, i)));\n-    assert!((1..6).all(|i| reachable.can_reach(4, i)));\n-    assert!((1..6).all(|i| reachable.can_reach(6, i)));\n-    assert!(reachable.can_reach(3, 3));\n-    assert!(!reachable.can_reach(3, 5));\n-    assert!(!reachable.can_reach(5, 3));\n-}\n-\n-/// use bigger indices to cross between words in the bit set\n-#[test]\n-fn test2() {\n-    // 30 -> 31 -> 32 -> 33\n-    //       ^      v\n-    //       36 <- 34 -> 35\n-    let graph = TestGraph::new(30,\n-                               &[(30, 31), (31, 32), (32, 33), (32, 34), (34, 35), (34, 36),\n-                                 (36, 31)]);\n-    let reachable = reachable(&graph);\n-    assert!((30..36).all(|i| reachable.can_reach(30, i)));\n-    assert!((31..36).all(|i| reachable.can_reach(31, i)));\n-    assert!((31..36).all(|i| reachable.can_reach(32, i)));\n-    assert!((31..36).all(|i| reachable.can_reach(34, i)));\n-    assert!((31..36).all(|i| reachable.can_reach(36, i)));\n-    assert!(reachable.can_reach(33, 33));\n-    assert!(!reachable.can_reach(33, 35));\n-    assert!(!reachable.can_reach(35, 33));\n-}"}, {"sha": "163d65c089c33c1ff698b736c44969b06d71302f", "filename": "src/librustc_data_structures/control_flow_graph/transpose.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/bf3ebcc98788d805f96b171362d272c93e0a50a0/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf3ebcc98788d805f96b171362d272c93e0a50a0/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fcontrol_flow_graph%2Ftranspose.rs?ref=bf3ebcc98788d805f96b171362d272c93e0a50a0", "patch": "@@ -1,64 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use super::*;\n-\n-pub struct TransposedGraph<G: ControlFlowGraph> {\n-    base_graph: G,\n-    start_node: G::Node,\n-}\n-\n-impl<G: ControlFlowGraph> TransposedGraph<G> {\n-    pub fn new(base_graph: G) -> Self {\n-        let start_node = base_graph.start_node();\n-        Self::with_start(base_graph, start_node)\n-    }\n-\n-    pub fn with_start(base_graph: G, start_node: G::Node) -> Self {\n-        TransposedGraph {\n-            base_graph,\n-            start_node,\n-        }\n-    }\n-}\n-\n-impl<G: ControlFlowGraph> ControlFlowGraph for TransposedGraph<G> {\n-    type Node = G::Node;\n-\n-    fn num_nodes(&self) -> usize {\n-        self.base_graph.num_nodes()\n-    }\n-\n-    fn start_node(&self) -> Self::Node {\n-        self.start_node\n-    }\n-\n-    fn predecessors<'graph>(&'graph self,\n-                            node: Self::Node)\n-                            -> <Self as GraphPredecessors<'graph>>::Iter {\n-        self.base_graph.successors(node)\n-    }\n-\n-    fn successors<'graph>(&'graph self,\n-                          node: Self::Node)\n-                          -> <Self as GraphSuccessors<'graph>>::Iter {\n-        self.base_graph.predecessors(node)\n-    }\n-}\n-\n-impl<'graph, G: ControlFlowGraph> GraphPredecessors<'graph> for TransposedGraph<G> {\n-    type Item = G::Node;\n-    type Iter = <G as GraphSuccessors<'graph>>::Iter;\n-}\n-\n-impl<'graph, G: ControlFlowGraph> GraphSuccessors<'graph> for TransposedGraph<G> {\n-    type Item = G::Node;\n-    type Iter = <G as GraphPredecessors<'graph>>::Iter;\n-}"}, {"sha": "50fd1d802b7ffe8e44ee6b8b148fb9d35f638e1c", "filename": "src/librustc_data_structures/fmt_wrap.rs", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bf3ebcc98788d805f96b171362d272c93e0a50a0/src%2Flibrustc_data_structures%2Ffmt_wrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf3ebcc98788d805f96b171362d272c93e0a50a0/src%2Flibrustc_data_structures%2Ffmt_wrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffmt_wrap.rs?ref=bf3ebcc98788d805f96b171362d272c93e0a50a0", "patch": "@@ -1,31 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::fmt;\n-\n-// Provide some more formatting options for some data types (at the moment\n-// that's just `{:x}` for slices of u8).\n-\n-pub struct FmtWrap<T>(pub T);\n-\n-impl<'a> fmt::LowerHex for FmtWrap<&'a [u8]> {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n-        for byte in self.0.iter() {\n-            try!(write!(formatter, \"{:02x}\", byte));\n-        }\n-        Ok(())\n-    }\n-}\n-\n-#[test]\n-fn test_lower_hex() {\n-    let bytes: &[u8] = &[0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef];\n-    assert_eq!(\"0123456789abcdef\", &format!(\"{:x}\", FmtWrap(bytes)));\n-}"}, {"sha": "5bf25437763cc6162ff69d26a5df51e90b2a00e2", "filename": "src/librustc_data_structures/fx.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Ffx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Ffx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ffx.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -107,9 +107,3 @@ impl Hasher for FxHasher {\n         self.hash as u64\n     }\n }\n-\n-pub fn hash<T: Hash>(v: &T) -> u64 {\n-    let mut state = FxHasher::default();\n-    v.hash(&mut state);\n-    state.finish()\n-}"}, {"sha": "a5f83ce05f5e5108e84ce29a08ee7668cb18601f", "filename": "src/librustc_data_structures/graph/mod.rs", "status": "modified", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -106,13 +106,6 @@ impl NodeIndex {\n     }\n }\n \n-impl EdgeIndex {\n-    /// Returns unique id (unique with respect to the graph holding associated edge).\n-    pub fn edge_id(&self) -> usize {\n-        self.0\n-    }\n-}\n-\n impl<N: Debug, E: Debug> Graph<N, E> {\n     pub fn new() -> Graph<N, E> {\n         Graph {\n@@ -201,34 +194,10 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         return idx;\n     }\n \n-    pub fn mut_edge_data(&mut self, idx: EdgeIndex) -> &mut E {\n-        &mut self.edges[idx.0].data\n-    }\n-\n-    pub fn edge_data(&self, idx: EdgeIndex) -> &E {\n-        &self.edges[idx.0].data\n-    }\n-\n     pub fn edge(&self, idx: EdgeIndex) -> &Edge<E> {\n         &self.edges[idx.0]\n     }\n \n-    pub fn first_adjacent(&self, node: NodeIndex, dir: Direction) -> EdgeIndex {\n-        //! Accesses the index of the first edge adjacent to `node`.\n-        //! This is useful if you wish to modify the graph while walking\n-        //! the linked list of edges.\n-\n-        self.nodes[node.0].first_edge[dir.repr]\n-    }\n-\n-    pub fn next_adjacent(&self, edge: EdgeIndex, dir: Direction) -> EdgeIndex {\n-        //! Accesses the next edge in a given direction.\n-        //! This is useful if you wish to modify the graph while walking\n-        //! the linked list of edges.\n-\n-        self.edges[edge.0].next_edge[dir.repr]\n-    }\n-\n     // # Iterating over nodes, edges\n \n     pub fn enumerated_nodes(&self) -> EnumeratedNodes<N> {\n@@ -282,25 +251,6 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         self.incoming_edges(target).sources()\n     }\n \n-    /// A common use for graphs in our compiler is to perform\n-    /// fixed-point iteration. In this case, each edge represents a\n-    /// constraint, and the nodes themselves are associated with\n-    /// variables or other bitsets. This method facilitates such a\n-    /// computation.\n-    pub fn iterate_until_fixed_point<'a, F>(&'a self, mut op: F)\n-        where F: FnMut(usize, EdgeIndex, &'a Edge<E>) -> bool\n-    {\n-        let mut iteration = 0;\n-        let mut changed = true;\n-        while changed {\n-            changed = false;\n-            iteration += 1;\n-            for (edge_index, edge) in self.enumerated_edges() {\n-                changed |= op(iteration, edge_index, edge);\n-            }\n-        }\n-    }\n-\n     pub fn depth_traverse<'a>(&'a self,\n                               start: NodeIndex,\n                               direction: Direction)\n@@ -343,35 +293,6 @@ impl<N: Debug, E: Debug> Graph<N, E> {\n         assert_eq!(result.len(), self.len_nodes());\n         result\n     }\n-\n-    /// Whether or not a node can be reached from itself.\n-    pub fn is_node_cyclic(&self, starting_node_index: NodeIndex) -> bool {\n-        // This is similar to depth traversal below, but we\n-        // can't use that, because depth traversal doesn't show\n-        // the starting node a second time.\n-        let mut visited = BitVector::new(self.len_nodes());\n-        let mut stack = vec![starting_node_index];\n-\n-        while let Some(current_node_index) = stack.pop() {\n-            visited.insert(current_node_index.0);\n-\n-            // Directionality doesn't change the answer,\n-            // so just use outgoing edges.\n-            for (_, edge) in self.outgoing_edges(current_node_index) {\n-                let target_node_index = edge.target();\n-\n-                if target_node_index == starting_node_index {\n-                    return true;\n-                }\n-\n-                if !visited.contains(target_node_index.0) {\n-                    stack.push(target_node_index);\n-                }\n-            }\n-        }\n-\n-        false\n-    }\n }\n \n // # Iterators\n@@ -479,16 +400,6 @@ pub struct DepthFirstTraversal<'g, N, E>\n }\n \n impl<'g, N: Debug, E: Debug> DepthFirstTraversal<'g, N, E> {\n-    pub fn new(graph: &'g Graph<N, E>, direction: Direction) -> Self {\n-        let visited = BitVector::new(graph.len_nodes());\n-        DepthFirstTraversal {\n-            graph,\n-            stack: vec![],\n-            visited,\n-            direction,\n-        }\n-    }\n-\n     pub fn with_start_node(graph: &'g Graph<N, E>,\n                            start_node: NodeIndex,\n                            direction: Direction)\n@@ -503,13 +414,6 @@ impl<'g, N: Debug, E: Debug> DepthFirstTraversal<'g, N, E> {\n         }\n     }\n \n-    pub fn reset(&mut self, start_node: NodeIndex) {\n-        self.stack.truncate(0);\n-        self.stack.push(start_node);\n-        self.visited.clear();\n-        self.visited.insert(start_node.node_id());\n-    }\n-\n     fn visit(&mut self, node: NodeIndex) {\n         if self.visited.insert(node.node_id()) {\n             self.stack.push(node);\n@@ -532,19 +436,6 @@ impl<'g, N: Debug, E: Debug> Iterator for DepthFirstTraversal<'g, N, E> {\n     }\n }\n \n-pub fn each_edge_index<F>(max_edge_index: EdgeIndex, mut f: F)\n-    where F: FnMut(EdgeIndex) -> bool\n-{\n-    let mut i = 0;\n-    let n = max_edge_index.0;\n-    while i < n {\n-        if !f(EdgeIndex(i)) {\n-            return;\n-        }\n-        i += 1;\n-    }\n-}\n-\n impl<E> Edge<E> {\n     pub fn source(&self) -> NodeIndex {\n         self.source"}, {"sha": "007704357af4fa8c1d6ec4452091f8f53d0bc155", "filename": "src/librustc_data_structures/graph/tests.rs", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Ftests.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -43,29 +43,6 @@ fn create_graph() -> TestGraph {\n     return graph;\n }\n \n-fn create_graph_with_cycle() -> TestGraph {\n-    let mut graph = Graph::new();\n-\n-    // Create a graph with a cycle.\n-    //\n-    //    A --> B <-- +\n-    //          |     |\n-    //          v     |\n-    //          C --> D\n-\n-    let a = graph.add_node(\"A\");\n-    let b = graph.add_node(\"B\");\n-    let c = graph.add_node(\"C\");\n-    let d = graph.add_node(\"D\");\n-\n-    graph.add_edge(a, b, \"AB\");\n-    graph.add_edge(b, c, \"BC\");\n-    graph.add_edge(c, d, \"CD\");\n-    graph.add_edge(d, b, \"DB\");\n-\n-    return graph;\n-}\n-\n #[test]\n fn each_node() {\n     let graph = create_graph();\n@@ -82,7 +59,6 @@ fn each_edge() {\n     let graph = create_graph();\n     let expected = [\"AB\", \"BC\", \"BD\", \"DE\", \"EC\", \"FB\"];\n     graph.each_edge(|idx, edge| {\n-        assert_eq!(&expected[idx.0], graph.edge_data(idx));\n         assert_eq!(expected[idx.0], edge.data);\n         true\n     });\n@@ -97,7 +73,6 @@ fn test_adjacent_edges<N: PartialEq + Debug, E: PartialEq + Debug>(graph: &Graph\n \n     let mut counter = 0;\n     for (edge_index, edge) in graph.incoming_edges(start_index) {\n-        assert!(graph.edge_data(edge_index) == &edge.data);\n         assert!(counter < expected_incoming.len());\n         debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                counter,\n@@ -117,7 +92,6 @@ fn test_adjacent_edges<N: PartialEq + Debug, E: PartialEq + Debug>(graph: &Graph\n \n     let mut counter = 0;\n     for (edge_index, edge) in graph.outgoing_edges(start_index) {\n-        assert!(graph.edge_data(edge_index) == &edge.data);\n         assert!(counter < expected_outgoing.len());\n         debug!(\"counter={:?} expected={:?} edge_index={:?} edge={:?}\",\n                counter,\n@@ -163,58 +137,3 @@ fn each_adjacent_from_d() {\n     let graph = create_graph();\n     test_adjacent_edges(&graph, NodeIndex(3), \"D\", &[(\"BD\", \"B\")], &[(\"DE\", \"E\")]);\n }\n-\n-#[test]\n-fn is_node_cyclic_a() {\n-    let graph = create_graph_with_cycle();\n-    assert!(!graph.is_node_cyclic(NodeIndex(0)));\n-}\n-\n-#[test]\n-fn is_node_cyclic_b() {\n-    let graph = create_graph_with_cycle();\n-    assert!(graph.is_node_cyclic(NodeIndex(1)));\n-}\n-\n-#[test]\n-fn nodes_in_postorder() {\n-    let expected = vec![\n-        (\"A\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"B\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"C\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"D\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"E\", vec![\"C\", \"E\", \"D\", \"B\", \"A\", \"F\"]),\n-        (\"F\", vec![\"C\", \"E\", \"D\", \"B\", \"F\", \"A\"])\n-    ];\n-\n-    let graph = create_graph();\n-\n-    for ((idx, node), &(node_name, ref expected))\n-        in graph.enumerated_nodes().zip(&expected)\n-    {\n-        assert_eq!(node.data, node_name);\n-        assert_eq!(expected,\n-                   &graph.nodes_in_postorder(OUTGOING, idx)\n-                   .into_iter().map(|idx| *graph.node_data(idx))\n-                   .collect::<Vec<&str>>());\n-    }\n-\n-    let expected = vec![\n-        (\"A\", vec![\"D\", \"C\", \"B\", \"A\"]),\n-        (\"B\", vec![\"D\", \"C\", \"B\", \"A\"]),\n-        (\"C\", vec![\"B\", \"D\", \"C\", \"A\"]),\n-        (\"D\", vec![\"C\", \"B\", \"D\", \"A\"]),\n-    ];\n-\n-    let graph = create_graph_with_cycle();\n-\n-    for ((idx, node), &(node_name, ref expected))\n-        in graph.enumerated_nodes().zip(&expected)\n-    {\n-        assert_eq!(node.data, node_name);\n-        assert_eq!(expected,\n-                   &graph.nodes_in_postorder(OUTGOING, idx)\n-                   .into_iter().map(|idx| *graph.node_data(idx))\n-                   .collect::<Vec<&str>>());\n-    }\n-}"}, {"sha": "de44509ef2fd81c17b0543acf39d2af91cdfa620", "filename": "src/librustc_data_structures/ivar.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/bf3ebcc98788d805f96b171362d272c93e0a50a0/src%2Flibrustc_data_structures%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf3ebcc98788d805f96b171362d272c93e0a50a0/src%2Flibrustc_data_structures%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fivar.rs?ref=bf3ebcc98788d805f96b171362d272c93e0a50a0", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::fmt;\n-use std::cell::Cell;\n-\n-/// A write-once variable. When constructed, it is empty, and\n-/// can only be set once.\n-///\n-/// Ivars ensure that data that can only be initialized once. A full\n-/// implementation is used for concurrency and blocks on a read of an\n-/// unfulfilled value. This implementation is more minimal and panics\n-/// if you attempt to read the value before it has been set. It is also\n-/// not `Sync`, but may be extended in the future to be usable as a true\n-/// concurrency type.\n-///\n-/// The `T: Copy` bound is not strictly needed, but it is required by\n-/// Cell (so removing it would require using UnsafeCell), and it\n-/// suffices for the current purposes.\n-#[derive(PartialEq)]\n-pub struct Ivar<T: Copy> {\n-    data: Cell<Option<T>>,\n-}\n-\n-impl<T: Copy> Ivar<T> {\n-    pub fn new() -> Ivar<T> {\n-        Ivar { data: Cell::new(None) }\n-    }\n-\n-    pub fn get(&self) -> Option<T> {\n-        self.data.get()\n-    }\n-\n-    pub fn fulfill(&self, value: T) {\n-        assert!(self.data.get().is_none(), \"Value already set!\");\n-        self.data.set(Some(value));\n-    }\n-\n-    pub fn is_fulfilled(&self) -> bool {\n-        self.data.get().is_some()\n-    }\n-\n-    pub fn unwrap(&self) -> T {\n-        self.get().unwrap()\n-    }\n-}\n-\n-impl<T: Copy + fmt::Debug> fmt::Debug for Ivar<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.get() {\n-            Some(val) => write!(f, \"Ivar({:?})\", val),\n-            None => f.write_str(\"Ivar(<unfulfilled>)\"),\n-        }\n-    }\n-}\n-\n-impl<T: Copy> Clone for Ivar<T> {\n-    fn clone(&self) -> Ivar<T> {\n-        match self.get() {\n-            Some(val) => Ivar { data: Cell::new(Some(val)) },\n-            None => Ivar::new(),\n-        }\n-    }\n-}"}, {"sha": "54eed6dc92a77442c388fc1651aa812076311020", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -52,11 +52,9 @@ pub mod accumulate_vec;\n pub mod small_vec;\n pub mod base_n;\n pub mod bitslice;\n-pub mod blake2b;\n pub mod bitvec;\n-pub mod fmt_wrap;\n+pub mod blake2b;\n pub mod graph;\n-pub mod ivar;\n pub mod indexed_set;\n pub mod indexed_vec;\n pub mod obligation_forest;"}, {"sha": "02cae52166ac3a4a009a48e72b2a4f586defa8d4", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -57,11 +57,6 @@ pub trait ObligationProcessor {\n         where I: Clone + Iterator<Item=&'c Self::Obligation>;\n }\n \n-struct SnapshotData {\n-    node_len: usize,\n-    cache_list_len: usize,\n-}\n-\n pub struct ObligationForest<O: ForestObligation> {\n     /// The list of obligations. In between calls to\n     /// `process_obligations`, this list only contains nodes in the\n@@ -83,14 +78,9 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// A list of the obligations added in snapshots, to allow\n     /// for their removal.\n     cache_list: Vec<O::Predicate>,\n-    snapshots: Vec<SnapshotData>,\n     scratch: Option<Vec<usize>>,\n }\n \n-pub struct Snapshot {\n-    len: usize,\n-}\n-\n #[derive(Debug)]\n struct Node<O> {\n     obligation: O,\n@@ -166,7 +156,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n     pub fn new() -> ObligationForest<O> {\n         ObligationForest {\n             nodes: vec![],\n-            snapshots: vec![],\n             done_cache: FxHashSet(),\n             waiting_cache: FxHashMap(),\n             cache_list: vec![],\n@@ -180,39 +169,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.nodes.len()\n     }\n \n-    pub fn start_snapshot(&mut self) -> Snapshot {\n-        self.snapshots.push(SnapshotData {\n-            node_len: self.nodes.len(),\n-            cache_list_len: self.cache_list.len()\n-        });\n-        Snapshot { len: self.snapshots.len() }\n-    }\n-\n-    pub fn commit_snapshot(&mut self, snapshot: Snapshot) {\n-        assert_eq!(snapshot.len, self.snapshots.len());\n-        let info = self.snapshots.pop().unwrap();\n-        assert!(self.nodes.len() >= info.node_len);\n-        assert!(self.cache_list.len() >= info.cache_list_len);\n-    }\n-\n-    pub fn rollback_snapshot(&mut self, snapshot: Snapshot) {\n-        // Check that we are obeying stack discipline.\n-        assert_eq!(snapshot.len, self.snapshots.len());\n-        let info = self.snapshots.pop().unwrap();\n-\n-        for entry in &self.cache_list[info.cache_list_len..] {\n-            self.done_cache.remove(entry);\n-            self.waiting_cache.remove(entry);\n-        }\n-\n-        self.nodes.truncate(info.node_len);\n-        self.cache_list.truncate(info.cache_list_len);\n-    }\n-\n-    pub fn in_snapshot(&self) -> bool {\n-        !self.snapshots.is_empty()\n-    }\n-\n     /// Registers an obligation\n     ///\n     /// This CAN be done in a snapshot\n@@ -262,7 +218,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n     ///\n     /// This cannot be done during a snapshot.\n     pub fn to_errors<E: Clone>(&mut self, error: E) -> Vec<Error<O, E>> {\n-        assert!(!self.in_snapshot());\n         let mut errors = vec![];\n         for index in 0..self.nodes.len() {\n             if let NodeState::Pending = self.nodes[index].state.get() {\n@@ -297,7 +252,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n         where P: ObligationProcessor<Obligation=O>\n     {\n         debug!(\"process_obligations(len={})\", self.nodes.len());\n-        assert!(!self.in_snapshot()); // cannot unroll this action\n \n         let mut errors = vec![];\n         let mut stalled = true;\n@@ -528,8 +482,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// on these nodes may be present. This is done by e.g. `process_cycles`.\n     #[inline(never)]\n     fn compress(&mut self) -> Vec<O> {\n-        assert!(!self.in_snapshot()); // didn't write code to unroll this action\n-\n         let nodes_len = self.nodes.len();\n         let mut node_rewrites: Vec<_> = self.scratch.take().unwrap();\n         node_rewrites.extend(0..nodes_len);"}, {"sha": "7853bf9478ab8157e9a99ea679349ea171114751", "filename": "src/librustc_data_structures/unify/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_data_structures%2Funify%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Funify%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -275,7 +275,8 @@ impl<'tcx, K: UnifyKey> UnificationTable<K>\n         self.get(id).value\n     }\n \n-    pub fn unioned(&mut self, a_id: K, b_id: K) -> bool {\n+    #[cfg(test)]\n+    fn unioned(&mut self, a_id: K, b_id: K) -> bool {\n         self.find(a_id) == self.find(b_id)\n     }\n }"}, {"sha": "64f61b65323c05b4f325a14d1e9eeaf502fd0ecc", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -102,7 +102,7 @@ use syntax::parse::{self, PResult};\n use syntax_pos::{DUMMY_SP, MultiSpan};\n \n #[cfg(test)]\n-pub mod test;\n+mod test;\n \n pub mod driver;\n pub mod pretty;\n@@ -859,17 +859,17 @@ impl RustcDefaultCalls {\n }\n \n /// Returns a version string such as \"0.12.0-dev\".\n-pub fn release_str() -> Option<&'static str> {\n+fn release_str() -> Option<&'static str> {\n     option_env!(\"CFG_RELEASE\")\n }\n \n /// Returns the full SHA1 hash of HEAD of the Git repo from which rustc was built.\n-pub fn commit_hash_str() -> Option<&'static str> {\n+fn commit_hash_str() -> Option<&'static str> {\n     option_env!(\"CFG_VER_HASH\")\n }\n \n /// Returns the \"commit date\" of HEAD of the Git repo from which rustc was built as a static string.\n-pub fn commit_date_str() -> Option<&'static str> {\n+fn commit_date_str() -> Option<&'static str> {\n     option_env!(\"CFG_VER_DATE\")\n }\n "}, {"sha": "0f063542383dce0eeaf9f9ed152b8e9b6b51b131", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -105,10 +105,6 @@ impl Diagnostic {\n         self.level == Level::Cancelled\n     }\n \n-    pub fn is_fatal(&self) -> bool {\n-        self.level == Level::Fatal\n-    }\n-\n     /// Add a span/label to be included in the resulting snippet.\n     /// This is pushed onto the `MultiSpan` that was created when the\n     /// diagnostic was first built. If you don't call this function at\n@@ -278,18 +274,10 @@ impl Diagnostic {\n         self.message.iter().map(|i| i.0.to_owned()).collect::<String>()\n     }\n \n-    pub fn set_message(&mut self, message: &str) {\n-        self.message = vec![(message.to_owned(), Style::NoStyle)];\n-    }\n-\n     pub fn styled_message(&self) -> &Vec<(String, Style)> {\n         &self.message\n     }\n \n-    pub fn level(&self) -> Level {\n-        self.level\n-    }\n-\n     /// Used by a lint. Copies over all details *but* the \"main\n     /// message\".\n     pub fn copy_details_not_message(&mut self, from: &Diagnostic) {"}, {"sha": "8d7ce4eb4f6d31edc81f9124a2efc39e75ce3da8", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -183,13 +183,6 @@ impl<'a> DiagnosticBuilder<'a> {\n             diagnostic: Diagnostic::new_with_code(level, code, message)\n         }\n     }\n-\n-    pub fn into_diagnostic(mut self) -> Diagnostic {\n-        // annoyingly, the Drop impl means we can't actually move\n-        let result = self.diagnostic.clone();\n-        self.cancel();\n-        result\n-    }\n }\n \n impl<'a> Debug for DiagnosticBuilder<'a> {"}, {"sha": "12b5ccf483762d6e1f9b76c5ec96d59243b365b5", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -38,8 +38,8 @@ use std::cell::{RefCell, Cell};\n use std::{error, fmt};\n use std::rc::Rc;\n \n-pub mod diagnostic;\n-pub mod diagnostic_builder;\n+mod diagnostic;\n+mod diagnostic_builder;\n pub mod emitter;\n mod snippet;\n pub mod registry;\n@@ -111,7 +111,7 @@ impl CodeSuggestion {\n     }\n \n     /// Returns the number of substitutions\n-    pub fn substitution_spans<'a>(&'a self) -> impl Iterator<Item = Span> + 'a {\n+    fn substitution_spans<'a>(&'a self) -> impl Iterator<Item = Span> + 'a {\n         self.substitution_parts.iter().map(|sub| sub.span)\n     }\n \n@@ -217,8 +217,10 @@ impl CodeSuggestion {\n             if !buf.ends_with('\\n') {\n                 push_trailing(buf, prev_line.as_ref(), &prev_hi, None);\n             }\n-            // remove trailing newline\n-            buf.pop();\n+            // remove trailing newlines\n+            while buf.ends_with('\\n') {\n+                buf.pop();\n+            }\n         }\n         bufs\n     }\n@@ -260,7 +262,7 @@ impl error::Error for ExplicitBug {\n     }\n }\n \n-pub use diagnostic::{Diagnostic, SubDiagnostic, DiagnosticStyledString, StringPart};\n+pub use diagnostic::{Diagnostic, SubDiagnostic, DiagnosticStyledString};\n pub use diagnostic_builder::DiagnosticBuilder;\n \n /// A handler deals with errors; certain errors\n@@ -489,7 +491,7 @@ impl Handler {\n         self.bug(&format!(\"unimplemented {}\", msg));\n     }\n \n-    pub fn bump_err_count(&self) {\n+    fn bump_err_count(&self) {\n         self.panic_if_treat_err_as_bug();\n         self.err_count.set(self.err_count.get() + 1);\n     }\n@@ -569,7 +571,7 @@ impl fmt::Display for Level {\n }\n \n impl Level {\n-    pub fn color(self) -> term::color::Color {\n+    fn color(self) -> term::color::Color {\n         match self {\n             Bug | Fatal | PhaseFatal | Error => term::color::BRIGHT_RED,\n             Warning => {\n@@ -596,12 +598,3 @@ impl Level {\n         }\n     }\n }\n-\n-pub fn expect<T, M>(diag: &Handler, opt: Option<T>, msg: M) -> T\n-    where M: FnOnce() -> String\n-{\n-    match opt {\n-        Some(t) => t,\n-        None => diag.bug(&msg()),\n-    }\n-}"}, {"sha": "94400890c56411449c999af58b676de2046b6846", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -62,10 +62,6 @@ impl IncrementalHashesMap {\n         }\n     }\n \n-    pub fn get(&self, k: &DepNode) -> Option<&Fingerprint> {\n-        self.hashes.get(k)\n-    }\n-\n     pub fn insert(&mut self, k: DepNode, v: Fingerprint) {\n         assert!(self.hashes.insert(k, v).is_none());\n     }"}, {"sha": "c68153140d97ce171a5404a75b857c8bc599422d", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -44,4 +44,3 @@ pub use persist::save_trans_partition;\n pub use persist::save_work_products;\n pub use persist::in_incr_comp_dir;\n pub use persist::finalize_session_directory;\n-pub use persist::delete_workproduct_files;"}, {"sha": "5c1582daa78fa07119caa53219831e699ed60e88", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -28,4 +28,3 @@ pub use self::load::load_dep_graph;\n pub use self::save::save_dep_graph;\n pub use self::save::save_work_products;\n pub use self::work_product::save_trans_partition;\n-pub use self::work_product::delete_workproduct_files;"}, {"sha": "755370b64659dfee03f2c4d1b3915211a9a5f189", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -45,10 +45,10 @@ extern crate rustc_back;\n extern crate rustc_const_eval;\n extern crate syntax_pos;\n \n-pub use rustc::lint;\n-pub use rustc::middle;\n-pub use rustc::session;\n-pub use rustc::util;\n+use rustc::lint;\n+use rustc::middle;\n+use rustc::session;\n+use rustc::util;\n \n use session::Session;\n use lint::LintId;"}, {"sha": "5f12f561faf45086eeb2572ae03b174252952e6a", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -38,9 +38,7 @@ pub use self::TypeKind::*;\n pub use self::AtomicRmwBinOp::*;\n pub use self::MetadataType::*;\n pub use self::CodeGenOptSize::*;\n-pub use self::DiagnosticKind::*;\n pub use self::CallConv::*;\n-pub use self::DiagnosticSeverity::*;\n pub use self::Linkage::*;\n \n use std::str::FromStr;\n@@ -51,7 +49,7 @@ use libc::{c_uint, c_char, size_t};\n \n pub mod archive_ro;\n pub mod diagnostic;\n-pub mod ffi;\n+mod ffi;\n \n pub use ffi::*;\n \n@@ -120,7 +118,7 @@ impl FromStr for ArchiveKind {\n \n #[allow(missing_copy_implementations)]\n pub enum RustString_opaque {}\n-pub type RustStringRef = *mut RustString_opaque;\n+type RustStringRef = *mut RustString_opaque;\n type RustStringRepr = *mut RefCell<Vec<u8>>;\n \n /// Appending to a Rust string -- used by RawRustStringOstream.\n@@ -199,8 +197,8 @@ impl Attribute {\n \n // Memory-managed interface to target data.\n \n-pub struct TargetData {\n-    pub lltd: TargetDataRef,\n+struct TargetData {\n+    lltd: TargetDataRef,\n }\n \n impl Drop for TargetData {\n@@ -211,7 +209,7 @@ impl Drop for TargetData {\n     }\n }\n \n-pub fn mk_target_data(string_rep: &str) -> TargetData {\n+fn mk_target_data(string_rep: &str) -> TargetData {\n     let string_rep = CString::new(string_rep).unwrap();\n     TargetData { lltd: unsafe { LLVMCreateTargetData(string_rep.as_ptr()) } }\n }\n@@ -272,7 +270,7 @@ pub fn get_param(llfn: ValueRef, index: c_uint) -> ValueRef {\n     }\n }\n \n-pub fn get_params(llfn: ValueRef) -> Vec<ValueRef> {\n+fn get_params(llfn: ValueRef) -> Vec<ValueRef> {\n     unsafe {\n         let num_params = LLVMCountParams(llfn);\n         let mut params = Vec::with_capacity(num_params as usize);"}, {"sha": "0ed8ab2bc55968f50abb8f0a24bebb210614391e", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -32,7 +32,7 @@ use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibrary, NativeLibraryKind, LinkagePreference};\n pub use rustc::middle::cstore::NativeLibraryKind::*;\n-pub use rustc::middle::cstore::{CrateSource, LinkMeta, LibSource};\n+pub use rustc::middle::cstore::{CrateSource, LibSource};\n \n pub use cstore_impl::{provide, provide_local};\n \n@@ -142,14 +142,6 @@ impl CStore {\n         }\n     }\n \n-    pub fn reset(&self) {\n-        self.metas.borrow_mut().clear();\n-        self.extern_mod_crate_map.borrow_mut().clear();\n-        self.used_libraries.borrow_mut().clear();\n-        self.used_link_args.borrow_mut().clear();\n-        self.statically_included_foreign_items.borrow_mut().clear();\n-    }\n-\n     pub fn crate_dependencies_in_rpo(&self, krate: CrateNum) -> Vec<CrateNum> {\n         let mut ordering = Vec::new();\n         self.push_dependencies_in_postorder(&mut ordering, krate);"}, {"sha": "69fbc9354610d9aabc1d94334069ab86e5249abe", "filename": "src/librustc_metadata/index.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_metadata%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_metadata%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -100,32 +100,6 @@ impl<'tcx> LazySeq<Index> {\n             Some(Lazy::with_position(position as usize))\n         }\n     }\n-\n-    pub fn iter_enumerated<'a>(&self,\n-                               bytes: &'a [u8])\n-                               -> impl Iterator<Item = (DefIndex, Lazy<Entry<'tcx>>)> + 'a {\n-        let words = &bytes_to_words(&bytes[self.position..])[..self.len];\n-        let lo_count = u32::from_le(words[0].get()) as usize;\n-        let lo = &words[1 .. lo_count + 1];\n-        let hi = &words[1 + lo_count ..];\n-\n-        lo.iter().map(|word| word.get()).enumerate().filter_map(|(index, pos)| {\n-            if pos == u32::MAX {\n-                None\n-            } else {\n-                let pos = u32::from_le(pos) as usize;\n-                Some((DefIndex::new(index), Lazy::with_position(pos)))\n-            }\n-        }).chain(hi.iter().map(|word| word.get()).enumerate().filter_map(|(index, pos)| {\n-            if pos == u32::MAX {\n-                None\n-            } else {\n-                let pos = u32::from_le(pos) as usize;\n-                Some((DefIndex::new(index + DefIndexAddressSpace::High.start()),\n-                                    Lazy::with_position(pos)))\n-            }\n-        }))\n-    }\n }\n \n #[repr(packed)]"}, {"sha": "8fd87ae88a88450c7f0bc915a61ba85685f930b4", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -47,8 +47,6 @@ extern crate rustc_data_structures;\n \n mod diagnostics;\n \n-pub use rustc::middle;\n-\n mod astencode;\n mod index_builder;\n mod index;"}, {"sha": "19f7cb0ee238a72b82e501a0fb7b7462479e3989", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -306,10 +306,6 @@ impl<'a> Context<'a> {\n         self.find_library_crate()\n     }\n \n-    pub fn load_library_crate(&mut self) -> Library {\n-        self.find_library_crate().unwrap_or_else(|| self.report_errs())\n-    }\n-\n     pub fn report_errs(&mut self) -> ! {\n         let add = match self.root {\n             &None => String::new(),"}, {"sha": "a4421b216c311b4d50134c8e4885123d708216e7", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 160, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -14,16 +14,13 @@\n \n use rustc::ty::TyCtxt;\n use rustc::mir::{self, Mir, Location};\n-use rustc_data_structures::bitslice::BitSlice; // adds set_bit/get_bit to &[usize] bitvector rep.\n use rustc_data_structures::bitslice::{BitwiseOperator};\n use rustc_data_structures::indexed_set::{IdxSet};\n-use rustc_data_structures::indexed_vec::Idx;\n \n use super::MoveDataParamEnv;\n use util::elaborate_drops::DropFlagState;\n \n-use super::move_paths::{HasMoveData, MoveData, MoveOutIndex, MovePathIndex};\n-use super::move_paths::LookupResult;\n+use super::move_paths::{HasMoveData, MoveData, MovePathIndex};\n use super::{BitDenotation, BlockSets, DataflowOperator};\n \n use super::drop_flag_effects_for_function_entry;\n@@ -204,40 +201,6 @@ impl<'a, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedLvals<'a, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n-/// `MovingOutStatements` tracks the statements that perform moves out\n-/// of particular l-values. More precisely, it tracks whether the\n-/// *effect* of such moves (namely, the uninitialization of the\n-/// l-value in question) can reach some point in the control-flow of\n-/// the function, or if that effect is \"killed\" by some intervening\n-/// operation reinitializing that l-value.\n-///\n-/// The resulting dataflow is a more enriched version of\n-/// `MaybeUninitializedLvals`. Both structures on their own only tell\n-/// you if an l-value *might* be uninitialized at a given point in the\n-/// control flow. But `MovingOutStatements` also includes the added\n-/// data of *which* particular statement causing the deinitialization\n-/// that the borrow checker's error message may need to report.\n-#[allow(dead_code)]\n-pub struct MovingOutStatements<'a, 'tcx: 'a> {\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n-    mdpe: &'a MoveDataParamEnv<'tcx>,\n-}\n-\n-impl<'a, 'tcx: 'a> MovingOutStatements<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               mir: &'a Mir<'tcx>,\n-               mdpe: &'a MoveDataParamEnv<'tcx>)\n-               -> Self\n-    {\n-        MovingOutStatements { tcx: tcx, mir: mir, mdpe: mdpe }\n-    }\n-}\n-\n-impl<'a, 'tcx> HasMoveData<'tcx> for MovingOutStatements<'a, 'tcx> {\n-    fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n-}\n-\n impl<'a, 'tcx> MaybeInitializedLvals<'a, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n@@ -432,121 +395,6 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n-    type Idx = MoveOutIndex;\n-    fn name() -> &'static str { \"moving_out\" }\n-    fn bits_per_block(&self) -> usize {\n-        self.move_data().moves.len()\n-    }\n-\n-    fn start_block_effect(&self, _sets: &mut BlockSets<MoveOutIndex>) {\n-        // no move-statements have been executed prior to function\n-        // execution, so this method has no effect on `_sets`.\n-    }\n-    fn statement_effect(&self,\n-                        sets: &mut BlockSets<MoveOutIndex>,\n-                        location: Location) {\n-        let (tcx, mir, move_data) = (self.tcx, self.mir, self.move_data());\n-        let stmt = &mir[location.block].statements[location.statement_index];\n-        let loc_map = &move_data.loc_map;\n-        let path_map = &move_data.path_map;\n-        let rev_lookup = &move_data.rev_lookup;\n-\n-        debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n-               stmt, location, &loc_map[location]);\n-        for move_index in &loc_map[location] {\n-            // Every path deinitialized by a *particular move*\n-            // has corresponding bit, \"gen'ed\" (i.e. set)\n-            // here, in dataflow vector\n-            zero_to_one(sets.gen_set.words_mut(), *move_index);\n-        }\n-        let bits_per_block = self.bits_per_block();\n-        match stmt.kind {\n-            mir::StatementKind::SetDiscriminant { .. } => {\n-                span_bug!(stmt.source_info.span, \"SetDiscriminant should not exist in borrowck\");\n-            }\n-            mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                // assigning into this `lvalue` kills all\n-                // MoveOuts from it, and *also* all MoveOuts\n-                // for children and associated fragment sets.\n-                match rvalue.initialization_state() {\n-                    mir::tcx::RvalueInitializationState::Shallow => {\n-                        if let LookupResult::Exact(mpi) = rev_lookup.find(lvalue) {\n-                             for moi in &path_map[mpi] {\n-                                 assert!(moi.index() < bits_per_block);\n-                                 sets.kill_set.add(&moi);\n-                             }\n-                        }\n-                    }\n-                    mir::tcx::RvalueInitializationState::Deep => {\n-                        on_lookup_result_bits(tcx,\n-                                              mir,\n-                                              move_data,\n-                                              rev_lookup.find(lvalue),\n-                                              |mpi| for moi in &path_map[mpi] {\n-                                                  assert!(moi.index() < bits_per_block);\n-                                                  sets.kill_set.add(&moi);\n-                                              });\n-                    }\n-                }\n-            }\n-            mir::StatementKind::StorageLive(_) |\n-            mir::StatementKind::StorageDead(_) |\n-            mir::StatementKind::InlineAsm { .. } |\n-            mir::StatementKind::EndRegion(_) |\n-            mir::StatementKind::Validate(..) |\n-            mir::StatementKind::Nop => {}\n-        }\n-    }\n-\n-    fn terminator_effect(&self,\n-                         sets: &mut BlockSets<MoveOutIndex>,\n-                         location: Location)\n-    {\n-        let (mir, move_data) = (self.mir, self.move_data());\n-        let term = mir[location.block].terminator();\n-        let loc_map = &move_data.loc_map;\n-        debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n-               term, location, &loc_map[location]);\n-        let bits_per_block = self.bits_per_block();\n-        for move_index in &loc_map[location] {\n-            assert!(move_index.index() < bits_per_block);\n-            zero_to_one(sets.gen_set.words_mut(), *move_index);\n-        }\n-    }\n-\n-    fn propagate_call_return(&self,\n-                             in_out: &mut IdxSet<MoveOutIndex>,\n-                             _call_bb: mir::BasicBlock,\n-                             _dest_bb: mir::BasicBlock,\n-                             dest_lval: &mir::Lvalue) {\n-        let move_data = self.move_data();\n-        let bits_per_block = self.bits_per_block();\n-\n-        let path_map = &move_data.path_map;\n-        on_lookup_result_bits(self.tcx,\n-                              self.mir,\n-                              move_data,\n-                              move_data.rev_lookup.find(dest_lval),\n-                              |mpi| for moi in &path_map[mpi] {\n-                                  assert!(moi.index() < bits_per_block);\n-                                  in_out.remove(&moi);\n-                              });\n-    }\n-}\n-\n-fn zero_to_one(bitvec: &mut [usize], move_index: MoveOutIndex) {\n-    let retval = bitvec.set_bit(move_index.index());\n-    assert!(retval);\n-}\n-\n-impl<'a, 'tcx> BitwiseOperator for MovingOutStatements<'a, 'tcx> {\n-    #[inline]\n-    fn join(&self, pred1: usize, pred2: usize) -> usize {\n-        pred1 | pred2 // moves from both preds are in scope\n-    }\n-}\n-\n impl<'a, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n@@ -578,13 +426,6 @@ impl<'a, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'tcx> {\n // propagating, or you start at all-ones and then use Intersect as\n // your merge when propagating.\n \n-impl<'a, 'tcx> DataflowOperator for MovingOutStatements<'a, 'tcx> {\n-    #[inline]\n-    fn bottom_value() -> bool {\n-        false // bottom = no loans in scope by default\n-    }\n-}\n-\n impl<'a, 'tcx> DataflowOperator for MaybeInitializedLvals<'a, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {"}, {"sha": "9f9909a8f57a99f9b1d4cf74e5319d0432fcb254", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -25,7 +25,7 @@ use std::path::PathBuf;\n use std::usize;\n \n pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n+pub use self::impls::{DefinitelyInitializedLvals};\n pub use self::impls::borrows::{Borrows, BorrowData, BorrowIndex};\n pub(crate) use self::drop_flag_effects::*;\n \n@@ -364,8 +364,6 @@ impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O> where O: BitDenotation\n         DataflowResults(self.flow_state)\n     }\n \n-    pub fn flow_state(&self) -> &DataflowState<O> { &self.flow_state }\n-\n     pub fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n }\n "}, {"sha": "6b1fe0d2ca9f6b504f2bcceeac11ba6dc2d0a746", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -43,10 +43,10 @@ extern crate rustc_const_math;\n extern crate rustc_const_eval;\n extern crate core; // for NonZero\n \n-pub mod diagnostics;\n+mod diagnostics;\n \n mod build;\n-pub mod dataflow;\n+mod dataflow;\n mod hair;\n mod shim;\n pub mod transform;"}, {"sha": "e66143784dcf213e7aafeb4b1f9bee4525615de3", "filename": "src/librustc_mir/transform/borrow_check.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -27,7 +27,6 @@ use dataflow::{do_dataflow};\n use dataflow::{MoveDataParamEnv};\n use dataflow::{BitDenotation, BlockSets, DataflowResults, DataflowResultsConsumer};\n use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-use dataflow::{MovingOutStatements};\n use dataflow::{Borrows, BorrowData, BorrowIndex};\n use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n@@ -80,9 +79,6 @@ fn borrowck_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &Mir\n         let flow_uninits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n                                        MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n                                        |bd, i| &bd.move_data().move_paths[i]);\n-        let flow_move_outs = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                                         MovingOutStatements::new(tcx, mir, &mdpe),\n-                                         |bd, i| &bd.move_data().moves[i]);\n \n         let mut mbcx = MirBorrowckCtxt {\n             tcx: tcx,\n@@ -95,8 +91,7 @@ fn borrowck_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &Mir\n \n         let mut state = InProgress::new(flow_borrows,\n                                         flow_inits,\n-                                        flow_uninits,\n-                                        flow_move_outs);\n+                                        flow_uninits);\n \n         mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n     });\n@@ -119,7 +114,6 @@ pub struct InProgress<'b, 'tcx: 'b> {\n     borrows: FlowInProgress<Borrows<'b, 'tcx>>,\n     inits: FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>,\n     uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>,\n-    move_outs: FlowInProgress<MovingOutStatements<'b, 'tcx>>,\n }\n \n struct FlowInProgress<BD> where BD: BitDenotation {\n@@ -519,10 +513,6 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n             if maybe_uninits.curr_state.contains(&mpi) {\n                 // find and report move(s) that could cause this to be uninitialized\n-\n-                // FIXME: for each move in flow_state.move_outs ...\n-                &flow_state.move_outs;\n-\n                 self.report_use_of_moved(context, lvalue_span);\n             } else {\n                 // sanity check: initialized on *some* path, right?\n@@ -1138,13 +1128,12 @@ impl ContextKind {\n impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n     pub(super) fn new(borrows: DataflowResults<Borrows<'b, 'tcx>>,\n                       inits: DataflowResults<MaybeInitializedLvals<'b, 'tcx>>,\n-                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>,\n-                      move_outs: DataflowResults<MovingOutStatements<'b, 'tcx>>) -> Self {\n+                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>)\n+                      -> Self {\n         InProgress {\n             borrows: FlowInProgress::new(borrows),\n             inits: FlowInProgress::new(inits),\n             uninits: FlowInProgress::new(uninits),\n-            move_outs: FlowInProgress::new(move_outs),\n         }\n     }\n "}, {"sha": "59cf5903aa9a0037b0d6399f7223252732a6134f", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -789,12 +789,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n pub struct TypeckMir;\n \n-impl TypeckMir {\n-    pub fn new() -> Self {\n-        TypeckMir\n-    }\n-}\n-\n impl MirPass for TypeckMir {\n     fn run_pass<'a, 'tcx>(&self,\n                           tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "8263e149d84e74fa1b4e5c7459fd2158d10d4990", "filename": "src/librustc_mir/util/def_use.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_mir%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fdef_use.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -50,10 +50,6 @@ impl<'tcx> DefUseAnalysis<'tcx> {\n         &self.info[local]\n     }\n \n-    pub fn local_info_mut(&mut self, local: Local) -> &mut Info<'tcx> {\n-        &mut self.info[local]\n-    }\n-\n     fn mutate_defs_and_uses<F>(&self, local: Local, mir: &mut Mir<'tcx>, mut callback: F)\n                                where F: for<'a> FnMut(&'a mut Lvalue<'tcx>,\n                                                       LvalueContext<'tcx>,"}, {"sha": "6c41aad98d54d64d36fbb26ff856c4aa238a439a", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -36,13 +36,13 @@ extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n \n-pub mod diagnostics;\n+mod diagnostics;\n \n pub mod ast_validation;\n pub mod consts;\n pub mod hir_stats;\n pub mod loops;\n-pub mod mir_stats;\n+mod mir_stats;\n pub mod no_asm;\n pub mod static_recursion;\n "}, {"sha": "3273d66dd4f516ff6f316738de6963b7619d6bc1", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -13,7 +13,6 @@\n // completely accurate (some things might be counted twice, others missed).\n \n use rustc_const_math::{ConstUsize};\n-use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::const_val::{ConstVal};\n use rustc::mir::{AggregateKind, AssertMessage, BasicBlock, BasicBlockData};\n use rustc::mir::{Constant, Literal, Location, LocalDecl};\n@@ -22,9 +21,7 @@ use rustc::mir::{Mir, Operand, ProjectionElem};\n use rustc::mir::{Rvalue, SourceInfo, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind, VisibilityScope, VisibilityScopeData};\n use rustc::mir::visit as mir_visit;\n-use rustc::mir::visit::Visitor;\n use rustc::ty::{ClosureSubsts, TyCtxt};\n-use rustc::util::common::to_readable_str;\n use rustc::util::nodemap::{FxHashMap};\n \n struct NodeData {\n@@ -37,21 +34,6 @@ struct StatCollector<'a, 'tcx: 'a> {\n     data: FxHashMap<&'static str, NodeData>,\n }\n \n-pub fn print_mir_stats<'tcx, 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, title: &str) {\n-    let mut collector = StatCollector {\n-        _tcx: tcx,\n-        data: FxHashMap(),\n-    };\n-    // For debugging instrumentation like this, we don't need to worry\n-    // about maintaining the dep graph.\n-    let _ignore = tcx.dep_graph.in_ignore();\n-    for &def_id in tcx.mir_keys(LOCAL_CRATE).iter() {\n-        let mir = tcx.optimized_mir(def_id);\n-        collector.visit_mir(&mir);\n-    }\n-    collector.print(title);\n-}\n-\n impl<'a, 'tcx> StatCollector<'a, 'tcx> {\n \n     fn record_with_size(&mut self, label: &'static str, node_size: usize) {\n@@ -67,27 +49,6 @@ impl<'a, 'tcx> StatCollector<'a, 'tcx> {\n     fn record<T>(&mut self, label: &'static str, node: &T) {\n         self.record_with_size(label, ::std::mem::size_of_val(node));\n     }\n-\n-    fn print(&self, title: &str) {\n-        let mut stats: Vec<_> = self.data.iter().collect();\n-\n-        stats.sort_by_key(|&(_, ref d)| d.count * d.size);\n-\n-        println!(\"\\n{}\\n\", title);\n-\n-        println!(\"{:<32}{:>18}{:>14}{:>14}\",\n-            \"Name\", \"Accumulated Size\", \"Count\", \"Item Size\");\n-        println!(\"------------------------------------------------------------------------------\");\n-\n-        for (label, data) in stats {\n-            println!(\"{:<32}{:>18}{:>14}{:>14}\",\n-                label,\n-                to_readable_str(data.count * data.size),\n-                to_readable_str(data.count),\n-                to_readable_str(data.size));\n-        }\n-        println!(\"------------------------------------------------------------------------------\");\n-    }\n }\n \n impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {"}, {"sha": "1a2e8e9c5d868e384aa24f88375d43b737bb1a19", "filename": "src/librustc_platform_intrinsics/powerpc.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_platform_intrinsics%2Fpowerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_platform_intrinsics%2Fpowerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Fpowerpc.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -282,6 +282,61 @@ pub fn find(name: &str) -> Option<Intrinsic> {\n             output: &::U32x4,\n             definition: Named(\"llvm.ppc.altivec.vavguw\")\n         },\n+        \"_vec_packssh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::I8x16,\n+            definition: Named(\"llvm.ppc.altivec.vpkshss\")\n+        },\n+        \"_vec_packsuh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U16x8, &::U16x8]; &INPUTS },\n+            output: &::U8x16,\n+            definition: Named(\"llvm.ppc.altivec.vpkuhus\")\n+        },\n+        \"_vec_packssw\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vpkswss\")\n+        },\n+        \"_vec_packsuw\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::U32x4, &::U32x4]; &INPUTS },\n+            output: &::U16x8,\n+            definition: Named(\"llvm.ppc.altivec.vpkuwus\")\n+        },\n+        \"_vec_packsush\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I16x8, &::I16x8]; &INPUTS },\n+            output: &::U8x16,\n+            definition: Named(\"llvm.ppc.altivec.vpkshus\")\n+        },\n+        \"_vec_packsusw\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::U16x8,\n+            definition: Named(\"llvm.ppc.altivec.vpkswus\")\n+        },\n+        \"_vec_packpx\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 2] = [&::I32x4, &::I32x4]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vpkpx\")\n+        },\n+        \"_vec_unpacklsb\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::I8x16]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vupklsb\")\n+        },\n+        \"_vec_unpacklsh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::I16x8]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vupklsh\")\n+        },\n+        \"_vec_unpackhsb\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::I8x16]; &INPUTS },\n+            output: &::I16x8,\n+            definition: Named(\"llvm.ppc.altivec.vupkhsb\")\n+        },\n+        \"_vec_unpackhsh\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 1] = [&::I16x8]; &INPUTS },\n+            output: &::I32x4,\n+            definition: Named(\"llvm.ppc.altivec.vupkhsh\")\n+        },\n         _ => return None,\n     })\n }"}, {"sha": "1020cec9a86a55edabfb180d5bf6b47543127d9c", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -80,7 +80,7 @@ extern crate rustc_errors as errors;\n \n pub use self::registry::Registry;\n \n-pub mod diagnostics;\n+mod diagnostics;\n pub mod registry;\n pub mod load;\n pub mod build;"}, {"sha": "eb82dddaf56fb6a4bd0f0a468017a8547f40c9c8", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -41,7 +41,7 @@ use std::cmp;\n use std::mem::replace;\n use std::rc::Rc;\n \n-pub mod diagnostics;\n+mod diagnostics;\n \n ////////////////////////////////////////////////////////////////////////////////\n /// Visitor used to determine if pub(restricted) is used anywhere in the crate."}, {"sha": "bfc76ee2f74f67204495d8b0decc56d368496019", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 113, "deletions": 50, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -581,6 +581,55 @@ impl<T> ::std::ops::IndexMut<Namespace> for PerNS<T> {\n     }\n }\n \n+struct UsePlacementFinder {\n+    target_module: NodeId,\n+    span: Option<Span>,\n+    found_use: bool,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n+    fn visit_mod(\n+        &mut self,\n+        module: &'tcx ast::Mod,\n+        _: Span,\n+        _: &[ast::Attribute],\n+        node_id: NodeId,\n+    ) {\n+        if self.span.is_some() {\n+            return;\n+        }\n+        if node_id != self.target_module {\n+            visit::walk_mod(self, module);\n+            return;\n+        }\n+        // find a use statement\n+        for item in &module.items {\n+            match item.node {\n+                ItemKind::Use(..) => {\n+                    // don't suggest placing a use before the prelude\n+                    // import or other generated ones\n+                    if item.span == DUMMY_SP {\n+                        let mut span = item.span;\n+                        span.hi = span.lo;\n+                        self.span = Some(span);\n+                        self.found_use = true;\n+                        return;\n+                    }\n+                },\n+                // don't place use before extern crate\n+                ItemKind::ExternCrate(_) => {}\n+                // but place them before the first other item\n+                _ => if self.span.map_or(true, |span| item.span < span ) {\n+                    let mut span = item.span;\n+                    span.hi = span.lo;\n+                    self.span = Some(span);\n+                },\n+            }\n+        }\n+        assert!(self.span.is_some(), \"a file can't have no items and emit suggestions\");\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n     fn visit_item(&mut self, item: &'tcx Item) {\n         self.resolve_item(item);\n@@ -733,8 +782,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n     }\n }\n \n-pub type ErrorMessage = Option<(Span, String)>;\n-\n #[derive(Copy, Clone)]\n enum TypeParameters<'a, 'b> {\n     NoTypeParameters,\n@@ -866,7 +913,7 @@ pub struct ModuleData<'a> {\n     expansion: Mark,\n }\n \n-pub type Module<'a> = &'a ModuleData<'a>;\n+type Module<'a> = &'a ModuleData<'a>;\n \n impl<'a> ModuleData<'a> {\n     fn new(parent: Option<Module<'a>>,\n@@ -990,6 +1037,16 @@ enum NameBindingKind<'a> {\n \n struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);\n \n+struct UseError<'a> {\n+    err: DiagnosticBuilder<'a>,\n+    /// Attach `use` statements for these candidates\n+    candidates: Vec<ImportSuggestion>,\n+    /// The node id of the module to place the use statements in\n+    node_id: NodeId,\n+    /// Whether the diagnostic should state that it's \"better\"\n+    better: bool,\n+}\n+\n struct AmbiguityError<'a> {\n     span: Span,\n     name: Name,\n@@ -1190,15 +1247,20 @@ pub struct Resolver<'a> {\n     extern_module_map: FxHashMap<(DefId, bool /* MacrosOnly? */), Module<'a>>,\n \n     pub make_glob_map: bool,\n-    // Maps imports to the names of items actually imported (this actually maps\n-    // all imports, but only glob imports are actually interesting).\n+    /// Maps imports to the names of items actually imported (this actually maps\n+    /// all imports, but only glob imports are actually interesting).\n     pub glob_map: GlobMap,\n \n     used_imports: FxHashSet<(NodeId, Namespace)>,\n     pub maybe_unused_trait_imports: NodeSet,\n \n+    /// privacy errors are delayed until the end in order to deduplicate them\n     privacy_errors: Vec<PrivacyError<'a>>,\n+    /// ambiguity errors are delayed for deduplication\n     ambiguity_errors: Vec<AmbiguityError<'a>>,\n+    /// `use` injections are delayed for better placement and deduplication\n+    use_injections: Vec<UseError<'a>>,\n+\n     gated_errors: FxHashSet<Span>,\n     disallowed_shadowing: Vec<&'a LegacyBinding<'a>>,\n \n@@ -1401,6 +1463,7 @@ impl<'a> Resolver<'a> {\n \n             privacy_errors: Vec::new(),\n             ambiguity_errors: Vec::new(),\n+            use_injections: Vec::new(),\n             gated_errors: FxHashSet(),\n             disallowed_shadowing: Vec::new(),\n \n@@ -1465,10 +1528,11 @@ impl<'a> Resolver<'a> {\n         ImportResolver { resolver: self }.finalize_imports();\n         self.current_module = self.graph_root;\n         self.finalize_current_module_macro_resolutions();\n+\n         visit::walk_crate(self, krate);\n \n         check_unused::check_crate(self, krate);\n-        self.report_errors();\n+        self.report_errors(krate);\n         self.crate_loader.postprocess(krate);\n     }\n \n@@ -2413,25 +2477,20 @@ impl<'a> Resolver<'a> {\n                 __diagnostic_used!(E0411);\n                 err.code(\"E0411\".into());\n                 err.span_label(span, \"`Self` is only available in traits and impls\");\n-                return err;\n+                return (err, Vec::new());\n             }\n             if is_self_value(path, ns) {\n                 __diagnostic_used!(E0424);\n                 err.code(\"E0424\".into());\n                 err.span_label(span, format!(\"`self` value is only available in \\\n                                                methods with `self` parameter\"));\n-                return err;\n+                return (err, Vec::new());\n             }\n \n             // Try to lookup the name in more relaxed fashion for better error reporting.\n             let ident = *path.last().unwrap();\n             let candidates = this.lookup_import_candidates(ident.node.name, ns, is_expected);\n-            if !candidates.is_empty() {\n-                let mut module_span = this.current_module.span;\n-                module_span.hi = module_span.lo;\n-                // Report import candidates as help and proceed searching for labels.\n-                show_candidates(&mut err, module_span, &candidates, def.is_some());\n-            } else if is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n+            if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n                 let enum_candidates =\n                     this.lookup_import_candidates(ident.node.name, ns, is_enum_variant);\n                 let mut enum_candidates = enum_candidates.iter()\n@@ -2471,7 +2530,7 @@ impl<'a> Resolver<'a> {\n                                                 format!(\"Self::{}\", path_str));\n                         }\n                     }\n-                    return err;\n+                    return (err, candidates);\n                 }\n             }\n \n@@ -2488,22 +2547,22 @@ impl<'a> Resolver<'a> {\n                 match (def, source) {\n                     (Def::Macro(..), _) => {\n                         err.span_label(span, format!(\"did you mean `{}!(...)`?\", path_str));\n-                        return err;\n+                        return (err, candidates);\n                     }\n                     (Def::TyAlias(..), PathSource::Trait) => {\n                         err.span_label(span, \"type aliases cannot be used for traits\");\n-                        return err;\n+                        return (err, candidates);\n                     }\n                     (Def::Mod(..), PathSource::Expr(Some(parent))) => match parent.node {\n                         ExprKind::Field(_, ident) => {\n                             err.span_label(parent.span, format!(\"did you mean `{}::{}`?\",\n                                                                  path_str, ident.node));\n-                            return err;\n+                            return (err, candidates);\n                         }\n                         ExprKind::MethodCall(ref segment, ..) => {\n                             err.span_label(parent.span, format!(\"did you mean `{}::{}(...)`?\",\n                                                                  path_str, segment.identifier));\n-                            return err;\n+                            return (err, candidates);\n                         }\n                         _ => {}\n                     },\n@@ -2519,7 +2578,7 @@ impl<'a> Resolver<'a> {\n                         }\n                         err.span_label(span, format!(\"did you mean `{} {{ /* fields */ }}`?\",\n                                                        path_str));\n-                        return err;\n+                        return (err, candidates);\n                     }\n                     _ => {}\n                 }\n@@ -2530,10 +2589,14 @@ impl<'a> Resolver<'a> {\n                 err.span_label(base_span, fallback_label);\n                 this.type_ascription_suggestion(&mut err, base_span);\n             }\n-            err\n+            (err, candidates)\n         };\n         let report_errors = |this: &mut Self, def: Option<Def>| {\n-            report_errors(this, def).emit();\n+            let (err, candidates) = report_errors(this, def);\n+            let def_id = this.current_module.normal_ancestor_id;\n+            let node_id = this.definitions.as_local_node_id(def_id).unwrap();\n+            let better = def.is_some();\n+            this.use_injections.push(UseError { err, candidates, node_id, better });\n             err_path_resolution()\n         };\n \n@@ -2966,31 +3029,6 @@ impl<'a> Resolver<'a> {\n         return def;\n     }\n \n-    // Calls `f` with a `Resolver` whose current lexical scope is `module`'s lexical scope,\n-    // i.e. the module's items and the prelude (unless the module is `#[no_implicit_prelude]`).\n-    // FIXME #34673: This needs testing.\n-    pub fn with_module_lexical_scope<T, F>(&mut self, module: Module<'a>, f: F) -> T\n-        where F: FnOnce(&mut Resolver<'a>) -> T,\n-    {\n-        self.with_empty_ribs(|this| {\n-            this.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n-            this.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n-            f(this)\n-        })\n-    }\n-\n-    fn with_empty_ribs<T, F>(&mut self, f: F) -> T\n-        where F: FnOnce(&mut Resolver<'a>) -> T,\n-    {\n-        let ribs = replace(&mut self.ribs, PerNS::<Vec<Rib>>::default());\n-        let label_ribs = replace(&mut self.label_ribs, Vec::new());\n-\n-        let result = f(self);\n-        self.ribs = ribs;\n-        self.label_ribs = label_ribs;\n-        result\n-    }\n-\n     fn lookup_assoc_candidate<FilterFn>(&mut self,\n                                         ident: Ident,\n                                         ns: Namespace,\n@@ -3458,8 +3496,9 @@ impl<'a> Resolver<'a> {\n         vis.is_accessible_from(module.normal_ancestor_id, self)\n     }\n \n-    fn report_errors(&mut self) {\n+    fn report_errors(&mut self, krate: &Crate) {\n         self.report_shadowing_errors();\n+        self.report_with_use_injections(krate);\n         let mut reported_spans = FxHashSet();\n \n         for &AmbiguityError { span, name, b1, b2, lexical, legacy } in &self.ambiguity_errors {\n@@ -3507,6 +3546,22 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn report_with_use_injections(&mut self, krate: &Crate) {\n+        for UseError { mut err, candidates, node_id, better } in self.use_injections.drain(..) {\n+            let mut finder = UsePlacementFinder {\n+                target_module: node_id,\n+                span: None,\n+                found_use: false,\n+            };\n+            visit::walk_crate(&mut finder, krate);\n+            if !candidates.is_empty() {\n+                let span = finder.span.expect(\"did not find module\");\n+                show_candidates(&mut err, span, &candidates, better, finder.found_use);\n+            }\n+            err.emit();\n+        }\n+    }\n+\n     fn report_shadowing_errors(&mut self) {\n         for (ident, scope) in replace(&mut self.lexical_macro_resolutions, Vec::new()) {\n             self.resolve_legacy_scope(scope, ident, true);\n@@ -3697,7 +3752,8 @@ fn import_candidate_to_paths(suggestion: &ImportSuggestion) -> (Span, String, St\n fn show_candidates(err: &mut DiagnosticBuilder,\n                    span: Span,\n                    candidates: &[ImportSuggestion],\n-                   better: bool) {\n+                   better: bool,\n+                   found_use: bool) {\n \n     // we want consistent results across executions, but candidates are produced\n     // by iterating through a hash map, so make sure they are ordered:\n@@ -3713,7 +3769,14 @@ fn show_candidates(err: &mut DiagnosticBuilder,\n     let msg = format!(\"possible {}candidate{} into scope\", better, msg_diff);\n \n     for candidate in &mut path_strings {\n-        *candidate = format!(\"use {};\\n\", candidate);\n+        // produce an additional newline to separate the new use statement\n+        // from the directly following item.\n+        let additional_newline = if found_use {\n+            \"\"\n+        } else {\n+            \"\\n\"\n+        };\n+        *candidate = format!(\"use {};\\n{}\", candidate, additional_newline);\n     }\n \n     err.span_suggestions(span, &msg, path_strings);"}, {"sha": "ee14171e9a49876600f1700dfe9937012b77ad36", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -51,7 +51,7 @@ use std::env;\n use std::fs::File;\n use std::path::{Path, PathBuf};\n \n-use syntax::ast::{self, NodeId, PatKind, Attribute, CRATE_NODE_ID};\n+use syntax::ast::{self, NodeId, PatKind, Attribute};\n use syntax::parse::lexer::comments::strip_doc_comment_decoration;\n use syntax::parse::token;\n use syntax::print::pprust;\n@@ -80,8 +80,6 @@ pub struct SaveContext<'l, 'tcx: 'l> {\n \n #[derive(Debug)]\n pub enum Data {\n-    /// Data about a macro use.\n-    MacroUseData(MacroRef),\n     RefData(Ref),\n     DefData(Def),\n     RelationData(Relation),\n@@ -759,11 +757,6 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n-    #[inline]\n-    pub fn enclosing_scope(&self, id: NodeId) -> NodeId {\n-        self.tcx.hir.get_enclosing_scope(id).unwrap_or(CRATE_NODE_ID)\n-    }\n-\n     fn docs_for_attrs(&self, attrs: &[Attribute]) -> String {\n         let mut result = String::new();\n "}, {"sha": "0d39db9e10a70894a3bbb50bb853eec4f4b5ae2c", "filename": "src/librustc_trans/back/archive.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_trans%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_trans%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Farchive.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -10,7 +10,7 @@\n \n //! A helper class for dealing with static archives\n \n-use std::ffi::{CString, CStr, OsString};\n+use std::ffi::{CString, CStr};\n use std::io;\n use std::mem;\n use std::path::{Path, PathBuf};\n@@ -28,8 +28,6 @@ pub struct ArchiveConfig<'a> {\n     pub dst: PathBuf,\n     pub src: Option<PathBuf>,\n     pub lib_search_paths: Vec<PathBuf>,\n-    pub ar_prog: String,\n-    pub command_path: OsString,\n }\n \n /// Helper for adding many files to an archive with a single invocation of"}, {"sha": "338f3bb08aa97a5825342e84d31d9f753065e44d", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -138,12 +138,6 @@ pub fn msvc_link_exe_cmd(_sess: &Session) -> (Command, Vec<(OsString, OsString)>\n     (Command::new(\"link.exe\"), vec![])\n }\n \n-pub fn get_ar_prog(sess: &Session) -> String {\n-    sess.opts.cg.ar.clone().unwrap_or_else(|| {\n-        sess.target.target.options.ar.clone()\n-    })\n-}\n-\n fn command_path(sess: &Session) -> OsString {\n     // The compiler's sysroot often has some bundled tools, so add it to the\n     // PATH for the child.\n@@ -383,8 +377,6 @@ fn archive_config<'a>(sess: &'a Session,\n         dst: output.to_path_buf(),\n         src: input.map(|p| p.to_path_buf()),\n         lib_search_paths: archive_search_paths(sess),\n-        ar_prog: get_ar_prog(sess),\n-        command_path: command_path(sess),\n     }\n }\n "}, {"sha": "3f9b28d3d610cc3d07bd8b9982f1f59394f87690", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -785,8 +785,6 @@ pub fn start_async_translation(sess: &Session,\n         crate_name,\n         link,\n         metadata,\n-        exported_symbols,\n-        no_builtins,\n         windows_subsystem,\n         linker_info,\n         no_integrated_as,\n@@ -1801,8 +1799,6 @@ pub struct OngoingCrateTranslation {\n     crate_name: Symbol,\n     link: LinkMeta,\n     metadata: EncodedMetadata,\n-    exported_symbols: Arc<ExportedSymbols>,\n-    no_builtins: bool,\n     windows_subsystem: Option<String>,\n     linker_info: LinkerInfo,\n     no_integrated_as: bool,\n@@ -1852,13 +1848,10 @@ impl OngoingCrateTranslation {\n             crate_name: self.crate_name,\n             link: self.link,\n             metadata: self.metadata,\n-            exported_symbols: self.exported_symbols,\n-            no_builtins: self.no_builtins,\n             windows_subsystem: self.windows_subsystem,\n             linker_info: self.linker_info,\n \n             modules: compiled_modules.modules,\n-            metadata_module: compiled_modules.metadata_module,\n             allocator_module: compiled_modules.allocator_module,\n         };\n "}, {"sha": "f2b07cf6a58310811accc34baf50e0769f350a91", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 1, "deletions": 69, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -27,10 +27,9 @@ use type_::Type;\n use rustc_data_structures::base_n;\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames};\n use rustc::session::Session;\n-use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{LayoutCx, LayoutError, LayoutTyper, TyLayout};\n-use rustc::util::nodemap::{DefIdMap, FxHashMap, FxHashSet};\n+use rustc::util::nodemap::{FxHashMap, FxHashSet};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n@@ -39,7 +38,6 @@ use std::iter;\n use std::str;\n use std::sync::Arc;\n use std::marker::PhantomData;\n-use syntax::ast;\n use syntax::symbol::InternedString;\n use syntax_pos::DUMMY_SP;\n use abi::Abi;\n@@ -124,12 +122,6 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     /// Cache of emitted const globals (value -> global)\n     const_globals: RefCell<FxHashMap<ValueRef, ValueRef>>,\n \n-    /// Cache of emitted const values\n-    const_values: RefCell<FxHashMap<(ast::NodeId, &'tcx Substs<'tcx>), ValueRef>>,\n-\n-    /// Cache of external const values\n-    extern_const_values: RefCell<DefIdMap<ValueRef>>,\n-\n     /// Mapping from static definitions to their DefId's.\n     statics: RefCell<FxHashMap<ValueRef, DefId>>,\n \n@@ -144,7 +136,6 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n     used_statics: RefCell<Vec<ValueRef>>,\n \n     lltypes: RefCell<FxHashMap<Ty<'tcx>, Type>>,\n-    type_hashcodes: RefCell<FxHashMap<Ty<'tcx>, String>>,\n     int_type: Type,\n     opaque_vec_type: Type,\n     str_slice_type: Type,\n@@ -157,9 +148,6 @@ pub struct LocalCrateContext<'a, 'tcx: 'a> {\n \n     intrinsics: RefCell<FxHashMap<&'static str, ValueRef>>,\n \n-    /// Depth of the current type-of computation - used to bail out\n-    type_of_depth: Cell<usize>,\n-\n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n \n@@ -406,13 +394,10 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 const_cstr_cache: RefCell::new(FxHashMap()),\n                 const_unsized: RefCell::new(FxHashMap()),\n                 const_globals: RefCell::new(FxHashMap()),\n-                const_values: RefCell::new(FxHashMap()),\n-                extern_const_values: RefCell::new(DefIdMap()),\n                 statics: RefCell::new(FxHashMap()),\n                 statics_to_rauw: RefCell::new(Vec::new()),\n                 used_statics: RefCell::new(Vec::new()),\n                 lltypes: RefCell::new(FxHashMap()),\n-                type_hashcodes: RefCell::new(FxHashMap()),\n                 int_type: Type::from_ref(ptr::null_mut()),\n                 opaque_vec_type: Type::from_ref(ptr::null_mut()),\n                 str_slice_type: Type::from_ref(ptr::null_mut()),\n@@ -421,7 +406,6 @@ impl<'a, 'tcx> LocalCrateContext<'a, 'tcx> {\n                 eh_unwind_resume: Cell::new(None),\n                 rust_try_fn: Cell::new(None),\n                 intrinsics: RefCell::new(FxHashMap()),\n-                type_of_depth: Cell::new(0),\n                 local_gen_sym_counter: Cell::new(0),\n                 placeholder: PhantomData,\n             };\n@@ -545,15 +529,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().const_globals\n     }\n \n-    pub fn const_values<'a>(&'a self) -> &'a RefCell<FxHashMap<(ast::NodeId, &'tcx Substs<'tcx>),\n-                                                               ValueRef>> {\n-        &self.local().const_values\n-    }\n-\n-    pub fn extern_const_values<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n-        &self.local().extern_const_values\n-    }\n-\n     pub fn statics<'a>(&'a self) -> &'a RefCell<FxHashMap<ValueRef, DefId>> {\n         &self.local().statics\n     }\n@@ -570,10 +545,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().lltypes\n     }\n \n-    pub fn type_hashcodes<'a>(&'a self) -> &'a RefCell<FxHashMap<Ty<'tcx>, String>> {\n-        &self.local().type_hashcodes\n-    }\n-\n     pub fn stats<'a>(&'a self) -> &'a Stats {\n         &self.local().stats\n     }\n@@ -582,10 +553,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().int_type\n     }\n \n-    pub fn opaque_vec_type(&self) -> Type {\n-        self.local().opaque_vec_type\n-    }\n-\n     pub fn str_slice_type(&self) -> Type {\n         self.local().str_slice_type\n     }\n@@ -602,27 +569,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local().intrinsics\n     }\n \n-    pub fn obj_size_bound(&self) -> u64 {\n-        self.tcx().data_layout.obj_size_bound()\n-    }\n-\n-    pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {\n-        self.sess().fatal(\n-            &format!(\"the type `{:?}` is too big for the current architecture\",\n-                    obj))\n-    }\n-\n-    pub fn enter_type_of(&self, ty: Ty<'tcx>) -> TypeOfDepthLock<'b, 'tcx> {\n-        let current_depth = self.local().type_of_depth.get();\n-        debug!(\"enter_type_of({:?}) at depth {:?}\", ty, current_depth);\n-        if current_depth > self.sess().recursion_limit.get() {\n-            self.sess().fatal(\n-                &format!(\"overflow representing the type `{}`\", ty))\n-        }\n-        self.local().type_of_depth.set(current_depth + 1);\n-        TypeOfDepthLock(self.local())\n-    }\n-\n     pub fn check_overflow(&self) -> bool {\n         self.shared.check_overflow\n     }\n@@ -631,12 +577,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.shared.use_dll_storage_attrs()\n     }\n \n-    /// Given the def-id of some item that has no type parameters, make\n-    /// a suitable \"empty substs\" for it.\n-    pub fn empty_substs_for_def_id(&self, item_def_id: DefId) -> &'tcx Substs<'tcx> {\n-        self.tcx().empty_substs_for_def_id(item_def_id)\n-    }\n-\n     /// Generate a new symbol name with the given prefix. This symbol name must\n     /// only be used for definitions with `internal` or `private` linkage.\n     pub fn generate_local_symbol_name(&self, prefix: &str) -> String {\n@@ -776,14 +716,6 @@ impl<'a, 'tcx> LayoutTyper<'tcx> for &'a CrateContext<'a, 'tcx> {\n     }\n }\n \n-pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'a, 'tcx>);\n-\n-impl<'a, 'tcx> Drop for TypeOfDepthLock<'a, 'tcx> {\n-    fn drop(&mut self) {\n-        self.0.type_of_depth.set(self.0.type_of_depth.get() - 1);\n-    }\n-}\n-\n /// Declare any llvm intrinsics that you might need\n fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n     macro_rules! ifn {"}, {"sha": "6da42caf75bef1480a2543da48ef29f02275fe45", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -36,7 +36,6 @@\n \n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n-use std::sync::Arc;\n \n extern crate flate2;\n extern crate libc;\n@@ -46,7 +45,7 @@ extern crate rustc_allocator;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n extern crate rustc_incremental;\n-pub extern crate rustc_llvm as llvm;\n+extern crate rustc_llvm as llvm;\n extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_const_math;\n #[macro_use]\n@@ -78,7 +77,7 @@ pub mod back {\n     pub(crate) mod symbol_export;\n     pub(crate) mod symbol_names;\n     pub mod write;\n-    pub mod rpath;\n+    mod rpath;\n }\n \n mod diagnostics;\n@@ -138,8 +137,8 @@ pub struct ModuleTranslation {\n     /// unique amongst **all** crates.  Therefore, it should contain\n     /// something unique to this crate (e.g., a module path) as well\n     /// as the crate name and disambiguator.\n-    pub name: String,\n-    pub symbol_name_hash: u64,\n+    name: String,\n+    symbol_name_hash: u64,\n     pub source: ModuleSource,\n     pub kind: ModuleKind,\n }\n@@ -206,7 +205,7 @@ pub enum ModuleSource {\n \n #[derive(Copy, Clone, Debug)]\n pub struct ModuleLlvm {\n-    pub llcx: llvm::ContextRef,\n+    llcx: llvm::ContextRef,\n     pub llmod: llvm::ModuleRef,\n }\n \n@@ -216,14 +215,11 @@ unsafe impl Sync for ModuleTranslation { }\n pub struct CrateTranslation {\n     pub crate_name: Symbol,\n     pub modules: Vec<CompiledModule>,\n-    pub metadata_module: CompiledModule,\n-    pub allocator_module: Option<CompiledModule>,\n+    allocator_module: Option<CompiledModule>,\n     pub link: rustc::middle::cstore::LinkMeta,\n     pub metadata: rustc::middle::cstore::EncodedMetadata,\n-    pub exported_symbols: Arc<back::symbol_export::ExportedSymbols>,\n-    pub no_builtins: bool,\n-    pub windows_subsystem: Option<String>,\n-    pub linker_info: back::linker::LinkerInfo\n+    windows_subsystem: Option<String>,\n+    linker_info: back::linker::LinkerInfo\n }\n \n __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }"}, {"sha": "b8a8068d36af7ef33f59a467410525be44cac9ca", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -237,19 +237,6 @@ impl Type {\n         ty!(llvm::LLVMPointerType(self.to_ref(), 0))\n     }\n \n-    pub fn is_aggregate(&self) -> bool {\n-        match self.kind() {\n-            TypeKind::Struct | TypeKind::Array => true,\n-            _ =>  false\n-        }\n-    }\n-\n-    pub fn is_packed(&self) -> bool {\n-        unsafe {\n-            llvm::LLVMIsPackedStruct(self.to_ref()) == True\n-        }\n-    }\n-\n     pub fn element_type(&self) -> Type {\n         unsafe {\n             Type::from_ref(llvm::LLVMGetElementType(self.to_ref()))\n@@ -263,12 +250,6 @@ impl Type {\n         }\n     }\n \n-    pub fn array_length(&self) -> usize {\n-        unsafe {\n-            llvm::LLVMGetArrayLength(self.to_ref()) as usize\n-        }\n-    }\n-\n     pub fn field_types(&self) -> Vec<Type> {\n         unsafe {\n             let n_elts = llvm::LLVMCountStructElementTypes(self.to_ref()) as usize;\n@@ -282,10 +263,6 @@ impl Type {\n         }\n     }\n \n-    pub fn return_type(&self) -> Type {\n-        ty!(llvm::LLVMGetReturnType(self.to_ref()))\n-    }\n-\n     pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as usize;\n@@ -324,13 +301,4 @@ impl Type {\n             I128 => Type::i128(cx),\n         }\n     }\n-\n-    pub fn from_primitive(ccx: &CrateContext, p: layout::Primitive) -> Type {\n-        match p {\n-            layout::Int(i) => Type::from_integer(ccx, i),\n-            layout::F32 => Type::f32(ccx),\n-            layout::F64 => Type::f64(ccx),\n-            layout::Pointer => bug!(\"It is not possible to convert Pointer directly to Type.\")\n-        }\n-    }\n }"}, {"sha": "819f48a1b57e80855c4a314c43c056af34a84729", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -27,8 +27,6 @@ use rustc::hir;\n pub use self::MethodError::*;\n pub use self::CandidateSource::*;\n \n-pub use self::suggest::AllTraitsVec;\n-\n mod confirm;\n pub mod probe;\n mod suggest;"}, {"sha": "ef8c1b39b0c1abe2cdf8dce558daeaf590266921", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -1687,11 +1687,10 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n                                         poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                                         -> Ty<'tcx>\n     {\n-        let item = self.tcx().associated_item(item_def_id);\n         let (trait_ref, _) =\n             self.replace_late_bound_regions_with_fresh_var(\n                 span,\n-                infer::LateBoundRegionConversionTime::AssocTypeProjection(item.name),\n+                infer::LateBoundRegionConversionTime::AssocTypeProjection(item_def_id),\n                 &poly_trait_ref);\n \n         self.tcx().mk_projection(item_def_id, trait_ref.substs)"}, {"sha": "22865b5103696cca21c7ddf671770fb31cd4d5be", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -1805,8 +1805,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     let (outlives, _) =\n                         self.replace_late_bound_regions_with_fresh_var(\n                             span,\n-                            infer::AssocTypeProjection(\n-                                self.tcx.associated_item(projection_ty.item_def_id).name),\n+                            infer::AssocTypeProjection(projection_ty.item_def_id),\n                             &outlives);\n \n                     debug!(\"projection_bounds: outlives={:?} (3)\","}, {"sha": "69f045ab4e96a0da3ce286333a230ae470d9b87e", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -233,7 +233,10 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                         fcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n                         traits::ObligationCause::new(field.span,\n                                                      fcx.body_id,\n-                                                     traits::FieldSized));\n+                                                     traits::FieldSized(match item.node.adt_kind() {\n+                                                        Some(i) => i,\n+                                                        None => bug!(),\n+                                                     })));\n                 }\n \n                 // All field types must be well-formed."}, {"sha": "294429b5b3671de74b66c86128edc4dd53a740c5", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -95,12 +95,11 @@ extern crate rustc_const_math;\n extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n \n-pub use rustc::dep_graph;\n-pub use rustc::hir;\n-pub use rustc::lint;\n-pub use rustc::middle;\n-pub use rustc::session;\n-pub use rustc::util;\n+use rustc::hir;\n+use rustc::lint;\n+use rustc::middle;\n+use rustc::session;\n+use rustc::util;\n \n use hir::map as hir_map;\n use rustc::infer::InferOk;\n@@ -118,7 +117,7 @@ use syntax_pos::Span;\n use std::iter;\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n-pub mod diagnostics;\n+mod diagnostics;\n \n mod check;\n mod check_unused;\n@@ -130,8 +129,8 @@ mod coherence;\n mod variance;\n \n pub struct TypeAndSubsts<'tcx> {\n-    pub substs: &'tcx Substs<'tcx>,\n-    pub ty: Ty<'tcx>,\n+    substs: &'tcx Substs<'tcx>,\n+    ty: Ty<'tcx>,\n }\n \n fn require_c_abi_if_variadic(tcx: TyCtxt,"}, {"sha": "6746754ebc3449fa8d26b97cc57692cb3bd0c110", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -103,26 +103,31 @@ mod prim_bool { }\n /// [`String`]: string/struct.String.html\n ///\n /// As always, remember that a human intuition for 'character' may not map to\n-/// Unicode's definitions. For example, emoji symbols such as '\u2764\ufe0f' can be more\n-/// than one Unicode code point; this \u2764\ufe0f in particular is two:\n+/// Unicode's definitions. For example, despite looking similar, the '\u00e9'\n+/// character is one Unicode code point while '\u00e9' is two Unicode code points:\n ///\n /// ```\n-/// let s = String::from(\"\u2764\ufe0f\");\n+/// let mut chars = \"\u00e9\".chars();\n+/// // U+00e9: 'latin small letter e with acute'\n+/// assert_eq!(Some('\\u{00e9}'), chars.next());\n+/// assert_eq!(None, chars.next());\n ///\n-/// // we get two chars out of a single \u2764\ufe0f\n-/// let mut iter = s.chars();\n-/// assert_eq!(Some('\\u{2764}'), iter.next());\n-/// assert_eq!(Some('\\u{fe0f}'), iter.next());\n-/// assert_eq!(None, iter.next());\n+/// let mut chars = \"e\u0301\".chars();\n+/// // U+0065: 'latin small letter e'\n+/// assert_eq!(Some('\\u{0065}'), chars.next());\n+/// // U+0301: 'combining acute accent'\n+/// assert_eq!(Some('\\u{0301}'), chars.next());\n+/// assert_eq!(None, chars.next());\n /// ```\n ///\n-/// This means it won't fit into a `char`. Trying to create a literal with\n-/// `let heart = '\u2764\ufe0f';` gives an error:\n+/// This means that the contents of the first string above _will_ fit into a\n+/// `char` while the contents of the second string _will not_. Trying to create\n+/// a `char` literal with the contents of the second string gives an error:\n ///\n /// ```text\n-/// error: character literal may only contain one codepoint: '\u2764\n-/// let heart = '\u2764\ufe0f';\n-///             ^~\n+/// error: character literal may only contain one codepoint: 'e\u0301'\n+/// let c = 'e\u0301';\n+///         ^^^^\n /// ```\n ///\n /// Another implication of the 4-byte fixed size of a `char` is that"}, {"sha": "d87364b8121a74ef9663235fcbb8084a4f0f044f", "filename": "src/libstd/sys/redox/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fprocess.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -336,7 +336,7 @@ impl Command {\n                 panic!(\"return from exec without err\");\n             }\n         } else {\n-            io::Error::new(io::ErrorKind::NotFound, \"\")\n+            io::Error::from_raw_os_error(syscall::ENOENT)\n         }\n     }\n "}, {"sha": "c9fe3590a64a05542c8946ba3308d9ce3e4ebba1", "filename": "src/libstd/sys/unix/ext/io.rs", "status": "modified", "additions": 1, "deletions": 56, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fio.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -13,11 +13,10 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use fs;\n-use net;\n use os::raw;\n use sys;\n use io;\n-use sys_common::{self, AsInner, FromInner, IntoInner};\n+use sys_common::{AsInner, FromInner, IntoInner};\n use libc;\n \n /// Raw file descriptors.\n@@ -93,19 +92,6 @@ impl IntoRawFd for fs::File {\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpStream {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpListener {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::UdpSocket {\n-    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n-}\n-\n #[stable(feature = \"asraw_stdio\", since = \"1.21.0\")]\n impl AsRawFd for io::Stdin {\n     fn as_raw_fd(&self) -> RawFd { libc::STDIN_FILENO }\n@@ -120,44 +106,3 @@ impl AsRawFd for io::Stdout {\n impl AsRawFd for io::Stderr {\n     fn as_raw_fd(&self) -> RawFd { libc::STDERR_FILENO }\n }\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n-    }\n-}\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n-    }\n-}\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::UdpSocket {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::UdpSocket {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}"}, {"sha": "86b0f35be924dcfeca450bc5afd3ba31586f09e6", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 61, "deletions": 3, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -30,14 +30,14 @@ use ffi::OsStr;\n use fmt;\n use io::{self, Initializer};\n use mem;\n-use net::Shutdown;\n+use net::{self, Shutdown};\n use os::unix::ffi::OsStrExt;\n use os::unix::io::{RawFd, AsRawFd, FromRawFd, IntoRawFd};\n use path::Path;\n use time::Duration;\n-use sys::cvt;\n+use sys::{self, cvt};\n use sys::net::Socket;\n-use sys_common::{AsInner, FromInner, IntoInner};\n+use sys_common::{self, AsInner, FromInner, IntoInner};\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\",\n           target_os = \"dragonfly\", target_os = \"freebsd\",\n@@ -588,6 +588,64 @@ impl IntoRawFd for UnixStream {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpStream {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::TcpListener {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsRawFd for net::UdpSocket {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().socket().as_inner() }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::TcpStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::TcpListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+impl FromRawFd for net::UdpSocket {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n+    }\n+}\n+\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::TcpStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::TcpListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+impl IntoRawFd for net::UdpSocket {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.into_inner().into_socket().into_inner()\n+    }\n+}\n+\n /// A structure representing a Unix domain socket server.\n ///\n /// # Examples"}, {"sha": "ca87c807103fd95c32a105e7122dab6cf95221b2", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -1064,26 +1064,21 @@ impl MetaItem {\n             },\n             _ => return None,\n         };\n+        let list_closing_paren_pos = tokens.peek().map(|tt| tt.span().hi);\n         let node = match MetaItemKind::from_tokens(tokens) {\n             Some(node) => node,\n             _ => return None,\n         };\n-        if let Some(last_span) = node.last_span() {\n-            span.hi = last_span.hi;\n-        }\n+        span.hi = match node {\n+            MetaItemKind::NameValue(ref lit) => lit.span.hi,\n+            MetaItemKind::List(..) => list_closing_paren_pos.unwrap_or(span.hi),\n+            _ => span.hi,\n+        };\n         Some(MetaItem { name: name, span: span, node: node })\n     }\n }\n \n impl MetaItemKind {\n-    fn last_span(&self) -> Option<Span> {\n-        match *self {\n-            MetaItemKind::Word => None,\n-            MetaItemKind::List(ref list) => list.last().map(NestedMetaItem::span),\n-            MetaItemKind::NameValue(ref lit) => Some(lit.span),\n-        }\n-    }\n-\n     pub fn tokens(&self, span: Span) -> TokenStream {\n         match *self {\n             MetaItemKind::Word => TokenStream::empty(),\n@@ -1130,7 +1125,7 @@ impl MetaItemKind {\n         let mut result = Vec::new();\n         while let Some(..) = tokens.peek() {\n             match NestedMetaItemKind::from_tokens(&mut tokens) {\n-                Some(item) => result.push(Spanned { span: item.span(), node: item }),\n+                Some(item) => result.push(respan(item.span(), item)),\n                 None => return None,\n             }\n             match tokens.next() {\n@@ -1163,7 +1158,7 @@ impl NestedMetaItemKind {\n         if let Some(TokenTree::Token(span, token)) = tokens.peek().cloned() {\n             if let Some(node) = LitKind::from_token(token) {\n                 tokens.next();\n-                return Some(NestedMetaItemKind::Literal(Spanned { node: node, span: span }));\n+                return Some(NestedMetaItemKind::Literal(respan(span, node)));\n             }\n         }\n \n@@ -1256,7 +1251,7 @@ pub trait HasAttrs: Sized {\n impl<T: HasAttrs> HasAttrs for Spanned<T> {\n     fn attrs(&self) -> &[ast::Attribute] { self.node.attrs() }\n     fn map_attrs<F: FnOnce(Vec<ast::Attribute>) -> Vec<ast::Attribute>>(self, f: F) -> Self {\n-        Spanned { node: self.node.map_attrs(f), span: self.span }\n+        respan(self.span, self.node.map_attrs(f))\n     }\n }\n "}, {"sha": "48c92873e146d9ea4ec2b80fe0463103d421479a", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -244,10 +244,9 @@ impl<'a> Parser<'a> {\n     pub fn parse_meta_item_kind(&mut self) -> PResult<'a, ast::MetaItemKind> {\n         Ok(if self.eat(&token::Eq) {\n             ast::MetaItemKind::NameValue(self.parse_unsuffixed_lit()?)\n-        } else if self.token == token::OpenDelim(token::Paren) {\n+        } else if self.eat(&token::OpenDelim(token::Paren)) {\n             ast::MetaItemKind::List(self.parse_meta_seq()?)\n         } else {\n-            self.eat(&token::OpenDelim(token::Paren));\n             ast::MetaItemKind::Word\n         })\n     }\n@@ -277,9 +276,8 @@ impl<'a> Parser<'a> {\n \n     /// matches meta_seq = ( COMMASEP(meta_item_inner) )\n     fn parse_meta_seq(&mut self) -> PResult<'a, Vec<ast::NestedMetaItem>> {\n-        self.parse_unspanned_seq(&token::OpenDelim(token::Paren),\n-                                 &token::CloseDelim(token::Paren),\n-                                 SeqSep::trailing_allowed(token::Comma),\n-                                 |p: &mut Parser<'a>| p.parse_meta_item_inner())\n+        self.parse_seq_to_end(&token::CloseDelim(token::Paren),\n+                              SeqSep::trailing_allowed(token::Comma),\n+                              |p: &mut Parser<'a>| p.parse_meta_item_inner())\n     }\n }"}, {"sha": "919804d7efd6fe1aa366b26cc5960cd2910305f4", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -323,8 +323,8 @@ impl NameAndSpan {\n     pub fn name(&self) -> Symbol {\n         match self.format {\n             ExpnFormat::MacroAttribute(s) |\n-            ExpnFormat::MacroBang(s) |\n-            ExpnFormat::CompilerDesugaring(s) => s,\n+            ExpnFormat::MacroBang(s) => s,\n+            ExpnFormat::CompilerDesugaring(ref kind) => kind.as_symbol(),\n         }\n     }\n }\n@@ -337,7 +337,27 @@ pub enum ExpnFormat {\n     /// e.g. `format!()`\n     MacroBang(Symbol),\n     /// Desugaring done by the compiler during HIR lowering.\n-    CompilerDesugaring(Symbol)\n+    CompilerDesugaring(CompilerDesugaringKind)\n+}\n+\n+/// The kind of compiler desugaring.\n+#[derive(Clone, Hash, Debug, PartialEq, Eq)]\n+pub enum CompilerDesugaringKind {\n+    BackArrow,\n+    DotFill,\n+    QuestionMark,\n+}\n+\n+impl CompilerDesugaringKind {\n+    pub fn as_symbol(&self) -> Symbol {\n+        use CompilerDesugaringKind::*;\n+        let s = match *self {\n+            BackArrow => \"<-\",\n+            DotFill => \"...\",\n+            QuestionMark => \"?\",\n+        };\n+        Symbol::intern(s)\n+    }\n }\n \n impl Encodable for SyntaxContext {"}, {"sha": "2385e3509ad1c14ff6928476784880b73aaa8a6a", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -47,7 +47,7 @@ extern crate serialize;\n extern crate serialize as rustc_serialize; // used by deriving\n \n pub mod hygiene;\n-pub use hygiene::{SyntaxContext, ExpnInfo, ExpnFormat, NameAndSpan};\n+pub use hygiene::{SyntaxContext, ExpnInfo, ExpnFormat, NameAndSpan, CompilerDesugaringKind};\n \n pub mod symbol;\n \n@@ -153,6 +153,17 @@ impl Span {\n         }\n     }\n \n+    /// Check if this span arises from a compiler desugaring of kind `kind`.\n+    pub fn is_compiler_desugaring(&self, kind: CompilerDesugaringKind) -> bool {\n+        match self.ctxt.outer().expn_info() {\n+            Some(info) => match info.callee.format {\n+                ExpnFormat::CompilerDesugaring(k) => k == kind,\n+                _ => false,\n+            },\n+            None => false,\n+        }\n+    }\n+\n     /// Check if a span is \"internal\" to a macro in which `unsafe`\n     /// can be used without triggering the `unsafe_code` lint\n     //  (that is, a macro marked with `#[allow_internal_unsafe]`)."}, {"sha": "a401861274debf02aa8383b9fc93a5cac9b362d7", "filename": "src/test/ui/resolve/enums-are-namespaced-xc.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fenums-are-namespaced-xc.stderr?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -6,7 +6,7 @@ error[E0425]: cannot find value `A` in module `namespaced_enums`\n    |\n help: possible candidate is found in another module, you can import it into scope\n    |\n-12 | use namespaced_enums::Foo::A;\n+14 | use namespaced_enums::Foo::A;\n    |\n \n error[E0425]: cannot find function `B` in module `namespaced_enums`\n@@ -17,7 +17,7 @@ error[E0425]: cannot find function `B` in module `namespaced_enums`\n    |\n help: possible candidate is found in another module, you can import it into scope\n    |\n-12 | use namespaced_enums::Foo::B;\n+14 | use namespaced_enums::Foo::B;\n    |\n \n error[E0422]: cannot find struct, variant or union type `C` in module `namespaced_enums`\n@@ -28,7 +28,7 @@ error[E0422]: cannot find struct, variant or union type `C` in module `namespace\n    |\n help: possible candidate is found in another module, you can import it into scope\n    |\n-12 | use namespaced_enums::Foo::C;\n+14 | use namespaced_enums::Foo::C;\n    |\n \n error: aborting due to 3 previous errors"}, {"sha": "da849ecc71ab4f6b93e3e14ba0a4f6a2151f3297", "filename": "src/test/ui/resolve/issue-21221-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -6,7 +6,7 @@ error[E0405]: cannot find trait `OuterTrait` in this scope\n    |\n help: possible candidate is found in another module, you can import it into scope\n    |\n-16 | use issue_21221_3::outer::OuterTrait;\n+18 | use issue_21221_3::outer::OuterTrait;\n    |\n \n error: cannot continue compilation due to previous error"}, {"sha": "78059ed37bee86401c71d43966cbda76a243eb5b", "filename": "src/test/ui/resolve/issue-21221-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -6,7 +6,7 @@ error[E0405]: cannot find trait `T` in this scope\n    |\n help: possible candidate is found in another module, you can import it into scope\n    |\n-16 | use issue_21221_4::T;\n+18 | use issue_21221_4::T;\n    |\n \n error: cannot continue compilation due to previous error"}, {"sha": "7a4d0ca698e6dec0d58b1e0ee6ec15bddb3d0bad", "filename": "src/test/ui/resolve/issue-3907.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -6,7 +6,7 @@ error[E0404]: expected trait, found type alias `Foo`\n    |\n help: possible better candidate is found in another module, you can import it into scope\n    |\n-12 | use issue_3907::Foo;\n+14 | use issue_3907::Foo;\n    |\n \n error: cannot continue compilation due to previous error"}, {"sha": "ee1481ec6f2b0087d4964dac21d037bfbf26950b", "filename": "src/test/ui/resolve/privacy-struct-ctor.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -10,7 +10,7 @@ error[E0423]: expected value, found struct `Z`\n    |\n help: possible better candidate is found in another module, you can import it into scope\n    |\n-15 | use m::n::Z;\n+16 |     use m::n::Z;\n    |\n \n error[E0423]: expected value, found struct `S`\n@@ -24,7 +24,7 @@ error[E0423]: expected value, found struct `S`\n    |\n help: possible better candidate is found in another module, you can import it into scope\n    |\n-13 | use m::S;\n+15 | use m::S;\n    |\n \n error[E0423]: expected value, found struct `xcrate::S`\n@@ -38,7 +38,7 @@ error[E0423]: expected value, found struct `xcrate::S`\n    |\n help: possible better candidate is found in another module, you can import it into scope\n    |\n-13 | use m::S;\n+15 | use m::S;\n    |\n \n error[E0603]: tuple struct `Z` is private"}, {"sha": "e0027fed4d6f292efe713351e11dbc68f75ca27d", "filename": "src/test/ui/resolve/use_suggestion_placement.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion_placement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion_placement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion_placement.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+macro_rules! y {\n+    () => {}\n+}\n+\n+mod m {\n+    pub const A: i32 = 0;\n+}\n+\n+fn main() {\n+    y!();\n+    let _ = A;\n+    foo();\n+}\n+\n+fn foo() {\n+    type Dict<K, V> = HashMap<K, V>;\n+}"}, {"sha": "5c74d8bed6665370d385fd13162ac36e6a1b3b46", "filename": "src/test/ui/resolve/use_suggestion_placement.stderr", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion_placement.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion_placement.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion_placement.stderr?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -0,0 +1,38 @@\n+error[E0425]: cannot find value `A` in this scope\n+  --> $DIR/use_suggestion_placement.rs:21:13\n+   |\n+21 |     let _ = A;\n+   |             ^ not found in this scope\n+   |\n+help: possible candidate is found in another module, you can import it into scope\n+   |\n+11 | use m::A;\n+   |\n+\n+error[E0412]: cannot find type `HashMap` in this scope\n+  --> $DIR/use_suggestion_placement.rs:26:23\n+   |\n+26 |     type Dict<K, V> = HashMap<K, V>;\n+   |                       ^^^^^^^ not found in this scope\n+   |\n+help: possible candidates are found in other modules, you can import them into scope\n+   |\n+11 | use std::collections::HashMap;\n+   |\n+11 | use std::collections::hash_map::HashMap;\n+   |\n+\n+error[E0091]: type parameter `K` is unused\n+  --> $DIR/use_suggestion_placement.rs:26:15\n+   |\n+26 |     type Dict<K, V> = HashMap<K, V>;\n+   |               ^ unused type parameter\n+\n+error[E0091]: type parameter `V` is unused\n+  --> $DIR/use_suggestion_placement.rs:26:18\n+   |\n+26 |     type Dict<K, V> = HashMap<K, V>;\n+   |                  ^ unused type parameter\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "c33b89953e27461f965c88f487ebf2879d59565c", "filename": "src/test/ui/span/E0536.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fspan%2FE0536.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fspan%2FE0536.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0536.stderr?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -2,7 +2,7 @@ error[E0536]: expected 1 cfg-pattern\n   --> $DIR/E0536.rs:11:7\n    |\n 11 | #[cfg(not())] //~ ERROR E0536\n-   |       ^^^\n+   |       ^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "9d66ddbaae317dbc0592340dedace69262bbbbdd", "filename": "src/test/ui/span/E0537.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fspan%2FE0537.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fspan%2FE0537.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2FE0537.stderr?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -2,7 +2,7 @@ error[E0537]: invalid predicate `unknown`\n   --> $DIR/E0537.rs:11:7\n    |\n 11 | #[cfg(unknown())] //~ ERROR E0537\n-   |       ^^^^^^^\n+   |       ^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "344cf69748eccf9f3ac688be384b1eb786b9bb96", "filename": "src/test/ui/span/visibility-ty-params.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -1,11 +1,3 @@\n-error[E0577]: expected module, found struct `S`\n-  --> $DIR/visibility-ty-params.rs:16:5\n-   |\n-16 | m!{ S<u8> } //~ ERROR generic arguments in visibility path\n-   |     -^^^^\n-   |     |\n-   |     did you mean `m`?\n-\n error: generic arguments in visibility path\n   --> $DIR/visibility-ty-params.rs:16:6\n    |\n@@ -18,5 +10,13 @@ error: generic arguments in visibility path\n 20 |     m!{ m<> } //~ ERROR generic arguments in visibility path\n    |          ^^\n \n+error[E0577]: expected module, found struct `S`\n+  --> $DIR/visibility-ty-params.rs:16:5\n+   |\n+16 | m!{ S<u8> } //~ ERROR generic arguments in visibility path\n+   |     -^^^^\n+   |     |\n+   |     did you mean `m`?\n+\n error: aborting due to 3 previous errors\n "}, {"sha": "eeca5ab740450494ae97b80515ddedbbb4096f30", "filename": "src/test/ui/union-sized-field.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Funion-sized-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Funion-sized-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-sized-field.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+union Foo<T: ?Sized> {\n+    value: T,\n+}\n+\n+struct Foo2<T: ?Sized> {\n+    value: T,\n+    t: u32,\n+}\n+\n+enum Foo3<T: ?Sized> {\n+    Value(T),\n+}\n+\n+fn main() {}"}, {"sha": "ea90d97c4c3d1f1d2f6150582a287d82d727a060", "filename": "src/test/ui/union-sized-field.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Funion-sized-field.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftest%2Fui%2Funion-sized-field.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-sized-field.stderr?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -0,0 +1,32 @@\n+error[E0277]: the trait bound `T: std::marker::Sized` is not satisfied\n+  --> $DIR/union-sized-field.rs:14:5\n+   |\n+14 |     value: T,\n+   |     ^^^^^^^^ `T` does not have a constant size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `T`\n+   = help: consider adding a `where T: std::marker::Sized` bound\n+   = note: no field of a union may have a dynamically sized type\n+\n+error[E0277]: the trait bound `T: std::marker::Sized` is not satisfied\n+  --> $DIR/union-sized-field.rs:18:5\n+   |\n+18 |     value: T,\n+   |     ^^^^^^^^ `T` does not have a constant size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `T`\n+   = help: consider adding a `where T: std::marker::Sized` bound\n+   = note: only the last field of a struct may have a dynamically sized type\n+\n+error[E0277]: the trait bound `T: std::marker::Sized` is not satisfied\n+  --> $DIR/union-sized-field.rs:23:11\n+   |\n+23 |     Value(T),\n+   |           ^^ `T` does not have a constant size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `T`\n+   = help: consider adding a `where T: std::marker::Sized` bound\n+   = note: no field of an enum variant may have a dynamically sized type\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "7a09ae48b91bd746aec2d28749d1b7081142eab3", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b31998ec93c1738642fd1557b419fa651bb6b543/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=b31998ec93c1738642fd1557b419fa651bb6b543", "patch": "@@ -94,6 +94,7 @@ static TARGETS: &'static [&'static str] = &[\n     \"x86_64-unknown-linux-gnu\",\n     \"x86_64-unknown-linux-musl\",\n     \"x86_64-unknown-netbsd\",\n+    \"x86_64-unknown-redox\",\n ];\n \n static MINGW: &'static [&'static str] = &["}]}