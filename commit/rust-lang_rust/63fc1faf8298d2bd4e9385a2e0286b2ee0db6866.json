{"sha": "63fc1faf8298d2bd4e9385a2e0286b2ee0db6866", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZmMxZmFmODI5OGQyYmQ0ZTkzODVhMmUwMjg2YjJlZTBkYjY4NjY=", "commit": {"author": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-08-06T22:52:51Z"}, "committer": {"name": "lukaramu", "email": "lukaramu@users.noreply.github.com", "date": "2017-08-07T21:10:16Z"}, "message": "Revise documentation in core::ops::arith\n\nPart of #29365.\n* Replaced examples for Mul-/Div-/RemAssign with more illustrative ones\n* Made summary senteces for the trait methods use third person singular\n* Moved some explanations from Examples section to main explanation\n* Switched around argument order for the vector-scalar multiplication\n  example such that the vector is on the left side (as it would be expected\n  if one were to switch from `*` to `*=`)\n* Replaced mostly redundant example introductions with headings in traits\n  with more than one example (where it made sense)\n* Cleaned up some examples to derive `PartialEq` instead of implementing it\n  manually when that wasn't needed\n* Removed explicit `fn main()`s in examples where they weren't necessary\n* Rephrased some things\n* Added some missing periods\n* Fixed some formatting/punctuation in examples", "tree": {"sha": "c436c7346e2ea19e7a1e6173f338e88f55d51af1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c436c7346e2ea19e7a1e6173f338e88f55d51af1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63fc1faf8298d2bd4e9385a2e0286b2ee0db6866", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63fc1faf8298d2bd4e9385a2e0286b2ee0db6866", "html_url": "https://github.com/rust-lang/rust/commit/63fc1faf8298d2bd4e9385a2e0286b2ee0db6866", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63fc1faf8298d2bd4e9385a2e0286b2ee0db6866/comments", "author": null, "committer": null, "parents": [{"sha": "0188ec6ef8d580f4d07c11ca271d90ec78e6b7a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0188ec6ef8d580f4d07c11ca271d90ec78e6b7a8", "html_url": "https://github.com/rust-lang/rust/commit/0188ec6ef8d580f4d07c11ca271d90ec78e6b7a8"}], "stats": {"total": 300, "additions": 118, "deletions": 182}, "files": [{"sha": "97fd8651b047bf44d7d273743d2d40620d091408", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 118, "deletions": 182, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/63fc1faf8298d2bd4e9385a2e0286b2ee0db6866/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fc1faf8298d2bd4e9385a2e0286b2ee0db6866/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=63fc1faf8298d2bd4e9385a2e0286b2ee0db6866", "patch": "@@ -10,15 +10,20 @@\n \n /// The addition operator `+`.\n ///\n+/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n+/// [`std::time::SystemTime`] implements `Add<Duration>`, which permits\n+/// operations of the form `SystemTime = SystemTime + Duration`.\n+///\n+/// [`std::time::SystemTime`]: ../../std/time/struct.SystemTime.html\n+///\n /// # Examples\n ///\n-/// This example creates a `Point` struct that implements the `Add` trait, and\n-/// then demonstrates adding two `Point`s.\n+/// ## `Add`able points\n ///\n /// ```\n /// use std::ops::Add;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point {\n ///     x: i32,\n ///     y: i32,\n@@ -35,31 +40,25 @@\n ///     }\n /// }\n ///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n-///                Point { x: 3, y: 3 });\n-/// }\n+/// assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n+///            Point { x: 3, y: 3 });\n /// ```\n ///\n+/// ## Implementing `Add` with generics\n+///\n /// Here is an example of the same `Point` struct implementing the `Add` trait\n /// using generics.\n ///\n /// ```\n /// use std::ops::Add;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point<T> {\n ///     x: T,\n ///     y: T,\n /// }\n ///\n-/// // Notice that the implementation uses the `Output` associated type\n+/// // Notice that the implementation uses the associated type `Output`.\n /// impl<T: Add<Output=T>> Add for Point<T> {\n ///     type Output = Point<T>;\n ///\n@@ -71,32 +70,18 @@\n ///     }\n /// }\n ///\n-/// impl<T: PartialEq> PartialEq for Point<T> {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n-///                Point { x: 3, y: 3 });\n-/// }\n+/// assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n+///            Point { x: 3, y: 3 });\n /// ```\n-///\n-/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n-/// [std::time::SystemTime] implements `Add<Duration>`, which permits\n-/// operations of the form `SystemTime = SystemTime + Duration`.\n-///\n-/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n #[lang = \"add\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} + {RHS}`\"]\n pub trait Add<RHS=Self> {\n-    /// The resulting type after applying the `+` operator\n+    /// The resulting type after applying the `+` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `+` operator\n+    /// Performs the `+` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn add(self, rhs: RHS) -> Self::Output;\n }\n@@ -120,15 +105,20 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n /// The subtraction operator `-`.\n ///\n+/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n+/// [std::time::SystemTime] implements `Sub<Duration>`, which permits\n+/// operations of the form `SystemTime = SystemTime - Duration`.\n+///\n+/// [`std::time::SystemTime`]: ../../std/time/struct.SystemTime.html\n+///\n /// # Examples\n ///\n-/// This example creates a `Point` struct that implements the `Sub` trait, and\n-/// then demonstrates subtracting two `Point`s.\n+/// ## `Sub`tractable points\n ///\n /// ```\n /// use std::ops::Sub;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point {\n ///     x: i32,\n ///     y: i32,\n@@ -145,31 +135,25 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     }\n /// }\n ///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 3, y: 3 } - Point { x: 2, y: 3 },\n-///                Point { x: 1, y: 0 });\n-/// }\n+/// assert_eq!(Point { x: 3, y: 3 } - Point { x: 2, y: 3 },\n+///            Point { x: 1, y: 0 });\n /// ```\n ///\n+/// ## Implementing `Sub` with generics\n+///\n /// Here is an example of the same `Point` struct implementing the `Sub` trait\n /// using generics.\n ///\n /// ```\n /// use std::ops::Sub;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point<T> {\n ///     x: T,\n ///     y: T,\n /// }\n ///\n-/// // Notice that the implementation uses the `Output` associated type\n+/// // Notice that the implementation uses the associated type `Output`.\n /// impl<T: Sub<Output=T>> Sub for Point<T> {\n ///     type Output = Point<T>;\n ///\n@@ -181,32 +165,18 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     }\n /// }\n ///\n-/// impl<T: PartialEq> PartialEq for Point<T> {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 2, y: 3 } - Point { x: 1, y: 0 },\n-///                Point { x: 1, y: 3 });\n-/// }\n+/// assert_eq!(Point { x: 2, y: 3 } - Point { x: 1, y: 0 },\n+///            Point { x: 1, y: 3 });\n /// ```\n-///\n-/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n-/// [std::time::SystemTime] implements `Sub<Duration>`, which permits\n-/// operations of the form `SystemTime = SystemTime - Duration`.\n-///\n-/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n #[lang = \"sub\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} - {RHS}`\"]\n pub trait Sub<RHS=Self> {\n-    /// The resulting type after applying the `-` operator\n+    /// The resulting type after applying the `-` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `-` operator\n+    /// Performs the `-` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sub(self, rhs: RHS) -> Self::Output;\n }\n@@ -230,17 +200,19 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n /// The multiplication operator `*`.\n ///\n+/// Note that `RHS = Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n-/// Implementing a `Mul`tipliable rational number struct:\n+/// ## `Mul`tipliable rational numbers\n ///\n /// ```\n /// use std::ops::Mul;\n ///\n-/// // The uniqueness of rational numbers in lowest terms is a consequence of\n-/// // the fundamental theorem of arithmetic.\n-/// #[derive(Eq)]\n-/// #[derive(PartialEq, Debug)]\n+/// // By the fundamental theorem of arithmetic, rational numbers in lowest\n+/// // terms are unique. So, by keeping `Rational`s in reduced form, we can\n+/// // derive `Eq` and `PartialEq`.\n+/// #[derive(Debug, Eq, PartialEq)]\n /// struct Rational {\n ///     nominator: usize,\n ///     denominator: usize,\n@@ -291,45 +263,37 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///            Rational::new(1, 2));\n /// ```\n ///\n-/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n-/// implementation which enables multiplication of vectors by scalars, as is\n-/// done in linear algebra.\n+/// ## Multiplying vectors by scalars as in linear algebra\n ///\n /// ```\n /// use std::ops::Mul;\n ///\n-/// struct Scalar {value: usize};\n+/// struct Scalar { value: usize }\n ///\n-/// #[derive(Debug)]\n-/// struct Vector {value: Vec<usize>};\n+/// #[derive(Debug, PartialEq)]\n+/// struct Vector { value: Vec<usize> }\n ///\n-/// impl Mul<Vector> for Scalar {\n+/// impl Mul<Scalar> for Vector {\n ///     type Output = Vector;\n ///\n-///     fn mul(self, rhs: Vector) -> Vector {\n-///         Vector {value: rhs.value.iter().map(|v| self.value * v).collect()}\n-///     }\n-/// }\n-///\n-/// impl PartialEq<Vector> for Vector {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.value == other.value\n+///     fn mul(self, rhs: Scalar) -> Vector {\n+///         Vector { value: self.value.iter().map(|v| v * rhs.value).collect() }\n ///     }\n /// }\n ///\n-/// let scalar = Scalar{value: 3};\n-/// let vector = Vector{value: vec![2, 4, 6]};\n-/// assert_eq!(scalar * vector, Vector{value: vec![6, 12, 18]});\n+/// let vector = Vector { value: vec![2, 4, 6] };\n+/// let scalar = Scalar { value: 3 };\n+/// assert_eq!(vector * scalar, Vector { value: vec![6, 12, 18] });\n /// ```\n #[lang = \"mul\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} * {RHS}`\"]\n pub trait Mul<RHS=Self> {\n-    /// The resulting type after applying the `*` operator\n+    /// The resulting type after applying the `*` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `*` operator\n+    /// Performs the `*` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn mul(self, rhs: RHS) -> Self::Output;\n }\n@@ -353,17 +317,19 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n /// The division operator `/`.\n ///\n+/// Note that `RHS = Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n-/// Implementing a `Div`idable rational number struct:\n+/// ## `Div`idable rational numbers\n ///\n /// ```\n /// use std::ops::Div;\n ///\n-/// // The uniqueness of rational numbers in lowest terms is a consequence of\n-/// // the fundamental theorem of arithmetic.\n-/// #[derive(Eq)]\n-/// #[derive(PartialEq, Debug)]\n+/// // By the fundamental theorem of arithmetic, rational numbers in lowest\n+/// // terms are unique. So, by keeping `Rational`s in reduced form, we can\n+/// // derive `Eq` and `PartialEq`.\n+/// #[derive(Debug, Eq, PartialEq)]\n /// struct Rational {\n ///     nominator: usize,\n ///     denominator: usize,\n@@ -413,52 +379,42 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     x\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n-///     assert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n-///                Rational::new(2, 3));\n-/// }\n+/// assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n+/// assert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n+///            Rational::new(2, 3));\n /// ```\n ///\n-/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n-/// implementation which enables division of vectors by scalars, as is done in\n-/// linear algebra.\n+/// ## Dividing vectors by scalars as in linear algebra\n ///\n /// ```\n /// use std::ops::Div;\n ///\n-/// struct Scalar {value: f32};\n+/// struct Scalar { value: f32 }\n ///\n-/// #[derive(Debug)]\n-/// struct Vector {value: Vec<f32>};\n+/// #[derive(Debug, PartialEq)]\n+/// struct Vector { value: Vec<f32> }\n ///\n /// impl Div<Scalar> for Vector {\n ///     type Output = Vector;\n ///\n ///     fn div(self, rhs: Scalar) -> Vector {\n-///         Vector {value: self.value.iter().map(|v| v / rhs.value).collect()}\n+///         Vector { value: self.value.iter().map(|v| v / rhs.value).collect() }\n ///     }\n /// }\n ///\n-/// impl PartialEq<Vector> for Vector {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.value == other.value\n-///     }\n-/// }\n-///\n-/// let scalar = Scalar{value: 2f32};\n-/// let vector = Vector{value: vec![2f32, 4f32, 6f32]};\n-/// assert_eq!(vector / scalar, Vector{value: vec![1f32, 2f32, 3f32]});\n+/// let scalar = Scalar { value: 2f32 };\n+/// let vector = Vector { value: vec![2f32, 4f32, 6f32] };\n+/// assert_eq!(vector / scalar, Vector { value: vec![1f32, 2f32, 3f32] });\n /// ```\n #[lang = \"div\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} / {RHS}`\"]\n pub trait Div<RHS=Self> {\n-    /// The resulting type after applying the `/` operator\n+    /// The resulting type after applying the `/` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `/` operator\n+    /// Performs the `/` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn div(self, rhs: RHS) -> Self::Output;\n }\n@@ -526,19 +482,19 @@ div_impl_float! { f32 f64 }\n /// }\n ///\n /// // If we were to divide &[0, 1, 2, 3, 4, 5, 6, 7] into slices of size 3,\n-/// // the remainder would be &[6, 7]\n+/// // the remainder would be &[6, 7].\n /// assert_eq!(SplitSlice { slice: &[0, 1, 2, 3, 4, 5, 6, 7] } % 3,\n ///            SplitSlice { slice: &[6, 7] });\n /// ```\n #[lang = \"rem\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} % {RHS}`\"]\n pub trait Rem<RHS=Self> {\n-    /// The resulting type after applying the `%` operator\n+    /// The resulting type after applying the `%` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output = Self;\n \n-    /// The method for the `%` operator\n+    /// Performs the `%` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rem(self, rhs: RHS) -> Self::Output;\n }\n@@ -607,21 +563,21 @@ rem_impl_float! { f32 f64 }\n ///     }\n /// }\n ///\n-/// // a negative positive is a negative\n+/// // A negative positive is a negative.\n /// assert_eq!(-Sign::Positive, Sign::Negative);\n-/// // a double negative is a positive\n+/// // A double negative is a positive.\n /// assert_eq!(-Sign::Negative, Sign::Positive);\n-/// // zero is its own negation\n+/// // Zero is its own negation.\n /// assert_eq!(-Sign::Zero, Sign::Zero);\n /// ```\n #[lang = \"neg\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Neg {\n-    /// The resulting type after applying the `-` operator\n+    /// The resulting type after applying the `-` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the unary `-` operator\n+    /// Performs the unary `-` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn neg(self) -> Self::Output;\n }\n@@ -668,7 +624,7 @@ neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n /// use std::ops::AddAssign;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point {\n ///     x: i32,\n ///     y: i32,\n@@ -683,12 +639,6 @@ neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n ///     }\n /// }\n ///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n /// let mut point = Point { x: 1, y: 0 };\n /// point += Point { x: 2, y: 3 };\n /// assert_eq!(point, Point { x: 3, y: 3 });\n@@ -697,7 +647,7 @@ neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} += {Rhs}`\"]\n pub trait AddAssign<Rhs=Self> {\n-    /// The method for the `+=` operator\n+    /// Performs the `+=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn add_assign(&mut self, rhs: Rhs);\n }\n@@ -725,7 +675,7 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n /// use std::ops::SubAssign;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point {\n ///     x: i32,\n ///     y: i32,\n@@ -740,12 +690,6 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     }\n /// }\n ///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n /// let mut point = Point { x: 3, y: 3 };\n /// point -= Point { x: 2, y: 3 };\n /// assert_eq!(point, Point {x: 1, y: 0});\n@@ -754,7 +698,7 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} -= {Rhs}`\"]\n pub trait SubAssign<Rhs=Self> {\n-    /// The method for the `-=` operator\n+    /// Performs the `-=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn sub_assign(&mut self, rhs: Rhs);\n }\n@@ -776,31 +720,27 @@ sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `MulAssign`. When `Foo *= Foo` happens, it ends up\n-/// calling `mul_assign`, and therefore, `main` prints `Multiplying!`.\n-///\n /// ```\n /// use std::ops::MulAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Frequency { hertz: f64 }\n ///\n-/// impl MulAssign for Foo {\n-///     fn mul_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Multiplying!\");\n+/// impl MulAssign<f64> for Frequency {\n+///     fn mul_assign(&mut self, rhs: f64) {\n+///         self.hertz *= rhs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo *= Foo;\n-/// }\n+/// let mut frequency = Frequency { hertz: 50.0 };\n+/// frequency *= 4.0;\n+/// assert_eq!(Frequency { hertz: 200.0 }, frequency);\n /// ```\n #[lang = \"mul_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} *= {Rhs}`\"]\n pub trait MulAssign<Rhs=Self> {\n-    /// The method for the `*=` operator\n+    /// Performs the `*=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn mul_assign(&mut self, rhs: Rhs);\n }\n@@ -822,31 +762,27 @@ mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `DivAssign`. When `Foo /= Foo` happens, it ends up\n-/// calling `div_assign`, and therefore, `main` prints `Dividing!`.\n-///\n /// ```\n /// use std::ops::DivAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Frequency { hertz: f64 }\n ///\n-/// impl DivAssign for Foo {\n-///     fn div_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Dividing!\");\n+/// impl DivAssign<f64> for Frequency {\n+///     fn div_assign(&mut self, rhs: f64) {\n+///         self.hertz /= rhs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo /= Foo;\n-/// }\n+/// let mut frequency = Frequency { hertz: 200.0 };\n+/// frequency /= 4.0;\n+/// assert_eq!(Frequency { hertz: 50.0 }, frequency);\n /// ```\n #[lang = \"div_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} /= {Rhs}`\"]\n pub trait DivAssign<Rhs=Self> {\n-    /// The method for the `/=` operator\n+    /// Performs the `/=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn div_assign(&mut self, rhs: Rhs);\n }\n@@ -867,31 +803,31 @@ div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `RemAssign`. When `Foo %= Foo` happens, it ends up\n-/// calling `rem_assign`, and therefore, `main` prints `Remainder-ing!`.\n-///\n /// ```\n /// use std::ops::RemAssign;\n ///\n-/// struct Foo;\n+/// struct CookieJar { cookies: u32 }\n ///\n-/// impl RemAssign for Foo {\n-///     fn rem_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Remainder-ing!\");\n+/// impl RemAssign<u32> for CookieJar {\n+///     fn rem_assign(&mut self, piles: u32) {\n+///         self.cookies %= piles;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo %= Foo;\n-/// }\n+/// let mut jar = CookieJar { cookies: 31 };\n+/// let piles = 4;\n+///\n+/// println!(\"Splitting up {} cookies into {} even piles!\", jar.cookies, piles);\n+///\n+/// jar %= piles;\n+///\n+/// println!(\"{} cookies remain in the cookie jar!\", jar.cookies);\n /// ```\n #[lang = \"rem_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} %= {Rhs}`\"]\n pub trait RemAssign<Rhs=Self> {\n-    /// The method for the `%=` operator\n+    /// Performs the `%=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn rem_assign(&mut self, rhs: Rhs);\n }"}]}