{"sha": "9bf9fe07dc2775a8499326990a2fa4bc4af88f8f", "node_id": "C_kwDOAAsO6NoAKDliZjlmZTA3ZGMyNzc1YTg0OTkzMjY5OTBhMmZhNGJjNGFmODhmOGY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-01-07T09:23:07Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-01-12T16:28:41Z"}, "message": "Don't leak inference variables in array unsizing", "tree": {"sha": "c80c8e87704529ff4babefc13acf7a28893992da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c80c8e87704529ff4babefc13acf7a28893992da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9bf9fe07dc2775a8499326990a2fa4bc4af88f8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9bf9fe07dc2775a8499326990a2fa4bc4af88f8f", "html_url": "https://github.com/rust-lang/rust/commit/9bf9fe07dc2775a8499326990a2fa4bc4af88f8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9bf9fe07dc2775a8499326990a2fa4bc4af88f8f/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "012910dab253e8b64dd06e2a91de1943d518439b", "url": "https://api.github.com/repos/rust-lang/rust/commits/012910dab253e8b64dd06e2a91de1943d518439b", "html_url": "https://github.com/rust-lang/rust/commit/012910dab253e8b64dd06e2a91de1943d518439b"}], "stats": {"total": 51, "additions": 29, "deletions": 22}, "files": [{"sha": "27c39934ba8e9f66448ff6a3e81adc075e149dff", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9bf9fe07dc2775a8499326990a2fa4bc4af88f8f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bf9fe07dc2775a8499326990a2fa4bc4af88f8f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=9bf9fe07dc2775a8499326990a2fa4bc4af88f8f", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // time writing the results into the various typeck results.\n         let mut autoderef =\n             self.autoderef_overloaded_span(self.span, unadjusted_self_ty, self.call_expr.span);\n-        let (_, n) = match autoderef.nth(pick.autoderefs) {\n+        let (ty, n) = match autoderef.nth(pick.autoderefs) {\n             Some(n) => n,\n             None => {\n                 return self.tcx.ty_error_with_message(\n@@ -161,14 +161,15 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         assert_eq!(n, pick.autoderefs);\n \n         let mut adjustments = self.adjust_steps(&autoderef);\n+        let mut target = self.structurally_resolved_type(autoderef.span(), ty);\n \n-        let mut target =\n-            self.structurally_resolved_type(autoderef.span(), autoderef.final_ty(false));\n-\n-        match &pick.autoref_or_ptr_adjustment {\n+        match pick.autoref_or_ptr_adjustment {\n             Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl, unsize }) => {\n                 let region = self.next_region_var(infer::Autoref(self.span));\n-                target = self.tcx.mk_ref(region, ty::TypeAndMut { mutbl: *mutbl, ty: target });\n+                // Type we're wrapping in a reference, used later for unsizing\n+                let base_ty = target;\n+\n+                target = self.tcx.mk_ref(region, ty::TypeAndMut { mutbl, ty: target });\n                 let mutbl = match mutbl {\n                     hir::Mutability::Not => AutoBorrowMutability::Not,\n                     hir::Mutability::Mut => AutoBorrowMutability::Mut {\n@@ -182,10 +183,18 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n                     target,\n                 });\n \n-                if let Some(unsize_target) = unsize {\n+                if unsize {\n+                    let unsized_ty = if let ty::Array(elem_ty, _) = base_ty.kind() {\n+                        self.tcx.mk_slice(elem_ty)\n+                    } else {\n+                        bug!(\n+                            \"AutorefOrPtrAdjustment's unsize flag should only be set for array ty, found {}\",\n+                            base_ty\n+                        )\n+                    };\n                     target = self\n                         .tcx\n-                        .mk_ref(region, ty::TypeAndMut { mutbl: mutbl.into(), ty: unsize_target });\n+                        .mk_ref(region, ty::TypeAndMut { mutbl: mutbl.into(), ty: unsized_ty });\n                     adjustments\n                         .push(Adjustment { kind: Adjust::Pointer(PointerCast::Unsize), target });\n                 }"}, {"sha": "8ce1c27f81dcc121481f1728144d7330c6ab118c", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9bf9fe07dc2775a8499326990a2fa4bc4af88f8f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9bf9fe07dc2775a8499326990a2fa4bc4af88f8f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=9bf9fe07dc2775a8499326990a2fa4bc4af88f8f", "patch": "@@ -167,26 +167,26 @@ enum ProbeResult {\n /// T`, we could convert it to `*const T`, then autoref to `&*const T`. However, currently we do\n /// (at most) one of these. Either the receiver has type `T` and we convert it to `&T` (or with\n /// `mut`), or it has type `*mut T` and we convert it to `*const T`.\n-#[derive(Debug, PartialEq, Clone)]\n-pub enum AutorefOrPtrAdjustment<'tcx> {\n+#[derive(Debug, PartialEq, Copy, Clone)]\n+pub enum AutorefOrPtrAdjustment {\n     /// Receiver has type `T`, add `&` or `&mut` (it `T` is `mut`), and maybe also \"unsize\" it.\n     /// Unsizing is used to convert a `[T; N]` to `[T]`, which only makes sense when autorefing.\n     Autoref {\n         mutbl: hir::Mutability,\n \n-        /// Indicates that the source expression should be \"unsized\" to a target type. This should\n-        /// probably eventually go away in favor of just coercing method receivers.\n-        unsize: Option<Ty<'tcx>>,\n+        /// Indicates that the source expression should be \"unsized\" to a target type.\n+        /// This is special-cased for just arrays unsizing to slices.\n+        unsize: bool,\n     },\n     /// Receiver has type `*mut T`, convert to `*const T`\n     ToConstPtr,\n }\n \n-impl<'tcx> AutorefOrPtrAdjustment<'tcx> {\n-    fn get_unsize(&self) -> Option<Ty<'tcx>> {\n+impl AutorefOrPtrAdjustment {\n+    fn get_unsize(&self) -> bool {\n         match self {\n             AutorefOrPtrAdjustment::Autoref { mutbl: _, unsize } => *unsize,\n-            AutorefOrPtrAdjustment::ToConstPtr => None,\n+            AutorefOrPtrAdjustment::ToConstPtr => false,\n         }\n     }\n }\n@@ -204,7 +204,7 @@ pub struct Pick<'tcx> {\n \n     /// Indicates that we want to add an autoref (and maybe also unsize it), or if the receiver is\n     /// `*mut T`, convert it to `*const T`.\n-    pub autoref_or_ptr_adjustment: Option<AutorefOrPtrAdjustment<'tcx>>,\n+    pub autoref_or_ptr_adjustment: Option<AutorefOrPtrAdjustment>,\n     pub self_ty: Ty<'tcx>,\n }\n \n@@ -1202,7 +1202,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     pick.autoderefs += 1;\n                     pick.autoref_or_ptr_adjustment = Some(AutorefOrPtrAdjustment::Autoref {\n                         mutbl,\n-                        unsize: pick.autoref_or_ptr_adjustment.and_then(|a| a.get_unsize()),\n+                        unsize: pick.autoref_or_ptr_adjustment.map_or(false, |a| a.get_unsize()),\n                     })\n                 }\n \n@@ -1227,10 +1227,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         self.pick_method(autoref_ty, unstable_candidates).map(|r| {\n             r.map(|mut pick| {\n                 pick.autoderefs = step.autoderefs;\n-                pick.autoref_or_ptr_adjustment = Some(AutorefOrPtrAdjustment::Autoref {\n-                    mutbl,\n-                    unsize: step.unsize.then_some(self_ty),\n-                });\n+                pick.autoref_or_ptr_adjustment =\n+                    Some(AutorefOrPtrAdjustment::Autoref { mutbl, unsize: step.unsize });\n                 pick\n             })\n         })"}]}