{"sha": "7d725a340f7cb0a256cd468daa189e46416c6afa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkNzI1YTM0MGY3Y2IwYTI1NmNkNDY4ZGFhMTg5ZTQ2NDE2YzZhZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-22T06:01:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-22T06:01:39Z"}, "message": "auto merge of #13618 : yuriks/rust/lru-cache, r=brson\n\nJust a few space saving optimizations that end up making the code less cluttered too. I'd like to someone to review the last commit closely, I don't have much experience with writing unsafe code, I had someone walk me through how to use cast::forget in IRC.", "tree": {"sha": "dd00532e80fe8040d854450aceb8bfaf53346a1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd00532e80fe8040d854450aceb8bfaf53346a1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d725a340f7cb0a256cd468daa189e46416c6afa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d725a340f7cb0a256cd468daa189e46416c6afa", "html_url": "https://github.com/rust-lang/rust/commit/7d725a340f7cb0a256cd468daa189e46416c6afa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d725a340f7cb0a256cd468daa189e46416c6afa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6c8c7c9c65a3623e98a62d98a8e71e483d5b7c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6c8c7c9c65a3623e98a62d98a8e71e483d5b7c7", "html_url": "https://github.com/rust-lang/rust/commit/e6c8c7c9c65a3623e98a62d98a8e71e483d5b7c7"}, {"sha": "9faef77b237baf8cf9908c799be162ab28a9aa84", "url": "https://api.github.com/repos/rust-lang/rust/commits/9faef77b237baf8cf9908c799be162ab28a9aa84", "html_url": "https://github.com/rust-lang/rust/commit/9faef77b237baf8cf9908c799be162ab28a9aa84"}], "stats": {"total": 93, "additions": 35, "deletions": 58}, "files": [{"sha": "097513c6c57013c70b7ab933d8631ec54395e394", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 35, "deletions": 58, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7d725a340f7cb0a256cd468daa189e46416c6afa/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d725a340f7cb0a256cd468daa189e46416c6afa/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=7d725a340f7cb0a256cd468daa189e46416c6afa", "patch": "@@ -41,25 +41,25 @@ use std::cast;\n use std::container::Container;\n use std::hash::Hash;\n use std::fmt;\n+use std::mem;\n use std::ptr;\n \n use HashMap;\n \n struct KeyRef<K> { k: *K }\n \n struct LruEntry<K, V> {\n-    key: Option<K>,\n-    value: Option<V>,\n     next: *mut LruEntry<K, V>,\n     prev: *mut LruEntry<K, V>,\n+    key: K,\n+    value: V,\n }\n \n /// An LRU Cache.\n pub struct LruCache<K, V> {\n     map: HashMap<KeyRef<K>, ~LruEntry<K, V>>,\n     max_size: uint,\n     head: *mut LruEntry<K, V>,\n-    tail: *mut LruEntry<K, V>,\n }\n \n impl<S, K: Hash<S>> Hash<S> for KeyRef<K> {\n@@ -77,19 +77,10 @@ impl<K: Eq> Eq for KeyRef<K> {\n impl<K: TotalEq> TotalEq for KeyRef<K> {}\n \n impl<K, V> LruEntry<K, V> {\n-    fn new() -> LruEntry<K, V> {\n+    fn new(k: K, v: V) -> LruEntry<K, V> {\n         LruEntry {\n-            key: None,\n-            value: None,\n-            next: ptr::mut_null(),\n-            prev: ptr::mut_null(),\n-        }\n-    }\n-\n-    fn with_key_value(k: K, v: V) -> LruEntry<K, V> {\n-        LruEntry {\n-            key: Some(k),\n-            value: Some(v),\n+            key: k,\n+            value: v,\n             next: ptr::mut_null(),\n             prev: ptr::mut_null(),\n         }\n@@ -102,41 +93,42 @@ impl<K: Hash + TotalEq, V> LruCache<K, V> {\n         let cache = LruCache {\n             map: HashMap::new(),\n             max_size: capacity,\n-            head: unsafe{ cast::transmute(~LruEntry::<K, V>::new()) },\n-            tail: unsafe{ cast::transmute(~LruEntry::<K, V>::new()) },\n+            head: unsafe{ cast::transmute(~mem::uninit::<LruEntry<K, V>>()) },\n         };\n         unsafe {\n-            (*cache.head).next = cache.tail;\n-            (*cache.tail).prev = cache.head;\n+            (*cache.head).next = cache.head;\n+            (*cache.head).prev = cache.head;\n         }\n         return cache;\n     }\n \n     /// Put a key-value pair into cache.\n     pub fn put(&mut self, k: K, v: V) {\n-        let mut key_existed = false;\n         let (node_ptr, node_opt) = match self.map.find_mut(&KeyRef{k: &k}) {\n             Some(node) => {\n-                key_existed = true;\n-                node.value = Some(v);\n+                node.value = v;\n                 let node_ptr: *mut LruEntry<K, V> = &mut **node;\n                 (node_ptr, None)\n             }\n             None => {\n-                let mut node = ~LruEntry::with_key_value(k, v);\n+                let mut node = ~LruEntry::new(k, v);\n                 let node_ptr: *mut LruEntry<K, V> = &mut *node;\n                 (node_ptr, Some(node))\n             }\n         };\n-        if key_existed {\n-            self.detach(node_ptr);\n-            self.attach(node_ptr);\n-        } else {\n-            let keyref = unsafe { (*node_ptr).key.as_ref().unwrap() };\n-            self.map.swap(KeyRef{k: keyref}, node_opt.unwrap());\n-            self.attach(node_ptr);\n-            if self.len() > self.capacity() {\n-                self.remove_lru();\n+        match node_opt {\n+            None => {\n+                // Existing node, just update LRU position\n+                self.detach(node_ptr);\n+                self.attach(node_ptr);\n+            }\n+            Some(node) => {\n+                let keyref = unsafe { &(*node_ptr).key };\n+                self.map.swap(KeyRef{k: keyref}, node);\n+                self.attach(node_ptr);\n+                if self.len() > self.capacity() {\n+                    self.remove_lru();\n+                }\n             }\n         }\n     }\n@@ -147,12 +139,7 @@ impl<K: Hash + TotalEq, V> LruCache<K, V> {\n             None => (None, None),\n             Some(node) => {\n                 let node_ptr: *mut LruEntry<K, V> = &mut **node;\n-                unsafe {\n-                    match (*node_ptr).value {\n-                        None => (None, None),\n-                        Some(ref value) => (Some(value), Some(node_ptr))\n-                    }\n-                }\n+                (Some(unsafe { &(*node_ptr).value }), Some(node_ptr))\n             }\n         };\n         match node_ptr_opt {\n@@ -169,7 +156,7 @@ impl<K: Hash + TotalEq, V> LruCache<K, V> {\n     pub fn pop(&mut self, k: &K) -> Option<V> {\n         match self.map.pop(&KeyRef{k: k}) {\n             None => None,\n-            Some(lru_entry) => lru_entry.value\n+            Some(lru_entry) => Some(lru_entry.value)\n         }\n     }\n \n@@ -190,14 +177,9 @@ impl<K: Hash + TotalEq, V> LruCache<K, V> {\n     #[inline]\n     fn remove_lru(&mut self) {\n         if self.len() > 0 {\n-            let lru = unsafe { (*self.tail).prev };\n+            let lru = unsafe { (*self.head).prev };\n             self.detach(lru);\n-            unsafe {\n-                match (*lru).key {\n-                    None => (),\n-                    Some(ref k) => { self.map.pop(&KeyRef{k: k}); }\n-                }\n-            }\n+            self.map.pop(&KeyRef{k: unsafe { &(*lru).key }});\n         }\n     }\n \n@@ -230,19 +212,11 @@ impl<A: fmt::Show + Hash + TotalEq, B: fmt::Show> fmt::Show for LruCache<A, B> {\n             if i > 0 { try!(write!(f.buf, \", \")) }\n             unsafe {\n                 cur = (*cur).next;\n-                match (*cur).key {\n-                    // should never print nil\n-                    None => try!(write!(f.buf, \"nil\")),\n-                    Some(ref k) => try!(write!(f.buf, \"{}\", *k)),\n-                }\n+                try!(write!(f.buf, \"{}\", (*cur).key));\n             }\n             try!(write!(f.buf, \": \"));\n             unsafe {\n-                match (*cur).value {\n-                    // should never print nil\n-                    None => try!(write!(f.buf, \"nil\")),\n-                    Some(ref value) => try!(write!(f.buf, \"{}\", *value)),\n-                }\n+                try!(write!(f.buf, \"{}\", (*cur).value));\n             }\n         }\n         write!(f.buf, r\"\\}\")\n@@ -267,8 +241,11 @@ impl<K: Hash + TotalEq, V> Mutable for LruCache<K, V> {\n impl<K, V> Drop for LruCache<K, V> {\n     fn drop(&mut self) {\n         unsafe {\n-            let _: ~LruEntry<K, V> = cast::transmute(self.head);\n-            let _: ~LruEntry<K, V> = cast::transmute(self.tail);\n+            let node: ~LruEntry<K, V> = cast::transmute(self.head);\n+            // Prevent compiler from trying to drop the un-initialized field in the sigil node.\n+            let ~LruEntry { key: k, value: v, .. } = node;\n+            cast::forget(k);\n+            cast::forget(v);\n         }\n     }\n }"}]}