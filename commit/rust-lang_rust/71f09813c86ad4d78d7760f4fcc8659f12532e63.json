{"sha": "71f09813c86ad4d78d7760f4fcc8659f12532e63", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxZjA5ODEzYzg2YWQ0ZDc4ZDc3NjBmNGZjYzg2NTlmMTI1MzJlNjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-05T07:57:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-05T07:57:46Z"}, "message": "auto merge of #5228 : pcwalton/rust/deriving-clone, r=pcwalton\n\nr? @graydon", "tree": {"sha": "769b6fbceeff3679a5300ffcbcbf087e81eef137", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/769b6fbceeff3679a5300ffcbcbf087e81eef137"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71f09813c86ad4d78d7760f4fcc8659f12532e63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71f09813c86ad4d78d7760f4fcc8659f12532e63", "html_url": "https://github.com/rust-lang/rust/commit/71f09813c86ad4d78d7760f4fcc8659f12532e63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71f09813c86ad4d78d7760f4fcc8659f12532e63/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab500d8b8dd75c51fb4ec17907725d5f13b4e348", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab500d8b8dd75c51fb4ec17907725d5f13b4e348", "html_url": "https://github.com/rust-lang/rust/commit/ab500d8b8dd75c51fb4ec17907725d5f13b4e348"}, {"sha": "0643df28a33f122af9cfbdf49970ab55ae08f106", "url": "https://api.github.com/repos/rust-lang/rust/commits/0643df28a33f122af9cfbdf49970ab55ae08f106", "html_url": "https://github.com/rust-lang/rust/commit/0643df28a33f122af9cfbdf49970ab55ae08f106"}], "stats": {"total": 349, "additions": 333, "deletions": 16}, "files": [{"sha": "01439fb40fb37853193c53595635ac038cff6df0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=71f09813c86ad4d78d7760f4fcc8659f12532e63", "patch": "@@ -155,6 +155,9 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n     syntax_expanders.insert(@~\"deriving_iter_bytes\",\n                             @SE(ItemDecorator(\n                                 ext::deriving::expand_deriving_iter_bytes)));\n+    syntax_expanders.insert(@~\"deriving_clone\",\n+                            @SE(ItemDecorator(\n+                                ext::deriving::expand_deriving_clone)));\n \n     // Quasi-quoting expanders\n     syntax_expanders.insert(@~\"quote_tokens\","}, {"sha": "f5dbf26913834cacaf1194ca02a513dca5b3081b", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 285, "deletions": 16, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=71f09813c86ad4d78d7760f4fcc8659f12532e63", "patch": "@@ -15,7 +15,7 @@ use core::prelude::*;\n \n use ast;\n use ast::{TraitTyParamBound, Ty, and, bind_by_ref, binop, deref, enum_def};\n-use ast::{enum_variant_kind, expr, expr_match, ident, item, item_};\n+use ast::{enum_variant_kind, expr, expr_match, ident, impure_fn, item, item_};\n use ast::{item_enum, item_impl, item_struct, Generics};\n use ast::{m_imm, meta_item, method};\n use ast::{named_field, or, pat, pat_ident, pat_wild, public, pure_fn};\n@@ -84,6 +84,18 @@ pub fn expand_deriving_iter_bytes(cx: ext_ctxt,\n                     expand_deriving_iter_bytes_enum_def)\n }\n \n+pub fn expand_deriving_clone(cx: ext_ctxt,\n+                             span: span,\n+                             _: @meta_item,\n+                             in_items: ~[@item])\n+                          -> ~[@item] {\n+    expand_deriving(cx,\n+                    span,\n+                    in_items,\n+                    expand_deriving_clone_struct_def,\n+                    expand_deriving_clone_enum_def)\n+}\n+\n fn expand_deriving(cx: ext_ctxt,\n                    span: span,\n                    in_items: ~[@item],\n@@ -303,6 +315,21 @@ fn create_derived_iter_bytes_impl(cx: ext_ctxt,\n     create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n }\n \n+fn create_derived_clone_impl(cx: ext_ctxt,\n+                             span: span,\n+                             type_ident: ident,\n+                             generics: &Generics,\n+                             method: @method)\n+                          -> @item {\n+    let methods = [ method ];\n+    let trait_path = [\n+        cx.ident_of(~\"core\"),\n+        cx.ident_of(~\"clone\"),\n+        cx.ident_of(~\"Clone\"),\n+    ];\n+    create_derived_impl(cx, span, type_ident, generics, methods, trait_path)\n+}\n+\n // Creates a method from the given set of statements conforming to the\n // signature of the `iter_bytes` method.\n fn create_iter_bytes_method(cx: ext_ctxt,\n@@ -352,6 +379,58 @@ fn create_iter_bytes_method(cx: ext_ctxt,\n     }\n }\n \n+// Creates a method from the given expression conforming to the signature of\n+// the `clone` method.\n+fn create_clone_method(cx: ext_ctxt,\n+                       span: span,\n+                       +type_ident: ast::ident,\n+                       generics: &Generics,\n+                       expr: @ast::expr)\n+                    -> @method {\n+    // Create the type parameters of the return value.\n+    let mut output_ty_params = ~[];\n+    for generics.ty_params.each |ty_param| {\n+        let path = build::mk_ty_path(cx, span, ~[ ty_param.ident ]);\n+        output_ty_params.push(path);\n+    }\n+\n+    // Create the type of the return value.\n+    let output_type_path = build::mk_raw_path_(span,\n+                                               ~[ type_ident ],\n+                                               output_ty_params);\n+    let output_type = ast::ty_path(output_type_path, cx.next_id());\n+    let output_type = @ast::Ty {\n+        id: cx.next_id(),\n+        node: output_type,\n+        span: span\n+    };\n+\n+    // Create the function declaration.\n+    let fn_decl = build::mk_fn_decl(~[], output_type);\n+\n+    // Create the body block.\n+    let body_block = build::mk_simple_block(cx, span, expr);\n+\n+    // Create the self type and method identifier.\n+    let self_ty = spanned { node: sty_region(m_imm), span: span };\n+    let method_ident = cx.ident_of(~\"clone\");\n+\n+    // Create the method.\n+    @ast::method {\n+        ident: method_ident,\n+        attrs: ~[],\n+        generics: ast_util::empty_generics(),\n+        self_ty: self_ty,\n+        purity: impure_fn,\n+        decl: fn_decl,\n+        body: body_block,\n+        id: cx.next_id(),\n+        span: span,\n+        self_id: cx.next_id(),\n+        vis: public,\n+    }\n+}\n+\n fn create_subpatterns(cx: ext_ctxt,\n                       span: span,\n                       prefix: ~str,\n@@ -372,6 +451,15 @@ fn create_subpatterns(cx: ext_ctxt,\n     return dvec::unwrap(subpats);\n }\n \n+fn is_struct_tuple(struct_def: &struct_def) -> bool {\n+    struct_def.fields.len() > 0 && struct_def.fields.all(|f| {\n+        match f.node.kind {\n+            named_field(*) => false,\n+            unnamed_field => true\n+        }\n+    })\n+}\n+\n fn create_enum_variant_pattern(cx: ext_ctxt,\n                                span: span,\n                                variant: &variant,\n@@ -488,6 +576,16 @@ fn call_substructure_iter_bytes_method(cx: ext_ctxt,\n     build::mk_stmt(cx, span, self_call)\n }\n \n+fn call_substructure_clone_method(cx: ext_ctxt,\n+                                  span: span,\n+                                  self_field: @expr)\n+                               -> @expr {\n+    // Call the substructure method.\n+    let clone_ident = cx.ident_of(~\"clone\");\n+    let self_method = build::mk_access_(cx, span, self_field, clone_ident);\n+    build::mk_call_(cx, span, self_method, ~[])\n+}\n+\n fn variant_arg_count(cx: ext_ctxt, span: span, variant: &variant) -> uint {\n     match variant.node.kind {\n         tuple_variant_kind(ref args) => args.len(),\n@@ -508,21 +606,12 @@ fn expand_deriving_eq_struct_def(cx: ext_ctxt,\n     let eq_ident = cx.ident_of(~\"eq\");\n     let ne_ident = cx.ident_of(~\"ne\");\n \n-    let is_struct_tuple =\n-    struct_def.fields.len() > 0 && struct_def.fields.all(|f| {\n-        match f.node.kind {\n-            named_field(*) => false,\n-            unnamed_field => true\n-        }\n-    });\n-\n-    let derive_struct_fn = if is_struct_tuple {\n+    let derive_struct_fn = if is_struct_tuple(struct_def) {\n         expand_deriving_eq_struct_tuple_method\n     } else {\n         expand_deriving_eq_struct_method\n     };\n \n-\n     let eq_method = derive_struct_fn(cx,\n                                      span,\n                                      struct_def,\n@@ -618,6 +707,48 @@ fn expand_deriving_iter_bytes_enum_def(cx: ext_ctxt,\n                                           method);\n }\n \n+fn expand_deriving_clone_struct_def(cx: ext_ctxt,\n+                                    span: span,\n+                                    struct_def: &struct_def,\n+                                    type_ident: ident,\n+                                    generics: &Generics)\n+                                 -> @item {\n+    // Create the method.\n+    let method = if !is_struct_tuple(struct_def) {\n+        expand_deriving_clone_struct_method(cx,\n+                                            span,\n+                                            struct_def,\n+                                            type_ident,\n+                                            generics)\n+    } else {\n+        expand_deriving_clone_tuple_struct_method(cx,\n+                                                  span,\n+                                                  struct_def,\n+                                                  type_ident,\n+                                                  generics)\n+    };\n+\n+    // Create the implementation.\n+    create_derived_clone_impl(cx, span, type_ident, generics, method)\n+}\n+\n+fn expand_deriving_clone_enum_def(cx: ext_ctxt,\n+                                  span: span,\n+                                  enum_definition: &enum_def,\n+                                  type_ident: ident,\n+                                  generics: &Generics)\n+                               -> @item {\n+    // Create the method.\n+    let method = expand_deriving_clone_enum_method(cx,\n+                                                   span,\n+                                                   enum_definition,\n+                                                   type_ident,\n+                                                   generics);\n+\n+    // Create the implementation.\n+    create_derived_clone_impl(cx, span, type_ident, generics, method)\n+}\n+\n fn expand_deriving_eq_struct_method(cx: ext_ctxt,\n                                     span: span,\n                                     struct_def: &struct_def,\n@@ -709,6 +840,93 @@ fn expand_deriving_iter_bytes_struct_method(cx: ext_ctxt,\n     return create_iter_bytes_method(cx, span, statements);\n }\n \n+fn expand_deriving_clone_struct_method(cx: ext_ctxt,\n+                                       span: span,\n+                                       struct_def: &struct_def,\n+                                       type_ident: ident,\n+                                       generics: &Generics)\n+                                    -> @method {\n+    let self_ident = cx.ident_of(~\"self\");\n+\n+    // Create the new fields.\n+    let mut fields = ~[];\n+    for struct_def.fields.each |struct_field| {\n+        match struct_field.node.kind {\n+            named_field(ident, _, _) => {\n+                // Create the accessor for this field.\n+                let self_field = build::mk_access(cx,\n+                                                  span,\n+                                                  ~[ self_ident ],\n+                                                  ident);\n+\n+                // Call the substructure method.\n+                let call = call_substructure_clone_method(cx,\n+                                                          span,\n+                                                          self_field);\n+\n+                let field = build::Field { ident: ident, ex: call };\n+                fields.push(field);\n+            }\n+            unnamed_field => {\n+                cx.span_bug(span,\n+                            ~\"unnamed fields in \\\n+                              expand_deriving_clone_struct_method\");\n+            }\n+        }\n+    }\n+\n+    // Create the struct literal.\n+    let struct_literal = build::mk_struct_e(cx,\n+                                            span,\n+                                            ~[ type_ident ],\n+                                            fields);\n+    create_clone_method(cx, span, type_ident, generics, struct_literal)\n+}\n+\n+fn expand_deriving_clone_tuple_struct_method(cx: ext_ctxt,\n+                                             span: span,\n+                                             struct_def: &struct_def,\n+                                             type_ident: ident,\n+                                             generics: &Generics)\n+                                          -> @method {\n+    // Create the pattern for the match.\n+    let matching_path = build::mk_raw_path(span, ~[ type_ident ]);\n+    let field_count = struct_def.fields.len();\n+    let subpats = create_subpatterns(cx, span, ~\"__self\", field_count);\n+    let pat = build::mk_pat_enum(cx, span, matching_path, subpats);\n+\n+    // Create the new fields.\n+    let mut subcalls = ~[];\n+    for uint::range(0, struct_def.fields.len()) |i| {\n+        // Create the expression for this field.\n+        let field_ident = cx.ident_of(~\"__self\" + i.to_str());\n+        let field = build::mk_path(cx, span, ~[ field_ident ]);\n+\n+        // Call the substructure method.\n+        let subcall = call_substructure_clone_method(cx, span, field);\n+        subcalls.push(subcall);\n+    }\n+\n+    // Create the call to the struct constructor.\n+    let call = build::mk_call(cx, span, ~[ type_ident ], subcalls);\n+\n+    // Create the pattern body.\n+    let match_body_block = build::mk_simple_block(cx, span, call);\n+\n+    // Create the arm.\n+    let arm = ast::arm {\n+        pats: ~[ pat ],\n+        guard: None,\n+        body: match_body_block\n+    };\n+\n+    // Create the method body.\n+    let self_match_expr = expand_enum_or_struct_match(cx, span, ~[ arm ]);\n+\n+    // Create the method.\n+    create_clone_method(cx, span, type_ident, generics, self_match_expr)\n+}\n+\n fn expand_deriving_eq_enum_method(cx: ext_ctxt,\n                                   span: span,\n                                   enum_definition: &enum_def,\n@@ -904,6 +1122,17 @@ fn expand_deriving_eq_struct_tuple_method(cx: ext_ctxt,\n         type_ident, generics, self_match_expr)\n }\n \n+fn expand_enum_or_struct_match(cx: ext_ctxt,\n+                               span: span,\n+                               arms: ~[ ast::arm ])\n+                            -> @expr {\n+    let self_ident = cx.ident_of(~\"self\");\n+    let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n+    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n+    let self_match_expr = expr_match(self_expr, arms);\n+    build::mk_expr(cx, span, self_match_expr)\n+}\n+\n fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n                                           span: span,\n                                           enum_definition: &enum_def)\n@@ -953,14 +1182,54 @@ fn expand_deriving_iter_bytes_enum_method(cx: ext_ctxt,\n     };\n \n     // Create the method body.\n-    let self_ident = cx.ident_of(~\"self\");\n-    let self_expr = build::mk_path(cx, span, ~[ self_ident ]);\n-    let self_expr = build::mk_unary(cx, span, deref, self_expr);\n-    let self_match_expr = expr_match(self_expr, arms);\n-    let self_match_expr = build::mk_expr(cx, span, self_match_expr);\n+    let self_match_expr = expand_enum_or_struct_match(cx, span, arms);\n     let self_match_stmt = build::mk_stmt(cx, span, self_match_expr);\n \n     // Create the method.\n     create_iter_bytes_method(cx, span, ~[ self_match_stmt ])\n }\n \n+fn expand_deriving_clone_enum_method(cx: ext_ctxt,\n+                                     span: span,\n+                                     enum_definition: &enum_def,\n+                                     type_ident: ident,\n+                                     generics: &Generics)\n+                                  -> @method {\n+    // Create the arms of the match in the method body.\n+    let arms = do enum_definition.variants.map |variant| {\n+        // Create the matching pattern.\n+        let pat = create_enum_variant_pattern(cx, span, variant, ~\"__self\");\n+\n+        // Iterate over the variant arguments, creating the subcalls.\n+        let mut subcalls = ~[];\n+        for uint::range(0, variant_arg_count(cx, span, variant)) |j| {\n+            // Create the expression for this field.\n+            let field_ident = cx.ident_of(~\"__self\" + j.to_str());\n+            let field = build::mk_path(cx, span, ~[ field_ident ]);\n+\n+            // Call the substructure method.\n+            let subcall = call_substructure_clone_method(cx, span, field);\n+            subcalls.push(subcall);\n+        }\n+\n+        // Create the call to the enum variant (if necessary).\n+        let call = if subcalls.len() > 0 {\n+            build::mk_call(cx, span, ~[ variant.node.name ], subcalls)\n+        } else {\n+            build::mk_path(cx, span, ~[ variant.node.name ])\n+        };\n+\n+        // Create the pattern body.\n+        let match_body_block = build::mk_simple_block(cx, span, call);\n+\n+        // Create the arm.\n+        ast::arm { pats: ~[ pat ], guard: None, body: match_body_block }\n+    };\n+\n+    // Create the method body.\n+    let self_match_expr = expand_enum_or_struct_match(cx, span, arms);\n+\n+    // Create the method.\n+    create_clone_method(cx, span, type_ident, generics, self_match_expr)\n+}\n+"}, {"sha": "bad83f41bac654ac21033612410cbf5fe56fd043", "filename": "src/test/run-pass/deriving-clone-enum.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Ftest%2Frun-pass%2Fderiving-clone-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Ftest%2Frun-pass%2Fderiving-clone-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-clone-enum.rs?ref=71f09813c86ad4d78d7760f4fcc8659f12532e63", "patch": "@@ -0,0 +1,9 @@\n+#[deriving_clone]\n+enum E {\n+    A,\n+    B(()),\n+    C\n+}\n+\n+fn main() {}\n+"}, {"sha": "c70e644e2a860b877b8a45af8285a582d2dc8c8d", "filename": "src/test/run-pass/deriving-clone-generic-enum.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Ftest%2Frun-pass%2Fderiving-clone-generic-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Ftest%2Frun-pass%2Fderiving-clone-generic-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-clone-generic-enum.rs?ref=71f09813c86ad4d78d7760f4fcc8659f12532e63", "patch": "@@ -0,0 +1,9 @@\n+#[deriving_clone]\n+enum E<T,U> {\n+    A(T),\n+    B(T,U),\n+    C\n+}\n+\n+fn main() {}\n+"}, {"sha": "73fb3ad8d64776e60dc3f240b9f5ed32b2f0aa6b", "filename": "src/test/run-pass/deriving-clone-generic-struct.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Ftest%2Frun-pass%2Fderiving-clone-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Ftest%2Frun-pass%2Fderiving-clone-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-clone-generic-struct.rs?ref=71f09813c86ad4d78d7760f4fcc8659f12532e63", "patch": "@@ -0,0 +1,9 @@\n+#[deriving_clone]\n+struct S<T> {\n+    foo: (),\n+    bar: (),\n+    baz: T,\n+}\n+\n+fn main() {}\n+"}, {"sha": "d7b15d63280d0f542e694d7c769069a3f4d7cb5e", "filename": "src/test/run-pass/deriving-clone-generic-tuple-struct.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Ftest%2Frun-pass%2Fderiving-clone-generic-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Ftest%2Frun-pass%2Fderiving-clone-generic-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-clone-generic-tuple-struct.rs?ref=71f09813c86ad4d78d7760f4fcc8659f12532e63", "patch": "@@ -0,0 +1,5 @@\n+#[deriving_clone]\n+struct S<T>(T, ());\n+\n+fn main() {}\n+"}, {"sha": "2f371c8920be5ab1eedde6753969de076b9e5998", "filename": "src/test/run-pass/deriving-clone-struct.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Ftest%2Frun-pass%2Fderiving-clone-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Ftest%2Frun-pass%2Fderiving-clone-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-clone-struct.rs?ref=71f09813c86ad4d78d7760f4fcc8659f12532e63", "patch": "@@ -0,0 +1,8 @@\n+#[deriving_clone]\n+struct S {\n+    foo: (),\n+    bar: ()\n+}\n+\n+fn main() {}\n+"}, {"sha": "a1a79613d401f436e3afb80f45f3483d9698e126", "filename": "src/test/run-pass/deriving-clone-tuple-struct.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Ftest%2Frun-pass%2Fderiving-clone-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71f09813c86ad4d78d7760f4fcc8659f12532e63/src%2Ftest%2Frun-pass%2Fderiving-clone-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-clone-tuple-struct.rs?ref=71f09813c86ad4d78d7760f4fcc8659f12532e63", "patch": "@@ -0,0 +1,5 @@\n+#[deriving_clone]\n+struct S((), ());\n+\n+fn main() {}\n+"}]}