{"sha": "ea47269f5f50cd7804141ba00811b79be1e156c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhNDcyNjlmNWY1MGNkNzgwNDE0MWJhMDA4MTFiNzliZTFlMTU2YzY=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-11-29T01:42:41Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-12-22T22:12:57Z"}, "message": "rustc_query_system: share previous graph edges with current graph\n\nReduce memory consumption by sharing the previous dependency graph's\nedges with the current graph when it is known to be valid to do so. It\nis known to be valid whenever we mark a node green because all of its\ndependencies were green. It is *not* known to be valid when we mark a\nnode green because we re-executed its query and its result was the same\nas in the previous compilation session. In that case, the dependency set\nmight have changed (we don't try to determine whether or not it changed\nand whether or not we can share).", "tree": {"sha": "9820dabb76dec9b964b3cec834ae90b8ebb153ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9820dabb76dec9b964b3cec834ae90b8ebb153ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea47269f5f50cd7804141ba00811b79be1e156c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea47269f5f50cd7804141ba00811b79be1e156c6", "html_url": "https://github.com/rust-lang/rust/commit/ea47269f5f50cd7804141ba00811b79be1e156c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea47269f5f50cd7804141ba00811b79be1e156c6/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6d6b0c96d86541e8fb69d133ff6222a038e5a53", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6d6b0c96d86541e8fb69d133ff6222a038e5a53", "html_url": "https://github.com/rust-lang/rust/commit/f6d6b0c96d86541e8fb69d133ff6222a038e5a53"}], "stats": {"total": 224, "additions": 159, "deletions": 65}, "files": [{"sha": "24508a5237369d61df8e83101a5b4f926e01c0aa", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 153, "deletions": 64, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/ea47269f5f50cd7804141ba00811b79be1e156c6/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea47269f5f50cd7804141ba00811b79be1e156c6/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=ea47269f5f50cd7804141ba00811b79be1e156c6", "patch": "@@ -134,16 +134,14 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     pub fn query(&self) -> DepGraphQuery<K> {\n+        // We call this before acquiring locks, since it also acquires them.\n+        let edge_count = self.edge_count();\n         let data = self.data.as_ref().unwrap();\n         let previous = &data.previous;\n+        let prev_index_to_index = data.current.prev_index_to_index.lock();\n         let data = data.current.data.lock();\n-\n         let node_count = data.hybrid_indices.len();\n \n-        let edge_count = data.new.edges.iter().map(|e| e.len()).sum::<usize>()\n-            + data.red.edges.iter().map(|e| e.len()).sum::<usize>()\n-            + data.green.edges.iter().map(|e| e.len()).sum::<usize>();\n-\n         let mut nodes = Vec::with_capacity(node_count);\n         let mut edges = Vec::with_capacity(edge_count);\n \n@@ -161,10 +159,18 @@ impl<K: DepKind> DepGraph<K> {\n                     nodes.push(previous.index_to_node(red.node_indices[red_index]));\n                     edges.extend(red.edges[red_index].iter().map(|dst| (src, dst.index())));\n                 }\n-                HybridIndex::Green(green_index) => {\n-                    let green = &data.green;\n-                    nodes.push(previous.index_to_node(green.node_indices[green_index]));\n-                    edges.extend(green.edges[green_index].iter().map(|dst| (src, dst.index())));\n+                HybridIndex::LightGreen(lg_index) => {\n+                    let lg = &data.light_green;\n+                    nodes.push(previous.index_to_node(lg.node_indices[lg_index]));\n+                    edges.extend(lg.edges[lg_index].iter().map(|dst| (src, dst.index())));\n+                }\n+                HybridIndex::DarkGreen(prev_index) => {\n+                    nodes.push(previous.index_to_node(prev_index));\n+                    let edges_iter = previous\n+                        .edge_targets_from(prev_index)\n+                        .iter()\n+                        .map(|&dst| (src, prev_index_to_index[dst].unwrap().index()));\n+                    edges.extend(edges_iter);\n                 }\n             }\n         }\n@@ -287,7 +293,7 @@ impl<K: DepKind> DepGraph<K> {\n                         }\n \n                         let dep_node_index =\n-                            data.current.intern_green_node(&data.previous, prev_index, edges);\n+                            data.current.intern_light_green_node(&data.previous, prev_index, edges);\n \n                         (DepNodeColor::Green(dep_node_index), dep_node_index)\n                     } else {\n@@ -479,9 +485,10 @@ impl<K: DepKind> DepGraph<K> {\n         match data.hybrid_indices[dep_node_index].into() {\n             HybridIndex::New(new_index) => data.new.nodes[new_index],\n             HybridIndex::Red(red_index) => previous.index_to_node(data.red.node_indices[red_index]),\n-            HybridIndex::Green(green_index) => {\n-                previous.index_to_node(data.green.node_indices[green_index])\n+            HybridIndex::LightGreen(light_green_index) => {\n+                previous.index_to_node(data.light_green.node_indices[light_green_index])\n             }\n+            HybridIndex::DarkGreen(prev_index) => previous.index_to_node(prev_index),\n         }\n     }\n \n@@ -494,9 +501,10 @@ impl<K: DepKind> DepGraph<K> {\n         match data.hybrid_indices[dep_node_index].into() {\n             HybridIndex::New(new_index) => data.new.fingerprints[new_index],\n             HybridIndex::Red(red_index) => data.red.fingerprints[red_index],\n-            HybridIndex::Green(green_index) => {\n-                previous.fingerprint_by_index(data.green.node_indices[green_index])\n+            HybridIndex::LightGreen(light_green_index) => {\n+                previous.fingerprint_by_index(data.light_green.node_indices[light_green_index])\n             }\n+            HybridIndex::DarkGreen(prev_index) => previous.fingerprint_by_index(prev_index),\n         }\n     }\n \n@@ -547,19 +555,38 @@ impl<K: DepKind> DepGraph<K> {\n         }\n     }\n \n+    #[inline]\n+    fn edge_count(&self) -> usize {\n+        let data = self.data.as_ref().unwrap();\n+        let previous = &data.previous;\n+        let data = data.current.data.lock();\n+\n+        // Linearly scanning each collection is a bit faster than scanning\n+        // `hybrid_indices` and bouncing around the different collections.\n+        let mut edge_count = data.new.edges.iter().map(|e| e.len()).sum::<usize>()\n+            + data.red.edges.iter().map(|e| e.len()).sum::<usize>()\n+            + data.light_green.edges.iter().map(|e| e.len()).sum::<usize>();\n+\n+        for &hybrid_index in data.hybrid_indices.iter() {\n+            if let HybridIndex::DarkGreen(prev_index) = hybrid_index.into() {\n+                edge_count += previous.edge_targets_from(prev_index).len()\n+            }\n+        }\n+\n+        edge_count\n+    }\n+\n     pub fn serialize(&self) -> SerializedDepGraph<K> {\n         type SDNI = SerializedDepNodeIndex;\n \n+        // We call this before acquiring locks, since it also acquires them.\n+        let edge_count = self.edge_count();\n         let data = self.data.as_ref().unwrap();\n         let previous = &data.previous;\n+        let prev_index_to_index = data.current.prev_index_to_index.lock();\n         let data = data.current.data.lock();\n-\n         let node_count = data.hybrid_indices.len();\n \n-        let edge_count = data.new.edges.iter().map(|e| e.len()).sum::<usize>()\n-            + data.red.edges.iter().map(|e| e.len()).sum::<usize>()\n-            + data.green.edges.iter().map(|e| e.len()).sum::<usize>();\n-\n         let mut nodes = IndexVec::with_capacity(node_count);\n         let mut fingerprints = IndexVec::with_capacity(node_count);\n         let mut edge_list_indices = IndexVec::with_capacity(node_count);\n@@ -590,11 +617,20 @@ impl<K: DepKind> DepGraph<K> {\n                     fingerprints.push(red.fingerprints[i]);\n                     add_edges(&mut edge_list_indices, &mut edge_list_data, red.edges[i].iter());\n                 }\n-                HybridIndex::Green(i) => {\n-                    let green = &data.green;\n-                    nodes.push(previous.index_to_node(green.node_indices[i]));\n-                    fingerprints.push(previous.fingerprint_by_index(green.node_indices[i]));\n-                    add_edges(&mut edge_list_indices, &mut edge_list_data, green.edges[i].iter());\n+                HybridIndex::LightGreen(i) => {\n+                    let lg = &data.light_green;\n+                    nodes.push(previous.index_to_node(lg.node_indices[i]));\n+                    fingerprints.push(previous.fingerprint_by_index(lg.node_indices[i]));\n+                    add_edges(&mut edge_list_indices, &mut edge_list_data, lg.edges[i].iter());\n+                }\n+                HybridIndex::DarkGreen(prev_index) => {\n+                    nodes.push(previous.index_to_node(prev_index));\n+                    fingerprints.push(previous.fingerprint_by_index(prev_index));\n+                    let edges_iter = previous\n+                        .edge_targets_from(prev_index)\n+                        .iter()\n+                        .map(|&dst| prev_index_to_index[dst].as_ref().unwrap());\n+                    add_edges(&mut edge_list_indices, &mut edge_list_data, edges_iter);\n                 }\n             }\n         }\n@@ -688,13 +724,11 @@ impl<K: DepKind> DepGraph<K> {\n \n         let prev_deps = data.previous.edge_targets_from(prev_dep_node_index);\n \n-        let mut current_deps = SmallVec::new();\n-\n         for &dep_dep_node_index in prev_deps {\n             let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n \n             match dep_dep_node_color {\n-                Some(DepNodeColor::Green(node_index)) => {\n+                Some(DepNodeColor::Green(_)) => {\n                     // This dependency has been marked as green before, we are\n                     // still fine and can continue with checking the other\n                     // dependencies.\n@@ -704,7 +738,6 @@ impl<K: DepKind> DepGraph<K> {\n                         dep_node,\n                         data.previous.index_to_node(dep_dep_node_index)\n                     );\n-                    current_deps.push(node_index);\n                 }\n                 Some(DepNodeColor::Red) => {\n                     // We found a dependency the value of which has changed\n@@ -737,13 +770,12 @@ impl<K: DepKind> DepGraph<K> {\n                             dep_dep_node_index,\n                             dep_dep_node,\n                         );\n-                        if let Some(node_index) = node_index {\n+                        if node_index.is_some() {\n                             debug!(\n                                 \"try_mark_previous_green({:?}) --- managed to MARK \\\n                                     dependency {:?} as green\",\n                                 dep_node, dep_dep_node\n                             );\n-                            current_deps.push(node_index);\n                             continue;\n                         }\n                     }\n@@ -758,13 +790,12 @@ impl<K: DepKind> DepGraph<K> {\n                         let dep_dep_node_color = data.colors.get(dep_dep_node_index);\n \n                         match dep_dep_node_color {\n-                            Some(DepNodeColor::Green(node_index)) => {\n+                            Some(DepNodeColor::Green(_)) => {\n                                 debug!(\n                                     \"try_mark_previous_green({:?}) --- managed to \\\n                                         FORCE dependency {:?} to green\",\n                                     dep_node, dep_dep_node\n                                 );\n-                                current_deps.push(node_index);\n                             }\n                             Some(DepNodeColor::Red) => {\n                                 debug!(\n@@ -822,7 +853,7 @@ impl<K: DepKind> DepGraph<K> {\n         let dep_node_index = {\n             // We allocating an entry for the node in the current dependency graph and\n             // adding all the appropriate edges imported from the previous graph\n-            data.current.intern_green_node(&data.previous, prev_dep_node_index, current_deps)\n+            data.current.intern_dark_green_node(&data.previous, prev_dep_node_index)\n         };\n \n         // ... emitting any stored diagnostic ...\n@@ -1015,9 +1046,9 @@ rustc_index::newtype_index! {\n     }\n }\n \n-// Index type for `GreenDepNodeData`.\n+// Index type for `LightGreenDepNodeData`.\n rustc_index::newtype_index! {\n-    struct GreenDepNodeIndex {\n+    struct LightGreenDepNodeIndex {\n         MAX = 0x7FFF_FFFF\n     }\n }\n@@ -1030,7 +1061,8 @@ struct CompressedHybridIndex(u32);\n impl CompressedHybridIndex {\n     const NEW_TAG: u32 = 0b0000_0000_0000_0000_0000_0000_0000_0000;\n     const RED_TAG: u32 = 0b0100_0000_0000_0000_0000_0000_0000_0000;\n-    const GREEN_TAG: u32 = 0b1000_0000_0000_0000_0000_0000_0000_0000;\n+    const LIGHT_GREEN_TAG: u32 = 0b1000_0000_0000_0000_0000_0000_0000_0000;\n+    const DARK_GREEN_TAG: u32 = 0b1100_0000_0000_0000_0000_0000_0000_0000;\n \n     const TAG_MASK: u32 = 0b1100_0000_0000_0000_0000_0000_0000_0000;\n     const INDEX_MASK: u32 = !Self::TAG_MASK;\n@@ -1050,10 +1082,17 @@ impl From<RedDepNodeIndex> for CompressedHybridIndex {\n     }\n }\n \n-impl From<GreenDepNodeIndex> for CompressedHybridIndex {\n+impl From<LightGreenDepNodeIndex> for CompressedHybridIndex {\n+    #[inline]\n+    fn from(index: LightGreenDepNodeIndex) -> Self {\n+        CompressedHybridIndex(Self::LIGHT_GREEN_TAG | index.as_u32())\n+    }\n+}\n+\n+impl From<SerializedDepNodeIndex> for CompressedHybridIndex {\n     #[inline]\n-    fn from(index: GreenDepNodeIndex) -> Self {\n-        CompressedHybridIndex(Self::GREEN_TAG | index.as_u32())\n+    fn from(index: SerializedDepNodeIndex) -> Self {\n+        CompressedHybridIndex(Self::DARK_GREEN_TAG | index.as_u32())\n     }\n }\n \n@@ -1063,7 +1102,8 @@ impl From<GreenDepNodeIndex> for CompressedHybridIndex {\n enum HybridIndex {\n     New(NewDepNodeIndex),\n     Red(RedDepNodeIndex),\n-    Green(GreenDepNodeIndex),\n+    LightGreen(LightGreenDepNodeIndex),\n+    DarkGreen(SerializedDepNodeIndex),\n }\n \n impl From<CompressedHybridIndex> for HybridIndex {\n@@ -1074,8 +1114,11 @@ impl From<CompressedHybridIndex> for HybridIndex {\n         match hybrid_index.0 & CompressedHybridIndex::TAG_MASK {\n             CompressedHybridIndex::NEW_TAG => HybridIndex::New(NewDepNodeIndex::from_u32(index)),\n             CompressedHybridIndex::RED_TAG => HybridIndex::Red(RedDepNodeIndex::from_u32(index)),\n-            CompressedHybridIndex::GREEN_TAG => {\n-                HybridIndex::Green(GreenDepNodeIndex::from_u32(index))\n+            CompressedHybridIndex::LIGHT_GREEN_TAG => {\n+                HybridIndex::LightGreen(LightGreenDepNodeIndex::from_u32(index))\n+            }\n+            CompressedHybridIndex::DARK_GREEN_TAG => {\n+                HybridIndex::DarkGreen(SerializedDepNodeIndex::from_u32(index))\n             }\n             _ => unreachable!(),\n         }\n@@ -1087,6 +1130,32 @@ impl From<CompressedHybridIndex> for HybridIndex {\n /// We divide nodes this way because different types of nodes are able to share\n /// more or less data with the previous graph.\n ///\n+/// To enable more sharing, we distinguish between two kinds of green nodes.\n+/// Light green nodes are nodes in the previous graph that have been marked\n+/// green because we re-executed their queries and the results were the same as\n+/// in the previous session. Dark green nodes are nodes in the previous graph\n+/// that have been marked green because we were able to mark all of their\n+/// dependencies green.\n+///\n+/// Both light and dark green nodes can share the dep node and fingerprint with\n+/// the previous graph, but for light green nodes, we can't be sure that the\n+/// edges may be shared without comparing them against the previous edges, so we\n+/// store them directly (an approach in which we compare edges with the previous\n+/// edges to see if they can be shared was evaluated, but was not found to be\n+/// very profitable).\n+///\n+/// For dark green nodes, we can share everything with the previous graph, which\n+/// is why the `HybridIndex::DarkGreen` enum variant contains the index of the\n+/// node in the previous graph, and why we don't have a separate collection for\n+/// dark green node data--the collection is the `PreviousDepGraph` itself.\n+///\n+/// (Note that for dark green nodes, the edges in the previous graph\n+/// (`SerializedDepNodeIndex`s) must be converted to edges in the current graph\n+/// (`DepNodeIndex`s). `CurrentDepGraph` contains `prev_index_to_index`, which\n+/// can perform this conversion. It should always be possible, as by definition,\n+/// a dark green node is one whose dependencies from the previous session have\n+/// all been marked green--which means `prev_index_to_index` contains them.)\n+///\n /// Node data is stored in parallel vectors to eliminate the padding between\n /// elements that would be needed to satisfy alignment requirements of the\n /// structure that would contain all of a node's data. We could group tightly\n@@ -1099,8 +1168,8 @@ struct DepNodeData<K> {\n     /// Data for nodes in previous graph that have been marked red.\n     red: RedDepNodeData,\n \n-    /// Data for nodes in previous graph that have been marked green.\n-    green: GreenDepNodeData,\n+    /// Data for nodes in previous graph that have been marked light green.\n+    light_green: LightGreenDepNodeData,\n \n     /// Mapping from `DepNodeIndex` to an index into a collection above.\n     /// Indicates which of the above collections contains a node's data.\n@@ -1130,12 +1199,13 @@ struct RedDepNodeData {\n     fingerprints: IndexVec<RedDepNodeIndex, Fingerprint>,\n }\n \n-/// Data for nodes in previous graph that have been marked green. We can share\n-/// both the dep node and the fingerprint with previous graph, but the edges may\n-/// be different, so we store the latter directly.\n-struct GreenDepNodeData {\n-    node_indices: IndexVec<GreenDepNodeIndex, SerializedDepNodeIndex>,\n-    edges: IndexVec<GreenDepNodeIndex, EdgesVec>,\n+/// Data for nodes in previous graph that have been marked green because we\n+/// re-executed their queries and the results were the same as in the previous\n+/// session. We can share the dep node and the fingerprint with the previous\n+/// graph, but the edges may be different, so we store them directly.\n+struct LightGreenDepNodeData {\n+    node_indices: IndexVec<LightGreenDepNodeIndex, SerializedDepNodeIndex>,\n+    edges: IndexVec<LightGreenDepNodeIndex, EdgesVec>,\n }\n \n /// `CurrentDepGraph` stores the dependency graph for the current session. It\n@@ -1164,10 +1234,9 @@ struct GreenDepNodeData {\n /// a `DepNodeIndex` typically just access the `data` field.\n ///\n /// We only need to manipulate at most two locks simultaneously:\n-/// `new_node_to_index` and `data`, or `prev_index_to_index` and `data`. The\n-/// only operation that must manipulate both locks is adding new nodes, in which\n-/// case we first acquire the `new_node_to_index` or `prev_index_to_index` lock\n-/// and then, once a new node is to be inserted, acquire the lock on `data`.\n+/// `new_node_to_index` and `data`, or `prev_index_to_index` and `data`. When\n+/// manipulating both, we acquire `new_node_to_index` or `prev_index_to_index`\n+/// first, and `data` second.\n pub(super) struct CurrentDepGraph<K> {\n     data: Lock<DepNodeData<K>>,\n     new_node_to_index: Sharded<FxHashMap<DepNode<K>, DepNodeIndex>>,\n@@ -1227,7 +1296,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         // structures during full incremental builds, where they aren't used.\n         let new_node_count_estimate = (prev_graph_node_count * 2) / 100 + 200;\n         let red_node_count_estimate = (prev_graph_node_count * 3) / 100;\n-        let green_node_count_estimate = (prev_graph_node_count * 95) / 100;\n+        let light_green_node_count_estimate = (prev_graph_node_count * 25) / 100;\n         let total_node_count_estimate = prev_graph_node_count + new_node_count_estimate;\n \n         // We store a large collection of these in `prev_index_to_index` during\n@@ -1247,9 +1316,9 @@ impl<K: DepKind> CurrentDepGraph<K> {\n                     edges: IndexVec::with_capacity(red_node_count_estimate),\n                     fingerprints: IndexVec::with_capacity(red_node_count_estimate),\n                 },\n-                green: GreenDepNodeData {\n-                    node_indices: IndexVec::with_capacity(green_node_count_estimate),\n-                    edges: IndexVec::with_capacity(green_node_count_estimate),\n+                light_green: LightGreenDepNodeData {\n+                    node_indices: IndexVec::with_capacity(light_green_node_count_estimate),\n+                    edges: IndexVec::with_capacity(light_green_node_count_estimate),\n                 },\n                 hybrid_indices: IndexVec::with_capacity(total_node_count_estimate),\n             }),\n@@ -1276,8 +1345,8 @@ impl<K: DepKind> CurrentDepGraph<K> {\n     ) -> DepNodeIndex {\n         debug_assert!(\n             prev_graph.node_to_index_opt(&dep_node).is_none(),\n-            \"node in previous graph should be interned using \\\n-            `intern_red_node` or `intern_green_node`\"\n+            \"node in previous graph should be interned using one \\\n+            of `intern_red_node`, `intern_light_green_node`, etc.\"\n         );\n \n         match self.new_node_to_index.get_shard_by_value(&dep_node).lock().entry(dep_node) {\n@@ -1319,7 +1388,7 @@ impl<K: DepKind> CurrentDepGraph<K> {\n         }\n     }\n \n-    fn intern_green_node(\n+    fn intern_light_green_node(\n         &self,\n         prev_graph: &PreviousDepGraph<K>,\n         prev_index: SerializedDepNodeIndex,\n@@ -1333,9 +1402,29 @@ impl<K: DepKind> CurrentDepGraph<K> {\n             Some(dep_node_index) => dep_node_index,\n             None => {\n                 let mut data = self.data.lock();\n-                let green_index = data.green.node_indices.push(prev_index);\n-                data.green.edges.push(edges);\n-                let dep_node_index = data.hybrid_indices.push(green_index.into());\n+                let light_green_index = data.light_green.node_indices.push(prev_index);\n+                data.light_green.edges.push(edges);\n+                let dep_node_index = data.hybrid_indices.push(light_green_index.into());\n+                prev_index_to_index[prev_index] = Some(dep_node_index);\n+                dep_node_index\n+            }\n+        }\n+    }\n+\n+    fn intern_dark_green_node(\n+        &self,\n+        prev_graph: &PreviousDepGraph<K>,\n+        prev_index: SerializedDepNodeIndex,\n+    ) -> DepNodeIndex {\n+        self.debug_assert_not_in_new_nodes(prev_graph, prev_index);\n+\n+        let mut prev_index_to_index = self.prev_index_to_index.lock();\n+\n+        match prev_index_to_index[prev_index] {\n+            Some(dep_node_index) => dep_node_index,\n+            None => {\n+                let mut data = self.data.lock();\n+                let dep_node_index = data.hybrid_indices.push(prev_index.into());\n                 prev_index_to_index[prev_index] = Some(dep_node_index);\n                 dep_node_index\n             }"}, {"sha": "28e074069185206d840ae103d25930c1fe10defc", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ea47269f5f50cd7804141ba00811b79be1e156c6/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea47269f5f50cd7804141ba00811b79be1e156c6/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=ea47269f5f50cd7804141ba00811b79be1e156c6", "patch": "@@ -4,8 +4,13 @@ use super::{DepKind, DepNode};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_index::vec::IndexVec;\n \n+// The maximum value of `SerializedDepNodeIndex` leaves the upper two bits\n+// unused so that we can store multiple index types in `CompressedHybridIndex`,\n+// and use those bits to encode which index type it contains.\n rustc_index::newtype_index! {\n-    pub struct SerializedDepNodeIndex { .. }\n+    pub struct SerializedDepNodeIndex {\n+        MAX = 0x7FFF_FFFF\n+    }\n }\n \n /// Data for use when recompiling the **current crate**."}]}