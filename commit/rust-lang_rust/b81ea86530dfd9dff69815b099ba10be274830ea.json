{"sha": "b81ea86530dfd9dff69815b099ba10be274830ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MWVhODY1MzBkZmQ5ZGZmNjk4MTViMDk5YmExMGJlMjc0ODMwZWE=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-08-23T16:45:02Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-09-04T16:38:46Z"}, "message": "debuginfo: Support for variables captured in closures and closure type descriptions.", "tree": {"sha": "157b642e9a6d196adf91f9bc3358d514193e6c8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/157b642e9a6d196adf91f9bc3358d514193e6c8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b81ea86530dfd9dff69815b099ba10be274830ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b81ea86530dfd9dff69815b099ba10be274830ea", "html_url": "https://github.com/rust-lang/rust/commit/b81ea86530dfd9dff69815b099ba10be274830ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b81ea86530dfd9dff69815b099ba10be274830ea/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67555d9bd40a36d93e193fe2d178713481ad445e", "url": "https://api.github.com/repos/rust-lang/rust/commits/67555d9bd40a36d93e193fe2d178713481ad445e", "html_url": "https://github.com/rust-lang/rust/commit/67555d9bd40a36d93e193fe2d178713481ad445e"}], "stats": {"total": 751, "additions": 559, "deletions": 192}, "files": [{"sha": "7903e6f02fa2ee5cd3ed5190e75caad3436e59cd", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=b81ea86530dfd9dff69815b099ba10be274830ea", "patch": "@@ -2084,6 +2084,25 @@ pub mod llvm {\n                                                         ColumnNo: c_uint)\n                                                         -> ValueRef;\n \n+        #[fast_ffi]\n+        pub fn LLVMDIBuilderCreateOpDeref(IntType: TypeRef) -> ValueRef;\n+\n+        #[fast_ffi]\n+        pub fn LLVMDIBuilderCreateOpPlus(IntType: TypeRef) -> ValueRef;\n+\n+        #[fast_ffi]\n+        pub fn LLVMDIBuilderCreateComplexVariable(Builder: DIBuilderRef,\n+            Tag: c_uint,\n+            Scope: ValueRef,\n+            Name: *c_char,\n+            File: ValueRef,\n+            LineNo: c_uint,\n+            Ty: ValueRef,\n+            AddrOps: *ValueRef,\n+            AddrOpsCount: c_uint,\n+            ArgNo: c_uint)\n+            -> ValueRef;\n+\n         pub fn LLVMInitializeX86TargetInfo();\n         pub fn LLVMInitializeX86Target();\n         pub fn LLVMInitializeX86TargetMC();"}, {"sha": "cb672947774a5b9e6216507053fd524b0e56d17a", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=b81ea86530dfd9dff69815b099ba10be274830ea", "patch": "@@ -143,7 +143,7 @@ use syntax::visit;\n use syntax::visit::Visitor;\n use syntax::codemap::Span;\n \n-#[deriving(Encodable, Decodable)]\n+#[deriving(Eq, Encodable, Decodable)]\n pub enum CaptureMode {\n     CapCopy, // Copy the value into the closure.\n     CapMove, // Move the value into the closure."}, {"sha": "92aedbdef84bafd771b90f2689f655c3a921a0fe", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b81ea86530dfd9dff69815b099ba10be274830ea", "patch": "@@ -131,20 +131,6 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     _InsnCtxt { _x: () }\n }\n \n-fn fcx_has_nonzero_span(fcx: &FunctionContext) -> bool {\n-    match fcx.span {\n-        None => false,\n-        Some(span) => *span.lo != 0 || *span.hi != 0\n-    }\n-}\n-\n-fn span_is_empty(opt_span: &Option<Span>) -> bool {\n-    match *opt_span {\n-        None => true,\n-        Some(span) => *span.lo == 0 && *span.hi == 0\n-    }\n-}\n-\n struct StatRecorder<'self> {\n     ccx: @mut CrateContext,\n     name: &'self str,\n@@ -1132,8 +1118,7 @@ pub fn trans_stmt(cx: @mut Block, s: &ast::Stmt) -> @mut Block {\n             match d.node {\n                 ast::DeclLocal(ref local) => {\n                     bcx = init_local(bcx, *local);\n-                    if cx.sess().opts.extra_debuginfo\n-                        && fcx_has_nonzero_span(bcx.fcx) {\n+                    if cx.sess().opts.extra_debuginfo {\n                         debuginfo::create_local_var_metadata(bcx, *local);\n                     }\n                 }\n@@ -1633,12 +1618,7 @@ pub fn new_fn_ctxt_w_id(ccx: @mut CrateContext,\n         }\n     };\n     let uses_outptr = type_of::return_uses_outptr(ccx.tcx, substd_output_type);\n-\n-    let debug_context = if id != -1 && ccx.sess.opts.debuginfo && !span_is_empty(&sp) {\n-        Some(debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl))\n-    } else {\n-        None\n-    };\n+    let debug_context = debuginfo::create_function_debug_context(ccx, id, param_substs, llfndecl);\n \n     let fcx = @mut FunctionContext {\n           llfn: llfndecl,\n@@ -1784,7 +1764,7 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n             fcx.llself = Some(ValSelfData {v: self_val, ..slf});\n             add_clean(bcx, self_val, slf.t);\n \n-            if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n+            if fcx.ccx.sess.opts.extra_debuginfo {\n                 debuginfo::create_self_argument_metadata(bcx, slf.t, self_val);\n             }\n         }\n@@ -1811,7 +1791,7 @@ pub fn copy_args_to_allocas(fcx: @mut FunctionContext,\n         };\n         bcx = _match::store_arg(bcx, args[arg_n].pat, llarg);\n \n-        if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n+        if fcx.ccx.sess.opts.extra_debuginfo {\n             debuginfo::create_argument_metadata(bcx, &args[arg_n]);\n         }\n     }"}, {"sha": "d25fedf2d8e6edab7bc9598593bbf8fe527244e4", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=b81ea86530dfd9dff69815b099ba10be274830ea", "patch": "@@ -17,6 +17,7 @@ use middle::trans::base::*;\n use middle::trans::build::*;\n use middle::trans::common::*;\n use middle::trans::datum::{Datum, INIT};\n+use middle::trans::debuginfo;\n use middle::trans::expr;\n use middle::trans::glue;\n use middle::trans::type_of::*;\n@@ -317,6 +318,11 @@ pub fn load_environment(fcx: @mut FunctionContext,\n         }\n         let def_id = ast_util::def_id_of_def(cap_var.def);\n         fcx.llupvars.insert(def_id.node, upvarptr);\n+\n+        if fcx.ccx.sess.opts.extra_debuginfo {\n+            debuginfo::create_captured_var_metadata(bcx, def_id.node, upvarptr, cap_var.span);\n+        }\n+\n         i += 1u;\n     }\n }"}, {"sha": "d64f221cb9ecd9e7b00b7db57bad679bb7b185f8", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=b81ea86530dfd9dff69815b099ba10be274830ea", "patch": "@@ -228,7 +228,7 @@ pub struct FunctionContext {\n     ccx: @mut CrateContext,\n \n     // Used and maintained by the debuginfo module.\n-    debug_context: Option<~debuginfo::FunctionDebugContext>\n+    debug_context: debuginfo::FunctionDebugContext,\n }\n \n impl FunctionContext {"}, {"sha": "049dee6bfea9605a0b078c002149d9cc7620cec7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 313, "deletions": 162, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=b81ea86530dfd9dff69815b099ba10be274830ea", "patch": "@@ -72,7 +72,7 @@ use syntax::codemap::Span;\n use syntax::{ast, codemap, ast_util, ast_map, opt_vec};\n use syntax::parse::token::special_idents;\n \n-static DW_LANG_RUST: int = 0x9000;\n+static DW_LANG_RUST: c_uint = 0x9000;\n \n static DW_TAG_auto_variable: c_uint = 0x100;\n static DW_TAG_arg_variable: c_uint = 0x101;\n@@ -118,11 +118,63 @@ impl DebugContext {\n     }\n }\n \n-pub struct FunctionDebugContext {\n-    priv scope_map: HashMap<ast::NodeId, DIScope>,\n-    priv fn_metadata: DISubprogram,\n-    priv argument_counter: uint,\n-    priv source_locations_enabled: bool,\n+pub enum FunctionDebugContext {\n+    priv FunctionDebugContext(~FunctionDebugContextData),\n+    priv DebugInfoDisabled,\n+    priv FunctionWithoutDebugInfo,\n+}\n+\n+impl FunctionDebugContext {\n+    fn get_ref<'a>(&'a self, cx: &CrateContext, span: span) -> &'a FunctionDebugContextData {\n+        match *self {\n+            FunctionDebugContext(~ref data) => data,\n+            DebugInfoDisabled => {\n+                cx.sess.span_bug(span, \"debuginfo: Error trying to access FunctionDebugContext \\\n+                                        although debug info is disabled!\");\n+            }\n+            FunctionWithoutDebugInfo => {\n+                cx.sess.span_bug(span, \"debuginfo: Error trying to access FunctionDebugContext \\\n+                                        for function that should be ignored by debug info!\");\n+            }\n+        }\n+    }\n+\n+    fn get_mut_ref<'a>(&'a mut self,\n+                       cx: &CrateContext,\n+                       span: span)\n+                    -> &'a mut FunctionDebugContextData {\n+        match *self {\n+            FunctionDebugContext(~ref mut data) => data,\n+            DebugInfoDisabled => {\n+                cx.sess.span_bug(span, \"debuginfo: Error trying to access FunctionDebugContext \\\n+                                        although debug info is disabled!\");\n+            }\n+            FunctionWithoutDebugInfo => {\n+                cx.sess.span_bug(span, \"debuginfo: Error trying to access FunctionDebugContext \\\n+                                        for function that should be ignored by debug info!\");\n+            }\n+        }\n+    }\n+}\n+\n+struct FunctionDebugContextData {\n+    scope_map: HashMap<ast::NodeId, DIScope>,\n+    fn_metadata: DISubprogram,\n+    argument_counter: uint,\n+    source_locations_enabled: bool,\n+}\n+\n+enum VariableAccess {\n+    // The value given is a pointer to data\n+    DirectVariable,\n+    // The value given has to be dereferenced once to get the pointer to data\n+    IndirectVariable\n+}\n+\n+enum VariableKind {\n+    ArgumentVariable(uint /*index*/),\n+    LocalVariable,\n+    CapturedVariable,\n }\n \n /// Create any deferred debug metadata nodes\n@@ -138,7 +190,12 @@ pub fn finalize(cx: @mut CrateContext) {\n /// Creates debug information for the given local variable.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_local_var_metadata(bcx: @mut Block, local: &ast::Local) {\n+pub fn create_local_var_metadata(bcx: @mut Block,\n+                                 local: &ast::Local) {\n+    if fn_should_be_ignored(bcx.fcx) {\n+        return;\n+    }\n+\n     let cx = bcx.ccx();\n     let def_map = cx.tcx.def_map;\n \n@@ -147,146 +204,191 @@ pub fn create_local_var_metadata(bcx: @mut Block, local: &ast::Local) {\n         let var_ident = ast_util::path_to_ident(path_ref);\n         let var_type = node_id_type(bcx, node_id);\n \n-        declare_local(bcx, var_ident, node_id, var_type, span);\n+        let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n+            Some(v) => v,\n+            None => {\n+                bcx.tcx().sess.span_bug(span, fmt!(\"No entry in lllocals table for %?\", node_id));\n+            }\n+        };\n+\n+        let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n+\n+        declare_local(bcx,\n+                      llptr,\n+                      var_ident,\n+                      var_type,\n+                      scope_metadata,\n+                      DirectVariable,\n+                      LocalVariable,\n+                      span);\n     }\n }\n \n+/// Creates debug information for a local variable introduced in the head of a match-statement arm.\n+///\n+// /// Adds the created metadata nodes directly to the crate's IR.\n+pub fn create_captured_var_metadata(bcx: @mut Block,\n+                                    node_id: ast::NodeId,\n+                                    llptr: ValueRef,\n+                                    span: span) {\n+    if fn_should_be_ignored(bcx.fcx) {\n+        return;\n+    }\n+\n+    let cx = bcx.ccx();\n+\n+    let ast_item = cx.tcx.items.find_copy(&node_id);\n+    let variable_ident = match ast_item {\n+        None => {\n+            cx.sess.span_bug(span, \"debuginfo::create_captured_var_metadata() - NodeId not found\");\n+        }\n+        Some(ast_map::node_local(ident)) => ident,\n+        Some(ast_map::node_arg(@ast::pat { node: ast::pat_ident(_, ref path, _), _ })) => {\n+            ast_util::path_to_ident(path)\n+        }\n+        _ => {\n+            cx.sess.span_bug(span, fmt!(\"debuginfo::create_captured_var_metadata() - \\\n+                Captured var-id refers to unexpected ast_map variant: %?\", ast_item));\n+        }\n+    };\n+    let variable_type = node_id_type(bcx, node_id);\n+    let scope_metadata = bcx.fcx.debug_context.get_ref(cx, span).fn_metadata;\n+\n+    declare_local(bcx,\n+                  llptr,\n+                  variable_ident,\n+                  variable_type,\n+                  scope_metadata,\n+                  IndirectVariable,\n+                  CapturedVariable,\n+                  span);\n+}\n+\n /// Creates debug information for a local variable introduced in the head of a match-statement arm.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_match_binding_metadata(bcx: @mut Block,\n                                      variable_ident: ast::Ident,\n                                      node_id: ast::NodeId,\n                                      variable_type: ty::t,\n-                                     span: Span) {\n-    declare_local(bcx, variable_ident, node_id, variable_type, span);\n+                                     span: span) {\n+    if fn_should_be_ignored(bcx.fcx) {\n+        return;\n+    }\n+\n+    let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n+        Some(v) => v,\n+        None => {\n+            bcx.tcx().sess.span_bug(span, fmt!(\"No entry in lllocals table for %?\", node_id));\n+        }\n+    };\n+\n+    let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n+\n+    declare_local(bcx,\n+                  llptr,\n+                  variable_ident,\n+                  variable_type,\n+                  scope_metadata,\n+                  DirectVariable,\n+                  LocalVariable,\n+                  span);\n }\n \n /// Creates debug information for the self argument of a method.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_self_argument_metadata(bcx: @mut Block,\n-                                     variable_type: ty::t,\n+                                     type_of_self: ty::t,\n                                      llptr: ValueRef) {\n-    assert_fcx_has_span(bcx.fcx);\n-    let span = bcx.fcx.span.unwrap();\n-\n-    let cx = bcx.ccx();\n+    if fn_should_be_ignored(bcx.fcx) {\n+        return;\n+    }\n \n-    let filename = span_start(cx, span).file.name;\n-    let file_metadata = file_metadata(cx, filename);\n+    // Extract the span of the self argument from the method's AST\n+    let fnitem = bcx.ccx().tcx.items.get_copy(&bcx.fcx.id);\n+    let span = match fnitem {\n+        ast_map::node_method(@ast::method { explicit_self: explicit_self, _ }, _, _) => {\n+            explicit_self.span\n+        }\n+        ast_map::node_trait_method(\n+            @ast::provided(\n+                @ast::method {\n+                    explicit_self: explicit_self,\n+                    _\n+                }),\n+            _,\n+            _) => {\n+            explicit_self.span\n+        }\n+        _ => bcx.ccx().sess.bug(fmt!(\"create_self_argument_metadata: unexpected sort of node: %?\", fnitem))\n+    };\n \n-    let loc = span_start(cx, span);\n-    let type_metadata = type_metadata(cx, variable_type, span);\n-    let scope = bcx.fcx.debug_context.get_ref().fn_metadata;\n+    let scope_metadata = bcx.fcx.debug_context.get_ref(bcx.ccx(), span).fn_metadata;\n \n     let argument_index = {\n-        let counter = &mut bcx.fcx.debug_context.get_mut_ref().argument_counter;\n+        let counter = &mut bcx.fcx.debug_context.get_mut_ref(bcx.ccx(), span).argument_counter;\n         let argument_index = *counter;\n         *counter += 1;\n-        argument_index as c_uint\n-    };\n-\n-    let var_metadata = do cx.sess.str_of(special_idents::self_).to_c_str().with_ref |name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateLocalVariable(\n-                DIB(cx),\n-                DW_TAG_arg_variable,\n-                scope,\n-                name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                type_metadata,\n-                false,\n-                0,\n-                argument_index)\n-        }\n+        argument_index\n     };\n \n-    set_debug_location(cx, DebugLocation::new(scope, loc.line, *loc.col));\n-    unsafe {\n-        let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-            DIB(cx),\n-            llptr,\n-            var_metadata,\n-            bcx.llbb);\n-\n-        llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n-    }\n-    set_debug_location(cx, UnknownLocation);\n+    declare_local(bcx,\n+                  llptr,\n+                  special_idents::self_,\n+                  type_of_self,\n+                  scope_metadata,\n+                  DirectVariable,\n+                  ArgumentVariable(argument_index),\n+                  span);\n }\n \n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_argument_metadata(bcx: @mut Block,\n                                 arg: &ast::arg) {\n+    if fn_should_be_ignored(bcx.fcx) {\n+        return;\n+    }\n+\n     let fcx = bcx.fcx;\n     let cx = fcx.ccx;\n \n     let pattern = arg.pat;\n     let filename = span_start(cx, pattern.span).file.name;\n \n-    if fcx.id == -1 ||\n-       fcx.span.is_none() ||\n-       \"<intrinsic>\" == filename {\n-        return;\n-    }\n-\n     let def_map = cx.tcx.def_map;\n     let file_metadata = file_metadata(cx, filename);\n-    let scope = bcx.fcx.debug_context.get_ref().fn_metadata;//create_function_metadata(fcx);\n+    let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n     do pat_util::pat_bindings(def_map, pattern) |_, node_id, span, path_ref| {\n \n-        let ty = node_id_type(bcx, node_id);\n-        let type_metadata = type_metadata(cx, ty, codemap::dummy_sp());\n-        let loc = span_start(cx, span);\n-        let ident = ast_util::path_to_ident(path_ref);\n-        let name: &str = cx.sess.str_of(ident);\n-        debug!(\"create_argument_metadata: %s\", name);\n-\n-        let argument_index = {\n-            let counter = &mut fcx.debug_context.get_mut_ref().argument_counter;\n-            let argument_index = *counter;\n-            *counter += 1;\n-            argument_index as c_uint\n-        };\n-\n-        let arg_metadata = do name.with_c_str |name| {\n-            unsafe {\n-                llvm::LLVMDIBuilderCreateLocalVariable(\n-                    DIB(cx),\n-                    DW_TAG_arg_variable,\n-                    scope,\n-                    name,\n-                    file_metadata,\n-                    loc.line as c_uint,\n-                    type_metadata,\n-                    false,\n-                    0,\n-                    argument_index)\n-            }\n-        };\n-\n         let llptr = match bcx.fcx.llargs.find_copy(&node_id) {\n             Some(v) => v,\n             None => {\n                 bcx.tcx().sess.span_bug(span, fmt!(\"No entry in llargs table for %?\", node_id));\n             }\n         };\n \n-        set_debug_location(cx, DebugLocation::new(scope, loc.line, *loc.col));\n-        unsafe {\n-            let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-                DIB(cx),\n-                llptr,\n-                arg_metadata,\n-                bcx.llbb);\n+        let argument_type = node_id_type(bcx, node_id);\n+        let argument_ident = ast_util::path_to_ident(path_ref);\n \n-            llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n-        }\n-        set_debug_location(cx, UnknownLocation);\n+        let argument_index = {\n+            let counter = &mut fcx.debug_context.get_mut_ref(cx, span).argument_counter;\n+            let argument_index = *counter;\n+            *counter += 1;\n+            argument_index\n+        };\n+\n+        declare_local(bcx,\n+                      llptr,\n+                      argument_ident,\n+                      argument_type,\n+                      scope_metadata,\n+                      DirectVariable,\n+                      ArgumentVariable(argument_index),\n+                      span);\n     }\n }\n \n@@ -296,16 +398,16 @@ pub fn create_argument_metadata(bcx: @mut Block,\n /// reliably find the correct visibility scope for the code position.\n pub fn set_source_location(fcx: &FunctionContext,\n                            node_id: ast::NodeId,\n-                           span: Span) {\n-    let cx: &mut CrateContext = fcx.ccx;\n-\n-    if !cx.sess.opts.debuginfo || (*span.lo == 0 && *span.hi == 0) {\n+                           span: span) {\n+    if fn_should_be_ignored(fcx) {\n         return;\n     }\n \n+    let cx = fcx.ccx;\n+\n     debug!(\"set_source_location: %s\", cx.sess.codemap.span_to_str(span));\n \n-    if fcx.debug_context.get_ref().source_locations_enabled {\n+    if fcx.debug_context.get_ref(cx, span).source_locations_enabled {\n         let loc = span_start(cx, span);\n         let scope = scope_metadata(fcx, node_id, span);\n \n@@ -316,16 +418,23 @@ pub fn set_source_location(fcx: &FunctionContext,\n }\n \n pub fn start_emitting_source_locations(fcx: &mut FunctionContext) {\n-    for debug_context in fcx.debug_context.mut_iter() {\n-        debug_context.source_locations_enabled = true;\n+    match fcx.debug_context {\n+        FunctionDebugContext(~ref mut data) => data.source_locations_enabled = true,\n+        _ => { /* safe to ignore */}\n     }\n }\n \n pub fn create_function_debug_context(cx: &mut CrateContext,\n                                      fn_ast_id: ast::NodeId,\n                                      param_substs: Option<@param_substs>,\n-                                     llfn: ValueRef) -> ~FunctionDebugContext {\n-    assert!(fn_ast_id != -1);\n+                                     llfn: ValueRef) -> FunctionDebugContext {\n+    if !cx.sess.opts.debuginfo {\n+        return DebugInfoDisabled;\n+    }\n+\n+    if fn_ast_id == -1 {\n+        return FunctionWithoutDebugInfo;\n+    }\n \n     let empty_generics = ast::Generics { lifetimes: opt_vec::Empty, ty_params: opt_vec::Empty };\n \n@@ -395,9 +504,18 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n             _) => {\n             (ident, fn_decl, generics, None, span)\n         }\n+        ast_map::node_variant(*)     |\n+        ast_map::node_struct_ctor(*) => {\n+            return FunctionWithoutDebugInfo;\n+        }\n         _ => cx.sess.bug(fmt!(\"create_function_debug_context: unexpected sort of node: %?\", fnitem))\n     };\n \n+    // This can be the case for functions inlined from another crate\n+    if span == codemap::dummy_sp() {\n+        return FunctionWithoutDebugInfo;\n+    }\n+\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n@@ -438,7 +556,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     };\n \n     // Initialize fn debug context (including scope map)\n-    let mut fn_debug_context = ~FunctionDebugContext {\n+    let mut fn_debug_context = ~FunctionDebugContextData {\n         scope_map: HashMap::new(),\n         fn_metadata: fn_metadata,\n         argument_counter: 1,\n@@ -448,7 +566,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n     let arg_pats = do fn_decl.inputs.map |arg_ref| { arg_ref.pat };\n     populate_scope_map(cx, arg_pats, top_level_block, fn_metadata, &mut fn_debug_context.scope_map);\n \n-    return fn_debug_context;\n+    return FunctionDebugContext(fn_debug_context);\n \n     fn get_function_signature(cx: &mut CrateContext,\n                               fn_ast_id: ast::NodeId,\n@@ -631,19 +749,28 @@ fn compile_unit_metadata(cx: @mut CrateContext) {\n     do \"\".with_c_str |flags| {\n     do \"\".with_c_str |split_name| {\n         unsafe {\n-            llvm::LLVMDIBuilderCreateCompileUnit(dcx.builder,\n-                DW_LANG_RUST as c_uint, crate_name, work_dir, producer,\n+            llvm::LLVMDIBuilderCreateCompileUnit(\n+                dcx.builder,\n+                DW_LANG_RUST,\n+                crate_name,\n+                work_dir,\n+                producer,\n                 cx.sess.opts.optimize != session::No,\n-                flags, 0, split_name);\n+                flags,\n+                0,\n+                split_name);\n         }\n     }}}}};\n }\n \n fn declare_local(bcx: @mut Block,\n-                 variable_ident: ast::Ident,\n-                 node_id: ast::NodeId,\n+                 llptr: ValueRef,\n+                 variable_ident: ast::ident,\n                  variable_type: ty::t,\n-                 span: Span) {\n+                 scope_metadata: DIScope,\n+                 variable_access: VariableAccess,\n+                 variable_kind: VariableKind,\n+                 span: span) {\n     let cx: &mut CrateContext = bcx.ccx();\n \n     let filename = span_start(cx, span).file.name;\n@@ -652,32 +779,48 @@ fn declare_local(bcx: @mut Block,\n     let name: &str = cx.sess.str_of(variable_ident);\n     let loc = span_start(cx, span);\n     let type_metadata = type_metadata(cx, variable_type, span);\n-    let scope = scope_metadata(bcx.fcx, node_id, span);\n+\n+    let argument_index = match variable_kind {\n+        ArgumentVariable(index) => index,\n+        LocalVariable    |\n+        CapturedVariable => 0\n+    } as c_uint;\n \n     let var_metadata = do name.with_c_str |name| {\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateLocalVariable(\n-                DIB(cx),\n-                DW_TAG_auto_variable,\n-                scope,\n-                name,\n-                file_metadata,\n-                loc.line as c_uint,\n-                type_metadata,\n-                false,\n-                0,\n-                0)\n-        }\n-    };\n+        match variable_access {\n+            DirectVariable => unsafe {\n+                llvm::LLVMDIBuilderCreateLocalVariable(\n+                    DIB(cx),\n+                    DW_TAG_auto_variable,\n+                    scope_metadata,\n+                    name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    type_metadata,\n+                    cx.sess.opts.optimize != session::No,\n+                    0,\n+                    argument_index)\n+            },\n+            IndirectVariable => unsafe {\n+                let address_op = llvm::LLVMDIBuilderCreateOpDeref(Type::i64().to_ref());\n+                let address_op_count = 1;\n \n-    let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n-        Some(v) => v,\n-        None => {\n-            bcx.tcx().sess.span_bug(span, fmt!(\"No entry in lllocals table for %?\", node_id));\n+                llvm::LLVMDIBuilderCreateComplexVariable(\n+                    DIB(cx),\n+                    DW_TAG_auto_variable,\n+                    scope_metadata,\n+                    name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    type_metadata,\n+                    ptr::to_unsafe_ptr(&address_op),\n+                    address_op_count,\n+                    argument_index)\n+            }\n         }\n     };\n \n-    set_debug_location(cx, DebugLocation::new(scope, loc.line, *loc.col));\n+    set_debug_location(cx, DebugLocation::new(scope_metadata, loc.line, *loc.col));\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n             DIB(cx),\n@@ -687,6 +830,14 @@ fn declare_local(bcx: @mut Block,\n \n         llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n     }\n+\n+    match variable_kind {\n+        ArgumentVariable(_) | CapturedVariable => {\n+            assert!(!bcx.fcx.debug_context.get_ref(cx, span).source_locations_enabled);\n+            set_debug_location(cx, UnknownLocation);\n+        }\n+        _ => { /* fallthrough */ }\n+    }\n }\n \n fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n@@ -720,13 +871,9 @@ fn file_metadata(cx: &mut CrateContext, full_path: &str) -> DIFile {\n /// Finds the scope metadata node for the given AST node.\n fn scope_metadata(fcx: &FunctionContext,\n                   node_id: ast::NodeId,\n-                  span: Span) -> DIScope {\n-    if fcx.debug_context.is_none() {\n-        fcx.ccx.sess.span_bug(span, \"debuginfo: FunctionDebugContext should be initialized \\\n-                                     but is not!\");\n-    }\n-\n-    let scope_map = &fcx.debug_context.get_ref().scope_map;\n+                  span: span)\n+               -> DIScope {\n+    let scope_map = &fcx.debug_context.get_ref(fcx.ccx, span).scope_map;\n \n     match scope_map.find_copy(&node_id) {\n         Some(scope_metadata) => scope_metadata,\n@@ -1260,30 +1407,31 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n     }\n }\n \n-fn bare_fn_metadata(cx: &mut CrateContext,\n-                    _fn_ty: ty::t,\n-                    inputs: ~[ty::t],\n-                    output: ty::t,\n-                    span: Span)\n-                 -> DICompositeType {\n-\n-    debug!(\"bare_fn_metadata: %?\", ty::get(_fn_ty));\n-\n+fn subroutine_type_metadata(cx: &mut CrateContext,\n+                            signature: &ty::FnSig,\n+                            span: span)\n+                         -> DICompositeType {\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n \n-    let nil_pointer_type_metadata = type_metadata(cx, ty::mk_nil_ptr(cx.tcx), span);\n-    let output_metadata = type_metadata(cx, output, span);\n-    let output_ptr_metadata = pointer_type_metadata(cx, output, output_metadata);\n+    let mut signature_metadata: ~[DIType] = vec::with_capacity(signature.inputs.len() + 1);\n+\n+    // return type\n+    signature_metadata.push(match ty::get(signature.output).sty {\n+        ty::ty_nil => ptr::null(),\n+        _ => type_metadata(cx, signature.output, span)\n+    });\n \n-    let inputs_vals = do inputs.map |arg| { type_metadata(cx, *arg, span) };\n-    let members = ~[output_ptr_metadata, nil_pointer_type_metadata] + inputs_vals;\n+    // regular arguments\n+    for &argument_type in signature.inputs.iter() {\n+        signature_metadata.push(type_metadata(cx, argument_type, span));\n+    }\n \n     return unsafe {\n         llvm::LLVMDIBuilderCreateSubroutineType(\n             DIB(cx),\n             file_metadata,\n-            create_DIArray(DIB(cx), members))\n+            create_DIArray(DIB(cx), signature_metadata))\n     };\n }\n \n@@ -1407,13 +1555,10 @@ fn type_metadata(cx: &mut CrateContext,\n             pointer_type_metadata(cx, t, pointee)\n         },\n         ty::ty_bare_fn(ref barefnty) => {\n-            let inputs = barefnty.sig.inputs.map(|a| *a);\n-            let output = barefnty.sig.output;\n-            bare_fn_metadata(cx, t, inputs, output, span)\n+            subroutine_type_metadata(cx, &barefnty.sig, span)\n         },\n-        ty::ty_closure(ref _closurety) => {\n-            cx.sess.span_note(span, \"debuginfo for closure NYI\");\n-            unimplemented_type_metadata(cx, t)\n+        ty::ty_closure(ref closurety) => {\n+            subroutine_type_metadata(cx, &closurety.sig, span)\n         },\n         ty::ty_trait(_did, ref _substs, ref _vstore, _, _bounds) => {\n             cx.sess.span_note(span, \"debuginfo for trait NYI\");\n@@ -1458,7 +1603,6 @@ fn set_debug_location(cx: &mut CrateContext, debug_location: DebugLocation) {\n         return;\n     }\n \n-\n     let metadata_node;\n \n     match debug_location {\n@@ -1524,6 +1668,13 @@ fn assert_fcx_has_span(fcx: &FunctionContext) {\n     }\n }\n \n+fn fn_should_be_ignored(fcx: &FunctionContext) -> bool {\n+    match fcx.debug_context {\n+        FunctionDebugContext(_) => false,\n+        _ => true\n+    }\n+}\n+\n // This procedure builds the *scope map* for a given function, which maps any given ast::NodeId in\n // the function's AST to the correct DIScope metadata instance.\n //"}, {"sha": "518d0fb0c38ca1e90b8cb394b57e1896803dead4", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=b81ea86530dfd9dff69815b099ba10be274830ea", "patch": "@@ -73,7 +73,7 @@ pub enum ast_node {\n     node_variant(variant, @item, @path),\n     node_expr(@Expr),\n     node_stmt(@Stmt),\n-    node_arg,\n+    node_arg(@pat),\n     node_local(Ident),\n     node_block(Block),\n     node_struct_ctor(@struct_def, @item, @path),\n@@ -171,7 +171,7 @@ impl Ctx {\n               sp: codemap::Span,\n               id: NodeId) {\n         for a in decl.inputs.iter() {\n-            self.map.insert(a.id, node_arg);\n+            self.map.insert(a.id, node_arg(a.pat));\n         }\n         visit::walk_fn(self, fk, decl, body, sp, id, ());\n     }\n@@ -487,8 +487,8 @@ pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n         fmt!(\"stmt %s (id=%?)\",\n              pprust::stmt_to_str(stmt, itr), id)\n       }\n-      Some(&node_arg) => {\n-        fmt!(\"arg (id=%?)\", id)\n+      Some(&node_arg(pat)) => {\n+        fmt!(\"arg %s (id=%?)\", pprust::pat_to_str(pat, itr), id)\n       }\n       Some(&node_local(ident)) => {\n         fmt!(\"local (id=%?, name=%s)\", id, itr.get(ident.name))"}, {"sha": "376adf24e25fde94c6ea49870355104084b7a944", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=b81ea86530dfd9dff69815b099ba10be274830ea", "patch": "@@ -724,3 +724,39 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateTemplateTypeParameter(\n       LineNo,\n       ColumnNo));\n }\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateOpDeref(LLVMTypeRef IntTy)\n+{\n+    return LLVMConstInt(IntTy, DIBuilder::OpDeref, true);\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateOpPlus(LLVMTypeRef IntTy)\n+{\n+    return LLVMConstInt(IntTy, DIBuilder::OpPlus, true);\n+}\n+\n+extern \"C\" LLVMValueRef LLVMDIBuilderCreateComplexVariable(\n+    DIBuilderRef Builder,\n+    unsigned Tag,\n+    LLVMValueRef Scope,\n+    const char *Name,\n+    LLVMValueRef File,\n+    unsigned LineNo,\n+    LLVMValueRef Ty,\n+    LLVMValueRef* AddrOps,\n+    unsigned AddrOpsCount,\n+    unsigned ArgNo)\n+{\n+    llvm::ArrayRef<llvm::Value*> addr_ops((llvm::Value**)AddrOps, AddrOpsCount);\n+\n+    return wrap(Builder->createComplexVariable(\n+        Tag,\n+        unwrapDI<DIDescriptor>(Scope),\n+        Name,\n+        unwrapDI<DIFile>(File),\n+        LineNo,\n+        unwrapDI<DIType>(Ty),\n+        addr_ops,\n+        ArgNo\n+    ));\n+}"}, {"sha": "37f5fef471b6dfd987eb5b0916e8f2acaadc761c", "filename": "src/test/debug-info/var-captured-in-managed-closure.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Ftest%2Fdebug-info%2Fvar-captured-in-managed-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Ftest%2Fdebug-info%2Fvar-captured-in-managed-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvar-captured-in-managed-closure.rs?ref=b81ea86530dfd9dff69815b099ba10be274830ea", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print constant\n+// check:$1 = 1\n+// debugger:print a_struct\n+// check:$2 = {a = -2, b = 3.5, c = 4}\n+// debugger:print *owned\n+// check:$3 = 5\n+// debugger:print managed->val\n+// check:$4 = 6\n+\n+#[allow(unused_variable)];\n+\n+struct Struct {\n+    a: int,\n+    b: float,\n+    c: uint\n+}\n+\n+fn main() {\n+    let constant = 1;\n+\n+    let a_struct = Struct {\n+        a: -2,\n+        b: 3.5,\n+        c: 4\n+    };\n+\n+    let owned = ~5;\n+    let managed = @6;\n+\n+    let closure: @fn() = || {\n+        zzz();\n+        do_something(&constant, &a_struct.a, owned, managed);\n+    };\n+\n+    closure();\n+}\n+\n+fn do_something(_: &int, _:&int, _:&int, _:&int) {\n+}\n+\n+fn zzz() {()}"}, {"sha": "c4568bd592fa610538fe8883786ff553cd3f2fab", "filename": "src/test/debug-info/var-captured-in-sendable-closure.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Ftest%2Fdebug-info%2Fvar-captured-in-sendable-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Ftest%2Fdebug-info%2Fvar-captured-in-sendable-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvar-captured-in-sendable-closure.rs?ref=b81ea86530dfd9dff69815b099ba10be274830ea", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print constant\n+// check:$1 = 1\n+// debugger:print a_struct\n+// check:$2 = {a = -2, b = 3.5, c = 4}\n+// debugger:print *owned\n+// check:$3 = 5\n+\n+#[allow(unused_variable)];\n+\n+struct Struct {\n+    a: int,\n+    b: float,\n+    c: uint\n+}\n+\n+fn main() {\n+    let constant = 1;\n+\n+    let a_struct = Struct {\n+        a: -2,\n+        b: 3.5,\n+        c: 4\n+    };\n+\n+    let owned = ~5;\n+\n+    let closure: ~fn() = || {\n+        zzz();\n+        do_something(&constant, &a_struct.a, owned);\n+    };\n+\n+    closure();\n+}\n+\n+fn do_something(_: &int, _:&int, _:&int) {\n+\n+}\n+\n+fn zzz() {()}"}, {"sha": "6694d5111a83560467aa81e57d360a8748c7768c", "filename": "src/test/debug-info/var-captured-in-stack-closure.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Ftest%2Fdebug-info%2Fvar-captured-in-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b81ea86530dfd9dff69815b099ba10be274830ea/src%2Ftest%2Fdebug-info%2Fvar-captured-in-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fvar-captured-in-stack-closure.rs?ref=b81ea86530dfd9dff69815b099ba10be274830ea", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-win32 Broken because of LLVM bug: http://llvm.org/bugs/show_bug.cgi?id=16249\n+\n+// compile-flags:-Z extra-debug-info\n+// debugger:break zzz\n+// debugger:run\n+// debugger:finish\n+\n+// debugger:print variable\n+// check:$1 = 1\n+// debugger:print constant\n+// check:$2 = 2\n+// debugger:print a_struct\n+// check:$3 = {a = -3, b = 4.5, c = 5}\n+// debugger:print *struct_ref\n+// check:$4 = {a = -3, b = 4.5, c = 5}\n+// debugger:print *owned\n+// check:$5 = 6\n+// debugger:print managed->val\n+// check:$6 = 7\n+\n+#[allow(unused_variable)];\n+\n+struct Struct {\n+    a: int,\n+    b: float,\n+    c: uint\n+}\n+\n+fn main() {\n+    let mut variable = 1;\n+    let constant = 2;\n+\n+    let a_struct = Struct {\n+        a: -3,\n+        b: 4.5,\n+        c: 5\n+    };\n+\n+    let struct_ref = &a_struct;\n+    let owned = ~6;\n+    let managed = @7;\n+\n+    let closure = || {\n+        zzz();\n+        variable = constant + a_struct.a + struct_ref.a + *owned + *managed;\n+    };\n+\n+    closure();\n+}\n+\n+fn zzz() {()}"}]}