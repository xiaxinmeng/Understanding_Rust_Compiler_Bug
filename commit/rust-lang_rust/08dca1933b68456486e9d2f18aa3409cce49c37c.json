{"sha": "08dca1933b68456486e9d2f18aa3409cce49c37c", "node_id": "C_kwDOAAsO6NoAKDA4ZGNhMTkzM2I2ODQ1NjQ4NmU5ZDJmMThhYTM0MDljY2U0OWMzN2M", "commit": {"author": {"name": "Ibraheem Ahmed", "email": "ibrah1440@gmail.com", "date": "2021-12-08T02:01:10Z"}, "committer": {"name": "Ibraheem Ahmed", "email": "ibrah1440@gmail.com", "date": "2021-12-08T02:07:47Z"}, "message": "generate `MaybeDone` futures inline `join`", "tree": {"sha": "c7b1b3f6db6aa35e5da69379ca0d938118d19810", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7b1b3f6db6aa35e5da69379ca0d938118d19810"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08dca1933b68456486e9d2f18aa3409cce49c37c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08dca1933b68456486e9d2f18aa3409cce49c37c", "html_url": "https://github.com/rust-lang/rust/commit/08dca1933b68456486e9d2f18aa3409cce49c37c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08dca1933b68456486e9d2f18aa3409cce49c37c/comments", "author": {"login": "ibraheemdev", "id": 34988408, "node_id": "MDQ6VXNlcjM0OTg4NDA4", "avatar_url": "https://avatars.githubusercontent.com/u/34988408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibraheemdev", "html_url": "https://github.com/ibraheemdev", "followers_url": "https://api.github.com/users/ibraheemdev/followers", "following_url": "https://api.github.com/users/ibraheemdev/following{/other_user}", "gists_url": "https://api.github.com/users/ibraheemdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibraheemdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibraheemdev/subscriptions", "organizations_url": "https://api.github.com/users/ibraheemdev/orgs", "repos_url": "https://api.github.com/users/ibraheemdev/repos", "events_url": "https://api.github.com/users/ibraheemdev/events{/privacy}", "received_events_url": "https://api.github.com/users/ibraheemdev/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibraheemdev", "id": 34988408, "node_id": "MDQ6VXNlcjM0OTg4NDA4", "avatar_url": "https://avatars.githubusercontent.com/u/34988408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibraheemdev", "html_url": "https://github.com/ibraheemdev", "followers_url": "https://api.github.com/users/ibraheemdev/followers", "following_url": "https://api.github.com/users/ibraheemdev/following{/other_user}", "gists_url": "https://api.github.com/users/ibraheemdev/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibraheemdev/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibraheemdev/subscriptions", "organizations_url": "https://api.github.com/users/ibraheemdev/orgs", "repos_url": "https://api.github.com/users/ibraheemdev/repos", "events_url": "https://api.github.com/users/ibraheemdev/events{/privacy}", "received_events_url": "https://api.github.com/users/ibraheemdev/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d761e84968de093ac2e0850293af1057b6fb44ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/d761e84968de093ac2e0850293af1057b6fb44ee", "html_url": "https://github.com/rust-lang/rust/commit/d761e84968de093ac2e0850293af1057b6fb44ee"}], "stats": {"total": 110, "additions": 47, "deletions": 63}, "files": [{"sha": "03d106c969bd8618b88a3a8ff0d8b4d6121a44b7", "filename": "library/core/src/future/join.rs", "status": "modified", "additions": 47, "deletions": 63, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/08dca1933b68456486e9d2f18aa3409cce49c37c/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08dca1933b68456486e9d2f18aa3409cce49c37c/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffuture%2Fjoin.rs?ref=08dca1933b68456486e9d2f18aa3409cce49c37c", "patch": "@@ -4,6 +4,7 @@ use crate::cell::UnsafeCell;\n use crate::future::{poll_fn, Future};\n use crate::pin::Pin;\n use crate::task::Poll;\n+\n /// Polls multiple futures simultaneously, returning a tuple\n /// of all results once complete.\n ///\n@@ -53,95 +54,78 @@ pub macro join {\n         @count: ($($count:tt)*),\n         // Futures and their positions in the tuple: \"{ a => (_), b => (_ _)) }\"\n         @futures: { $($fut:tt)* },\n-        // The future currently being expanded, and the rest\n+        // Take a future from @rest to expand\n         @rest: ($current:expr, $($rest:tt)*)\n     ) => {\n         join! {\n-            @count: ($($count)* _), // Add to the count\n-            @futures: { $($fut)* $current => ($($count)*), }, // Add the future from @rest with it's position\n-            @rest: ($($rest)*) // And leave the rest\n+            @count: ($($count)* _),\n+            @futures: { $($fut)* $current => ($($count)*), },\n+            @rest: ($($rest)*)\n         }\n     },\n     // Now generate the output future\n     (\n         @count: ($($count:tt)*),\n         @futures: {\n-            $( $fut:expr => ( $($pos:tt)* ), )*\n+            $( $(@$f:tt)? $fut:expr => ( $($pos:tt)* ), )*\n         },\n         @rest: ()\n     ) => {{\n-        let mut futures = ( $( MaybeDone::Future($fut), )* );\n+        // The futures and whether they have completed\n+        let mut state = ( $( UnsafeCell::new(($fut, false)), )* );\n+\n+        // Make sure the futures don't panic\n+        // if polled after completion, and\n+        // store their output separately\n+        let mut futures = ($(\n+            ({\n+                let ( $($pos,)* state, .. ) = &state;\n+\n+                poll_fn(move |cx| {\n+                    // SAFETY: each future borrows a distinct element\n+                    // of the tuple\n+                    let (fut, done) = unsafe { &mut *state.get() };\n+\n+                    if *done {\n+                        return Poll::Ready(None)\n+                    }\n+\n+                    // SAFETY: The futures are never moved\n+                    match unsafe { Pin::new_unchecked(fut).poll(cx) } {\n+                        Poll::Ready(val) => {\n+                            *done = true;\n+                            Poll::Ready(Some(val))\n+                        }\n+                        Poll::Pending => Poll::Pending\n+                    }\n+                })\n+            }, None),\n+        )*);\n \n         poll_fn(move |cx| {\n             let mut done = true;\n \n             $(\n-                // Extract the future from the tuple\n-                let ( $($pos,)* fut, .. ) = &mut futures;\n+                let ( $($pos,)* (fut, out), .. ) = &mut futures;\n \n-                // SAFETY: the futures are never moved\n-                done &= unsafe { Pin::new_unchecked(fut).poll(cx).is_ready() };\n+                // SAFETY: The futures are never moved\n+                match unsafe { Pin::new_unchecked(fut).poll(cx) } {\n+                    Poll::Ready(Some(val)) => *out = Some(val),\n+                    // the future was already done\n+                    Poll::Ready(None) => {},\n+                    Poll::Pending => done = false,\n+                }\n             )*\n \n             if done {\n+                // Extract all the outputs\n                 Poll::Ready(($({\n-                    let ( $($pos,)* fut, .. ) = &mut futures;\n-\n-                    // SAFETY: the futures are never moved\n-                    unsafe { Pin::new_unchecked(fut).take_output().unwrap() }\n+                    let ( $($pos,)* (_, val), .. ) = &mut futures;\n+                    val.unwrap()\n                 }),*))\n             } else {\n                 Poll::Pending\n             }\n         }).await\n     }}\n }\n-\n-/// Future used by `join!` that stores it's output to\n-/// be later taken and doesn't panic when polled after ready.\n-#[allow(dead_code)]\n-#[unstable(feature = \"future_join\", issue = \"none\")]\n-enum MaybeDone<F: Future> {\n-    Future(F),\n-    Done(F::Output),\n-    Took,\n-}\n-\n-#[unstable(feature = \"future_join\", issue = \"none\")]\n-impl<F: Future + Unpin> Unpin for MaybeDone<F> {}\n-\n-#[unstable(feature = \"future_join\", issue = \"none\")]\n-impl<F: Future> MaybeDone<F> {\n-    #[allow(dead_code)]\n-    fn take_output(self: Pin<&mut Self>) -> Option<F::Output> {\n-        unsafe {\n-            match &*self {\n-                MaybeDone::Done(_) => match mem::replace(self.get_unchecked_mut(), Self::Took) {\n-                    MaybeDone::Done(val) => Some(val),\n-                    _ => unreachable!(),\n-                },\n-                _ => None,\n-            }\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"future_join\", issue = \"none\")]\n-impl<F: Future> Future for MaybeDone<F> {\n-    type Output = ();\n-\n-    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n-        unsafe {\n-            match self.as_mut().get_unchecked_mut() {\n-                MaybeDone::Future(f) => match Pin::new_unchecked(f).poll(cx) {\n-                    Poll::Ready(val) => self.set(Self::Done(val)),\n-                    Poll::Pending => return Poll::Pending,\n-                },\n-                MaybeDone::Done(_) => {}\n-                MaybeDone::Took => unreachable!(),\n-            }\n-        }\n-\n-        Poll::Ready(())\n-    }\n-}"}]}