{"sha": "71409184dc00604537ce03312dc17ba986c329d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNDA5MTg0ZGMwMDYwNDUzN2NlMDMzMTJkYzE3YmE5ODZjMzI5ZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-01T17:15:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-01T17:15:29Z"}, "message": "Auto merge of #29177 - vadimcn:rtstuff, r=alexcrichton\n\nNote: for now, this change only affects `-windows-gnu` builds.\r\n\r\nSo why was this `libgcc` dylib dependency needed in the first place?\r\nThe stack unwinder needs to know about locations of unwind tables of all the modules loaded in the current process.  The easiest portable way of achieving this is to have each module register itself with the unwinder when loaded into the process.  All modules compiled by GCC do this by calling the __register_frame_info() in their startup code (that's `crtbegin.o` and `crtend.o`, which are automatically linked into any gcc output).\r\nAnother important piece is that there should be only one copy of the unwinder (and thus unwind tables registry) in the process.  This pretty much means that the unwinder must be in a shared library (unless everything is statically linked). \r\n\r\nNow, Rust compiler tries very hard to make sure that any given Rust crate appears in the final output just once.   So if we link the unwinder statically to one of Rust's crates, everything should be fine.\r\n\r\nUnfortunately, GCC startup objects are built under assumption that `libgcc` is the one true place for the unwind info registry, so I couldn't find any better way than to replace them.  So out go `crtbegin`/`crtend`, in come `rsbegin`/`rsend`!  \r\n\r\nA side benefit of this change is that rustc is now more in control of the command line that goes to the linker, so we could stop using `gcc` as the linker driver and just invoke `ld` directly.", "tree": {"sha": "ca73303814b925bd964ae123c4a288defc506057", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca73303814b925bd964ae123c4a288defc506057"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71409184dc00604537ce03312dc17ba986c329d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71409184dc00604537ce03312dc17ba986c329d9", "html_url": "https://github.com/rust-lang/rust/commit/71409184dc00604537ce03312dc17ba986c329d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71409184dc00604537ce03312dc17ba986c329d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d43fef3aaf64b2e7df14ca676a3a39b723ed7f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d43fef3aaf64b2e7df14ca676a3a39b723ed7f3", "html_url": "https://github.com/rust-lang/rust/commit/6d43fef3aaf64b2e7df14ca676a3a39b723ed7f3"}, {"sha": "0332ee9f6336c17e8e8e7524cd2db1c6a92c1a30", "url": "https://api.github.com/repos/rust-lang/rust/commits/0332ee9f6336c17e8e8e7524cd2db1c6a92c1a30", "html_url": "https://github.com/rust-lang/rust/commit/0332ee9f6336c17e8e8e7524cd2db1c6a92c1a30"}], "stats": {"total": 518, "additions": 383, "deletions": 135}, "files": [{"sha": "ced8bf43163e7049fcd70e40fe39b382f896af55", "filename": "mk/cfg/i686-pc-windows-gnu.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/mk%2Fcfg%2Fi686-pc-windows-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/mk%2Fcfg%2Fi686-pc-windows-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-pc-windows-gnu.mk?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -22,3 +22,4 @@ CFG_LDPATH_i686-pc-windows-gnu :=\n CFG_RUN_i686-pc-windows-gnu=$(2)\n CFG_RUN_TARG_i686-pc-windows-gnu=$(call CFG_RUN_i686-pc-windows-gnu,,$(2))\n CFG_GNU_TRIPLE_i686-pc-windows-gnu := i686-w64-mingw32\n+CFG_LIBC_STARTUP_OBJECTS_i686-pc-windows-gnu := crt2.o dllcrt2.o"}, {"sha": "0f49b6d585c6e9571eb66429a1ac5224e7dbe01b", "filename": "mk/cfg/x86_64-pc-windows-gnu.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fx86_64-pc-windows-gnu.mk?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -22,3 +22,4 @@ CFG_LDPATH_x86_64-pc-windows-gnu :=\n CFG_RUN_x86_64-pc-windows-gnu=$(2)\n CFG_RUN_TARG_x86_64-pc-windows-gnu=$(call CFG_RUN_x86_64-pc-windows-gnu,,$(2))\n CFG_GNU_TRIPLE_x86_64-pc-windows-gnu := x86_64-w64-mingw32\n+CFG_LIBC_STARTUP_OBJECTS_x86_64-pc-windows-gnu := crt2.o dllcrt2.o\n\\ No newline at end of file"}, {"sha": "5caf8d8e81eda9623f138691b1259abdf47d7f01", "filename": "mk/target.mk", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/mk%2Ftarget.mk", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/mk%2Ftarget.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftarget.mk?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -132,6 +132,73 @@ $$(TBIN$(1)_T_$(2)_H_$(3))/$(4)$$(X_$(2)): \\\n \n endef\n \n+# Macro for building runtime startup objects\n+# Of those we have two kinds:\n+# - Rust runtime-specific: these are Rust's equivalents of GCC's crti.o/crtn.o,\n+# - LibC-specific: these we don't build ourselves, but copy them from the system lib directory.\n+#\n+# $(1) - stage\n+# $(2) - target triple\n+# $(3) - host triple\n+define TARGET_RT_STARTUP\n+\n+# Expand build rules for rsbegin.o and rsend.o\n+$$(foreach obj,rsbegin rsend, \\\n+\t$$(eval $$(call TARGET_RUSTRT_STARTUP_OBJ,$(1),$(2),$(3),$$(obj))) )\n+\n+# Expand build rules for libc startup objects\n+$$(foreach obj,$$(CFG_LIBC_STARTUP_OBJECTS_$(2)), \\\n+\t$$(eval $$(call TARGET_LIBC_STARTUP_OBJ,$(1),$(2),$(3),$$(obj))) )\n+\n+endef\n+\n+# Macro for building runtime startup/shutdown object files;\n+# these are Rust's equivalent of crti.o, crtn.o\n+#\n+# $(1) - stage\n+# $(2) - target triple\n+# $(3) - host triple\n+# $(4) - object basename\n+define TARGET_RUSTRT_STARTUP_OBJ\n+\n+$$(TLIB$(1)_T_$(2)_H_$(3))/$(4).o: \\\n+\t\t$(S)src/rtstartup/$(4).rs \\\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.core \\\n+\t\t$$(HSREQ$(1)_T_$(2)_H_$(3)) \\\n+\t\t| $$(TBIN$(1)_T_$(2)_H_$(3))/\n+\t@$$(call E, rustc: $$@)\n+\t$$(STAGE$(1)_T_$(2)_H_$(3)) --emit=obj -o $$@ $$<\n+\n+# Add dependencies on Rust startup objects to all crates that depend on core.\n+# This ensures that they are built after core (since they depend on it),\n+# but before everything else (since they are needed for linking dylib crates).\n+$$(foreach crate, $$(TARGET_CRATES), \\\n+\t$$(if $$(findstring core,$$(DEPS_$$(crate))), \\\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.$$(crate))) : $$(TLIB$(1)_T_$(2)_H_$(3))/$(4).o\n+\n+endef\n+\n+# Macro for copying libc startup objects into the target's lib directory.\n+#\n+# $(1) - stage\n+# $(2) - target triple\n+# $(3) - host triple\n+# $(4) - object name\n+define TARGET_LIBC_STARTUP_OBJ\n+\n+# Ask gcc where the startup object is located\n+$$(TLIB$(1)_T_$(2)_H_$(3))/$(4) : $$(shell $$(CC_$(2)) -print-file-name=$(4))\n+\t@$$(call E, cp: $$@)\n+\t@cp $$^ $$@\n+\n+# Make sure this is done before libcore has finished building\n+# (libcore itself does not depend on these objects, but other crates do,\n+#  so might as well do it here)\n+$$(TLIB$(1)_T_$(2)_H_$(3))/stamp.core : $$(TLIB$(1)_T_$(2)_H_$(3))/$(4)\n+\n+endef\n+\n+\n # Every recipe in RUST_TARGET_STAGE_N outputs to $$(TLIB$(1)_T_$(2)_H_$(3),\n # a directory that can be cleaned out during the middle of a run of\n # the get-snapshot.py script.  Therefore, every recipe needs to have\n@@ -174,3 +241,8 @@ $(foreach host,$(CFG_HOST), \\\n   $(foreach stage,$(STAGES), \\\n    $(foreach tool,$(TOOLS), \\\n     $(eval $(call TARGET_TOOL,$(stage),$(target),$(host),$(tool)))))))\n+\n+$(foreach host,$(CFG_HOST), \\\n+ $(foreach target,$(CFG_TARGET), \\\n+  $(foreach stage,$(STAGES), \\\n+   \t$(eval $(call TARGET_RT_STARTUP,$(stage),$(target),$(host))))))"}, {"sha": "6b19abc728caf1435130fd0932ae0afa70cc8f61", "filename": "src/doc/trpl/custom-allocators.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Fdoc%2Ftrpl%2Fcustom-allocators.md", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Fdoc%2Ftrpl%2Fcustom-allocators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcustom-allocators.md?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -140,6 +140,8 @@ pub extern fn __rust_usable_size(size: usize, _align: usize) -> usize {\n # #[lang = \"panic_fmt\"] fn panic_fmt() {}\n # #[lang = \"eh_personality\"] fn eh_personality() {}\n # #[lang = \"eh_unwind_resume\"] extern fn eh_unwind_resume() {}\n+# #[no_mangle] pub extern fn rust_eh_register_frames () {}\n+# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}\n ```\n \n After we compile this crate, it can be used as follows:"}, {"sha": "76b9f82827bbbc33cd16e995a783b5d817753493", "filename": "src/doc/trpl/lang-items.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Fdoc%2Ftrpl%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Fdoc%2Ftrpl%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flang-items.md?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -54,6 +54,8 @@ fn main(argc: isize, argv: *const *const u8) -> isize {\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n # #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n+# #[no_mangle] pub extern fn rust_eh_register_frames () {}\n+# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}\n ```\n \n Note the use of `abort`: the `exchange_malloc` lang item is assumed to"}, {"sha": "0040878fb2f4f19057a509dde4f5b06e34a0ec66", "filename": "src/doc/trpl/no-stdlib.md", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fno-stdlib.md?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -34,6 +34,8 @@ fn start(_argc: isize, _argv: *const *const u8) -> isize {\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n # #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n+# #[no_mangle] pub extern fn rust_eh_register_frames () {}\n+# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}\n # // fn main() {} tricked you, rustdoc!\n ```\n \n@@ -60,6 +62,8 @@ pub extern fn main(argc: i32, argv: *const *const u8) -> i32 {\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n # #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n+# #[no_mangle] pub extern fn rust_eh_register_frames () {}\n+# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}\n # // fn main() {} tricked you, rustdoc!\n ```\n \n@@ -145,8 +149,10 @@ extern fn panic_fmt(args: &core::fmt::Arguments,\n }\n \n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n-# #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n # #[start] fn start(argc: isize, argv: *const *const u8) -> isize { 0 }\n+# #[lang = \"eh_unwind_resume\"] extern fn rust_eh_unwind_resume() {}\n+# #[no_mangle] pub extern fn rust_eh_register_frames () {}\n+# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}\n # fn main() {}\n ```\n "}, {"sha": "fa12bbd89323c78e2a56e758b48468e0a337747c", "filename": "src/librustc_back/target/i686_pc_windows_gnu.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -11,17 +11,12 @@\n use target::Target;\n \n pub fn target() -> Target {\n-    let mut options = super::windows_base::opts();\n-    options.cpu = \"pentium4\".to_string();\n+    let mut base = super::windows_base::opts();\n+    base.cpu = \"pentium4\".to_string();\n \n     // Mark all dynamic libraries and executables as compatible with the larger 4GiB address\n     // space available to x86 Windows binaries on x86_64.\n-    options.pre_link_args.push(\"-Wl,--large-address-aware\".to_string());\n-\n-    // Make sure that we link to the dynamic libgcc, otherwise cross-module\n-    // DWARF stack unwinding will not work.\n-    // This behavior may be overridden by -Clink-args=\"-static-libgcc\"\n-    options.pre_link_args.push(\"-shared-libgcc\".to_string());\n+    base.pre_link_args.push(\"-Wl,--large-address-aware\".to_string());\n \n     Target {\n         llvm_target: \"i686-pc-windows-gnu\".to_string(),\n@@ -31,6 +26,6 @@ pub fn target() -> Target {\n         target_os: \"windows\".to_string(),\n         target_env: \"gnu\".to_string(),\n         target_vendor: \"pc\".to_string(),\n-        options: options,\n+        options: base,\n     }\n }"}, {"sha": "9efbeb93d2acec3252f54e2bf9f5c1edeb28063f", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -98,16 +98,25 @@ pub struct TargetOptions {\n     pub linker: String,\n     /// Archive utility to use when managing archives. Defaults to \"ar\".\n     pub ar: String,\n+\n     /// Linker arguments that are unconditionally passed *before* any\n     /// user-defined libraries.\n     pub pre_link_args: Vec<String>,\n+    /// Objects to link before all others, always found within the\n+    /// sysroot folder.\n+    pub pre_link_objects_exe: Vec<String>, // ... when linking an executable\n+    pub pre_link_objects_dll: Vec<String>, // ... when linking a dylib\n+    /// Linker arguments that are unconditionally passed after any\n+    /// user-defined but before post_link_objects.  Standard platform\n+    /// libraries that should be always be linked to, usually go here.\n+    pub late_link_args: Vec<String>,\n+    /// Objects to link after all others, always found within the\n+    /// sysroot folder.\n+    pub post_link_objects: Vec<String>,\n     /// Linker arguments that are unconditionally passed *after* any\n     /// user-defined libraries.\n     pub post_link_args: Vec<String>,\n-    /// Objects to link before and after all others, always found within the\n-    /// sysroot folder.\n-    pub pre_link_objects: Vec<String>,\n-    pub post_link_objects: Vec<String>,\n+\n     /// Default CPU to pass to LLVM. Corresponds to `llc -mcpu=$cpu`. Defaults\n     /// to \"default\".\n     pub cpu: String,\n@@ -219,8 +228,10 @@ impl Default for TargetOptions {\n             no_compiler_rt: false,\n             no_default_libraries: true,\n             position_independent_executables: false,\n-            pre_link_objects: Vec::new(),\n+            pre_link_objects_exe: Vec::new(),\n+            pre_link_objects_dll: Vec::new(),\n             post_link_objects: Vec::new(),\n+            late_link_args: Vec::new(),\n             archive_format: String::new(),\n             custom_unwind_resume: false,\n             lib_allocation_crate: \"alloc_system\".to_string(),"}, {"sha": "634a63cf0bb34c5fdc7ca211bf666fd4bb8ff4d2", "filename": "src/librustc_back/target/windows_base.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_base.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -23,10 +23,7 @@ pub fn opts() -> TargetOptions {\n         exe_suffix: \".exe\".to_string(),\n         staticlib_prefix: \"\".to_string(),\n         staticlib_suffix: \".lib\".to_string(),\n-        // Unfortunately right now passing -nodefaultlibs to gcc on windows\n-        // doesn't work so hot (in terms of native dependencies). This flag\n-        // should hopefully be removed one day though!\n-        no_default_libraries: false,\n+        no_default_libraries: true,\n         is_like_windows: true,\n         archive_format: \"gnu\".to_string(),\n         pre_link_args: vec!(\n@@ -63,7 +60,30 @@ pub fn opts() -> TargetOptions {\n \n             // Always enable DEP (NX bit) when it is available\n             \"-Wl,--nxcompat\".to_string(),\n+\n+            // Do not use the standard system startup files or libraries when linking\n+            \"-nostdlib\".to_string(),\n+        ),\n+        pre_link_objects_exe: vec!(\n+            \"crt2.o\".to_string(),    // mingw C runtime initialization for executables\n+            \"rsbegin.o\".to_string(), // Rust compiler runtime initialization, see rsbegin.rs\n+        ),\n+        pre_link_objects_dll: vec!(\n+            \"dllcrt2.o\".to_string(), // mingw C runtime initialization for dlls\n+            \"rsbegin.o\".to_string(),\n+        ),\n+        late_link_args: vec!(\n+            \"-lmingwex\".to_string(),\n+            \"-lmingw32\".to_string(),\n+            \"-lgcc\".to_string(), // alas, mingw* libraries above depend on libgcc\n+            \"-lmsvcrt\".to_string(),\n+            \"-luser32\".to_string(),\n+            \"-lkernel32\".to_string(),\n+        ),\n+        post_link_objects: vec!(\n+            \"rsend.o\".to_string()\n         ),\n+        custom_unwind_resume: true,\n         exe_allocation_crate: super::maybe_jemalloc(),\n \n         .. Default::default()"}, {"sha": "3e8438539156f02f0909616abfe820be230e77b0", "filename": "src/librustc_back/target/x86_64_pc_windows_gnu.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -13,10 +13,7 @@ use target::Target;\n pub fn target() -> Target {\n     let mut base = super::windows_base::opts();\n     base.cpu = \"x86-64\".to_string();\n-    // On Win64 unwinding is handled by the OS, so we can link libgcc statically.\n-    base.pre_link_args.push(\"-static-libgcc\".to_string());\n     base.pre_link_args.push(\"-m64\".to_string());\n-    base.custom_unwind_resume = true;\n \n     Target {\n         llvm_target: \"x86_64-pc-windows-gnu\".to_string(),"}, {"sha": "dafbb924a9ca5739b5a3e397bd40d6329700565d", "filename": "src/librustc_back/target/x86_64_unknown_linux_musl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_musl.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -58,8 +58,8 @@ pub fn target() -> Target {\n     //\n     // Each target directory for musl has these object files included in it so\n     // they'll be included from there.\n-    base.pre_link_objects.push(\"crt1.o\".to_string());\n-    base.pre_link_objects.push(\"crti.o\".to_string());\n+    base.pre_link_objects_exe.push(\"crt1.o\".to_string());\n+    base.pre_link_objects_exe.push(\"crti.o\".to_string());\n     base.post_link_objects.push(\"crtn.o\".to_string());\n \n     // MUSL support doesn't currently include dynamic linking, so there's no"}, {"sha": "f44f47bb785237142db479a63e1a6ab7246f5a16", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -852,7 +852,13 @@ fn link_natively(sess: &Session, dylib: bool,\n \n     let root = sess.target_filesearch(PathKind::Native).get_lib_path();\n     cmd.args(&sess.target.target.options.pre_link_args);\n-    for obj in &sess.target.target.options.pre_link_objects {\n+\n+    let pre_link_objects = if dylib {\n+        &sess.target.target.options.pre_link_objects_dll\n+    } else {\n+        &sess.target.target.options.pre_link_objects_exe\n+    };\n+    for obj in pre_link_objects {\n         cmd.arg(root.join(obj));\n     }\n \n@@ -868,6 +874,7 @@ fn link_natively(sess: &Session, dylib: bool,\n             linker.link_staticlib(\"compiler-rt\");\n         }\n     }\n+    cmd.args(&sess.target.target.options.late_link_args);\n     for obj in &sess.target.target.options.post_link_objects {\n         cmd.arg(root.join(obj));\n     }"}, {"sha": "46a4cb0c92ee7ee3738b8532aa7e9ebc01d36aee", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -943,6 +943,19 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n     Call(cx, lifetime_end, &[C_u64(ccx, size), ptr], None, DebugLoc::None);\n }\n \n+// Generates code for resumption of unwind at the end of a landing pad.\n+pub fn trans_unwind_resume(bcx: Block, lpval: ValueRef) {\n+    if !bcx.sess().target.target.options.custom_unwind_resume {\n+        Resume(bcx, lpval);\n+    } else {\n+        let exc_ptr = ExtractValue(bcx, lpval, 0);\n+        let llunwresume = bcx.fcx.eh_unwind_resume();\n+        Call(bcx, llunwresume, &[exc_ptr], None, DebugLoc::None);\n+        Unreachable(bcx);\n+    }\n+}\n+\n+\n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();"}, {"sha": "ffdc2701f8158fc189a9ab3fff4ef709cb87b396", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -732,7 +732,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                             \"create_landing_pad() should have set this\");\n                         let lp = build::Load(prev_bcx, personality);\n                         base::call_lifetime_end(prev_bcx, personality);\n-                        build::Resume(prev_bcx, lp);\n+                        base::trans_unwind_resume(prev_bcx, lp);\n                         prev_llbb = prev_bcx.llbb;\n                         break;\n                     }\n@@ -845,8 +845,6 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n \n         debug!(\"get_or_create_landing_pad\");\n \n-        self.inject_unwind_resume_hook();\n-\n         // Check if a landing pad block exists; if not, create one.\n         {\n             let mut scopes = self.scopes.borrow_mut();"}, {"sha": "b39b7818a6350f7d66d521c46a44598168cb75a5", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 24, "deletions": 44, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -561,53 +561,33 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         }\n     }\n \n-    /// By default, LLVM lowers `resume` instructions into calls to `_Unwind_Resume`\n-    /// defined in libgcc, however, unlike personality routines, there is no easy way to\n-    /// override that symbol.  This method injects a local-scoped `_Unwind_Resume` function\n-    /// which immediately defers to the user-defined `eh_unwind_resume` lang item.\n-    pub fn inject_unwind_resume_hook(&self) {\n-        let ccx = self.ccx;\n-        if !ccx.sess().target.target.options.custom_unwind_resume ||\n-           ccx.unwind_resume_hooked().get() {\n-            return;\n-        }\n-\n-        let new_resume = match ccx.tcx().lang_items.eh_unwind_resume() {\n-            Some(did) => callee::trans_fn_ref(ccx, did, ExprId(0), &self.param_substs).val,\n+    // Returns a ValueRef of the \"eh_unwind_resume\" lang item if one is defined,\n+    // otherwise declares it as an external funtion.\n+    pub fn eh_unwind_resume(&self) -> ValueRef {\n+        use trans::attributes;\n+        assert!(self.ccx.sess().target.target.options.custom_unwind_resume);\n+        match self.ccx.tcx().lang_items.eh_unwind_resume() {\n+            Some(def_id) => {\n+                callee::trans_fn_ref(self.ccx, def_id, ExprId(0),\n+                                     self.param_substs).val\n+            }\n             None => {\n-                let fty = Type::variadic_func(&[], &Type::void(self.ccx));\n-                declare::declare_cfn(self.ccx, \"rust_eh_unwind_resume\", fty,\n-                                     self.ccx.tcx().mk_nil())\n+                let mut unwresume = self.ccx.eh_unwind_resume().borrow_mut();\n+                match *unwresume {\n+                    Some(llfn) => llfn,\n+                    None => {\n+                        let fty = Type::func(&[Type::i8p(self.ccx)], &Type::void(self.ccx));\n+                        let llfn = declare::declare_fn(self.ccx,\n+                                                       \"rust_eh_unwind_resume\",\n+                                                       llvm::CCallConv,\n+                                                       fty, ty::FnDiverging);\n+                        attributes::unwind(llfn, true);\n+                        *unwresume = Some(llfn);\n+                        llfn\n+                    }\n+                }\n             }\n-        };\n-\n-        unsafe {\n-            let resume_type = Type::func(&[Type::i8(ccx).ptr_to()], &Type::void(ccx));\n-            let old_resume = llvm::LLVMAddFunction(ccx.llmod(),\n-                                                   \"_Unwind_Resume\\0\".as_ptr() as *const _,\n-                                                   resume_type.to_ref());\n-            llvm::SetLinkage(old_resume, llvm::InternalLinkage);\n-            let llbb = llvm::LLVMAppendBasicBlockInContext(ccx.llcx(),\n-                                                           old_resume,\n-                                                           \"\\0\".as_ptr() as *const _);\n-            let builder = ccx.builder();\n-            builder.position_at_end(llbb);\n-            builder.call(new_resume, &[llvm::LLVMGetFirstParam(old_resume)], None);\n-            builder.unreachable(); // it should never return\n-\n-            // Until DwarfEHPrepare pass has run, _Unwind_Resume is not referenced by any live code\n-            // and is subject to dead code elimination.  Here we add _Unwind_Resume to @llvm.globals\n-            // to prevent that.\n-            let i8p_ty = Type::i8p(ccx);\n-            let used_ty = Type::array(&i8p_ty, 1);\n-            let used = llvm::LLVMAddGlobal(ccx.llmod(), used_ty.to_ref(),\n-                                           \"llvm.used\\0\".as_ptr() as *const _);\n-            let old_resume = llvm::LLVMConstBitCast(old_resume, i8p_ty.to_ref());\n-            llvm::LLVMSetInitializer(used, C_array(i8p_ty, &[old_resume]));\n-            llvm::SetLinkage(used, llvm::AppendingLinkage);\n-            llvm::LLVMSetSection(used, \"llvm.metadata\\0\".as_ptr() as *const _)\n         }\n-        ccx.unwind_resume_hooked().set(true);\n     }\n }\n "}, {"sha": "01d0c51a08dd91026ccbcc1b01abdb4b66dc0e56", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -146,8 +146,8 @@ pub struct LocalCrateContext<'tcx> {\n     dbg_cx: Option<debuginfo::CrateDebugContext<'tcx>>,\n \n     eh_personality: RefCell<Option<ValueRef>>,\n+    eh_unwind_resume: RefCell<Option<ValueRef>>,\n     rust_try_fn: RefCell<Option<ValueRef>>,\n-    unwind_resume_hooked: Cell<bool>,\n \n     intrinsics: RefCell<FnvHashMap<&'static str, ValueRef>>,\n \n@@ -469,8 +469,8 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 closure_vals: RefCell::new(FnvHashMap()),\n                 dbg_cx: dbg_cx,\n                 eh_personality: RefCell::new(None),\n+                eh_unwind_resume: RefCell::new(None),\n                 rust_try_fn: RefCell::new(None),\n-                unwind_resume_hooked: Cell::new(false),\n                 intrinsics: RefCell::new(FnvHashMap()),\n                 n_llvm_insns: Cell::new(0),\n                 type_of_depth: Cell::new(0),\n@@ -732,12 +732,12 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.eh_personality\n     }\n \n-    pub fn rust_try_fn<'a>(&'a self) -> &'a RefCell<Option<ValueRef>> {\n-        &self.local.rust_try_fn\n+    pub fn eh_unwind_resume<'a>(&'a self) -> &'a RefCell<Option<ValueRef>> {\n+        &self.local.eh_unwind_resume\n     }\n \n-    pub fn unwind_resume_hooked<'a>(&'a self) -> &'a Cell<bool> {\n-        &self.local.unwind_resume_hooked\n+    pub fn rust_try_fn<'a>(&'a self) -> &'a RefCell<Option<ValueRef>> {\n+        &self.local.rust_try_fn\n     }\n \n     fn intrinsics<'a>(&'a self) -> &'a RefCell<FnvHashMap<&'static str, ValueRef>> {"}, {"sha": "773256a17e4ac66ec7cd8374e1a80ce43f0de8df", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -1154,7 +1154,7 @@ fn trans_msvc_try<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         // The \"catch-resume\" block is where we're running this landing pad but\n         // we actually need to not catch the exception, so just resume the\n         // exception to return.\n-        Resume(catch_resume, vals);\n+        trans_unwind_resume(catch_resume, vals);\n \n         // On the successful branch we just return null.\n         Ret(then, C_null(Type::i8p(ccx)), dloc);"}, {"sha": "44961611b7bd78bf2e10c4e861de556ed2342666", "filename": "src/libstd/rt.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibstd%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibstd%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -32,6 +32,11 @@ use thread::{self, Thread};\n // Reexport some of our utilities which are expected by other crates.\n pub use sys_common::unwind::{begin_unwind, begin_unwind_fmt};\n \n+// Rust runtime's startup objects depend on these symbols, so they must be public.\n+// Since sys_common isn't public, we have to re-export them here.\n+#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n+pub use sys_common::unwind::imp::eh_frame_registry::*;\n+\n #[cfg(not(test))]\n #[lang = \"start\"]\n fn lang_start(main: *const u8, argc: isize, argv: *const *const u8) -> isize {"}, {"sha": "75bb11216e1a2ad7bbd61e70724370494ad80548", "filename": "src/libstd/sys/common/libunwind.rs", "status": "modified", "additions": 22, "deletions": 29, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibstd%2Fsys%2Fcommon%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibstd%2Fsys%2Fcommon%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Flibunwind.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -99,35 +99,23 @@ pub type _Unwind_Exception_Cleanup_Fn =\n         extern \"C\" fn(unwind_code: _Unwind_Reason_Code,\n                       exception: *mut _Unwind_Exception);\n \n-#[cfg(any(all(target_os = \"linux\", not(target_env = \"musl\")),\n-          target_os = \"freebsd\"))]\n-#[link(name = \"gcc_s\")]\n-extern {}\n-\n-#[cfg(all(target_os = \"linux\", target_env = \"musl\", not(test)))]\n-#[link(name = \"unwind\", kind = \"static\")]\n-extern {}\n-\n-#[cfg(any(target_os = \"android\", target_os = \"openbsd\"))]\n-#[link(name = \"gcc\")]\n-extern {}\n-\n-#[cfg(all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")))]\n-#[link(name = \"gcc\")]\n-extern {}\n-\n-#[cfg(all(target_os = \"netbsd\", target_vendor = \"rumprun\"))]\n-#[link(name = \"unwind\")]\n-extern {}\n-\n-#[cfg(target_os = \"dragonfly\")]\n-#[link(name = \"gcc_pic\")]\n-extern {}\n-\n-#[cfg(target_os = \"bitrig\")]\n-#[link(name = \"c++abi\")]\n-extern {}\n-\n+#[cfg_attr(any(all(target_os = \"linux\", not(target_env = \"musl\")),\n+               target_os = \"freebsd\"),\n+           link(name = \"gcc_s\"))]\n+#[cfg_attr(all(target_os = \"linux\", target_env = \"musl\", not(test)),\n+           link(name = \"unwind\", kind = \"static\"))]\n+#[cfg_attr(any(target_os = \"android\", target_os = \"openbsd\"),\n+           link(name = \"gcc\"))]\n+#[cfg_attr(all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n+           link(name = \"gcc\"))]\n+#[cfg_attr(all(target_os = \"netbsd\", target_vendor = \"rumprun\"),\n+           link(name = \"unwind\"))]\n+#[cfg_attr(target_os = \"dragonfly\",\n+           link(name = \"gcc_pic\"))]\n+#[cfg_attr(target_os = \"bitrig\",\n+           link(name = \"c++abi\"))]\n+#[cfg_attr(all(target_os = \"windows\", target_env=\"gnu\"),\n+           link(name = \"gcc_eh\"))]\n extern \"C\" {\n     // iOS on armv7 uses SjLj exceptions and requires to link\n     // against corresponding routine (..._SjLj_...)\n@@ -142,6 +130,11 @@ extern \"C\" {\n                                    -> _Unwind_Reason_Code;\n \n     pub fn _Unwind_DeleteException(exception: *mut _Unwind_Exception);\n+\n+    // remove cfg after new snapshot\n+    #[cfg(not(all(stage0, target_os=\"windows\", target_arch=\"x86_64\")))]\n+    #[unwind]\n+    pub fn _Unwind_Resume(exception: *mut _Unwind_Exception) -> !;\n }\n \n // ... and now we just providing access to SjLj counterspart"}, {"sha": "0a598b559514c7db4be49eb36c576e8ff1216df4", "filename": "src/libstd/sys/common/unwind/gcc.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fgcc.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -231,3 +231,36 @@ pub mod eabi {\n         }\n     }\n }\n+\n+// See docs in the `unwind` module.\n+#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\", not(test)))]\n+#[lang = \"eh_unwind_resume\"]\n+#[unwind]\n+unsafe extern fn rust_eh_unwind_resume(panic_ctx: *mut u8) -> ! {\n+    uw::_Unwind_Resume(panic_ctx as *mut uw::_Unwind_Exception);\n+}\n+\n+#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n+pub mod eh_frame_registry {\n+    // The implementation of stack unwinding is (for now) deferred to libgcc_eh, however Rust\n+    // crates use these Rust-specific entry points to avoid potential clashes with GCC runtime.\n+    // See also: rtbegin.rs, `unwind` module.\n+\n+    #[link(name = \"gcc_eh\")]\n+    extern {\n+        fn __register_frame_info(eh_frame_begin: *const u8, object: *mut u8);\n+        fn __deregister_frame_info(eh_frame_begin: *const u8, object: *mut u8);\n+    }\n+    #[cfg(not(test))]\n+    #[no_mangle]\n+    pub unsafe extern fn rust_eh_register_frames(eh_frame_begin: *const u8,\n+                                                 object: *mut u8) {\n+        __register_frame_info(eh_frame_begin, object);\n+    }\n+    #[cfg(not(test))]\n+    #[no_mangle]\n+    pub  unsafe extern fn rust_eh_unregister_frames(eh_frame_begin: *const u8,\n+                                                   object: *mut u8) {\n+        __deregister_frame_info(eh_frame_begin, object);\n+    }\n+}"}, {"sha": "e455d163ed9bf3ec9d5cfeecb317f409febeb945", "filename": "src/libstd/sys/common/unwind/mod.rs", "status": "modified", "additions": 24, "deletions": 17, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fmod.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -34,28 +34,35 @@\n //! object being thrown, and to decide whether it should be caught at that stack\n //! frame.  Once the handler frame has been identified, cleanup phase begins.\n //!\n-//! In the cleanup phase, personality routines invoke cleanup code associated\n-//! with their stack frames (i.e. destructors).  Once stack has been unwound down\n-//! to the handler frame level, unwinding stops and the last personality routine\n-//! transfers control to its catch block.\n+//! In the cleanup phase, the unwinder invokes each personality routine again.\n+//! This time it decides which (if any) cleanup code needs to be run for\n+//! the current stack frame.  If so, the control is transferred to a special branch\n+//! in the function body, the \"landing pad\", which invokes destructors, frees memory,\n+//! etc.  At the end of the landing pad, control is transferred back to the unwinder\n+//! and unwinding resumes.\n //!\n-//! ## Frame unwind info registration\n+//! Once stack has been unwound down to the handler frame level, unwinding stops\n+//! and the last personality routine transfers control to the catch block.\n //!\n-//! Each module has its own frame unwind info section (usually \".eh_frame\"), and\n-//! unwinder needs to know about all of them in order for unwinding to be able to\n-//! cross module boundaries.\n+//! ## `eh_personality` and `eh_unwind_resume`\n //!\n-//! On some platforms, like Linux, this is achieved by dynamically enumerating\n-//! currently loaded modules via the dl_iterate_phdr() API and finding all\n-//! .eh_frame sections.\n+//! These language items are used by the compiler when generating unwind info.\n+//! The first one is the personality routine described above.  The second one\n+//! allows compilation target to customize the process of resuming unwind at the\n+//! end of the landing pads.  `eh_unwind_resume` is used only if `custom_unwind_resume`\n+//! flag in the target options is set.\n //!\n-//! Others, like Windows, require modules to actively register their unwind info\n-//! sections by calling __register_frame_info() API at startup.  In the latter\n-//! case it is essential that there is only one copy of the unwinder runtime in\n-//! the process.  This is usually achieved by linking to the dynamic version of\n-//! the unwind runtime.\n+//! ## Frame unwind info registration\n //!\n-//! Currently Rust uses unwind runtime provided by libgcc.\n+//! Each module's image contains a frame unwind info section (usually \".eh_frame\").\n+//! When a module is loaded/unloaded into the process, the unwinder must be informed\n+//! about the location of this section in memory. The methods of achieving that vary\n+//! by the platform.\n+//! On some (e.g. Linux), the unwinder can discover unwind info sections on its own\n+//! (by dynamically enumerating currently loaded modules via the dl_iterate_phdr() API\n+//! and finding their \".eh_frame\" sections);\n+//! Others, like Windows, require modules to actively register their unwind info\n+//! sections via unwinder API (see `rust_eh_register_frames`/`rust_eh_unregister_frames`).\n \n #![allow(dead_code)]\n #![allow(unused_imports)]"}, {"sha": "92f059d68e1a33ab2f306d30537749e39d2dca64", "filename": "src/libstd/sys/common/unwind/seh64_gnu.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh64_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh64_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Funwind%2Fseh64_gnu.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -190,17 +190,10 @@ unsafe extern fn rust_eh_personality(\n     ExceptionContinueSearch\n }\n \n-// The `resume` instruction, found at the end of the landing pads, and whose job\n-// is to resume stack unwinding, is typically lowered by LLVM into a call to\n-// `_Unwind_Resume` routine.  To avoid confusion with the same symbol exported\n-// from libgcc, we redirect it to `rust_eh_unwind_resume`.\n-// Since resolution of this symbol is done by the linker, `rust_eh_unwind_resume`\n-// must be marked `pub` + `#[no_mangle]`.  (Can we make it a lang item?)\n-\n-#[lang = \"eh_unwind_resume\"]\n #[cfg(not(test))]\n+#[lang = \"eh_unwind_resume\"]\n #[unwind]\n-unsafe extern fn rust_eh_unwind_resume(panic_ctx: LPVOID) {\n+unsafe extern fn rust_eh_unwind_resume(panic_ctx: LPVOID) -> ! {\n     let params = [panic_ctx as ULONG_PTR];\n     RaiseException(RUST_PANIC,\n                    EXCEPTION_NONCONTINUABLE,"}, {"sha": "b168081ff8a2ed963aedd6e34a0fc271e7632c00", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -356,6 +356,7 @@ pub type PVECTORED_EXCEPTION_HANDLER = extern \"system\"\n \n #[link(name = \"ws2_32\")]\n #[link(name = \"userenv\")]\n+#[link(name = \"shell32\")]\n extern \"system\" {\n     pub fn WSAStartup(wVersionRequested: libc::WORD,\n                       lpWSAData: LPWSADATA) -> libc::c_int;"}, {"sha": "af9a01ea2e4f7f8f0285d32708f44b1810018bb8", "filename": "src/rtstartup/rsbegin.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Frtstartup%2Frsbegin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Frtstartup%2Frsbegin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frtstartup%2Frsbegin.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// rsbegin.o and rsend.o are the so called \"compiler runtime startup objects\".\n+// They contain code needed to correctly initialize the compiler runtime.\n+//\n+// When an executable or dylib image is linked, all user code and libraries are\n+// \"sandwiched\" between these two object files, so code or data from rsbegin.o\n+// become first in the respective sections of the image, whereas code and data\n+// from rsend.o become the last ones.  This effect can be used to place symbols\n+// at the beginning or at the end of a section, as well as to insert any required\n+// headers or footers.\n+//\n+// Note that the actual module entry point is located in the C runtime startup\n+// object (usually called `crtX.o), which then invokes initialization callbacks\n+// of other runtime components (registered via yet another special image section).\n+\n+#![feature(no_std)]\n+\n+#![crate_type=\"rlib\"]\n+#![no_std]\n+#![allow(non_camel_case_types)]\n+\n+#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n+pub mod eh_frames\n+{\n+    #[no_mangle]\n+    #[link_section = \".eh_frame\"]\n+    // Marks beginning of the stack frame unwind info section\n+    pub static __EH_FRAME_BEGIN__: [u8; 0] = [];\n+\n+    // Scratch space for unwinder's internal book-keeping.\n+    // This is defined as `struct object` in $GCC/libgcc/unwind-dw2-fde.h.\n+    static mut obj: [isize; 6] = [0; 6];\n+\n+    // Unwind info registration/deregistration routines.\n+    // See the docs of `unwind` module in libstd.\n+    extern {\n+        fn rust_eh_register_frames(eh_frame_begin: *const u8, object: *mut u8);\n+        fn rust_eh_unregister_frames(eh_frame_begin: *const u8, object: *mut u8);\n+    }\n+\n+    unsafe fn init() {\n+        // register unwind info on module startup\n+        rust_eh_register_frames(&__EH_FRAME_BEGIN__ as *const u8,\n+                                &mut obj as *mut _ as *mut u8);\n+    }\n+\n+    unsafe fn uninit() {\n+        // unregister on shutdown\n+        rust_eh_unregister_frames(&__EH_FRAME_BEGIN__ as *const u8,\n+                                  &mut obj as *mut _ as *mut u8);\n+    }\n+\n+    // MSVC-specific init/uninit routine registration\n+    pub mod ms_init\n+    {\n+        // .CRT$X?? sections are roughly analogous to ELF's .init_array and .fini_array,\n+        // except that they exploit the fact that linker will sort them alphabitically,\n+        // so e.g. sections with names between .CRT$XIA and .CRT$XIZ are guaranteed to be\n+        // placed between those two, without requiring any ordering of objects on the linker\n+        // command line.\n+        // Note that ordering of same-named sections from different objects is not guaranteed.\n+        // Since .CRT$XIA contains init array's header symbol, which must always come first,\n+        // we place our initialization callback into .CRT$XIB.\n+\n+        #[link_section = \".CRT$XIB\"] // .CRT$XI? : C initialization callbacks\n+        pub static P_INIT: unsafe fn() = super::init;\n+\n+        #[link_section = \".CRT$XTY\"] // .CRT$XT? : C termination callbacks\n+        pub static P_UNINIT: unsafe fn() = super::uninit;\n+    }\n+}"}, {"sha": "ecb6a228e1776d5f396739fa088b308ce152fee9", "filename": "src/rtstartup/rsend.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Frtstartup%2Frsend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Frtstartup%2Frsend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frtstartup%2Frsend.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// See rsbegin.rs for details.\n+\n+#![feature(no_std)]\n+\n+#![crate_type=\"rlib\"]\n+#![no_std]\n+\n+#[cfg(all(target_os=\"windows\", target_arch = \"x86\", target_env=\"gnu\"))]\n+pub mod eh_frames\n+{\n+    // Terminate the frame unwind info section with a 0 as a sentinel;\n+    // this would be the 'length' field in a real FDE.\n+    #[no_mangle]\n+    #[link_section = \".eh_frame\"]\n+    pub static __EH_FRAME_END__: u32 = 0;\n+}"}, {"sha": "2df7604f96138f5c4dcad98c3c2a31a259e54365", "filename": "src/test/run-make/no-duplicate-libs/bar.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Fbar.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -20,3 +20,5 @@ pub extern fn bar() {}\n #[lang = \"eh_personality\"] fn eh_personality() {}\n #[lang = \"eh_unwind_resume\"] fn eh_unwind_resume() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n+#[no_mangle] pub extern fn rust_eh_register_frames () {}\n+#[no_mangle] pub extern fn rust_eh_unregister_frames () {}"}, {"sha": "4e81f0ea06e6a6b620f861f317072de4e901cdee", "filename": "src/test/run-make/no-duplicate-libs/foo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fno-duplicate-libs%2Ffoo.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -20,4 +20,5 @@ pub extern fn foo() {}\n #[lang = \"eh_personality\"] fn eh_personality() {}\n #[lang = \"eh_unwind_resume\"] fn eh_unwind_resume() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n-\n+#[no_mangle] pub extern fn rust_eh_register_frames () {}\n+#[no_mangle] pub extern fn rust_eh_unregister_frames () {}"}, {"sha": "b11970560d59a730583178b60bae51eb11d2bf62", "filename": "src/test/run-pass/smallest-hello-world.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/71409184dc00604537ce03312dc17ba986c329d9/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71409184dc00604537ce03312dc17ba986c329d9/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsmallest-hello-world.rs?ref=71409184dc00604537ce03312dc17ba986c329d9", "patch": "@@ -23,6 +23,8 @@ extern \"rust-intrinsic\" { fn transmute<T, U>(t: T) -> U; }\n #[lang = \"eh_personality\"] extern fn eh_personality() {}\n #[lang = \"eh_unwind_resume\"] extern fn eh_unwind_resume() {}\n #[lang = \"panic_fmt\"] fn panic_fmt() -> ! { loop {} }\n+#[no_mangle] pub extern fn rust_eh_register_frames () {}\n+#[no_mangle] pub extern fn rust_eh_unregister_frames () {}\n \n #[start]\n fn main(_: isize, _: *const *const u8) -> isize {"}]}