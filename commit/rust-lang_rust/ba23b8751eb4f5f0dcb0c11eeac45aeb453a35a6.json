{"sha": "ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMjNiODc1MWViNGY1ZjBkY2IwYzExZWVhYzQ1YWViNDUzYTM1YTY=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-06-23T08:22:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-06-23T08:22:54Z"}, "message": "Merge pull request #34 from oli-obk/alignment\n\nuse ty::layout::Size and ty::layout::TargetDataLayout", "tree": {"sha": "9013c9b098fd968a665135afcaf62d8afc9d30ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9013c9b098fd968a665135afcaf62d8afc9d30ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6", "html_url": "https://github.com/rust-lang/rust/commit/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c720f6e6bb5269f18732273cb26ee1a1416fc22", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c720f6e6bb5269f18732273cb26ee1a1416fc22", "html_url": "https://github.com/rust-lang/rust/commit/0c720f6e6bb5269f18732273cb26ee1a1416fc22"}, {"sha": "4c7aae73bc2e7484b27cad5658cf5de9c6bad2b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c7aae73bc2e7484b27cad5658cf5de9c6bad2b4", "html_url": "https://github.com/rust-lang/rust/commit/4c7aae73bc2e7484b27cad5658cf5de9c6bad2b4"}], "stats": {"total": 127, "additions": 72, "deletions": 55}, "files": [{"sha": "3a31aa4f36c22b1a1f302b2cd91a0b827d4c90ca", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6", "patch": "@@ -35,7 +35,7 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n     mir_cache: RefCell<DefIdMap<Rc<mir::Mir<'tcx>>>>,\n \n     /// The virtual memory system.\n-    memory: Memory<'tcx>,\n+    memory: Memory<'a, 'tcx>,\n \n     /// Precomputed statics, constants and promoteds.\n     statics: HashMap<ConstantId<'tcx>, Pointer>,\n@@ -138,11 +138,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             tcx: tcx,\n             mir_map: mir_map,\n             mir_cache: RefCell::new(DefIdMap()),\n-            memory: Memory::new(tcx.sess\n-                                   .target\n-                                   .uint_type\n-                                   .bit_width()\n-                                   .expect(\"Session::target::uint_type was usize\")/8),\n+            memory: Memory::new(&tcx.data_layout),\n             statics: HashMap::new(),\n             stack: Vec::new(),\n         }\n@@ -162,7 +158,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &self.memory\n     }\n \n-    pub fn memory_mut(&mut self) -> &mut Memory<'tcx> {\n+    pub fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx> {\n         &mut self.memory\n     }\n \n@@ -182,7 +178,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Ok(ptr)\n             }\n             Str(ref s) => {\n-                let psize = self.memory.pointer_size;\n+                let psize = self.memory.pointer_size();\n                 let static_ptr = self.memory.allocate(s.len());\n                 let ptr = self.memory.allocate(psize * 2);\n                 self.memory.write_bytes(static_ptr, s.as_bytes())?;\n@@ -191,7 +187,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Ok(ptr)\n             }\n             ByteStr(ref bs) => {\n-                let psize = self.memory.pointer_size;\n+                let psize = self.memory.pointer_size();\n                 let static_ptr = self.memory.allocate(bs.len());\n                 let ptr = self.memory.allocate(psize);\n                 self.memory.write_bytes(static_ptr, bs)?;\n@@ -515,7 +511,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match lv.extra {\n                     LvalueExtra::None => {},\n                     LvalueExtra::Length(len) => {\n-                        let len_ptr = dest.offset(self.memory.pointer_size as isize);\n+                        let len_ptr = dest.offset(self.memory.pointer_size() as isize);\n                         self.memory.write_usize(len_ptr, len)?;\n                     }\n                     LvalueExtra::DowncastVariant(..) =>\n@@ -541,7 +537,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n                             (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n-                                let len_ptr = dest.offset(self.memory.pointer_size as isize);\n+                                let len_ptr = dest.offset(self.memory.pointer_size() as isize);\n                                 self.memory.write_usize(len_ptr, length as u64)?;\n                             }\n \n@@ -655,7 +651,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 Ok(Size::from_bytes(0))\n             }\n             FatPointer { .. } => {\n-                let bytes = layout::FAT_PTR_ADDR * self.memory.pointer_size;\n+                let bytes = layout::FAT_PTR_ADDR * self.memory.pointer_size();\n                 Ok(Size::from_bytes(bytes as u64))\n             }\n             _ => Err(EvalError::Unimplemented(format!(\"can't handle type: {:?}, with layout: {:?}\", ty, layout))),\n@@ -766,7 +762,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let ptr = self.memory.read_ptr(base.ptr)?;\n                         let extra = match pointee_ty.sty {\n                             ty::TySlice(_) | ty::TyStr => {\n-                                let len_ptr = base.ptr.offset(self.memory.pointer_size as isize);\n+                                let len_ptr = base.ptr.offset(self.memory.pointer_size() as isize);\n                                 let len = self.memory.read_usize(len_ptr)?;\n                                 LvalueExtra::Length(len)\n                             }\n@@ -815,7 +811,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     pub fn read_primval(&mut self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use syntax::ast::{IntTy, UintTy};\n-        let val = match (self.memory.pointer_size, &ty.sty) {\n+        let val = match (self.memory.pointer_size(), &ty.sty) {\n             (_, &ty::TyBool)              => PrimVal::Bool(self.memory.read_bool(ptr)?),\n             (_, &ty::TyChar)              => {\n                 let c = self.memory.read_uint(ptr, 4)? as u32;\n@@ -923,7 +919,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n \n     if mir.arg_decls.len() == 2 {\n         // start function\n-        let ptr_size = ecx.memory().pointer_size;\n+        let ptr_size = ecx.memory().pointer_size();\n         let nargs = ecx.memory_mut().allocate(ptr_size);\n         ecx.memory_mut().write_usize(nargs, 0).unwrap();\n         let args = ecx.memory_mut().allocate(ptr_size);"}, {"sha": "536d9b678ab378fc4c2495902dbdafba33b111cf", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6", "patch": "@@ -277,7 +277,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             .collect();\n         let args_ptrs = args_res?;\n \n-        let pointer_size = self.memory.pointer_size;\n+        let pointer_size = self.memory.pointer_size();\n \n         match name {\n             \"add_with_overflow\" => self.intrinsic_with_overflow(mir::BinOp::Add, &args[0], &args[1], dest, dest_layout)?,\n@@ -368,7 +368,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         ty::TySlice(_) | ty::TyStr => {\n                             let elem_ty = ty.sequence_element_type(self.tcx);\n                             let elem_size = self.type_size(elem_ty) as u64;\n-                            let ptr_size = self.memory.pointer_size as isize;\n+                            let ptr_size = self.memory.pointer_size() as isize;\n                             let n = self.memory.read_usize(args_ptrs[0].offset(ptr_size))?;\n                             self.memory.write_uint(dest, n * elem_size, pointer_size)?;\n                         }\n@@ -557,7 +557,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         self.memory.deallocate(contents_ptr)?;\n                     }\n                     Err(EvalError::ReadBytesAsPointer) => {\n-                        let size = self.memory.pointer_size;\n+                        let size = self.memory.pointer_size();\n                         let possible_drop_fill = self.memory.read_bytes(ptr, size)?;\n                         if possible_drop_fill.iter().all(|&b| b == mem::POST_DROP_U8) {\n                             return Ok(());"}, {"sha": "89c7ad7b7506f43ff232115f5f5faa708e686e9c", "filename": "src/memory.rs", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6", "patch": "@@ -6,6 +6,7 @@ use std::{fmt, iter, mem, ptr};\n use rustc::hir::def_id::DefId;\n use rustc::ty::BareFnTy;\n use rustc::ty::subst::Substs;\n+use rustc::ty::layout::TargetDataLayout;\n \n use error::{EvalError, EvalResult};\n use primval::PrimVal;\n@@ -53,7 +54,7 @@ pub struct FunctionDefinition<'tcx> {\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n \n-pub struct Memory<'tcx> {\n+pub struct Memory<'a, 'tcx> {\n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations)\n     alloc_map: HashMap<AllocId, Allocation>,\n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n@@ -62,18 +63,17 @@ pub struct Memory<'tcx> {\n     /// Inverse map of `functions` so we don't allocate a new pointer every time we need one\n     function_alloc_cache: HashMap<FunctionDefinition<'tcx>, AllocId>,\n     next_id: AllocId,\n-    pub pointer_size: usize,\n+    pub layout: &'a TargetDataLayout,\n }\n \n-impl<'tcx> Memory<'tcx> {\n-    // FIXME: pass tcx.data_layout (This would also allow it to use primitive type alignments to diagnose unaligned memory accesses.)\n-    pub fn new(pointer_size: usize) -> Self {\n+impl<'a, 'tcx> Memory<'a, 'tcx> {\n+    pub fn new(layout: &'a TargetDataLayout) -> Self {\n         Memory {\n             alloc_map: HashMap::new(),\n             functions: HashMap::new(),\n             function_alloc_cache: HashMap::new(),\n             next_id: AllocId(0),\n-            pointer_size: pointer_size,\n+            layout: layout,\n         }\n     }\n \n@@ -156,10 +156,13 @@ impl<'tcx> Memory<'tcx> {\n         Ok(())\n     }\n \n-    ////////////////////////////////////////////////////////////////////////////////\n-    // Allocation accessors\n-    ////////////////////////////////////////////////////////////////////////////////\n+    pub fn pointer_size(&self) -> usize {\n+        self.layout.pointer_size.bytes() as usize\n+    }\n+}\n \n+/// Allocation accessors\n+impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn get(&self, id: AllocId) -> EvalResult<'tcx, &Allocation> {\n         match self.alloc_map.get(&id) {\n             Some(alloc) => Ok(alloc),\n@@ -235,21 +238,20 @@ impl<'tcx> Memory<'tcx> {\n             if !relocations.is_empty() {\n                 print!(\"{:1$}\", \"\", prefix.len()); // Print spaces.\n                 let mut pos = 0;\n-                let relocation_width = (self.pointer_size - 1) * 3;\n+                let relocation_width = (self.pointer_size() - 1) * 3;\n                 for (i, target_id) in relocations {\n                     print!(\"{:1$}\", \"\", (i - pos) * 3);\n                     print!(\"\u2514{0:\u2500^1$}\u2518 \", format!(\"({})\", target_id), relocation_width);\n-                    pos = i + self.pointer_size;\n+                    pos = i + self.pointer_size();\n                 }\n                 println!(\"\");\n             }\n         }\n     }\n+}\n \n-    ////////////////////////////////////////////////////////////////////////////////\n-    // Byte accessors\n-    ////////////////////////////////////////////////////////////////////////////////\n-\n+/// Byte accessors\n+impl<'a, 'tcx> Memory<'a, 'tcx> {\n     fn get_bytes_unchecked(&self, ptr: Pointer, size: usize) -> EvalResult<'tcx, &[u8]> {\n         let alloc = self.get(ptr.alloc_id)?;\n         if ptr.offset + size > alloc.bytes.len() {\n@@ -287,11 +289,10 @@ impl<'tcx> Memory<'tcx> {\n         self.mark_definedness(ptr, size, true)?;\n         self.get_bytes_unchecked_mut(ptr, size)\n     }\n+}\n \n-    ////////////////////////////////////////////////////////////////////////////////\n-    // Reading and writing\n-    ////////////////////////////////////////////////////////////////////////////////\n-\n+/// Reading and writing\n+impl<'a, 'tcx> Memory<'a, 'tcx> {\n     pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         self.check_relocation_edges(src, size)?;\n \n@@ -336,7 +337,7 @@ impl<'tcx> Memory<'tcx> {\n     }\n \n     pub fn read_ptr(&self, ptr: Pointer) -> EvalResult<'tcx, Pointer> {\n-        let size = self.pointer_size;\n+        let size = self.pointer_size();\n         self.check_defined(ptr, size)?;\n         let offset = self.get_bytes_unchecked(ptr, size)?\n             .read_uint::<NativeEndian>(size).unwrap() as usize;\n@@ -349,7 +350,7 @@ impl<'tcx> Memory<'tcx> {\n \n     pub fn write_ptr(&mut self, dest: Pointer, ptr: Pointer) -> EvalResult<'tcx, ()> {\n         {\n-            let size = self.pointer_size;\n+            let size = self.pointer_size();\n             let mut bytes = self.get_bytes_mut(dest, size)?;\n             bytes.write_uint::<NativeEndian>(ptr.offset as u64, size).unwrap();\n         }\n@@ -358,7 +359,7 @@ impl<'tcx> Memory<'tcx> {\n     }\n \n     pub fn write_primval(&mut self, ptr: Pointer, val: PrimVal) -> EvalResult<'tcx, ()> {\n-        let pointer_size = self.pointer_size;\n+        let pointer_size = self.pointer_size();\n         match val {\n             PrimVal::Bool(b) => self.write_bool(ptr, b),\n             PrimVal::I8(n)   => self.write_int(ptr, n as i64, 1),\n@@ -406,31 +407,30 @@ impl<'tcx> Memory<'tcx> {\n     }\n \n     pub fn read_isize(&self, ptr: Pointer) -> EvalResult<'tcx, i64> {\n-        self.read_int(ptr, self.pointer_size)\n+        self.read_int(ptr, self.pointer_size())\n     }\n \n     pub fn write_isize(&mut self, ptr: Pointer, n: i64) -> EvalResult<'tcx, ()> {\n-        let size = self.pointer_size;\n+        let size = self.pointer_size();\n         self.write_int(ptr, n, size)\n     }\n \n     pub fn read_usize(&self, ptr: Pointer) -> EvalResult<'tcx, u64> {\n-        self.read_uint(ptr, self.pointer_size)\n+        self.read_uint(ptr, self.pointer_size())\n     }\n \n     pub fn write_usize(&mut self, ptr: Pointer, n: u64) -> EvalResult<'tcx, ()> {\n-        let size = self.pointer_size;\n+        let size = self.pointer_size();\n         self.write_uint(ptr, n, size)\n     }\n+}\n \n-    ////////////////////////////////////////////////////////////////////////////////\n-    // Relocations\n-    ////////////////////////////////////////////////////////////////////////////////\n-\n+/// Relocations\n+impl<'a, 'tcx> Memory<'a, 'tcx> {\n     fn relocations(&self, ptr: Pointer, size: usize)\n         -> EvalResult<'tcx, btree_map::Range<usize, AllocId>>\n     {\n-        let start = ptr.offset.saturating_sub(self.pointer_size - 1);\n+        let start = ptr.offset.saturating_sub(self.pointer_size() - 1);\n         let end = ptr.offset + size;\n         Ok(self.get(ptr.alloc_id)?.relocations.range(Included(&start), Excluded(&end)))\n     }\n@@ -444,7 +444,7 @@ impl<'tcx> Memory<'tcx> {\n         let start = ptr.offset;\n         let end = start + size;\n         let first = *keys.first().unwrap();\n-        let last = *keys.last().unwrap() + self.pointer_size;\n+        let last = *keys.last().unwrap() + self.pointer_size();\n \n         let alloc = self.get_mut(ptr.alloc_id)?;\n \n@@ -478,11 +478,10 @@ impl<'tcx> Memory<'tcx> {\n         self.get_mut(dest.alloc_id)?.relocations.extend(relocations);\n         Ok(())\n     }\n+}\n \n-    ////////////////////////////////////////////////////////////////////////////////\n-    // Undefined bytes\n-    ////////////////////////////////////////////////////////////////////////////////\n-\n+/// Undefined bytes\n+impl<'a, 'tcx> Memory<'a, 'tcx> {\n     // FIXME(solson): This is a very naive, slow version.\n     fn copy_undef_mask(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<'tcx, ()> {\n         // The bits have to be saved locally before writing to dest in case src and dest overlap."}, {"sha": "bde78200b3c47a92dc601b2b1939eff6a9500512", "filename": "tests/compile-fail/invalid_enum_discriminant.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Finvalid_enum_discriminant.rs?ref=ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6", "patch": "@@ -0,0 +1,14 @@\n+#[repr(C)]\n+pub enum Foo {\n+    A, B, C, D\n+}\n+\n+fn main() {\n+    let f = unsafe { std::mem::transmute::<i32, Foo>(42) };\n+    match f {\n+        Foo::A => {}, //~ ERROR invalid enum discriminant value read\n+        Foo::B => {},\n+        Foo::C => {},\n+        Foo::D => {},\n+    }\n+}"}, {"sha": "a91c7fef6aa1e92b3d4709d26f1b56fb47c343af", "filename": "tests/compile-fail/match_char.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6/tests%2Fcompile-fail%2Fmatch_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6/tests%2Fcompile-fail%2Fmatch_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatch_char.rs?ref=ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    assert!(std::char::from_u32(-1_i32 as u32).is_none());\n+    match unsafe { std::mem::transmute::<i32, char>(-1) } {\n+        'a' => {}, //~ERROR tried to interpret an invalid 32-bit value as a char: 4294967295\n+        'b' => {},\n+        _ => {},\n+    }\n+}"}, {"sha": "a401257c6ae7e955ee450f37a6d495ae176ed90b", "filename": "tests/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=ba23b8751eb4f5f0dcb0c11eeac45aeb453a35a6", "patch": "@@ -77,7 +77,7 @@ fn compile_test() {\n             match cmd.output() {\n                 Ok(ref output) if output.status.success() => writeln!(stderr.lock(), \"ok\").unwrap(),\n                 Ok(output) => {\n-                    writeln!(stderr.lock(), \"FAILED with exit code {}\", output.status.code().unwrap_or(0)).unwrap();\n+                    writeln!(stderr.lock(), \"FAILED with exit code {:?}\", output.status.code()).unwrap();\n                     writeln!(stderr.lock(), \"stdout: \\n {}\", std::str::from_utf8(&output.stdout).unwrap()).unwrap();\n                     writeln!(stderr.lock(), \"stderr: \\n {}\", std::str::from_utf8(&output.stderr).unwrap()).unwrap();\n                     panic!(\"some tests failed\");"}]}