{"sha": "1623ab0246deebec4fe32dc525d20bf8a88096f2", "node_id": "C_kwDOAAsO6NoAKDE2MjNhYjAyNDZkZWViZWM0ZmUzMmRjNTI1ZDIwYmY4YTg4MDk2ZjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-11T05:46:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-11T05:46:24Z"}, "message": "Auto merge of #107507 - BoxyUwU:deferred_projection_equality, r=lcnr\n\nImplement `deferred_projection_equality` for erica solver\n\nSomewhat of a revival of #96912. When relating projections now emit an `AliasEq` obligation instead of attempting to determine equality of projections that may not be as normalized as possible (i.e. because of lazy norm, or just containing inference variables that prevent us from resolving an impl). Only do this when the new solver is enabled", "tree": {"sha": "b53f139b7fbe2cd91228c2724e4affccfc1a85c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b53f139b7fbe2cd91228c2724e4affccfc1a85c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1623ab0246deebec4fe32dc525d20bf8a88096f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1623ab0246deebec4fe32dc525d20bf8a88096f2", "html_url": "https://github.com/rust-lang/rust/commit/1623ab0246deebec4fe32dc525d20bf8a88096f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1623ab0246deebec4fe32dc525d20bf8a88096f2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a8dfd933a70cc47e44502a20fd67dfaec6555d5", "html_url": "https://github.com/rust-lang/rust/commit/5a8dfd933a70cc47e44502a20fd67dfaec6555d5"}, {"sha": "4c98429d8c7b05276fa94eac2e78b24c947509c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c98429d8c7b05276fa94eac2e78b24c947509c3", "html_url": "https://github.com/rust-lang/rust/commit/4c98429d8c7b05276fa94eac2e78b24c947509c3"}], "stats": {"total": 748, "additions": 585, "deletions": 163}, "files": [{"sha": "8dd06187877c864c79c5394fda5586eeac987276", "filename": "compiler/rustc_borrowck/src/type_check/relate_tys.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Frelate_tys.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -1,4 +1,4 @@\n-use rustc_infer::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n+use rustc_infer::infer::nll_relate::{TypeRelating, TypeRelatingDelegate};\n use rustc_infer::infer::NllRegionVariableOrigin;\n use rustc_infer::traits::PredicateObligations;\n use rustc_middle::mir::ConstraintCategory;\n@@ -140,10 +140,6 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx>\n         );\n     }\n \n-    fn normalization() -> NormalizationStrategy {\n-        NormalizationStrategy::Eager\n-    }\n-\n     fn forbid_inference_vars() -> bool {\n         true\n     }"}, {"sha": "75cc7cbaa6053a8fe3cc949855425c371c3f2f3c", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -1320,6 +1320,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     ty::Clause::RegionOutlives(_) => bug!(),\n                 },\n                 ty::PredicateKind::WellFormed(_)\n+                | ty::PredicateKind::AliasEq(..)\n                 | ty::PredicateKind::ObjectSafe(_)\n                 | ty::PredicateKind::ClosureKind(_, _, _)\n                 | ty::PredicateKind::Subtype(_)"}, {"sha": "02f77f9d6afba4793721ff0e0832f11be7df9119", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -517,6 +517,7 @@ fn trait_predicate_kind<'tcx>(\n         ty::PredicateKind::Clause(ty::Clause::RegionOutlives(_))\n         | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(_))\n         | ty::PredicateKind::Clause(ty::Clause::Projection(_))\n+        | ty::PredicateKind::AliasEq(..)\n         | ty::PredicateKind::WellFormed(_)\n         | ty::PredicateKind::Subtype(_)\n         | ty::PredicateKind::Coerce(_)"}, {"sha": "ecd6849426dbf8dcd089f7bf82b673428ee0b80e", "filename": "compiler/rustc_hir_analysis/src/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -55,6 +55,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                     ty::PredicateKind::Clause(ty::Clause::Trait(..))\n                     | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                     | ty::PredicateKind::WellFormed(..)\n+                    | ty::PredicateKind::AliasEq(..)\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ClosureKind(..)\n                     | ty::PredicateKind::Subtype(..)"}, {"sha": "52c2dabee293e55c4dbf27dc49ed20855ee17e42", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -669,6 +669,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n                 | ty::PredicateKind::WellFormed(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::AliasEq(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 // N.B., this predicate is created by breaking down a"}, {"sha": "16b0d48002efc157d24c2e0a582ac5f958816eeb", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -837,6 +837,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Ambiguous\n+                | ty::PredicateKind::AliasEq(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             }\n         });"}, {"sha": "0c97217bd6a5dbda676e00acd798c5a650d6e7a3", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -12,7 +12,7 @@ use crate::infer::canonical::{\n     Canonical, CanonicalQueryResponse, CanonicalVarValues, Certainty, OriginalQueryValues,\n     QueryOutlivesConstraint, QueryRegionConstraints, QueryResponse,\n };\n-use crate::infer::nll_relate::{NormalizationStrategy, TypeRelating, TypeRelatingDelegate};\n+use crate::infer::nll_relate::{TypeRelating, TypeRelatingDelegate};\n use crate::infer::region_constraints::{Constraint, RegionConstraintData};\n use crate::infer::{InferCtxt, InferOk, InferResult, NllRegionVariableOrigin};\n use crate::traits::query::{Fallible, NoSolution};\n@@ -717,10 +717,6 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         });\n     }\n \n-    fn normalization() -> NormalizationStrategy {\n-        NormalizationStrategy::Eager\n-    }\n-\n     fn forbid_inference_vars() -> bool {\n         true\n     }"}, {"sha": "4da2a67414498abb1d19de005e87a87cb8b7f097", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 58, "deletions": 29, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -38,8 +38,8 @@ use rustc_middle::ty::error::{ExpectedFound, TypeError};\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{\n-    self, FallibleTypeFolder, InferConst, Ty, TyCtxt, TypeFoldable, TypeSuperFoldable,\n-    TypeVisitable,\n+    self, AliasKind, FallibleTypeFolder, InferConst, ToPredicate, Ty, TyCtxt, TypeFoldable,\n+    TypeSuperFoldable, TypeVisitable,\n };\n use rustc_middle::ty::{IntType, UintType};\n use rustc_span::{Span, DUMMY_SP};\n@@ -74,7 +74,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         b: Ty<'tcx>,\n     ) -> RelateResult<'tcx, Ty<'tcx>>\n     where\n-        R: TypeRelation<'tcx>,\n+        R: ObligationEmittingRelation<'tcx>,\n     {\n         let a_is_expected = relation.a_is_expected();\n \n@@ -122,6 +122,15 @@ impl<'tcx> InferCtxt<'tcx> {\n                 Err(TypeError::Sorts(ty::relate::expected_found(relation, a, b)))\n             }\n \n+            (ty::Alias(AliasKind::Projection, _), _) if self.tcx.trait_solver_next() => {\n+                relation.register_type_equate_obligation(a.into(), b.into());\n+                Ok(b)\n+            }\n+            (_, ty::Alias(AliasKind::Projection, _)) if self.tcx.trait_solver_next() => {\n+                relation.register_type_equate_obligation(b.into(), a.into());\n+                Ok(a)\n+            }\n+\n             _ => ty::relate::super_relate_tys(relation, a, b),\n         }\n     }\n@@ -133,7 +142,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         b: ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, ty::Const<'tcx>>\n     where\n-        R: ConstEquateRelation<'tcx>,\n+        R: ObligationEmittingRelation<'tcx>,\n     {\n         debug!(\"{}.consts({:?}, {:?})\", relation.tag(), a, b);\n         if a == b {\n@@ -169,15 +178,15 @@ impl<'tcx> InferCtxt<'tcx> {\n                 // FIXME(#59490): Need to remove the leak check to accommodate\n                 // escaping bound variables here.\n                 if !a.has_escaping_bound_vars() && !b.has_escaping_bound_vars() {\n-                    relation.const_equate_obligation(a, b);\n+                    relation.register_const_equate_obligation(a, b);\n                 }\n                 return Ok(b);\n             }\n             (_, ty::ConstKind::Unevaluated(..)) if self.tcx.lazy_normalization() => {\n                 // FIXME(#59490): Need to remove the leak check to accommodate\n                 // escaping bound variables here.\n                 if !a.has_escaping_bound_vars() && !b.has_escaping_bound_vars() {\n-                    relation.const_equate_obligation(a, b);\n+                    relation.register_const_equate_obligation(a, b);\n                 }\n                 return Ok(a);\n             }\n@@ -435,32 +444,21 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         Ok(Generalization { ty, needs_wf })\n     }\n \n-    pub fn add_const_equate_obligation(\n+    pub fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n+        self.obligations.extend(obligations.into_iter());\n+    }\n+\n+    pub fn register_predicates(\n         &mut self,\n-        a_is_expected: bool,\n-        a: ty::Const<'tcx>,\n-        b: ty::Const<'tcx>,\n+        obligations: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n     ) {\n-        let predicate = if a_is_expected {\n-            ty::PredicateKind::ConstEquate(a, b)\n-        } else {\n-            ty::PredicateKind::ConstEquate(b, a)\n-        };\n-        self.obligations.push(Obligation::new(\n-            self.tcx(),\n-            self.trace.cause.clone(),\n-            self.param_env,\n-            ty::Binder::dummy(predicate),\n-        ));\n+        self.obligations.extend(obligations.into_iter().map(|to_pred| {\n+            Obligation::new(self.infcx.tcx, self.trace.cause.clone(), self.param_env, to_pred)\n+        }))\n     }\n \n     pub fn mark_ambiguous(&mut self) {\n-        self.obligations.push(Obligation::new(\n-            self.tcx(),\n-            self.trace.cause.clone(),\n-            self.param_env,\n-            ty::Binder::dummy(ty::PredicateKind::Ambiguous),\n-        ));\n+        self.register_predicates([ty::Binder::dummy(ty::PredicateKind::Ambiguous)]);\n     }\n }\n \n@@ -779,11 +777,42 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n     }\n }\n \n-pub trait ConstEquateRelation<'tcx>: TypeRelation<'tcx> {\n+pub trait ObligationEmittingRelation<'tcx>: TypeRelation<'tcx> {\n+    /// Register obligations that must hold in order for this relation to hold\n+    fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>);\n+\n+    /// Register predicates that must hold in order for this relation to hold. Uses\n+    /// a default obligation cause, [`ObligationEmittingRelation::register_obligations`] should\n+    /// be used if control over the obligaton causes is required.\n+    fn register_predicates(\n+        &mut self,\n+        obligations: impl IntoIterator<Item = impl ToPredicate<'tcx>>,\n+    );\n+\n     /// Register an obligation that both constants must be equal to each other.\n     ///\n     /// If they aren't equal then the relation doesn't hold.\n-    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>);\n+    fn register_const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n+        let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n+\n+        self.register_predicates([ty::Binder::dummy(if self.tcx().trait_solver_next() {\n+            ty::PredicateKind::AliasEq(a.into(), b.into())\n+        } else {\n+            ty::PredicateKind::ConstEquate(a, b)\n+        })]);\n+    }\n+\n+    /// Register an obligation that both types must be equal to each other.\n+    ///\n+    /// If they aren't equal then the relation doesn't hold.\n+    fn register_type_equate_obligation(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n+        let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n+\n+        self.register_predicates([ty::Binder::dummy(ty::PredicateKind::AliasEq(\n+            a.into(),\n+            b.into(),\n+        ))]);\n+    }\n }\n \n fn int_unification_error<'tcx>("}, {"sha": "742c01efff60352f5f995516571780c56af37d07", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -1,4 +1,6 @@\n-use super::combine::{CombineFields, ConstEquateRelation, RelationDir};\n+use crate::traits::PredicateObligations;\n+\n+use super::combine::{CombineFields, ObligationEmittingRelation, RelationDir};\n use super::Subtype;\n \n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n@@ -198,8 +200,15 @@ impl<'tcx> TypeRelation<'tcx> for Equate<'_, '_, 'tcx> {\n     }\n }\n \n-impl<'tcx> ConstEquateRelation<'tcx> for Equate<'_, '_, 'tcx> {\n-    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n-        self.fields.add_const_equate_obligation(self.a_is_expected, a, b);\n+impl<'tcx> ObligationEmittingRelation<'tcx> for Equate<'_, '_, 'tcx> {\n+    fn register_predicates(\n+        &mut self,\n+        obligations: impl IntoIterator<Item = impl ty::ToPredicate<'tcx>>,\n+    ) {\n+        self.fields.register_predicates(obligations);\n+    }\n+\n+    fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n+        self.fields.register_obligations(obligations);\n     }\n }"}, {"sha": "74abca7bbea36bbfd1f7b5a8c76189d3f593cde0", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -1,12 +1,11 @@\n //! Greatest lower bound. See [`lattice`].\n \n-use super::combine::CombineFields;\n+use super::combine::{CombineFields, ObligationEmittingRelation};\n use super::lattice::{self, LatticeDir};\n use super::InferCtxt;\n use super::Subtype;\n \n-use crate::infer::combine::ConstEquateRelation;\n-use crate::traits::{ObligationCause, PredicateObligation};\n+use crate::traits::{ObligationCause, PredicateObligations};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n@@ -136,10 +135,6 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n         &self.fields.trace.cause\n     }\n \n-    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>) {\n-        self.fields.obligations.extend(obligations)\n-    }\n-\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(v, a)?;\n@@ -152,8 +147,15 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Glb<'combine, 'infcx,\n     }\n }\n \n-impl<'tcx> ConstEquateRelation<'tcx> for Glb<'_, '_, 'tcx> {\n-    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n-        self.fields.add_const_equate_obligation(self.a_is_expected, a, b);\n+impl<'tcx> ObligationEmittingRelation<'tcx> for Glb<'_, '_, 'tcx> {\n+    fn register_predicates(\n+        &mut self,\n+        obligations: impl IntoIterator<Item = impl ty::ToPredicate<'tcx>>,\n+    ) {\n+        self.fields.register_predicates(obligations);\n+    }\n+\n+    fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n+        self.fields.register_obligations(obligations);\n     }\n }"}, {"sha": "f377ac1d19e9c66a0554c7e113e45353f91e66de", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -17,11 +17,12 @@\n //!\n //! [lattices]: https://en.wikipedia.org/wiki/Lattice_(order)\n \n+use super::combine::ObligationEmittingRelation;\n use super::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use super::InferCtxt;\n \n-use crate::traits::{ObligationCause, PredicateObligation};\n-use rustc_middle::ty::relate::{RelateResult, TypeRelation};\n+use crate::traits::ObligationCause;\n+use rustc_middle::ty::relate::RelateResult;\n use rustc_middle::ty::TyVar;\n use rustc_middle::ty::{self, Ty};\n \n@@ -30,13 +31,11 @@ use rustc_middle::ty::{self, Ty};\n ///\n /// GLB moves \"down\" the lattice (to smaller values); LUB moves\n /// \"up\" the lattice (to bigger values).\n-pub trait LatticeDir<'f, 'tcx>: TypeRelation<'tcx> {\n+pub trait LatticeDir<'f, 'tcx>: ObligationEmittingRelation<'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'tcx>;\n \n     fn cause(&self) -> &ObligationCause<'tcx>;\n \n-    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>);\n-\n     fn define_opaque_types(&self) -> bool;\n \n     // Relates the type `v` to `a` and `b` such that `v` represents\n@@ -113,7 +112,7 @@ where\n         | (_, &ty::Alias(ty::Opaque, ty::AliasTy { def_id, .. }))\n             if this.define_opaque_types() && def_id.is_local() =>\n         {\n-            this.add_obligations(\n+            this.register_obligations(\n                 infcx\n                     .handle_opaque_type(a, b, this.a_is_expected(), this.cause(), this.param_env())?\n                     .obligations,"}, {"sha": "f997171b97f2740a07029830f81967b16b39c98e", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -1,12 +1,11 @@\n //! Least upper bound. See [`lattice`].\n \n-use super::combine::CombineFields;\n+use super::combine::{CombineFields, ObligationEmittingRelation};\n use super::lattice::{self, LatticeDir};\n use super::InferCtxt;\n use super::Subtype;\n \n-use crate::infer::combine::ConstEquateRelation;\n-use crate::traits::{ObligationCause, PredicateObligation};\n+use crate::traits::{ObligationCause, PredicateObligations};\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n \n@@ -127,12 +126,6 @@ impl<'tcx> TypeRelation<'tcx> for Lub<'_, '_, 'tcx> {\n     }\n }\n \n-impl<'tcx> ConstEquateRelation<'tcx> for Lub<'_, '_, 'tcx> {\n-    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n-        self.fields.add_const_equate_obligation(self.a_is_expected, a, b);\n-    }\n-}\n-\n impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx, 'tcx> {\n     fn infcx(&self) -> &'infcx InferCtxt<'tcx> {\n         self.fields.infcx\n@@ -142,10 +135,6 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx,\n         &self.fields.trace.cause\n     }\n \n-    fn add_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>) {\n-        self.fields.obligations.extend(obligations)\n-    }\n-\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(a, v)?;\n@@ -157,3 +146,16 @@ impl<'combine, 'infcx, 'tcx> LatticeDir<'infcx, 'tcx> for Lub<'combine, 'infcx,\n         self.fields.define_opaque_types\n     }\n }\n+\n+impl<'tcx> ObligationEmittingRelation<'tcx> for Lub<'_, '_, 'tcx> {\n+    fn register_predicates(\n+        &mut self,\n+        obligations: impl IntoIterator<Item = impl ty::ToPredicate<'tcx>>,\n+    ) {\n+        self.fields.register_predicates(obligations);\n+    }\n+\n+    fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n+        self.fields.register_obligations(obligations)\n+    }\n+}"}, {"sha": "e77924900a07119f857d8b2502b29f1f457ef045", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -4,6 +4,7 @@ pub use self::LateBoundRegionConversionTime::*;\n pub use self::RegionVariableOrigin::*;\n pub use self::SubregionOrigin::*;\n pub use self::ValuePairs::*;\n+pub use combine::ObligationEmittingRelation;\n \n use self::opaque_types::OpaqueTypeStorage;\n pub(crate) use self::undo_log::{InferCtxtUndoLogs, Snapshot, UndoLog};"}, {"sha": "1dd5062acaf05cb28220b34cdc69d2426bcbfce7", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 20, "deletions": 69, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -21,11 +21,10 @@\n //!   thing we relate in chalk are basically domain goals and their\n //!   constituents)\n \n-use crate::infer::combine::ConstEquateRelation;\n use crate::infer::InferCtxt;\n use crate::infer::{ConstVarValue, ConstVariableValue};\n use crate::infer::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::traits::{Obligation, PredicateObligation};\n+use crate::traits::{Obligation, PredicateObligations};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::traits::ObligationCause;\n use rustc_middle::ty::error::TypeError;\n@@ -36,11 +35,7 @@ use rustc_span::Span;\n use std::fmt::Debug;\n use std::ops::ControlFlow;\n \n-#[derive(PartialEq)]\n-pub enum NormalizationStrategy {\n-    Lazy,\n-    Eager,\n-}\n+use super::combine::ObligationEmittingRelation;\n \n pub struct TypeRelating<'me, 'tcx, D>\n where\n@@ -92,7 +87,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n         info: ty::VarianceDiagInfo<'tcx>,\n     );\n \n-    fn register_obligations(&mut self, obligations: Vec<PredicateObligation<'tcx>>);\n+    fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>);\n \n     /// Creates a new universe index. Used when instantiating placeholders.\n     fn create_next_universe(&mut self) -> ty::UniverseIndex;\n@@ -125,9 +120,6 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// relation stating that `'?0: 'a`).\n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx>;\n \n-    /// Define the normalization strategy to use, eager or lazy.\n-    fn normalization() -> NormalizationStrategy;\n-\n     /// Enables some optimizations if we do not expect inference variables\n     /// in the RHS of the relation.\n     fn forbid_inference_vars() -> bool;\n@@ -265,38 +257,6 @@ where\n         self.delegate.push_outlives(sup, sub, info);\n     }\n \n-    /// Relate a projection type and some value type lazily. This will always\n-    /// succeed, but we push an additional `ProjectionEq` goal depending\n-    /// on the value type:\n-    /// - if the value type is any type `T` which is not a projection, we push\n-    ///   `ProjectionEq(projection = T)`.\n-    /// - if the value type is another projection `other_projection`, we create\n-    ///   a new inference variable `?U` and push the two goals\n-    ///   `ProjectionEq(projection = ?U)`, `ProjectionEq(other_projection = ?U)`.\n-    fn relate_projection_ty(\n-        &mut self,\n-        projection_ty: ty::AliasTy<'tcx>,\n-        value_ty: Ty<'tcx>,\n-    ) -> Ty<'tcx> {\n-        use rustc_span::DUMMY_SP;\n-\n-        match *value_ty.kind() {\n-            ty::Alias(ty::Projection, other_projection_ty) => {\n-                let var = self.infcx.next_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::MiscVariable,\n-                    span: DUMMY_SP,\n-                });\n-                // FIXME(lazy-normalization): This will always ICE, because the recursive\n-                // call will end up in the _ arm below.\n-                self.relate_projection_ty(projection_ty, var);\n-                self.relate_projection_ty(other_projection_ty, var);\n-                var\n-            }\n-\n-            _ => bug!(\"should never be invoked with eager normalization\"),\n-        }\n-    }\n-\n     /// Relate a type inference variable with a value type. This works\n     /// by creating a \"generalization\" G of the value where all the\n     /// lifetimes are replaced with fresh inference values. This\n@@ -335,12 +295,6 @@ where\n                 return Ok(value_ty);\n             }\n \n-            ty::Alias(ty::Projection, projection_ty)\n-                if D::normalization() == NormalizationStrategy::Lazy =>\n-            {\n-                return Ok(self.relate_projection_ty(projection_ty, self.infcx.tcx.mk_ty_var(vid)));\n-            }\n-\n             _ => (),\n         }\n \n@@ -627,18 +581,6 @@ where\n                 self.relate_opaques(a, b)\n             }\n \n-            (&ty::Alias(ty::Projection, projection_ty), _)\n-                if D::normalization() == NormalizationStrategy::Lazy =>\n-            {\n-                Ok(self.relate_projection_ty(projection_ty, b))\n-            }\n-\n-            (_, &ty::Alias(ty::Projection, projection_ty))\n-                if D::normalization() == NormalizationStrategy::Lazy =>\n-            {\n-                Ok(self.relate_projection_ty(projection_ty, a))\n-            }\n-\n             _ => {\n                 debug!(?a, ?b, ?self.ambient_variance);\n \n@@ -813,17 +755,26 @@ where\n     }\n }\n \n-impl<'tcx, D> ConstEquateRelation<'tcx> for TypeRelating<'_, 'tcx, D>\n+impl<'tcx, D> ObligationEmittingRelation<'tcx> for TypeRelating<'_, 'tcx, D>\n where\n     D: TypeRelatingDelegate<'tcx>,\n {\n-    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n-        self.delegate.register_obligations(vec![Obligation::new(\n-            self.tcx(),\n-            ObligationCause::dummy(),\n-            self.param_env(),\n-            ty::Binder::dummy(ty::PredicateKind::ConstEquate(a, b)),\n-        )]);\n+    fn register_predicates(\n+        &mut self,\n+        obligations: impl IntoIterator<Item = impl ty::ToPredicate<'tcx>>,\n+    ) {\n+        self.delegate.register_obligations(\n+            obligations\n+                .into_iter()\n+                .map(|to_pred| {\n+                    Obligation::new(self.tcx(), ObligationCause::dummy(), self.param_env(), to_pred)\n+                })\n+                .collect(),\n+        );\n+    }\n+\n+    fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n+        self.delegate.register_obligations(obligations);\n     }\n }\n "}, {"sha": "a8e668d81eae30371927ce582686d65ca354ff2b", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -21,6 +21,7 @@ pub fn explicit_outlives_bounds<'tcx>(\n         .filter_map(move |kind| match kind {\n             ty::PredicateKind::Clause(ty::Clause::Projection(..))\n             | ty::PredicateKind::Clause(ty::Clause::Trait(..))\n+            | ty::PredicateKind::AliasEq(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::WellFormed(..)"}, {"sha": "f795047709e4033088ed6c65df34a12fe622e24f", "filename": "compiler/rustc_infer/src/infer/projection.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -21,16 +21,28 @@ impl<'tcx> InferCtxt<'tcx> {\n         recursion_depth: usize,\n         obligations: &mut Vec<PredicateObligation<'tcx>>,\n     ) -> Ty<'tcx> {\n-        let def_id = projection_ty.def_id;\n-        let ty_var = self.next_ty_var(TypeVariableOrigin {\n-            kind: TypeVariableOriginKind::NormalizeProjectionType,\n-            span: self.tcx.def_span(def_id),\n-        });\n-        let projection =\n-            ty::Binder::dummy(ty::ProjectionPredicate { projection_ty, term: ty_var.into() });\n-        let obligation =\n-            Obligation::with_depth(self.tcx, cause, recursion_depth, param_env, projection);\n-        obligations.push(obligation);\n-        ty_var\n+        if self.tcx.trait_solver_next() {\n+            // FIXME(-Ztrait-solver=next): Instead of branching here,\n+            // completely change the normalization routine with the new solver.\n+            //\n+            // The new solver correctly handles projection equality so this hack\n+            // is not necessary. if re-enabled it should emit `PredicateKind::AliasEq`\n+            // not `PredicateKind::Clause(Clause::Projection(..))` as in the new solver\n+            // `Projection` is used as `normalizes-to` which will fail for `<T as Trait>::Assoc eq ?0`.\n+            return projection_ty.to_ty(self.tcx);\n+        } else {\n+            let def_id = projection_ty.def_id;\n+            let ty_var = self.next_ty_var(TypeVariableOrigin {\n+                kind: TypeVariableOriginKind::NormalizeProjectionType,\n+                span: self.tcx.def_span(def_id),\n+            });\n+            let projection = ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::Projection(\n+                ty::ProjectionPredicate { projection_ty, term: ty_var.into() },\n+            )));\n+            let obligation =\n+                Obligation::with_depth(self.tcx, cause, recursion_depth, param_env, projection);\n+            obligations.push(obligation);\n+            ty_var\n+        }\n     }\n }"}, {"sha": "bf1b34415470c5fde25357c65c1bb7da9667fedb", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -1,8 +1,7 @@\n use super::combine::{CombineFields, RelationDir};\n-use super::SubregionOrigin;\n+use super::{ObligationEmittingRelation, SubregionOrigin};\n \n-use crate::infer::combine::ConstEquateRelation;\n-use crate::traits::Obligation;\n+use crate::traits::{Obligation, PredicateObligations};\n use rustc_middle::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::visit::TypeVisitable;\n use rustc_middle::ty::TyVar;\n@@ -228,8 +227,15 @@ impl<'tcx> TypeRelation<'tcx> for Sub<'_, '_, 'tcx> {\n     }\n }\n \n-impl<'tcx> ConstEquateRelation<'tcx> for Sub<'_, '_, 'tcx> {\n-    fn const_equate_obligation(&mut self, a: ty::Const<'tcx>, b: ty::Const<'tcx>) {\n-        self.fields.add_const_equate_obligation(self.a_is_expected, a, b);\n+impl<'tcx> ObligationEmittingRelation<'tcx> for Sub<'_, '_, 'tcx> {\n+    fn register_predicates(\n+        &mut self,\n+        obligations: impl IntoIterator<Item = impl ty::ToPredicate<'tcx>>,\n+    ) {\n+        self.fields.register_predicates(obligations);\n+    }\n+\n+    fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n+        self.fields.register_obligations(obligations);\n     }\n }"}, {"sha": "e617eb68d477587db3dae0666ad02f52f4fa2481", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -294,6 +294,9 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Nothing to elaborate\n             }\n             ty::PredicateKind::Ambiguous => {}\n+            ty::PredicateKind::AliasEq(..) => {\n+                // No\n+            }\n         }\n     }\n }"}, {"sha": "7a50b6aec87a65b2b40b7507ecb7c10a66817c69", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -1594,12 +1594,14 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     // Ignore projections, as they can only be global\n                     // if the trait bound is global\n                     Clause(Clause::Projection(..)) |\n+                    AliasEq(..) |\n                     // Ignore bounds that a user can't type\n                     WellFormed(..) |\n                     ObjectSafe(..) |\n                     ClosureKind(..) |\n                     Subtype(..) |\n                     Coerce(..) |\n+                    // FIXME(generic_const_exprs): `ConstEvaluatable` can be written\n                     ConstEvaluatable(..) |\n                     ConstEquate(..) |\n                     Ambiguous |"}, {"sha": "04537ad635a50ee071969fe7dbf0d8e48b645b88", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -2254,6 +2254,10 @@ impl<'tcx> TyCtxt<'tcx> {\n             })\n         )\n     }\n+\n+    pub fn trait_solver_next(self) -> bool {\n+        self.sess.opts.unstable_opts.trait_solver == rustc_session::config::TraitSolver::Next\n+    }\n }\n \n impl<'tcx> TyCtxtAt<'tcx> {"}, {"sha": "258bc9c3e4188cd7da2a81738de77bd2f696e2a7", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -264,10 +264,7 @@ impl FlagComputation {\n                 term,\n             })) => {\n                 self.add_projection_ty(projection_ty);\n-                match term.unpack() {\n-                    ty::TermKind::Ty(ty) => self.add_ty(ty),\n-                    ty::TermKind::Const(c) => self.add_const(c),\n-                }\n+                self.add_term(term);\n             }\n             ty::PredicateKind::WellFormed(arg) => {\n                 self.add_substs(slice::from_ref(&arg));\n@@ -287,6 +284,10 @@ impl FlagComputation {\n                 self.add_ty(ty);\n             }\n             ty::PredicateKind::Ambiguous => {}\n+            ty::PredicateKind::AliasEq(t1, t2) => {\n+                self.add_term(t1);\n+                self.add_term(t2);\n+            }\n         }\n     }\n \n@@ -380,4 +381,11 @@ impl FlagComputation {\n             }\n         }\n     }\n+\n+    fn add_term(&mut self, term: ty::Term<'_>) {\n+        match term.unpack() {\n+            ty::TermKind::Ty(ty) => self.add_ty(ty),\n+            ty::TermKind::Const(ct) => self.add_const(ct),\n+        }\n+    }\n }"}, {"sha": "0e86b2666b2d6c4c1ac58d9febaeb4637038ab98", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -545,6 +545,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::Clause(Clause::RegionOutlives(_))\n             | PredicateKind::Clause(Clause::TypeOutlives(_))\n             | PredicateKind::Clause(Clause::Projection(_))\n+            | PredicateKind::AliasEq(..)\n             | PredicateKind::ObjectSafe(_)\n             | PredicateKind::ClosureKind(_, _, _)\n             | PredicateKind::Subtype(_)\n@@ -632,6 +633,12 @@ pub enum PredicateKind<'tcx> {\n     /// A marker predicate that is always ambiguous.\n     /// Used for coherence to mark opaque types as possibly equal to each other but ambiguous.\n     Ambiguous,\n+\n+    /// Separate from `Clause::Projection` which is used for normalization in new solver.\n+    /// This predicate requires two terms to be equal to eachother.\n+    ///\n+    /// Only used for new solver\n+    AliasEq(Term<'tcx>, Term<'tcx>),\n }\n \n /// The crate outlives map is computed during typeck and contains the\n@@ -963,6 +970,33 @@ impl<'tcx> Term<'tcx> {\n             TermKind::Const(c) => c.into(),\n         }\n     }\n+\n+    /// This function returns `None` for `AliasKind::Opaque`.\n+    ///\n+    /// FIXME: rename `AliasTy` to `AliasTerm` and make sure we correctly\n+    /// deal with constants.\n+    pub fn to_alias_term_no_opaque(&self, tcx: TyCtxt<'tcx>) -> Option<AliasTy<'tcx>> {\n+        match self.unpack() {\n+            TermKind::Ty(ty) => match ty.kind() {\n+                ty::Alias(kind, alias_ty) => match kind {\n+                    AliasKind::Projection => Some(*alias_ty),\n+                    AliasKind::Opaque => None,\n+                },\n+                _ => None,\n+            },\n+            TermKind::Const(ct) => match ct.kind() {\n+                ConstKind::Unevaluated(uv) => Some(tcx.mk_alias_ty(uv.def.did, uv.substs)),\n+                _ => None,\n+            },\n+        }\n+    }\n+\n+    pub fn is_infer(&self) -> bool {\n+        match self.unpack() {\n+            TermKind::Ty(ty) => ty.is_ty_or_numeric_infer(),\n+            TermKind::Const(ct) => ct.is_ct_infer(),\n+        }\n+    }\n }\n \n const TAG_MASK: usize = 0b11;\n@@ -1152,6 +1186,7 @@ impl<'tcx> Predicate<'tcx> {\n         match predicate.skip_binder() {\n             PredicateKind::Clause(Clause::Trait(t)) => Some(predicate.rebind(t)),\n             PredicateKind::Clause(Clause::Projection(..))\n+            | PredicateKind::AliasEq(..)\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n             | PredicateKind::Clause(Clause::RegionOutlives(..))\n@@ -1171,6 +1206,7 @@ impl<'tcx> Predicate<'tcx> {\n         match predicate.skip_binder() {\n             PredicateKind::Clause(Clause::Projection(t)) => Some(predicate.rebind(t)),\n             PredicateKind::Clause(Clause::Trait(..))\n+            | PredicateKind::AliasEq(..)\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n             | PredicateKind::Clause(Clause::RegionOutlives(..))\n@@ -1191,6 +1227,7 @@ impl<'tcx> Predicate<'tcx> {\n             PredicateKind::Clause(Clause::TypeOutlives(data)) => Some(predicate.rebind(data)),\n             PredicateKind::Clause(Clause::Trait(..))\n             | PredicateKind::Clause(Clause::Projection(..))\n+            | PredicateKind::AliasEq(..)\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n             | PredicateKind::Clause(Clause::RegionOutlives(..))"}, {"sha": "7ba531fba78678feec2dc7453655085651da03a6", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -2842,6 +2842,7 @@ define_print_and_forward_display! {\n                 p!(\"the type `\", print(ty), \"` is found in the environment\")\n             }\n             ty::PredicateKind::Ambiguous => p!(\"ambiguous\"),\n+            ty::PredicateKind::AliasEq(t1, t2) => p!(print(t1), \" == \", print(t2)),\n         }\n     }\n "}, {"sha": "1ef66b01ea0c6107fffe77dc65b0a329ba59a67c", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -177,6 +177,7 @@ impl<'tcx> fmt::Debug for ty::PredicateKind<'tcx> {\n                 write!(f, \"TypeWellFormedFromEnv({:?})\", ty)\n             }\n             ty::PredicateKind::Ambiguous => write!(f, \"Ambiguous\"),\n+            ty::PredicateKind::AliasEq(t1, t2) => write!(f, \"AliasEq({t1:?}, {t2:?})\"),\n         }\n     }\n }"}, {"sha": "a55b984fd630dc32e1445c7a331694f4e7b355e2", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -73,6 +73,11 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                                         MismatchedProjectionTypes { err: TypeError::Mismatch },\n                                     )\n                                 }\n+                                ty::PredicateKind::AliasEq(_, _) => {\n+                                    FulfillmentErrorCode::CodeProjectionError(\n+                                        MismatchedProjectionTypes { err: TypeError::Mismatch },\n+                                    )\n+                                }\n                                 ty::PredicateKind::Subtype(pred) => {\n                                     let (a, b) = infcx.instantiate_binder_with_placeholders(\n                                         goal.predicate.kind().rebind((pred.a, pred.b)),"}, {"sha": "e56588c58bd05eb78a639df4d70f67e860109222", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -42,6 +42,8 @@ mod trait_goals;\n \n pub use fulfill::FulfillmentCtxt;\n \n+use self::infcx_ext::InferCtxtExt;\n+\n /// A goal is a statement, i.e. `predicate`, we want to prove\n /// given some assumptions, i.e. `param_env`.\n ///\n@@ -81,6 +83,21 @@ pub struct Response<'tcx> {\n     pub certainty: Certainty,\n }\n \n+trait CanonicalResponseExt {\n+    fn has_no_inference_or_external_constraints(&self) -> bool;\n+}\n+\n+impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n+    fn has_no_inference_or_external_constraints(&self) -> bool {\n+        // so that we get a compile error when regions are supported\n+        // so this code can be checked for being correct\n+        let _: () = self.value.external_constraints.regions;\n+\n+        self.value.var_values.is_identity()\n+            && self.value.external_constraints.opaque_types.is_empty()\n+    }\n+}\n+\n #[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n pub enum Certainty {\n     Yes,\n@@ -302,6 +319,9 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n+                ty::PredicateKind::AliasEq(lhs, rhs) => {\n+                    self.compute_alias_eq_goal(Goal { param_env, predicate: (lhs, rhs) })\n+                }\n             }\n         } else {\n             let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n@@ -398,6 +418,63 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             None => self.make_canonical_response(Certainty::AMBIGUOUS),\n         }\n     }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn compute_alias_eq_goal(\n+        &mut self,\n+        goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>)>,\n+    ) -> QueryResult<'tcx> {\n+        let tcx = self.tcx();\n+\n+        let evaluate_normalizes_to = |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other| {\n+            debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n+            let r = ecx.infcx.probe(|_| {\n+                let (_, certainty) = ecx.evaluate_goal(goal.with(\n+                    tcx,\n+                    ty::Binder::dummy(ty::ProjectionPredicate {\n+                        projection_ty: alias,\n+                        term: other,\n+                    }),\n+                ))?;\n+                ecx.make_canonical_response(certainty)\n+            });\n+            debug!(\"evaluate_normalizes_to(..) -> {:?}\", r);\n+            r\n+        };\n+\n+        if goal.predicate.0.is_infer() || goal.predicate.1.is_infer() {\n+            bug!(\n+                \"`AliasEq` goal with an infer var on lhs or rhs which should have been instantiated\"\n+            );\n+        }\n+\n+        match (\n+            goal.predicate.0.to_alias_term_no_opaque(tcx),\n+            goal.predicate.1.to_alias_term_no_opaque(tcx),\n+        ) {\n+            (None, None) => bug!(\"`AliasEq` goal without an alias on either lhs or rhs\"),\n+            (Some(alias), None) => evaluate_normalizes_to(self, alias, goal.predicate.1),\n+            (None, Some(alias)) => evaluate_normalizes_to(self, alias, goal.predicate.0),\n+            (Some(alias_lhs), Some(alias_rhs)) => {\n+                debug!(\"compute_alias_eq_goal: both sides are aliases\");\n+\n+                let mut candidates = Vec::with_capacity(3);\n+\n+                // Evaluate all 3 potential candidates for the alias' being equal\n+                candidates.push(evaluate_normalizes_to(self, alias_lhs, goal.predicate.1));\n+                candidates.push(evaluate_normalizes_to(self, alias_rhs, goal.predicate.0));\n+                candidates.push(self.infcx.probe(|_| {\n+                    debug!(\"compute_alias_eq_goal: alias defids are equal, equating substs\");\n+                    let nested_goals = self.infcx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n+                    self.evaluate_all_and_make_canonical_response(nested_goals)\n+                }));\n+\n+                debug!(?candidates);\n+\n+                self.try_merge_responses(candidates.into_iter())\n+            }\n+        }\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n@@ -449,6 +526,43 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     ) -> QueryResult<'tcx> {\n         self.evaluate_all(goals).and_then(|certainty| self.make_canonical_response(certainty))\n     }\n+\n+    fn try_merge_responses(\n+        &mut self,\n+        responses: impl Iterator<Item = QueryResult<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        let candidates = responses.into_iter().flatten().collect::<Box<[_]>>();\n+\n+        if candidates.is_empty() {\n+            return Err(NoSolution);\n+        }\n+\n+        // FIXME(-Ztreat-solver=next): We should instead try to find a `Certainty::Yes` response with\n+        // a subset of the constraints that all the other responses have.\n+        let one = candidates[0];\n+        if candidates[1..].iter().all(|resp| resp == &one) {\n+            return Ok(one);\n+        }\n+\n+        if let Some(response) = candidates.iter().find(|response| {\n+            response.value.certainty == Certainty::Yes\n+                && response.has_no_inference_or_external_constraints()\n+        }) {\n+            return Ok(response.clone());\n+        }\n+\n+        let certainty = candidates.iter().fold(Certainty::AMBIGUOUS, |certainty, response| {\n+            certainty.unify_and(response.value.certainty)\n+        });\n+        // FIXME(-Ztrait-solver=next): We should take the intersection of the constraints on all the\n+        // responses and use that for the constraints of this ambiguous response.\n+        let response = self.make_canonical_response(certainty);\n+        if let Ok(response) = &response {\n+            assert!(response.has_no_inference_or_external_constraints());\n+        }\n+\n+        response\n+    }\n }\n \n #[instrument(level = \"debug\", skip(infcx), ret)]"}, {"sha": "6a840704e8637135eea9d29bc4357c0ba25aed81", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -823,14 +823,17 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                         _ => return false,\n                     }\n                 }\n+\n                 // There's not really much we can do with these predicates -\n                 // we start out with a `ParamEnv` with no inference variables,\n                 // and these don't correspond to adding any new bounds to\n                 // the `ParamEnv`.\n                 ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::AliasEq(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)\n+                // FIXME(generic_const_exprs): you can absolutely add this as a where clauses\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::Coerce(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}"}, {"sha": "9474c70cb535e8aeaae5068c48a2f4dfbacbef0e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/method_chain.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -1,5 +1,7 @@\n use crate::infer::InferCtxt;\n \n+use rustc_infer::infer::ObligationEmittingRelation;\n+use rustc_infer::traits::PredicateObligations;\n use rustc_middle::ty::error::TypeError;\n use rustc_middle::ty::relate::{self, Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n@@ -88,3 +90,16 @@ impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n         Ok(a.rebind(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n }\n+\n+impl<'tcx> ObligationEmittingRelation<'tcx> for CollectAllMismatches<'_, 'tcx> {\n+    fn register_obligations(&mut self, _obligations: PredicateObligations<'tcx>) {\n+        // FIXME(deferred_projection_equality)\n+    }\n+\n+    fn register_predicates(\n+        &mut self,\n+        _obligations: impl IntoIterator<Item = impl ty::ToPredicate<'tcx>>,\n+    ) {\n+        // FIXME(deferred_projection_equality)\n+    }\n+}"}, {"sha": "4867855c2ae95fe0feeef37329c197879f7231e9", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -1278,6 +1278,11 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         span,\n                         \"TypeWellFormedFromEnv predicate should only exist in the environment\"\n                     ),\n+\n+                    ty::PredicateKind::AliasEq(..) => span_bug!(\n+                        span,\n+                        \"AliasEq predicate should never be the predicate cause of a SelectionError\"\n+                    ),\n                 }\n             }\n "}, {"sha": "19d47d33f671f02787f1e15f74897c19d43a0e21", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -328,6 +328,9 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n+                ty::PredicateKind::AliasEq(..) => {\n+                    bug!(\"AliasEq is only used for new solver\")\n+                }\n             },\n             Some(pred) => match pred {\n                 ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n@@ -594,6 +597,9 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n+                ty::PredicateKind::AliasEq(..) => {\n+                    bug!(\"AliasEq is only used for new solver\")\n+                }\n             },\n         }\n     }"}, {"sha": "977446894e770b477945baa615e263d75e2a2cb5", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -327,13 +327,16 @@ fn predicate_references_self<'tcx>(\n             // possible alternatives.\n             if data.projection_ty.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n         }\n+        ty::PredicateKind::AliasEq(..) => bug!(\"`AliasEq` not allowed as assumption\"),\n+\n         ty::PredicateKind::WellFormed(..)\n         | ty::PredicateKind::ObjectSafe(..)\n         | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n         | ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n         | ty::PredicateKind::ClosureKind(..)\n         | ty::PredicateKind::Subtype(..)\n         | ty::PredicateKind::Coerce(..)\n+        // FIXME(generic_const_exprs): this can mention `Self`\n         | ty::PredicateKind::ConstEvaluatable(..)\n         | ty::PredicateKind::ConstEquate(..)\n         | ty::PredicateKind::Ambiguous\n@@ -368,6 +371,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n             | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::AliasEq(..)\n             | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => false,\n         }"}, {"sha": "45c4811321a01fb459067f7a6727dda121fc34ee", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -991,6 +991,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for chalk\")\n                 }\n+                ty::PredicateKind::AliasEq(..) => {\n+                    bug!(\"AliasEq is only used for new solver\")\n+                }\n                 ty::PredicateKind::Ambiguous => Ok(EvaluatedToAmbig),\n             }\n         })"}, {"sha": "1136b70a0b91e77ae581d33b5182d7bf2eb3c6a3", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -187,6 +187,9 @@ pub fn predicate_obligations<'tcx>(\n         ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n             bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n         }\n+        ty::PredicateKind::AliasEq(..) => {\n+            bug!(\"We should only wf check where clauses and `AliasEq` is not a `Clause`\")\n+        }\n     }\n \n     wf.normalize(infcx)\n@@ -928,6 +931,7 @@ pub(crate) fn required_region_bounds<'tcx>(\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Ambiguous\n+                | ty::PredicateKind::AliasEq(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n                 ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n                     ref t,"}, {"sha": "7c9a014e2aba59f076edd06933b8b30adac5cb46", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -116,6 +116,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                     )),\n                 },\n                 ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::AliasEq(..)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n@@ -210,6 +211,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             // We can defer this, but ultimately we'll want to express\n             // some of these in terms of chalk operations.\n             ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::AliasEq(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::Ambiguous\n@@ -645,6 +647,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             ty::PredicateKind::WellFormed(_ty) => None,\n \n             ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::AliasEq(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::Coerce(..)\n@@ -778,6 +781,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n             ty::PredicateKind::WellFormed(_ty) => None,\n \n             ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n+            | ty::PredicateKind::AliasEq(..)\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)"}, {"sha": "93f9b66e0f855b577bb358245588ba411655b94d", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -85,7 +85,8 @@ fn compute_implied_outlives_bounds<'tcx>(\n             // learn anything new from those.\n             if obligation.predicate.has_non_region_infer() {\n                 match obligation.predicate.kind().skip_binder() {\n-                    ty::PredicateKind::Clause(ty::Clause::Projection(..)) => {\n+                    ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+                    | ty::PredicateKind::AliasEq(..) => {\n                         ocx.register_obligation(obligation.clone());\n                     }\n                     _ => {}\n@@ -106,6 +107,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Ambiguous\n+                | ty::PredicateKind::AliasEq(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n \n                 // We need to search through *all* WellFormed predicates"}, {"sha": "07e716cda42cc486b27498c60a92873e1d4970fc", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -60,6 +60,7 @@ fn not_outlives_predicate(p: ty::Predicate<'_>) -> bool {\n         | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..)) => false,\n         ty::PredicateKind::Clause(ty::Clause::Trait(..))\n         | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n+        | ty::PredicateKind::AliasEq(..)\n         | ty::PredicateKind::WellFormed(..)\n         | ty::PredicateKind::ObjectSafe(..)\n         | ty::PredicateKind::ClosureKind(..)"}, {"sha": "d497f7ea67976cbc58bc4b4d2b5e25736ed79a29", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -311,10 +311,12 @@ pub(crate) fn clean_predicate<'tcx>(\n         ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n             Some(clean_projection_predicate(bound_predicate.rebind(pred), cx))\n         }\n+        // FIXME(generic_const_exprs): should this do something?\n         ty::PredicateKind::ConstEvaluatable(..) => None,\n         ty::PredicateKind::WellFormed(..) => None,\n \n         ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::AliasEq(..)\n         | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ObjectSafe(..)\n         | ty::PredicateKind::ClosureKind(..)"}, {"sha": "26b1d01974990449c3a5f22ba782e2e9066a7863", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -36,6 +36,7 @@ pub fn is_min_const_fn<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, msrv: &Msrv)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n+                ty::PredicateKind::AliasEq(..) => panic!(\"alias eq predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::ObjectSafe(_) => panic!(\"object safe predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::Subtype(_) => panic!(\"subtype predicate on function: {predicate:#?}\"),"}, {"sha": "dc726ba51f94ffd18ab92635dfd134784f90d89f", "filename": "tests/ui/traits/new-solver/alias_eq_cant_be_furthur_normalized.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_cant_be_furthur_normalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_cant_be_furthur_normalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_cant_be_furthur_normalized.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -0,0 +1,29 @@\n+// check-pass\n+// compile-flags: -Ztrait-solver=next\n+\n+// check that a goal such as `alias-eq(<T as TraitB>::Assoc<bool>, <T as TraitB>::Assoc<?0>)`\n+// succeeds with a constraint that `?0 = bool`\n+\n+// FIXME(deferred_projection_equality): add a test that this is true during coherence\n+\n+trait TraitA {}\n+\n+trait TraitB {\n+    type Assoc<T: ?Sized>;\n+}\n+\n+impl<T: TraitB> TraitA for (T, T::Assoc<bool>) {}\n+\n+impl TraitB for i32 {\n+    type Assoc<T: ?Sized> = u32;\n+}\n+\n+fn needs_a<T: TraitA>() {}\n+\n+fn bar<T: TraitB>() {\n+    needs_a::<(T, <T as TraitB>::Assoc<_>)>();\n+}\n+\n+fn main() {\n+    bar::<i32>();\n+}"}, {"sha": "fd5d0e3b1946e64442ccf44bb0f3d1f7b8465a28", "filename": "tests/ui/traits/new-solver/alias_eq_dont_use_normalizes_to_if_substs_eq.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -0,0 +1,45 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+// check that when computing `alias-eq(<() as Foo<u16, T>>::Assoc, <() as Foo<?0, T>>::Assoc)`\n+//  we do not infer `?0 = u8` via the `for<STOP> (): Foo<u8, STOP>` impl or `?0 = u16` by\n+// relating substs as either could be a valid solution.\n+\n+trait Foo<T, STOP> {\n+    type Assoc;\n+}\n+\n+impl<STOP> Foo<u8, STOP> for ()\n+where\n+    (): Foo<u16, STOP>,\n+{\n+    type Assoc = <() as Foo<u16, STOP>>::Assoc;\n+}\n+\n+impl Foo<u16, i8> for () {\n+    type Assoc = u8;\n+}\n+\n+impl Foo<u16, i16> for () {\n+    type Assoc = u16;\n+}\n+\n+fn output<T, U>() -> <() as Foo<T, U>>::Assoc\n+where\n+    (): Foo<T, U>,\n+{\n+    todo!()\n+}\n+\n+fn incomplete<T>()\n+where\n+    (): Foo<u16, T>,\n+{\n+    // `<() as Foo<u16, STOP>>::Assoc == <() as Foo<_, STOP>>::Assoc`\n+    let _: <() as Foo<u16, T>>::Assoc = output::<_, T>();\n+    //~^ error: type annotations needed\n+\n+    // let _: <() as Foo<u16, T>>::Assoc = output::<u8, T>(); // OK\n+    // let _: <() as Foo<u16, T>>::Assoc = output::<u16, T>(); // OK\n+}\n+\n+fn main() {}"}, {"sha": "a6712332c37c5e1abdf48b0eb325105fa7db981d", "filename": "tests/ui/traits/new-solver/alias_eq_dont_use_normalizes_to_if_substs_eq.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_dont_use_normalizes_to_if_substs_eq.stderr?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/alias_eq_dont_use_normalizes_to_if_substs_eq.rs:38:41\n+   |\n+LL |     let _: <() as Foo<u16, T>>::Assoc = output::<_, T>();\n+   |                                         ^^^^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the function `output`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "6792cf3ce35ab17c35bb37ce72148bb390473b3f", "filename": "tests/ui/traits/new-solver/alias_eq_simple.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_simple.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+// compile-flags: -Ztrait-solver=next\n+\n+// test that the new solver can handle `alias-eq(<i32 as TraitB>::Assoc, u32)`\n+\n+trait TraitA {}\n+\n+trait TraitB {\n+    type Assoc;\n+}\n+\n+impl<T: TraitB> TraitA for (T, T::Assoc) {}\n+\n+impl TraitB for i32 {\n+    type Assoc = u32;\n+}\n+\n+fn needs_a<T: TraitA>() {}\n+\n+fn main() {\n+    needs_a::<(i32, u32)>();\n+}"}, {"sha": "d4cc380fa211b1c87c8750cf4039e90650106eaf", "filename": "tests/ui/traits/new-solver/alias_eq_substs_eq_not_intercrate.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_substs_eq_not_intercrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_substs_eq_not_intercrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_substs_eq_not_intercrate.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+// check that a `alias-eq(<?0 as TraitB>::Assoc, <T as TraitB>::Assoc)` goal fails.\n+\n+// FIXME(deferred_projection_equality): add a test that this is true during coherence\n+\n+trait TraitB {\n+    type Assoc;\n+}\n+\n+fn needs_a<T: TraitB>() -> T::Assoc {\n+    unimplemented!()\n+}\n+\n+fn bar<T: TraitB>() {\n+    let _: <_ as TraitB>::Assoc = needs_a::<T>();\n+    //~^ error: type annotations needed\n+}\n+\n+fn main() {}"}, {"sha": "d063d8fce111cf08d1053c5f22db38b268d48a9a", "filename": "tests/ui/traits/new-solver/alias_eq_substs_eq_not_intercrate.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_substs_eq_not_intercrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_substs_eq_not_intercrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias_eq_substs_eq_not_intercrate.stderr?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/alias_eq_substs_eq_not_intercrate.rs:16:12\n+   |\n+LL |     let _: <_ as TraitB>::Assoc = needs_a::<T>();\n+   |            ^^^^^^^^^^^^^^^^^^^^ cannot infer type for associated type `<_ as TraitB>::Assoc`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "46343241b452868d4c917757f426bab69964d013", "filename": "tests/ui/traits/new-solver/normalizes_to_ignores_unnormalizable_candidate.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Fnormalizes_to_ignores_unnormalizable_candidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Fnormalizes_to_ignores_unnormalizable_candidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fnormalizes_to_ignores_unnormalizable_candidate.rs?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -0,0 +1,40 @@\n+// [no_self_infer] check-pass\n+// compile-flags: -Ztrait-solver=next\n+// revisions: self_infer no_self_infer\n+\n+// checks that the new solver is smart enough to infer `?0 = U` when solving:\n+// `normalizes-to(<Vec<?0> as Trait>::Assoc, u8)`\n+// with `normalizes-to(<Vec<U> as Trait>::Assoc, u8)` in the paramenv even when\n+// there is a separate `Vec<T>: Trait` bound  in the paramenv.\n+//\n+// FIXME(-Ztrait-solver=next)\n+// This could also compile for `normalizes-to(<?0 as Trait>::Assoc, u8)` but\n+// we currently immediately consider a goal ambiguous if the self type is an\n+// inference variable.\n+\n+trait Trait {\n+    type Assoc;\n+}\n+\n+fn foo<T: Trait<Assoc = u8>>(x: T) {}\n+\n+#[cfg(self_infer)]\n+fn unconstrained<T>() -> T {\n+    todo!()\n+}\n+\n+#[cfg(no_self_infer)]\n+fn unconstrained<T>() -> Vec<T> {\n+    todo!()\n+}\n+\n+fn bar<T, U>()\n+where\n+    Vec<T>: Trait,\n+    Vec<U>: Trait<Assoc = u8>,\n+{\n+    foo(unconstrained())\n+    //[self_infer]~^ ERROR type annotations needed\n+}\n+\n+fn main() {}"}, {"sha": "06283201261042a14e48ab314412fb75787c45a5", "filename": "tests/ui/traits/new-solver/normalizes_to_ignores_unnormalizable_candidate.self_infer.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Fnormalizes_to_ignores_unnormalizable_candidate.self_infer.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1623ab0246deebec4fe32dc525d20bf8a88096f2/tests%2Fui%2Ftraits%2Fnew-solver%2Fnormalizes_to_ignores_unnormalizable_candidate.self_infer.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fnormalizes_to_ignores_unnormalizable_candidate.self_infer.stderr?ref=1623ab0246deebec4fe32dc525d20bf8a88096f2", "patch": "@@ -0,0 +1,14 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/normalizes_to_ignores_unnormalizable_candidate.rs:36:5\n+   |\n+LL |     foo(unconstrained())\n+   |     ^^^ cannot infer type of the type parameter `T` declared on the function `foo`\n+   |\n+help: consider specifying the generic argument\n+   |\n+LL |     foo::<T>(unconstrained())\n+   |        +++++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}]}