{"sha": "1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhYzhmYzc2ZDRiNzMyYWU0YmNlMjdiMWFjMzI2YTBjNjQ2MmJlMmM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-24T03:39:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-24T03:39:53Z"}, "message": "Rollup merge of #67337 - oli-obk:no_mut_static_ref_from_const, r=RalfJung\n\nEnsure that evaluating or validating a constant never reads from a static\n\nr? @RalfJung\n\nas per https://github.com/rust-lang/rust/pull/66302#issuecomment-554663387\n\nThis does not yet address the fact that evaluation of a constant can read from a static (under unleash-miri)", "tree": {"sha": "b3247b84fb2194bfedd00f68421c55cb08487e2b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3247b84fb2194bfedd00f68421c55cb08487e2b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeAYiJCRBK7hj4Ov3rIwAAdHIIAIUk699Xtsj7sxeWeYRj6eCP\ntKqby2PvKROTUu90vF8OOuqksLWJ4YP79ZChUaAymJ2hdL8GXlsNWhWxYUE+EwTY\nS99Ydni8xm2Ss+wHdlBgWdrffdzqDUjt6ynPoU7WD6fLtVNW0rZP75Ape6yKhPIK\n0tvPRMy+xE7TZCmjfS91C1musS/F410IOpzerZjrot4u19FQZiwXFNwTLrbgLBH4\nR52DNvYK4N/8K+iOwnB88yPGDSb17YJDTC/Q5Il8nGOszxQDQLnapLOZfB756KoX\n50BSujyC8RMPg7KAG1KsjRToXAJhkbPuVM2KNV+xeIu4SQn7wpPr7uBKFzhFY+A=\n=7Vbq\n-----END PGP SIGNATURE-----\n", "payload": "tree b3247b84fb2194bfedd00f68421c55cb08487e2b\nparent a4cd03dee2b57216b5c95084a0b46de130946ad7\nparent 87fea048714913ae21581446a015a3c98ebc9d53\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1577158793 +0100\ncommitter GitHub <noreply@github.com> 1577158793 +0100\n\nRollup merge of #67337 - oli-obk:no_mut_static_ref_from_const, r=RalfJung\n\nEnsure that evaluating or validating a constant never reads from a static\n\nr? @RalfJung\n\nas per https://github.com/rust-lang/rust/pull/66302#issuecomment-554663387\n\nThis does not yet address the fact that evaluation of a constant can read from a static (under unleash-miri)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "html_url": "https://github.com/rust-lang/rust/commit/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4cd03dee2b57216b5c95084a0b46de130946ad7", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4cd03dee2b57216b5c95084a0b46de130946ad7", "html_url": "https://github.com/rust-lang/rust/commit/a4cd03dee2b57216b5c95084a0b46de130946ad7"}, {"sha": "87fea048714913ae21581446a015a3c98ebc9d53", "url": "https://api.github.com/repos/rust-lang/rust/commits/87fea048714913ae21581446a015a3c98ebc9d53", "html_url": "https://github.com/rust-lang/rust/commit/87fea048714913ae21581446a015a3c98ebc9d53"}], "stats": {"total": 329, "additions": 301, "deletions": 28}, "files": [{"sha": "4fa4e87e0ffb1f56c27d5a7d6d2f82cc162a0a94", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -45,9 +45,15 @@ fn mk_eval_cx<'mir, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n     span: Span,\n     param_env: ty::ParamEnv<'tcx>,\n+    can_access_statics: bool,\n ) -> CompileTimeEvalContext<'mir, 'tcx> {\n     debug!(\"mk_eval_cx: {:?}\", param_env);\n-    InterpCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new(), Default::default())\n+    InterpCx::new(\n+        tcx.at(span),\n+        param_env,\n+        CompileTimeInterpreter::new(),\n+        MemoryExtra { can_access_statics },\n+    )\n }\n \n fn op_to_const<'tcx>(\n@@ -176,6 +182,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n #[derive(Clone, Debug)]\n pub enum ConstEvalError {\n     NeedsRfc(String),\n+    ConstAccessesStatic,\n }\n \n impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalError {\n@@ -195,6 +202,7 @@ impl fmt::Display for ConstEvalError {\n                     msg\n                 )\n             }\n+            ConstAccessesStatic => write!(f, \"constant accesses static\"),\n         }\n     }\n }\n@@ -204,6 +212,7 @@ impl Error for ConstEvalError {\n         use self::ConstEvalError::*;\n         match *self {\n             NeedsRfc(_) => \"this feature needs an rfc before being allowed inside constants\",\n+            ConstAccessesStatic => \"constant accesses static\",\n         }\n     }\n \n@@ -224,6 +233,12 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n     pub(super) loop_detector: snapshot::InfiniteLoopDetector<'mir, 'tcx>,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub struct MemoryExtra {\n+    /// Whether this machine may read from statics\n+    can_access_statics: bool,\n+}\n+\n impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n     fn new() -> Self {\n         CompileTimeInterpreter {\n@@ -311,7 +326,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     type ExtraFnVal = !;\n \n     type FrameExtra = ();\n-    type MemoryExtra = ();\n+    type MemoryExtra = MemoryExtra;\n     type AllocExtra = ();\n \n     type MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>;\n@@ -473,7 +488,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     #[inline(always)]\n     fn init_allocation_extra<'b>(\n-        _memory_extra: &(),\n+        _memory_extra: &MemoryExtra,\n         _id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         _kind: Option<MemoryKind<!>>,\n@@ -484,7 +499,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     #[inline(always)]\n     fn tag_static_base_pointer(\n-        _memory_extra: &(),\n+        _memory_extra: &MemoryExtra,\n         _id: AllocId,\n     ) -> Self::PointerTag {\n         ()\n@@ -527,6 +542,17 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         Ok(())\n     }\n+\n+    fn before_access_static(\n+        memory_extra: &MemoryExtra,\n+        _allocation: &Allocation,\n+    ) -> InterpResult<'tcx> {\n+        if memory_extra.can_access_statics {\n+            Ok(())\n+        } else {\n+            Err(ConstEvalError::ConstAccessesStatic.into())\n+        }\n+    }\n }\n \n /// Extracts a field of a (variant of a) const.\n@@ -540,7 +566,7 @@ pub fn const_field<'tcx>(\n     value: &'tcx ty::Const<'tcx>,\n ) -> &'tcx ty::Const<'tcx> {\n     trace!(\"const_field: {:?}, {:?}\", field, value);\n-    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n+    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n     // get the operand again\n     let op = ecx.eval_const_to_op(value, None).unwrap();\n     // downcast\n@@ -560,7 +586,7 @@ pub fn const_caller_location<'tcx>(\n     (file, line, col): (Symbol, u32, u32),\n ) -> &'tcx ty::Const<'tcx> {\n     trace!(\"const_caller_location: {}:{}:{}\", file, line, col);\n-    let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all());\n+    let mut ecx = mk_eval_cx(tcx, DUMMY_SP, ty::ParamEnv::reveal_all(), false);\n \n     let loc_ty = tcx.caller_location_ty();\n     let loc_place = ecx.alloc_caller_location(file, line, col);\n@@ -581,7 +607,7 @@ pub fn const_variant_index<'tcx>(\n     val: &'tcx ty::Const<'tcx>,\n ) -> VariantIdx {\n     trace!(\"const_variant_index: {:?}\", val);\n-    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env);\n+    let ecx = mk_eval_cx(tcx, DUMMY_SP, param_env, false);\n     let op = ecx.eval_const_to_op(val, None).unwrap();\n     ecx.read_discriminant(op).unwrap().1\n }\n@@ -610,7 +636,9 @@ fn validate_and_turn_into_const<'tcx>(\n     key: ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n     let cid = key.value;\n-    let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env);\n+    let def_id = cid.instance.def.def_id();\n+    let is_static = tcx.is_static(def_id);\n+    let ecx = mk_eval_cx(tcx, tcx.def_span(key.value.instance.def_id()), key.param_env, is_static);\n     let val = (|| {\n         let mplace = ecx.raw_const_to_mplace(constant)?;\n         let mut ref_tracking = RefTracking::new(mplace);\n@@ -624,8 +652,7 @@ fn validate_and_turn_into_const<'tcx>(\n         // Now that we validated, turn this into a proper constant.\n         // Statics/promoteds are always `ByRef`, for the rest `op_to_const` decides\n         // whether they become immediates.\n-        let def_id = cid.instance.def.def_id();\n-        if tcx.is_static(def_id) || cid.promoted.is_some() {\n+        if is_static || cid.promoted.is_some() {\n             let ptr = mplace.ptr.to_ptr()?;\n             Ok(tcx.mk_const(ty::Const {\n                 val: ty::ConstKind::Value(ConstValue::ByRef {\n@@ -732,12 +759,14 @@ pub fn const_eval_raw_provider<'tcx>(\n         return Err(ErrorHandled::Reported);\n     }\n \n+    let is_static = tcx.is_static(def_id);\n+\n     let span = tcx.def_span(cid.instance.def_id());\n     let mut ecx = InterpCx::new(\n         tcx.at(span),\n         key.param_env,\n         CompileTimeInterpreter::new(),\n-        Default::default()\n+        MemoryExtra { can_access_statics: is_static },\n     );\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);\n@@ -751,7 +780,7 @@ pub fn const_eval_raw_provider<'tcx>(\n     }).map_err(|error| {\n         let err = error_to_const_error(&ecx, error);\n         // errors in statics are always emitted as fatal errors\n-        if tcx.is_static(def_id) {\n+        if is_static {\n             // Ensure that if the above error was either `TooGeneric` or `Reported`\n             // an error must be reported.\n             let v = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");"}, {"sha": "b53741e9e43ff5049afdcd3247c7f7d79ca0de6c", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -20,7 +20,6 @@ pub trait CompileTimeMachine<'mir, 'tcx> = Machine<\n     PointerTag = (),\n     ExtraFnVal = !,\n     FrameExtra = (),\n-    MemoryExtra = (),\n     AllocExtra = (),\n     MemoryMap = FxHashMap<AllocId, (MemoryKind<!>, Allocation)>,\n >;\n@@ -320,12 +319,20 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n             // We can't call the `intern_shallow` method here, as its logic is tailored to safe\n             // references and a `leftover_allocations` set (where we only have a todo-list here).\n             // So we hand-roll the interning logic here again.\n-            if base_intern_mode != InternMode::Static {\n-                // If it's not a static, it *must* be immutable.\n-                // We cannot have mutable memory inside a constant.\n-                // FIXME: ideally we would assert that they already are immutable, to double-\n-                // check our static checks.\n-                alloc.mutability = Mutability::Not;\n+            match base_intern_mode {\n+                InternMode::Static => {}\n+                InternMode::Const | InternMode::ConstBase => {\n+                    // If it's not a static, it *must* be immutable.\n+                    // We cannot have mutable memory inside a constant.\n+                    // We use `delay_span_bug` here, because this can be reached in the presence\n+                    // of fancy transmutes.\n+                    if alloc.mutability == Mutability::Mut {\n+                        // For better errors later, mark the allocation as immutable\n+                        // (on top of the delayed ICE).\n+                        alloc.mutability = Mutability::Not;\n+                        ecx.tcx.sess.delay_span_bug(ecx.tcx.span, \"mutable allocation in constant\");\n+                    }\n+                }\n             }\n             let alloc = tcx.intern_const_alloc(alloc);\n             tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n@@ -337,6 +344,8 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n         } else if ecx.memory.dead_alloc_map.contains_key(&alloc_id) {\n             // dangling pointer\n             throw_unsup!(ValidationFailure(\"encountered dangling pointer in final constant\".into()))\n+        } else if ecx.tcx.alloc_map.lock().get(alloc_id).is_none() {\n+            span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);\n         }\n     }\n     Ok(())"}, {"sha": "e77ba9fa4cb0decc6b77bb37658afc3005718f64", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -212,7 +212,10 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     }\n \n     /// Called before a `StaticKind::Static` value is accessed.\n-    fn before_access_static(_allocation: &Allocation) -> InterpResult<'tcx> {\n+    fn before_access_static(\n+        _memory_extra: &Self::MemoryExtra,\n+        _allocation: &Allocation,\n+    ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n "}, {"sha": "71e6d3e8ca1fc87b783139acc81f0436c929097a", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -116,15 +116,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M>\n // carefully copy only the reachable parts.\n impl<'mir, 'tcx, M> Clone for Memory<'mir, 'tcx, M>\n where\n-    M: Machine<'mir, 'tcx, PointerTag = (), AllocExtra = (), MemoryExtra = ()>,\n+    M: Machine<'mir, 'tcx, PointerTag = (), AllocExtra = ()>,\n+    M::MemoryExtra: Copy,\n     M::MemoryMap: AllocMap<AllocId, (MemoryKind<M::MemoryKinds>, Allocation)>,\n {\n     fn clone(&self) -> Self {\n         Memory {\n             alloc_map: self.alloc_map.clone(),\n             extra_fn_ptr_map: self.extra_fn_ptr_map.clone(),\n             dead_alloc_map: self.dead_alloc_map.clone(),\n-            extra: (),\n+            extra: self.extra,\n             tcx: self.tcx,\n         }\n     }\n@@ -455,7 +456,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     let id = raw_const.alloc_id;\n                     let allocation = tcx.alloc_map.lock().unwrap_memory(id);\n \n-                    M::before_access_static(allocation)?;\n+                    M::before_access_static(memory_extra, allocation)?;\n                     Cow::Borrowed(allocation)\n                 }\n             }"}, {"sha": "a6b30ab5e68cf6b0ec0e1e3c0c511644b802ee68", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -224,6 +224,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n     }\n \n     fn before_access_static(\n+        _memory_extra: &(),\n         allocation: &Allocation<Self::PointerTag, Self::AllocExtra>,\n     ) -> InterpResult<'tcx> {\n         // if the static allocation is mutable or if it has relocations (it may be legal to mutate"}, {"sha": "b998b7a97be4e773b43f9a2e2805001fb40d534d", "filename": "src/test/ui/consts/const-points-to-static.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.rs?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -0,0 +1,12 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+\n+#![allow(dead_code)]\n+\n+const TEST: &u8 = &MY_STATIC;\n+//~^ skipping const checks\n+//~| it is undefined behavior to use this value\n+\n+static MY_STATIC: u8 = 4;\n+\n+fn main() {\n+}"}, {"sha": "8949358e2933338ed8797a7ef6caf08ca5f686f9", "filename": "src/test/ui/consts/const-points-to-static.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-points-to-static.stderr?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -0,0 +1,17 @@\n+warning: skipping const checks\n+  --> $DIR/const-points-to-static.rs:5:20\n+   |\n+LL | const TEST: &u8 = &MY_STATIC;\n+   |                    ^^^^^^^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/const-points-to-static.rs:5:1\n+   |\n+LL | const TEST: &u8 = &MY_STATIC;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constant accesses static\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "14ec064e4ceef8a60c01a211c75b489121fc7173", "filename": "src/test/ui/consts/const-prop-read-static-in-const.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-read-static-in-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-read-static-in-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-read-static-in-const.rs?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -1,9 +1,8 @@\n // compile-flags: -Zunleash-the-miri-inside-of-you\n-// run-pass\n \n #![allow(dead_code)]\n \n-const TEST: u8 = MY_STATIC;\n+const TEST: u8 = MY_STATIC; //~ ERROR any use of this value will cause an error\n //~^ skipping const checks\n \n static MY_STATIC: u8 = 4;"}, {"sha": "bfaa0f934ade2ee37a69d2e96dbadb21dc1235be", "filename": "src/test/ui/consts/const-prop-read-static-in-const.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-read-static-in-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-read-static-in-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-prop-read-static-in-const.stderr?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -1,6 +1,18 @@\n warning: skipping const checks\n-  --> $DIR/const-prop-read-static-in-const.rs:6:18\n+  --> $DIR/const-prop-read-static-in-const.rs:5:18\n    |\n LL | const TEST: u8 = MY_STATIC;\n    |                  ^^^^^^^^^\n \n+error: any use of this value will cause an error\n+  --> $DIR/const-prop-read-static-in-const.rs:5:18\n+   |\n+LL | const TEST: u8 = MY_STATIC;\n+   | -----------------^^^^^^^^^-\n+   |                  |\n+   |                  constant accesses static\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: aborting due to previous error\n+"}, {"sha": "55f3f1c8488557b932272f265178905f012ab786", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.rs?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -0,0 +1,38 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+#![warn(const_err)]\n+\n+#![feature(const_raw_ptr_deref)]\n+\n+use std::sync::atomic::AtomicUsize;\n+use std::sync::atomic::Ordering;\n+\n+const BOO: &usize = { //~ ERROR undefined behavior to use this value\n+    static FOO: AtomicUsize = AtomicUsize::new(0);\n+    unsafe { &*(&FOO as *const _ as *const usize) }\n+    //~^ WARN skipping const checks\n+};\n+\n+const FOO: usize = {\n+    static FOO: AtomicUsize = AtomicUsize::new(0);\n+    FOO.fetch_add(1, Ordering::Relaxed) //~ WARN any use of this value will cause an error\n+    //~^ WARN skipping const checks\n+    //~| WARN skipping const checks\n+};\n+\n+const BAR: usize = {\n+    static FOO: AtomicUsize = AtomicUsize::new(0);\n+    unsafe { *(&FOO as *const _ as *const usize) } //~ WARN any use of this value will cause an err\n+    //~^ WARN skipping const checks\n+};\n+\n+static mut MUTABLE: u32 = 0;\n+const BAD: u32 = unsafe { MUTABLE }; //~ WARN any use of this value will cause an error\n+//~^ WARN skipping const checks\n+\n+// ok some day perhaps\n+const BOO_OK: &usize = { //~ ERROR it is undefined behavior to use this value\n+    static FOO: usize = 0;\n+    &FOO\n+    //~^ WARN skipping const checks\n+};\n+fn main() {}"}, {"sha": "6ae88558d700399b8bd1fb7f016b9552c27b789a", "filename": "src/test/ui/consts/miri_unleashed/const_refers_to_static.stderr", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fconst_refers_to_static.stderr?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -0,0 +1,100 @@\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static.rs:11:18\n+   |\n+LL |     unsafe { &*(&FOO as *const _ as *const usize) }\n+   |                  ^^^\n+\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static.rs:17:5\n+   |\n+LL |     FOO.fetch_add(1, Ordering::Relaxed)\n+   |     ^^^\n+\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static.rs:17:5\n+   |\n+LL |     FOO.fetch_add(1, Ordering::Relaxed)\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static.rs:24:17\n+   |\n+LL |     unsafe { *(&FOO as *const _ as *const usize) }\n+   |                 ^^^\n+\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static.rs:29:27\n+   |\n+LL | const BAD: u32 = unsafe { MUTABLE };\n+   |                           ^^^^^^^\n+\n+warning: skipping const checks\n+  --> $DIR/const_refers_to_static.rs:35:6\n+   |\n+LL |     &FOO\n+   |      ^^^\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/const_refers_to_static.rs:9:1\n+   |\n+LL | / const BOO: &usize = {\n+LL | |     static FOO: AtomicUsize = AtomicUsize::new(0);\n+LL | |     unsafe { &*(&FOO as *const _ as *const usize) }\n+LL | |\n+LL | | };\n+   | |__^ constant accesses static\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+warning: any use of this value will cause an error\n+  --> $DIR/const_refers_to_static.rs:17:5\n+   |\n+LL | / const FOO: usize = {\n+LL | |     static FOO: AtomicUsize = AtomicUsize::new(0);\n+LL | |     FOO.fetch_add(1, Ordering::Relaxed)\n+   | |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ calling non-const function `std::sync::atomic::AtomicUsize::fetch_add`\n+LL | |\n+LL | |\n+LL | | };\n+   | |__-\n+   |\n+note: lint level defined here\n+  --> $DIR/const_refers_to_static.rs:2:9\n+   |\n+LL | #![warn(const_err)]\n+   |         ^^^^^^^^^\n+\n+warning: any use of this value will cause an error\n+  --> $DIR/const_refers_to_static.rs:24:14\n+   |\n+LL | / const BAR: usize = {\n+LL | |     static FOO: AtomicUsize = AtomicUsize::new(0);\n+LL | |     unsafe { *(&FOO as *const _ as *const usize) }\n+   | |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ constant accesses static\n+LL | |\n+LL | | };\n+   | |__-\n+\n+warning: any use of this value will cause an error\n+  --> $DIR/const_refers_to_static.rs:29:27\n+   |\n+LL | const BAD: u32 = unsafe { MUTABLE };\n+   | --------------------------^^^^^^^---\n+   |                           |\n+   |                           constant accesses static\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/const_refers_to_static.rs:33:1\n+   |\n+LL | / const BOO_OK: &usize = {\n+LL | |     static FOO: usize = 0;\n+LL | |     &FOO\n+LL | |\n+LL | | };\n+   | |__^ constant accesses static\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rustc repository if you believe it should not be considered undefined behavior.\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "97af1f2f993c347510a2aa2b60660fd20fd7d8c3", "filename": "src/test/ui/consts/miri_unleashed/mutable_const2.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.rs?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -Zunleash-the-miri-inside-of-you\n+// failure-status: 101\n+// rustc-env:RUST_BACKTRACE=0\n+// normalize-stderr-test \"note: rustc 1.* running on .*\" -> \"note: rustc VERSION running on TARGET\"\n+// normalize-stderr-test \"note: compiler flags: .*\" -> \"note: compiler flags: FLAGS\"\n+// normalize-stderr-test \"interpret/intern.rs:[0-9]*:[0-9]*\" -> \"interpret/intern.rs:LL:CC\"\n+\n+#![feature(const_raw_ptr_deref)]\n+#![feature(const_mut_refs)]\n+#![deny(const_err)]\n+\n+use std::cell::UnsafeCell;\n+\n+// make sure we do not just intern this as mutable\n+const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n+//~^ WARN: skipping const checks\n+//~| ERROR: mutable allocation in constant\n+\n+fn main() {}"}, {"sha": "2b4e23cd46e815a02401c8d286cff2f0d95b5adc", "filename": "src/test/ui/consts/miri_unleashed/mutable_const2.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_const2.stderr?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -0,0 +1,25 @@\n+warning: skipping const checks\n+  --> $DIR/mutable_const2.rs:15:38\n+   |\n+LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n+   |                                      ^^^^^^^^^^^^^^^^^^^^\n+\n+error: internal compiler error: mutable allocation in constant\n+  --> $DIR/mutable_const2.rs:15:1\n+   |\n+LL | const MUTABLE_BEHIND_RAW: *mut i32 = &UnsafeCell::new(42) as *const _ as *mut _;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+thread 'rustc' panicked at 'no errors encountered even though `delay_span_bug` issued', src/librustc_errors/lib.rs:349:17\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n+\n+error: internal compiler error: unexpected panic\n+\n+note: the compiler unexpectedly panicked. this is a bug.\n+\n+note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\n+\n+note: rustc VERSION running on TARGET\n+\n+note: compiler flags: FLAGS\n+"}, {"sha": "fed08902c8b9d35def06f90722a25d06b55a4bdc", "filename": "src/test/ui/issues/issue-52060.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fissues%2Fissue-52060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fissues%2Fissue-52060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52060.rs?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -3,5 +3,6 @@\n static A: &'static [u32] = &[1];\n static B: [u32; 1] = [0; A.len()];\n //~^ ERROR [E0013]\n+//~| ERROR evaluation of constant value failed\n \n fn main() {}"}, {"sha": "c69145c1fe8336d22369a6ca551db770cdcf557b", "filename": "src/test/ui/issues/issue-52060.stderr", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fissues%2Fissue-52060.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c/src%2Ftest%2Fui%2Fissues%2Fissue-52060.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52060.stderr?ref=1ac8fc76d4b732ae4bce27b1ac326a0c6462be2c", "patch": "@@ -4,6 +4,13 @@ error[E0013]: constants cannot refer to statics, use a constant instead\n LL | static B: [u32; 1] = [0; A.len()];\n    |                          ^\n \n-error: aborting due to previous error\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/issue-52060.rs:4:26\n+   |\n+LL | static B: [u32; 1] = [0; A.len()];\n+   |                          ^ constant accesses static\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0013`.\n+Some errors have detailed explanations: E0013, E0080.\n+For more information about an error, try `rustc --explain E0013`."}]}