{"sha": "012f909f3546dc7515b43ba389cfc0a1ead0d21f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMmY5MDlmMzU0NmRjNzUxNWI0M2JhMzg5Y2ZjMGExZWFkMGQyMWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-03T19:46:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-03T19:46:32Z"}, "message": "auto merge of #9522 : steveklabnik/rust/doc_std_opts, r=alexcrichton\n\nAdded an overview with a 'real' example, as well as toy implementations of all of\r\nthe traits.\r\n\r\nCloses #9356.", "tree": {"sha": "b0f94214071dcf63f0407e21bfcebe88754ab29f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0f94214071dcf63f0407e21bfcebe88754ab29f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/012f909f3546dc7515b43ba389cfc0a1ead0d21f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/012f909f3546dc7515b43ba389cfc0a1ead0d21f", "html_url": "https://github.com/rust-lang/rust/commit/012f909f3546dc7515b43ba389cfc0a1ead0d21f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/012f909f3546dc7515b43ba389cfc0a1ead0d21f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9344e2a8665ccd8010bd903aab450115de80bf46", "url": "https://api.github.com/repos/rust-lang/rust/commits/9344e2a8665ccd8010bd903aab450115de80bf46", "html_url": "https://github.com/rust-lang/rust/commit/9344e2a8665ccd8010bd903aab450115de80bf46"}, {"sha": "28e88b4c6f752203c4ceff7d87094de63e8fdb8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/28e88b4c6f752203c4ceff7d87094de63e8fdb8d", "html_url": "https://github.com/rust-lang/rust/commit/28e88b4c6f752203c4ceff7d87094de63e8fdb8d"}], "stats": {"total": 384, "additions": 382, "deletions": 2}, "files": [{"sha": "3418fd939bd430fda0f33762772a11e95fef6493", "filename": "src/libstd/ops.rs", "status": "modified", "additions": 382, "deletions": 2, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/012f909f3546dc7515b43ba389cfc0a1ead0d21f/src%2Flibstd%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/012f909f3546dc7515b43ba389cfc0a1ead0d21f/src%2Flibstd%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fops.rs?ref=012f909f3546dc7515b43ba389cfc0a1ead0d21f", "patch": "@@ -8,75 +8,455 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Traits for the built-in operators\n-\n+// So we don't have to document the actual methods on the traits.\n #[allow(missing_doc)];\n \n+/*!\n+ *\n+ * Traits for the built-in operators. Implementing these traits allows you to get\n+ * an effect similar to oveloading operators.\n+ *\n+ * The values for the right hand side of an operator are automatically\n+ * borrowed, so `a + b` is sugar for `a.add(&b)`.\n+ *\n+ * All of these traits are imported by the prelude, so they are available in\n+ * every Rust program.\n+ *\n+ * # Example\n+ *\n+ * This example creates a `Point` struct that implements `Add` and `Sub`, and then\n+ * demonstrates adding and subtracting two `Point`s.\n+ *\n+ * ```rust\n+ * struct Point {\n+ *     x: int,\n+ *     y: int\n+ * }\n+ *\n+ * impl Add<Point, Point> for Point {\n+ *     fn add(&self, other: &Point) -> Point {\n+ *         Point {x: self.x + other.x, y: self.y + other.y}\n+ *     }\n+ * }\n+ *\n+ * impl Sub<Point, Point> for Point {\n+ *     fn sub(&self, other: &Point) -> Point {\n+ *         Point {x: self.x - other.x, y: self.y - other.y}\n+ *     }\n+ * }\n+ * fn main() {\n+ *     println(format!(\"{:?}\", Point {x: 1, y: 0} + Point {x: 2, y: 3}));\n+ *     println(format!(\"{:?}\", Point {x: 1, y: 0} - Point {x: 2, y: 3}));\n+ * }\n+ * ```\n+ *\n+ * See the documentation for each trait for a minimum implementation that prints\n+ * something to the screen.\n+ *\n+ */\n+\n+/**\n+ *\n+ * The `Drop` trait is used to run some code when a value goes out of scope. This\n+ * is sometimes called a 'destructor'.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `Drop`. The `drop` method is called when `_x` goes\n+ * out of scope, and therefore `main` prints `Dropping!`.\n+ *\n+ * ```rust\n+ * struct HasDrop;\n+ *\n+ * impl Drop for HasDrop {\n+ *   fn drop(&mut self) {\n+ *       println(\"Dropping!\");\n+ *   }\n+ * }\n+ *\n+ * fn main() {\n+ *   let _x = HasDrop;\n+ * }\n+ * ```\n+ */\n #[lang=\"drop\"]\n pub trait Drop {\n     fn drop(&mut self);\n }\n \n+/**\n+ *\n+ * The `Add` trait is used to specify the functionality of `+`.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `Add`. When `Foo + Foo` happens, it ends up\n+ * calling `add`, and therefore, `main` prints `Adding!`.\n+ *\n+ * ```rust\n+ * struct Foo;\n+ *\n+ * impl Add<Foo, Foo> for Foo {\n+ *     fn add(&self, _rhs: &Foo) -> Foo {\n+ *       println(\"Adding!\");\n+ *       *self\n+ *   }\n+ * }\n+ *\n+ * fn main() {\n+ *   Foo + Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"add\"]\n pub trait Add<RHS,Result> {\n     fn add(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ *\n+ * The `Sub` trait is used to specify the functionality of `-`.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `Sub`. When `Foo - Foo` happens, it ends up\n+ * calling `sub`, and therefore, `main` prints `Subtracting!`.\n+ *\n+ * ```rust\n+ * struct Foo;\n+ *\n+ * impl Sub<Foo, Foo> for Foo {\n+ *     fn sub(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Subtracting!\");\n+ *         *self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     Foo - Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"sub\"]\n pub trait Sub<RHS,Result> {\n     fn sub(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ *\n+ * The `Mul` trait is used to specify the functionality of `*`.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `Mul`. When `Foo * Foo` happens, it ends up\n+ * calling `mul`, and therefore, `main` prints `Multiplying!`.\n+ *\n+ * ```rust\n+ * struct Foo;\n+ *\n+ * impl Mul<Foo, Foo> for Foo {\n+ *     fn mul(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Multiplying!\");\n+ *         *self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     Foo * Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"mul\"]\n pub trait Mul<RHS,Result> {\n     fn mul(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ *\n+ * The `Div` trait is used to specify the functionality of `/`.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `Div`. When `Foo / Foo` happens, it ends up\n+ * calling `div`, and therefore, `main` prints `Dividing!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl Div<Foo, Foo> for Foo {\n+ *     fn div(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Dividing!\");\n+ *         *self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     Foo / Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"div\"]\n pub trait Div<RHS,Result> {\n     fn div(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ *\n+ * The `Rem` trait is used to specify the functionality of `%`.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `Rem`. When `Foo % Foo` happens, it ends up\n+ * calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl Rem<Foo, Foo> for Foo {\n+ *     fn rem(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Remainder-ing!\");\n+ *         *self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     Foo % Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"rem\"]\n pub trait Rem<RHS,Result> {\n     fn rem(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ *\n+ * The `Neg` trait is used to specify the functionality of unary `-`.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `Neg`. When `-Foo` happens, it ends up calling\n+ * `neg`, and therefore, `main` prints `Negating!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl Neg<Foo> for Foo {\n+ *     fn neg(&self) -> Foo {\n+ *         println(\"Negating!\");\n+ *         *self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     -Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"neg\"]\n pub trait Neg<Result> {\n     fn neg(&self) -> Result;\n }\n \n+/**\n+ *\n+ * The `Not` trait is used to specify the functionality of unary `!`.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `Not`. When `!Foo` happens, it ends up calling\n+ * `not`, and therefore, `main` prints `Not-ing!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl Not<Foo> for Foo {\n+ *     fn not(&self) -> Foo {\n+ *         println(\"Not-ing!\");\n+ *         *self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     !Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"not\"]\n pub trait Not<Result> {\n     fn not(&self) -> Result;\n }\n \n+/**\n+ *\n+ * The `BitAnd` trait is used to specify the functionality of `&`.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `BitAnd`. When `Foo & Foo` happens, it ends up\n+ * calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl BitAnd<Foo, Foo> for Foo {\n+ *     fn bitand(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Bitwise And-ing!\");\n+ *         *self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     Foo & Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"bitand\"]\n pub trait BitAnd<RHS,Result> {\n     fn bitand(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ *\n+ * The `BitOr` trait is used to specify the functionality of `|`.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `BitOr`. When `Foo | Foo` happens, it ends up\n+ * calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl BitOr<Foo, Foo> for Foo {\n+ *     fn bitor(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Bitwise Or-ing!\");\n+ *         *self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     Foo | Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"bitor\"]\n pub trait BitOr<RHS,Result> {\n     fn bitor(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ *\n+ * The `BitXor` trait is used to specify the functionality of `^`.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `BitXor`. When `Foo ^ Foo` happens, it ends up\n+ * calling `bixtor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl BitXor<Foo, Foo> for Foo {\n+ *     fn bitxor(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Bitwise Xor-ing!\");\n+ *         *self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     Foo ^ Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"bitxor\"]\n pub trait BitXor<RHS,Result> {\n     fn bitxor(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ *\n+ * The `Shl` trait is used to specify the functionality of `<<`.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `Shl`. When `Foo << Foo` happens, it ends up\n+ * calling `shl`, and therefore, `main` prints `Shifting left!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl Shl<Foo, Foo> for Foo {\n+ *     fn shl(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Shifting left!\");\n+ *         *self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     Foo << Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"shl\"]\n pub trait Shl<RHS,Result> {\n     fn shl(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ *\n+ * The `Shr` trait is used to specify the functionality of `>>`.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `Shr`. When `Foo >> Foo` happens, it ends up\n+ * calling `shr`, and therefore, `main` prints `Shifting right!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl Shr<Foo, Foo> for Foo {\n+ *     fn shr(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Shifting right!\");\n+ *         *self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     Foo >> Foo;\n+ * }\n+ * ```\n+ */\n #[lang=\"shr\"]\n pub trait Shr<RHS,Result> {\n     fn shr(&self, rhs: &RHS) -> Result;\n }\n \n+/**\n+ *\n+ * The `Index` trait is used to specify the functionality of indexing operations\n+ * like `arr[idx]`.\n+ *\n+ * # Example\n+ *\n+ * A trivial implementation of `Index`. When `Foo[Foo]` happens, it ends up\n+ * calling `index`, and therefore, `main` prints `Indexing!`.\n+ *\n+ * ```\n+ * struct Foo;\n+ *\n+ * impl Index<Foo, Foo> for Foo {\n+ *     fn index(&self, _rhs: &Foo) -> Foo {\n+ *         println(\"Indexing!\");\n+ *         *self\n+ *     }\n+ * }\n+ *\n+ * fn main() {\n+ *     Foo[Foo];\n+ * }\n+ * ```\n+ */\n #[lang=\"index\"]\n pub trait Index<Index,Result> {\n     fn index(&self, index: &Index) -> Result;"}]}