{"sha": "64c58a1a4ab6ba68db6d87a6a1f813679875110e", "node_id": "C_kwDOAAsO6NoAKDY0YzU4YTFhNGFiNmJhNjhkYjZkODdhNmExZjgxMzY3OTg3NTExMGU", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-05-18T06:41:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-18T06:41:13Z"}, "message": "Rollup merge of #94639 - compiler-errors:rval-mutref, r=wesleywiser\n\nSuggest dereferencing non-lval mutable reference on assignment\n\n1. Adds deref suggestions for LHS of assignment (or assign-binop) when it implements `DerefMut`\n2. Fixes missing deref suggestions for LHS when it isn't a place expr\n\nFixes #46276\nFixes #93980", "tree": {"sha": "0940461f48fd451cba2dfdd751c01a9437dbbd4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0940461f48fd451cba2dfdd751c01a9437dbbd4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64c58a1a4ab6ba68db6d87a6a1f813679875110e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJihJUKCRBK7hj4Ov3rIwAAJRcIABT87cNyV6b4PzXZl0mI3kqx\n/nFdQ/HiLlVn+++XFonly74fr9jGjnabCRxfbUDa6+X7b8OikpsySZQISltsfdZD\nFqsBRbRg7/pzR0jxlAALm9s+aHZ/1RdVpSkQJONFCr10576FECM+EVbWc79yiu0O\n1Bp9JwoXbQAF9nl1ZfI6vNDHd+fQHNJrm9+x90u/Yf6YPGlEjlqKJmjy5a9CcFZC\nmyN0AqN0ObeK4FJLZ7URoOwIY1MOmcalzaZ4WD5c8L3uQt9+mFkT6ZlbZFXPrwQa\nK+HYBTo7B8BkoPf3NtLHVvoo/hVFgV4V2QFiqq5gVrmlfvsKtftDh1x+YPGml+k=\n=g8ZC\n-----END PGP SIGNATURE-----\n", "payload": "tree 0940461f48fd451cba2dfdd751c01a9437dbbd4f\nparent 77972d2d0134fb597249b3b64dcf9510a790c34e\nparent d50d3fccdd3038b2621245e9591ea6e20eebde2a\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1652856073 +0200\ncommitter GitHub <noreply@github.com> 1652856073 +0200\n\nRollup merge of #94639 - compiler-errors:rval-mutref, r=wesleywiser\n\nSuggest dereferencing non-lval mutable reference on assignment\n\n1. Adds deref suggestions for LHS of assignment (or assign-binop) when it implements `DerefMut`\n2. Fixes missing deref suggestions for LHS when it isn't a place expr\n\nFixes #46276\nFixes #93980\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64c58a1a4ab6ba68db6d87a6a1f813679875110e", "html_url": "https://github.com/rust-lang/rust/commit/64c58a1a4ab6ba68db6d87a6a1f813679875110e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64c58a1a4ab6ba68db6d87a6a1f813679875110e/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77972d2d0134fb597249b3b64dcf9510a790c34e", "url": "https://api.github.com/repos/rust-lang/rust/commits/77972d2d0134fb597249b3b64dcf9510a790c34e", "html_url": "https://github.com/rust-lang/rust/commit/77972d2d0134fb597249b3b64dcf9510a790c34e"}, {"sha": "d50d3fccdd3038b2621245e9591ea6e20eebde2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d50d3fccdd3038b2621245e9591ea6e20eebde2a", "html_url": "https://github.com/rust-lang/rust/commit/d50d3fccdd3038b2621245e9591ea6e20eebde2a"}], "stats": {"total": 331, "additions": 290, "deletions": 41}, "files": [{"sha": "22683b1de75f13d63e9c62afa2e53fa40ca390d3", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/64c58a1a4ab6ba68db6d87a6a1f813679875110e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c58a1a4ab6ba68db6d87a6a1f813679875110e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=64c58a1a4ab6ba68db6d87a6a1f813679875110e", "patch": "@@ -58,7 +58,8 @@ use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n use rustc_span::{self, BytePos, DesugaringKind, Span};\n use rustc_target::spec::abi::Abi;\n-use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n+use rustc_trait_selection::infer::InferCtxtExt as _;\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{self, ObligationCause, ObligationCauseCode};\n \n use smallvec::{smallvec, SmallVec};\n@@ -962,6 +963,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .find_map(|(ty, steps)| self.probe(|_| coerce.unify(ty, target)).ok().map(|_| steps))\n     }\n \n+    /// Given a type, this function will calculate and return the type given\n+    /// for `<Ty as Deref>::Target` only if `Ty` also implements `DerefMut`.\n+    ///\n+    /// This function is for diagnostics only, since it does not register\n+    /// trait or region sub-obligations. (presumably we could, but it's not\n+    /// particularly important for diagnostics...)\n+    pub fn deref_once_mutably_for_diagnostic(&self, expr_ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+        self.autoderef(rustc_span::DUMMY_SP, expr_ty).nth(1).and_then(|(deref_ty, _)| {\n+            self.infcx\n+                .type_implements_trait(\n+                    self.infcx.tcx.lang_items().deref_mut_trait()?,\n+                    expr_ty,\n+                    ty::List::empty(),\n+                    self.param_env,\n+                )\n+                .may_apply()\n+                .then(|| deref_ty)\n+        })\n+    }\n+\n     /// Given some expressions, their known unified type and another expression,\n     /// tries to unify the types, potentially inserting coercions on any of the\n     /// provided expressions and returns their LUB (aka \"common supertype\")."}, {"sha": "ede2180a8e9e73cf811ae198f9934e32e6280c4a", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/64c58a1a4ab6ba68db6d87a6a1f813679875110e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c58a1a4ab6ba68db6d87a6a1f813679875110e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=64c58a1a4ab6ba68db6d87a6a1f813679875110e", "patch": "@@ -696,28 +696,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         };\n \n                         if let Some(hir::Node::Expr(hir::Expr {\n-                            kind: hir::ExprKind::Assign(left_expr, ..),\n+                            kind: hir::ExprKind::Assign(..),\n                             ..\n                         })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n                         {\n                             if mutability == hir::Mutability::Mut {\n-                                // Found the following case:\n-                                // fn foo(opt: &mut Option<String>){ opt = None }\n-                                //                                   ---   ^^^^\n-                                //                                   |     |\n-                                //    consider dereferencing here: `*opt`  |\n-                                // expected mutable reference, found enum `Option`\n-                                if sm.span_to_snippet(left_expr.span).is_ok() {\n-                                    return Some((\n-                                        left_expr.span.shrink_to_lo(),\n-                                        \"consider dereferencing here to assign to the mutable \\\n-                                         borrowed piece of memory\"\n-                                            .to_string(),\n-                                        \"*\".to_string(),\n-                                        Applicability::MachineApplicable,\n-                                        true,\n-                                    ));\n-                                }\n+                                // Suppressing this diagnostic, we'll properly print it in `check_expr_assign`\n+                                return None;\n                             }\n                         }\n "}, {"sha": "6d56445771a07885aa036ba00f3570fe343144e0", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/64c58a1a4ab6ba68db6d87a6a1f813679875110e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c58a1a4ab6ba68db6d87a6a1f813679875110e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=64c58a1a4ab6ba68db6d87a6a1f813679875110e", "patch": "@@ -51,6 +51,7 @@ use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Pos};\n+use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::{self, ObligationCauseCode};\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -836,6 +837,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         lhs: &'tcx hir::Expr<'tcx>,\n         err_code: &'static str,\n         op_span: Span,\n+        adjust_err: impl FnOnce(&mut DiagnosticBuilder<'tcx, ErrorGuaranteed>),\n     ) {\n         if lhs.is_syntactic_place_expr() {\n             return;\n@@ -858,6 +860,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             );\n         });\n \n+        adjust_err(&mut err);\n+\n         err.emit();\n     }\n \n@@ -1050,10 +1054,47 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return self.tcx.ty_error();\n         }\n \n-        self.check_lhs_assignable(lhs, \"E0070\", span);\n-\n         let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n-        let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty, Some(lhs));\n+\n+        let suggest_deref_binop = |err: &mut DiagnosticBuilder<'tcx, ErrorGuaranteed>,\n+                                   rhs_ty: Ty<'tcx>| {\n+            if let Some(lhs_deref_ty) = self.deref_once_mutably_for_diagnostic(lhs_ty) {\n+                // Can only assign if the type is sized, so if `DerefMut` yields a type that is\n+                // unsized, do not suggest dereferencing it.\n+                let lhs_deref_ty_is_sized = self\n+                    .infcx\n+                    .type_implements_trait(\n+                        self.tcx.lang_items().sized_trait().unwrap(),\n+                        lhs_deref_ty,\n+                        ty::List::empty(),\n+                        self.param_env,\n+                    )\n+                    .may_apply();\n+                if lhs_deref_ty_is_sized && self.can_coerce(rhs_ty, lhs_deref_ty) {\n+                    err.span_suggestion_verbose(\n+                        lhs.span.shrink_to_lo(),\n+                        \"consider dereferencing here to assign to the mutably borrowed value\",\n+                        \"*\".to_string(),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        };\n+\n+        self.check_lhs_assignable(lhs, \"E0070\", span, |err| {\n+            let rhs_ty = self.check_expr(&rhs);\n+            suggest_deref_binop(err, rhs_ty);\n+        });\n+\n+        // This is (basically) inlined `check_expr_coercable_to_type`, but we want\n+        // to suggest an additional fixup here in `suggest_deref_binop`.\n+        let rhs_ty = self.check_expr_with_hint(&rhs, lhs_ty);\n+        if let (_, Some(mut diag)) =\n+            self.demand_coerce_diag(rhs, rhs_ty, lhs_ty, Some(lhs), AllowTwoPhase::No)\n+        {\n+            suggest_deref_binop(&mut diag, rhs_ty);\n+            diag.emit();\n+        }\n \n         self.require_type_is_sized(lhs_ty, lhs.span, traits::AssignmentLhsSized);\n "}, {"sha": "c99d9d8f9230d2824b2f1e944076f53c5ffffd8c", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/64c58a1a4ab6ba68db6d87a6a1f813679875110e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c58a1a4ab6ba68db6d87a6a1f813679875110e/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=64c58a1a4ab6ba68db6d87a6a1f813679875110e", "patch": "@@ -41,7 +41,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 return_ty\n             };\n \n-        self.check_lhs_assignable(lhs, \"E0067\", op.span);\n+        self.check_lhs_assignable(lhs, \"E0067\", op.span, |err| {\n+            if let Some(lhs_deref_ty) = self.deref_once_mutably_for_diagnostic(lhs_ty) {\n+                if self\n+                    .lookup_op_method(\n+                        lhs_deref_ty,\n+                        Some(rhs_ty),\n+                        Some(rhs),\n+                        Op::Binary(op, IsAssign::Yes),\n+                    )\n+                    .is_ok()\n+                {\n+                    // Suppress this error, since we already emitted\n+                    // a deref suggestion in check_overloaded_binop\n+                    err.delay_as_bug();\n+                }\n+            }\n+        });\n \n         ty\n     }\n@@ -404,16 +420,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         (err, missing_trait, use_output)\n                     }\n                 };\n-                if let Ref(_, rty, _) = lhs_ty.kind() {\n-                    if self.infcx.type_is_copy_modulo_regions(self.param_env, *rty, lhs_expr.span)\n-                        && self\n-                            .lookup_op_method(\n-                                *rty,\n-                                Some(rhs_ty),\n-                                Some(rhs_expr),\n-                                Op::Binary(op, is_assign),\n-                            )\n-                            .is_ok()\n+\n+                let mut suggest_deref_binop = |lhs_deref_ty: Ty<'tcx>| {\n+                    if self\n+                        .lookup_op_method(\n+                            lhs_deref_ty,\n+                            Some(rhs_ty),\n+                            Some(rhs_expr),\n+                            Op::Binary(op, is_assign),\n+                        )\n+                        .is_ok()\n                     {\n                         if let Ok(lstring) = source_map.span_to_snippet(lhs_expr.span) {\n                             let msg = &format!(\n@@ -423,7 +439,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     IsAssign::Yes => \"=\",\n                                     IsAssign::No => \"\",\n                                 },\n-                                rty.peel_refs(),\n+                                lhs_deref_ty.peel_refs(),\n                                 lstring,\n                             );\n                             err.span_suggestion_verbose(\n@@ -434,6 +450,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             );\n                         }\n                     }\n+                };\n+\n+                // We should suggest `a + b` => `*a + b` if `a` is copy, and suggest\n+                // `a += b` => `*a += b` if a is a mut ref.\n+                if is_assign == IsAssign::Yes\n+                    && let Some(lhs_deref_ty) = self.deref_once_mutably_for_diagnostic(lhs_ty) {\n+                        suggest_deref_binop(lhs_deref_ty);\n+                } else if is_assign == IsAssign::No\n+                    && let Ref(_, lhs_deref_ty, _) = lhs_ty.kind() {\n+                    if self.infcx.type_is_copy_modulo_regions(self.param_env, *lhs_deref_ty, lhs_expr.span) {\n+                        suggest_deref_binop(*lhs_deref_ty);\n+                    }\n                 }\n                 if let Some(missing_trait) = missing_trait {\n                     let mut visitor = TypeParamVisitor(vec![]);"}, {"sha": "f53ddb95416d15adf0b0266dcdb887cebc8dd9bc", "filename": "src/test/ui/issues/issue-5239-1.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5239-1.stderr?ref=64c58a1a4ab6ba68db6d87a6a1f813679875110e", "patch": "@@ -5,11 +5,6 @@ LL |     let x = |ref x: isize| { x += 1; };\n    |                              -^^^^^\n    |                              |\n    |                              cannot use `+=` on type `&isize`\n-   |\n-help: `+=` can be used on `isize`, you can dereference `x`\n-   |\n-LL |     let x = |ref x: isize| { *x += 1; };\n-   |                              +\n \n error: aborting due to previous error\n "}, {"sha": "b3cb6dd06142be65bca5fe37c3d00e0a9706edd2", "filename": "src/test/ui/suggestions/mut-ref-reassignment.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Fsuggestions%2Fmut-ref-reassignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Fsuggestions%2Fmut-ref-reassignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmut-ref-reassignment.stderr?ref=64c58a1a4ab6ba68db6d87a6a1f813679875110e", "patch": "@@ -8,7 +8,7 @@ LL |     opt = None;\n    |\n    = note: expected mutable reference `&mut Option<String>`\n                            found enum `Option<_>`\n-help: consider dereferencing here to assign to the mutable borrowed piece of memory\n+help: consider dereferencing here to assign to the mutably borrowed value\n    |\n LL |     *opt = None;\n    |     +\n@@ -34,7 +34,7 @@ LL |     opt = Some(String::new())\n    |\n    = note: expected mutable reference `&mut Option<String>`\n                            found enum `Option<String>`\n-help: consider dereferencing here to assign to the mutable borrowed piece of memory\n+help: consider dereferencing here to assign to the mutably borrowed value\n    |\n LL |     *opt = Some(String::new())\n    |     +"}, {"sha": "0c23199af22706526f6a4acf73b8cb12622dcf53", "filename": "src/test/ui/typeck/assign-non-lval-derefmut.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.fixed?ref=64c58a1a4ab6ba68db6d87a6a1f813679875110e", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+fn main() {\n+    let x = std::sync::Mutex::new(1usize);\n+    *x.lock().unwrap() = 2;\n+    //~^ ERROR invalid left-hand side of assignment\n+    *x.lock().unwrap() += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `MutexGuard<'_, usize>`\n+\n+    let mut y = x.lock().unwrap();\n+    *y = 2;\n+    //~^ ERROR mismatched types\n+    *y += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `MutexGuard<'_, usize>`\n+}"}, {"sha": "ec1882f5271b19e89dba3b0f76615685d4da4015", "filename": "src/test/ui/typeck/assign-non-lval-derefmut.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.rs?ref=64c58a1a4ab6ba68db6d87a6a1f813679875110e", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+fn main() {\n+    let x = std::sync::Mutex::new(1usize);\n+    x.lock().unwrap() = 2;\n+    //~^ ERROR invalid left-hand side of assignment\n+    x.lock().unwrap() += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `MutexGuard<'_, usize>`\n+\n+    let mut y = x.lock().unwrap();\n+    y = 2;\n+    //~^ ERROR mismatched types\n+    y += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `MutexGuard<'_, usize>`\n+}"}, {"sha": "a6fcdfe21f481a3fb99435827c80454274974b32", "filename": "src/test/ui/typeck/assign-non-lval-derefmut.stderr", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-derefmut.stderr?ref=64c58a1a4ab6ba68db6d87a6a1f813679875110e", "patch": "@@ -0,0 +1,58 @@\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/assign-non-lval-derefmut.rs:5:23\n+   |\n+LL |     x.lock().unwrap() = 2;\n+   |     ----------------- ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+help: consider dereferencing here to assign to the mutably borrowed value\n+   |\n+LL |     *x.lock().unwrap() = 2;\n+   |     +\n+\n+error[E0368]: binary assignment operation `+=` cannot be applied to type `MutexGuard<'_, usize>`\n+  --> $DIR/assign-non-lval-derefmut.rs:7:5\n+   |\n+LL |     x.lock().unwrap() += 1;\n+   |     -----------------^^^^^\n+   |     |\n+   |     cannot use `+=` on type `MutexGuard<'_, usize>`\n+   |\n+help: `+=` can be used on `usize`, you can dereference `x.lock().unwrap()`\n+   |\n+LL |     *x.lock().unwrap() += 1;\n+   |     +\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assign-non-lval-derefmut.rs:11:9\n+   |\n+LL |     let mut y = x.lock().unwrap();\n+   |                 ----------------- expected due to this value\n+LL |     y = 2;\n+   |         ^ expected struct `MutexGuard`, found integer\n+   |\n+   = note: expected struct `MutexGuard<'_, usize>`\n+                found type `{integer}`\n+help: consider dereferencing here to assign to the mutably borrowed value\n+   |\n+LL |     *y = 2;\n+   |     +\n+\n+error[E0368]: binary assignment operation `+=` cannot be applied to type `MutexGuard<'_, usize>`\n+  --> $DIR/assign-non-lval-derefmut.rs:13:5\n+   |\n+LL |     y += 1;\n+   |     -^^^^^\n+   |     |\n+   |     cannot use `+=` on type `MutexGuard<'_, usize>`\n+   |\n+help: `+=` can be used on `usize`, you can dereference `y`\n+   |\n+LL |     *y += 1;\n+   |     +\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0070, E0308, E0368.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "10c7b9dbfb331182333e6dfa58a7ba27f3ab0af9", "filename": "src/test/ui/typeck/assign-non-lval-mut-ref.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.fixed?ref=64c58a1a4ab6ba68db6d87a6a1f813679875110e", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+fn main() {\n+    let mut x = vec![1usize];\n+    *x.last_mut().unwrap() = 2;\n+    //~^ ERROR invalid left-hand side of assignment\n+    *x.last_mut().unwrap() += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `&mut usize`\n+\n+    let y = x.last_mut().unwrap();\n+    *y = 2;\n+    //~^ ERROR mismatched types\n+    *y += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `&mut usize`\n+}"}, {"sha": "bceff0ef09d190c92eea614259fe431f8c11a5b9", "filename": "src/test/ui/typeck/assign-non-lval-mut-ref.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.rs?ref=64c58a1a4ab6ba68db6d87a6a1f813679875110e", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+fn main() {\n+    let mut x = vec![1usize];\n+    x.last_mut().unwrap() = 2;\n+    //~^ ERROR invalid left-hand side of assignment\n+    x.last_mut().unwrap() += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `&mut usize`\n+\n+    let y = x.last_mut().unwrap();\n+    y = 2;\n+    //~^ ERROR mismatched types\n+    y += 1;\n+    //~^ ERROR binary assignment operation `+=` cannot be applied to type `&mut usize`\n+}"}, {"sha": "be2e9fe95e87144a3e27ffcfe1d4d14267c2d14e", "filename": "src/test/ui/typeck/assign-non-lval-mut-ref.stderr", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fassign-non-lval-mut-ref.stderr?ref=64c58a1a4ab6ba68db6d87a6a1f813679875110e", "patch": "@@ -0,0 +1,56 @@\n+error[E0070]: invalid left-hand side of assignment\n+  --> $DIR/assign-non-lval-mut-ref.rs:5:27\n+   |\n+LL |     x.last_mut().unwrap() = 2;\n+   |     --------------------- ^\n+   |     |\n+   |     cannot assign to this expression\n+   |\n+help: consider dereferencing here to assign to the mutably borrowed value\n+   |\n+LL |     *x.last_mut().unwrap() = 2;\n+   |     +\n+\n+error[E0368]: binary assignment operation `+=` cannot be applied to type `&mut usize`\n+  --> $DIR/assign-non-lval-mut-ref.rs:7:5\n+   |\n+LL |     x.last_mut().unwrap() += 1;\n+   |     ---------------------^^^^^\n+   |     |\n+   |     cannot use `+=` on type `&mut usize`\n+   |\n+help: `+=` can be used on `usize`, you can dereference `x.last_mut().unwrap()`\n+   |\n+LL |     *x.last_mut().unwrap() += 1;\n+   |     +\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assign-non-lval-mut-ref.rs:11:9\n+   |\n+LL |     let y = x.last_mut().unwrap();\n+   |             --------------------- expected due to this value\n+LL |     y = 2;\n+   |         ^ expected `&mut usize`, found integer\n+   |\n+help: consider dereferencing here to assign to the mutably borrowed value\n+   |\n+LL |     *y = 2;\n+   |     +\n+\n+error[E0368]: binary assignment operation `+=` cannot be applied to type `&mut usize`\n+  --> $DIR/assign-non-lval-mut-ref.rs:13:5\n+   |\n+LL |     y += 1;\n+   |     -^^^^^\n+   |     |\n+   |     cannot use `+=` on type `&mut usize`\n+   |\n+help: `+=` can be used on `usize`, you can dereference `y`\n+   |\n+LL |     *y += 1;\n+   |     +\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0070, E0308, E0368.\n+For more information about an error, try `rustc --explain E0070`."}, {"sha": "167edc8942aec47d11cc2c26860ec9ca269de9d1", "filename": "src/test/ui/typeck/issue-93486.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Ftypeck%2Fissue-93486.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64c58a1a4ab6ba68db6d87a6a1f813679875110e/src%2Ftest%2Fui%2Ftypeck%2Fissue-93486.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fissue-93486.stderr?ref=64c58a1a4ab6ba68db6d87a6a1f813679875110e", "patch": "@@ -5,6 +5,11 @@ LL |         vec![].last_mut().unwrap() = 3_u8;\n    |         -------------------------- ^\n    |         |\n    |         cannot assign to this expression\n+   |\n+help: consider dereferencing here to assign to the mutably borrowed value\n+   |\n+LL |         *vec![].last_mut().unwrap() = 3_u8;\n+   |         +\n \n error: aborting due to previous error\n "}]}