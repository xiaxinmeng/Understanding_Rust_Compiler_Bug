{"sha": "6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkYTllM2MyMjY3M2NhOTdkM2RkZDFhNDA4MWFmNTdlNzcyM2M0ZDM=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-02-12T06:11:32Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2021-02-17T01:58:38Z"}, "message": "Take `&mut DocContext` in passes\n\nThis should hopefully allow for less interior mutability.", "tree": {"sha": "82af474a03b1bd2b3fe1ed6b8ca2215df87b1ba7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82af474a03b1bd2b3fe1ed6b8ca2215df87b1ba7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "html_url": "https://github.com/rust-lang/rust/commit/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd", "html_url": "https://github.com/rust-lang/rust/commit/8fe989dd768f5dfdb0fc90933f3f74fa4579fefd"}], "stats": {"total": 132, "additions": 49, "deletions": 83}, "files": [{"sha": "c92b1884f6958e26ab9edc53ce67c51ac6bc2ffd", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "patch": "@@ -627,7 +627,7 @@ crate fn run_global_ctxt(\n         };\n         if run {\n             debug!(\"running pass {}\", p.pass.name);\n-            krate = ctxt.tcx.sess.time(p.pass.name, || (p.pass.run)(krate, &ctxt));\n+            krate = ctxt.tcx.sess.time(p.pass.name, || (p.pass.run)(krate, &mut ctxt));\n         }\n     }\n "}, {"sha": "542cf6d2c275ad5838fe367c7c1bcad4f66cb9f4", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "patch": "@@ -20,8 +20,8 @@ crate const CALCULATE_DOC_COVERAGE: Pass = Pass {\n     description: \"counts the number of items with and without documentation\",\n };\n \n-fn calculate_doc_coverage(krate: clean::Crate, ctx: &DocContext<'_>) -> clean::Crate {\n-    let mut calc = CoverageCalculator::new(ctx);\n+fn calculate_doc_coverage(krate: clean::Crate, ctx: &mut DocContext<'_>) -> clean::Crate {\n+    let mut calc = CoverageCalculator { items: Default::default(), ctx };\n     let krate = calc.fold_crate(krate);\n \n     calc.print_results();\n@@ -101,7 +101,7 @@ impl ops::AddAssign for ItemCount {\n \n struct CoverageCalculator<'a, 'b> {\n     items: BTreeMap<FileName, ItemCount>,\n-    ctx: &'a DocContext<'b>,\n+    ctx: &'a mut DocContext<'b>,\n }\n \n fn limit_filename_len(filename: String) -> String {\n@@ -115,10 +115,6 @@ fn limit_filename_len(filename: String) -> String {\n }\n \n impl<'a, 'b> CoverageCalculator<'a, 'b> {\n-    fn new(ctx: &'a DocContext<'b>) -> CoverageCalculator<'a, 'b> {\n-        CoverageCalculator { items: Default::default(), ctx }\n-    }\n-\n     fn to_json(&self) -> String {\n         serde_json::to_string(\n             &self"}, {"sha": "c85490864ec70e68a1037d780ac961bc001896c1", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "patch": "@@ -17,7 +17,7 @@ crate const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n     description: \"validates syntax inside Rust code blocks\",\n };\n \n-crate fn check_code_block_syntax(krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n+crate fn check_code_block_syntax(krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n     SyntaxChecker { cx }.fold_crate(krate)\n }\n "}, {"sha": "398b9cfc364471be0267313b8ba6b18e13441bac", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 26, "deletions": 33, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "patch": "@@ -47,8 +47,13 @@ crate const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n     description: \"resolves intra-doc links\",\n };\n \n-crate fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n-    LinkCollector::new(cx).fold_crate(krate)\n+crate fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+    LinkCollector {\n+        cx,\n+        mod_ids: Vec::new(),\n+        kind_side_channel: Cell::new(None),\n+        visited_links: FxHashMap::default(),\n+    }.fold_crate(krate)\n }\n \n /// Top-level errors emitted by this pass.\n@@ -257,7 +262,7 @@ struct CachedLink {\n }\n \n struct LinkCollector<'a, 'tcx> {\n-    cx: &'a DocContext<'tcx>,\n+    cx: &'a mut DocContext<'tcx>,\n     /// A stack of modules used to decide what scope to resolve in.\n     ///\n     /// The last module will be used if the parent scope of the current item is\n@@ -273,15 +278,6 @@ struct LinkCollector<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n-    fn new(cx: &'a DocContext<'tcx>) -> Self {\n-        LinkCollector {\n-            cx,\n-            mod_ids: Vec::new(),\n-            kind_side_channel: Cell::new(None),\n-            visited_links: FxHashMap::default(),\n-        }\n-    }\n-\n     /// Given a full link, parse it as an [enum struct variant].\n     ///\n     /// In particular, this will return an error whenever there aren't three\n@@ -293,7 +289,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'path str,\n         module_id: DefId,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n-        let cx = self.cx;\n+        let tcx = self.cx.tcx;\n         let no_res = || ResolutionFailure::NotResolved {\n             module_id,\n             partial_res: None,\n@@ -317,7 +313,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             // If there's no third component, we saw `[a::b]` before and it failed to resolve.\n             // So there's no partial res.\n             .ok_or_else(no_res)?;\n-        let ty_res = cx\n+        let ty_res = self.cx\n             .enter_resolver(|resolver| {\n                 resolver.resolve_str_path_error(DUMMY_SP, &path, TypeNS, module_id)\n             })\n@@ -326,18 +322,17 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n         match ty_res {\n             Res::Def(DefKind::Enum, did) => {\n-                if cx\n-                    .tcx\n+                if tcx\n                     .inherent_impls(did)\n                     .iter()\n-                    .flat_map(|imp| cx.tcx.associated_items(*imp).in_definition_order())\n+                    .flat_map(|imp| tcx.associated_items(*imp).in_definition_order())\n                     .any(|item| item.ident.name == variant_name)\n                 {\n                     // This is just to let `fold_item` know that this shouldn't be considered;\n                     // it's a bug for the error to make it to the user\n                     return Err(ResolutionFailure::Dummy.into());\n                 }\n-                match cx.tcx.type_of(did).kind() {\n+                match tcx.type_of(did).kind() {\n                     ty::Adt(def, _) if def.is_enum() => {\n                         if def.all_fields().any(|item| item.ident.name == variant_field_name) {\n                             Ok((\n@@ -380,16 +375,16 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         item_name: Symbol,\n         item_str: &'path str,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n-        let cx = self.cx;\n+        let tcx = self.cx.tcx;\n \n         prim_ty\n-            .impls(cx.tcx)\n+            .impls(tcx)\n             .into_iter()\n             .find_map(|&impl_| {\n-                cx.tcx\n+                tcx\n                     .associated_items(impl_)\n                     .find_by_name_and_namespace(\n-                        cx.tcx,\n+                        tcx,\n                         Ident::with_dummy_span(item_name),\n                         ns,\n                         impl_,\n@@ -434,9 +429,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         path_str: &'a str,\n         module_id: DefId,\n     ) -> Result<Res, ResolutionFailure<'a>> {\n-        let cx = self.cx;\n         let path = ast::Path::from_ident(Ident::from_str(path_str));\n-        cx.enter_resolver(|resolver| {\n+        self.cx.enter_resolver(|resolver| {\n             // FIXME(jynelson): does this really need 3 separate lookups?\n             if let Ok((Some(ext), res)) = resolver.resolve_macro_path(\n                 &path,\n@@ -498,7 +492,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         module_id: DefId,\n         extra_fragment: &Option<String>,\n     ) -> Result<(Res, Option<String>), ErrorKind<'path>> {\n-        let cx = self.cx;\n+        let cx = &self.cx;\n \n         if let Some(res) = self.resolve_path(path_str, ns, module_id) {\n             match res {\n@@ -948,12 +942,11 @@ impl LinkCollector<'_, '_> {\n             return None;\n         }\n \n-        let cx = self.cx;\n         let link = ori_link.link.replace(\"`\", \"\");\n         let parts = link.split('#').collect::<Vec<_>>();\n         let (link, extra_fragment) = if parts.len() > 2 {\n             // A valid link can't have multiple #'s\n-            anchor_failure(cx, &item, &link, dox, ori_link.range, AnchorFailure::MultipleAnchors);\n+            anchor_failure(self.cx, &item, &link, dox, ori_link.range, AnchorFailure::MultipleAnchors);\n             return None;\n         } else if parts.len() == 2 {\n             if parts[0].trim().is_empty() {\n@@ -1105,7 +1098,7 @@ impl LinkCollector<'_, '_> {\n                 if matches!(disambiguator, Some(Disambiguator::Primitive)) {\n                     if fragment.is_some() {\n                         anchor_failure(\n-                            cx,\n+                            self.cx,\n                             &item,\n                             path_str,\n                             dox,\n@@ -1119,7 +1112,7 @@ impl LinkCollector<'_, '_> {\n                 } else {\n                     // `[char]` when a `char` module is in scope\n                     let candidates = vec![res, prim];\n-                    ambiguity_error(cx, &item, path_str, dox, ori_link.range, candidates);\n+                    ambiguity_error(self.cx, &item, path_str, dox, ori_link.range, candidates);\n                     return None;\n                 }\n             }\n@@ -1140,7 +1133,7 @@ impl LinkCollector<'_, '_> {\n                 suggest_disambiguator(resolved, diag, path_str, dox, sp, &ori_link.range);\n             };\n             report_diagnostic(\n-                cx,\n+                self.cx,\n                 BROKEN_INTRA_DOC_LINKS,\n                 &msg,\n                 &item,\n@@ -1187,7 +1180,7 @@ impl LinkCollector<'_, '_> {\n                 if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n                     && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)\n                 {\n-                    privacy_error(cx, &item, &path_str, dox, &ori_link);\n+                    privacy_error(self.cx, &item, &path_str, dox, &ori_link);\n                 }\n             }\n \n@@ -1211,7 +1204,7 @@ impl LinkCollector<'_, '_> {\n                         && !self.cx.tcx.features().intra_doc_pointers\n                     {\n                         let span = super::source_span_for_markdown_range(\n-                            cx,\n+                            self.cx,\n                             dox,\n                             &ori_link.range,\n                             &item.attrs,\n@@ -1243,7 +1236,7 @@ impl LinkCollector<'_, '_> {\n             }\n             Res::Def(kind, id) => {\n                 verify(kind, id)?;\n-                let id = clean::register_res(cx, rustc_hir::def::Res::Def(kind, id));\n+                let id = clean::register_res(self.cx, rustc_hir::def::Res::Def(kind, id));\n                 Some(ItemLink { link: ori_link.link, link_text, did: Some(id), fragment })\n             }\n         }"}, {"sha": "6ca37453de6bf7c2397201311734a6918f73d7dc", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "patch": "@@ -14,8 +14,8 @@ crate const COLLECT_TRAIT_IMPLS: Pass = Pass {\n     description: \"retrieves trait impls for items in the crate\",\n };\n \n-crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n-    let mut synth = SyntheticImplCollector::new(cx);\n+crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+    let mut synth = SyntheticImplCollector { cx, impls: Vec::new() };\n     let mut krate = cx.sess().time(\"collect_synthetic_impls\", || synth.fold_crate(krate));\n \n     let prims: FxHashSet<PrimitiveType> = krate.primitives.iter().map(|p| p.1).collect();\n@@ -164,12 +164,6 @@ struct SyntheticImplCollector<'a, 'tcx> {\n     impls: Vec<Item>,\n }\n \n-impl<'a, 'tcx> SyntheticImplCollector<'a, 'tcx> {\n-    fn new(cx: &'a DocContext<'tcx>) -> Self {\n-        SyntheticImplCollector { cx, impls: Vec::new() }\n-    }\n-}\n-\n impl<'a, 'tcx> DocFolder for SyntheticImplCollector<'a, 'tcx> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if i.is_struct() || i.is_enum() || i.is_union() {"}, {"sha": "042a895d2fa2f4e8daf314db6a3660e2b89451a4", "filename": "src/librustdoc/passes/doc_test_lints.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fdoc_test_lints.rs?ref=6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "patch": "@@ -19,27 +19,20 @@ crate const CHECK_PRIVATE_ITEMS_DOC_TESTS: Pass = Pass {\n };\n \n struct PrivateItemDocTestLinter<'a, 'tcx> {\n-    cx: &'a DocContext<'tcx>,\n+    cx: &'a mut DocContext<'tcx>,\n }\n \n-impl<'a, 'tcx> PrivateItemDocTestLinter<'a, 'tcx> {\n-    fn new(cx: &'a DocContext<'tcx>) -> Self {\n-        PrivateItemDocTestLinter { cx }\n-    }\n-}\n-\n-crate fn check_private_items_doc_tests(krate: Crate, cx: &DocContext<'_>) -> Crate {\n-    let mut coll = PrivateItemDocTestLinter::new(cx);\n+crate fn check_private_items_doc_tests(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+    let mut coll = PrivateItemDocTestLinter { cx };\n \n     coll.fold_crate(krate)\n }\n \n impl<'a, 'tcx> DocFolder for PrivateItemDocTestLinter<'a, 'tcx> {\n     fn fold_item(&mut self, item: Item) -> Option<Item> {\n-        let cx = self.cx;\n         let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);\n \n-        look_for_tests(&cx, &dox, &item);\n+        look_for_tests(self.cx, &dox, &item);\n \n         Some(self.fold_item_recur(item))\n     }"}, {"sha": "a6fe7e228d7e8105ed7c95c0eee666ed6747e4c7", "filename": "src/librustdoc/passes/html_tags.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fhtml_tags.rs?ref=6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "patch": "@@ -16,20 +16,14 @@ crate const CHECK_INVALID_HTML_TAGS: Pass = Pass {\n };\n \n struct InvalidHtmlTagsLinter<'a, 'tcx> {\n-    cx: &'a DocContext<'tcx>,\n+    cx: &'a mut DocContext<'tcx>,\n }\n \n-impl<'a, 'tcx> InvalidHtmlTagsLinter<'a, 'tcx> {\n-    fn new(cx: &'a DocContext<'tcx>) -> Self {\n-        InvalidHtmlTagsLinter { cx }\n-    }\n-}\n-\n-crate fn check_invalid_html_tags(krate: Crate, cx: &DocContext<'_>) -> Crate {\n+crate fn check_invalid_html_tags(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     if !cx.tcx.sess.is_nightly_build() {\n         krate\n     } else {\n-        let mut coll = InvalidHtmlTagsLinter::new(cx);\n+        let mut coll = InvalidHtmlTagsLinter { cx };\n \n         coll.fold_crate(krate)\n     }"}, {"sha": "5813732facb6e92f6ad38e4195ca391d74a5b24d", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "patch": "@@ -53,7 +53,7 @@ crate use self::html_tags::CHECK_INVALID_HTML_TAGS;\n #[derive(Copy, Clone)]\n crate struct Pass {\n     crate name: &'static str,\n-    crate run: fn(clean::Crate, &DocContext<'_>) -> clean::Crate,\n+    crate run: fn(clean::Crate, &mut DocContext<'_>) -> clean::Crate,\n     crate description: &'static str,\n }\n "}, {"sha": "1bce5060d770e662f6269edca952eb5f390deba2", "filename": "src/librustdoc/passes/non_autolinks.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fnon_autolinks.rs?ref=6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "patch": "@@ -23,15 +23,11 @@ const URL_REGEX: &str = concat!(\n );\n \n struct NonAutolinksLinter<'a, 'tcx> {\n-    cx: &'a DocContext<'tcx>,\n+    cx: &'a mut DocContext<'tcx>,\n     regex: Regex,\n }\n \n impl<'a, 'tcx> NonAutolinksLinter<'a, 'tcx> {\n-    fn new(cx: &'a DocContext<'tcx>) -> Self {\n-        Self { cx, regex: Regex::new(URL_REGEX).expect(\"failed to build regex\") }\n-    }\n-\n     fn find_raw_urls(\n         &self,\n         text: &str,\n@@ -52,11 +48,11 @@ impl<'a, 'tcx> NonAutolinksLinter<'a, 'tcx> {\n     }\n }\n \n-crate fn check_non_autolinks(krate: Crate, cx: &DocContext<'_>) -> Crate {\n+crate fn check_non_autolinks(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     if !cx.tcx.sess.is_nightly_build() {\n         krate\n     } else {\n-        let mut coll = NonAutolinksLinter::new(cx);\n+        let mut coll = NonAutolinksLinter { cx, regex: Regex::new(URL_REGEX).expect(\"failed to build regex\") };\n \n         coll.fold_crate(krate)\n     }"}, {"sha": "2369ff78b1ce05eee76299ab1e9383da4b919fbc", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "patch": "@@ -12,7 +12,7 @@ crate const PROPAGATE_DOC_CFG: Pass = Pass {\n     description: \"propagates `#[doc(cfg(...))]` to child items\",\n };\n \n-crate fn propagate_doc_cfg(cr: Crate, _: &DocContext<'_>) -> Crate {\n+crate fn propagate_doc_cfg(cr: Crate, _: &mut DocContext<'_>) -> Crate {\n     CfgPropagator { parent_cfg: None }.fold_crate(cr)\n }\n "}, {"sha": "c742d32cb62eab09756d992a712d76ebeedcbf53", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "patch": "@@ -15,7 +15,7 @@ crate const STRIP_HIDDEN: Pass = Pass {\n };\n \n /// Strip items marked `#[doc(hidden)]`\n-crate fn strip_hidden(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n+crate fn strip_hidden(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n     let mut retained = DefIdSet::default();\n \n     // strip all #[doc(hidden)] items"}, {"sha": "63869324cb8d234c94314a14a09f33b74b92ad9c", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "patch": "@@ -9,6 +9,6 @@ crate const STRIP_PRIV_IMPORTS: Pass = Pass {\n     description: \"strips all private import statements (`use`, `extern crate`) from a crate\",\n };\n \n-crate fn strip_priv_imports(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n+crate fn strip_priv_imports(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n     ImportStripper.fold_crate(krate)\n }"}, {"sha": "c0bb05af3edb51dda040b94ef9a758beb5374cdb", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "patch": "@@ -14,7 +14,7 @@ crate const STRIP_PRIVATE: Pass = Pass {\n \n /// Strip private items from the point of view of a crate or externally from a\n /// crate, specified by the `xcrate` flag.\n-crate fn strip_private(mut krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n+crate fn strip_private(mut krate: clean::Crate, cx: &mut DocContext<'_>) -> clean::Crate {\n     // This stripper collects all *retained* nodes.\n     let mut retained = DefIdSet::default();\n     let access_levels = cx.renderinfo.borrow().access_levels.clone();"}, {"sha": "da2eda73641228e737f6f70cab177bbc48511940", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6da9e3c22673ca97d3ddd1a4081af57e7723c4d3/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=6da9e3c22673ca97d3ddd1a4081af57e7723c4d3", "patch": "@@ -14,7 +14,7 @@ crate const UNINDENT_COMMENTS: Pass = Pass {\n     description: \"removes excess indentation on comments in order for markdown to like it\",\n };\n \n-crate fn unindent_comments(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n+crate fn unindent_comments(krate: clean::Crate, _: &mut DocContext<'_>) -> clean::Crate {\n     CommentCleaner.fold_crate(krate)\n }\n "}]}