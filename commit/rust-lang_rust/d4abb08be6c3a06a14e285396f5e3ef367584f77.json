{"sha": "d4abb08be6c3a06a14e285396f5e3ef367584f77", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0YWJiMDhiZTZjM2EwNmExNGUyODUzOTZmNWUzZWYzNjc1ODRmNzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-07T09:33:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-07T09:33:34Z"}, "message": "Auto merge of #61919 - alexreg:fix-atb-1, r=nikomatsakis\n\nFix for \"ambiguous associated type\" issue with ATBs\n\nFixes #61752.\n\nr? @nikomatsakis\n\nCC @Centril", "tree": {"sha": "ad10c5c02dbcc73bd78f0c16dfcb60c3118acaec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad10c5c02dbcc73bd78f0c16dfcb60c3118acaec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4abb08be6c3a06a14e285396f5e3ef367584f77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4abb08be6c3a06a14e285396f5e3ef367584f77", "html_url": "https://github.com/rust-lang/rust/commit/d4abb08be6c3a06a14e285396f5e3ef367584f77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4abb08be6c3a06a14e285396f5e3ef367584f77/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5421d94960018235654c7fb39aa1c502a3564621", "url": "https://api.github.com/repos/rust-lang/rust/commits/5421d94960018235654c7fb39aa1c502a3564621", "html_url": "https://github.com/rust-lang/rust/commit/5421d94960018235654c7fb39aa1c502a3564621"}, {"sha": "0410e320e28d0d2dfcc99d4d5ffcf7a6e5559b89", "url": "https://api.github.com/repos/rust-lang/rust/commits/0410e320e28d0d2dfcc99d4d5ffcf7a6e5559b89", "html_url": "https://github.com/rust-lang/rust/commit/0410e320e28d0d2dfcc99d4d5ffcf7a6e5559b89"}], "stats": {"total": 248, "additions": 157, "deletions": 91}, "files": [{"sha": "3d049fe4ccdad71dc1efc8b9aca9d58c7ccc4c89", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d4abb08be6c3a06a14e285396f5e3ef367584f77", "patch": "@@ -2234,7 +2234,7 @@ pub enum UseKind {\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitRef {\n     pub path: P<Path>,\n-    // Don't hash the ref_id. It is tracked via the thing it is used to access\n+    // Don't hash the `ref_id`. It is tracked via the thing it is used to access.\n     #[stable_hasher(ignore)]\n     pub hir_ref_id: HirId,\n }"}, {"sha": "a10578b0a43908aae1f4742855c77b22679348e3", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d4abb08be6c3a06a14e285396f5e3ef367584f77", "patch": "@@ -904,7 +904,7 @@ pub struct Generics {\n     pub parent_count: usize,\n     pub params: Vec<GenericParamDef>,\n \n-    /// Reverse map to the `index` field of each `GenericParamDef`\n+    /// Reverse map to the `index` field of each `GenericParamDef`.\n     #[stable_hasher(ignore)]\n     pub param_def_id_to_index: FxHashMap<DefId, u32>,\n \n@@ -1252,7 +1252,7 @@ impl<'tcx> TraitPredicate<'tcx> {\n \n impl<'tcx> PolyTraitPredicate<'tcx> {\n     pub fn def_id(&self) -> DefId {\n-        // Ok to skip binder since trait def-ID does not care about regions.\n+        // Ok to skip binder since trait `DefId` does not care about regions.\n         self.skip_binder().def_id()\n     }\n }\n@@ -1319,7 +1319,7 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n     /// Note that this is not the `DefId` of the `TraitRef` containing this\n     /// associated type, which is in `tcx.associated_item(projection_def_id()).container`.\n     pub fn projection_def_id(&self) -> DefId {\n-        // Ok to skip binder since trait def-ID does not care about regions.\n+        // Ok to skip binder since trait `DefId` does not care about regions.\n         self.skip_binder().projection_ty.item_def_id\n     }\n }\n@@ -1646,9 +1646,9 @@ pub type PlaceholderConst = Placeholder<BoundVar>;\n /// particular point.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable)]\n pub struct ParamEnv<'tcx> {\n-    /// Obligations that the caller must satisfy. This is basically\n+    /// `Obligation`s that the caller must satisfy. This is basically\n     /// the set of bounds on the in-scope type parameters, translated\n-    /// into Obligations, and elaborated and normalized.\n+    /// into `Obligation`s, and elaborated and normalized.\n     pub caller_bounds: &'tcx List<ty::Predicate<'tcx>>,\n \n     /// Typically, this is `Reveal::UserFacing`, but during codegen we\n@@ -2796,7 +2796,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 _ => false,\n             }\n         } else {\n-            match self.def_kind(def_id).expect(\"no def for def-id\") {\n+            match self.def_kind(def_id).expect(\"no def for `DefId`\") {\n                 DefKind::AssocConst\n                 | DefKind::Method\n                 | DefKind::AssocTy => true,"}, {"sha": "064c374de2b4caf04d43351f44af11e68bec807c", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d4abb08be6c3a06a14e285396f5e3ef367584f77", "patch": "@@ -646,7 +646,7 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n     ///\n     /// A Rust trait object type consists (in addition to a lifetime bound)\n     /// of a set of trait bounds, which are separated into any number\n-    /// of auto-trait bounds, and at most 1 non-auto-trait bound. The\n+    /// of auto-trait bounds, and at most one non-auto-trait bound. The\n     /// non-auto-trait bound is called the \"principal\" of the trait\n     /// object.\n     ///\n@@ -680,7 +680,8 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n \n     #[inline]\n     pub fn projection_bounds<'a>(&'a self) ->\n-        impl Iterator<Item=ExistentialProjection<'tcx>> + 'a {\n+        impl Iterator<Item = ExistentialProjection<'tcx>> + 'a\n+    {\n         self.iter().filter_map(|predicate| {\n             match *predicate {\n                 ExistentialPredicate::Projection(p) => Some(p),\n@@ -690,7 +691,7 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n     }\n \n     #[inline]\n-    pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item=DefId> + 'a {\n+    pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item = DefId> + 'a {\n         self.iter().filter_map(|predicate| {\n             match *predicate {\n                 ExistentialPredicate::AutoTrait(d) => Some(d),\n@@ -711,17 +712,17 @@ impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n \n     #[inline]\n     pub fn projection_bounds<'a>(&'a self) ->\n-        impl Iterator<Item=PolyExistentialProjection<'tcx>> + 'a {\n+        impl Iterator<Item = PolyExistentialProjection<'tcx>> + 'a {\n         self.skip_binder().projection_bounds().map(Binder::bind)\n     }\n \n     #[inline]\n-    pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item=DefId> + 'a {\n+    pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item = DefId> + 'a {\n         self.skip_binder().auto_traits()\n     }\n \n     pub fn iter<'a>(&'a self)\n-        -> impl DoubleEndedIterator<Item=Binder<ExistentialPredicate<'tcx>>> + 'tcx {\n+        -> impl DoubleEndedIterator<Item = Binder<ExistentialPredicate<'tcx>>> + 'tcx {\n         self.skip_binder().iter().cloned().map(Binder::bind)\n     }\n }"}, {"sha": "51e789b17880ac1e76885bde05aefe58921e071c", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=d4abb08be6c3a06a14e285396f5e3ef367584f77", "patch": "@@ -450,11 +450,11 @@ fn subroutine_type_metadata(\n         false);\n }\n \n-// FIXME(1563) This is all a bit of a hack because 'trait pointer' is an ill-\n-// defined concept. For the case of an actual trait pointer (i.e., Box<Trait>,\n-// &Trait), trait_object_type should be the whole thing (e.g, Box<Trait>) and\n-// trait_type should be the actual trait (e.g., Trait). Where the trait is part\n-// of a DST struct, there is no trait_object_type and the results of this\n+// FIXME(1563): This is all a bit of a hack because 'trait pointer' is an ill-\n+// defined concept. For the case of an actual trait pointer (i.e., `Box<Trait>`,\n+// `&Trait`), `trait_object_type` should be the whole thing (e.g, `Box<Trait>`) and\n+// `trait_type` should be the actual trait (e.g., `Trait`). Where the trait is part\n+// of a DST struct, there is no `trait_object_type` and the results of this\n // function will be a little bit weird.\n fn trait_pointer_metadata(\n     cx: &CodegenCx<'ll, 'tcx>,\n@@ -464,13 +464,13 @@ fn trait_pointer_metadata(\n ) -> &'ll DIType {\n     // The implementation provided here is a stub. It makes sure that the trait\n     // type is assigned the correct name, size, namespace, and source location.\n-    // But it does not describe the trait's methods.\n+    // However, it does not describe the trait's methods.\n \n     let containing_scope = match trait_type.sty {\n         ty::Dynamic(ref data, ..) =>\n             data.principal_def_id().map(|did| get_namespace_for_item(cx, did)),\n         _ => {\n-            bug!(\"debuginfo: Unexpected trait-object type in \\\n+            bug!(\"debuginfo: unexpected trait-object type in \\\n                   trait_pointer_metadata(): {:?}\",\n                  trait_type);\n         }"}, {"sha": "4040c0166d85900f52be61adcd30f6e5a23b4d75", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=d4abb08be6c3a06a14e285396f5e3ef367584f77", "patch": "@@ -1050,14 +1050,19 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         if !self.in_body {\n             // Avoid calling `hir_trait_to_predicates` in bodies, it will ICE.\n             // The traits' privacy in bodies is already checked as a part of trait object types.\n-            let (principal, bounds) = rustc_typeck::hir_trait_to_predicates(self.tcx, trait_ref);\n-            if self.visit_trait(*principal.skip_binder()) {\n-                return;\n+            let bounds = rustc_typeck::hir_trait_to_predicates(self.tcx, trait_ref);\n+\n+            for (trait_predicate, _) in bounds.trait_bounds {\n+                if self.visit_trait(*trait_predicate.skip_binder()) {\n+                    return;\n+                }\n             }\n+\n             for (poly_predicate, _) in bounds.projection_bounds {\n                 let tcx = self.tcx;\n-                if self.visit(poly_predicate.skip_binder().ty) ||\n-                   self.visit_trait(poly_predicate.skip_binder().projection_ty.trait_ref(tcx)) {\n+                if self.visit(poly_predicate.skip_binder().ty)\n+                    || self.visit_trait(poly_predicate.skip_binder().projection_ty.trait_ref(tcx))\n+                {\n                     return;\n                 }\n             }"}, {"sha": "25e9355161bcf325883233b706caf85d3c073543", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 57, "deletions": 38, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d4abb08be6c3a06a14e285396f5e3ef367584f77", "patch": "@@ -42,8 +42,17 @@ pub struct PathSeg(pub DefId, pub usize);\n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> TyCtxt<'tcx>;\n \n-    /// Returns the set of bounds in scope for the type parameter with\n-    /// the given id.\n+    /// Returns predicates in scope of the form `X: Foo`, where `X` is\n+    /// a type parameter `X` with the given id `def_id`. This is a\n+    /// subset of the full set of predicates.\n+    ///\n+    /// This is used for one specific purpose: resolving \"short-hand\"\n+    /// associated type references like `T::Item`. In principle, we\n+    /// would do that by first getting the full set of predicates in\n+    /// scope and then filtering down to find those that apply to `T`,\n+    /// but this can lead to cycle errors. The problem is that we have\n+    /// to do this resolution *in order to create the predicates in\n+    /// the first place*. Hence, we have this \"special pass\".\n     fn get_type_parameter_bounds(&self, span: Span, def_id: DefId)\n                                  -> &'tcx ty::GenericPredicates<'tcx>;\n \n@@ -775,11 +784,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// The given trait-ref must actually be a trait.\n     pub(super) fn instantiate_poly_trait_ref_inner(&self,\n         trait_ref: &hir::TraitRef,\n+        span: Span,\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n-    ) -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n-    {\n+    ) -> Option<Vec<Span>> {\n         let trait_def_id = trait_ref.trait_def_id();\n \n         debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n@@ -794,6 +803,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         );\n         let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n \n+        bounds.trait_bounds.push((poly_trait_ref, span));\n+\n         let mut dup_bindings = FxHashMap::default();\n         for binding in &assoc_bindings {\n             // Specify type to assert that error was already reported in `Err` case.\n@@ -804,14 +815,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     binding,\n                     bounds,\n                     speculative,\n-                    &mut dup_bindings\n+                    &mut dup_bindings,\n                 );\n             // Okay to ignore `Err` because of `ErrorReported` (see above).\n         }\n \n         debug!(\"instantiate_poly_trait_ref({:?}, bounds={:?}) -> {:?}\",\n                trait_ref, bounds, poly_trait_ref);\n-        (poly_trait_ref, potential_assoc_types)\n+        potential_assoc_types\n     }\n \n     /// Given a trait bound like `Debug`, applies that trait bound the given self-type to construct\n@@ -836,10 +847,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn instantiate_poly_trait_ref(&self,\n         poly_trait_ref: &hir::PolyTraitRef,\n         self_ty: Ty<'tcx>,\n-        bounds: &mut Bounds<'tcx>\n-    ) -> (ty::PolyTraitRef<'tcx>, Option<Vec<Span>>)\n-    {\n-        self.instantiate_poly_trait_ref_inner(&poly_trait_ref.trait_ref, self_ty, bounds, false)\n+        bounds: &mut Bounds<'tcx>,\n+    ) -> Option<Vec<Span>> {\n+        self.instantiate_poly_trait_ref_inner(\n+            &poly_trait_ref.trait_ref,\n+            poly_trait_ref.span,\n+            self_ty,\n+            bounds,\n+            false,\n+        )\n     }\n \n     fn ast_path_to_mono_trait_ref(&self,\n@@ -983,12 +999,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n \n         for bound in trait_bounds {\n-            let (poly_trait_ref, _) = self.instantiate_poly_trait_ref(\n+            let _ = self.instantiate_poly_trait_ref(\n                 bound,\n                 param_ty,\n                 bounds,\n             );\n-            bounds.trait_bounds.push((poly_trait_ref, bound.span))\n         }\n \n         bounds.region_bounds.extend(region_bounds\n@@ -1172,11 +1187,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n                 // parameter to have a skipped binder.\n                 let param_ty = tcx.mk_projection(assoc_ty.def_id, candidate.skip_binder().substs);\n-                self.add_bounds(\n-                    param_ty,\n-                    ast_bounds,\n-                    bounds,\n-                );\n+                self.add_bounds(param_ty, ast_bounds, bounds);\n             }\n         }\n         Ok(())\n@@ -1216,25 +1227,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut bounds = Bounds::default();\n         let mut potential_assoc_types = Vec::new();\n         let dummy_self = self.tcx().types.trait_object_dummy_self;\n-        // FIXME: we want to avoid collecting into a `Vec` here, but simply cloning the iterator is\n-        // not straightforward due to the borrow checker.\n-        let bound_trait_refs: Vec<_> = trait_bounds\n-            .iter()\n-            .rev()\n-            .map(|trait_bound| {\n-                let (trait_ref, cur_potential_assoc_types) = self.instantiate_poly_trait_ref(\n-                    trait_bound,\n-                    dummy_self,\n-                    &mut bounds,\n-                );\n-                potential_assoc_types.extend(cur_potential_assoc_types.into_iter().flatten());\n-                (trait_ref, trait_bound.span)\n-            })\n-            .collect();\n+        for trait_bound in trait_bounds.iter().rev() {\n+            let cur_potential_assoc_types = self.instantiate_poly_trait_ref(\n+                trait_bound,\n+                dummy_self,\n+                &mut bounds,\n+            );\n+            potential_assoc_types.extend(cur_potential_assoc_types.into_iter().flatten());\n+        }\n \n         // Expand trait aliases recursively and check that only one regular (non-auto) trait\n         // is used and no 'maybe' bounds are used.\n-        let expanded_traits = traits::expand_trait_aliases(tcx, bound_trait_refs.iter().cloned());\n+        let expanded_traits =\n+            traits::expand_trait_aliases(tcx, bounds.trait_bounds.iter().cloned());\n         let (mut auto_traits, regular_traits): (Vec<_>, Vec<_>) =\n             expanded_traits.partition(|i| tcx.trait_is_auto(i.trait_ref().def_id()));\n         if regular_traits.len() > 1 {\n@@ -1276,7 +1281,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // Use a `BTreeSet` to keep output in a more consistent order.\n         let mut associated_types = BTreeSet::default();\n \n-        let regular_traits_refs = bound_trait_refs\n+        let regular_traits_refs = bounds.trait_bounds\n             .into_iter()\n             .filter(|(trait_ref, _)| !tcx.trait_is_auto(trait_ref.def_id()))\n             .map(|(trait_ref, _)| trait_ref);\n@@ -1491,7 +1496,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     {\n         let tcx = self.tcx();\n \n+        debug!(\n+            \"find_bound_for_assoc_item(ty_param_def_id={:?}, assoc_name={:?}, span={:?})\",\n+            ty_param_def_id,\n+            assoc_name,\n+            span,\n+        );\n+\n         let predicates = &self.get_type_parameter_bounds(span, ty_param_def_id).predicates;\n+\n+        debug!(\"find_bound_for_assoc_item: predicates={:#?}\", predicates);\n+\n         let bounds = predicates.iter().filter_map(|(p, _)| p.to_opt_poly_trait_ref());\n \n         // Check that there is exactly one way to find an associated type with the\n@@ -1515,7 +1530,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                    assoc_name: ast::Ident,\n                                    span: Span)\n         -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n-        where I: Iterator<Item=ty::PolyTraitRef<'tcx>>\n+        where I: Iterator<Item = ty::PolyTraitRef<'tcx>>\n     {\n         let bound = match bounds.next() {\n             Some(bound) => bound,\n@@ -1524,13 +1539,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                  \"associated type `{}` not found for `{}`\",\n                                  assoc_name,\n                                  ty_param_name)\n-                  .span_label(span, format!(\"associated type `{}` not found\", assoc_name))\n-                  .emit();\n+                    .span_label(span, format!(\"associated type `{}` not found\", assoc_name))\n+                    .emit();\n                 return Err(ErrorReported);\n             }\n         };\n \n+        debug!(\"one_bound_for_assoc_type: bound = {:?}\", bound);\n+\n         if let Some(bound2) = bounds.next() {\n+            debug!(\"one_bound_for_assoc_type: bound2 = {:?}\", bound2);\n+\n             let bounds = iter::once(bound).chain(iter::once(bound2)).chain(bounds);\n             let mut err = struct_span_err!(\n                 self.tcx().sess, span, E0221,\n@@ -1544,7 +1563,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     item.kind == ty::AssocKind::Type &&\n                         self.tcx().hygienic_eq(assoc_name, item.ident, bound.def_id())\n                 })\n-                .and_then(|item| self.tcx().hir().span_if_local(item.def_id));\n+                    .and_then(|item| self.tcx().hir().span_if_local(item.def_id));\n \n                 if let Some(span) = bound_span {\n                     err.span_label(span, format!(\"ambiguous `{}` from `{}`\","}, {"sha": "08033b46b800420f9b9fb35d46296207353f1261", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d4abb08be6c3a06a14e285396f5e3ef367584f77", "patch": "@@ -2030,7 +2030,7 @@ fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span, qpath: &\n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n         self.tcx\n-        }\n+    }\n \n     fn get_type_parameter_bounds(&self, _: Span, def_id: DefId)\n                                  -> &'tcx ty::GenericPredicates<'tcx>"}, {"sha": "0f0568907c64679e4b3dcd3f295cb63b746cf108", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d4abb08be6c3a06a14e285396f5e3ef367584f77", "patch": "@@ -49,8 +49,6 @@ use rustc::hir::{self, CodegenFnAttrFlags, CodegenFnAttrs, Unsafety};\n \n use errors::{Applicability, DiagnosticId};\n \n-use std::iter;\n-\n struct OnlySelfBounds(bool);\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -226,7 +224,7 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n         if let Some(trait_ref) = poly_trait_ref.no_bound_vars() {\n             self.tcx().mk_projection(item_def_id, trait_ref.substs)\n         } else {\n-            // no late-bound regions, we can just ignore the binder\n+            // There are no late-bound regions; we can just ignore the binder.\n             span_err!(\n                 self.tcx().sess,\n                 span,\n@@ -239,29 +237,30 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n     }\n \n     fn normalize_ty(&self, _span: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        // types in item signatures are not normalized, to avoid undue\n-        // dependencies.\n+        // Types in item signatures are not normalized to avoid undue dependencies.\n         ty\n     }\n \n     fn set_tainted_by_errors(&self) {\n-        // no obvious place to track this, so just let it go\n+        // There's no obvious place to track this, so just let it go.\n     }\n \n     fn record_ty(&self, _hir_id: hir::HirId, _ty: Ty<'tcx>, _span: Span) {\n-        // no place to record types from signatures?\n+        // There's no place to record types from signatures?\n     }\n }\n \n+/// Returns the predicates defined on `item_def_id` of the form\n+/// `X: Foo` where `X` is the type parameter `def_id`.\n fn type_param_predicates(\n     tcx: TyCtxt<'_>,\n     (item_def_id, def_id): (DefId, DefId),\n ) -> &ty::GenericPredicates<'_> {\n     use rustc::hir::*;\n \n     // In the AST, bounds can derive from two places. Either\n-    // written inline like `<T : Foo>` or in a where clause like\n-    // `where T : Foo`.\n+    // written inline like `<T: Foo>` or in a where-clause like\n+    // `where T: Foo`.\n \n     let param_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let param_owner = tcx.hir().ty_param_owner(param_id);\n@@ -325,16 +324,23 @@ fn type_param_predicates(\n     let icx = ItemCtxt::new(tcx, item_def_id);\n     let mut result = (*result).clone();\n     result.predicates.extend(extend.into_iter());\n-    result.predicates\n-          .extend(icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty,\n-                  OnlySelfBounds(true)));\n+    result.predicates.extend(\n+        icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty, OnlySelfBounds(true))\n+            .into_iter()\n+            .filter(|(predicate, _)| {\n+                match predicate {\n+                    ty::Predicate::Trait(ref data) => data.skip_binder().self_ty().is_param(index),\n+                    _ => false,\n+                }\n+            })\n+    );\n     tcx.arena.alloc(result)\n }\n \n impl ItemCtxt<'tcx> {\n     /// Finds bounds from `hir::Generics`. This requires scanning through the\n     /// AST. We do this to avoid having to convert *all* the bounds, which\n-    /// would create artificial cycles. Instead we can only convert the\n+    /// would create artificial cycles. Instead, we can only convert the\n     /// bounds for a type parameter `X` if `X::Foo` is used.\n     fn type_parameter_bounds_in_generics(\n         &self,\n@@ -2192,15 +2198,12 @@ fn explicit_predicates_of(\n                     match bound {\n                         &hir::GenericBound::Trait(ref poly_trait_ref, _) => {\n                             let mut bounds = Bounds::default();\n-\n-                            let (trait_ref, _) = AstConv::instantiate_poly_trait_ref(\n+                            let _ = AstConv::instantiate_poly_trait_ref(\n                                 &icx,\n                                 poly_trait_ref,\n                                 ty,\n                                 &mut bounds,\n                             );\n-\n-                            predicates.push((trait_ref.to_predicate(), poly_trait_ref.span));\n                             predicates.extend(bounds.predicates(tcx, ty));\n                         }\n \n@@ -2292,7 +2295,7 @@ fn explicit_predicates_of(\n /// Converts a specific `GenericBound` from the AST into a set of\n /// predicates that apply to the self type. A vector is returned\n /// because this can be anywhere from zero predicates (`T: ?Sized` adds no\n-/// predicates) to one (`T: Foo`) to many (`T: Bar<X=i32>` adds `T: Bar`\n+/// predicates) to one (`T: Foo`) to many (`T: Bar<X = i32>` adds `T: Bar`\n /// and `<T as Bar>::X == i32`).\n fn predicates_from_bound<'tcx>(\n     astconv: &dyn AstConv<'tcx>,\n@@ -2302,10 +2305,12 @@ fn predicates_from_bound<'tcx>(\n     match *bound {\n         hir::GenericBound::Trait(ref tr, hir::TraitBoundModifier::None) => {\n             let mut bounds = Bounds::default();\n-            let (pred, _) = astconv.instantiate_poly_trait_ref(tr, param_ty, &mut bounds);\n-            iter::once((pred.to_predicate(), tr.span))\n-                .chain(bounds.predicates(astconv.tcx(), param_ty))\n-                .collect()\n+            let _ = astconv.instantiate_poly_trait_ref(\n+                tr,\n+                param_ty,\n+                &mut bounds,\n+            );\n+            bounds.predicates(astconv.tcx(), param_ty)\n         }\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);"}, {"sha": "9d9a9d9b559e47bcdbac5321819f7edd5cacec0a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=d4abb08be6c3a06a14e285396f5e3ef367584f77", "patch": "@@ -108,7 +108,7 @@ use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::query::Providers;\n use rustc::util;\n-use syntax_pos::Span;\n+use syntax_pos::{DUMMY_SP, Span};\n use util::common::time;\n \n use std::iter;\n@@ -375,19 +375,19 @@ pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty) -> Ty<'tcx> {\n pub fn hir_trait_to_predicates<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     hir_trait: &hir::TraitRef,\n-) -> (ty::PolyTraitRef<'tcx>, Bounds<'tcx>) {\n+) -> Bounds<'tcx> {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n     // scope.  This is derived from the enclosing item-like thing.\n     let env_hir_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n     let env_def_id = tcx.hir().local_def_id(env_hir_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id);\n     let mut bounds = Bounds::default();\n-    let (principal, _) = AstConv::instantiate_poly_trait_ref_inner(\n-        &item_cx, hir_trait, tcx.types.err, &mut bounds, true\n+    let _ = AstConv::instantiate_poly_trait_ref_inner(\n+        &item_cx, hir_trait, DUMMY_SP, tcx.types.err, &mut bounds, true\n     );\n \n-    (principal, bounds)\n+    bounds\n }\n \n __build_diagnostic_array! { librustc_typeck, DIAGNOSTICS }"}, {"sha": "9c47a003dfd09fc9b480e490128f21b2e1c5d2d6", "filename": "src/test/ui/associated-type-bounds/ambiguous-associated-type.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type.rs?ref=d4abb08be6c3a06a14e285396f5e3ef367584f77", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+pub struct Flatten<I>\n+where\n+    I: Iterator<Item: IntoIterator>,\n+{\n+    inner: <I::Item as IntoIterator>::IntoIter,\n+}\n+\n+fn main() {}"}, {"sha": "f38ec640e1781d32095c0dd2ddb8415afa5e80d6", "filename": "src/test/ui/associated-type-bounds/issue-61752.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-61752.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4abb08be6c3a06a14e285396f5e3ef367584f77/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-61752.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fissue-61752.rs?ref=d4abb08be6c3a06a14e285396f5e3ef367584f77", "patch": "@@ -0,0 +1,24 @@\n+// check-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+trait Foo {\n+    type Bar;\n+}\n+\n+impl Foo for () {\n+    type Bar = ();\n+}\n+\n+fn a<F: Foo>() where F::Bar: Copy {}\n+\n+fn b<F: Foo>() where <F as Foo>::Bar: Copy {}\n+\n+// This used to complain about ambiguous associated types.\n+fn c<F: Foo<Bar: Foo>>() where F::Bar: Copy {}\n+\n+fn main() {\n+    a::<()>();\n+    b::<()>();\n+    c::<()>();\n+}"}]}