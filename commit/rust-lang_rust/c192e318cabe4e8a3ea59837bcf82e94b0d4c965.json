{"sha": "c192e318cabe4e8a3ea59837bcf82e94b0d4c965", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxOTJlMzE4Y2FiZTRlOGEzZWE1OTgzN2JjZjgyZTk0YjBkNGM5NjU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-23T20:19:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-23T20:19:14Z"}, "message": "Rollup merge of #65583 - eddyb:more-query-like-cross-crate-tables, r=michaelwoerister\n\nrustc_metadata: use a table for super_predicates, fn_sig, impl_trait_ref.\n\nThis is an attempt at a part of #65407, i.e. moving parts of cross-crate \"metadata\" into tables that match queries more closely.\n\nThree new tables should be enough to see some perf/metadata size changes.\n(need to do something similar to https://github.com/rust-lang/rust/pull/59953#issuecomment-542521919)\n\nThere are other bits of data that could be made into tables, but they can be more compact so the impact would likely be not as bad, and they're also more work to set up.", "tree": {"sha": "51f3d9e00024172e900bbe54b9b4a443aa272a4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51f3d9e00024172e900bbe54b9b4a443aa272a4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c192e318cabe4e8a3ea59837bcf82e94b0d4c965", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdsLXCCRBK7hj4Ov3rIwAAdHIIALBAKUUzNP6eLkbYJ4+Ivnvp\nIEHEWA5eSI2VOTEQLdLVWbGhtITcPR7xQXIVDghR0NZ1ixKEwWxwiae2n1zn7LPM\ns5ir3cqdriZmXNi8Wm7vAOEqxp/TCNg/R3q3XnbsdUZBkIJbD6jH863jlHtnSBwC\nKPzS3Wl5jpsEnPWxvYhlvDENaUWvgJPr3OfhRBmXKIcZj4WZu1oD1DKiAIU3mNx4\nsXYvsIbMi90mFfT2iXuDjLQUpfSb+KUPGdtND8NTamiqtOtWVzx1jOWG/mR6YZf3\nfd4mrhsUR7wQQLYl0eJFS+VBJ5u+YGC4Wb+EwaRHxPOf+xVSkkF7IjdaLwH9ByE=\n=239K\n-----END PGP SIGNATURE-----\n", "payload": "tree 51f3d9e00024172e900bbe54b9b4a443aa272a4d\nparent 6bb7449fdb0c1abb597b6a3d3ab77efab466c937\nparent 371cc39b256d0fa5ec0da3193e0ec6f9377bd903\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1571861954 +0200\ncommitter GitHub <noreply@github.com> 1571861954 +0200\n\nRollup merge of #65583 - eddyb:more-query-like-cross-crate-tables, r=michaelwoerister\n\nrustc_metadata: use a table for super_predicates, fn_sig, impl_trait_ref.\n\nThis is an attempt at a part of #65407, i.e. moving parts of cross-crate \"metadata\" into tables that match queries more closely.\n\nThree new tables should be enough to see some perf/metadata size changes.\n(need to do something similar to https://github.com/rust-lang/rust/pull/59953#issuecomment-542521919)\n\nThere are other bits of data that could be made into tables, but they can be more compact so the impact would likely be not as bad, and they're also more work to set up.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c192e318cabe4e8a3ea59837bcf82e94b0d4c965", "html_url": "https://github.com/rust-lang/rust/commit/c192e318cabe4e8a3ea59837bcf82e94b0d4c965", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c192e318cabe4e8a3ea59837bcf82e94b0d4c965/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bb7449fdb0c1abb597b6a3d3ab77efab466c937", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bb7449fdb0c1abb597b6a3d3ab77efab466c937", "html_url": "https://github.com/rust-lang/rust/commit/6bb7449fdb0c1abb597b6a3d3ab77efab466c937"}, {"sha": "371cc39b256d0fa5ec0da3193e0ec6f9377bd903", "url": "https://api.github.com/repos/rust-lang/rust/commits/371cc39b256d0fa5ec0da3193e0ec6f9377bd903", "html_url": "https://github.com/rust-lang/rust/commit/371cc39b256d0fa5ec0da3193e0ec6f9377bd903"}], "stats": {"total": 167, "additions": 74, "deletions": 93}, "files": [{"sha": "1333e3fb3ce3ee64471b78417303115e3a73bd5d", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c192e318cabe4e8a3ea59837bcf82e94b0d4c965/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c192e318cabe4e8a3ea59837bcf82e94b0d4c965/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=c192e318cabe4e8a3ea59837bcf82e94b0d4c965", "patch": "@@ -448,7 +448,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Mod(_) => DefKind::Mod,\n             EntryKind::Variant(_) => DefKind::Variant,\n             EntryKind::Trait(_) => DefKind::Trait,\n-            EntryKind::TraitAlias(_) => DefKind::TraitAlias,\n+            EntryKind::TraitAlias => DefKind::TraitAlias,\n             EntryKind::Enum(..) => DefKind::Enum,\n             EntryKind::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n             EntryKind::ForeignType => DefKind::ForeignTy,\n@@ -458,7 +458,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Impl(_) |\n             EntryKind::Field |\n             EntryKind::Generator(_) |\n-            EntryKind::Closure(_) => return None,\n+            EntryKind::Closure => return None,\n         })\n     }\n }\n@@ -575,7 +575,7 @@ impl<'a, 'tcx> CrateMetadata {\n                                   data.is_marker,\n                                   self.def_path_table.def_path_hash(item_id))\n             },\n-            EntryKind::TraitAlias(_) => {\n+            EntryKind::TraitAlias => {\n                 ty::TraitDef::new(self.local_def_id(item_id),\n                                   hir::Unsafety::Normal,\n                                   false,\n@@ -680,13 +680,7 @@ impl<'a, 'tcx> CrateMetadata {\n         item_id: DefIndex,\n         tcx: TyCtxt<'tcx>,\n     ) -> ty::GenericPredicates<'tcx> {\n-        let super_predicates = match self.kind(item_id) {\n-            EntryKind::Trait(data) => data.decode(self).super_predicates,\n-            EntryKind::TraitAlias(data) => data.decode(self).super_predicates,\n-            _ => bug!(\"def-index does not refer to trait or trait alias\"),\n-        };\n-\n-        super_predicates.decode((self, tcx))\n+        self.root.per_def.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n     }\n \n     crate fn get_generics(&self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n@@ -717,7 +711,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    fn get_impl_data(&self, id: DefIndex) -> ImplData<'tcx> {\n+    fn get_impl_data(&self, id: DefIndex) -> ImplData {\n         match self.kind(id) {\n             EntryKind::Impl(data) => data.decode(self),\n             _ => bug!(),\n@@ -744,7 +738,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn get_impl_trait(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n-        self.get_impl_data(id).trait_ref.map(|tr| tr.decode((self, tcx)))\n+        self.root.per_def.impl_trait_ref.get(self, id).map(|tr| tr.decode((self, tcx)))\n     }\n \n     /// Iterates over all the stability attributes in the given crate.\n@@ -1118,7 +1112,7 @@ impl<'a, 'tcx> CrateMetadata {\n         def_key.parent.and_then(|parent_index| {\n             match self.kind(parent_index) {\n                 EntryKind::Trait(_) |\n-                EntryKind::TraitAlias(_) => Some(self.local_def_id(parent_index)),\n+                EntryKind::TraitAlias => Some(self.local_def_id(parent_index)),\n                 _ => None,\n             }\n         })\n@@ -1245,16 +1239,7 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     crate fn fn_sig(&self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        let sig = match self.kind(id) {\n-            EntryKind::Fn(data) |\n-            EntryKind::ForeignFn(data) => data.decode(self).sig,\n-            EntryKind::Method(data) => data.decode(self).fn_data.sig,\n-            EntryKind::Variant(data) |\n-            EntryKind::Struct(data, _) => data.decode(self).ctor_sig.unwrap(),\n-            EntryKind::Closure(data) => data.decode(self).sig,\n-            _ => bug!(),\n-        };\n-        sig.decode((self, tcx))\n+        self.root.per_def.fn_sig.get(self, id).unwrap().decode((self, tcx))\n     }\n \n     #[inline]"}, {"sha": "0dc9f91ae00e1c78bdc7f89a3304af52ca8e3eea", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 46, "deletions": 38, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/c192e318cabe4e8a3ea59837bcf82e94b0d4c965/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c192e318cabe4e8a3ea59837bcf82e94b0d4c965/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=c192e318cabe4e8a3ea59837bcf82e94b0d4c965", "patch": "@@ -71,11 +71,14 @@ struct PerDefTables<'tcx> {\n     deprecation: PerDefTable<Lazy<attr::Deprecation>>,\n \n     ty: PerDefTable<Lazy<Ty<'tcx>>>,\n+    fn_sig: PerDefTable<Lazy<ty::PolyFnSig<'tcx>>>,\n+    impl_trait_ref: PerDefTable<Lazy<ty::TraitRef<'tcx>>>,\n     inherent_impls: PerDefTable<Lazy<[DefIndex]>>,\n     variances: PerDefTable<Lazy<[ty::Variance]>>,\n     generics: PerDefTable<Lazy<ty::Generics>>,\n     predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n     predicates_defined_on: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n+    super_predicates: PerDefTable<Lazy<ty::GenericPredicates<'tcx>>>,\n \n     mir: PerDefTable<Lazy<mir::Body<'tcx>>>,\n     promoted_mir: PerDefTable<Lazy<IndexVec<mir::Promoted, mir::Body<'tcx>>>>,\n@@ -508,11 +511,14 @@ impl<'tcx> EncodeContext<'tcx> {\n             deprecation: self.per_def.deprecation.encode(&mut self.opaque),\n \n             ty: self.per_def.ty.encode(&mut self.opaque),\n+            fn_sig: self.per_def.fn_sig.encode(&mut self.opaque),\n+            impl_trait_ref: self.per_def.impl_trait_ref.encode(&mut self.opaque),\n             inherent_impls: self.per_def.inherent_impls.encode(&mut self.opaque),\n             variances: self.per_def.variances.encode(&mut self.opaque),\n             generics: self.per_def.generics.encode(&mut self.opaque),\n             predicates: self.per_def.predicates.encode(&mut self.opaque),\n             predicates_defined_on: self.per_def.predicates_defined_on.encode(&mut self.opaque),\n+            super_predicates: self.per_def.super_predicates.encode(&mut self.opaque),\n \n             mir: self.per_def.mir.encode(&mut self.opaque),\n             promoted_mir: self.per_def.promoted_mir.encode(&mut self.opaque),\n@@ -635,13 +641,7 @@ impl EncodeContext<'tcx> {\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            // FIXME(eddyb) deduplicate these with `encode_enum_variant_ctor`.\n             ctor: variant.ctor_def_id.map(|did| did.index),\n-            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                variant.ctor_def_id.map(|ctor_def_id| self.lazy(&tcx.fn_sig(ctor_def_id)))\n-            } else {\n-                None\n-            },\n         };\n \n         let enum_id = tcx.hir().as_local_hir_id(enum_did).unwrap();\n@@ -660,6 +660,11 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n+            // FIXME(eddyb) encode signature only in `encode_enum_variant_ctor`.\n+            if let Some(ctor_def_id) = variant.ctor_def_id {\n+                record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(ctor_def_id));\n+            }\n+            // FIXME(eddyb) is this ever used?\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -679,15 +684,11 @@ impl EncodeContext<'tcx> {\n         let def_id = variant.ctor_def_id.unwrap();\n         debug!(\"EncodeContext::encode_enum_variant_ctor({:?})\", def_id);\n \n+        // FIXME(eddyb) encode only the `CtorKind` for constructors.\n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n-            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(tcx.fn_sig(def_id)))\n-            } else {\n-                None\n-            }\n         };\n \n         // Variant constructors have the same visibility as the parent enums, unless marked as\n@@ -706,6 +707,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -780,11 +782,6 @@ impl EncodeContext<'tcx> {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n             ctor: Some(def_id.index),\n-            ctor_sig: if variant.ctor_kind == CtorKind::Fn {\n-                Some(self.lazy(tcx.fn_sig(def_id)))\n-            } else {\n-                None\n-            }\n         };\n \n         let struct_id = tcx.hir().as_local_hir_id(adt_def_id).unwrap();\n@@ -811,6 +808,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if variant.ctor_kind == CtorKind::Fn {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -835,6 +833,11 @@ impl EncodeContext<'tcx> {\n             self.tcx.predicates_defined_on(def_id))\n     }\n \n+    fn encode_super_predicates(&mut self, def_id: DefId) {\n+        debug!(\"EncodeContext::encode_super_predicates({:?})\", def_id);\n+        record!(self.per_def.super_predicates[def_id] <- self.tcx.super_predicates_of(def_id));\n+    }\n+\n     fn encode_info_for_trait_item(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n@@ -874,7 +877,6 @@ impl EncodeContext<'tcx> {\n                         asyncness: m_sig.header.asyncness,\n                         constness: hir::Constness::NotConst,\n                         param_names,\n-                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -906,6 +908,7 @@ impl EncodeContext<'tcx> {\n             ty::AssocKind::OpaqueTy => unreachable!(),\n         }\n         if trait_item.kind == ty::AssocKind::Method {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -952,7 +955,6 @@ impl EncodeContext<'tcx> {\n                         asyncness: sig.header.asyncness,\n                         constness: sig.header.constness,\n                         param_names: self.encode_fn_param_names_for_body(body),\n-                        sig: self.lazy(tcx.fn_sig(def_id)),\n                     }\n                 } else {\n                     bug!()\n@@ -973,6 +975,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if impl_item.kind == ty::AssocKind::Method {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);\n@@ -1081,7 +1084,6 @@ impl EncodeContext<'tcx> {\n                     asyncness: header.asyncness,\n                     constness: header.constness,\n                     param_names: self.encode_fn_param_names_for_body(body),\n-                    sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n \n                 EntryKind::Fn(self.lazy(data))\n@@ -1109,7 +1111,6 @@ impl EncodeContext<'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor,\n-                    ctor_sig: None,\n                 }), adt_def.repr)\n             }\n             hir::ItemKind::Union(..) => {\n@@ -1120,7 +1121,6 @@ impl EncodeContext<'tcx> {\n                     ctor_kind: variant.ctor_kind,\n                     discr: variant.discr,\n                     ctor: None,\n-                    ctor_sig: None,\n                 }), adt_def.repr)\n             }\n             hir::ItemKind::Impl(_, _, defaultness, ..) => {\n@@ -1154,7 +1154,6 @@ impl EncodeContext<'tcx> {\n                     defaultness,\n                     parent_impl: parent,\n                     coerce_unsized_info,\n-                    trait_ref: trait_ref.map(|trait_ref| self.lazy(trait_ref)),\n                 };\n \n                 EntryKind::Impl(self.lazy(data))\n@@ -1166,18 +1165,11 @@ impl EncodeContext<'tcx> {\n                     paren_sugar: trait_def.paren_sugar,\n                     has_auto_impl: self.tcx.trait_is_auto(def_id),\n                     is_marker: trait_def.is_marker,\n-                    super_predicates: self.lazy(tcx.super_predicates_of(def_id)),\n                 };\n \n                 EntryKind::Trait(self.lazy(data))\n             }\n-            hir::ItemKind::TraitAlias(..) => {\n-                let data = TraitAliasData {\n-                    super_predicates: self.lazy(tcx.super_predicates_of(def_id)),\n-                };\n-\n-                EntryKind::TraitAlias(self.lazy(data))\n-            }\n+            hir::ItemKind::TraitAlias(..) => EntryKind::TraitAlias,\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         });\n@@ -1232,6 +1224,14 @@ impl EncodeContext<'tcx> {\n             hir::ItemKind::Impl(..) => self.encode_item_type(def_id),\n             _ => {}\n         }\n+        if let hir::ItemKind::Fn(..) = item.kind {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n+        }\n+        if let hir::ItemKind::Impl(..) = item.kind {\n+            if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n+                record!(self.per_def.impl_trait_ref[def_id] <- trait_ref);\n+            }\n+        }\n         self.encode_inherent_implementations(def_id);\n         match item.kind {\n             hir::ItemKind::Enum(..) |\n@@ -1269,6 +1269,13 @@ impl EncodeContext<'tcx> {\n             }\n             _ => {} // not *wrong* for other kinds of items, but not needed\n         }\n+        match item.kind {\n+            hir::ItemKind::Trait(..) |\n+            hir::ItemKind::TraitAlias(..) => {\n+                self.encode_super_predicates(def_id);\n+            }\n+            _ => {}\n+        }\n \n         let mir = match item.kind {\n             hir::ItemKind::Static(..) | hir::ItemKind::Const(..) => true,\n@@ -1321,10 +1328,12 @@ impl EncodeContext<'tcx> {\n     fn encode_info_for_closure(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n \n-        let tables = self.tcx.typeck_tables_of(def_id);\n+        // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n+        // including on the signature, which is inferred in `typeck_tables_of.\n         let hir_id = self.tcx.hir().as_local_hir_id(def_id).unwrap();\n+        let ty = self.tcx.typeck_tables_of(def_id).node_type(hir_id);\n \n-        record!(self.per_def.kind[def_id] <- match tables.node_type(hir_id).kind {\n+        record!(self.per_def.kind[def_id] <- match ty.kind {\n             ty::Generator(def_id, ..) => {\n                 let layout = self.tcx.generator_layout(def_id);\n                 let data = GeneratorData {\n@@ -1333,18 +1342,17 @@ impl EncodeContext<'tcx> {\n                 EntryKind::Generator(self.lazy(data))\n             }\n \n-            ty::Closure(def_id, substs) => {\n-                let sig = substs.as_closure().sig(def_id, self.tcx);\n-                let data = ClosureData { sig: self.lazy(sig) };\n-                EntryKind::Closure(self.lazy(data))\n-            }\n+            ty::Closure(..) => EntryKind::Closure,\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n         });\n         record!(self.per_def.visibility[def_id] <- ty::Visibility::Public);\n         record!(self.per_def.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.per_def.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n         self.encode_item_type(def_id);\n+        if let ty::Closure(def_id, substs) = ty.kind {\n+            record!(self.per_def.fn_sig[def_id] <- substs.as_closure().sig(def_id, self.tcx));\n+        }\n         self.encode_generics(def_id);\n         self.encode_optimized_mir(def_id);\n         self.encode_promoted_mir(def_id);\n@@ -1553,7 +1561,6 @@ impl EncodeContext<'tcx> {\n                     asyncness: hir::IsAsync::NotAsync,\n                     constness: hir::Constness::NotConst,\n                     param_names: self.encode_fn_param_names(names),\n-                    sig: self.lazy(tcx.fn_sig(def_id)),\n                 };\n                 EntryKind::ForeignFn(self.lazy(data))\n             }\n@@ -1569,6 +1576,7 @@ impl EncodeContext<'tcx> {\n         self.encode_deprecation(def_id);\n         self.encode_item_type(def_id);\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n+            record!(self.per_def.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             self.encode_variances_of(def_id);\n         }\n         self.encode_generics(def_id);"}, {"sha": "ad39aa34fd5c8d3f1695d4936ad1749518bed1d8", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c192e318cabe4e8a3ea59837bcf82e94b0d4c965/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c192e318cabe4e8a3ea59837bcf82e94b0d4c965/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=c192e318cabe4e8a3ea59837bcf82e94b0d4c965", "patch": "@@ -238,11 +238,14 @@ crate struct LazyPerDefTables<'tcx> {\n     pub deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n \n     pub ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n+    pub fn_sig: Lazy!(PerDefTable<Lazy!(ty::PolyFnSig<'tcx>)>),\n+    pub impl_trait_ref: Lazy!(PerDefTable<Lazy!(ty::TraitRef<'tcx>)>),\n     pub inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n     pub variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n     pub generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n     pub predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n     pub predicates_defined_on: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    pub super_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n \n     pub mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),\n     pub promoted_mir: Lazy!(PerDefTable<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n@@ -264,22 +267,22 @@ crate enum EntryKind<'tcx> {\n     OpaqueTy,\n     Enum(ReprOptions),\n     Field,\n-    Variant(Lazy!(VariantData<'tcx>)),\n-    Struct(Lazy!(VariantData<'tcx>), ReprOptions),\n-    Union(Lazy!(VariantData<'tcx>), ReprOptions),\n-    Fn(Lazy!(FnData<'tcx>)),\n-    ForeignFn(Lazy!(FnData<'tcx>)),\n+    Variant(Lazy<VariantData>),\n+    Struct(Lazy<VariantData>, ReprOptions),\n+    Union(Lazy<VariantData>, ReprOptions),\n+    Fn(Lazy<FnData>),\n+    ForeignFn(Lazy<FnData>),\n     Mod(Lazy<ModData>),\n     MacroDef(Lazy<MacroDef>),\n-    Closure(Lazy!(ClosureData<'tcx>)),\n+    Closure,\n     Generator(Lazy!(GeneratorData<'tcx>)),\n-    Trait(Lazy!(TraitData<'tcx>)),\n-    Impl(Lazy!(ImplData<'tcx>)),\n-    Method(Lazy!(MethodData<'tcx>)),\n+    Trait(Lazy<TraitData>),\n+    Impl(Lazy<ImplData>),\n+    Method(Lazy<MethodData>),\n     AssocType(AssocContainer),\n     AssocOpaqueTy(AssocContainer),\n     AssocConst(AssocContainer, ConstQualif, Lazy<RenderedConst>),\n-    TraitAlias(Lazy!(TraitAliasData<'tcx>)),\n+    TraitAlias,\n }\n \n /// Additional data for EntryKind::Const and EntryKind::AssocConst\n@@ -305,47 +308,37 @@ crate struct MacroDef {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct FnData<'tcx> {\n+crate struct FnData {\n     pub asyncness: hir::IsAsync,\n     pub constness: hir::Constness,\n     pub param_names: Lazy<[ast::Name]>,\n-    pub sig: Lazy!(ty::PolyFnSig<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct VariantData<'tcx> {\n+crate struct VariantData {\n     pub ctor_kind: CtorKind,\n     pub discr: ty::VariantDiscr,\n     /// If this is unit or tuple-variant/struct, then this is the index of the ctor id.\n     pub ctor: Option<DefIndex>,\n-    /// If this is a tuple struct or variant\n-    /// ctor, this is its \"function\" signature.\n-    pub ctor_sig: Option<Lazy!(ty::PolyFnSig<'tcx>)>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct TraitData<'tcx> {\n+crate struct TraitData {\n     pub unsafety: hir::Unsafety,\n     pub paren_sugar: bool,\n     pub has_auto_impl: bool,\n     pub is_marker: bool,\n-    pub super_predicates: Lazy!(ty::GenericPredicates<'tcx>),\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct TraitAliasData<'tcx> {\n-    pub super_predicates: Lazy!(ty::GenericPredicates<'tcx>),\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable)]\n-crate struct ImplData<'tcx> {\n+crate struct ImplData {\n     pub polarity: ty::ImplPolarity,\n     pub defaultness: hir::Defaultness,\n     pub parent_impl: Option<DefId>,\n \n     /// This is `Some` only for impls of `CoerceUnsized`.\n+    // FIXME(eddyb) perhaps compute this on the fly if cheap enough?\n     pub coerce_unsized_info: Option<ty::adjustment::CoerceUnsizedInfo>,\n-    pub trait_ref: Option<Lazy!(ty::TraitRef<'tcx>)>,\n }\n \n \n@@ -388,17 +381,12 @@ impl AssocContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct MethodData<'tcx> {\n-    pub fn_data: FnData<'tcx>,\n+crate struct MethodData {\n+    pub fn_data: FnData,\n     pub container: AssocContainer,\n     pub has_self: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n-crate struct ClosureData<'tcx> {\n-    pub sig: Lazy!(ty::PolyFnSig<'tcx>),\n-}\n-\n #[derive(RustcEncodable, RustcDecodable)]\n crate struct GeneratorData<'tcx> {\n     pub layout: mir::GeneratorLayout<'tcx>,"}]}