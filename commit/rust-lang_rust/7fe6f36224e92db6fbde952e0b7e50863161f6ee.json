{"sha": "7fe6f36224e92db6fbde952e0b7e50863161f6ee", "node_id": "C_kwDOAAsO6NoAKDdmZTZmMzYyMjRlOTJkYjZmYmRlOTUyZTBiN2U1MDg2MzE2MWY2ZWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-21T12:17:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-21T12:17:03Z"}, "message": "Auto merge of #103491 - cjgillot:self-rpit, r=oli-obk\n\nSupport using `Self` or projections inside an RPIT/async fn\n\nI reuse the same idea as https://github.com/rust-lang/rust/pull/103449 to use variances to encode whether a lifetime parameter is captured by impl-trait.\n\nThe current implementation of async and RPIT replace all lifetimes from the parent generics by `'static`.  This PR changes the scheme\n```rust\nimpl<'a> Foo<'a> {\n    fn foo<'b, T>() -> impl Into<Self> + 'b { ... }\n}\n\nopaque Foo::<'_a>::foo::<'_b, T>::opaque<'b>: Into<Foo<'_a>> + 'b;\nimpl<'a> Foo<'a> {\n    // OLD\n    fn foo<'b, T>() -> Foo::<'static>::foo::<'static, T>::opaque::<'b> { ... }\n                             ^^^^^^^ the `Self` becomes `Foo<'static>`\n\n    // NEW\n    fn foo<'b, T>() -> Foo::<'a>::foo::<'b, T>::opaque::<'b> { ... }\n                             ^^ the `Self` stays `Foo<'a>`\n}\n```\n\nThere is the same issue with projections. In the example, substitute `Self` by `<T as Trait<'b>>::Assoc` in the sugared version, and `Foo<'_a>` by `<T as Trait<'_b>>::Assoc` in the desugared one.\n\nThis allows to support `Self` in impl-trait, since we do not replace lifetimes by `'static` any more.  The same trick allows to use projections like `T::Assoc` where `Self` is allowed.  The feature is gated behind a `impl_trait_projections` feature gate.\n\nThe implementation relies on 2 tweaking rules for opaques in 2 places:\n- we only relate substs that correspond to captured lifetimes during TypeRelation;\n- we only list captured lifetimes in choice region computation.\n\nFor simplicity, I encoded the \"capturedness\" of lifetimes as a variance, `Bivariant` vs `Invariant` for unused vs captured lifetimes. The `variances_of` query used to ICE for opaques.\n\nImpl-trait that do not reference `Self` or projections will have their variances as:\n- `o` (invariant) for each parent type or const;\n- `*` (bivariant) for each parent lifetime --> will not participate in borrowck;\n- `o` (invariant) for each own lifetime.\n\nImpl-trait that does reference `Self` and/or projections will have some parent lifetimes marked as `o` (as the example above), and participate in type relation and borrowck.  In the example above, `variances_of(opaque) = ['_a: o, '_b: *, T: o, 'b: o]`.\n\nr? types\ncc `@compiler-errors` , as you asked about the issue with `Self` and projections.", "tree": {"sha": "581f4b1ae8eb562da89b71d1bdf4a0fc3d8d5f05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/581f4b1ae8eb562da89b71d1bdf4a0fc3d8d5f05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fe6f36224e92db6fbde952e0b7e50863161f6ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fe6f36224e92db6fbde952e0b7e50863161f6ee", "html_url": "https://github.com/rust-lang/rust/commit/7fe6f36224e92db6fbde952e0b7e50863161f6ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fe6f36224e92db6fbde952e0b7e50863161f6ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "736c675d2ab65bcde6554e1b73340c2dbc27c85a", "url": "https://api.github.com/repos/rust-lang/rust/commits/736c675d2ab65bcde6554e1b73340c2dbc27c85a", "html_url": "https://github.com/rust-lang/rust/commit/736c675d2ab65bcde6554e1b73340c2dbc27c85a"}, {"sha": "b37feca804ece8eed650465faab65f5c53494b33", "url": "https://api.github.com/repos/rust-lang/rust/commits/b37feca804ece8eed650465faab65f5c53494b33", "html_url": "https://github.com/rust-lang/rust/commit/b37feca804ece8eed650465faab65f5c53494b33"}], "stats": {"total": 909, "additions": 569, "deletions": 340}, "files": [{"sha": "500737f6e809afbd3444bef51ecffa99c06f670c", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -60,8 +60,8 @@ use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::DefPathData;\n use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::span_bug;\n use rustc_middle::ty::{ResolverAstLowering, TyCtxt};\n-use rustc_middle::{bug, span_bug};\n use rustc_session::parse::feature_err;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DesugaringKind;\n@@ -1465,17 +1465,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // frequently opened issues show.\n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::OpaqueTy, span, None);\n \n-        let opaque_ty_def_id = match origin {\n-            hir::OpaqueTyOrigin::TyAlias => self.create_def(\n-                self.current_hir_id_owner.def_id,\n-                opaque_ty_node_id,\n-                DefPathData::ImplTrait,\n-            ),\n-            hir::OpaqueTyOrigin::FnReturn(fn_def_id) => {\n-                self.create_def(fn_def_id, opaque_ty_node_id, DefPathData::ImplTrait)\n-            }\n-            hir::OpaqueTyOrigin::AsyncFn(..) => bug!(\"unreachable\"),\n-        };\n+        let opaque_ty_def_id = self.create_def(\n+            self.current_hir_id_owner.def_id,\n+            opaque_ty_node_id,\n+            DefPathData::ImplTrait,\n+        );\n         debug!(?opaque_ty_def_id);\n \n         // Contains the new lifetime definitions created for the TAIT (if any)."}, {"sha": "b5e00f471d26a0d266e021e330cfeb78f56fef1f", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -11,6 +11,7 @@ use std::ops::Index;\n \n /// Compactly stores a set of `R0 member of [R1...Rn]` constraints,\n /// indexed by the region `R0`.\n+#[derive(Debug)]\n pub(crate) struct MemberConstraintSet<'tcx, R>\n where\n     R: Copy + Eq,\n@@ -31,6 +32,7 @@ where\n }\n \n /// Represents a `R0 member of [R1..Rn]` constraint\n+#[derive(Debug)]\n pub(crate) struct NllMemberConstraint<'tcx> {\n     next_constraint: Option<NllMemberConstraintIndex>,\n "}, {"sha": "b35abbd107b9ce7e148603f91207a64c513e1f84", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -128,6 +128,7 @@ pub struct RegionInferenceContext<'tcx> {\n /// adds a new lower bound to the SCC it is analyzing: so you wind up\n /// with `'R: 'O` where `'R` is the pick-region and `'O` is the\n /// minimal viable option.\n+#[derive(Debug)]\n pub(crate) struct AppliedMemberConstraint {\n     /// The SCC that was affected. (The \"member region\".)\n     ///"}, {"sha": "d82d4cc39fb1c4f141dc435efccde1d029a69a15", "filename": "compiler/rustc_borrowck/src/region_infer/opaque_types.rs", "status": "modified", "additions": 37, "deletions": 11, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fopaque_types.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -1,4 +1,4 @@\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n use rustc_data_structures::vec_map::VecMap;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::OpaqueTyOrigin;\n@@ -61,17 +61,21 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         opaque_ty_decls: VecMap<OpaqueTypeKey<'tcx>, (OpaqueHiddenType<'tcx>, OpaqueTyOrigin)>,\n     ) -> VecMap<LocalDefId, OpaqueHiddenType<'tcx>> {\n         let mut result: VecMap<LocalDefId, OpaqueHiddenType<'tcx>> = VecMap::new();\n+\n+        let member_constraints: FxHashMap<_, _> = self\n+            .member_constraints\n+            .all_indices()\n+            .map(|ci| (self.member_constraints[ci].key, ci))\n+            .collect();\n+        debug!(?member_constraints);\n+\n         for (opaque_type_key, (concrete_type, origin)) in opaque_ty_decls {\n             let substs = opaque_type_key.substs;\n             debug!(?concrete_type, ?substs);\n \n             let mut subst_regions = vec![self.universal_regions.fr_static];\n-            let universal_substs = infcx.tcx.fold_regions(substs, |region, _| {\n-                if let ty::RePlaceholder(..) = region.kind() {\n-                    // Higher kinded regions don't need remapping, they don't refer to anything outside of this the substs.\n-                    return region;\n-                }\n-                let vid = self.to_region_vid(region);\n+\n+            let to_universal_region = |vid, subst_regions: &mut Vec<_>| {\n                 trace!(?vid);\n                 let scc = self.constraint_sccs.scc(vid);\n                 trace!(?scc);\n@@ -92,10 +96,33 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         infcx.tcx.lifetimes.re_static\n                     }\n                 }\n+            };\n+\n+            // Start by inserting universal regions from the member_constraint choice regions.\n+            // This will ensure they get precedence when folding the regions in the concrete type.\n+            if let Some(&ci) = member_constraints.get(&opaque_type_key) {\n+                for &vid in self.member_constraints.choice_regions(ci) {\n+                    to_universal_region(vid, &mut subst_regions);\n+                }\n+            }\n+            debug!(?subst_regions);\n+\n+            // Next, insert universal regions from substs, so we can translate regions that appear\n+            // in them but are not subject to member constraints, for instance closure substs.\n+            let universal_substs = infcx.tcx.fold_regions(substs, |region, _| {\n+                if let ty::RePlaceholder(..) = region.kind() {\n+                    // Higher kinded regions don't need remapping, they don't refer to anything outside of this the substs.\n+                    return region;\n+                }\n+                let vid = self.to_region_vid(region);\n+                to_universal_region(vid, &mut subst_regions)\n             });\n+            debug!(?universal_substs);\n+            debug!(?subst_regions);\n \n-            subst_regions.sort();\n-            subst_regions.dedup();\n+            // Deduplicate the set of regions while keeping the chosen order.\n+            let subst_regions = subst_regions.into_iter().collect::<FxIndexSet<_>>();\n+            debug!(?subst_regions);\n \n             let universal_concrete_type =\n                 infcx.tcx.fold_regions(concrete_type, |region, _| match *region {\n@@ -106,8 +133,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         .unwrap_or(infcx.tcx.lifetimes.re_erased),\n                     _ => region,\n                 });\n-\n-            debug!(?universal_concrete_type, ?universal_substs);\n+            debug!(?universal_concrete_type);\n \n             let opaque_type_key =\n                 OpaqueTypeKey { def_id: opaque_type_key.def_id, substs: universal_substs };"}, {"sha": "85e5faada224e4269622c711e59a4ff836bbcf17", "filename": "compiler/rustc_error_codes/src/error_codes/E0760.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0760.md", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0760.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0760.md?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -1,9 +1,11 @@\n+#### Note: this error code is no longer emitted by the compiler.\n+\n `async fn`/`impl trait` return type cannot contain a projection\n or `Self` that references lifetimes from a parent scope.\n \n Erroneous code example:\n \n-```compile_fail,E0760,edition2018\n+```compile_fail,edition2018\n struct S<'a>(&'a i32);\n \n impl<'a> S<'a> {"}, {"sha": "9ca63c393c623746524833e90ca58d1362c338a6", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -419,6 +419,8 @@ declare_features! (\n     (active, if_let_guard, \"1.47.0\", Some(51114), None),\n     /// Allows `impl Trait` as output type in `Fn` traits in return position of functions.\n     (active, impl_trait_in_fn_trait_return, \"1.64.0\", Some(99697), None),\n+    /// Allows referencing `Self` and projections in impl-trait.\n+    (active, impl_trait_projections, \"CURRENT_RUSTC_VERSION\", Some(103532), None),\n     /// Allows using imported `main` function\n     (active, imported_main, \"1.53.0\", Some(28937), None),\n     /// Allows associated types in inherent impls."}, {"sha": "e8098ea66b2cca78c6c0454946e7d3d44098f833", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -2777,35 +2777,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let substs = InternalSubsts::for_item(tcx, def_id, |param, _| {\n             if let Some(i) = (param.index as usize).checked_sub(generics.parent_count) {\n                 // Our own parameters are the resolved lifetimes.\n-                if let GenericParamDefKind::Lifetime = param.kind {\n-                    if let hir::GenericArg::Lifetime(lifetime) = &lifetimes[i] {\n-                        self.ast_region_to_region(lifetime, None).into()\n-                    } else {\n-                        bug!()\n-                    }\n-                } else {\n-                    bug!()\n-                }\n+                let GenericParamDefKind::Lifetime { .. } = param.kind else { bug!() };\n+                let hir::GenericArg::Lifetime(lifetime) = &lifetimes[i] else { bug!() };\n+                self.ast_region_to_region(lifetime, None).into()\n             } else {\n-                match param.kind {\n-                    // For RPIT (return position impl trait), only lifetimes\n-                    // mentioned in the impl Trait predicate are captured by\n-                    // the opaque type, so the lifetime parameters from the\n-                    // parent item need to be replaced with `'static`.\n-                    //\n-                    // For `impl Trait` in the types of statics, constants,\n-                    // locals and type aliases. These capture all parent\n-                    // lifetimes, so they can use their identity subst.\n-                    GenericParamDefKind::Lifetime\n-                        if matches!(\n-                            origin,\n-                            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..)\n-                        ) =>\n-                    {\n-                        tcx.lifetimes.re_static.into()\n-                    }\n-                    _ => tcx.mk_param_from_def(param),\n-                }\n+                tcx.mk_param_from_def(param)\n             }\n         });\n         debug!(\"impl_trait_ty_to_ty: substs={:?}\", substs);\n@@ -2982,6 +2958,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Some(tcx.liberate_late_bound_regions(fn_hir_id.expect_owner().to_def_id(), ty))\n     }\n \n+    #[instrument(level = \"trace\", skip(self, generate_err))]\n     fn validate_late_bound_regions(\n         &self,\n         constrained_regions: FxHashSet<ty::BoundRegionKind>,"}, {"sha": "33b9c61993a3c6b6b6c7d1383aea3849ca0e7bad", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 41, "deletions": 50, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -10,6 +10,7 @@ use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{ItemKind, Node, PathSegment};\n+use rustc_infer::infer::opaque_types::ConstrainOpaqueTypeRegionVisitor;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n use rustc_infer::infer::{DefiningAnchor, RegionVariableOrigin, TyCtxtInferExt};\n use rustc_infer::traits::Obligation;\n@@ -229,7 +230,9 @@ fn check_opaque<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n     let substs = InternalSubsts::identity_for_item(tcx, item.owner_id.to_def_id());\n     let span = tcx.def_span(item.owner_id.def_id);\n \n-    check_opaque_for_inheriting_lifetimes(tcx, item.owner_id.def_id, span);\n+    if !tcx.features().impl_trait_projections {\n+        check_opaque_for_inheriting_lifetimes(tcx, item.owner_id.def_id, span);\n+    }\n     if tcx.type_of(item.owner_id.def_id).references_error() {\n         return;\n     }\n@@ -238,6 +241,7 @@ fn check_opaque<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n     }\n     check_opaque_meets_bounds(tcx, item.owner_id.def_id, substs, span, &origin);\n }\n+\n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n /// in \"inheriting lifetimes\".\n #[instrument(level = \"debug\", skip(tcx, span))]\n@@ -249,52 +253,37 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n     let item = tcx.hir().expect_item(def_id);\n     debug!(?item, ?span);\n \n-    struct FoundParentLifetime;\n-    struct FindParentLifetimeVisitor<'tcx>(&'tcx ty::Generics);\n-    impl<'tcx> ty::visit::TypeVisitor<'tcx> for FindParentLifetimeVisitor<'tcx> {\n-        type BreakTy = FoundParentLifetime;\n-\n-        fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            debug!(\"FindParentLifetimeVisitor: r={:?}\", r);\n-            if let ty::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = *r {\n-                if index < self.0.parent_count as u32 {\n-                    return ControlFlow::Break(FoundParentLifetime);\n-                } else {\n-                    return ControlFlow::CONTINUE;\n-                }\n-            }\n-\n-            r.super_visit_with(self)\n-        }\n-\n-        fn visit_const(&mut self, c: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if let ty::ConstKind::Unevaluated(..) = c.kind() {\n-                // FIXME(#72219) We currently don't detect lifetimes within substs\n-                // which would violate this check. Even though the particular substitution is not used\n-                // within the const, this should still be fixed.\n-                return ControlFlow::CONTINUE;\n-            }\n-            c.super_visit_with(self)\n-        }\n-    }\n-\n     struct ProhibitOpaqueVisitor<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         opaque_identity_ty: Ty<'tcx>,\n-        generics: &'tcx ty::Generics,\n+        parent_count: u32,\n+        references_parent_regions: bool,\n         selftys: Vec<(Span, Option<String>)>,\n     }\n \n     impl<'tcx> ty::visit::TypeVisitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n         type BreakTy = Ty<'tcx>;\n \n         fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            debug!(\"check_opaque_for_inheriting_lifetimes: (visit_ty) t={:?}\", t);\n+            debug!(?t, \"root_visit_ty\");\n             if t == self.opaque_identity_ty {\n                 ControlFlow::CONTINUE\n             } else {\n-                t.super_visit_with(&mut FindParentLifetimeVisitor(self.generics))\n-                    .map_break(|FoundParentLifetime| t)\n+                t.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+                    tcx: self.tcx,\n+                    op: |region| {\n+                        if let ty::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = *region\n+                            && index < self.parent_count\n+                        {\n+                            self.references_parent_regions= true;\n+                        }\n+                    },\n+                });\n+                if self.references_parent_regions {\n+                    ControlFlow::Break(t)\n+                } else {\n+                    ControlFlow::CONTINUE\n+                }\n             }\n         }\n     }\n@@ -327,26 +316,27 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n \n     if let ItemKind::OpaqueTy(hir::OpaqueTy {\n         origin: hir::OpaqueTyOrigin::AsyncFn(..) | hir::OpaqueTyOrigin::FnReturn(..),\n+        in_trait,\n         ..\n     }) = item.kind\n     {\n+        let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+        let opaque_identity_ty = if in_trait {\n+            tcx.mk_projection(def_id.to_def_id(), substs)\n+        } else {\n+            tcx.mk_opaque(def_id.to_def_id(), substs)\n+        };\n         let mut visitor = ProhibitOpaqueVisitor {\n-            opaque_identity_ty: tcx.mk_opaque(\n-                def_id.to_def_id(),\n-                InternalSubsts::identity_for_item(tcx, def_id.to_def_id()),\n-            ),\n-            generics: tcx.generics_of(def_id),\n+            opaque_identity_ty,\n+            parent_count: tcx.generics_of(def_id).parent_count as u32,\n+            references_parent_regions: false,\n             tcx,\n             selftys: vec![],\n         };\n         let prohibit_opaque = tcx\n             .explicit_item_bounds(def_id)\n             .iter()\n             .try_for_each(|(predicate, _)| predicate.visit_with(&mut visitor));\n-        debug!(\n-            \"check_opaque_for_inheriting_lifetimes: prohibit_opaque={:?}, visitor.opaque_identity_ty={:?}, visitor.generics={:?}\",\n-            prohibit_opaque, visitor.opaque_identity_ty, visitor.generics\n-        );\n \n         if let Some(ty) = prohibit_opaque.break_value() {\n             visitor.visit_item(&item);\n@@ -357,15 +347,16 @@ pub(super) fn check_opaque_for_inheriting_lifetimes<'tcx>(\n                 _ => unreachable!(),\n             };\n \n-            let mut err = struct_span_err!(\n-                tcx.sess,\n+            let mut err = feature_err(\n+                &tcx.sess.parse_sess,\n+                sym::impl_trait_projections,\n                 span,\n-                E0760,\n-                \"`{}` return type cannot contain a projection or `Self` that references lifetimes from \\\n-                 a parent scope\",\n-                if is_async { \"async fn\" } else { \"impl Trait\" },\n+                &format!(\n+                    \"`{}` return type cannot contain a projection or `Self` that references \\\n+                    lifetimes from a parent scope\",\n+                    if is_async { \"async fn\" } else { \"impl Trait\" },\n+                ),\n             );\n-\n             for (span, name) in visitor.selftys {\n                 err.span_suggestion(\n                     span,"}, {"sha": "b81f9d7a6d2c195ed8dc24abde3ba8038c7832f0", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -1539,7 +1539,6 @@ fn check_fn_or_method<'tcx>(\n \n     check_return_position_impl_trait_in_trait_bounds(\n         tcx,\n-        wfcx,\n         def_id,\n         sig.output(),\n         hir_decl.output.span(),\n@@ -1575,9 +1574,9 @@ fn check_fn_or_method<'tcx>(\n \n /// Basically `check_associated_type_bounds`, but separated for now and should be\n /// deduplicated when RPITITs get lowered into real associated items.\n+#[tracing::instrument(level = \"trace\", skip(tcx))]\n fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    wfcx: &WfCheckingCtxt<'_, 'tcx>,\n     fn_def_id: LocalDefId,\n     fn_output: Ty<'tcx>,\n     span: Span,\n@@ -1591,18 +1590,22 @@ fn check_return_position_impl_trait_in_trait_bounds<'tcx>(\n                 && tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder\n                 && tcx.impl_trait_in_trait_parent(proj.item_def_id) == fn_def_id.to_def_id()\n             {\n-                let bounds = wfcx.tcx().explicit_item_bounds(proj.item_def_id);\n-                let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n-                    let normalized_bound = wfcx.normalize(span, None, bound);\n-                    traits::wf::predicate_obligations(\n-                        wfcx.infcx,\n-                        wfcx.param_env,\n-                        wfcx.body_id,\n-                        normalized_bound,\n-                        bound_span,\n-                    )\n+                // Create a new context, since we want the opaque's ParamEnv and not the parent's.\n+                let span = tcx.def_span(proj.item_def_id);\n+                enter_wf_checking_ctxt(tcx, span, proj.item_def_id.expect_local(), |wfcx| {\n+                    let bounds = wfcx.tcx().explicit_item_bounds(proj.item_def_id);\n+                    let wf_obligations = bounds.iter().flat_map(|&(bound, bound_span)| {\n+                        let normalized_bound = wfcx.normalize(span, None, bound);\n+                        traits::wf::predicate_obligations(\n+                            wfcx.infcx,\n+                            wfcx.param_env,\n+                            wfcx.body_id,\n+                            normalized_bound,\n+                            bound_span,\n+                        )\n+                    });\n+                    wfcx.register_obligations(wf_obligations);\n                 });\n-                wfcx.register_obligations(wf_obligations);\n             }\n         }\n     }"}, {"sha": "c3f1bb457f701c300da320fb8b989d342c7c0e2c", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 71, "deletions": 52, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -84,60 +84,30 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n \n         Node::ImplItem(item) => item.generics,\n \n-        Node::Item(item) => {\n-            match item.kind {\n-                ItemKind::Impl(ref impl_) => {\n-                    if impl_.defaultness.is_default() {\n-                        is_default_impl_trait = tcx.impl_trait_ref(def_id).map(ty::Binder::dummy);\n-                    }\n-                    &impl_.generics\n+        Node::Item(item) => match item.kind {\n+            ItemKind::Impl(ref impl_) => {\n+                if impl_.defaultness.is_default() {\n+                    is_default_impl_trait = tcx.impl_trait_ref(def_id).map(ty::Binder::dummy);\n                 }\n-                ItemKind::Fn(.., ref generics, _)\n-                | ItemKind::TyAlias(_, ref generics)\n-                | ItemKind::Enum(_, ref generics)\n-                | ItemKind::Struct(_, ref generics)\n-                | ItemKind::Union(_, ref generics) => *generics,\n-\n-                ItemKind::Trait(_, _, ref generics, ..) => {\n-                    is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n-                    *generics\n-                }\n-                ItemKind::TraitAlias(ref generics, _) => {\n-                    is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n-                    *generics\n-                }\n-                ItemKind::OpaqueTy(OpaqueTy {\n-                    origin: hir::OpaqueTyOrigin::AsyncFn(..) | hir::OpaqueTyOrigin::FnReturn(..),\n-                    ..\n-                }) => {\n-                    // return-position impl trait\n-                    //\n-                    // We don't inherit predicates from the parent here:\n-                    // If we have, say `fn f<'a, T: 'a>() -> impl Sized {}`\n-                    // then the return type is `f::<'static, T>::{{opaque}}`.\n-                    //\n-                    // If we inherited the predicates of `f` then we would\n-                    // require that `T: 'static` to show that the return\n-                    // type is well-formed.\n-                    //\n-                    // The only way to have something with this opaque type\n-                    // is from the return type of the containing function,\n-                    // which will ensure that the function's predicates\n-                    // hold.\n-                    return ty::GenericPredicates { parent: None, predicates: &[] };\n-                }\n-                ItemKind::OpaqueTy(OpaqueTy {\n-                    ref generics,\n-                    origin: hir::OpaqueTyOrigin::TyAlias,\n-                    ..\n-                }) => {\n-                    // type-alias impl trait\n-                    generics\n-                }\n-\n-                _ => NO_GENERICS,\n+                &impl_.generics\n             }\n-        }\n+            ItemKind::Fn(.., ref generics, _)\n+            | ItemKind::TyAlias(_, ref generics)\n+            | ItemKind::Enum(_, ref generics)\n+            | ItemKind::Struct(_, ref generics)\n+            | ItemKind::Union(_, ref generics) => *generics,\n+\n+            ItemKind::Trait(_, _, ref generics, ..) => {\n+                is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n+                *generics\n+            }\n+            ItemKind::TraitAlias(ref generics, _) => {\n+                is_trait = Some(ty::TraitRef::identity(tcx, def_id));\n+                *generics\n+            }\n+            ItemKind::OpaqueTy(OpaqueTy { ref generics, .. }) => generics,\n+            _ => NO_GENERICS,\n+        },\n \n         Node::ForeignItem(item) => match item.kind {\n             ForeignItemKind::Static(..) => NO_GENERICS,\n@@ -181,6 +151,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n \n     trace!(?predicates);\n     trace!(?ast_generics);\n+    trace!(?generics);\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T: Foo>`).\n@@ -299,6 +270,54 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n         );\n     }\n \n+    // Opaque types duplicate some of their generic parameters.\n+    // We create bi-directional Outlives predicates between the original\n+    // and the duplicated parameter, to ensure that they do not get out of sync.\n+    if let Node::Item(&Item { kind: ItemKind::OpaqueTy(..), .. }) = node {\n+        let opaque_ty_id = tcx.hir().get_parent_node(hir_id);\n+        let opaque_ty_node = tcx.hir().get(opaque_ty_id);\n+        let Node::Ty(&Ty { kind: TyKind::OpaqueDef(_, lifetimes, _), .. }) = opaque_ty_node else {\n+            bug!(\"unexpected {opaque_ty_node:?}\")\n+        };\n+        debug!(?lifetimes);\n+        for (arg, duplicate) in std::iter::zip(lifetimes, ast_generics.params) {\n+            let hir::GenericArg::Lifetime(arg) = arg else { bug!() };\n+            let orig_region = <dyn AstConv<'_>>::ast_region_to_region(&icx, &arg, None);\n+            if !matches!(orig_region.kind(), ty::ReEarlyBound(..)) {\n+                // Only early-bound regions can point to the original generic parameter.\n+                continue;\n+            }\n+\n+            let hir::GenericParamKind::Lifetime { .. } = duplicate.kind else { continue };\n+            let dup_def = tcx.hir().local_def_id(duplicate.hir_id).to_def_id();\n+\n+            let Some(dup_index) = generics.param_def_id_to_index(tcx, dup_def) else { bug!() };\n+\n+            let dup_region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                def_id: dup_def,\n+                index: dup_index,\n+                name: duplicate.name.ident().name,\n+            }));\n+            predicates.push((\n+                ty::Binder::dummy(ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n+                    orig_region,\n+                    dup_region,\n+                )))\n+                .to_predicate(icx.tcx),\n+                duplicate.span,\n+            ));\n+            predicates.push((\n+                ty::Binder::dummy(ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n+                    dup_region,\n+                    orig_region,\n+                )))\n+                .to_predicate(icx.tcx),\n+                duplicate.span,\n+            ));\n+        }\n+        debug!(?predicates);\n+    }\n+\n     ty::GenericPredicates {\n         parent: generics.parent,\n         predicates: tcx.arena.alloc_from_iter(predicates),"}, {"sha": "b6137f89cadaae0a7499a6999aa3d723bd9d6360", "filename": "compiler/rustc_hir_analysis/src/variance/mod.rs", "status": "modified", "additions": 92, "deletions": 2, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fmod.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -5,9 +5,10 @@\n \n use rustc_arena::DroplessArena;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, CrateVariancesMap, TyCtxt};\n+use rustc_middle::ty::{self, CrateVariancesMap, TyCtxt, TypeSuperVisitable, TypeVisitable};\n+use std::ops::ControlFlow;\n \n /// Defines the `TermsContext` basically houses an arena where we can\n /// allocate terms.\n@@ -50,6 +51,9 @@ fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n         | DefKind::Union\n         | DefKind::Variant\n         | DefKind::Ctor(..) => {}\n+        DefKind::OpaqueTy | DefKind::ImplTraitPlaceholder => {\n+            return variance_of_opaque(tcx, item_def_id.expect_local());\n+        }\n         _ => {\n             // Variance not relevant.\n             span_bug!(tcx.def_span(item_def_id), \"asked to compute variance for wrong kind of item\")\n@@ -61,3 +65,89 @@ fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n     let crate_map = tcx.crate_variances(());\n     crate_map.variances.get(&item_def_id).copied().unwrap_or(&[])\n }\n+\n+#[instrument(level = \"trace\", skip(tcx), ret)]\n+fn variance_of_opaque(tcx: TyCtxt<'_>, item_def_id: LocalDefId) -> &[ty::Variance] {\n+    let generics = tcx.generics_of(item_def_id);\n+\n+    // Opaque types may only use regions that are bound. So for\n+    // ```rust\n+    // type Foo<'a, 'b, 'c> = impl Trait<'a> + 'b;\n+    // ```\n+    // we may not use `'c` in the hidden type.\n+    struct OpaqueTypeLifetimeCollector {\n+        variances: Vec<ty::Variance>,\n+    }\n+\n+    impl<'tcx> ty::TypeVisitor<'tcx> for OpaqueTypeLifetimeCollector {\n+        #[instrument(level = \"trace\", skip(self), ret)]\n+        fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            if let ty::RegionKind::ReEarlyBound(ebr) = r.kind() {\n+                self.variances[ebr.index as usize] = ty::Invariant;\n+            }\n+            r.super_visit_with(self)\n+        }\n+    }\n+\n+    // By default, RPIT are invariant wrt type and const generics, but they are bivariant wrt\n+    // lifetime generics.\n+    let mut variances: Vec<_> = std::iter::repeat(ty::Invariant).take(generics.count()).collect();\n+\n+    // Mark all lifetimes from parent generics as unused (Bivariant).\n+    // This will be overridden later if required.\n+    {\n+        let mut generics = generics;\n+        while let Some(def_id) = generics.parent {\n+            generics = tcx.generics_of(def_id);\n+            for param in &generics.params {\n+                match param.kind {\n+                    ty::GenericParamDefKind::Lifetime => {\n+                        variances[param.index as usize] = ty::Bivariant;\n+                    }\n+                    ty::GenericParamDefKind::Type { .. }\n+                    | ty::GenericParamDefKind::Const { .. } => {}\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut collector = OpaqueTypeLifetimeCollector { variances };\n+    let id_substs = ty::InternalSubsts::identity_for_item(tcx, item_def_id.to_def_id());\n+    for pred in tcx.bound_explicit_item_bounds(item_def_id.to_def_id()).transpose_iter() {\n+        let pred = pred.map_bound(|(pred, _)| *pred).subst(tcx, id_substs);\n+        debug!(?pred);\n+\n+        // We only ignore opaque type substs if the opaque type is the outermost type.\n+        // The opaque type may be nested within itself via recursion in e.g.\n+        // type Foo<'a> = impl PartialEq<Foo<'a>>;\n+        // which thus mentions `'a` and should thus accept hidden types that borrow 'a\n+        // instead of requiring an additional `+ 'a`.\n+        match pred.kind().skip_binder() {\n+            ty::PredicateKind::Trait(ty::TraitPredicate {\n+                trait_ref: ty::TraitRef { def_id: _, substs },\n+                constness: _,\n+                polarity: _,\n+            }) => {\n+                for subst in &substs[1..] {\n+                    subst.visit_with(&mut collector);\n+                }\n+            }\n+            ty::PredicateKind::Projection(ty::ProjectionPredicate {\n+                projection_ty: ty::ProjectionTy { substs, item_def_id: _ },\n+                term,\n+            }) => {\n+                for subst in &substs[1..] {\n+                    subst.visit_with(&mut collector);\n+                }\n+                term.visit_with(&mut collector);\n+            }\n+            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_, region)) => {\n+                region.visit_with(&mut collector);\n+            }\n+            _ => {\n+                pred.visit_with(&mut collector);\n+            }\n+        }\n+    }\n+    tcx.arena.alloc_from_iter(collector.variances.into_iter())\n+}"}, {"sha": "c2552561c42dfda9f7f99c54da006ad3457a5eb4", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -564,6 +564,7 @@ impl<'tcx> TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 &opt_variances,\n                 a_subst,\n                 b_subst,\n+                true,\n             )\n         }\n     }"}, {"sha": "d773aa5f1fce1402141df71dd825fe4c61846678", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -261,6 +261,7 @@ fn label_msg_span(\n     }\n }\n \n+#[instrument(level = \"trace\", skip(tcx))]\n pub fn unexpected_hidden_region_diagnostic<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     span: Span,"}, {"sha": "8d3d002cb27fae541d8f0f6a9589a8e953ece446", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 37, "deletions": 28, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -332,32 +332,11 @@ impl<'tcx> InferCtxt<'tcx> {\n         concrete_ty: Ty<'tcx>,\n         span: Span,\n     ) {\n-        let def_id = opaque_type_key.def_id;\n-\n-        let tcx = self.tcx;\n-\n         let concrete_ty = self.resolve_vars_if_possible(concrete_ty);\n-\n         debug!(?concrete_ty);\n \n-        let first_own_region = match self.opaque_ty_origin_unchecked(def_id, span) {\n-            hir::OpaqueTyOrigin::FnReturn(..) | hir::OpaqueTyOrigin::AsyncFn(..) => {\n-                // We lower\n-                //\n-                // fn foo<'l0..'ln>() -> impl Trait<'l0..'lm>\n-                //\n-                // into\n-                //\n-                // type foo::<'p0..'pn>::Foo<'q0..'qm>\n-                // fn foo<l0..'ln>() -> foo::<'static..'static>::Foo<'l0..'lm>.\n-                //\n-                // For these types we only iterate over `'l0..lm` below.\n-                tcx.generics_of(def_id).parent_count\n-            }\n-            // These opaque type inherit all lifetime parameters from their\n-            // parent, so we have to check them all.\n-            hir::OpaqueTyOrigin::TyAlias => 0,\n-        };\n+        let variances = self.tcx.variances_of(opaque_type_key.def_id);\n+        debug!(?variances);\n \n         // For a case like `impl Foo<'a, 'b>`, we would generate a constraint\n         // `'r in ['a, 'b, 'static]` for each region `'r` that appears in the\n@@ -370,9 +349,12 @@ impl<'tcx> InferCtxt<'tcx> {\n         // type can be equal to any of the region parameters of the\n         // opaque type definition.\n         let choice_regions: Lrc<Vec<ty::Region<'tcx>>> = Lrc::new(\n-            opaque_type_key.substs[first_own_region..]\n+            opaque_type_key\n+                .substs\n                 .iter()\n-                .filter_map(|arg| match arg.unpack() {\n+                .enumerate()\n+                .filter(|(i, _)| variances[*i] == ty::Variance::Invariant)\n+                .filter_map(|(_, arg)| match arg.unpack() {\n                     GenericArgKind::Lifetime(r) => Some(r),\n                     GenericArgKind::Type(_) | GenericArgKind::Const(_) => None,\n                 })\n@@ -381,6 +363,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         );\n \n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+            tcx: self.tcx,\n             op: |r| self.member_constraint(opaque_type_key, span, concrete_ty, r, &choice_regions),\n         });\n     }\n@@ -440,11 +423,12 @@ impl<'tcx> InferCtxt<'tcx> {\n //\n // We ignore any type parameters because impl trait values are assumed to\n // capture all the in-scope type parameters.\n-struct ConstrainOpaqueTypeRegionVisitor<OP> {\n-    op: OP,\n+pub struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP: FnMut(ty::Region<'tcx>)> {\n+    pub tcx: TyCtxt<'tcx>,\n+    pub op: OP,\n }\n \n-impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<OP>\n+impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<'tcx, OP>\n where\n     OP: FnMut(ty::Region<'tcx>),\n {\n@@ -490,6 +474,31 @@ where\n                 substs.as_generator().yield_ty().visit_with(self);\n                 substs.as_generator().resume_ty().visit_with(self);\n             }\n+\n+            ty::Opaque(def_id, ref substs) => {\n+                // Skip lifetime paramters that are not captures.\n+                let variances = self.tcx.variances_of(*def_id);\n+\n+                for (v, s) in std::iter::zip(variances, substs.iter()) {\n+                    if *v != ty::Variance::Bivariant {\n+                        s.visit_with(self);\n+                    }\n+                }\n+            }\n+\n+            ty::Projection(proj)\n+                if self.tcx.def_kind(proj.item_def_id) == DefKind::ImplTraitPlaceholder =>\n+            {\n+                // Skip lifetime paramters that are not captures.\n+                let variances = self.tcx.variances_of(proj.item_def_id);\n+\n+                for (v, s) in std::iter::zip(variances, proj.substs.iter()) {\n+                    if *v != ty::Variance::Bivariant {\n+                        s.visit_with(self);\n+                    }\n+                }\n+            }\n+\n             _ => {\n                 ty.super_visit_with(self);\n             }"}, {"sha": "76a7fb41e6c909a470863947e6187a6a7f51bf27", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -928,6 +928,8 @@ fn should_encode_variances(def_kind: DefKind) -> bool {\n         | DefKind::Union\n         | DefKind::Enum\n         | DefKind::Variant\n+        | DefKind::OpaqueTy\n+        | DefKind::ImplTraitPlaceholder\n         | DefKind::Fn\n         | DefKind::Ctor(..)\n         | DefKind::AssocFn => true,\n@@ -941,8 +943,6 @@ fn should_encode_variances(def_kind: DefKind) -> bool {\n         | DefKind::Const\n         | DefKind::ForeignMod\n         | DefKind::TyAlias\n-        | DefKind::OpaqueTy\n-        | DefKind::ImplTraitPlaceholder\n         | DefKind::Impl\n         | DefKind::Trait\n         | DefKind::TraitAlias"}, {"sha": "ffb4ad4db88f5fa661dea0496ff4668182bf3bfc", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 54, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -1257,7 +1257,7 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable, TyEncodable, TyDecodable, Lift)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable, TyEncodable, TyDecodable, Lift)]\n #[derive(TypeFoldable, TypeVisitable)]\n pub struct OpaqueTypeKey<'tcx> {\n     pub def_id: LocalDefId,\n@@ -1332,6 +1332,9 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n         let id_substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n         debug!(?id_substs);\n \n+        // This zip may have several times the same lifetime in `substs` paired with a different\n+        // lifetime from `id_substs`.  Simply `collect`ing the iterator is the correct behaviour:\n+        // it will pick the last one, which is the one we introduced in the impl-trait desugaring.\n         let map = substs.iter().zip(id_substs);\n \n         let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> = match origin {\n@@ -1345,61 +1348,13 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n                 // type Foo<'a, 'b, 'c> = impl Trait<'a> + 'b;\n                 // ```\n                 // we may not use `'c` in the hidden type.\n-                struct OpaqueTypeLifetimeCollector<'tcx> {\n-                    lifetimes: FxHashSet<ty::Region<'tcx>>,\n-                }\n-\n-                impl<'tcx> ty::TypeVisitor<'tcx> for OpaqueTypeLifetimeCollector<'tcx> {\n-                    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                        self.lifetimes.insert(r);\n-                        r.super_visit_with(self)\n-                    }\n-                }\n+                let variances = tcx.variances_of(def_id);\n+                debug!(?variances);\n \n-                let mut collector = OpaqueTypeLifetimeCollector { lifetimes: Default::default() };\n-\n-                for pred in tcx.bound_explicit_item_bounds(def_id.to_def_id()).transpose_iter() {\n-                    let pred = pred.map_bound(|(pred, _)| *pred).subst(tcx, id_substs);\n-\n-                    trace!(pred=?pred.kind());\n-\n-                    // We only ignore opaque type substs if the opaque type is the outermost type.\n-                    // The opaque type may be nested within itself via recursion in e.g.\n-                    // type Foo<'a> = impl PartialEq<Foo<'a>>;\n-                    // which thus mentions `'a` and should thus accept hidden types that borrow 'a\n-                    // instead of requiring an additional `+ 'a`.\n-                    match pred.kind().skip_binder() {\n-                        ty::PredicateKind::Trait(TraitPredicate {\n-                            trait_ref: ty::TraitRef { def_id: _, substs },\n-                            constness: _,\n-                            polarity: _,\n-                        }) => {\n-                            trace!(?substs);\n-                            for subst in &substs[1..] {\n-                                subst.visit_with(&mut collector);\n-                            }\n-                        }\n-                        ty::PredicateKind::Projection(ty::ProjectionPredicate {\n-                            projection_ty: ty::ProjectionTy { substs, item_def_id: _ },\n-                            term,\n-                        }) => {\n-                            for subst in &substs[1..] {\n-                                subst.visit_with(&mut collector);\n-                            }\n-                            term.visit_with(&mut collector);\n-                        }\n-                        _ => {\n-                            pred.visit_with(&mut collector);\n-                        }\n-                    }\n-                }\n-                let lifetimes = collector.lifetimes;\n-                trace!(?lifetimes);\n                 map.filter(|(_, v)| {\n-                    let ty::GenericArgKind::Lifetime(lt) = v.unpack() else {\n-                        return true;\n-                    };\n-                    lifetimes.contains(&lt)\n+                    let ty::GenericArgKind::Lifetime(lt) = v.unpack() else { return true };\n+                    let ty::ReEarlyBound(ebr) = lt.kind() else { bug!() };\n+                    variances[ebr.index as usize] == ty::Variance::Invariant\n                 })\n                 .collect()\n             }"}, {"sha": "6d02551716e35d86a63dc996df9992ec34a5668c", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -60,7 +60,7 @@ pub trait TypeRelation<'tcx>: Sized {\n \n         let tcx = self.tcx();\n         let opt_variances = tcx.variances_of(item_def_id);\n-        relate_substs_with_variances(self, item_def_id, opt_variances, a_subst, b_subst)\n+        relate_substs_with_variances(self, item_def_id, opt_variances, a_subst, b_subst, true)\n     }\n \n     /// Switch variance for the purpose of relating `a` and `b`.\n@@ -151,13 +151,14 @@ pub fn relate_substs_with_variances<'tcx, R: TypeRelation<'tcx>>(\n     variances: &[ty::Variance],\n     a_subst: SubstsRef<'tcx>,\n     b_subst: SubstsRef<'tcx>,\n+    fetch_ty_for_diag: bool,\n ) -> RelateResult<'tcx, SubstsRef<'tcx>> {\n     let tcx = relation.tcx();\n \n     let mut cached_ty = None;\n     let params = iter::zip(a_subst, b_subst).enumerate().map(|(i, (a, b))| {\n         let variance = variances[i];\n-        let variance_info = if variance == ty::Invariant {\n+        let variance_info = if variance == ty::Invariant && fetch_ty_for_diag {\n             let ty =\n                 *cached_ty.get_or_insert_with(|| tcx.bound_type_of(ty_def_id).subst(tcx, a_subst));\n             ty::VarianceDiagInfo::Invariant { ty, param_index: i.try_into().unwrap() }\n@@ -561,7 +562,15 @@ pub fn super_relate_tys<'tcx, R: TypeRelation<'tcx>>(\n         (&ty::Opaque(a_def_id, a_substs), &ty::Opaque(b_def_id, b_substs))\n             if a_def_id == b_def_id =>\n         {\n-            let substs = relate_substs(relation, a_substs, b_substs)?;\n+            let opt_variances = tcx.variances_of(a_def_id);\n+            let substs = relate_substs_with_variances(\n+                relation,\n+                a_def_id,\n+                opt_variances,\n+                a_substs,\n+                b_substs,\n+                false, // do not fetch `type_of(a_def_id)`, as it will cause a cycle\n+            )?;\n             Ok(tcx.mk_opaque(a_def_id, substs))\n         }\n "}, {"sha": "29312a21b4d464f8af5e6c407d27f133727b6fe5", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -787,6 +787,7 @@ symbols! {\n         impl_lint_pass,\n         impl_trait_in_bindings,\n         impl_trait_in_fn_trait_return,\n+        impl_trait_projections,\n         implied_by,\n         import,\n         import_name_type,"}, {"sha": "bd7b64ad7c1ea8e979c113f187a54d6cbb403330", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -108,12 +108,7 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> &[Ty<'_>] {\n \n /// See `ParamEnv` struct definition for details.\n fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n-    // The param_env of an impl Trait type is its defining function's param_env\n-    if let Some(parent) = ty::is_impl_trait_defn(tcx, def_id) {\n-        return param_env(tcx, parent.to_def_id());\n-    }\n     // Compute the bounds on Self and the type parameters.\n-\n     let ty::InstantiatedPredicates { mut predicates, .. } =\n         tcx.predicates_of(def_id).instantiate_identity(tcx);\n "}, {"sha": "41f887430c1cb8bcf7e3bdd3d9205d28c997db97", "filename": "src/test/ui/async-await/feature-self-return-type.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fasync-await%2Ffeature-self-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fasync-await%2Ffeature-self-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ffeature-self-return-type.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -0,0 +1,28 @@\n+// edition:2018\n+#![feature(impl_trait_projections)]\n+\n+// This test checks that we emit the correct borrowck error when `Self` is used as a return type.\n+// See #61949 for context.\n+\n+pub struct Foo<'a> {\n+    pub bar: &'a i32,\n+}\n+\n+impl<'a> Foo<'a> {\n+    pub async fn new(_bar: &'a i32) -> Self {\n+        Foo {\n+            bar: &22\n+        }\n+    }\n+}\n+\n+pub async fn foo() {\n+    let x = {\n+        let bar = 22;\n+        Foo::new(&bar).await\n+        //~^ ERROR `bar` does not live long enough\n+    };\n+    drop(x);\n+}\n+\n+fn main() { }"}, {"sha": "8924683684fb48169d123b1cae8de2a8a9b5518d", "filename": "src/test/ui/async-await/feature-self-return-type.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fasync-await%2Ffeature-self-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fasync-await%2Ffeature-self-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ffeature-self-return-type.stderr?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -0,0 +1,15 @@\n+error[E0597]: `bar` does not live long enough\n+  --> $DIR/feature-self-return-type.rs:22:18\n+   |\n+LL |     let x = {\n+   |         - borrow later stored here\n+LL |         let bar = 22;\n+LL |         Foo::new(&bar).await\n+   |                  ^^^^ borrowed value does not live long enough\n+LL |\n+LL |     };\n+   |     - `bar` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "974f5aaff83c35d8e25744c3d52f281304ddcb62", "filename": "src/test/ui/async-await/in-trait/async-associated-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -1,8 +1,8 @@\n-// check-fail\n-// known-bug: #102682\n+// check-pass\n // edition: 2021\n \n #![feature(async_fn_in_trait)]\n+#![feature(impl_trait_projections)]\n #![allow(incomplete_features)]\n \n use std::fmt::Debug;"}, {"sha": "0985150eee0decc8fa070500d0e94fa030e875e6", "filename": "src/test/ui/async-await/in-trait/async-associated-types.stderr", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/736c675d2ab65bcde6554e1b73340c2dbc27c85a/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/736c675d2ab65bcde6554e1b73340c2dbc27c85a/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fin-trait%2Fasync-associated-types.stderr?ref=736c675d2ab65bcde6554e1b73340c2dbc27c85a", "patch": "@@ -1,57 +0,0 @@\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n-  --> $DIR/async-associated-types.rs:19:43\n-   |\n-LL |     async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n-   |                                           ^^^^^^^^^^^^^^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'a` as defined here...\n-  --> $DIR/async-associated-types.rs:16:6\n-   |\n-LL | impl<'a, 'b, T: Debug + Sized + 'b, U: 'a> MyTrait<'a, 'b, T> for U {\n-   |      ^^\n-note: ...so that the types are compatible\n-  --> $DIR/async-associated-types.rs:19:43\n-   |\n-LL |     async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n-   |                                           ^^^^^^^^^^^^^^\n-   = note: expected `(&'a U, &'b T)`\n-              found `(&U, &T)`\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that the types are compatible\n-  --> $DIR/async-associated-types.rs:19:43\n-   |\n-LL |     async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n-   |                                           ^^^^^^^^^^^^^^\n-   = note: expected `MyTrait<'static, 'static, T>`\n-              found `MyTrait<'_, '_, T>`\n-\n-error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'b` due to conflicting requirements\n-  --> $DIR/async-associated-types.rs:19:43\n-   |\n-LL |     async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n-   |                                           ^^^^^^^^^^^^^^\n-   |\n-note: first, the lifetime cannot outlive the lifetime `'b` as defined here...\n-  --> $DIR/async-associated-types.rs:16:10\n-   |\n-LL | impl<'a, 'b, T: Debug + Sized + 'b, U: 'a> MyTrait<'a, 'b, T> for U {\n-   |          ^^\n-note: ...so that the types are compatible\n-  --> $DIR/async-associated-types.rs:19:43\n-   |\n-LL |     async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n-   |                                           ^^^^^^^^^^^^^^\n-   = note: expected `(&'a U, &'b T)`\n-              found `(&U, &T)`\n-   = note: but, the lifetime must be valid for the static lifetime...\n-note: ...so that the types are compatible\n-  --> $DIR/async-associated-types.rs:19:43\n-   |\n-LL |     async fn foo(&'a self, key: &'b T) -> (&'a U, &'b T) {\n-   |                                           ^^^^^^^^^^^^^^\n-   = note: expected `MyTrait<'static, 'static, T>`\n-              found `MyTrait<'_, '_, T>`\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0495`."}, {"sha": "d73dbc6e828f3879a7af56604062d8ee61448dd7", "filename": "src/test/ui/async-await/issue-61949-self-return-type.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -1,4 +1,5 @@\n // edition:2018\n+// gate-test-impl_trait_projections\n \n // This test checks that `Self` is prohibited as a return type. See #61949 for context.\n \n@@ -19,6 +20,7 @@ async fn foo() {\n     let x = {\n         let bar = 22;\n         Foo::new(&bar).await\n+        //~^ ERROR `bar` does not live long enough\n     };\n     drop(x);\n }"}, {"sha": "638b197bc022d6d5f68f8e2f96491d3682de5ec8", "filename": "src/test/ui/async-await/issue-61949-self-return-type.stderr", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-61949-self-return-type.stderr?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -1,9 +1,25 @@\n-error[E0760]: `async fn` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n-  --> $DIR/issue-61949-self-return-type.rs:10:40\n+error[E0658]: `async fn` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n+  --> $DIR/issue-61949-self-return-type.rs:11:40\n    |\n LL |     pub async fn new(_bar: &'a i32) -> Self {\n    |                                        ^^^^ help: consider spelling out the type instead: `Foo<'a>`\n+   |\n+   = note: see issue #103532 <https://github.com/rust-lang/rust/issues/103532> for more information\n+   = help: add `#![feature(impl_trait_projections)]` to the crate attributes to enable\n+\n+error[E0597]: `bar` does not live long enough\n+  --> $DIR/issue-61949-self-return-type.rs:22:18\n+   |\n+LL |     let x = {\n+   |         - borrow later stored here\n+LL |         let bar = 22;\n+LL |         Foo::new(&bar).await\n+   |                  ^^^^ borrowed value does not live long enough\n+LL |\n+LL |     };\n+   |     - `bar` dropped here while still borrowed\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0760`.\n+Some errors have detailed explanations: E0597, E0658.\n+For more information about an error, try `rustc --explain E0597`."}, {"sha": "37eafa996c535863558e25f6d1a55f902eeb5a02", "filename": "src/test/ui/async-await/issues/issue-78600.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78600.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78600.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-78600.stderr?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -1,11 +1,14 @@\n-error[E0760]: `async fn` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n+error[E0658]: `async fn` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n   --> $DIR/issue-78600.rs:6:33\n    |\n LL |     async fn new(i: &'a i32) -> Result<Self, ()> {\n    |                                 ^^^^^^^----^^^^^\n    |                                        |\n    |                                        help: consider spelling out the type instead: `S<'a>`\n+   |\n+   = note: see issue #103532 <https://github.com/rust-lang/rust/issues/103532> for more information\n+   = help: add `#![feature(impl_trait_projections)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0760`.\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "a9fa2da569f85e08be827526537979842450d504", "filename": "src/test/ui/impl-trait/bound-normalization-fail.stderr", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fbound-normalization-fail.stderr?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -19,17 +19,20 @@ help: consider constraining the associated type `<T as impl_trait::Trait>::Assoc\n LL |     fn foo_fail<T: Trait<Assoc = ()>>() -> impl FooLike<Output = T::Assoc> {\n    |                         ++++++++++++\n \n-error[E0760]: `impl Trait` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n+error[E0658]: `impl Trait` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\n   --> $DIR/bound-normalization-fail.rs:41:41\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #103532 <https://github.com/rust-lang/rust/issues/103532> for more information\n+   = help: add `#![feature(impl_trait_projections)]` to the crate attributes to enable\n \n-error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n+error[E0271]: type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'a>>::Assoc`\n   --> $DIR/bound-normalization-fail.rs:41:41\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a>>() -> impl FooLike<Output = T::Assoc> {\n-   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'static>>::Assoc`\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type mismatch resolving `<Foo<()> as FooLike>::Output == <T as lifetimes::Trait<'a>>::Assoc`\n ...\n LL |         Foo(())\n    |         ------- return type was inferred to be `Foo<()>` here\n@@ -40,13 +43,13 @@ note: expected this to be `()`\n LL |     type Output = T;\n    |                   ^\n    = note:    expected unit type `()`\n-           found associated type `<T as lifetimes::Trait<'static>>::Assoc`\n-help: consider constraining the associated type `<T as lifetimes::Trait<'static>>::Assoc` to `()`\n+           found associated type `<T as lifetimes::Trait<'a>>::Assoc`\n+help: consider constraining the associated type `<T as lifetimes::Trait<'a>>::Assoc` to `()`\n    |\n LL |     fn foo2_fail<'a, T: Trait<'a, Assoc = ()>>() -> impl FooLike<Output = T::Assoc> {\n    |                                 ++++++++++++\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0271, E0760.\n+Some errors have detailed explanations: E0271, E0658.\n For more information about an error, try `rustc --explain E0271`."}, {"sha": "51877e9cc3c436287219d3fcb18b4a3ae2f84a48", "filename": "src/test/ui/impl-trait/feature-self-return-type.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fimpl-trait%2Ffeature-self-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fimpl-trait%2Ffeature-self-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ffeature-self-return-type.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -0,0 +1,102 @@\n+// edition:2018\n+#![feature(impl_trait_projections)]\n+\n+// This test checks that we emit the correct borrowck error when `Self` or a projection is used as\n+// a return type.  See #61949 for context.\n+\n+mod with_self {\n+    pub struct Foo<'a> {\n+        pub bar: &'a i32,\n+    }\n+\n+    impl<'a> Foo<'a> {\n+        pub fn new(_bar: &'a i32) -> impl Into<Self> {\n+            Foo {\n+                bar: &22\n+            }\n+        }\n+    }\n+\n+    fn foo() {\n+        let x = {\n+            let bar = 22;\n+            Foo::new(&bar).into()\n+            //~^ ERROR `bar` does not live long enough\n+        };\n+        drop(x);\n+    }\n+}\n+\n+struct Foo<T>(T);\n+\n+trait FooLike {\n+    type Output;\n+}\n+\n+impl<T> FooLike for Foo<T> {\n+    type Output = T;\n+}\n+\n+mod impl_trait {\n+    use super::*;\n+\n+    trait Trait {\n+        type Assoc;\n+\n+        fn make_assoc(self) -> Self::Assoc;\n+    }\n+\n+    /// `T::Assoc` can't be normalized any further here.\n+    fn foo<T: Trait>(x: T) -> impl FooLike<Output = T::Assoc> {\n+        Foo(x.make_assoc())\n+    }\n+\n+    impl<'a> Trait for &'a () {\n+        type Assoc = &'a ();\n+\n+        fn make_assoc(self) -> &'a () { &() }\n+    }\n+\n+    fn usage() {\n+        let x = {\n+            let y = ();\n+            foo(&y)\n+            //~^ ERROR `y` does not live long enough\n+        };\n+        drop(x);\n+    }\n+}\n+\n+// Same with lifetimes in the trait\n+\n+mod lifetimes {\n+    use super::*;\n+\n+    trait Trait<'a> {\n+        type Assoc;\n+\n+        fn make_assoc(self) -> Self::Assoc;\n+    }\n+\n+    /// Missing bound constraining `Assoc`, `T::Assoc` can't be normalized further.\n+    fn foo<'a, T: Trait<'a>>(x: T) -> impl FooLike<Output = T::Assoc> {\n+        Foo(x.make_assoc())\n+    }\n+\n+    impl<'a> Trait<'a> for &'a () {\n+        type Assoc = &'a ();\n+\n+        fn make_assoc(self) -> &'a () { &() }\n+    }\n+\n+    fn usage() {\n+        let x = {\n+            let y = ();\n+            foo(&y)\n+            //~^ ERROR `y` does not live long enough\n+        };\n+        drop(x);\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "601e53b7694596631c84c67ada9e54e958519058", "filename": "src/test/ui/impl-trait/feature-self-return-type.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fimpl-trait%2Ffeature-self-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fimpl-trait%2Ffeature-self-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ffeature-self-return-type.stderr?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -0,0 +1,39 @@\n+error[E0597]: `bar` does not live long enough\n+  --> $DIR/feature-self-return-type.rs:23:22\n+   |\n+LL |         let x = {\n+   |             - borrow later stored here\n+LL |             let bar = 22;\n+LL |             Foo::new(&bar).into()\n+   |                      ^^^^ borrowed value does not live long enough\n+LL |\n+LL |         };\n+   |         - `bar` dropped here while still borrowed\n+\n+error[E0597]: `y` does not live long enough\n+  --> $DIR/feature-self-return-type.rs:63:17\n+   |\n+LL |         let x = {\n+   |             - borrow later stored here\n+LL |             let y = ();\n+LL |             foo(&y)\n+   |                 ^^ borrowed value does not live long enough\n+LL |\n+LL |         };\n+   |         - `y` dropped here while still borrowed\n+\n+error[E0597]: `y` does not live long enough\n+  --> $DIR/feature-self-return-type.rs:95:17\n+   |\n+LL |         let x = {\n+   |             - borrow later stored here\n+LL |             let y = ();\n+LL |             foo(&y)\n+   |                 ^^ borrowed value does not live long enough\n+LL |\n+LL |         };\n+   |         - `y` dropped here while still borrowed\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "c19420bbb0cebbb9bdbe73668083807bb67abaab", "filename": "src/test/ui/impl-trait/impl-fn-predefined-lifetimes.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-fn-predefined-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-fn-predefined-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-fn-predefined-lifetimes.stderr?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -14,10 +14,7 @@ error[E0720]: cannot resolve opaque type\n   --> $DIR/impl-fn-predefined-lifetimes.rs:4:35\n    |\n LL | fn a<'a>() -> impl Fn(&'a u8) -> (impl Debug + '_) {\n-   |                                   ^^^^^^^^^^^^^^^ recursive opaque type\n-...\n-LL |     |x| x\n-   |     ----- returning here with type `[closure@$DIR/impl-fn-predefined-lifetimes.rs:7:5: 7:8]`\n+   |                                   ^^^^^^^^^^^^^^^ cannot resolve opaque type\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7b9ed171d2dbf88b0f2fbbcc931117731bb19436", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -1,4 +1,4 @@\n-error[E0700]: hidden type for `Opaque(DefId(0:13 ~ impl_trait_captures[1afc]::foo::{opaque#0}), [ReStatic, T, ReEarlyBound(0, 'a)])` captures lifetime that does not appear in bounds\n+error[E0700]: hidden type for `Opaque(DefId(0:13 ~ impl_trait_captures[1afc]::foo::{opaque#0}), [ReEarlyBound(0, 'a), T, ReEarlyBound(0, 'a)])` captures lifetime that does not appear in bounds\n   --> $DIR/impl-trait-captures.rs:11:5\n    |\n LL | fn foo<'a, T>(x: &T) -> impl Foo<'a> {"}, {"sha": "01d1f5db13265617269ef3374badd230b905295f", "filename": "src/test/ui/type-alias-impl-trait/missing_lifetime_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmissing_lifetime_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmissing_lifetime_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmissing_lifetime_bound.rs?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -2,6 +2,6 @@\n \n type Opaque<'a, T> = impl Sized;\n fn defining<'a, T>(x: &'a i32) -> Opaque<T> { x }\n-//~^ ERROR: non-defining opaque type use in defining scope\n+//~^ ERROR: hidden type for `Opaque<'a, T>` captures lifetime that does not appear in bounds\n \n fn main() {}"}, {"sha": "65a0af0d22fe8481cd610829ad02c2311a0a1507", "filename": "src/test/ui/type-alias-impl-trait/missing_lifetime_bound.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmissing_lifetime_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7fe6f36224e92db6fbde952e0b7e50863161f6ee/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmissing_lifetime_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fmissing_lifetime_bound.stderr?ref=7fe6f36224e92db6fbde952e0b7e50863161f6ee", "patch": "@@ -1,8 +1,11 @@\n-error: non-defining opaque type use in defining scope\n+error[E0700]: hidden type for `Opaque<'a, T>` captures lifetime that does not appear in bounds\n   --> $DIR/missing_lifetime_bound.rs:4:47\n    |\n LL | fn defining<'a, T>(x: &'a i32) -> Opaque<T> { x }\n-   |                                               ^ lifetime `'a` is part of concrete type but not used in parameter list of the `impl Trait` type alias\n+   |             --                                ^\n+   |             |\n+   |             hidden type `&'a i32` captures the lifetime `'a` as defined here\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0700`."}]}