{"sha": "5984e70af23e24710b2e18195361e4918cf2988f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ODRlNzBhZjIzZTI0NzEwYjJlMTgxOTUzNjFlNDkxOGNmMjk4OGY=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-13T00:52:31Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-20T17:24:00Z"}, "message": "Cleanups and fixes throughout", "tree": {"sha": "9ba3c1d215f5cc5a680a219879d35a4e941c1e3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ba3c1d215f5cc5a680a219879d35a4e941c1e3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5984e70af23e24710b2e18195361e4918cf2988f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5984e70af23e24710b2e18195361e4918cf2988f", "html_url": "https://github.com/rust-lang/rust/commit/5984e70af23e24710b2e18195361e4918cf2988f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5984e70af23e24710b2e18195361e4918cf2988f/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ceecd6250f31e614c5ae86165e70ce3f09dc9008", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceecd6250f31e614c5ae86165e70ce3f09dc9008", "html_url": "https://github.com/rust-lang/rust/commit/ceecd6250f31e614c5ae86165e70ce3f09dc9008"}], "stats": {"total": 245, "additions": 118, "deletions": 127}, "files": [{"sha": "acb50b5b83d24f55d3c4120238e1c6848eb06ccd", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5984e70af23e24710b2e18195361e4918cf2988f/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5984e70af23e24710b2e18195361e4918cf2988f/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=5984e70af23e24710b2e18195361e4918cf2988f", "patch": "@@ -602,7 +602,7 @@ impl<'a> Step<'a> for Compiletest<'a> {\n \n             builder.ensure(dist::DebuggerScripts {\n                 sysroot: &builder.sysroot(compiler),\n-                host: compiler.host\n+                target: target\n             });\n \n             if mode == \"debuginfo-gdb\" {\n@@ -1326,7 +1326,7 @@ impl<'a> Step<'a> for RemoteCopyLibs<'a> {\n         println!(\"REMOTE copy libs to emulator ({})\", target);\n         t!(fs::create_dir_all(build.out.join(\"tmp\")));\n \n-        let server = builder.ensure(tool::RemoteTestServer { compiler, target }));\n+        let server = builder.ensure(tool::RemoteTestServer { stage: compiler.stage, target });\n \n         // Spawn the emulator and wait for it to come online\n         let tool = builder.tool_exe(Tool::RemoteTestClient);\n@@ -1368,9 +1368,6 @@ impl<'a> Step<'a> for Distcheck {\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n \n-        builder.ensure(dist::PlainSourceTarball);\n-        builder.ensure(dist::Src);\n-\n         if build.build != \"x86_64-unknown-linux-gnu\" {\n             return\n         }\n@@ -1388,7 +1385,7 @@ impl<'a> Step<'a> for Distcheck {\n \n         let mut cmd = Command::new(\"tar\");\n         cmd.arg(\"-xzf\")\n-           .arg(dist::rust_src_location(build))\n+           .arg(builder.ensure(dist::PlainSourceTarball))\n            .arg(\"--strip-components=1\")\n            .current_dir(&dir);\n         build.run(&mut cmd);\n@@ -1408,7 +1405,7 @@ impl<'a> Step<'a> for Distcheck {\n \n         let mut cmd = Command::new(\"tar\");\n         cmd.arg(\"-xzf\")\n-           .arg(dist::rust_src_installer(build))\n+           .arg(builder.ensure(dist::Src))\n            .arg(\"--strip-components=1\")\n            .current_dir(&dir);\n         build.run(&mut cmd);"}, {"sha": "db2912e7e272b8f056619df0d3fb89f0145a14a5", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5984e70af23e24710b2e18195361e4918cf2988f/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5984e70af23e24710b2e18195361e4918cf2988f/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=5984e70af23e24710b2e18195361e4918cf2988f", "patch": "@@ -364,24 +364,21 @@ impl<'a> Step<'a> for StartupObjects<'a> {\n             return\n         }\n \n-        let compiler = builder.compiler(0, &build.build);\n-        let compiler_path = builder.rustc(compiler);\n         let src_dir = &build.src.join(\"src/rtstartup\");\n         let dst_dir = &build.native_dir(target).join(\"rtstartup\");\n         let sysroot_dir = &builder.sysroot_libdir(for_compiler, target);\n         t!(fs::create_dir_all(dst_dir));\n-        t!(fs::create_dir_all(sysroot_dir));\n \n         for file in &[\"rsbegin\", \"rsend\"] {\n             let src_file = &src_dir.join(file.to_string() + \".rs\");\n             let dst_file = &dst_dir.join(file.to_string() + \".o\");\n             if !up_to_date(src_file, dst_file) {\n-                let mut cmd = Command::new(&compiler_path);\n+                let mut cmd = Command::new(&build.initial_rustc);\n                 build.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n-                            .arg(\"--cfg\").arg(format!(\"stage{}\", compiler.stage))\n+                            .arg(\"--cfg\").arg(\"stage0\")\n                             .arg(\"--target\").arg(target)\n                             .arg(\"--emit=obj\")\n-                            .arg(\"--out-dir\").arg(dst_dir)\n+                            .arg(\"--o\").arg(dst_file)\n                             .arg(src_file));\n             }\n "}, {"sha": "c5d09869b2b3c6fc11b8e31cee994a8da0339a2b", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 90, "deletions": 109, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/5984e70af23e24710b2e18195361e4918cf2988f/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5984e70af23e24710b2e18195361e4918cf2988f/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=5984e70af23e24710b2e18195361e4918cf2988f", "patch": "@@ -74,11 +74,11 @@ fn rust_installer(builder: &Builder) -> Command {\n #[derive(Serialize)]\n pub struct Docs<'a> {\n     pub stage: u32,\n-    pub host: &'a str,\n+    pub target: &'a str,\n }\n \n impl<'a> Step<'a> for Docs<'a> {\n-    type Output = ();\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n \n@@ -89,33 +89,33 @@ impl<'a> Step<'a> for Docs<'a> {\n     fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n         builder.ensure(Docs {\n             stage: builder.top_stage,\n-            host: target,\n+            target: target,\n         });\n     }\n \n     /// Builds the `rust-docs` installer component.\n     ///\n-    /// Slurps up documentation from the `stage`'s `host`.\n-    fn run(self, builder: &Builder) {\n+    /// Slurps up documentation from the `stage`'s `target`.\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         let build = builder.build;\n         let stage = self.stage;\n-        let host = self.host;\n+        let target = self.target;\n \n         builder.default_doc(None);\n \n-        println!(\"Dist docs stage{} ({})\", stage, host);\n+        println!(\"Dist docs stage{} ({})\", stage, target);\n         if !build.config.docs {\n             println!(\"\\tskipping - docs disabled\");\n-            return\n+            return None;\n         }\n \n         let name = pkgname(build, \"rust-docs\");\n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n         let _ = fs::remove_dir_all(&image);\n \n         let dst = image.join(\"share/doc/rust/html\");\n         t!(fs::create_dir_all(&dst));\n-        let src = build.out.join(host).join(\"doc\");\n+        let src = build.out.join(target).join(\"doc\");\n         cp_r(&src, &dst);\n \n         let mut cmd = rust_installer(builder);\n@@ -126,7 +126,7 @@ impl<'a> Step<'a> for Docs<'a> {\n            .arg(\"--image-dir\").arg(&image)\n            .arg(\"--work-dir\").arg(&tmpdir(build))\n            .arg(\"--output-dir\").arg(&distdir(build))\n-           .arg(format!(\"--package-name={}-{}\", name, host))\n+           .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(\"--component-name=rust-docs\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--bulk-dirs=share/doc/rust/html\");\n@@ -135,11 +135,13 @@ impl<'a> Step<'a> for Docs<'a> {\n \n         // As part of this step, *also* copy the docs directory to a directory which\n         // buildbot typically uploads.\n-        if host == build.build {\n+        if target == build.build {\n             let dst = distdir(build).join(\"doc\").join(build.rust_package_vers());\n             t!(fs::create_dir_all(&dst));\n             cp_r(&src, &dst);\n         }\n+\n+        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n \n@@ -281,47 +283,45 @@ fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build:\n \n #[derive(Serialize)]\n pub struct Mingw<'a> {\n-    host: &'a str,\n+    target: &'a str,\n }\n \n impl<'a> Step<'a> for Mingw<'a> {\n-    type Output = ();\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n \n     fn should_run(_builder: &Builder, _path: &Path) -> bool {\n         false\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, _target: &str) {\n-        builder.ensure(Mingw {\n-            host: host,\n-        });\n+    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n+        builder.ensure(Mingw { target });\n     }\n \n     /// Build the `rust-mingw` installer component.\n     ///\n     /// This contains all the bits and pieces to run the MinGW Windows targets\n     /// without any extra installed software (e.g. we bundle gcc, libraries, etc).\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         let build = builder.build;\n-        let host = self.host;\n+        let target = self.target;\n \n-        if !host.contains(\"pc-windows-gnu\") {\n-            return;\n+        if !target.contains(\"pc-windows-gnu\") {\n+            return None;\n         }\n \n-        println!(\"Dist mingw ({})\", host);\n+        println!(\"Dist mingw ({})\", target);\n         let name = pkgname(build, \"rust-mingw\");\n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n         let _ = fs::remove_dir_all(&image);\n         t!(fs::create_dir_all(&image));\n \n         // The first argument is a \"temporary directory\" which is just\n         // thrown away (this contains the runtime DLLs included in the rustc package\n         // above) and the second argument is where to place all the MinGW components\n         // (which is what we want).\n-        make_win_dist(&tmpdir(build), &image, host, &build);\n+        make_win_dist(&tmpdir(build), &image, target, &build);\n \n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"generate\")\n@@ -331,11 +331,12 @@ impl<'a> Step<'a> for Mingw<'a> {\n            .arg(\"--image-dir\").arg(&image)\n            .arg(\"--work-dir\").arg(&tmpdir(build))\n            .arg(\"--output-dir\").arg(&distdir(build))\n-           .arg(format!(\"--package-name={}-{}\", name, host))\n+           .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(\"--component-name=rust-mingw\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n         t!(fs::remove_dir_all(&image));\n+        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n \n@@ -350,11 +351,11 @@ impl<'a> Step<'a> for Mingw<'a> {\n #[derive(Serialize)]\n pub struct Rustc<'a> {\n     pub stage: u32,\n-    pub host: &'a str,\n+    pub target: &'a str,\n }\n \n impl<'a> Step<'a> for Rustc<'a> {\n-    type Output = ();\n+    type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n@@ -363,27 +364,32 @@ impl<'a> Step<'a> for Rustc<'a> {\n         path.ends_with(\"src/librustc\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, _target: &str) {\n+    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n         builder.ensure(Rustc {\n             stage: builder.top_stage,\n-            host: host,\n+            target: target,\n         });\n     }\n \n     /// Creates the `rustc` installer component.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n         let stage = self.stage;\n-        let host = self.host;\n-        println!(\"Dist rustc stage{} ({})\", stage, host);\n+        let target = self.target;\n+\n+        let compiler = builder.ensure(compile::Assemble {\n+            target_compiler: builder.compiler(stage, &build.build),\n+        });\n+\n+        println!(\"Dist rustc stage{} ({})\", stage, target);\n         let name = pkgname(build, \"rustc\");\n-        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n         let _ = fs::remove_dir_all(&image);\n-        let overlay = tmpdir(build).join(format!(\"{}-{}-overlay\", name, host));\n+        let overlay = tmpdir(build).join(format!(\"{}-{}-overlay\", name, target));\n         let _ = fs::remove_dir_all(&overlay);\n \n         // Prepare the rustc \"image\", what will actually end up getting installed\n-        prepare_image(builder, stage, host, &image);\n+        prepare_image(builder, compiler, target, &image);\n \n         // Prepare the overlay which is part of the tarball but won't actually be\n         // installed\n@@ -408,8 +414,8 @@ impl<'a> Step<'a> for Rustc<'a> {\n         // anything requiring us to distribute a license, but it's likely the\n         // install will *also* include the rust-mingw package, which also needs\n         // licenses, so to be safe we just include it here in all MinGW packages.\n-        if host.contains(\"pc-windows-gnu\") {\n-            make_win_dist(&image, &tmpdir(build), host, build);\n+        if target.contains(\"pc-windows-gnu\") {\n+            make_win_dist(&image, &tmpdir(build), target, build);\n \n             let dst = image.join(\"share/doc\");\n             t!(fs::create_dir_all(&dst));\n@@ -426,17 +432,19 @@ impl<'a> Step<'a> for Rustc<'a> {\n            .arg(\"--work-dir\").arg(&tmpdir(build))\n            .arg(\"--output-dir\").arg(&distdir(build))\n            .arg(\"--non-installed-overlay\").arg(&overlay)\n-           .arg(format!(\"--package-name={}-{}\", name, host))\n+           .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(\"--component-name=rustc\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n         t!(fs::remove_dir_all(&image));\n         t!(fs::remove_dir_all(&overlay));\n \n-        fn prepare_image(builder: &Builder, stage: u32, host: &str, image: &Path) {\n+        return distdir(build).join(format!(\"{}-{}.tar.gz\", name, target));\n+\n+        fn prepare_image(builder: &Builder, compiler: Compiler, target: &str, image: &Path) {\n             let build = builder.build;\n-            let src = builder.sysroot(builder.compiler(stage, host));\n-            let libdir = libdir(host);\n+            let src = builder.sysroot(compiler);\n+            let libdir = libdir(target);\n \n             // Copy rustc/rustdoc binaries\n             t!(fs::create_dir_all(image.join(\"bin\")));\n@@ -461,7 +469,7 @@ impl<'a> Step<'a> for Rustc<'a> {\n             // Debugger scripts\n             builder.ensure(DebuggerScripts {\n                 sysroot: &image,\n-                host: host,\n+                target: target,\n             });\n \n             // Misc license info\n@@ -483,7 +491,7 @@ impl<'a> Step<'a> for Rustc<'a> {\n #[derive(Serialize)]\n pub struct DebuggerScripts<'a> {\n     pub sysroot: &'a Path,\n-    pub host: &'a str,\n+    pub target: &'a str,\n }\n \n impl<'a> Step<'a> for DebuggerScripts<'a> {\n@@ -493,25 +501,24 @@ impl<'a> Step<'a> for DebuggerScripts<'a> {\n         path.ends_with(\"src/etc/lldb_batchmode.py\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, _target: &str) {\n+    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n         builder.ensure(DebuggerScripts {\n-            // FIXME: builder.top_stage is likely wrong in some cases.\n             sysroot: &builder.sysroot(builder.compiler(builder.top_stage, host)),\n-            host: host,\n+            target: target,\n         });\n     }\n \n-    /// Copies debugger scripts for `host` into the `sysroot` specified.\n+    /// Copies debugger scripts for `target` into the `sysroot` specified.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n-        let host = self.host;\n+        let target = self.target;\n         let sysroot = self.sysroot;\n         let dst = sysroot.join(\"lib/rustlib/etc\");\n         t!(fs::create_dir_all(&dst));\n         let cp_debugger_script = |file: &str| {\n             install(&build.src.join(\"src/etc/\").join(file), &dst, 0o644);\n         };\n-        if host.contains(\"windows-msvc\") {\n+        if target.contains(\"windows-msvc\") {\n             // windbg debugger scripts\n             install(&build.src.join(\"src/etc/rust-windbg.cmd\"), &sysroot.join(\"bin\"),\n                 0o755);\n@@ -560,7 +567,7 @@ pub struct Std<'a> {\n }\n \n impl<'a> Step<'a> for Std<'a> {\n-    type Output = ();\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n \n@@ -575,7 +582,7 @@ impl<'a> Step<'a> for Std<'a> {\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n@@ -587,7 +594,7 @@ impl<'a> Step<'a> for Std<'a> {\n         // let's reduce redundant work by only producing archives from that host.\n         if compiler.host != build.build {\n             println!(\"\\tskipping, not a build host\");\n-            return\n+            return None;\n         }\n \n         // We want to package up as many target libraries as possible\n@@ -622,21 +629,10 @@ impl<'a> Step<'a> for Std<'a> {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n         t!(fs::remove_dir_all(&image));\n+        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n \n-/// The path to the complete rustc-src tarball\n-pub fn rust_src_location(build: &Build) -> PathBuf {\n-    let plain_name = format!(\"rustc-{}-src\", build.rust_package_vers());\n-    distdir(build).join(&format!(\"{}.tar.gz\", plain_name))\n-}\n-\n-/// The path to the rust-src component installer\n-pub fn rust_src_installer(build: &Build) -> PathBuf {\n-    let name = pkgname(build, \"rust-src\");\n-    distdir(build).join(&format!(\"{}.tar.gz\", name))\n-}\n-\n // rules.dist(\"dist-analysis\", \"analysis\")\n //      .default(build.config.extended)\n //      .dep(|s| s.name(\"dist-std\"))\n@@ -651,7 +647,7 @@ pub struct Analysis<'a> {\n }\n \n impl<'a> Step<'a> for Analysis<'a> {\n-    type Output = ();\n+    type Output = Option<PathBuf>;\n     const DEFAULT: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n \n@@ -670,7 +666,7 @@ impl<'a> Step<'a> for Analysis<'a> {\n     }\n \n     /// Creates a tarball of save-analysis metadata, if available.\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder) -> Option<PathBuf> {\n         let build = builder.build;\n         let compiler = self.compiler;\n         let target = self.target;\n@@ -679,7 +675,7 @@ impl<'a> Step<'a> for Analysis<'a> {\n \n         if compiler.host != build.build {\n             println!(\"\\tskipping, not a build host\");\n-            return;\n+            return None;\n         }\n \n         // Package save-analysis from stage1 if not doing a full bootstrap, as the\n@@ -715,6 +711,7 @@ impl<'a> Step<'a> for Analysis<'a> {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n         t!(fs::remove_dir_all(&image));\n+        Some(distdir(build).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n }\n \n@@ -770,7 +767,8 @@ fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_di\n pub struct Src;\n \n impl<'a> Step<'a> for Src {\n-    type Output = ();\n+    /// The output path of the src installer tarball\n+    type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n@@ -785,7 +783,7 @@ impl<'a> Step<'a> for Src {\n     }\n \n     /// Creates the `rust-src` installer component\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n         println!(\"Dist src\");\n \n@@ -848,6 +846,7 @@ impl<'a> Step<'a> for Src {\n         build.run(&mut cmd);\n \n         t!(fs::remove_dir_all(&image));\n+        distdir(build).join(&format!(\"{}.tar.gz\", name))\n     }\n }\n \n@@ -865,7 +864,8 @@ const CARGO_VENDOR_VERSION: &str = \"0.1.4\";\n pub struct PlainSourceTarball;\n \n impl<'a> Step<'a> for PlainSourceTarball {\n-    type Output = ();\n+    /// Produces the location of the tarball generated\n+    type Output = PathBuf;\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n     const ONLY_BUILD_TARGETS: bool = true;\n@@ -884,7 +884,7 @@ impl<'a> Step<'a> for PlainSourceTarball {\n     }\n \n     /// Creates the plain source tarball\n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n         println!(\"Create plain source tarball\");\n \n@@ -947,10 +947,11 @@ impl<'a> Step<'a> for PlainSourceTarball {\n         }\n \n         // Create plain source tarball\n-        let mut tarball = rust_src_location(build);\n+        let plain_name = format!(\"rustc-{}-src\", build.rust_package_vers());\n+        let mut tarball = distdir(build).join(&format!(\"{}.tar.gz\", plain_name));\n         tarball.set_extension(\"\"); // strip .gz\n         tarball.set_extension(\"\"); // strip .tar\n-        if let Some(dir) = tarball.parent() {\n+        if let Some(dir) = distdir(build).parent() {\n             t!(fs::create_dir_all(dir));\n         }\n         let mut cmd = rust_installer(builder);\n@@ -960,6 +961,7 @@ impl<'a> Step<'a> for PlainSourceTarball {\n            .arg(\"--work-dir=.\")\n            .current_dir(tmpdir(build));\n         build.run(&mut cmd);\n+        distdir(build).join(&format!(\"{}.tar.gz\", plain_name))\n     }\n }\n \n@@ -1016,7 +1018,7 @@ pub struct Cargo<'a> {\n }\n \n impl<'a> Step<'a> for Cargo<'a> {\n-    type Output = ();\n+    type Output = PathBuf;\n     const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -1031,7 +1033,7 @@ impl<'a> Step<'a> for Cargo<'a> {\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n@@ -1095,6 +1097,7 @@ impl<'a> Step<'a> for Cargo<'a> {\n            .arg(\"--component-name=cargo\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n+        distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n \n@@ -1111,7 +1114,7 @@ pub struct Rls<'a> {\n }\n \n impl<'a> Step<'a> for Rls<'a> {\n-    type Output = ();\n+    type Output = PathBuf;\n     const ONLY_BUILD_TARGETS: bool = true;\n     const ONLY_HOSTS: bool = true;\n \n@@ -1126,7 +1129,7 @@ impl<'a> Step<'a> for Rls<'a> {\n         });\n     }\n \n-    fn run(self, builder: &Builder) {\n+    fn run(self, builder: &Builder) -> PathBuf {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n@@ -1179,6 +1182,7 @@ impl<'a> Step<'a> for Rls<'a> {\n            .arg(\"--component-name=rls\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n         build.run(&mut cmd);\n+        distdir(build).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n }\n \n@@ -1229,38 +1233,15 @@ impl<'a> Step<'a> for Extended<'a> {\n         let target = self.target;\n         let compiler = builder.compiler(stage, &build.build);\n \n-        builder.ensure(Std { compiler, target });\n-        builder.ensure(Rustc { stage, host: target });\n-        builder.ensure(Mingw { host: target });\n-        builder.ensure(Docs { stage, host: target });\n-        builder.ensure(Cargo { stage, target });\n-        builder.ensure(Rls { stage, target });\n-        builder.ensure(Analysis { compiler, target });\n-\n         println!(\"Dist extended stage{} ({})\", stage, target);\n \n-        let dist = distdir(build);\n-        let rustc_installer = dist.join(format!(\"{}-{}.tar.gz\",\n-                                                pkgname(build, \"rustc\"),\n-                                                target));\n-        let cargo_installer = dist.join(format!(\"{}-{}.tar.gz\",\n-                                                pkgname(build, \"cargo\"),\n-                                                target));\n-        let rls_installer = dist.join(format!(\"{}-{}.tar.gz\",\n-                                                pkgname(build, \"rls\"),\n-                                                target));\n-        let analysis_installer = dist.join(format!(\"{}-{}.tar.gz\",\n-                                                    pkgname(build, \"rust-analysis\"),\n-                                                    target));\n-        let docs_installer = dist.join(format!(\"{}-{}.tar.gz\",\n-                                                pkgname(build, \"rust-docs\"),\n-                                                target));\n-        let mingw_installer = dist.join(format!(\"{}-{}.tar.gz\",\n-                                                pkgname(build, \"rust-mingw\"),\n-                                                target));\n-        let std_installer = dist.join(format!(\"{}-{}.tar.gz\",\n-                                                pkgname(build, \"rust-std\"),\n-                                                target));\n+        let rustc_installer = builder.ensure(Rustc { stage, target });\n+        let cargo_installer = builder.ensure(Cargo { stage, target });\n+        let rls_installer = builder.ensure(Rls { stage, target });\n+        let analysis_installer = builder.ensure(Analysis { compiler, target }).unwrap();\n+        let docs_installer = builder.ensure(Docs { stage, target }).unwrap();\n+        let mingw_installer = builder.ensure(Mingw { target });\n+        let std_installer = builder.ensure(Std { compiler, target }).unwrap();\n \n         let tmp = tmpdir(build);\n         let overlay = tmp.join(\"extended-overlay\");\n@@ -1282,7 +1263,7 @@ impl<'a> Step<'a> for Extended<'a> {\n         let mut tarballs = vec![rustc_installer, cargo_installer, rls_installer,\n                                 analysis_installer, docs_installer, std_installer];\n         if target.contains(\"pc-windows-gnu\") {\n-            tarballs.push(mingw_installer);\n+            tarballs.push(mingw_installer.unwrap());\n         }\n         let mut input_tarballs = tarballs[0].as_os_str().to_owned();\n         for tarball in &tarballs[1..] {"}, {"sha": "d12f93f7f6db10b3c563129b08ac35fc1bfe4f18", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5984e70af23e24710b2e18195361e4918cf2988f/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5984e70af23e24710b2e18195361e4918cf2988f/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=5984e70af23e24710b2e18195361e4918cf2988f", "patch": "@@ -222,6 +222,22 @@ pub struct TheBook<'a> {\n impl<'a> Step<'a> for TheBook<'a> {\n     type Output = ();\n \n+    fn should_run(_builder: &Builder, path: &Path) -> bool {\n+        path.ends_with(\"src/doc/book\")\n+    }\n+\n+    fn make_run(builder: &Builder, path: Option<&Path>, _host: &str, target: &str) {\n+        if path.is_none() && !builder.build.config.docs {\n+            // Not a default rule if docs are disabled.\n+            return;\n+        }\n+\n+        builder.ensure(TheBook {\n+            target,\n+            name: \"book\",\n+        });\n+    }\n+\n     /// Build the book and associated stuff.\n     ///\n     /// We need to build:"}, {"sha": "2f5d174bb3fb4bcc7ab1021f620d13f3c41b8bf6", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5984e70af23e24710b2e18195361e4918cf2988f/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5984e70af23e24710b2e18195361e4918cf2988f/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=5984e70af23e24710b2e18195361e4918cf2988f", "patch": "@@ -201,7 +201,7 @@ install!(\n     //      .dep(|s| s.name(\"dist-docs\"))\n     //      .run(move |s| install::Installer::new(build).install_docs(s.stage, s.target));\n     Docs, \"src/doc\", builder.build.config.docs, only_hosts: false, (self, builder), {\n-        builder.ensure(dist::Docs { stage: self.stage, host: self.host });\n+        builder.ensure(dist::Docs { stage: self.stage, target: self.target });\n         Installer::new(builder.build).install_docs(self.stage, self.target);\n     };\n     // rules.install(\"install-std\", \"src/libstd\")\n@@ -266,7 +266,7 @@ install!(\n     //      .dep(|s| s.name(\"dist-rustc\"))\n     //      .run(move |s| install::Installer::new(build).install_rustc(s.stage, s.target));\n     Rustc, \"src/librustc\", builder.build.config.extended, only_hosts: true, (self, builder), {\n-        builder.ensure(dist::Rustc { stage: self.stage, host: self.host });\n+        builder.ensure(dist::Rustc { stage: self.stage, target: self.target });\n         Installer::new(builder.build).install_rustc(self.stage, self.target);\n     };\n );"}, {"sha": "63404bcf500097807d713ac3e05c47aab1e89545", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5984e70af23e24710b2e18195361e4918cf2988f/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5984e70af23e24710b2e18195361e4918cf2988f/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=5984e70af23e24710b2e18195361e4918cf2988f", "patch": "@@ -253,7 +253,7 @@ tool!(\n \n #[derive(Serialize)]\n pub struct RemoteTestServer<'a> {\n-    pub compiler: Compiler<'a>,\n+    pub stage: u32,\n     pub target: &'a str,\n }\n \n@@ -264,9 +264,9 @@ impl<'a> Step<'a> for RemoteTestServer<'a> {\n         path.ends_with(\"src/tools/remote-test-server\")\n     }\n \n-    fn make_run(builder: &Builder, _path: Option<&Path>, host: &str, target: &str) {\n+    fn make_run(builder: &Builder, _path: Option<&Path>, _host: &str, target: &str) {\n         builder.ensure(RemoteTestServer {\n-            compiler: builder.compiler(builder.top_stage, host),\n+            stage: builder.top_stage,\n             target,\n         });\n     }"}]}