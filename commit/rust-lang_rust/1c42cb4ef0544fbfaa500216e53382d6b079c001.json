{"sha": "1c42cb4ef0544fbfaa500216e53382d6b079c001", "node_id": "C_kwDOAAsO6NoAKDFjNDJjYjRlZjA1NDRmYmZhYTUwMDIxNmU1MzM4MmQ2YjA3OWMwMDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-26T18:32:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-26T18:32:57Z"}, "message": "Auto merge of #110852 - matthiaskrgr:rollup-jz3eosr, r=matthiaskrgr\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #108760 (Add lint to deny diagnostics composed of static strings)\n - #109444 (Change tidy error message for TODOs)\n - #110419 (Spelling library)\n - #110550 (Suggest deref on comparison binop RHS even if type is not Copy)\n - #110641 (Add new rustdoc book chapter to describe in-doc settings)\n - #110798 (pass `unused_extern_crates` in `librustdoc::doctest::make_test`)\n - #110819 (simplify TrustedLen impls)\n - #110825 (diagnostics: add test case for already-solved issue)\n - #110835 (Make some region folders a little stricter.)\n - #110847 (rustdoc-json: Time serialization.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b5a83a2da88f666ea99a61dcb91a8c0a6fd29cef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b5a83a2da88f666ea99a61dcb91a8c0a6fd29cef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c42cb4ef0544fbfaa500216e53382d6b079c001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c42cb4ef0544fbfaa500216e53382d6b079c001", "html_url": "https://github.com/rust-lang/rust/commit/1c42cb4ef0544fbfaa500216e53382d6b079c001", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c42cb4ef0544fbfaa500216e53382d6b079c001/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c044d77a334609513f3b615e0763a40cc02424d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c044d77a334609513f3b615e0763a40cc02424d", "html_url": "https://github.com/rust-lang/rust/commit/9c044d77a334609513f3b615e0763a40cc02424d"}, {"sha": "63bccced0c96d52ff10ed35eb81abf712aaf7bc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/63bccced0c96d52ff10ed35eb81abf712aaf7bc1", "html_url": "https://github.com/rust-lang/rust/commit/63bccced0c96d52ff10ed35eb81abf712aaf7bc1"}], "stats": {"total": 1162, "additions": 833, "deletions": 329}, "files": [{"sha": "74049406426ed0bf97318d58249df61f4bdd4907", "filename": "compiler/rustc_builtin_macros/messages.ftl", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_builtin_macros%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fmessages.ftl?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -149,6 +149,25 @@ builtin_macros_format_pos_mismatch = {$n} positional {$n ->\n     [one] argument\n     *[more] arguments\n     } in format string, but {$desc}\n+\n builtin_macros_offset_of_expected_field = expected field\n \n builtin_macros_offset_of_expected_two_args = expected 2 arguments\n+\n+builtin_macros_test_case_non_item = `#[test_case]` attribute is only allowed on items\n+\n+builtin_macros_test_bad_fn = {$kind} functions cannot be used for tests\n+    .label = `{$kind}` because of this\n+\n+builtin_macros_asm_explicit_register_name = explicit register arguments cannot have names\n+\n+builtin_macros_asm_mutually_exclusive = the `{$opt1}` and `{$opt2}` options are mutually exclusive\n+\n+builtin_macros_asm_pure_combine = the `pure` option must be combined with either `nomem` or `readonly`\n+\n+builtin_macros_asm_pure_no_output = asm with the `pure` option must have at least one output\n+\n+builtin_macros_asm_modifier_invalid = asm template modifier must be a single character\n+\n+builtin_macros_test_runner_invalid = `test_runner` argument must be a path\n+builtin_macros_test_runner_nargs = `#![test_runner(..)]` accepts exactly 1 argument"}, {"sha": "bcdd58a090162f6cf5909637cd8d647a4ab93534", "filename": "compiler/rustc_builtin_macros/src/asm.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fasm.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -15,6 +15,8 @@ use rustc_span::{InnerSpan, Span};\n use rustc_target::asm::InlineAsmArch;\n use smallvec::smallvec;\n \n+use crate::errors;\n+\n pub struct AsmArgs {\n     pub templates: Vec<P<ast::Expr>>,\n     pub operands: Vec<(ast::InlineAsmOperand, Span)>,\n@@ -205,7 +207,7 @@ pub fn parse_asm_args<'a>(\n         // of the argument available.\n         if explicit_reg {\n             if name.is_some() {\n-                diag.struct_span_err(span, \"explicit register arguments cannot have names\").emit();\n+                diag.emit_err(errors::AsmExplicitRegisterName { span });\n             }\n             args.reg_args.insert(slot);\n         } else if let Some(name) = name {\n@@ -240,25 +242,19 @@ pub fn parse_asm_args<'a>(\n         && args.options.contains(ast::InlineAsmOptions::READONLY)\n     {\n         let spans = args.options_spans.clone();\n-        diag.struct_span_err(spans, \"the `nomem` and `readonly` options are mutually exclusive\")\n-            .emit();\n+        diag.emit_err(errors::AsmMutuallyExclusive { spans, opt1: \"nomem\", opt2: \"readonly\" });\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE)\n         && args.options.contains(ast::InlineAsmOptions::NORETURN)\n     {\n         let spans = args.options_spans.clone();\n-        diag.struct_span_err(spans, \"the `pure` and `noreturn` options are mutually exclusive\")\n-            .emit();\n+        diag.emit_err(errors::AsmMutuallyExclusive { spans, opt1: \"pure\", opt2: \"noreturn\" });\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE)\n         && !args.options.intersects(ast::InlineAsmOptions::NOMEM | ast::InlineAsmOptions::READONLY)\n     {\n         let spans = args.options_spans.clone();\n-        diag.struct_span_err(\n-            spans,\n-            \"the `pure` option must be combined with either `nomem` or `readonly`\",\n-        )\n-        .emit();\n+        diag.emit_err(errors::AsmPureCombine { spans });\n     }\n \n     let mut have_real_output = false;\n@@ -285,11 +281,7 @@ pub fn parse_asm_args<'a>(\n         }\n     }\n     if args.options.contains(ast::InlineAsmOptions::PURE) && !have_real_output {\n-        diag.struct_span_err(\n-            args.options_spans.clone(),\n-            \"asm with the `pure` option must have at least one output\",\n-        )\n-        .emit();\n+        diag.emit_err(errors::AsmPureNoOutput { spans: args.options_spans.clone() });\n     }\n     if args.options.contains(ast::InlineAsmOptions::NORETURN) && !outputs_sp.is_empty() {\n         let err = diag\n@@ -705,11 +697,7 @@ fn expand_preparsed_asm(ecx: &mut ExtCtxt<'_>, args: AsmArgs) -> Option<ast::Inl\n                             .ty_span\n                             .map(|sp| template_sp.from_inner(InnerSpan::new(sp.start, sp.end)))\n                             .unwrap_or(template_sp);\n-                        ecx.struct_span_err(\n-                            span,\n-                            \"asm template modifier must be a single character\",\n-                        )\n-                        .emit();\n+                        ecx.emit_err(errors::AsmModifierInvalid { span });\n                         modifier = None;\n                     }\n "}, {"sha": "b146988a3c2357a33e8914d51239ec1caae479e5", "filename": "compiler/rustc_builtin_macros/src/errors.rs", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ferrors.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -551,3 +551,71 @@ pub(crate) struct FormatPositionalMismatch {\n     #[subdiagnostic]\n     pub(crate) highlight: SingleLabelManySpans,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_test_case_non_item)]\n+pub(crate) struct TestCaseNonItem {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_test_bad_fn)]\n+pub(crate) struct TestBadFn {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+    #[label]\n+    pub(crate) cause: Span,\n+    pub(crate) kind: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_explicit_register_name)]\n+pub(crate) struct AsmExplicitRegisterName {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_mutually_exclusive)]\n+pub(crate) struct AsmMutuallyExclusive {\n+    #[primary_span]\n+    pub(crate) spans: Vec<Span>,\n+    pub(crate) opt1: &'static str,\n+    pub(crate) opt2: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_pure_combine)]\n+pub(crate) struct AsmPureCombine {\n+    #[primary_span]\n+    pub(crate) spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_pure_no_output)]\n+pub(crate) struct AsmPureNoOutput {\n+    #[primary_span]\n+    pub(crate) spans: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_asm_modifier_invalid)]\n+pub(crate) struct AsmModifierInvalid {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_test_runner_invalid)]\n+pub(crate) struct TestRunnerInvalid {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(builtin_macros_test_runner_nargs)]\n+pub(crate) struct TestRunnerNargs {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}"}, {"sha": "49ee276af4e6f2b13af83b7664d5370d4d185784", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n /// The expansion from a test function to the appropriate test struct for libtest\n /// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n use crate::util::{check_builtin_macro_attribute, warn_on_duplicate_attribute};\n@@ -40,12 +41,7 @@ pub fn expand_test_case(\n             unreachable!()\n         },\n         _ => {\n-            ecx.struct_span_err(\n-                anno_item.span(),\n-                \"`#[test_case]` attribute is only allowed on items\",\n-            )\n-            .emit();\n-\n+            ecx.emit_err(errors::TestCaseNonItem { span: anno_item.span() });\n             return vec![];\n         }\n     };\n@@ -533,15 +529,11 @@ fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n     match &i.kind {\n         ast::ItemKind::Fn(box ast::Fn { sig, generics, .. }) => {\n             if let ast::Unsafe::Yes(span) = sig.header.unsafety {\n-                sd.struct_span_err(i.span, \"unsafe functions cannot be used for tests\")\n-                    .span_label(span, \"`unsafe` because of this\")\n-                    .emit();\n+                sd.emit_err(errors::TestBadFn { span: i.span, cause: span, kind: \"unsafe\" });\n                 return false;\n             }\n             if let ast::Async::Yes { span, .. } = sig.header.asyncness {\n-                sd.struct_span_err(i.span, \"async functions cannot be used for tests\")\n-                    .span_label(span, \"`async` because of this\")\n-                    .emit();\n+                sd.emit_err(errors::TestBadFn { span: i.span, cause: span, kind: \"async\" });\n                 return false;\n             }\n "}, {"sha": "be4ba66c082aa9df702a450d58aac6452af43fc2", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -19,6 +19,8 @@ use tracing::debug;\n \n use std::{iter, mem};\n \n+use crate::errors;\n+\n #[derive(Clone)]\n struct Test {\n     span: Span,\n@@ -385,11 +387,11 @@ fn get_test_runner(sd: &rustc_errors::Handler, krate: &ast::Crate) -> Option<ast\n         [single] => match single.meta_item() {\n             Some(meta_item) if meta_item.is_word() => return Some(meta_item.path.clone()),\n             _ => {\n-                sd.struct_span_err(span, \"`test_runner` argument must be a path\").emit();\n+                sd.emit_err(errors::TestRunnerInvalid { span });\n             }\n         },\n         _ => {\n-            sd.struct_span_err(span, \"`#![test_runner(..)]` accepts exactly 1 argument\").emit();\n+            sd.emit_err(errors::TestRunnerNargs { span });\n         }\n     }\n     None"}, {"sha": "375fdec10075a39eab98cfb5f854a0b5a45737c8", "filename": "compiler/rustc_codegen_ssa/messages.ftl", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_codegen_ssa%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fmessages.ftl?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -291,3 +291,16 @@ codegen_ssa_invalid_monomorphization_unsupported_cast = invalid monomorphization\n codegen_ssa_invalid_monomorphization_unsupported_operation = invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`\n \n codegen_ssa_invalid_monomorphization_expected_vector_element_type = invalid monomorphization of `{$name}` intrinsic: expected element type `{$expected_element}` of vector type `{$vector_type}` to be a signed or unsigned integer type\n+\n+codegen_ssa_invalid_no_sanitize = invalid argument for `no_sanitize`\n+    .note = expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\n+\n+codegen_ssa_invalid_link_ordinal_nargs = incorrect number of arguments to `#[link_ordinal]`\n+    .note = the attribute requires exactly one argument\n+\n+codegen_ssa_illegal_link_ordinal_format = illegal ordinal format in `link_ordinal`\n+    .note = an unsuffixed integer value, e.g., `1`, is expected\n+\n+codegen_ssa_target_feature_safe_trait = `#[target_feature(..)]` cannot be applied to safe trait method\n+    .label = cannot be applied to safe trait method\n+    .label_def = not an `unsafe` function"}, {"sha": "5bd42622f2c33c459ca51d249edf119b030eaee1", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -14,6 +14,7 @@ use rustc_span::symbol::Ident;\n use rustc_span::{sym, Span};\n use rustc_target::spec::{abi, SanitizerSet};\n \n+use crate::errors;\n use crate::target_features::from_target_feature;\n use crate::{errors::ExpectedUsedSymbol, target_features::check_target_feature_trait_unsafe};\n \n@@ -334,10 +335,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, did: LocalDefId) -> CodegenFnAttrs {\n                                 codegen_fn_attrs.no_sanitize |= SanitizerSet::HWADDRESS\n                             }\n                             _ => {\n-                                tcx.sess\n-                                    .struct_span_err(item.span(), \"invalid argument for `no_sanitize`\")\n-                                    .note(\"expected one of: `address`, `cfi`, `hwaddress`, `kcfi`, `memory`, `memtag`, `shadow-call-stack`, or `thread`\")\n-                                    .emit();\n+                                tcx.sess.emit_err(errors::InvalidNoSanitize { span: item.span() });\n                             }\n                         }\n                     }\n@@ -608,10 +606,7 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n     let sole_meta_list = match meta_item_list {\n         Some([item]) => item.lit(),\n         Some(_) => {\n-            tcx.sess\n-                .struct_span_err(attr.span, \"incorrect number of arguments to `#[link_ordinal]`\")\n-                .note(\"the attribute requires exactly one argument\")\n-                .emit();\n+            tcx.sess.emit_err(errors::InvalidLinkOrdinalNargs { span: attr.span });\n             return None;\n         }\n         _ => None,\n@@ -642,10 +637,7 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n             None\n         }\n     } else {\n-        tcx.sess\n-            .struct_span_err(attr.span, \"illegal ordinal format in `link_ordinal`\")\n-            .note(\"an unsuffixed integer value, e.g., `1`, is expected\")\n-            .emit();\n+        tcx.sess.emit_err(errors::InvalidLinkOrdinalFormat { span: attr.span });\n         None\n     }\n }"}, {"sha": "cf4893b822651a77fdf2adcc07177b165505a8c8", "filename": "compiler/rustc_codegen_ssa/src/errors.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ferrors.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -981,3 +981,37 @@ impl IntoDiagnosticArg for ExpectedPointerMutability {\n         }\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_invalid_no_sanitize)]\n+#[note]\n+pub struct InvalidNoSanitize {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_invalid_link_ordinal_nargs)]\n+#[note]\n+pub struct InvalidLinkOrdinalNargs {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_illegal_link_ordinal_format)]\n+#[note]\n+pub struct InvalidLinkOrdinalFormat {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_ssa_target_feature_safe_trait)]\n+pub struct TargetFeatureSafeTrait {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(codegen_ssa_label_def)]\n+    pub def: Span,\n+}"}, {"sha": "a936b62dd4eba4a218cbab6924a016195835ce25", "filename": "compiler/rustc_codegen_ssa/src/target_features.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftarget_features.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -1,3 +1,4 @@\n+use crate::errors;\n use rustc_ast::ast;\n use rustc_attr::InstructionSetAttr;\n use rustc_data_structures::fx::FxHashMap;\n@@ -443,14 +444,10 @@ pub fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_s\n     if let DefKind::AssocFn = tcx.def_kind(id) {\n         let parent_id = tcx.local_parent(id);\n         if let DefKind::Trait | DefKind::Impl { of_trait: true } = tcx.def_kind(parent_id) {\n-            tcx.sess\n-                .struct_span_err(\n-                    attr_span,\n-                    \"`#[target_feature(..)]` cannot be applied to safe trait method\",\n-                )\n-                .span_label(attr_span, \"cannot be applied to safe trait method\")\n-                .span_label(tcx.def_span(id), \"not an `unsafe` function\")\n-                .emit();\n+            tcx.sess.emit_err(errors::TargetFeatureSafeTrait {\n+                span: attr_span,\n+                def: tcx.def_span(id),\n+            });\n         }\n     }\n }"}, {"sha": "70d2718b70639937e99ae0213de0589b62cae944", "filename": "compiler/rustc_expand/messages.ftl", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_expand%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_expand%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fmessages.ftl?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -136,3 +136,7 @@ expand_proc_macro_panicked =\n \n expand_proc_macro_derive_tokens =\n     proc-macro derive produced unparsable tokens\n+\n+expand_duplicate_matcher_binding = duplicate matcher binding\n+    .label = duplicate binding\n+    .label2 = previous binding"}, {"sha": "e3a0ae3570eb074c1a0a37cfaa67d507810c44c4", "filename": "compiler/rustc_expand/src/errors.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -397,3 +397,13 @@ pub struct ProcMacroDeriveTokens {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_duplicate_matcher_binding)]\n+pub struct DuplicateMatcherBinding {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(expand_label2)]\n+    pub prev: Span,\n+}"}, {"sha": "75b6396f0be383f4ebd11249820ebb6177b749bd", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -104,6 +104,7 @@\n //! Kleene operators under which a meta-variable is repeating is the concatenation of the stacks\n //! stored when entering a macro definition starting from the state in which the meta-variable is\n //! bound.\n+use crate::errors;\n use crate::mbe::{KleeneToken, TokenTree};\n \n use rustc_ast::token::{Delimiter, Token, TokenKind};\n@@ -281,10 +282,7 @@ fn check_binders(\n                 // Duplicate binders at the top-level macro definition are errors. The lint is only\n                 // for nested macro definitions.\n                 sess.span_diagnostic\n-                    .struct_span_err(span, \"duplicate matcher binding\")\n-                    .span_label(span, \"duplicate binding\")\n-                    .span_label(prev_info.span, \"previous binding\")\n-                    .emit();\n+                    .emit_err(errors::DuplicateMatcherBinding { span, prev: prev_info.span });\n                 *valid = false;\n             } else {\n                 binders.insert(name, BinderInfo { span, ops: ops.into() });"}, {"sha": "5d45d09797b0be0f6a20019ccbfce8eeeb642ae6", "filename": "compiler/rustc_hir_analysis/messages.ftl", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fmessages.ftl?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -262,3 +262,17 @@ hir_analysis_transparent_non_zero_sized_enum = the variant of a transparent {$de\n hir_analysis_transparent_non_zero_sized = transparent {$desc} needs at most one non-zero-sized field, but has {$field_count}\n     .label = needs at most one non-zero-sized field, but has {$field_count}\n     .labels = this field is non-zero-sized\n+\n+hir_analysis_too_large_static = extern static is too large for the current architecture\n+\n+hir_analysis_specialization_trait = implementing `rustc_specialization_trait` traits is unstable\n+    .help = add `#![feature(min_specialization)]` to the crate attributes to enable\n+\n+hir_analysis_closure_implicit_hrtb = implicit types in closure signatures are forbidden when `for<...>` is present\n+    .label = `for<...>` is here\n+\n+hir_analysis_const_specialize = cannot specialize on const impl with non-const impl\n+\n+hir_analysis_static_specialize = cannot specialize on `'static` lifetime\n+\n+hir_analysis_missing_tilde_const = missing `~const` qualifier for specialization"}, {"sha": "68e957f9d8e3af706aaae468783b51553bd9de30", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -170,9 +170,7 @@ fn check_static_inhabited(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n             if matches!(tcx.def_kind(def_id), DefKind::Static(_)\n                 if tcx.def_kind(tcx.local_parent(def_id)) == DefKind::ForeignMod) =>\n         {\n-            tcx.sess\n-                .struct_span_err(span, \"extern static is too large for the current architecture\")\n-                .emit();\n+            tcx.sess.emit_err(errors::TooLargeStatic { span });\n             return;\n         }\n         // Generic statics are rejected, but we still reach this case."}, {"sha": "aab005dacf3e29ced9980979ad9cfa46d6326d3e", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -1576,17 +1576,10 @@ impl<'tcx> TypeVisitor<TyCtxt<'tcx>> for ImplTraitInTraitFinder<'_, 'tcx> {\n             && let hir::OpaqueTyOrigin::FnReturn(source) | hir::OpaqueTyOrigin::AsyncFn(source) = opaque.origin\n             && source == self.fn_def_id\n         {\n-            let opaque_ty = tcx.fold_regions(unshifted_opaque_ty, |re, depth| {\n-                if let ty::ReLateBound(index, bv) = re.kind() {\n-                    if depth != ty::INNERMOST {\n-                        return tcx.mk_re_error_with_message(\n-                            DUMMY_SP,\n-                            \"we shouldn't walk non-predicate binders with `impl Trait`...\",\n-                        );\n-                    }\n-                    tcx.mk_re_late_bound(index.shifted_out_to_binder(self.depth), bv)\n-                } else {\n-                    re\n+            let opaque_ty = tcx.fold_regions(unshifted_opaque_ty, |re, _depth| {\n+                match re.kind() {\n+                    ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReError(_) => re,\n+                    r => bug!(\"unexpected region: {r:?}\"),\n                 }\n             });\n             for (bound, bound_span) in tcx"}, {"sha": "cd2ec2bef20f9fce53e382ae1d6ac11b7e18457e", "filename": "compiler/rustc_hir_analysis/src/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -5,6 +5,7 @@\n // done by the orphan and overlap modules. Then we build up various\n // mappings. That mapping code resides here.\n \n+use crate::errors;\n use rustc_errors::{error_code, struct_span_err};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n@@ -67,13 +68,7 @@ fn enforce_trait_manually_implementable(\n         tcx.trait_def(trait_def_id).specialization_kind\n     {\n         if !tcx.features().specialization && !tcx.features().min_specialization {\n-            tcx.sess\n-                .struct_span_err(\n-                    impl_header_span,\n-                    \"implementing `rustc_specialization_trait` traits is unstable\",\n-                )\n-                .help(\"add `#![feature(min_specialization)]` to the crate attributes to enable\")\n-                .emit();\n+            tcx.sess.emit_err(errors::SpecializationTrait { span: impl_header_span });\n             return;\n         }\n     }"}, {"sha": "41547dd2a754d356506cf3d9212c389db4750b5c", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -386,8 +386,10 @@ impl<'tcx> AstConv<'tcx> for ItemCtxt<'tcx> {\n \n     fn ct_infer(&self, ty: Ty<'tcx>, _: Option<&ty::GenericParamDef>, span: Span) -> Const<'tcx> {\n         let ty = self.tcx.fold_regions(ty, |r, _| match *r {\n-            ty::ReErased => self.tcx.lifetimes.re_static,\n-            _ => r,\n+            // This is never reached in practice. If it ever is reached,\n+            // `ReErased` should be changed to `ReStatic`, and any other region\n+            // left alone.\n+            r => bug!(\"unexpected region: {r:?}\"),\n         });\n         self.tcx().const_error_with_message(ty, span, \"bad placeholder constant\")\n     }"}, {"sha": "1c496f867a0630d7df5a3038fa4ed55d2dffea24", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -455,13 +455,9 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n                     .collect::<Vec<_>>();\n \n                 if !infer_spans.is_empty() {\n-                    self.tcx.sess\n-                        .struct_span_err(\n-                            infer_spans,\n-                            \"implicit types in closure signatures are forbidden when `for<...>` is present\",\n-                        )\n-                        .span_label(for_sp, \"`for<...>` is here\")\n-                        .emit();\n+                    self.tcx\n+                        .sess\n+                        .emit_err(errors::ClosureImplicitHrtb { spans: infer_spans, for_sp });\n                 }\n             }\n "}, {"sha": "f82169dee988e2914756a20154df2d590e8a8767", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -633,6 +633,7 @@ pub(crate) struct SIMDFFIHighlyExperimental {\n }\n \n #[derive(Diagnostic)]\n+\n pub enum ImplNotMarkedDefault {\n     #[diag(hir_analysis_impl_not_marked_default, code = \"E0520\")]\n     #[note]\n@@ -769,3 +770,48 @@ pub(crate) struct TransparentNonZeroSized<'a> {\n     pub field_count: usize,\n     pub desc: &'a str,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_too_large_static)]\n+pub(crate) struct TooLargeStatic {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_specialization_trait)]\n+#[help]\n+pub(crate) struct SpecializationTrait {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_closure_implicit_hrtb)]\n+pub(crate) struct ClosureImplicitHrtb {\n+    #[primary_span]\n+    pub spans: Vec<Span>,\n+    #[label]\n+    pub for_sp: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_const_specialize)]\n+pub(crate) struct ConstSpecialize {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_static_specialize)]\n+pub(crate) struct StaticSpecialize {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_analysis_missing_tilde_const)]\n+pub(crate) struct MissingTildeConst {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "56f456e55577e4ea22b960defd934924706bdc3b", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -65,8 +65,8 @@\n //! cause use after frees with purely safe code in the same way as specializing\n //! on traits with methods can.\n \n-use crate::constrained_generic_params as cgp;\n use crate::errors::SubstsOnOverriddenImpl;\n+use crate::{constrained_generic_params as cgp, errors};\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n@@ -137,9 +137,7 @@ fn check_constness(tcx: TyCtxt<'_>, impl1_def_id: LocalDefId, impl2_node: Node,\n \n     if let hir::Constness::Const = impl2_constness {\n         if let hir::Constness::NotConst = impl1_constness {\n-            tcx.sess\n-                .struct_span_err(span, \"cannot specialize on const impl with non-const impl\")\n-                .emit();\n+            tcx.sess.emit_err(errors::ConstSpecialize { span });\n         }\n     }\n }\n@@ -293,7 +291,7 @@ fn check_static_lifetimes<'tcx>(\n     span: Span,\n ) {\n     if tcx.any_free_region_meets(parent_substs, |r| r.is_static()) {\n-        tcx.sess.struct_span_err(span, \"cannot specialize on `'static` lifetime\").emit();\n+        tcx.sess.emit_err(errors::StaticSpecialize { span });\n     }\n }\n \n@@ -438,7 +436,7 @@ fn trait_predicates_eq<'tcx>(\n     // the one on the base.\n     match (trait_pred2.constness, trait_pred1.constness) {\n         (ty::BoundConstness::ConstIfConst, ty::BoundConstness::NotConst) => {\n-            tcx.sess.struct_span_err(span, \"missing `~const` qualifier for specialization\").emit();\n+            tcx.sess.emit_err(errors::MissingTildeConst { span });\n         }\n         _ => {}\n     }"}, {"sha": "603ea1440e9ca8d1f6927d289e445abfb80f8a68", "filename": "compiler/rustc_hir_typeck/messages.ftl", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_typeck%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fmessages.ftl?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -62,3 +62,16 @@ hir_typeck_fru_suggestion =\n         [NONE]{\"\"}\n         *[other] {\" \"}from `{$expr}`\n     }, separate the last named field with a comma\n+\n+hir_typeck_const_select_must_be_const = this argument must be a `const fn`\n+    .help = consult the documentation on `const_eval_select` for more information\n+\n+hir_typeck_const_select_must_be_fn = this argument must be a function item\n+    .note = expected a function item, found {$ty}\n+    .help = consult the documentation on `const_eval_select` for more information\n+\n+hir_typeck_union_pat_multiple_fields = union patterns should have exactly one field\n+hir_typeck_union_pat_dotdot = `..` cannot be used in union patterns\n+\n+hir_typeck_arg_mismatch_indeterminate = argument type mismatch was detected, but rustc had trouble determining where\n+    .note = we would appreciate a bug report: https://github.com/rust-lang/rust/issues/new"}, {"sha": "b8222820cf7a4086971261e24e815d4d953de5d1", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -1508,6 +1508,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // FIXME(compiler-errors): We can actually do this if the checked_ty is\n                         // `steps` layers of boxes, not just one, but this is easier and most likely.\n                         || (checked_ty.is_box() && steps == 1)\n+                        // We can always deref a binop that takes its arguments by ref.\n+                        || matches!(\n+                            self.tcx.hir().get_parent(expr.hir_id),\n+                            hir::Node::Expr(hir::Expr { kind: hir::ExprKind::Binary(op, ..), .. })\n+                                if !op.node.is_by_value()\n+                        )\n                     {\n                         let deref_kind = if checked_ty.is_box() {\n                             \"unboxing the value\""}, {"sha": "48c40d216034e00c56cda3a76fbdae8a6c942508", "filename": "compiler/rustc_hir_typeck/src/errors.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ferrors.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -228,3 +228,42 @@ impl HelpUseLatestEdition {\n         }\n     }\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_const_select_must_be_const)]\n+#[help]\n+pub struct ConstSelectMustBeConst {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_const_select_must_be_fn)]\n+#[note]\n+#[help]\n+pub struct ConstSelectMustBeFn<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_union_pat_multiple_fields)]\n+pub struct UnionPatMultipleFields {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_union_pat_dotdot)]\n+pub struct UnionPatDotDot {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(hir_typeck_arg_mismatch_indeterminate)]\n+pub struct ArgMismatchIndeterminate {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "f42c825d9e8b18030af7bd3afe53b4870816d5e3", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -2,8 +2,8 @@ use crate::coercion::CoerceMany;\n use crate::fn_ctxt::arg_matrix::{ArgMatrix, Compatibility, Error, ExpectedIdx, ProvidedIdx};\n use crate::gather_locals::Declaration;\n use crate::method::MethodCallee;\n-use crate::Expectation::*;\n use crate::TupleArgumentsFlag::*;\n+use crate::{errors, Expectation::*};\n use crate::{\n     struct_span_err, BreakableCtxt, Diverges, Expectation, FnCtxt, LocalTy, Needs, RawTy,\n     TupleArgumentsFlag,\n@@ -283,19 +283,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     if idx == 1 && !self.tcx.is_const_fn_raw(*def_id) {\n                         self.tcx\n                             .sess\n-                            .struct_span_err(provided_arg.span, \"this argument must be a `const fn`\")\n-                            .help(\"consult the documentation on `const_eval_select` for more information\")\n-                            .emit();\n+                            .emit_err(errors::ConstSelectMustBeConst { span: provided_arg.span });\n                     }\n                 } else {\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(provided_arg.span, \"this argument must be a function item\")\n-                        .note(format!(\"expected a function item, found {checked_ty}\"))\n-                        .help(\n-                            \"consult the documentation on `const_eval_select` for more information\",\n-                        )\n-                        .emit();\n+                    self.tcx.sess.emit_err(errors::ConstSelectMustBeFn {\n+                        span: provided_arg.span,\n+                        ty: checked_ty,\n+                    });\n                 }\n             }\n \n@@ -744,17 +738,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if cfg!(debug_assertions) {\n                 span_bug!(error_span, \"expected errors from argument matrix\");\n             } else {\n-                tcx.sess\n-                    .struct_span_err(\n-                        error_span,\n-                        \"argument type mismatch was detected, \\\n-                        but rustc had trouble determining where\",\n-                    )\n-                    .note(\n-                        \"we would appreciate a bug report: \\\n-                        https://github.com/rust-lang/rust/issues/new\",\n-                    )\n-                    .emit();\n+                tcx.sess.emit_err(errors::ArgMismatchIndeterminate { span: error_span });\n             }\n             return;\n         }"}, {"sha": "d69a16d45ae543ee441b5cf776c47e48f40b73ad", "filename": "compiler/rustc_hir_typeck/src/pat.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fpat.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -1,4 +1,4 @@\n-use crate::{FnCtxt, RawTy};\n+use crate::{errors, FnCtxt, RawTy};\n use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{\n@@ -1410,12 +1410,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Report an error if an incorrect number of fields was specified.\n         if adt.is_union() {\n             if fields.len() != 1 {\n-                tcx.sess\n-                    .struct_span_err(pat.span, \"union patterns should have exactly one field\")\n-                    .emit();\n+                tcx.sess.emit_err(errors::UnionPatMultipleFields { span: pat.span });\n             }\n             if has_rest_pat {\n-                tcx.sess.struct_span_err(pat.span, \"`..` cannot be used in union patterns\").emit();\n+                tcx.sess.emit_err(errors::UnionPatDotDot { span: pat.span });\n             }\n         } else if !unmentioned_fields.is_empty() {\n             let accessible_unmentioned_fields: Vec<_> = unmentioned_fields"}, {"sha": "3c6dbb466db7aec804d666fd4fe02a35a180640c", "filename": "compiler/rustc_lint/messages.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_lint%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_lint%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fmessages.ftl?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -99,6 +99,8 @@ lint_diag_out_of_impl =\n \n lint_untranslatable_diag = diagnostics should be created using translatable messages\n \n+lint_trivial_untranslatable_diag = diagnostic with static strings only\n+\n lint_bad_opt_access = {$msg}\n \n lint_cstring_ptr = getting the inner pointer of a temporary `CString`"}, {"sha": "595b50c4063ca206167bc14efa7d818b87fe1d58", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -4,6 +4,7 @@\n use crate::lints::{\n     BadOptAccessDiag, DefaultHashTypesDiag, DiagOutOfImpl, LintPassByHand, NonExistentDocKeyword,\n     QueryInstability, TyQualified, TykindDiag, TykindKind, UntranslatableDiag,\n+    UntranslatableDiagnosticTrivial,\n };\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n@@ -366,7 +367,15 @@ declare_tool_lint! {\n     report_in_external_macro: true\n }\n \n-declare_lint_pass!(Diagnostics => [ UNTRANSLATABLE_DIAGNOSTIC, DIAGNOSTIC_OUTSIDE_OF_IMPL ]);\n+declare_tool_lint! {\n+    /// The `untranslatable_diagnostic_trivial` lint detects diagnostics created using only static strings.\n+    pub rustc::UNTRANSLATABLE_DIAGNOSTIC_TRIVIAL,\n+    Deny,\n+    \"prevent creation of diagnostics which cannot be translated, which use only static strings\",\n+    report_in_external_macro: true\n+}\n+\n+declare_lint_pass!(Diagnostics => [ UNTRANSLATABLE_DIAGNOSTIC, DIAGNOSTIC_OUTSIDE_OF_IMPL, UNTRANSLATABLE_DIAGNOSTIC_TRIVIAL ]);\n \n impl LateLintPass<'_> for Diagnostics {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n@@ -423,6 +432,75 @@ impl LateLintPass<'_> for Diagnostics {\n     }\n }\n \n+impl EarlyLintPass for Diagnostics {\n+    #[allow(unused_must_use)]\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &ast::Stmt) {\n+        // Looking for a straight chain of method calls from 'struct_span_err' to 'emit'.\n+        let ast::StmtKind::Semi(expr) = &stmt.kind else {\n+            return;\n+        };\n+        let ast::ExprKind::MethodCall(meth) = &expr.kind else {\n+            return;\n+        };\n+        if meth.seg.ident.name != sym::emit || !meth.args.is_empty() {\n+            return;\n+        }\n+        let mut segments = vec![];\n+        let mut cur = &meth.receiver;\n+        let fake = &[].into();\n+        loop {\n+            match &cur.kind {\n+                ast::ExprKind::Call(func, args) => {\n+                    if let ast::ExprKind::Path(_, path) = &func.kind {\n+                        segments.push((path.segments.last().unwrap().ident.name, args))\n+                    }\n+                    break;\n+                }\n+                ast::ExprKind::MethodCall(method) => {\n+                    segments.push((method.seg.ident.name, &method.args));\n+                    cur = &method.receiver;\n+                }\n+                ast::ExprKind::MacCall(mac) => {\n+                    segments.push((mac.path.segments.last().unwrap().ident.name, fake));\n+                    break;\n+                }\n+                _ => {\n+                    break;\n+                }\n+            }\n+        }\n+        segments.reverse();\n+        if segments.is_empty() {\n+            return;\n+        }\n+        if segments[0].0.as_str() != \"struct_span_err\" {\n+            return;\n+        }\n+        if !segments.iter().all(|(name, args)| {\n+            let arg = match name.as_str() {\n+                \"struct_span_err\" | \"span_note\" | \"span_label\" | \"span_help\" => &args[1],\n+                \"note\" | \"help\" => &args[0],\n+                _ => {\n+                    return false;\n+                }\n+            };\n+            if let ast::ExprKind::Lit(lit) = arg.kind\n+                && let ast::token::LitKind::Str = lit.kind {\n+                    true\n+            } else {\n+                false\n+            }\n+        }) {\n+            return;\n+        }\n+        cx.emit_spanned_lint(\n+            UNTRANSLATABLE_DIAGNOSTIC_TRIVIAL,\n+            stmt.span,\n+            UntranslatableDiagnosticTrivial,\n+        );\n+    }\n+}\n+\n declare_tool_lint! {\n     /// The `bad_opt_access` lint detects accessing options by field instead of\n     /// the wrapper function."}, {"sha": "319eb2ea445ed3c93e8fede7cdf3fad7c0bb2738", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -518,6 +518,7 @@ fn register_internals(store: &mut LintStore) {\n     store.register_lints(&TyTyKind::get_lints());\n     store.register_late_pass(|_| Box::new(TyTyKind));\n     store.register_lints(&Diagnostics::get_lints());\n+    store.register_early_pass(|| Box::new(Diagnostics));\n     store.register_late_pass(|_| Box::new(Diagnostics));\n     store.register_lints(&BadOptAccess::get_lints());\n     store.register_late_pass(|_| Box::new(BadOptAccess));"}, {"sha": "848f6a9ecb532286cb1b7844a689c0901f7636e7", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -820,6 +820,10 @@ pub struct DiagOutOfImpl;\n #[diag(lint_untranslatable_diag)]\n pub struct UntranslatableDiag;\n \n+#[derive(LintDiagnostic)]\n+#[diag(lint_trivial_untranslatable_diag)]\n+pub struct UntranslatableDiagnosticTrivial;\n+\n #[derive(LintDiagnostic)]\n #[diag(lint_bad_opt_access)]\n pub struct BadOptAccessDiag<'a> {"}, {"sha": "d05d3e2d3dcf56811bfdfdb452f7f85f2e5a6fc7", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -829,7 +829,13 @@ impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for SubstFolder<'a, 'tcx> {\n                     None => region_param_out_of_range(data, self.substs),\n                 }\n             }\n-            _ => r,\n+            ty::ReLateBound(..)\n+            | ty::ReFree(_)\n+            | ty::ReStatic\n+            | ty::RePlaceholder(_)\n+            | ty::ReErased\n+            | ty::ReError(_) => r,\n+            ty::ReVar(_) => bug!(\"unexpected region: {r:?}\"),\n         }\n     }\n "}, {"sha": "d45fa90a11b086138acf9683ef1658bee66245d4", "filename": "compiler/rustc_parse/messages.ftl", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_parse%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_parse%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fmessages.ftl?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -742,3 +742,33 @@ parse_bad_return_type_notation_output =\n parse_bad_return_type_notation_dotdot =\n     return type notation uses `()` instead of `(..)` for elided arguments\n     .suggestion = remove the `..`\n+\n+parse_bad_assoc_type_bounds = bounds on associated types do not belong here\n+    .label = belongs in `where` clause\n+\n+parse_attr_after_generic = trailing attribute after generic parameter\n+    .label = attributes must go before parameters\n+\n+parse_attr_without_generics = attribute without generic parameters\n+    .label = attributes are only permitted when preceding parameters\n+\n+parse_where_generics = generic parameters on `where` clauses are reserved for future use\n+    .label = currently unsupported\n+\n+parse_generics_in_path = unexpected generic arguments in path\n+\n+parse_assoc_lifetime = associated lifetimes are not supported\n+    .label = the lifetime is given here\n+    .help = if you meant to specify a trait object, write `dyn Trait + 'lifetime`\n+\n+parse_tilde_const_lifetime = `~const` may only modify trait bounds, not lifetime bounds\n+\n+parse_maybe_lifetime = `?` may only modify trait bounds, not lifetime bounds\n+\n+parse_parenthesized_lifetime = parenthesized lifetime bounds are not supported\n+    .suggestion = remove the parentheses\n+\n+parse_const_bounds_missing_tilde = const bounds must start with `~`\n+    .suggestion = add `~`\n+\n+parse_underscore_literal_suffix = underscore literal suffix is not allowed"}, {"sha": "b0e1189851a1b7ac87d55456d88e8efe47aff16f", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -2332,3 +2332,92 @@ pub(crate) struct BadReturnTypeNotationDotDot {\n     #[suggestion(code = \"\", applicability = \"maybe-incorrect\")]\n     pub span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_bad_assoc_type_bounds)]\n+pub(crate) struct BadAssocTypeBounds {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_attr_after_generic)]\n+pub(crate) struct AttrAfterGeneric {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_attr_without_generics)]\n+pub(crate) struct AttrWithoutGenerics {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_where_generics)]\n+pub(crate) struct WhereOnGenerics {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_generics_in_path)]\n+pub(crate) struct GenericsInPath {\n+    #[primary_span]\n+    pub span: Vec<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_assoc_lifetime)]\n+#[help]\n+pub(crate) struct AssocLifetime {\n+    #[primary_span]\n+    pub span: Span,\n+    #[label]\n+    pub lifetime: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_tilde_const_lifetime)]\n+pub(crate) struct TildeConstLifetime {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_maybe_lifetime)]\n+pub(crate) struct MaybeLifetime {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_parenthesized_lifetime)]\n+pub(crate) struct ParenthesizedLifetime {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(style = \"short\", applicability = \"machine-applicable\", code = \"{snippet}\")]\n+    pub sugg: Option<Span>,\n+    pub snippet: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_const_bounds_missing_tilde)]\n+pub(crate) struct ConstMissingTilde {\n+    #[primary_span]\n+    pub span: Span,\n+    #[suggestion(code = \"~\", applicability = \"machine-applicable\")]\n+    pub start: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(parse_underscore_literal_suffix)]\n+pub(crate) struct UnderscoreLiteralSuffix {\n+    #[primary_span]\n+    pub span: Span,\n+}"}, {"sha": "a4a75fcb969957f10c1293e949aa5dd7d00c96bc", "filename": "compiler/rustc_parse/src/lexer/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Fmod.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -209,11 +209,7 @@ impl<'a> StringReader<'a> {\n                         if string == \"_\" {\n                             self.sess\n                                 .span_diagnostic\n-                                .struct_span_err(\n-                                    self.mk_sp(suffix_start, self.pos),\n-                                    \"underscore literal suffix is not allowed\",\n-                                )\n-                                .emit();\n+                                .emit_err(errors::UnderscoreLiteralSuffix { span: self.mk_sp(suffix_start, self.pos) });\n                             None\n                         } else {\n                             Some(Symbol::intern(string))"}, {"sha": "61a7ae93bfa8bbb997672e50936b266a5a68465c", "filename": "compiler/rustc_parse/src/parser/generics.rs", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fgenerics.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -1,5 +1,5 @@\n use crate::errors::{\n-    MultipleWhereClauses, UnexpectedDefaultValueForLifetimeInGenericParameters,\n+    self, MultipleWhereClauses, UnexpectedDefaultValueForLifetimeInGenericParameters,\n     UnexpectedSelfInGenericParameters, WhereClauseBeforeTupleStructBody,\n     WhereClauseBeforeTupleStructBodySugg,\n };\n@@ -181,12 +181,9 @@ impl<'a> Parser<'a> {\n                         let snapshot = this.create_snapshot_for_diagnostic();\n                         match this.parse_ty_where_predicate() {\n                             Ok(where_predicate) => {\n-                                this.struct_span_err(\n-                                    where_predicate.span(),\n-                                    \"bounds on associated types do not belong here\",\n-                                )\n-                                .span_label(where_predicate.span(), \"belongs in `where` clause\")\n-                                .emit();\n+                                this.sess.emit_err(errors::BadAssocTypeBounds {\n+                                    span: where_predicate.span(),\n+                                });\n                                 // FIXME - try to continue parsing other generics?\n                                 return Ok((None, TrailingToken::None));\n                             }\n@@ -201,22 +198,11 @@ impl<'a> Parser<'a> {\n                         // Check for trailing attributes and stop parsing.\n                         if !attrs.is_empty() {\n                             if !params.is_empty() {\n-                                this.struct_span_err(\n-                                    attrs[0].span,\n-                                    \"trailing attribute after generic parameter\",\n-                                )\n-                                .span_label(attrs[0].span, \"attributes must go before parameters\")\n-                                .emit();\n+                                this.sess\n+                                    .emit_err(errors::AttrAfterGeneric { span: attrs[0].span });\n                             } else {\n-                                this.struct_span_err(\n-                                    attrs[0].span,\n-                                    \"attribute without generic parameters\",\n-                                )\n-                                .span_label(\n-                                    attrs[0].span,\n-                                    \"attributes are only permitted when preceding parameters\",\n-                                )\n-                                .emit();\n+                                this.sess\n+                                    .emit_err(errors::AttrWithoutGenerics { span: attrs[0].span });\n                             }\n                         }\n                         return Ok((None, TrailingToken::None));\n@@ -304,12 +290,7 @@ impl<'a> Parser<'a> {\n         // change we parse those generics now, but report an error.\n         if self.choose_generics_over_qpath(0) {\n             let generics = self.parse_generics()?;\n-            self.struct_span_err(\n-                generics.span,\n-                \"generic parameters on `where` clauses are reserved for future use\",\n-            )\n-            .span_label(generics.span, \"currently unsupported\")\n-            .emit();\n+            self.sess.emit_err(errors::WhereOnGenerics { span: generics.span });\n         }\n \n         loop {"}, {"sha": "6cceb47ff83841c4d4853ac6c957a3b6af18310a", "filename": "compiler/rustc_parse/src/parser/path.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpath.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -150,16 +150,13 @@ impl<'a> Parser<'a> {\n             //\n             if style == PathStyle::Mod && path.segments.iter().any(|segment| segment.args.is_some())\n             {\n-                parser\n-                    .struct_span_err(\n-                        path.segments\n-                            .iter()\n-                            .filter_map(|segment| segment.args.as_ref())\n-                            .map(|arg| arg.span())\n-                            .collect::<Vec<_>>(),\n-                        \"unexpected generic arguments in path\",\n-                    )\n-                    .emit();\n+                let span = path\n+                    .segments\n+                    .iter()\n+                    .filter_map(|segment| segment.args.as_ref())\n+                    .map(|arg| arg.span())\n+                    .collect::<Vec<_>>();\n+                parser.sess.emit_err(errors::GenericsInPath { span });\n             }\n         };\n \n@@ -620,10 +617,7 @@ impl<'a> Parser<'a> {\n                 c.into()\n             }\n             Some(GenericArg::Lifetime(lt)) => {\n-                self.struct_span_err(span, \"associated lifetimes are not supported\")\n-                    .span_label(lt.ident.span, \"the lifetime is given here\")\n-                    .help(\"if you meant to specify a trait object, write `dyn Trait + 'lifetime`\")\n-                    .emit();\n+                self.sess.emit_err(errors::AssocLifetime { span, lifetime: lt.ident.span });\n                 self.mk_ty(span, ast::TyKind::Err).into()\n             }\n             None => {"}, {"sha": "f5f6788362ba916d79e72310912b59ee95bf9689", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -1,7 +1,7 @@\n use super::{Parser, PathStyle, TokenType};\n \n use crate::errors::{\n-    DynAfterMut, ExpectedFnPathFoundFnKeyword, ExpectedMutOrConstInRawPointerType,\n+    self, DynAfterMut, ExpectedFnPathFoundFnKeyword, ExpectedMutOrConstInRawPointerType,\n     FnPointerCannotBeAsync, FnPointerCannotBeConst, FnPtrWithGenerics, FnPtrWithGenericsSugg,\n     InvalidDynKeyword, LifetimeAfterMut, NeedPlusAfterTraitObjectLifetime,\n     NegativeBoundsNotSupported, NegativeBoundsNotSupportedSugg, NestedCVariadicType,\n@@ -807,36 +807,26 @@ impl<'a> Parser<'a> {\n     /// Emits an error if any trait bound modifiers were present.\n     fn error_lt_bound_with_modifiers(&self, modifiers: BoundModifiers) {\n         if let Some(span) = modifiers.maybe_const {\n-            self.struct_span_err(\n-                span,\n-                \"`~const` may only modify trait bounds, not lifetime bounds\",\n-            )\n-            .emit();\n+            self.sess.emit_err(errors::TildeConstLifetime { span });\n         }\n \n         if let Some(span) = modifiers.maybe {\n-            self.struct_span_err(span, \"`?` may only modify trait bounds, not lifetime bounds\")\n-                .emit();\n+            self.sess.emit_err(errors::MaybeLifetime { span });\n         }\n     }\n \n     /// Recover on `('lifetime)` with `(` already eaten.\n     fn recover_paren_lifetime(&mut self, lo: Span, inner_lo: Span) -> PResult<'a, ()> {\n         let inner_span = inner_lo.to(self.prev_token.span);\n         self.expect(&token::CloseDelim(Delimiter::Parenthesis))?;\n-        let mut err = self.struct_span_err(\n-            lo.to(self.prev_token.span),\n-            \"parenthesized lifetime bounds are not supported\",\n-        );\n-        if let Ok(snippet) = self.span_to_snippet(inner_span) {\n-            err.span_suggestion_short(\n-                lo.to(self.prev_token.span),\n-                \"remove the parentheses\",\n-                snippet,\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-        err.emit();\n+        let span = lo.to(self.prev_token.span);\n+        let (sugg, snippet) = if let Ok(snippet) = self.span_to_snippet(inner_span) {\n+            (Some(span), snippet)\n+        } else {\n+            (None, String::new())\n+        };\n+\n+        self.sess.emit_err(errors::ParenthesizedLifetime { span, sugg, snippet });\n         Ok(())\n     }\n \n@@ -857,15 +847,7 @@ impl<'a> Parser<'a> {\n         } else if self.eat_keyword(kw::Const) {\n             let span = self.prev_token.span;\n             self.sess.gated_spans.gate(sym::const_trait_impl, span);\n-\n-            self.struct_span_err(span, \"const bounds must start with `~`\")\n-                .span_suggestion(\n-                    span.shrink_to_lo(),\n-                    \"add `~`\",\n-                    \"~\",\n-                    Applicability::MachineApplicable,\n-                )\n-                .emit();\n+            self.sess.emit_err(errors::ConstMissingTilde { span, start: span.shrink_to_lo() });\n \n             Some(span)\n         } else {"}, {"sha": "32409499047cd315ca8190b22b7400101c283dec", "filename": "compiler/rustc_resolve/messages.ftl", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_resolve%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_resolve%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fmessages.ftl?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -226,3 +226,10 @@ resolve_add_as_non_derive =\n \n resolve_proc_macro_same_crate = can't use a procedural macro from the same crate that defines it\n     .help = you can define integration tests in a directory named `tests`\n+\n+resolve_imported_crate = `$crate` may not be imported\n+\n+resolve_macro_use_extern_crate_self = `#[macro_use]` is not supported on `extern crate self`\n+\n+resolve_accessible_unsure = not sure whether the path is accessible or not\n+    .note = the type may have associated items, but we are currently not checking them"}, {"sha": "3799679cb1eac162501bbddc00753a07c2634eaf", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -9,7 +9,9 @@ use crate::def_collector::collect_definitions;\n use crate::imports::{Import, ImportKind};\n use crate::macros::{MacroRulesBinding, MacroRulesScope, MacroRulesScopeRef};\n use crate::Namespace::{self, MacroNS, TypeNS, ValueNS};\n-use crate::{Determinacy, ExternPreludeEntry, Finalize, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{\n+    errors, Determinacy, ExternPreludeEntry, Finalize, Module, ModuleKind, ModuleOrUniformRoot,\n+};\n use crate::{\n     MacroData, NameBinding, NameBindingKind, ParentScope, PathResult, PerNS, ResolutionError,\n };\n@@ -523,11 +525,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                             ident.name = crate_name;\n                         }\n \n-                        self.r\n-                            .tcx\n-                            .sess\n-                            .struct_span_err(item.span, \"`$crate` may not be imported\")\n-                            .emit();\n+                        self.r.tcx.sess.emit_err(errors::CrateImported { span: item.span });\n                     }\n                 }\n \n@@ -1028,11 +1026,7 @@ impl<'a, 'b, 'tcx> BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n                         self.r\n                             .tcx\n                             .sess\n-                            .struct_span_err(\n-                                attr.span,\n-                                \"`#[macro_use]` is not supported on `extern crate self`\",\n-                            )\n-                            .emit();\n+                            .emit_err(errors::MacroUseExternCrateSelf { span: attr.span });\n                     }\n                 }\n                 let ill_formed = |span| {"}, {"sha": "4f9f1c7e85648a3326176882ed6789ec6699b551", "filename": "compiler/rustc_resolve/src/errors.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Ferrors.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -517,3 +517,25 @@ pub(crate) struct ProcMacroSameCrate {\n     #[help]\n     pub(crate) is_test: bool,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_imported_crate)]\n+pub(crate) struct CrateImported {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_macro_use_extern_crate_self)]\n+pub(crate) struct MacroUseExternCrateSelf {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(resolve_accessible_unsure)]\n+#[note]\n+pub(crate) struct CfgAccessibleUnsure {\n+    #[primary_span]\n+    pub(crate) span: Span,\n+}"}, {"sha": "b30c1cd226cb6efdf92899594c230558f04006cd", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -436,9 +436,7 @@ impl<'a, 'tcx> ResolverExpand for Resolver<'a, 'tcx> {\n                 // HACK(Urgau): This shouldn't be necessary\n                 PathResult::Failed { is_error_from_last_segment: false, .. } => {\n                     self.tcx.sess\n-                        .struct_span_err(span, \"not sure whether the path is accessible or not\")\n-                        .note(\"the type may have associated items, but we are currently not checking them\")\n-                        .emit();\n+                        .emit_err(errors::CfgAccessibleUnsure { span });\n \n                     // If we get a partially resolved NonModule in one namespace, we should get the\n                     // same result in any other namespaces, so we can return early."}, {"sha": "abf19c30e3deba5febfb3c59c10a6cbc1b7501df", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -651,6 +651,7 @@ symbols! {\n         edition_panic,\n         eh_catch_typeinfo,\n         eh_personality,\n+        emit,\n         emit_enum,\n         emit_enum_variant,\n         emit_enum_variant_arg,"}, {"sha": "996dc329dcb9b45622f5fbc8430c8ac9475f0a28", "filename": "compiler/rustc_trait_selection/src/solve/assembly/structural_traits.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fstructural_traits.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -91,14 +91,15 @@ pub(in crate::solve) fn replace_erased_lifetimes_with_bound_vars<'tcx>(\n ) -> ty::Binder<'tcx, Ty<'tcx>> {\n     debug_assert!(!ty.has_late_bound_regions());\n     let mut counter = 0;\n-    let ty = tcx.fold_regions(ty, |mut r, current_depth| {\n-        if let ty::ReErased = r.kind() {\n+    let ty = tcx.fold_regions(ty, |r, current_depth| match r.kind() {\n+        ty::ReErased => {\n             let br =\n                 ty::BoundRegion { var: ty::BoundVar::from_u32(counter), kind: ty::BrAnon(None) };\n             counter += 1;\n-            r = tcx.mk_re_late_bound(current_depth, br);\n+            tcx.mk_re_late_bound(current_depth, br)\n         }\n-        r\n+        // All free regions should be erased here.\n+        r => bug!(\"unexpected region: {r:?}\"),\n     });\n     let bound_vars = tcx.mk_bound_variable_kinds_from_iter(\n         (0..counter).map(|_| ty::BoundVariableKind::Region(ty::BrAnon(None))),"}, {"sha": "af61ca0c29f44e6c4ba9387420a018984701d9b7", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -3006,16 +3006,16 @@ fn bind_generator_hidden_types_above<'tcx>(\n \n             // Only remap erased regions if we use them.\n             if considering_regions {\n-                ty = tcx.fold_regions(ty, |mut r, current_depth| {\n-                    if let ty::ReErased = r.kind() {\n+                ty = tcx.fold_regions(ty, |r, current_depth| match r.kind() {\n+                    ty::ReErased => {\n                         let br = ty::BoundRegion {\n                             var: ty::BoundVar::from_u32(counter),\n                             kind: ty::BrAnon(None),\n                         };\n                         counter += 1;\n-                        r = tcx.mk_re_late_bound(current_depth, br);\n+                        tcx.mk_re_late_bound(current_depth, br)\n                     }\n-                    r\n+                    r => bug!(\"unexpected region: {r:?}\"),\n                 })\n             }\n "}, {"sha": "2708c7fe10259d83f5aa22db095d7a3dc250efbe", "filename": "library/alloc/src/collections/vec_deque/spec_from_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_from_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_from_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_from_iter.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -12,7 +12,7 @@ where\n     default fn spec_from_iter(iterator: I) -> Self {\n         // Since converting is O(1) now, just re-use the `Vec` logic for\n         // anything where we can't do something extra-special for `VecDeque`,\n-        // especially as that could save us some monomorphiziation work\n+        // especially as that could save us some monomorphization work\n         // if one uses the same iterators (like slice ones) with both.\n         crate::vec::Vec::from_iter(iterator).into()\n     }"}, {"sha": "8497740990443b1d5d1ee029c031fef6f31f91c3", "filename": "library/alloc/src/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Falloc%2Fsrc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Falloc%2Fsrc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstr.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -404,12 +404,12 @@ impl str {\n             // See https://www.unicode.org/versions/Unicode7.0.0/ch03.pdf#G33992\n             // for the definition of `Final_Sigma`.\n             debug_assert!('\u03a3'.len_utf8() == 2);\n-            let is_word_final = case_ignoreable_then_cased(from[..i].chars().rev())\n-                && !case_ignoreable_then_cased(from[i + 2..].chars());\n+            let is_word_final = case_ignorable_then_cased(from[..i].chars().rev())\n+                && !case_ignorable_then_cased(from[i + 2..].chars());\n             to.push_str(if is_word_final { \"\u03c2\" } else { \"\u03c3\" });\n         }\n \n-        fn case_ignoreable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {\n+        fn case_ignorable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {\n             use core::unicode::{Case_Ignorable, Cased};\n             match iter.skip_while(|&c| Case_Ignorable(c)).next() {\n                 Some(c) => Cased(c),"}, {"sha": "2f1ee8b03533da7dddd4d092efc74d9d38d66e63", "filename": "library/alloc/src/vec/in_place_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -201,7 +201,7 @@ where\n         //\n         // Note: This access to the source wouldn't be allowed by the TrustedRandomIteratorNoCoerce\n         // contract (used by SpecInPlaceCollect below). But see the \"O(1) collect\" section in the\n-        // module documenttation why this is ok anyway.\n+        // module documentation why this is ok anyway.\n         let dst_guard = InPlaceDstBufDrop { ptr: dst_buf, len, cap };\n         src.forget_allocation_drop_remaining();\n         mem::forget(dst_guard);"}, {"sha": "9aa5575ca938b83cdb00c154538ac17b646529c1", "filename": "library/alloc/tests/slice.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Falloc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Falloc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fslice.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -705,7 +705,7 @@ fn test_move_rev_iterator() {\n }\n \n #[test]\n-fn test_splitator() {\n+fn test_split_iterator() {\n     let xs = &[1, 2, 3, 4, 5];\n \n     let splits: &[&[_]] = &[&[1], &[3], &[5]];\n@@ -725,7 +725,7 @@ fn test_splitator() {\n }\n \n #[test]\n-fn test_splitator_inclusive() {\n+fn test_split_iterator_inclusive() {\n     let xs = &[1, 2, 3, 4, 5];\n \n     let splits: &[&[_]] = &[&[1, 2], &[3, 4], &[5]];\n@@ -745,7 +745,7 @@ fn test_splitator_inclusive() {\n }\n \n #[test]\n-fn test_splitator_inclusive_reverse() {\n+fn test_split_iterator_inclusive_reverse() {\n     let xs = &[1, 2, 3, 4, 5];\n \n     let splits: &[&[_]] = &[&[5], &[3, 4], &[1, 2]];\n@@ -765,7 +765,7 @@ fn test_splitator_inclusive_reverse() {\n }\n \n #[test]\n-fn test_splitator_mut_inclusive() {\n+fn test_split_iterator_mut_inclusive() {\n     let xs = &mut [1, 2, 3, 4, 5];\n \n     let splits: &[&[_]] = &[&[1, 2], &[3, 4], &[5]];\n@@ -785,7 +785,7 @@ fn test_splitator_mut_inclusive() {\n }\n \n #[test]\n-fn test_splitator_mut_inclusive_reverse() {\n+fn test_split_iterator_mut_inclusive_reverse() {\n     let xs = &mut [1, 2, 3, 4, 5];\n \n     let splits: &[&[_]] = &[&[5], &[3, 4], &[1, 2]];\n@@ -805,7 +805,7 @@ fn test_splitator_mut_inclusive_reverse() {\n }\n \n #[test]\n-fn test_splitnator() {\n+fn test_splitn_iterator() {\n     let xs = &[1, 2, 3, 4, 5];\n \n     let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n@@ -821,7 +821,7 @@ fn test_splitnator() {\n }\n \n #[test]\n-fn test_splitnator_mut() {\n+fn test_splitn_iterator_mut() {\n     let xs = &mut [1, 2, 3, 4, 5];\n \n     let splits: &[&mut [_]] = &[&mut [1, 2, 3, 4, 5]];\n@@ -837,7 +837,7 @@ fn test_splitnator_mut() {\n }\n \n #[test]\n-fn test_rsplitator() {\n+fn test_rsplit_iterator() {\n     let xs = &[1, 2, 3, 4, 5];\n \n     let splits: &[&[_]] = &[&[5], &[3], &[1]];\n@@ -855,7 +855,7 @@ fn test_rsplitator() {\n }\n \n #[test]\n-fn test_rsplitnator() {\n+fn test_rsplitn_iterator() {\n     let xs = &[1, 2, 3, 4, 5];\n \n     let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n@@ -932,7 +932,7 @@ fn test_split_iterators_size_hint() {\n }\n \n #[test]\n-fn test_windowsator() {\n+fn test_windows_iterator() {\n     let v = &[1, 2, 3, 4];\n \n     let wins: &[&[_]] = &[&[1, 2], &[2, 3], &[3, 4]];\n@@ -948,13 +948,13 @@ fn test_windowsator() {\n \n #[test]\n #[should_panic]\n-fn test_windowsator_0() {\n+fn test_windows_iterator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.windows(0);\n }\n \n #[test]\n-fn test_chunksator() {\n+fn test_chunks_iterator() {\n     let v = &[1, 2, 3, 4, 5];\n \n     assert_eq!(v.chunks(2).len(), 3);\n@@ -972,13 +972,13 @@ fn test_chunksator() {\n \n #[test]\n #[should_panic]\n-fn test_chunksator_0() {\n+fn test_chunks_iterator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.chunks(0);\n }\n \n #[test]\n-fn test_chunks_exactator() {\n+fn test_chunks_exact_iterator() {\n     let v = &[1, 2, 3, 4, 5];\n \n     assert_eq!(v.chunks_exact(2).len(), 2);\n@@ -996,13 +996,13 @@ fn test_chunks_exactator() {\n \n #[test]\n #[should_panic]\n-fn test_chunks_exactator_0() {\n+fn test_chunks_exact_iterator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.chunks_exact(0);\n }\n \n #[test]\n-fn test_rchunksator() {\n+fn test_rchunks_iterator() {\n     let v = &[1, 2, 3, 4, 5];\n \n     assert_eq!(v.rchunks(2).len(), 3);\n@@ -1020,13 +1020,13 @@ fn test_rchunksator() {\n \n #[test]\n #[should_panic]\n-fn test_rchunksator_0() {\n+fn test_rchunks_iterator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.rchunks(0);\n }\n \n #[test]\n-fn test_rchunks_exactator() {\n+fn test_rchunks_exact_iterator() {\n     let v = &[1, 2, 3, 4, 5];\n \n     assert_eq!(v.rchunks_exact(2).len(), 2);\n@@ -1044,7 +1044,7 @@ fn test_rchunks_exactator() {\n \n #[test]\n #[should_panic]\n-fn test_rchunks_exactator_0() {\n+fn test_rchunks_exact_iterator_0() {\n     let v = &[1, 2, 3, 4];\n     let _it = v.rchunks_exact(0);\n }\n@@ -1219,7 +1219,7 @@ fn test_ends_with() {\n }\n \n #[test]\n-fn test_mut_splitator() {\n+fn test_mut_split_iterator() {\n     let mut xs = [0, 1, 0, 2, 3, 0, 0, 4, 5, 0];\n     assert_eq!(xs.split_mut(|x| *x == 0).count(), 6);\n     for slice in xs.split_mut(|x| *x == 0) {\n@@ -1235,7 +1235,7 @@ fn test_mut_splitator() {\n }\n \n #[test]\n-fn test_mut_splitator_rev() {\n+fn test_mut_split_iterator_rev() {\n     let mut xs = [1, 2, 0, 3, 4, 0, 0, 5, 6, 0];\n     for slice in xs.split_mut(|x| *x == 0).rev().take(4) {\n         slice.reverse();"}, {"sha": "cc4c1f12728659941a5d8ded067bbd763d5cd8e6", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -2470,7 +2470,7 @@ fn test_vec_dedup_panicking() {\n \n // Regression test for issue #82533\n #[test]\n-fn test_extend_from_within_panicing_clone() {\n+fn test_extend_from_within_panicking_clone() {\n     struct Panic<'dc> {\n         drop_count: &'dc AtomicU32,\n         aaaaa: bool,"}, {"sha": "d1c6b67b2788138ff9c6854aaf7922ddfc10d2a0", "filename": "library/core/src/fmt/builders.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fbuilders.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -109,14 +109,14 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n     ///            .field(\"bar\", &self.bar) // We add `bar` field.\n     ///            .field(\"another\", &self.another) // We add `another` field.\n     ///            // We even add a field which doesn't exist (because why not?).\n-    ///            .field(\"not_existing_field\", &1)\n+    ///            .field(\"nonexistent_field\", &1)\n     ///            .finish() // We're good to go!\n     ///     }\n     /// }\n     ///\n     /// assert_eq!(\n     ///     format!(\"{:?}\", Bar { bar: 10, another: \"Hello World\".to_string() }),\n-    ///     \"Bar { bar: 10, another: \\\"Hello World\\\", not_existing_field: 1 }\",\n+    ///     \"Bar { bar: 10, another: \\\"Hello World\\\", nonexistent_field: 1 }\",\n     /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]"}, {"sha": "741f20cf4c7150edf3dd60bda99ac33b1954d510", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -2474,7 +2474,7 @@ extern \"rust-intrinsic\" {\n /// This macro should be called as `assert_unsafe_precondition!([Generics](name: Type) => Expression)`\n /// where the names specified will be moved into the macro as captured variables, and defines an item\n /// to call `const_eval_select` on. The tokens inside the square brackets are used to denote generics\n-/// for the function declaractions and can be omitted if there is no generics.\n+/// for the function declarations and can be omitted if there is no generics.\n ///\n /// # Safety\n ///\n@@ -2733,7 +2733,7 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n     // SAFETY: the safety contract for `copy` must be upheld by the caller.\n     unsafe {\n         assert_unsafe_precondition!(\n-            \"ptr::copy requires that both pointer arguments are aligned aligned and non-null\",\n+            \"ptr::copy requires that both pointer arguments are aligned and non-null\",\n             [T](src: *const T, dst: *mut T) =>\n             is_aligned_and_not_null(src) && is_aligned_and_not_null(dst)\n         );"}, {"sha": "7217e8f2a8ef694d73ef9901836896f66b23a85c", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -136,26 +136,12 @@ where\n }\n \n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<T, I, F, const N: usize> TrustedLen for FlatMap<I, [T; N], F>\n+unsafe impl<I, U, F> TrustedLen for FlatMap<I, U, F>\n where\n-    I: TrustedLen,\n-    F: FnMut(I::Item) -> [T; N],\n-{\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<'a, T, I, F, const N: usize> TrustedLen for FlatMap<I, &'a [T; N], F>\n-where\n-    I: TrustedLen,\n-    F: FnMut(I::Item) -> &'a [T; N],\n-{\n-}\n-\n-#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n-unsafe impl<'a, T, I, F, const N: usize> TrustedLen for FlatMap<I, &'a mut [T; N], F>\n-where\n-    I: TrustedLen,\n-    F: FnMut(I::Item) -> &'a mut [T; N],\n+    I: Iterator,\n+    U: IntoIterator,\n+    F: FnMut(I::Item) -> U,\n+    FlattenCompat<Map<I, F>, <U as IntoIterator>::IntoIter>: TrustedLen,\n {\n }\n \n@@ -298,8 +284,8 @@ where\n #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n unsafe impl<I> TrustedLen for Flatten<I>\n where\n-    I: TrustedLen,\n-    <I as Iterator>::Item: TrustedConstSize,\n+    I: Iterator<Item: IntoIterator>,\n+    FlattenCompat<I, <I::Item as IntoIterator>::IntoIter>: TrustedLen,\n {\n }\n \n@@ -660,6 +646,27 @@ where\n     }\n }\n \n+unsafe impl<const N: usize, I, T> TrustedLen\n+    for FlattenCompat<I, <[T; N] as IntoIterator>::IntoIter>\n+where\n+    I: TrustedLen<Item = [T; N]>,\n+{\n+}\n+\n+unsafe impl<'a, const N: usize, I, T> TrustedLen\n+    for FlattenCompat<I, <&'a [T; N] as IntoIterator>::IntoIter>\n+where\n+    I: TrustedLen<Item = &'a [T; N]>,\n+{\n+}\n+\n+unsafe impl<'a, const N: usize, I, T> TrustedLen\n+    for FlattenCompat<I, <&'a mut [T; N] as IntoIterator>::IntoIter>\n+where\n+    I: TrustedLen<Item = &'a mut [T; N]>,\n+{\n+}\n+\n trait ConstSizeIntoIterator: IntoIterator {\n     // FIXME(#31844): convert to an associated const once specialization supports that\n     fn size() -> Option<usize>;\n@@ -696,19 +703,6 @@ impl<T, const N: usize> ConstSizeIntoIterator for &mut [T; N] {\n     }\n }\n \n-#[doc(hidden)]\n-#[unstable(feature = \"std_internals\", issue = \"none\")]\n-// FIXME(#20400): Instead of this helper trait there should be multiple impl TrustedLen for Flatten<>\n-//   blocks with different bounds on Iterator::Item but the compiler erroneously considers them overlapping\n-pub unsafe trait TrustedConstSize: IntoIterator {}\n-\n-#[unstable(feature = \"std_internals\", issue = \"none\")]\n-unsafe impl<T, const N: usize> TrustedConstSize for [T; N] {}\n-#[unstable(feature = \"std_internals\", issue = \"none\")]\n-unsafe impl<T, const N: usize> TrustedConstSize for &'_ [T; N] {}\n-#[unstable(feature = \"std_internals\", issue = \"none\")]\n-unsafe impl<T, const N: usize> TrustedConstSize for &'_ mut [T; N] {}\n-\n #[inline]\n fn and_then_or_clear<T, U>(opt: &mut Option<T>, f: impl FnOnce(&mut T) -> Option<U>) -> Option<U> {\n     let x = f(opt.as_mut()?);"}, {"sha": "8b549e187ba81e3711e8cb0360cb1ebe4b08eaa5", "filename": "library/core/src/macros/panic.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Fmacros%2Fpanic.md", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Fmacros%2Fpanic.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fpanic.md?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -42,7 +42,7 @@ the successful result of some computation, `Ok(T)`, or error types that\n represent an anticipated runtime failure mode of that computation, `Err(E)`.\n `Result` is used alongside user defined types which represent the various\n anticipated runtime failure modes that the associated computation could\n-encounter. `Result` must be propagated manually, often with the the help of the\n+encounter. `Result` must be propagated manually, often with the help of the\n `?` operator and `Try` trait, and they must be reported manually, often with\n the help of the `Error` trait.\n "}, {"sha": "6b18f5f5a40d1e2acabce0fc357199d63291b9e6", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -264,7 +264,7 @@ impl<T: ?Sized> *const T {\n         let dest_addr = addr as isize;\n         let offset = dest_addr.wrapping_sub(self_addr);\n \n-        // This is the canonical desugarring of this operation\n+        // This is the canonical desugaring of this operation\n         self.wrapping_byte_offset(offset)\n     }\n "}, {"sha": "675bc8245d8d8360d59b17da1d7260987bba544f", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -2126,7 +2126,7 @@ mod new_fn_ptr_impl {\n /// assert_eq!(unsafe { raw_f2.read_unaligned() }, 2);\n /// ```\n ///\n-/// See [`addr_of_mut`] for how to create a pointer to unininitialized data.\n+/// See [`addr_of_mut`] for how to create a pointer to uninitialized data.\n /// Doing that with `addr_of` would not make much sense since one could only\n /// read the data, and that would be Undefined Behavior.\n #[stable(feature = \"raw_ref_macros\", since = \"1.51.0\")]"}, {"sha": "7b0fd02eb9f8bf49e99f27c0494fee3e2a117cd8", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -270,7 +270,7 @@ impl<T: ?Sized> *mut T {\n         let dest_addr = addr as isize;\n         let offset = dest_addr.wrapping_sub(self_addr);\n \n-        // This is the canonical desugarring of this operation\n+        // This is the canonical desugaring of this operation\n         self.wrapping_byte_offset(offset)\n     }\n "}, {"sha": "33a468a6bca5757735043f49d07b54029e8b5663", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -4451,7 +4451,7 @@ impl<T, const N: usize> SlicePattern for [T; N] {\n /// This will do `binomial(N + 1, 2) = N * (N + 1) / 2 = 0, 1, 3, 6, 10, ..`\n /// comparison operations.\n fn get_many_check_valid<const N: usize>(indices: &[usize; N], len: usize) -> bool {\n-    // NB: The optimzer should inline the loops into a sequence\n+    // NB: The optimizer should inline the loops into a sequence\n     // of instructions without additional branching.\n     let mut valid = true;\n     for (i, &idx) in indices.iter().enumerate() {"}, {"sha": "1d9670886eb3dce766b0fa3bda9c1ecf67b3d5af", "filename": "library/core/tests/asserting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Ftests%2Fasserting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Ftests%2Fasserting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fasserting.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -24,14 +24,14 @@ struct NoCopyNoDebug;\n struct NoDebug;\n \n test!(\n-    capture_with_non_copyable_and_non_debugabble_elem_has_correct_params,\n+    capture_with_non_copyable_and_non_debuggable_elem_has_correct_params,\n     NoCopyNoDebug,\n     None,\n     \"N/A\"\n );\n \n test!(capture_with_non_copyable_elem_has_correct_params, NoCopy, None, \"N/A\");\n \n-test!(capture_with_non_debugabble_elem_has_correct_params, NoDebug, None, \"N/A\");\n+test!(capture_with_non_debuggable_elem_has_correct_params, NoDebug, None, \"N/A\");\n \n-test!(capture_with_copyable_and_debugabble_elem_has_correct_params, 1i32, Some(1i32), \"1\");\n+test!(capture_with_copyable_and_debuggable_elem_has_correct_params, 1i32, Some(1i32), \"1\");"}, {"sha": "7f7f1f00588013c9aa569f73b3eca9a059dd2b53", "filename": "library/core/tests/lazy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Ftests%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Ftests%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flazy.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -10,7 +10,7 @@ fn once_cell() {\n     c.get_or_init(|| 92);\n     assert_eq!(c.get(), Some(&92));\n \n-    c.get_or_init(|| panic!(\"Kabom!\"));\n+    c.get_or_init(|| panic!(\"Kaboom!\"));\n     assert_eq!(c.get(), Some(&92));\n }\n "}, {"sha": "3e1f848ccfec2c4d8764751c61deca41abf3de9b", "filename": "library/core/tests/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fmod.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -170,7 +170,7 @@ fn test_can_not_overflow() {\n         for base in 2..=36 {\n             let num = (<$t>::MAX as u128) + 1;\n \n-           // Calcutate the string length for the smallest overflowing number:\n+           // Calculate the string length for the smallest overflowing number:\n            let max_len_string = format_radix(num, base as u128);\n            // Ensure that string length is deemed to potentially overflow:\n            assert!(can_overflow::<$t>(base, &max_len_string));"}, {"sha": "35a5291a34769ee3ec49e06d82ffed7b62aa43c2", "filename": "library/std/src/io/buffered/tests.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered%2Ftests.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -831,9 +831,9 @@ fn partial_line_buffered_after_line_write() {\n     assert_eq!(&writer.get_ref().buffer, b\"Line 1\\nLine 2\\nLine 3\");\n }\n \n-/// Test that, given a partial line that exceeds the length of\n-/// LineBuffer's buffer (that is, without a trailing newline), that that\n-/// line is written to the inner writer\n+/// Test that for calls to LineBuffer::write where the passed bytes do not contain\n+/// a newline and on their own are greater in length than the internal buffer, the\n+/// passed bytes are immediately written to the inner writer.\n #[test]\n fn long_line_flushed() {\n     let writer = ProgrammableSink::default();\n@@ -844,9 +844,10 @@ fn long_line_flushed() {\n }\n \n /// Test that, given a very long partial line *after* successfully\n-/// flushing a complete line, that that line is buffered unconditionally,\n-/// and no additional writes take place. This assures the property that\n-/// `write` should make at-most-one attempt to write new data.\n+/// flushing a complete line, the very long partial line is buffered\n+/// unconditionally, and no additional writes take place. This assures\n+/// the property that `write` should make at-most-one attempt to write\n+/// new data.\n #[test]\n fn line_long_tail_not_flushed() {\n     let writer = ProgrammableSink::default();"}, {"sha": "89a2f6b2271bda64410cfc8510e5b63cf5891d13", "filename": "library/std/src/io/readbuf/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Freadbuf%2Ftests.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -36,7 +36,7 @@ fn initialize_unfilled() {\n }\n \n #[test]\n-fn addvance_filled() {\n+fn advance_filled() {\n     let buf: &mut [_] = &mut [0; 16];\n     let mut rbuf: BorrowedBuf<'_> = buf.into();\n "}, {"sha": "be6dc7768af944b38ec47d5a3e4faba1549cb302", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -1925,7 +1925,7 @@ mod type_keyword {}\n /// `unsafe_op_in_unsafe_fn` lint can be enabled to warn against that and require explicit unsafe\n /// blocks even inside `unsafe fn`.\n ///\n-/// See the [Rustnomicon] and the [Reference] for more information.\n+/// See the [Rustonomicon] and the [Reference] for more information.\n ///\n /// # Examples\n ///\n@@ -2129,7 +2129,7 @@ mod type_keyword {}\n /// [`impl`]: keyword.impl.html\n /// [raw pointers]: ../reference/types/pointer.html\n /// [memory safety]: ../book/ch19-01-unsafe-rust.html\n-/// [Rustnomicon]: ../nomicon/index.html\n+/// [Rustonomicon]: ../nomicon/index.html\n /// [nomicon-soundness]: ../nomicon/safe-unsafe-meaning.html\n /// [soundness]: https://rust-lang.github.io/unsafe-code-guidelines/glossary.html#soundness-of-code--of-a-library\n /// [Reference]: ../reference/unsafety.html"}, {"sha": "11948cecad853a985a46fffc2ec5f6a45b5ccab3", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -450,7 +450,7 @@ impl AsHandle for OwnedHandle {\n     #[inline]\n     fn as_handle(&self) -> BorrowedHandle<'_> {\n         // Safety: `OwnedHandle` and `BorrowedHandle` have the same validity\n-        // invariants, and the `BorrowdHandle` is bounded by the lifetime\n+        // invariants, and the `BorrowedHandle` is bounded by the lifetime\n         // of `&self`.\n         unsafe { BorrowedHandle::borrow_raw(self.as_raw_handle()) }\n     }"}, {"sha": "b6bd0f9e12bd4f2a1cd9c6d944c0c012c5bf1e9a", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -260,7 +260,7 @@ impl AsSocket for OwnedSocket {\n     #[inline]\n     fn as_socket(&self) -> BorrowedSocket<'_> {\n         // Safety: `OwnedSocket` and `BorrowedSocket` have the same validity\n-        // invariants, and the `BorrowdSocket` is bounded by the lifetime\n+        // invariants, and the `BorrowedSocket` is bounded by the lifetime\n         // of `&self`.\n         unsafe { BorrowedSocket::borrow_raw(self.as_raw_socket()) }\n     }"}, {"sha": "d5d32e73d8880f7874a6dc3f6e06c7ceb04d0b59", "filename": "library/std/src/sync/once_lock/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce_lock%2Ftests.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -24,7 +24,7 @@ fn sync_once_cell() {\n         assert_eq!(ONCE_CELL.get(), Some(&92));\n     });\n \n-    ONCE_CELL.get_or_init(|| panic!(\"Kabom!\"));\n+    ONCE_CELL.get_or_init(|| panic!(\"Kaboom!\"));\n     assert_eq!(ONCE_CELL.get(), Some(&92));\n }\n "}, {"sha": "0ced48d10b7c627f1f392911fff27f2bc74c739a", "filename": "library/std/src/sync/remutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fsync%2Fremutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fsync%2Fremutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fremutex.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -7,7 +7,7 @@ use crate::panic::{RefUnwindSafe, UnwindSafe};\n use crate::sync::atomic::{AtomicUsize, Ordering::Relaxed};\n use crate::sys::locks as sys;\n \n-/// A re-entrant mutual exclusion\n+/// A reentrant mutual exclusion\n ///\n /// This mutex will block *other* threads waiting for the lock to become\n /// available. The thread which has already locked the mutex can lock it"}, {"sha": "ca79d1d796e9aee798ea9ada0fc3192edf442293", "filename": "library/std/src/sys/sgx/abi/entry.S", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fentry.S", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fentry.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fentry.S?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -58,15 +58,15 @@ IMAGE_BASE:\n     globvar DEBUG 1\n     /*  The base address (relative to enclave start) of the enclave text section */\n     globvar TEXT_BASE 8\n-    /*  The size in bytes of enclacve text section */\n+    /*  The size in bytes of enclave text section */\n     globvar TEXT_SIZE 8\n     /*  The base address (relative to enclave start) of the enclave .eh_frame_hdr section */\n     globvar EH_FRM_HDR_OFFSET 8\n     /*  The size in bytes of enclave .eh_frame_hdr section */\n     globvar EH_FRM_HDR_LEN 8\n     /*  The base address (relative to enclave start) of the enclave .eh_frame section */\n     globvar EH_FRM_OFFSET 8\n-    /*  The size in bytes of enclacve .eh_frame section */\n+    /*  The size in bytes of enclave .eh_frame section */\n     globvar EH_FRM_LEN 8\n \n .org .Lxsave_clear+512"}, {"sha": "612d43fe20414a1a1420275c0a40abe804214c2d", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -735,7 +735,7 @@ impl ExitStatus {\n         // true on all actual versions of Unix, is widely assumed, and is specified in SuS\n         // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html. If it is not\n         // true for a platform pretending to be Unix, the tests (our doctests, and also\n-        // procsss_unix/tests.rs) will spot it. `ExitStatusError::code` assumes this too.\n+        // process_unix/tests.rs) will spot it. `ExitStatusError::code` assumes this too.\n         match NonZero_c_int::try_from(self.0) {\n             /* was nonzero */ Ok(failure) => Err(ExitStatusError(failure)),\n             /* was zero, couldn't convert */ Err(_) => Ok(()),"}, {"sha": "c40e7ada03cbde7d8ecc8603765c75a60b19f668", "filename": "library/std/src/sys/unix/process/process_vxworks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_vxworks.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -199,7 +199,7 @@ impl ExitStatus {\n         // true on all actual versions of Unix, is widely assumed, and is specified in SuS\n         // https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html. If it is not\n         // true for a platform pretending to be Unix, the tests (our doctests, and also\n-        // procsss_unix/tests.rs) will spot it. `ExitStatusError::code` assumes this too.\n+        // process_unix/tests.rs) will spot it. `ExitStatusError::code` assumes this too.\n         match NonZero_c_int::try_from(self.0) {\n             Ok(failure) => Err(ExitStatusError(failure)),\n             Err(_) => Ok(()),"}, {"sha": "40e8e5a629e19c38fa81e05c0ff5ba97f5d70d10", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -494,7 +494,7 @@ impl Builder {\n                 MaybeDangling(mem::MaybeUninit::new(x))\n             }\n             fn into_inner(self) -> T {\n-                // SAFETY: we are always initiailized.\n+                // SAFETY: we are always initialized.\n                 let ret = unsafe { self.0.assume_init_read() };\n                 // Make sure we don't drop.\n                 mem::forget(self);\n@@ -503,7 +503,7 @@ impl Builder {\n         }\n         impl<T> Drop for MaybeDangling<T> {\n             fn drop(&mut self) {\n-                // SAFETY: we are always initiailized.\n+                // SAFETY: we are always initialized.\n                 unsafe { self.0.assume_init_drop() };\n             }\n         }"}, {"sha": "b512135d92770046f7739bea49c4e0bbb6aa3060", "filename": "src/doc/rustdoc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -3,6 +3,7 @@\n - [What is rustdoc?](what-is-rustdoc.md)\n - [Command-line arguments](command-line-arguments.md)\n - [How to read rustdoc output](how-to-read-rustdoc.md)\n+    - [In-doc settings](read-documentation/in-doc-settings.md)\n - [How to write documentation](how-to-write-documentation.md)\n     - [What to include (and exclude)](write-documentation/what-to-include.md)\n     - [The `#[doc]` attribute](write-documentation/the-doc-attribute.md)"}, {"sha": "ccd77fb17e9388d7e277c0de0939c4e99c0bfb89", "filename": "src/doc/rustdoc/src/how-to-read-rustdoc.md", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-read-rustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-read-rustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fhow-to-read-rustdoc.md?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -68,7 +68,7 @@ Typing in the search bar instantly searches the available documentation for\n the string entered with a fuzzy matching algorithm that is tolerant of minor\n typos.\n \n-By default, the search results give are \"In Names\",\n+By default, the search results given are \"In Names\",\n meaning that the fuzzy match is made against the names of items.\n Matching names are shown on the left, and the first few words of their\n descriptions are given on the right.\n@@ -105,11 +105,6 @@ will match these queries:\n \n But it *does not* match `Result<Vec, u8>` or `Result<u8<Vec>>`.\n \n-### Changing displayed theme\n-\n-You can change the displayed theme by opening the settings menu (the gear\n-icon in the upper right) and then pick a new one from there.\n-\n ### Shortcuts\n \n Pressing `S` while focused elsewhere on the page will move focus to the"}, {"sha": "c382870c64a659f945fdd76fdefd315db4eed709", "filename": "src/doc/rustdoc/src/images/collapsed-long-item.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Fdoc%2Frustdoc%2Fsrc%2Fimages%2Fcollapsed-long-item.png", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Fdoc%2Frustdoc%2Fsrc%2Fimages%2Fcollapsed-long-item.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fimages%2Fcollapsed-long-item.png?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001"}, {"sha": "f685656e09a9cc42b44545824bb37582e4e01226", "filename": "src/doc/rustdoc/src/images/collapsed-trait-impls.png", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Fdoc%2Frustdoc%2Fsrc%2Fimages%2Fcollapsed-trait-impls.png", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Fdoc%2Frustdoc%2Fsrc%2Fimages%2Fcollapsed-trait-impls.png", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fimages%2Fcollapsed-trait-impls.png?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001"}, {"sha": "12928a4f36926d9fdaf7d0d1eeb208fa2a0e7361", "filename": "src/doc/rustdoc/src/read-documentation/in-doc-settings.md", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Fdoc%2Frustdoc%2Fsrc%2Fread-documentation%2Fin-doc-settings.md", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Fdoc%2Frustdoc%2Fsrc%2Fread-documentation%2Fin-doc-settings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fread-documentation%2Fin-doc-settings.md?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -0,0 +1,64 @@\n+# Rustdoc in-doc settings\n+\n+Rustdoc's HTML output includes a settings menu, and this chapter describes what\n+each setting in this menu does.\n+\n+It can be accessed by clicking on the gear button\n+(<i class=\"fa fa-cog\" aria-hidden=\"true\"></i>) in the upper right.\n+\n+## Changing displayed theme\n+\n+It is possible to change the theme. If you pick the \"system preference\", you\n+will be able to see two new sub-menus: \"Preferred light theme\" and \"Preferred\n+dark theme\". It means that if your system preference is set to \"light\", then\n+rustdoc will use the theme you selected in \"Preferred light theme\".\n+\n+## Auto-hide item contents for large items\n+\n+If the type definition contains more than 12 items, and this setting is enabled,\n+it'll collapse them by default. You can see them by clicking on the `[+]` button\n+to expand them.\n+\n+A good example of this setting in use can be seen in the\n+[`Iterator`](https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html) doc\n+page:\n+\n+![Collapsed long item](../images/collapsed-long-item.png)\n+\n+## Auto-hide item methods' documentation\n+\n+If enabled, this setting will collapse all trait implementations blocks. It is\n+convenient if you just want an overview of all the methods available. You can\n+still see a method's documentation by expanding it.\n+\n+## Auto-hide trait implementation documentation\n+\n+If enabled, this setting will collapse all trait implementations blocks (you can\n+see them in the \"Trait Implementations\" section). It is convenient if you just\n+want an overview of all the trait implemented on a type. You can still see\n+a trait implementation's associated items by expanding it.\n+\n+Example:\n+\n+![Collapsed trait implementations](../images/collapsed-trait-impls.png)\n+\n+## Directly go to item in search if there is only one result\n+\n+If this setting is enabled, you will directly be taken to the result page if\n+your search only returned one element. Useful if you know exactly what you're\n+looking for and want to be taken there directly and not waste time selecting the\n+only search result.\n+\n+## Show line numbers on code examples\n+\n+If enabled, this setting will add line numbers to the code examples in the\n+documentation. It provides a visual aide for the code reading.\n+\n+## Disable keyboard shortcuts\n+\n+If this setting is enabled, the keyboard shortcuts will be disabled. It's useful\n+in case some of these shortcuts are already used by a web extension you're\n+using.\n+\n+To see the full list of the rustdoc keyboard shortcuts, you can open the help\n+menu (the button with the question mark on the left of the setting menu button)."}, {"sha": "1b622905e1adb51fc38c29f297c27fd78e56e0f6", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -741,8 +741,10 @@ impl<'a, 'tcx> TypeFolder<TyCtxt<'tcx>> for RegionReplacer<'a, 'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n+            // These are the regions that can be seen in the AST.\n             ty::ReVar(vid) => self.vid_to_region.get(&vid).cloned().unwrap_or(r),\n-            _ => r,\n+            ty::ReEarlyBound(_) | ty::ReStatic | ty::ReLateBound(..) | ty::ReError(_) => r,\n+            r => bug!(\"unexpected region: {r:?}\"),\n         }\n     }\n }"}, {"sha": "d71098ad89da06f70b8ca05eb41dc32ab1e0e3db", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -679,6 +679,10 @@ pub(crate) fn make_test(\n             // parse the source, but only has false positives, not false\n             // negatives.\n             if s.contains(crate_name) {\n+                // rustdoc implicitly inserts an `extern crate` item for the own crate\n+                // which may be unused, so we need to allow the lint.\n+                prog.push_str(&format!(\"#[allow(unused_extern_crates)]\\n\"));\n+\n                 prog.push_str(&format!(\"extern crate r#{crate_name};\\n\"));\n                 line_offset += 1;\n             }"}, {"sha": "a30fe28f94f99a674579e1a1b7e9dc395a5c7cdf", "filename": "src/librustdoc/doctest/tests.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Flibrustdoc%2Fdoctest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Flibrustdoc%2Fdoctest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest%2Ftests.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -38,6 +38,7 @@ fn make_test_crate_name() {\n     let input = \"use asdf::qwop;\n assert_eq!(2+2, 4);\";\n     let expected = \"#![allow(unused)]\n+#[allow(unused_extern_crates)]\n extern crate r#asdf;\n fn main() {\n use asdf::qwop;\n@@ -128,6 +129,7 @@ fn make_test_opts_attrs() {\n     let input = \"use asdf::qwop;\n assert_eq!(2+2, 4);\";\n     let expected = \"#![feature(sick_rad)]\n+#[allow(unused_extern_crates)]\n extern crate r#asdf;\n fn main() {\n use asdf::qwop;\n@@ -141,6 +143,7 @@ assert_eq!(2+2, 4);\n     opts.attrs.push(\"feature(hella_dope)\".to_string());\n     let expected = \"#![feature(sick_rad)]\n #![feature(hella_dope)]\n+#[allow(unused_extern_crates)]\n extern crate r#asdf;\n fn main() {\n use asdf::qwop;\n@@ -236,6 +239,7 @@ assert_eq!(asdf::foo, 4);\";\n \n     let expected = \"#![allow(unused)]\n extern crate hella_qwop;\n+#[allow(unused_extern_crates)]\n extern crate r#asdf;\n fn main() {\n assert_eq!(asdf::foo, 4);"}, {"sha": "9392dd4d08825fa511b68bcce9aadf156917f893", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -279,7 +279,10 @@ impl<'tcx> FormatRenderer<'tcx> for JsonRenderer<'tcx> {\n         p.push(output.index.get(&output.root).unwrap().name.clone().unwrap());\n         p.set_extension(\"json\");\n         let mut file = BufWriter::new(try_err!(File::create(&p), p));\n-        serde_json::ser::to_writer(&mut file, &output).unwrap();\n+        self.tcx\n+            .sess\n+            .time(\"rustdoc_json_serialization\", || serde_json::ser::to_writer(&mut file, &output))\n+            .unwrap();\n         try_err!(file.flush(), p);\n \n         Ok(())"}, {"sha": "5f388ee47bbdb9d98a647c5af42f03eb59b06948", "filename": "src/tools/tidy/src/style.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fstyle.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -385,10 +385,12 @@ pub fn check(path: &Path, bad: &mut bool) {\n             }\n             if filename != \"style.rs\" {\n                 if trimmed.contains(\"TODO\") {\n-                    err(\"TODO is deprecated; use FIXME\")\n+                    err(\n+                        \"TODO is used for tasks that should be done before merging a PR; If you want to leave a message in the codebase use FIXME\",\n+                    )\n                 }\n                 if trimmed.contains(\"//\") && trimmed.contains(\" XXX\") {\n-                    err(\"XXX is deprecated; use FIXME\")\n+                    err(\"Instead of XXX use FIXME\")\n                 }\n                 if any_problematic_line {\n                     for s in problematic_consts_strings.iter() {"}, {"sha": "2542ed657c1a78ed94ab56ba1889cd95b29da5f8", "filename": "tests/rustdoc/playground-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/tests%2Frustdoc%2Fplayground-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/tests%2Frustdoc%2Fplayground-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fplayground-arg.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -10,4 +10,4 @@\n pub fn dummy() {}\n \n // ensure that `extern crate foo;` was inserted into code snips automatically:\n-// @matches foo/index.html '//a[@class=\"test-arrow\"][@href=\"https://example.com/?code=%23!%5Ballow(unused)%5D%0Aextern+crate+r%23foo;%0Afn+main()+%7B%0Ause+foo::dummy;%0Adummy();%0A%7D&edition=2015\"]' \"Run\"\n+// @matches foo/index.html '//a[@class=\"test-arrow\"][@href=\"https://example.com/?code=%23!%5Ballow(unused)%5D%0A%23%5Ballow(unused_extern_crates)%5D%0Aextern+crate+r%23foo;%0Afn+main()+%7B%0Ause+foo::dummy;%0Adummy();%0A%7D&edition=2015\"]' \"Run\""}, {"sha": "dc39cc9dbffb00538de542553c67dfd69fa6a62c", "filename": "tests/ui/inference/deref-suggestion.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/tests%2Fui%2Finference%2Fderef-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/tests%2Fui%2Finference%2Fderef-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Fderef-suggestion.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -72,4 +72,13 @@ fn main() {\n     } else {\n         &0\n     };\n+\n+    #[derive(PartialEq, Eq)]\n+    struct Foo;\n+    let foo = Foo;\n+    let bar = &Foo;\n+\n+    if foo == bar {\n+    //~^ ERROR mismatched types\n+    }\n }"}, {"sha": "6f5aacacfc1f183ef08b07df665af870013dd602", "filename": "tests/ui/inference/deref-suggestion.stderr", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/tests%2Fui%2Finference%2Fderef-suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/tests%2Fui%2Finference%2Fderef-suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Fderef-suggestion.stderr?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -175,6 +175,19 @@ LL | ||     };\n    |  |_____`if` and `else` have incompatible types\n    |        expected `i32`, found `&{integer}`\n \n-error: aborting due to 13 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/deref-suggestion.rs:81:15\n+   |\n+LL |     if foo == bar {\n+   |        ---    ^^^ expected `Foo`, found `&Foo`\n+   |        |\n+   |        expected because this is `Foo`\n+   |\n+help: consider dereferencing the borrow\n+   |\n+LL |     if foo == *bar {\n+   |               +\n+\n+error: aborting due to 14 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "d54d0a1a48a2d599f6dacaadcfc7fffd8d158319", "filename": "tests/ui/inference/issue-70082.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/tests%2Fui%2Finference%2Fissue-70082.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/tests%2Fui%2Finference%2Fissue-70082.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Fissue-70082.rs?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    // this closure is fine, and should not get any error annotations\n+    let em = |v: f64| -> f64 { v };\n+\n+    let x: f64 = em(1i16.into());\n+\n+    let y: f64 = 0.01f64 * 1i16.into();\n+    //~^ ERROR type annotations needed\n+    //~| HELP try using a fully qualified path\n+}"}, {"sha": "47229a5fee14d0356fc71a1ecf728462b5cda74f", "filename": "tests/ui/inference/issue-70082.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1c42cb4ef0544fbfaa500216e53382d6b079c001/tests%2Fui%2Finference%2Fissue-70082.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1c42cb4ef0544fbfaa500216e53382d6b079c001/tests%2Fui%2Finference%2Fissue-70082.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finference%2Fissue-70082.stderr?ref=1c42cb4ef0544fbfaa500216e53382d6b079c001", "patch": "@@ -0,0 +1,17 @@\n+error[E0284]: type annotations needed\n+  --> $DIR/issue-70082.rs:7:33\n+   |\n+LL |     let y: f64 = 0.01f64 * 1i16.into();\n+   |                          -      ^^^^\n+   |                          |\n+   |                          type must be known at this point\n+   |\n+   = note: cannot satisfy `<f64 as Mul<_>>::Output == f64`\n+help: try using a fully qualified path to specify the expected types\n+   |\n+LL |     let y: f64 = 0.01f64 * <i16 as Into<T>>::into(1i16);\n+   |                            +++++++++++++++++++++++    ~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0284`."}]}