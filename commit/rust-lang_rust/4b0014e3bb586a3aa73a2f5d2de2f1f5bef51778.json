{"sha": "4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiMDAxNGUzYmI1ODZhM2FhNzNhMmY1ZDJkZTJmMWY1YmVmNTE3Nzg=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-05-26T11:32:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-26T11:32:08Z"}, "message": "Rollup merge of #85633 - lqd:stackless_span_stacks, r=oli-obk\n\nPost-monomorphization errors traces MVP\n\nThis PR works towards better diagnostics for the errors encountered in #85155 and similar.\n\nWe can encounter post-monomorphization errors (PMEs) when collecting mono items. The current diagnostics are confusing for these cases when they happen in a dependency (but are acceptable when they happen in the local crate).\n\nThese kinds of errors will be more likely now that `stdarch` uses const generics for its intrinsics' immediate arguments, and validates these const arguments with a mechanism that triggers such PMEs.\n\n(Not to mention that the errors happen during codegen, so only when building code that actually uses these code paths. Check builds don't trigger them, neither does unused code)\n\nSo in this PR, we detect these kinds of errors during the mono item graph walk: if any error happens while collecting a node or its neighbors, we print a diagnostic about the current collection step, so that the user has at least some context of which erroneous code and dependency triggered the error.\n\nThe diagnostics for issue #85155 now have this note showing the source of the erroneous const argument:\n```\nnote: the above error was encountered while instantiating `fn std::arch::x86_64::_mm_blend_ps::<51_i32>`\n  --> issue-85155.rs:11:24\n   |\n11 |         let _blended = _mm_blend_ps(a, b, 0x33);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n```\n\nNote that #85155 is a reduced version of a case happening in the wild, to indirect users of the `rustfft` crate, as seen in https://github.com/ejmahler/RustFFT/issues/74. The crate had a few of these out-of-range immediates. Here's how the diagnostics in this PR would have looked on one of its examples before it was fixed:\n\n<details>\n\n```\nerror[E0080]: evaluation of constant value failed\n --> ./stdarch/crates/core_arch/src/macros.rs:8:9\n  |\n8 |         assert!(IMM >= MIN && IMM <= MAX, \"IMM value not in expected range\");\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the evaluated program panicked at 'IMM value not in expected range', ./stdarch/crates/core_arch/src/macros.rs:8:9\n  |\n  = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nnote: the above error was encountered while instantiating `fn _mm_blend_ps::<51_i32>`\n    --> /tmp/RustFFT/src/avx/avx_vector.rs:1314:23\n     |\n1314 |         let blended = _mm_blend_ps(rows[0], rows[2], 0x33);\n     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nnote: the above error was encountered while instantiating `fn _mm_permute_pd::<5_i32>`\n    --> /tmp/RustFFT/src/avx/avx_vector.rs:1859:9\n     |\n1859 |         _mm_permute_pd(self, 0x05)\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nnote: the above error was encountered while instantiating `fn _mm_permute_pd::<15_i32>`\n    --> /tmp/RustFFT/src/avx/avx_vector.rs:1863:32\n     |\n1863 |         (_mm_movedup_pd(self), _mm_permute_pd(self, 0x0F))\n     |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0080`.\nerror: could not compile `rustfft`\n\nTo learn more, run the command again with --verbose.\n```\n\n</details>\n\nI've developed and discussed this with them, so maybe r? `@oli-obk` -- but feel free to redirect to someone else of course.\n\n(I'm not sure we can say that this PR definitely closes issue 85155, as it's still unclear exactly which diagnostics and information would be interesting to report in such cases -- and we've discussed printing backtraces before. I have prototypes of some complete and therefore noisy backtraces I showed Oli, but we decided to not include them in this PR for now)", "tree": {"sha": "047d1bdf23d3305b7f8118e4ed056d8342ff1c22", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/047d1bdf23d3305b7f8118e4ed056d8342ff1c22"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgrjG5CRBK7hj4Ov3rIwAA/bYIACKriTp+7yg6WzbpqCuPRpiy\nmL5WlsL035Rs6Surkd5dLVnb4tPTt64v+Ns7m9bgF0G3q3o3hp7rdUx8vQR3dR6H\nAhyQwh1TMxSyVNWsQIKfCUMnhrM7q1fTfaMCTjuZhRtw16JvGCJhn7dMZPRa4MoY\n1CnC9p1KUWALXgjRAUeZuzwfnGz6mGdyE82J4eeyBGkBW5TTNxw8se8o+nQ+MTqs\nVPmI8f65x764VuOTm0qkTS73QuI73sMoqUzzuyiTtPV4QHokXhDXZEUf97GiOVzn\nMRbgaTlvfPjd1uGdt16K5RHafIpgdBX62Lkp+VoQkLI9DhJTQlBZ2NyzP/02E8s=\n=V2uX\n-----END PGP SIGNATURE-----\n", "payload": "tree 047d1bdf23d3305b7f8118e4ed056d8342ff1c22\nparent f5c5cca7a563bec392aa10918eec104accbd86e1\nparent 6f6145617d303c090166956d7f7f2c19811e6765\nauthor Dylan DPC <dylan.dpc@gmail.com> 1622028728 +0200\ncommitter GitHub <noreply@github.com> 1622028728 +0200\n\nRollup merge of #85633 - lqd:stackless_span_stacks, r=oli-obk\n\nPost-monomorphization errors traces MVP\n\nThis PR works towards better diagnostics for the errors encountered in #85155 and similar.\n\nWe can encounter post-monomorphization errors (PMEs) when collecting mono items. The current diagnostics are confusing for these cases when they happen in a dependency (but are acceptable when they happen in the local crate).\n\nThese kinds of errors will be more likely now that `stdarch` uses const generics for its intrinsics' immediate arguments, and validates these const arguments with a mechanism that triggers such PMEs.\n\n(Not to mention that the errors happen during codegen, so only when building code that actually uses these code paths. Check builds don't trigger them, neither does unused code)\n\nSo in this PR, we detect these kinds of errors during the mono item graph walk: if any error happens while collecting a node or its neighbors, we print a diagnostic about the current collection step, so that the user has at least some context of which erroneous code and dependency triggered the error.\n\nThe diagnostics for issue #85155 now have this note showing the source of the erroneous const argument:\n```\nnote: the above error was encountered while instantiating `fn std::arch::x86_64::_mm_blend_ps::<51_i32>`\n  --> issue-85155.rs:11:24\n   |\n11 |         let _blended = _mm_blend_ps(a, b, 0x33);\n   |                        ^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n```\n\nNote that #85155 is a reduced version of a case happening in the wild, to indirect users of the `rustfft` crate, as seen in https://github.com/ejmahler/RustFFT/issues/74. The crate had a few of these out-of-range immediates. Here's how the diagnostics in this PR would have looked on one of its examples before it was fixed:\n\n<details>\n\n```\nerror[E0080]: evaluation of constant value failed\n --> ./stdarch/crates/core_arch/src/macros.rs:8:9\n  |\n8 |         assert!(IMM >= MIN && IMM <= MAX, \"IMM value not in expected range\");\n  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the evaluated program panicked at 'IMM value not in expected range', ./stdarch/crates/core_arch/src/macros.rs:8:9\n  |\n  = note: this error originates in the macro `$crate::panic::panic_2015` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nnote: the above error was encountered while instantiating `fn _mm_blend_ps::<51_i32>`\n    --> /tmp/RustFFT/src/avx/avx_vector.rs:1314:23\n     |\n1314 |         let blended = _mm_blend_ps(rows[0], rows[2], 0x33);\n     |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nnote: the above error was encountered while instantiating `fn _mm_permute_pd::<5_i32>`\n    --> /tmp/RustFFT/src/avx/avx_vector.rs:1859:9\n     |\n1859 |         _mm_permute_pd(self, 0x05)\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nnote: the above error was encountered while instantiating `fn _mm_permute_pd::<15_i32>`\n    --> /tmp/RustFFT/src/avx/avx_vector.rs:1863:32\n     |\n1863 |         (_mm_movedup_pd(self), _mm_permute_pd(self, 0x0F))\n     |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0080`.\nerror: could not compile `rustfft`\n\nTo learn more, run the command again with --verbose.\n```\n\n</details>\n\nI've developed and discussed this with them, so maybe r? `@oli-obk` -- but feel free to redirect to someone else of course.\n\n(I'm not sure we can say that this PR definitely closes issue 85155, as it's still unclear exactly which diagnostics and information would be interesting to report in such cases -- and we've discussed printing backtraces before. I have prototypes of some complete and therefore noisy backtraces I showed Oli, but we decided to not include them in this PR for now)\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778", "html_url": "https://github.com/rust-lang/rust/commit/4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5c5cca7a563bec392aa10918eec104accbd86e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5c5cca7a563bec392aa10918eec104accbd86e1", "html_url": "https://github.com/rust-lang/rust/commit/f5c5cca7a563bec392aa10918eec104accbd86e1"}, {"sha": "6f6145617d303c090166956d7f7f2c19811e6765", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f6145617d303c090166956d7f7f2c19811e6765", "html_url": "https://github.com/rust-lang/rust/commit/6f6145617d303c090166956d7f7f2c19811e6765"}], "stats": {"total": 111, "additions": 109, "deletions": 2}, "files": [{"sha": "0109580a0bba90062c773206f1b31e4f703686cb", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778", "patch": "@@ -186,6 +186,15 @@ impl<'tcx> MonoItem<'tcx> {\n     pub fn codegen_dep_node(&self, tcx: TyCtxt<'tcx>) -> DepNode {\n         crate::dep_graph::make_compile_mono_item(tcx, self)\n     }\n+\n+    /// Returns the item's `CrateNum`\n+    pub fn krate(&self) -> CrateNum {\n+        match self {\n+            MonoItem::Fn(ref instance) => instance.def_id().krate,\n+            MonoItem::Static(def_id) => def_id.krate,\n+            MonoItem::GlobalAsm(..) => LOCAL_CRATE,\n+        }\n+    }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for MonoItem<'tcx> {"}, {"sha": "afe4457bf433d5f772ea7708dfcccedeeb2e265a", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778", "patch": "@@ -184,7 +184,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{par_iter, MTLock, MTRef, ParallelIterator};\n use rustc_errors::{ErrorReported, FatalError};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n+use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::GrowableBitSet;\n@@ -342,7 +342,8 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n         .collect()\n }\n \n-// Collect all monomorphized items reachable from `starting_point`\n+/// Collect all monomorphized items reachable from `starting_point`, and emit a note diagnostic if a\n+/// post-monorphization error is encountered during a collection step.\n fn collect_items_rec<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     starting_point: Spanned<MonoItem<'tcx>>,\n@@ -359,6 +360,31 @@ fn collect_items_rec<'tcx>(\n     let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n \n+    //\n+    // Post-monomorphization errors MVP\n+    //\n+    // We can encounter errors while monomorphizing an item, but we don't have a good way of\n+    // showing a complete stack of spans ultimately leading to collecting the erroneous one yet.\n+    // (It's also currently unclear exactly which diagnostics and information would be interesting\n+    // to report in such cases)\n+    //\n+    // This leads to suboptimal error reporting: a post-monomorphization error (PME) will be\n+    // shown with just a spanned piece of code causing the error, without information on where\n+    // it was called from. This is especially obscure if the erroneous mono item is in a\n+    // dependency. See for example issue #85155, where, before minimization, a PME happened two\n+    // crates downstream from libcore's stdarch, without a way to know which dependency was the\n+    // cause.\n+    //\n+    // If such an error occurs in the current crate, its span will be enough to locate the\n+    // source. If the cause is in another crate, the goal here is to quickly locate which mono\n+    // item in the current crate is ultimately responsible for causing the error.\n+    //\n+    // To give at least _some_ context to the user: while collecting mono items, we check the\n+    // error count. If it has changed, a PME occurred, and we trigger some diagnostics about the\n+    // current step of mono items collection.\n+    //\n+    let error_count = tcx.sess.diagnostic().err_count();\n+\n     match starting_point.node {\n         MonoItem::Static(def_id) => {\n             let instance = Instance::mono(tcx, def_id);\n@@ -411,6 +437,22 @@ fn collect_items_rec<'tcx>(\n         }\n     }\n \n+    // Check for PMEs and emit a diagnostic if one happened. To try to show relevant edges of the\n+    // mono item graph where the PME diagnostics are currently the most problematic (e.g. ones\n+    // involving a dependency, and the lack of context is confusing) in this MVP, we focus on\n+    // diagnostics on edges crossing a crate boundary: the collected mono items which are not\n+    // defined in the local crate.\n+    if tcx.sess.diagnostic().err_count() > error_count && starting_point.node.krate() != LOCAL_CRATE\n+    {\n+        tcx.sess.span_note_without_error(\n+            starting_point.span,\n+            &format!(\n+                \"the above error was encountered while instantiating `{}`\",\n+                starting_point.node\n+            ),\n+        );\n+    }\n+\n     record_accesses(tcx, starting_point.node, neighbors.iter().map(|i| &i.node), inlining_map);\n \n     for neighbour in neighbors {"}, {"sha": "bdeaa0cd3606281e3e6b32e0ed5aed838d2e7609", "filename": "src/test/ui/consts/const-eval/auxiliary/post_monomorphization_error.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fauxiliary%2Fpost_monomorphization_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fauxiliary%2Fpost_monomorphization_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fauxiliary%2Fpost_monomorphization_error.rs?ref=4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778", "patch": "@@ -0,0 +1,20 @@\n+// Auxiliary crate used for testing post-monomorphization errors cross-crate.\n+// It duplicates the setup used in `stdarch` to validate its intrinsics' const arguments.\n+\n+struct ValidateConstImm<const IMM: i32, const MIN: i32, const MAX: i32>;\n+impl<const IMM: i32, const MIN: i32, const MAX: i32> ValidateConstImm<IMM, MIN, MAX> {\n+    pub(crate) const VALID: () = {\n+        let _ = 1 / ((IMM >= MIN && IMM <= MAX) as usize);\n+    };\n+}\n+\n+macro_rules! static_assert_imm1 {\n+    ($imm:ident) => {\n+        let _ = $crate::ValidateConstImm::<$imm, 0, { (1 << 1) - 1 }>::VALID;\n+    };\n+}\n+\n+// This function triggers an error whenever the const argument does not fit in 1-bit.\n+pub fn stdarch_intrinsic<const IMM1: i32>() {\n+    static_assert_imm1!(IMM1);\n+}"}, {"sha": "c3216d53d055406260e338b9e66d69fb4733c430", "filename": "src/test/ui/consts/const-eval/issue-85155.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.rs?ref=4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778", "patch": "@@ -0,0 +1,21 @@\n+// This is a test with a setup similar to issue 85155, which triggers a const eval error: a const\n+// argument value is outside the range expected by the `stdarch` intrinsic.\n+//\n+// It's not the exact code mentioned in that issue because it depends both on `stdarch` intrinsics\n+// only available on x64, and internal implementation details of `stdarch`. But mostly because these\n+// are not important to trigger the diagnostics issue: it's specifically about the lack of context\n+// in the diagnostics of post-monomorphization errors (PMEs) for consts, happening in a dependency.\n+// Therefore, its setup is reproduced with an aux crate, which will similarly trigger a PME\n+// depending on the const argument value, like the `stdarch` intrinsics would.\n+//\n+// aux-build: post_monomorphization_error.rs\n+// build-fail: this is a post-monomorphization error, it passes check runs and requires building\n+//             to actually fail.\n+\n+extern crate post_monomorphization_error;\n+\n+fn main() {\n+    // This function triggers a PME whenever the const argument does not fit in 1-bit.\n+    post_monomorphization_error::stdarch_intrinsic::<2>();\n+    //~^ NOTE the above error was encountered while instantiating\n+}"}, {"sha": "0a1edfb8a33568c7470f10290350f2418ac5216f", "filename": "src/test/ui/consts/const-eval/issue-85155.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.stderr?ref=4b0014e3bb586a3aa73a2f5d2de2f1f5bef51778", "patch": "@@ -0,0 +1,15 @@\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/auxiliary/post_monomorphization_error.rs:7:17\n+   |\n+LL |         let _ = 1 / ((IMM >= MIN && IMM <= MAX) as usize);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempt to divide `1_usize` by zero\n+\n+note: the above error was encountered while instantiating `fn stdarch_intrinsic::<2_i32>`\n+  --> $DIR/issue-85155.rs:19:5\n+   |\n+LL |     post_monomorphization_error::stdarch_intrinsic::<2>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}]}