{"sha": "5d4cce6cec7c0975263bbe6f4260167a772bfc89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNGNjZTZjZWM3YzA5NzUyNjNiYmU2ZjQyNjAxNjdhNzcyYmZjODk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-12T02:41:08Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-05-13T02:35:53Z"}, "message": "Rebasing", "tree": {"sha": "1dba65dbc1d9332fe808af52bc82951b3f453c8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1dba65dbc1d9332fe808af52bc82951b3f453c8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d4cce6cec7c0975263bbe6f4260167a772bfc89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d4cce6cec7c0975263bbe6f4260167a772bfc89", "html_url": "https://github.com/rust-lang/rust/commit/5d4cce6cec7c0975263bbe6f4260167a772bfc89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d4cce6cec7c0975263bbe6f4260167a772bfc89/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db1b14a194cbdbba813aeb4773ee7fa203a40fb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/db1b14a194cbdbba813aeb4773ee7fa203a40fb1", "html_url": "https://github.com/rust-lang/rust/commit/db1b14a194cbdbba813aeb4773ee7fa203a40fb1"}], "stats": {"total": 227, "additions": 118, "deletions": 109}, "files": [{"sha": "15d6e6fa9606c8f758d3c90753addc87c892f4a7", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -460,7 +460,6 @@ impl<T: ?Sized> Deref for Rc<T> {\n }\n \n #[cfg(stage0)] // SNAP c64d671\n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n@@ -512,7 +511,6 @@ impl<T> Drop for Rc<T> {\n }\n \n #[cfg(not(stage0))] // SNAP c64d671\n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for Rc<T> {\n     /// Drops the `Rc<T>`.\n@@ -933,7 +931,6 @@ impl<T: ?Sized> Weak<T> {\n }\n \n #[cfg(stage0)] // SNAP c64d671\n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n@@ -979,7 +976,6 @@ impl<T> Drop for Weak<T> {\n }\n \n #[cfg(not(stage0))] // SNAP c64d671\n-#[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Drop for Weak<T> {\n     /// Drops the `Weak<T>`."}, {"sha": "45a8012210417842edf6adb231defb94ebcb4410", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -707,5 +707,4 @@ impl<T: ?Sized> UnsafeCell<T> {\n         #![allow(trivial_casts)]\n         &self.value as *const T as *mut T\n     }\n-\n }"}, {"sha": "9396adc0fe5b74676da76509d01ae05459425140", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -1220,24 +1220,33 @@ pub trait CoerceUnsized<T> {\n     // Empty.\n }\n \n+// &mut T -> &mut U\n #[cfg(not(stage0))] // SNAP c64d671\n impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a mut U> for &'a mut T {}\n+// &mut T -> &U\n #[cfg(not(stage0))] // SNAP c64d671\n impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b mut T {}\n+// &mut T -> *mut U\n #[cfg(not(stage0))] // SNAP c64d671\n impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for &'a mut T {}\n+// &mut T -> *const U\n #[cfg(not(stage0))] // SNAP c64d671\n impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a mut T {}\n \n+// &T -> &U\n #[cfg(not(stage0))] // SNAP c64d671\n impl<'a, 'b: 'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<&'a U> for &'b T {}\n+// &T -> *const U\n #[cfg(not(stage0))] // SNAP c64d671\n impl<'a, T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for &'a T {}\n \n+// *mut T -> *mut U\n #[cfg(not(stage0))] // SNAP c64d671\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*mut U> for *mut T {}\n+// *mut T -> *const U\n #[cfg(not(stage0))] // SNAP c64d671\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n \n+// *const T -> *const U\n #[cfg(not(stage0))] // SNAP c64d671\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}"}, {"sha": "f02312b8641e118f7ec3d7b20cb228067732690c", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -172,14 +172,15 @@ fn unsafe_cell_unsized() {\n     assert_eq!(unsafe { &mut *cell.get() }, comp);\n }\n \n-#[test]\n-fn refcell_unsized() {\n-    let cell: &RefCell<[i32]> = &RefCell::new([1, 2, 3]);\n-    {\n-        let b = &mut *cell.borrow_mut();\n-        b[0] = 4;\n-        b[2] = 5;\n-    }\n-    let comp: &mut [i32] = &mut [4, 2, 5];\n-    assert_eq!(&*cell.borrow(), comp);\n-}\n+// FIXME(#25351) needs deeply nested coercions of DST structs.\n+// #[test]\n+// fn refcell_unsized() {\n+//     let cell: &RefCell<[i32]> = &RefCell::new([1, 2, 3]);\n+//     {\n+//         let b = &mut *cell.borrow_mut();\n+//         b[0] = 4;\n+//         b[2] = 5;\n+//     }\n+//     let comp: &mut [i32] = &mut [4, 2, 5];\n+//     assert_eq!(&*cell.borrow(), comp);\n+// }"}, {"sha": "bb50d5110cb60c4b0ff8e976a89b6e693fa0279e", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -808,8 +808,6 @@ register_diagnostics! {\n     E0019,\n     E0022,\n     E0038,\n-    E0079, // enum variant: expected signed integer constant\n-    E0080, // enum variant: constant evaluation error\n     E0109,\n     E0110,\n     E0134,"}, {"sha": "a4ed73d735832955e0da5e1a0c3581cc9b0dc6a6", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -1369,7 +1369,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn assemble_candidates_for_unsizing(&mut self,\n                                         obligation: &TraitObligation<'tcx>,\n                                         candidates: &mut SelectionCandidateSet<'tcx>) {\n-        // TODO is it Ok to skip the binder here?\n+        // It is ok to skip past the higher-ranked binders here because the `match`\n+        // below does not consider regions at all.\n         let source = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let target = self.infcx.shallow_resolve(obligation.predicate.0.input_types()[0]);\n \n@@ -1494,7 +1495,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 &ClosureCandidate(..) |\n                 &FnPointerCandidate(..) |\n                 &BuiltinObjectCandidate(..) |\n-                &&BuiltinUnsizeCandidate(..) |\n+                &BuiltinUnsizeCandidate(..) |\n                 &DefaultImplObjectCandidate(..) |\n                 &BuiltinCandidate(..) => {\n                     // We have a where-clause so don't go around looking\n@@ -2498,7 +2499,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::lookup_field_type_unsubstituted(tcx, def_id, f.id)\n                 }).collect::<Vec<_>>();\n \n-                // The last field of the structure has to exist and be a\n+                // FIXME(#25351) The last field of the structure has to exist and be a\n                 // type parameter (for now, to avoid tracking edge cases).\n                 let i = if let Some(&ty::ty_param(p)) = fields.last().map(|ty| &ty.sty) {\n                     assert!(p.space == TypeSpace);"}, {"sha": "f30f8560b9fe1627185e3a318c4993e1c0477a2f", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -377,7 +377,7 @@ pub fn predicate_for_trait_def<'tcx>(\n     let trait_ref = ty::TraitRef {\n         def_id: trait_def_id,\n         substs: tcx.mk_substs(Substs::new_trait(ty_params, vec![], param_ty))\n-    });\n+    };\n     predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n }\n "}, {"sha": "9054cd654732d7ef33603e8e0453d6fcfcde3aaa", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -4420,7 +4420,7 @@ pub fn deref<'tcx>(ty: Ty<'tcx>, explicit: bool) -> Option<mt<'tcx>> {\n pub fn type_content<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_uniq(ty) => ty,\n-        ty_rptr(_, mt) |ty_ptr(mt) => mt.ty,\n+        ty_rptr(_, mt) | ty_ptr(mt) => mt.ty,\n         _ => ty\n     }\n }"}, {"sha": "ab86cd7cdde5996a7db24362341e8cde6818a2f2", "filename": "src/librustc_trans/trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmetadata.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -1058,6 +1058,7 @@ impl MetadataCreationResult {\n     }\n }\n \n+#[derive(Debug)]\n enum MemberOffset {\n     FixedMemberOffset { bytes: usize },\n     // For ComputedMemberOffset, the offset is read from the llvm type definition.\n@@ -1066,6 +1067,7 @@ enum MemberOffset {\n \n // Description of a type member, which can either be a regular field (as in\n // structs or tuples) or an enum variant.\n+#[derive(Debug)]\n struct MemberDescription {\n     name: String,\n     llvm_type: Type,\n@@ -1163,13 +1165,13 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      span: Span)\n                                      -> RecursiveTypeDescription<'tcx> {\n     let struct_name = compute_debuginfo_type_name(cx, struct_type, false);\n-    let struct_llvm_type = type_of::type_of(cx, struct_type);\n+    let struct_llvm_type = type_of::in_memory_type_of(cx, struct_type);\n \n     let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n \n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n-                                                  &struct_name[..],\n+                                                  &struct_name,\n                                                   unique_type_id,\n                                                   containing_scope);\n \n@@ -1299,7 +1301,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         set_members_of_composite_type(cx,\n                                                       variant_type_metadata,\n                                                       variant_llvm_type,\n-                                                      &member_descriptions[..]);\n+                                                      &member_descriptions);\n                         MemberDescription {\n                             name: \"\".to_string(),\n                             llvm_type: variant_llvm_type,"}, {"sha": "270aacfe143df2ac3846dc06ddca4ab9d5957bb5", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -487,11 +487,11 @@ fn coerce_unsized<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let trait_substs = Substs::erased(VecPerParamSpace::new(vec![target.ty],\n                                                                     vec![source.ty],\n                                                                     Vec::new()));\n-            let trait_ref = ty::Binder(Rc::new(ty::TraitRef {\n+            let trait_ref = ty::Binder(ty::TraitRef {\n                 def_id: langcall(bcx, Some(span), \"coercion\",\n                                  CoerceUnsizedTraitLangItem),\n                 substs: bcx.tcx().mk_substs(trait_substs)\n-            }));\n+            });\n \n             let kind = match fulfill_obligation(bcx.ccx(), span, trait_ref) {\n                 traits::VtableImpl(traits::VtableImplData { impl_def_id, .. }) => {"}, {"sha": "bc6159c0cff3003f9ca791a346ed76d7505f5de9", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 30, "deletions": 25, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -60,28 +60,29 @@ pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n     let e = &cast.expr;\n     let t_e = structurally_resolved_type(fcx, span, cast.expr_ty);\n     let t_1 = structurally_resolved_type(fcx, span, cast.cast_ty);\n+    let tcx = fcx.tcx();\n \n     // Check for trivial casts.\n     if !ty::type_has_ty_infer(t_1) {\n         if let Ok(()) = coercion::mk_assignty(fcx, e, t_e, t_1) {\n             if ty::type_is_numeric(t_1) && ty::type_is_numeric(t_e) {\n-                fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n-                                        e.id,\n-                                        span,\n-                                        format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n-                                                 replaced by coercion, this might require type \\\n-                                                 ascription or a temporary variable\",\n-                                                fcx.infcx().ty_to_string(t_e),\n-                                                fcx.infcx().ty_to_string(t_1)));\n+                tcx.sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n+                                  e.id,\n+                                  span,\n+                                  format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n+                                           replaced by coercion, this might require type \\\n+                                           ascription or a temporary variable\",\n+                                          fcx.infcx().ty_to_string(t_e),\n+                                          fcx.infcx().ty_to_string(t_1)));\n             } else {\n-                fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n-                                        e.id,\n-                                        span,\n-                                        format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n-                                                 replaced by coercion, this might require type \\\n-                                                 ascription or a temporary variable\",\n-                                                fcx.infcx().ty_to_string(t_e),\n-                                                fcx.infcx().ty_to_string(t_1)));\n+                tcx.sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n+                                  e.id,\n+                                  span,\n+                                  format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n+                                           replaced by coercion, this might require type \\\n+                                           ascription or a temporary variable\",\n+                                          fcx.infcx().ty_to_string(t_e),\n+                                          fcx.infcx().ty_to_string(t_1)));\n             }\n             return;\n         }\n@@ -91,14 +92,14 @@ pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n     let t_e_is_scalar = ty::type_is_scalar(t_e);\n     let t_e_is_integral = ty::type_is_integral(t_e);\n     let t_e_is_float = ty::type_is_floating_point(t_e);\n-    let t_e_is_c_enum = ty::type_is_c_like_enum(fcx.tcx(), t_e);\n+    let t_e_is_c_enum = ty::type_is_c_like_enum(tcx, t_e);\n \n     let t_1_is_scalar = ty::type_is_scalar(t_1);\n     let t_1_is_integral = ty::type_is_integral(t_1);\n     let t_1_is_char = ty::type_is_char(t_1);\n     let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n     let t_1_is_float = ty::type_is_floating_point(t_1);\n-    let t_1_is_c_enum = ty::type_is_c_like_enum(fcx.tcx(), t_1);\n+    let t_1_is_c_enum = ty::type_is_c_like_enum(tcx, t_1);\n     let t1_is_fat_ptr = fcx.type_is_fat_ptr(t_1, span);\n \n     // casts to scalars other than `char` and `bare fn` are trivial\n@@ -114,7 +115,7 @@ pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n             }, t_e, None);\n         }\n     } else if t_1.sty == ty::ty_bool {\n-        span_err!(fcx.tcx().sess, span, E0054,\n+        span_err!(tcx.sess, span, E0054,\n                   \"cannot cast as `bool`, compare with zero instead\");\n     } else if t_e_is_float && (t_1_is_scalar || t_1_is_c_enum) &&\n         !(t_1_is_integral || t_1_is_float) {\n@@ -174,12 +175,16 @@ pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n     } else if t1_is_fat_ptr {\n         // FIXME This should be allowed where the lefthandside is also a fat\n         // pointer and is the same kind of fat pointer, i.e., array to array,\n-        // trait object to trait object.\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"cast to fat pointer: `{}` as `{}`\",\n-                    actual,\n-                    fcx.infcx().ty_to_string(t_1))\n-        }, t_e, None);\n+        // trait object to trait object. That is a bit looser than the current\n+        // rquirement that they are pointers to the same type.\n+        if !(fcx.type_is_fat_ptr(t_e, span) &&\n+             ty::deref(t_1, true).unwrap().ty == ty::deref(t_e, true).unwrap().ty) {\n+            fcx.type_error_message(span, |actual| {\n+                format!(\"cast to fat pointer: `{}` as `{}`\",\n+                        actual,\n+                        fcx.infcx().ty_to_string(t_1))\n+            }, t_e, None);\n+        }\n     } else if !(t_e_is_scalar && t_1_is_trivial) {\n         fcx.type_error_message(span, |actual| {\n             format!(\"non-scalar cast: `{}` as `{}`\","}, {"sha": "dd63a512ae39305f20e4fc8f362fb44a74bfa8d2", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -285,14 +285,19 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // Create an obligation for `Source: CoerceUnsized<Target>`.\n         let cause = ObligationCause::misc(self.origin.span(), self.fcx.body_id);\n-        queue.push_back(predicate_for_trait_def(self.tcx(), cause, coerce_unsized_did,\n-                                                0, source, vec![target]));\n+        queue.push_back(predicate_for_trait_def(self.tcx(),\n+                                                cause,\n+                                                coerce_unsized_did,\n+                                                0,\n+                                                source,\n+                                                vec![target]));\n \n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n         // inference might unify those two inner type variables later.\n         let traits = [coerce_unsized_did, unsize_did];\n         while let Some(obligation) = queue.pop_front() {\n+            debug!(\"coerce_unsized resolve step: {}\", obligation.repr(self.tcx()));\n             let trait_ref =  match obligation.predicate {\n                 ty::Predicate::Trait(ref tr) if traits.contains(&tr.def_id()) => {\n                     tr.clone()\n@@ -305,6 +310,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             match selcx.select(&obligation.with(trait_ref)) {\n                 // Uncertain or unimplemented.\n                 Ok(None) | Err(traits::Unimplemented) => {\n+                    debug!(\"coerce_unsized: early return - can't prove obligation\");\n                     return Err(ty::terr_mismatch);\n                 }\n "}, {"sha": "090d111b62b898dde6acc1007c92c4ca647fddae", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -85,6 +85,7 @@\n use astconv::AstConv;\n use check::dropck;\n use check::FnCtxt;\n+use middle::free_region::FreeRegionMap;\n use middle::implicator;\n use middle::mem_categorization as mc;\n use middle::region::CodeExtent;"}, {"sha": "58ad8ce86280d4f1aca04cea56bfa409dc1b9e09", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -29,6 +29,7 @@ use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int};\n use middle::ty::{ty_uint, ty_closure, ty_uniq, ty_bare_fn};\n use middle::ty::ty_projection;\n use middle::ty;\n+use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n use middle::infer::{self, InferCtxt, new_infer_ctxt};\n use std::cell::RefCell;\n@@ -439,32 +440,19 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n         };\n \n-        let trait_impls = match tcx.trait_impls\n-                                   .borrow()\n-                                   .get(&coerce_unsized_trait)\n-                                   .cloned() {\n-            None => {\n-                debug!(\"check_implementations_of_coerce_unsized(): no types \\\n-                        with implementations of `CoerceUnsized` found\");\n-                return\n-            }\n-            Some(found_impls) => found_impls\n-        };\n+        let trait_def = ty::lookup_trait_def(tcx, coerce_unsized_trait);\n \n-        // Clone first to avoid a double borrow error.\n-        let trait_impls = trait_impls.borrow().clone();\n-\n-        for &impl_did in &trait_impls {\n+        trait_def.for_each_impl(tcx, |impl_did| {\n             debug!(\"check_implementations_of_coerce_unsized: impl_did={}\",\n                    impl_did.repr(tcx));\n \n             if impl_did.krate != ast::LOCAL_CRATE {\n                 debug!(\"check_implementations_of_coerce_unsized(): impl not \\\n                         in this crate\");\n-                continue\n+                return;\n             }\n \n-            let source = self.get_self_type_for_implementation(impl_did).ty;\n+            let source = ty::lookup_item_type(tcx, impl_did).ty;\n             let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx,\n                                                      impl_did.node);\n             let target = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n@@ -507,12 +495,12 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     if def_id_a != def_id_b {\n                         let source_path = ty::item_path_str(tcx, def_id_a);\n                         let target_path = ty::item_path_str(tcx, def_id_b);\n-                        span_err!(tcx.sess, span, E0373,\n+                        span_err!(tcx.sess, span, E0377,\n                                   \"the trait `CoerceUnsized` may only be implemented \\\n                                    for a coercion between structures with the same \\\n                                    definition; expected {}, found {}\",\n                                   source_path, target_path);\n-                        continue;\n+                        return;\n                     }\n \n                     let origin = infer::Misc(span);\n@@ -532,7 +520,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                   \"the trait `CoerceUnsized` may only be implemented \\\n                                    for a coercion between structures with one field \\\n                                    being coerced, none found\");\n-                        continue;\n+                        return;\n                     } else if diff_fields.len() > 1 {\n                         span_err!(tcx.sess, span, E0375,\n                                   \"the trait `CoerceUnsized` may only be implemented \\\n@@ -549,7 +537,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                                 a.repr(tcx),\n                                                 b.repr(tcx))\n                                    }).collect::<Vec<_>>().connect(\", \"));\n-                        continue;\n+                        return;\n                     }\n \n                     let (i, a, b) = diff_fields[0];\n@@ -561,7 +549,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     span_err!(tcx.sess, span, E0376,\n                               \"the trait `CoerceUnsized` may only be implemented \\\n                                for a coercion between structures\");\n-                    continue;\n+                    return;\n                 }\n             };\n \n@@ -578,14 +566,15 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 traits::report_fulfillment_errors(&infcx, &errors);\n             }\n \n-            // Finally, resolve all regions. This catches wily misuses of lifetime\n-            // parameters.\n-            infcx.resolve_regions_and_report_errors(impl_did.node);\n+            // Finally, resolve all regions.\n+            let mut free_regions = FreeRegionMap::new();\n+            free_regions.relate_free_regions_from_predicates(tcx, &param_env.caller_bounds);\n+            infcx.resolve_regions_and_report_errors(&free_regions, impl_did.node);\n \n             if let Some(kind) = kind {\n                 tcx.custom_coerce_unsized_kinds.borrow_mut().insert(impl_did, kind);\n             }\n-        }\n+        });\n     }\n }\n "}, {"sha": "4c9fe6492e9ca530430ea1884d5b5532b781e087", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -323,7 +323,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                     return;\n                 }\n                 if Some(trait_def_id) == self.tcx.lang_items.unsize_trait() {\n-                    span_err!(self.tcx.sess, item.span, E0323,\n+                    span_err!(self.tcx.sess, item.span, E0328,\n                               \"explicit impls for the `Unsize` trait are not permitted\");\n                     return;\n                 }"}, {"sha": "e92779641c9cb63411bb759c4cecfd982a3cdcd2", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -452,13 +452,13 @@ register_diagnostics! {\n     E0369, // binary operation `<op>` cannot be applied to types\n     E0371, // impl Trait for Trait is illegal\n     E0372, // impl Trait for Trait where Trait is not object safe\n-    E0373, // the trait `CoerceUnsized` may only be implemented for a coercion\n-           // between structures with the same definition\n     E0374, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with one field being coerced, none found\n     E0375, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with one field being coerced, but multiple\n            // fields need coercions\n-    E0376  // the trait `CoerceUnsized` may only be implemented for a coercion\n+    E0376, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures\n+    E0377  // the trait `CoerceUnsized` may only be implemented for a coercion\n+           // between structures with the same definition\n }"}, {"sha": "f9ed7c863d126c1adcaff76026772abbf5fcb730", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -531,15 +531,16 @@ mod tests {\n         assert_eq!(*lock, 2);\n     }\n \n-    #[test]\n-    fn test_mutex_unsized() {\n-        let mutex: &Mutex<[i32]> = &Mutex::new([1, 2, 3]);\n-        {\n-            let b = &mut *mutex.lock().unwrap();\n-            b[0] = 4;\n-            b[2] = 5;\n-        }\n-        let comp: &[i32] = &[4, 2, 5];\n-        assert_eq!(&*mutex.lock().unwrap(), comp);\n-    }\n+    // FIXME(#25351) needs deeply nested coercions of DST structs.\n+    // #[test]\n+    // fn test_mutex_unsized() {\n+    //     let mutex: &Mutex<[i32]> = &Mutex::new([1, 2, 3]);\n+    //     {\n+    //         let b = &mut *mutex.lock().unwrap();\n+    //         b[0] = 4;\n+    //         b[2] = 5;\n+    //     }\n+    //     let comp: &[i32] = &[4, 2, 5];\n+    //     assert_eq!(&*mutex.lock().unwrap(), comp);\n+    // }\n }"}, {"sha": "36f6fbf3b72d53438d3878b035d2021a3b159e16", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -573,17 +573,18 @@ mod tests {\n         assert_eq!(*lock, 2);\n     }\n \n-    #[test]\n-    fn test_rwlock_unsized() {\n-        let rw: &RwLock<[i32]> = &RwLock::new([1, 2, 3]);\n-        {\n-            let b = &mut *rw.write().unwrap();\n-            b[0] = 4;\n-            b[2] = 5;\n-        }\n-        let comp: &[i32] = &[4, 2, 5];\n-        assert_eq!(&*rw.read().unwrap(), comp);\n-    }\n+    // FIXME(#25351) needs deeply nested coercions of DST structs.\n+    // #[test]\n+    // fn test_rwlock_unsized() {\n+    //     let rw: &RwLock<[i32]> = &RwLock::new([1, 2, 3]);\n+    //     {\n+    //         let b = &mut *rw.write().unwrap();\n+    //         b[0] = 4;\n+    //         b[2] = 5;\n+    //     }\n+    //     let comp: &[i32] = &[4, 2, 5];\n+    //     assert_eq!(&*rw.read().unwrap(), comp);\n+    // }\n \n     #[test]\n     fn test_rwlock_try_write() {"}, {"sha": "2099424b05c281c1941d52ba8fe97ad10ae9299c", "filename": "src/test/compile-fail/fat-ptr-cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d4cce6cec7c0975263bbe6f4260167a772bfc89/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs?ref=5d4cce6cec7c0975263bbe6f4260167a772bfc89", "patch": "@@ -16,8 +16,8 @@ fn main() {\n     let a: &[i32] = &[1, 2, 3];\n     let b: Box<[i32]> = Box::new([1, 2, 3]);\n \n-    a as usize; //~ ERROR illegal cast\n-    b as usize; //~ ERROR illegal cast\n+    a as usize; //~ ERROR non-scalar cast\n+    b as usize; //~ ERROR non-scalar cast\n \n     let a: usize = 42;\n     a as *const [i32]; //~ ERROR cast to fat pointer: `usize` as `*const [i32]`"}]}