{"sha": "e1c517ca4815273285ac5699a88ccf0bcdb6103e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxYzUxN2NhNDgxNTI3MzI4NWFjNTY5OWE4OGNjZjBiY2RiNjEwM2U=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-10-07T17:31:34Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-10-07T17:32:25Z"}, "message": "migrate libsyntax/rustc to auto_serialize2", "tree": {"sha": "22683ff90039c419ca424575e075b19cae689043", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22683ff90039c419ca424575e075b19cae689043"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1c517ca4815273285ac5699a88ccf0bcdb6103e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1c517ca4815273285ac5699a88ccf0bcdb6103e", "html_url": "https://github.com/rust-lang/rust/commit/e1c517ca4815273285ac5699a88ccf0bcdb6103e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1c517ca4815273285ac5699a88ccf0bcdb6103e/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a41abb9efee7e07b3989f3a60b994a05c386851", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a41abb9efee7e07b3989f3a60b994a05c386851", "html_url": "https://github.com/rust-lang/rust/commit/2a41abb9efee7e07b3989f3a60b994a05c386851"}], "stats": {"total": 946, "additions": 503, "deletions": 443}, "files": [{"sha": "1c279f81cc39332b26bbd0dcf38bb5cd64013fdf", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 208, "deletions": 147, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e1c517ca4815273285ac5699a88ccf0bcdb6103e", "patch": "@@ -1,33 +1,25 @@\n // The Rust abstract syntax tree.\n \n+use std::serialization2::{Serializable,\n+                          Deserializable,\n+                          Serializer,\n+                          Deserializer};\n use codemap::{span, filename};\n-use std::serialization::{Serializer,\n-                            Deserializer,\n-                            serialize_Option,\n-                            deserialize_Option,\n-                            serialize_uint,\n-                            deserialize_uint,\n-                            serialize_int,\n-                            deserialize_int,\n-                            serialize_i64,\n-                            deserialize_i64,\n-                            serialize_u64,\n-                            deserialize_u64,\n-                            serialize_str,\n-                            deserialize_str,\n-                            serialize_bool,\n-                            deserialize_bool};\n use parse::token;\n \n-/* Note #1972 -- spans are serialized but not deserialized */\n-fn serialize_span<S>(_s: S, _v: span) {\n+impl span: Serializable {\n+    /* Note #1972 -- spans are serialized but not deserialized */\n+    fn serialize<S: Serializer>(&self, _s: &S) { }\n }\n \n-fn deserialize_span<D>(_d: D) -> span {\n-    ast_util::dummy_sp()\n+impl span: Deserializable {\n+    static fn deserialize<D: Deserializer>(_d: &D) -> span {\n+        ast_util::dummy_sp()\n+    }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type spanned<T> = {node: T, span: span};\n \n \n@@ -42,25 +34,30 @@ macro_rules! interner_key (\n // implemented.\n struct ident { repr: uint }\n \n-fn serialize_ident<S: Serializer>(s: S, i: ident) {\n-    let intr = match unsafe{\n-        task::local_data::local_data_get(interner_key!())\n-    } {\n-        None => fail ~\"serialization: TLS interner not set up\",\n-        Some(intr) => intr\n-    };\n+impl ident: Serializable {\n+    fn serialize<S: Serializer>(&self, s: &S) {\n+        let intr = match unsafe {\n+            task::local_data::local_data_get(interner_key!())\n+        } {\n+            None => fail ~\"serialization: TLS interner not set up\",\n+            Some(intr) => intr\n+        };\n \n-    s.emit_str(*(*intr).get(i));\n+        s.emit_owned_str(*(*intr).get(*self));\n+    }\n }\n-fn deserialize_ident<D: Deserializer>(d: D) -> ident  {\n-    let intr = match unsafe{\n-        task::local_data::local_data_get(interner_key!())\n-    } {\n-        None => fail ~\"deserialization: TLS interner not set up\",\n-        Some(intr) => intr\n-    };\n \n-    (*intr).intern(@d.read_str())\n+impl ident: Deserializable {\n+    static fn deserialize<D: Deserializer>(d: &D) -> ident {\n+        let intr = match unsafe {\n+            task::local_data::local_data_get(interner_key!())\n+        } {\n+            None => fail ~\"deserialization: TLS interner not set up\",\n+            Some(intr) => intr\n+        };\n+\n+        (*intr).intern(@d.read_owned_str())\n+    }\n }\n \n impl ident: cmp::Eq {\n@@ -75,23 +72,22 @@ impl ident: to_bytes::IterBytes {\n }\n \n // Functions may or may not have names.\n-#[auto_serialize]\n type fn_ident = Option<ident>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type path = {span: span,\n              global: bool,\n              idents: ~[ident],\n              rp: Option<@region>,\n              types: ~[@ty]};\n \n-#[auto_serialize]\n type crate_num = int;\n \n-#[auto_serialize]\n type node_id = int;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type def_id = {crate: crate_num, node: node_id};\n \n impl def_id : cmp::Eq {\n@@ -104,7 +100,8 @@ impl def_id : cmp::Eq {\n const local_crate: crate_num = 0;\n const crate_node_id: node_id = 0;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum ty_param_bound {\n     bound_copy,\n     bound_send,\n@@ -113,10 +110,12 @@ enum ty_param_bound {\n     bound_trait(@ty),\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type ty_param = {ident: ident, id: node_id, bounds: @~[ty_param_bound]};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum def {\n     def_fn(def_id, purity),\n     def_static_method(def_id, purity),\n@@ -293,33 +292,36 @@ enum crate_directive_ {\n \n type crate_directive = spanned<crate_directive_>;\n \n-#[auto_serialize]\n type meta_item = spanned<meta_item_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum meta_item_ {\n     meta_word(~str),\n     meta_list(~str, ~[@meta_item]),\n     meta_name_value(~str, lit),\n }\n \n-#[auto_serialize]\n type blk = spanned<blk_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type blk_ = {view_items: ~[@view_item],\n              stmts: ~[@stmt],\n              expr: Option<@expr>,\n              id: node_id,\n              rules: blk_check_mode};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type pat = {id: node_id, node: pat_, span: span};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type field_pat = {ident: ident, pat: @pat};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum binding_mode {\n     bind_by_value,\n     bind_by_move,\n@@ -375,7 +377,8 @@ impl binding_mode : cmp::Eq {\n     pure fn ne(other: &binding_mode) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum pat_ {\n     pat_wild,\n     // A pat_ident may either be a new bound variable,\n@@ -398,7 +401,8 @@ enum pat_ {\n     pat_range(@expr, @expr),\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum mutability { m_mutbl, m_imm, m_const, }\n \n impl mutability : to_bytes::IterBytes {\n@@ -414,7 +418,8 @@ impl mutability : cmp::Eq {\n     pure fn ne(other: &mutability) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum proto {\n     proto_bare,    // foreign fn\n     proto_uniq,    // fn~\n@@ -429,7 +434,8 @@ impl proto : cmp::Eq {\n     pure fn ne(other: &proto) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum vstore {\n     // FIXME (#2112): Change uint to @expr (actually only constant exprs)\n     vstore_fixed(Option<uint>),   // [1,2,3,4]/_ or 4\n@@ -438,7 +444,8 @@ enum vstore {\n     vstore_slice(@region)         // &[1,2,3,4](foo)?\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum expr_vstore {\n     // FIXME (#2112): Change uint to @expr (actually only constant exprs)\n     expr_vstore_fixed(Option<uint>),   // [1,2,3,4]/_ or 4\n@@ -454,7 +461,8 @@ pure fn is_blockish(p: ast::proto) -> bool {\n     }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum binop {\n     add,\n     subtract,\n@@ -483,7 +491,8 @@ impl binop : cmp::Eq {\n     pure fn ne(other: &binop) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum unop {\n     box(mutability),\n     uniq(mutability),\n@@ -534,7 +543,8 @@ impl unop : cmp::Eq {\n \n // Generally, after typeck you can get the inferred value\n // using ty::resolved_T(...).\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum inferable<T> {\n     expl(T),\n     infer(node_id)\n@@ -573,7 +583,8 @@ impl<T:cmp::Eq> inferable<T> : cmp::Eq {\n }\n \n // \"resolved\" mode: the real modes.\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum rmode { by_ref, by_val, by_move, by_copy }\n \n impl rmode : to_bytes::IterBytes {\n@@ -591,13 +602,12 @@ impl rmode : cmp::Eq {\n }\n \n // inferable mode.\n-#[auto_serialize]\n type mode = inferable<rmode>;\n \n-#[auto_serialize]\n type stmt = spanned<stmt_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum stmt_ {\n     stmt_decl(@decl, node_id),\n \n@@ -608,7 +618,8 @@ enum stmt_ {\n     stmt_semi(@expr, node_id),\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum init_op { init_assign, init_move, }\n \n impl init_op : cmp::Eq {\n@@ -631,34 +642,37 @@ impl init_op : cmp::Eq {\n     pure fn ne(other: &init_op) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type initializer = {op: init_op, expr: @expr};\n \n // FIXME (pending discussion of #1697, #2178...): local should really be\n // a refinement on pat.\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type local_ =  {is_mutbl: bool, ty: @ty, pat: @pat,\n                 init: Option<initializer>, id: node_id};\n \n-#[auto_serialize]\n type local = spanned<local_>;\n \n-#[auto_serialize]\n type decl = spanned<decl_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum decl_ { decl_local(~[@local]), decl_item(@item), }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type arm = {pats: ~[@pat], guard: Option<@expr>, body: blk};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type field_ = {mutbl: mutability, ident: ident, expr: @expr};\n \n-#[auto_serialize]\n type field = spanned<field_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum blk_check_mode { default_blk, unsafe_blk, }\n \n impl blk_check_mode : cmp::Eq {\n@@ -673,18 +687,22 @@ impl blk_check_mode : cmp::Eq {\n     pure fn ne(other: &blk_check_mode) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type expr = {id: node_id, callee_id: node_id, node: expr_, span: span};\n // Extra node ID is only used for index, assign_op, unary, binary\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum log_level { error, debug, other }\n // 0 = error, 1 = debug, 2 = other\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum alt_mode { alt_check, alt_exhaustive, }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n@@ -740,15 +758,17 @@ enum expr_ {\n     expr_repeat(@expr /* element */, @expr /* count */, mutability)\n }\n \n-#[auto_serialize]\n-type capture_item = @{\n+#[auto_serialize2]\n+#[auto_deserialize2]\n+type capture_item_ = {\n     id: int,\n     is_move: bool,\n     name: ident, // Currently, can only capture a local var.\n     span: span\n };\n \n-#[auto_serialize]\n+type capture_item = @capture_item_;\n+\n type capture_clause = @~[capture_item];\n \n //\n@@ -767,7 +787,8 @@ type capture_clause = @~[capture_item];\n // else knows what to do with them, so you'll probably get a syntax\n // error.\n //\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n enum token_tree {\n     tt_tok(span, token::token),\n@@ -829,10 +850,10 @@ enum token_tree {\n // If you understand that, you have closed to loop and understand the whole\n // macro system. Congratulations.\n //\n-#[auto_serialize]\n type matcher = spanned<matcher_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum matcher_ {\n     // match one token\n     match_tok(token::token),\n@@ -843,19 +864,18 @@ enum matcher_ {\n     match_nonterminal(ident, ident, uint)\n }\n \n-#[auto_serialize]\n type mac = spanned<mac_>;\n \n-#[auto_serialize]\n type mac_arg = Option<@expr>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type mac_body_ = {span: span};\n \n-#[auto_serialize]\n type mac_body = Option<mac_body_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum mac_ {\n     mac_invoc(@path, mac_arg, mac_body), // old macro-invocation\n     mac_invoc_tt(@path,~[token_tree]),   // new macro-invocation\n@@ -866,10 +886,10 @@ enum mac_ {\n     mac_var(uint)\n }\n \n-#[auto_serialize]\n type lit = spanned<lit_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum lit_ {\n     lit_str(@~str),\n     lit_int(i64, int_ty),\n@@ -910,21 +930,24 @@ impl ast::lit_: cmp::Eq {\n \n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type mt = {ty: @ty, mutbl: mutability};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type ty_field_ = {ident: ident, mt: mt};\n \n-#[auto_serialize]\n type ty_field = spanned<ty_field_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type ty_method = {ident: ident, attrs: ~[attribute], purity: purity,\n                   decl: fn_decl, tps: ~[ty_param], self_ty: self_ty,\n                   id: node_id, span: span};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n@@ -933,7 +956,8 @@ enum trait_method {\n     provided(@method),\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum int_ty { ty_i, ty_char, ty_i8, ty_i16, ty_i32, ty_i64, }\n \n impl int_ty : to_bytes::IterBytes {\n@@ -962,7 +986,8 @@ impl int_ty : cmp::Eq {\n     pure fn ne(other: &int_ty) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum uint_ty { ty_u, ty_u8, ty_u16, ty_u32, ty_u64, }\n \n impl uint_ty : to_bytes::IterBytes {\n@@ -989,7 +1014,8 @@ impl uint_ty : cmp::Eq {\n     pure fn ne(other: &uint_ty) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum float_ty { ty_f, ty_f32, ty_f64, }\n \n impl float_ty : to_bytes::IterBytes {\n@@ -1007,11 +1033,13 @@ impl float_ty : cmp::Eq {\n     pure fn ne(other: &float_ty) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type ty = {id: node_id, node: ty_, span: span};\n \n // Not represented directly in the AST, referred to by name through a ty_path.\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum prim_ty {\n     ty_int(int_ty),\n     ty_uint(uint_ty),\n@@ -1058,18 +1086,21 @@ impl prim_ty : cmp::Eq {\n     pure fn ne(other: &prim_ty) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type region = {id: node_id, node: region_};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum region_ {\n     re_anon,\n     re_static,\n     re_self,\n     re_named(ident)\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum ty_ {\n     ty_nil,\n     ty_bot, /* bottom type */\n@@ -1108,16 +1139,19 @@ impl ty : to_bytes::IterBytes {\n }\n \n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type arg = {mode: mode, ty: @ty, ident: ident, id: node_id};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type fn_decl =\n     {inputs: ~[arg],\n      output: @ty,\n      cf: ret_style};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum purity {\n     pure_fn, // declared with \"pure fn\"\n     unsafe_fn, // declared with \"unsafe fn\"\n@@ -1138,7 +1172,8 @@ impl purity : cmp::Eq {\n     pure fn ne(other: &purity) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum ret_style {\n     noreturn, // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n@@ -1163,7 +1198,8 @@ impl ret_style : cmp::Eq {\n     pure fn ne(other: &ret_style) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum self_ty_ {\n     sty_static,                         // no self: static method\n     sty_by_ref,                         // old by-reference self: ``\n@@ -1217,28 +1253,31 @@ impl self_ty_ : cmp::Eq {\n     pure fn ne(other: &self_ty_) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n type self_ty = spanned<self_ty_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type method = {ident: ident, attrs: ~[attribute],\n                tps: ~[ty_param], self_ty: self_ty,\n                purity: purity, decl: fn_decl, body: blk,\n                id: node_id, span: span, self_id: node_id,\n                vis: visibility};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type _mod = {view_items: ~[@view_item], items: ~[@item]};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum foreign_abi {\n     foreign_abi_rust_intrinsic,\n     foreign_abi_cdecl,\n     foreign_abi_stdcall,\n }\n \n // Foreign mods can be named or anonymous\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum foreign_mod_sort { named, anonymous }\n \n impl foreign_mod_sort : cmp::Eq {\n@@ -1262,39 +1301,48 @@ impl foreign_abi : cmp::Eq {\n     pure fn ne(other: &foreign_abi) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type foreign_mod =\n     {sort: foreign_mod_sort,\n      view_items: ~[@view_item],\n      items: ~[@foreign_item]};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type variant_arg = {ty: @ty, id: node_id};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum variant_kind {\n     tuple_variant_kind(~[variant_arg]),\n     struct_variant_kind(@struct_def),\n     enum_variant_kind(enum_def)\n }\n \n-#[auto_serialize]\n-enum enum_def = { variants: ~[variant], common: Option<@struct_def> };\n+#[auto_serialize2]\n+#[auto_deserialize2]\n+type enum_def_ = { variants: ~[variant], common: Option<@struct_def> };\n+\n+#[auto_serialize2]\n+#[auto_deserialize2]\n+enum enum_def = enum_def_;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type variant_ = {name: ident, attrs: ~[attribute], kind: variant_kind,\n                  id: node_id, disr_expr: Option<@expr>, vis: visibility};\n \n-#[auto_serialize]\n type variant = spanned<variant_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type path_list_ident_ = {name: ident, id: node_id};\n \n-#[auto_serialize]\n type path_list_ident = spanned<path_list_ident_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum namespace { module_ns, type_value_ns }\n \n impl namespace : cmp::Eq {\n@@ -1304,10 +1352,10 @@ impl namespace : cmp::Eq {\n     pure fn ne(other: &namespace) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n type view_path = spanned<view_path_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum view_path_ {\n \n     // quux = foo::bar::baz\n@@ -1324,25 +1372,27 @@ enum view_path_ {\n     view_path_list(@path, ~[path_list_ident], node_id)\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type view_item = {node: view_item_, attrs: ~[attribute],\n                   vis: visibility, span: span};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum view_item_ {\n     view_item_use(ident, ~[@meta_item], node_id),\n     view_item_import(~[@view_path]),\n     view_item_export(~[@view_path])\n }\n \n // Meta-data associated with an item\n-#[auto_serialize]\n type attribute = spanned<attribute_>;\n \n // Distinguishes between attributes that decorate items and attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum attr_style { attr_outer, attr_inner, }\n \n impl attr_style : cmp::Eq {\n@@ -1353,7 +1403,8 @@ impl attr_style : cmp::Eq {\n }\n \n // doc-comments are promoted to attributes that have is_sugared_doc = true\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type attribute_ = {style: attr_style, value: meta_item, is_sugared_doc: bool};\n \n /*\n@@ -1365,10 +1416,12 @@ type attribute_ = {style: attr_style, value: meta_item, is_sugared_doc: bool};\n   conceptually, the impl_id stands in for the pair of (this class, this\n   trait)\n  */\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type trait_ref = {path: @path, ref_id: node_id, impl_id: node_id};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum visibility { public, private, inherited }\n \n impl visibility : cmp::Eq {\n@@ -1385,23 +1438,25 @@ impl visibility : cmp::Eq {\n     pure fn ne(other: &visibility) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type struct_field_ = {\n     kind: struct_field_kind,\n     id: node_id,\n     ty: @ty\n };\n \n-#[auto_serialize]\n type struct_field = spanned<struct_field_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum struct_field_kind {\n     named_field(ident, class_mutability, visibility),\n     unnamed_field   // element of a tuple-like struct\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type struct_def = {\n     traits: ~[@trait_ref],   /* traits this struct implements */\n     fields: ~[@struct_field], /* fields */\n@@ -1417,12 +1472,14 @@ type struct_def = {\n   FIXME (#3300): Should allow items to be anonymous. Right now\n   we just use dummy names for anon items.\n  */\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type item = {ident: ident, attrs: ~[attribute],\n              id: node_id, node: item_,\n              vis: visibility, span: span};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum item_ {\n     item_const(@ty, @expr),\n     item_fn(fn_decl, purity, ~[ty_param], blk),\n@@ -1439,7 +1496,8 @@ enum item_ {\n     item_mac(mac),\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum class_mutability { class_mutable, class_immutable }\n \n impl class_mutability : to_bytes::IterBytes {\n@@ -1460,26 +1518,27 @@ impl class_mutability : cmp::Eq {\n     pure fn ne(other: &class_mutability) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n type class_ctor = spanned<class_ctor_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type class_ctor_ = {id: node_id,\n                     attrs: ~[attribute],\n                     self_id: node_id,\n                     dec: fn_decl,\n                     body: blk};\n \n-#[auto_serialize]\n type class_dtor = spanned<class_dtor_>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type class_dtor_ = {id: node_id,\n                     attrs: ~[attribute],\n                     self_id: node_id,\n                     body: blk};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type foreign_item =\n     {ident: ident,\n      attrs: ~[attribute],\n@@ -1488,7 +1547,8 @@ type foreign_item =\n      span: span,\n      vis: visibility};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, ~[ty_param]),\n     foreign_item_const(@ty)\n@@ -1497,7 +1557,8 @@ enum foreign_item_ {\n // The data we save and restore about an inlined item or method.  This is not\n // part of the AST that we parse from a file, but it becomes part of the tree\n // that we trans.\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),"}, {"sha": "47cbdb7ac6cbbc8b5e05fdadf65dce0ff98be078", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=e1c517ca4815273285ac5699a88ccf0bcdb6103e", "patch": "@@ -406,7 +406,8 @@ fn dtor_dec() -> fn_decl {\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type id_range = {min: node_id, max: node_id};\n \n fn empty(range: id_range) -> bool {"}, {"sha": "53880baea9b871f4de468a79e0c43b567dd34b41", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e1c517ca4815273285ac5699a88ccf0bcdb6103e", "patch": "@@ -54,7 +54,7 @@ enum syntax_extension {\n     // macro_defining() is obsolete, remove when #old_macros go away.\n     macro_defining(macro_definer),\n \n-    // #[auto_serialize] and such. will probably survive death of #old_macros\n+    // #[auto_serialize2] and such. will probably survive death of #old_macros\n     item_decorator(item_decorator),\n \n     // Token-tree expanders"}, {"sha": "2d0b2f4c80ab5947d3cf170b452c8e94fd7b997d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e1c517ca4815273285ac5699a88ccf0bcdb6103e", "patch": "@@ -124,7 +124,7 @@ fn expand_expr(exts: HashMap<~str, syntax_extension>, cx: ext_ctxt,\n }\n \n // This is a secondary mechanism for invoking syntax extensions on items:\n-// \"decorator\" attributes, such as #[auto_serialize]. These are invoked by an\n+// \"decorator\" attributes, such as #[auto_serialize2]. These are invoked by an\n // attribute prefixing an item, and are interpreted by feeding the item\n // through the named attribute _as a syntax extension_ and splicing in the\n // resulting item vec into place in favour of the decorator. Note that"}, {"sha": "19e79a4ae7a94d571fecd6659ac1369e5e499f55", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e1c517ca4815273285ac5699a88ccf0bcdb6103e", "patch": "@@ -1,18 +1,9 @@\n use util::interner;\n use util::interner::interner;\n use std::map::HashMap;\n-use std::serialization::{Serializer,\n-                            Deserializer,\n-                            serialize_uint,\n-                            deserialize_uint,\n-                            serialize_i64,\n-                            deserialize_i64,\n-                            serialize_u64,\n-                            deserialize_u64,\n-                            serialize_bool,\n-                            deserialize_bool};\n-\n-#[auto_serialize]\n+\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum binop {\n     PLUS,\n     MINUS,\n@@ -26,7 +17,8 @@ enum binop {\n     SHR,\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum token {\n     /* Expression-operator symbols. */\n     EQ,\n@@ -83,7 +75,8 @@ enum token {\n     EOF,\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n /// For interpolation during macro expansion.\n enum nonterminal {\n     nt_item(@ast::item),"}, {"sha": "52813eb6b75d98f220e300ede2d0a5f13f7133f7", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=e1c517ca4815273285ac5699a88ccf0bcdb6103e", "patch": "@@ -1,6 +1,6 @@\n // Searching for information from the cstore\n \n-use std::{ebml};\n+use std::ebml2;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_map;\n@@ -136,7 +136,7 @@ fn get_field_type(tcx: ty::ctxt, class_id: ast::def_id,\n                   def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n-    let all_items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n+    let all_items = ebml2::get_doc(ebml2::Doc(cdata.data), tag_items);\n     debug!(\"Looking up %?\", class_id);\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),"}, {"sha": "197e567ab2f88d490eb58de797160dc80803ec40", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 122, "deletions": 122, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=e1c517ca4815273285ac5699a88ccf0bcdb6103e", "patch": "@@ -1,7 +1,8 @@\n // Decoding metadata from a single crate's metadata\n \n-use std::{ebml, map};\n+use std::{ebml2, map};\n use std::map::HashMap;\n+use std::serialization2::deserialize;\n use io::WriterUtil;\n use dvec::DVec;\n use syntax::{ast, ast_util};\n@@ -63,25 +64,25 @@ export translate_def_id;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash(d: ebml::Doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n-   Option<ebml::Doc> {\n-    let index = ebml::get_doc(d, tag_index);\n-    let table = ebml::get_doc(index, tag_index_table);\n+fn lookup_hash(d: ebml2::Doc, eq_fn: fn(x:&[u8]) -> bool, hash: uint) ->\n+   Option<ebml2::Doc> {\n+    let index = ebml2::get_doc(d, tag_index);\n+    let table = ebml2::get_doc(index, tag_index_table);\n     let hash_pos = table.start + hash % 256u * 4u;\n     let pos = io::u64_from_be_bytes(*d.data, hash_pos, 4u) as uint;\n-    let {tag:_, doc:bucket} = ebml::doc_at(d.data, pos);\n+    let tagged_doc = ebml2::doc_at(d.data, pos);\n \n     let belt = tag_index_buckets_bucket_elt;\n-    for ebml::tagged_docs(bucket, belt) |elt| {\n+    for ebml2::tagged_docs(tagged_doc.doc, belt) |elt| {\n         let pos = io::u64_from_be_bytes(*elt.data, elt.start, 4u) as uint;\n         if eq_fn(vec::view(*elt.data, elt.start + 4u, elt.end)) {\n-            return Some(ebml::doc_at(d.data, pos).doc);\n+            return Some(ebml2::doc_at(d.data, pos).doc);\n         }\n     };\n     None\n }\n \n-fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n+fn maybe_find_item(item_id: int, items: ebml2::Doc) -> Option<ebml2::Doc> {\n     fn eq_item(bytes: &[u8], item_id: int) -> bool {\n         return io::u64_from_be_bytes(vec::view(bytes, 0u, 4u), 0u, 4u) as int\n             == item_id;\n@@ -91,14 +92,14 @@ fn maybe_find_item(item_id: int, items: ebml::Doc) -> Option<ebml::Doc> {\n                 item_id.hash() as uint)\n }\n \n-fn find_item(item_id: int, items: ebml::Doc) -> ebml::Doc {\n+fn find_item(item_id: int, items: ebml2::Doc) -> ebml2::Doc {\n     return maybe_find_item(item_id, items).get();\n }\n \n-// Looks up an item in the given metadata and returns an ebml doc pointing\n+// Looks up an item in the given metadata and returns an ebml2 doc pointing\n // to the item data.\n-fn lookup_item(item_id: int, data: @~[u8]) -> ebml::Doc {\n-    let items = ebml::get_doc(ebml::Doc(data), tag_items);\n+fn lookup_item(item_id: int, data: @~[u8]) -> ebml2::Doc {\n+    let items = ebml2::get_doc(ebml2::Doc(data), tag_items);\n     match maybe_find_item(item_id, items) {\n        None => fail(fmt!(\"lookup_item: id not found: %d\", item_id)),\n        Some(d) => d\n@@ -136,9 +137,9 @@ impl Family : cmp::Eq {\n     pure fn ne(other: &Family) -> bool { !self.eq(other) }\n }\n \n-fn item_family(item: ebml::Doc) -> Family {\n-    let fam = ebml::get_doc(item, tag_items_data_item_family);\n-    match ebml::doc_as_u8(fam) as char {\n+fn item_family(item: ebml2::Doc) -> Family {\n+    let fam = ebml2::get_doc(item, tag_items_data_item_family);\n+    match ebml2::doc_as_u8(fam) as char {\n       'c' => Const,\n       'f' => Fn,\n       'u' => UnsafeFn,\n@@ -164,78 +165,78 @@ fn item_family(item: ebml::Doc) -> Family {\n     }\n }\n \n-fn item_symbol(item: ebml::Doc) -> ~str {\n-    let sym = ebml::get_doc(item, tag_items_data_item_symbol);\n-    return str::from_bytes(ebml::doc_data(sym));\n+fn item_symbol(item: ebml2::Doc) -> ~str {\n+    let sym = ebml2::get_doc(item, tag_items_data_item_symbol);\n+    return str::from_bytes(ebml2::doc_data(sym));\n }\n \n-fn item_parent_item(d: ebml::Doc) -> Option<ast::def_id> {\n-    for ebml::tagged_docs(d, tag_items_data_parent_item) |did| {\n-        return Some(ebml::with_doc_data(did, |d| parse_def_id(d)));\n+fn item_parent_item(d: ebml2::Doc) -> Option<ast::def_id> {\n+    for ebml2::tagged_docs(d, tag_items_data_parent_item) |did| {\n+        return Some(ebml2::with_doc_data(did, |d| parse_def_id(d)));\n     }\n     None\n }\n \n-fn item_def_id(d: ebml::Doc, cdata: cmd) -> ast::def_id {\n-    let tagdoc = ebml::get_doc(d, tag_def_id);\n-    return translate_def_id(cdata, ebml::with_doc_data(tagdoc,\n+fn item_def_id(d: ebml2::Doc, cdata: cmd) -> ast::def_id {\n+    let tagdoc = ebml2::get_doc(d, tag_def_id);\n+    return translate_def_id(cdata, ebml2::with_doc_data(tagdoc,\n                                                     |d| parse_def_id(d)));\n }\n \n-fn each_reexport(d: ebml::Doc, f: fn(ebml::Doc) -> bool) {\n-    for ebml::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n+fn each_reexport(d: ebml2::Doc, f: fn(ebml2::Doc) -> bool) {\n+    for ebml2::tagged_docs(d, tag_items_data_item_reexport) |reexport_doc| {\n         if !f(reexport_doc) {\n             return;\n         }\n     }\n }\n \n-fn field_mutability(d: ebml::Doc) -> ast::class_mutability {\n+fn field_mutability(d: ebml2::Doc) -> ast::class_mutability {\n     // Use maybe_get_doc in case it's a method\n     option::map_default(\n-        &ebml::maybe_get_doc(d, tag_class_mut),\n+        &ebml2::maybe_get_doc(d, tag_class_mut),\n         ast::class_immutable,\n         |d| {\n-            match ebml::doc_as_u8(*d) as char {\n+            match ebml2::doc_as_u8(*d) as char {\n               'm' => ast::class_mutable,\n               _   => ast::class_immutable\n             }\n         })\n }\n \n-fn variant_disr_val(d: ebml::Doc) -> Option<int> {\n-    do option::chain(ebml::maybe_get_doc(d, tag_disr_val)) |val_doc| {\n-        int::parse_bytes(ebml::doc_data(val_doc), 10u)\n+fn variant_disr_val(d: ebml2::Doc) -> Option<int> {\n+    do option::chain(ebml2::maybe_get_doc(d, tag_disr_val)) |val_doc| {\n+        int::parse_bytes(ebml2::doc_data(val_doc), 10u)\n     }\n }\n \n-fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n-    let tp = ebml::get_doc(doc, tag_items_data_item_type);\n+fn doc_type(doc: ebml2::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n+    let tp = ebml2::get_doc(doc, tag_items_data_item_type);\n     parse_ty_data(tp.data, cdata.cnum, tp.start, tcx, |did| {\n         translate_def_id(cdata, did)\n     })\n }\n \n-fn item_type(item_id: ast::def_id, item: ebml::Doc,\n+fn item_type(item_id: ast::def_id, item: ebml2::Doc,\n              tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let t = doc_type(item, tcx, cdata);\n     if family_names_type(item_family(item)) {\n         ty::mk_with_id(tcx, t, item_id)\n     } else { t }\n }\n \n-fn item_impl_traits(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n+fn item_impl_traits(item: ebml2::Doc, tcx: ty::ctxt, cdata: cmd) -> ~[ty::t] {\n     let mut results = ~[];\n-    for ebml::tagged_docs(item, tag_impl_trait) |ity| {\n+    for ebml2::tagged_docs(item, tag_impl_trait) |ity| {\n         results.push(doc_type(ity, tcx, cdata));\n     };\n     results\n }\n \n-fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n+fn item_ty_param_bounds(item: ebml2::Doc, tcx: ty::ctxt, cdata: cmd)\n     -> @~[ty::param_bounds] {\n     let mut bounds = ~[];\n-    for ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n+    for ebml2::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n         let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, |did| {\n             translate_def_id(cdata, did)\n         });\n@@ -244,43 +245,42 @@ fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n     @bounds\n }\n \n-fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n-    ebml::maybe_get_doc(item, tag_region_param).map(|doc| {\n-        let d = ebml::ebml_deserializer(*doc);\n-        ty::deserialize_region_variance(d)\n+fn item_ty_region_param(item: ebml2::Doc) -> Option<ty::region_variance> {\n+    ebml2::maybe_get_doc(item, tag_region_param).map(|doc| {\n+        deserialize(&ebml2::Deserializer(*doc))\n     })\n }\n \n-fn item_ty_param_count(item: ebml::Doc) -> uint {\n+fn item_ty_param_count(item: ebml2::Doc) -> uint {\n     let mut n = 0u;\n-    ebml::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n+    ebml2::tagged_docs(item, tag_items_data_item_ty_param_bounds,\n                       |_p| { n += 1u; true } );\n     n\n }\n \n-fn enum_variant_ids(item: ebml::Doc, cdata: cmd) -> ~[ast::def_id] {\n+fn enum_variant_ids(item: ebml2::Doc, cdata: cmd) -> ~[ast::def_id] {\n     let mut ids: ~[ast::def_id] = ~[];\n     let v = tag_items_data_item_variant;\n-    for ebml::tagged_docs(item, v) |p| {\n-        let ext = ebml::with_doc_data(p, |d| parse_def_id(d));\n+    for ebml2::tagged_docs(item, v) |p| {\n+        let ext = ebml2::with_doc_data(p, |d| parse_def_id(d));\n         ids.push({crate: cdata.cnum, node: ext.node});\n     };\n     return ids;\n }\n \n-fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n-    let path_doc = ebml::get_doc(item_doc, tag_path);\n+fn item_path(intr: @ident_interner, item_doc: ebml2::Doc) -> ast_map::path {\n+    let path_doc = ebml2::get_doc(item_doc, tag_path);\n \n-    let len_doc = ebml::get_doc(path_doc, tag_path_len);\n-    let len = ebml::doc_as_u32(len_doc) as uint;\n+    let len_doc = ebml2::get_doc(path_doc, tag_path_len);\n+    let len = ebml2::doc_as_u32(len_doc) as uint;\n \n     let mut result = vec::with_capacity(len);\n-    for ebml::docs(path_doc) |tag, elt_doc| {\n+    for ebml2::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n-            let str = ebml::doc_as_str(elt_doc);\n+            let str = ebml2::doc_as_str(elt_doc);\n             result.push(ast_map::path_mod(intr.intern(@str)));\n         } else if tag == tag_path_elt_name {\n-            let str = ebml::doc_as_str(elt_doc);\n+            let str = ebml2::doc_as_str(elt_doc);\n             result.push(ast_map::path_name(intr.intern(@str)));\n         } else {\n             // ignore tag_path_len element\n@@ -290,12 +290,12 @@ fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n     return result;\n }\n \n-fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::ident {\n-    let name = ebml::get_doc(item, tag_paths_data_name);\n-    intr.intern(@str::from_bytes(ebml::doc_data(name)))\n+fn item_name(intr: @ident_interner, item: ebml2::Doc) -> ast::ident {\n+    let name = ebml2::get_doc(item, tag_paths_data_name);\n+    intr.intern(@str::from_bytes(ebml2::doc_data(name)))\n }\n \n-fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::crate_num)\n+fn item_to_def_like(item: ebml2::Doc, did: ast::def_id, cnum: ast::crate_num)\n         -> def_like {\n     let fam = item_family(item);\n     match fam {\n@@ -367,10 +367,10 @@ fn get_impl_traits(cdata: cmd, id: ast::node_id, tcx: ty::ctxt) -> ~[ty::t] {\n \n fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                    name: ast::ident) -> ast::def_id {\n-    let items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n+    let items = ebml2::get_doc(ebml2::Doc(cdata.data), tag_items);\n     let mut found = None;\n-    for ebml::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n-        let m_did = ebml::with_doc_data(mid, |d| parse_def_id(d));\n+    for ebml2::tagged_docs(find_item(id, items), tag_item_impl_method) |mid| {\n+        let m_did = ebml2::with_doc_data(mid, |d| parse_def_id(d));\n         if item_name(intr, find_item(m_did.node, items)) == name {\n             found = Some(translate_def_id(cdata, m_did));\n         }\n@@ -380,14 +380,14 @@ fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n \n fn get_class_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                     name: ast::ident) -> ast::def_id {\n-    let items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n+    let items = ebml2::get_doc(ebml2::Doc(cdata.data), tag_items);\n     let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n       Some(it) => it,\n       None => fail (fmt!(\"get_class_method: class id not found \\\n                               when looking up method %s\", *intr.get(name)))\n     };\n-    for ebml::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n+    for ebml2::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n         let m_did = item_def_id(mid, cdata);\n         if item_name(intr, mid) == name {\n             found = Some(m_did);\n@@ -401,16 +401,16 @@ fn get_class_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n }\n \n fn class_dtor(cdata: cmd, id: ast::node_id) -> Option<ast::def_id> {\n-    let items = ebml::get_doc(ebml::Doc(cdata.data), tag_items);\n+    let items = ebml2::get_doc(ebml2::Doc(cdata.data), tag_items);\n     let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n             Some(it) => it,\n             None     => fail (fmt!(\"class_dtor: class id not found \\\n               when looking up dtor for %d\", id))\n     };\n-    for ebml::tagged_docs(cls_items, tag_item_dtor) |doc| {\n-         let doc1 = ebml::get_doc(doc, tag_def_id);\n-         let did = ebml::with_doc_data(doc1, |d| parse_def_id(d));\n+    for ebml2::tagged_docs(cls_items, tag_item_dtor) |doc| {\n+         let doc1 = ebml2::get_doc(doc, tag_def_id);\n+         let did = ebml2::with_doc_data(doc1, |d| parse_def_id(d));\n          found = Some(translate_def_id(cdata, did));\n     };\n     found\n@@ -452,14 +452,14 @@ fn path_entry(path_string: ~str, def_like: def_like) -> path_entry {\n \n /// Iterates over all the paths in the given crate.\n fn each_path(intr: @ident_interner, cdata: cmd, f: fn(path_entry) -> bool) {\n-    let root = ebml::Doc(cdata.data);\n-    let items = ebml::get_doc(root, tag_items);\n-    let items_data = ebml::get_doc(items, tag_items_data);\n+    let root = ebml2::Doc(cdata.data);\n+    let items = ebml2::get_doc(root, tag_items);\n+    let items_data = ebml2::get_doc(items, tag_items_data);\n \n     let mut broken = false;\n \n     // First, go through all the explicit items.\n-    for ebml::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n+    for ebml2::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n         if !broken {\n             let path = ast_map::path_to_str_with_sep(\n                 item_path(intr, item_doc), ~\"::\", intr);\n@@ -482,16 +482,16 @@ fn each_path(intr: @ident_interner, cdata: cmd, f: fn(path_entry) -> bool) {\n             for each_reexport(item_doc) |reexport_doc| {\n                 if !broken {\n                     let def_id_doc =\n-                        ebml::get_doc(reexport_doc,\n+                        ebml2::get_doc(reexport_doc,\n                             tag_items_data_item_reexport_def_id);\n                     let def_id =\n-                        ebml::with_doc_data(def_id_doc, |d| parse_def_id(d));\n+                        ebml2::with_doc_data(def_id_doc, |d| parse_def_id(d));\n                     let def_id = translate_def_id(cdata, def_id);\n \n                     let reexport_name_doc =\n-                        ebml::get_doc(reexport_doc,\n+                        ebml2::get_doc(reexport_doc,\n                                       tag_items_data_item_reexport_name);\n-                    let reexport_name = ebml::doc_as_str(reexport_name_doc);\n+                    let reexport_name = ebml2::doc_as_str(reexport_name_doc);\n \n                     let reexport_path;\n                     if path == ~\"\" {\n@@ -540,7 +540,7 @@ type decode_inlined_item = fn(\n     cdata: cstore::crate_metadata,\n     tcx: ty::ctxt,\n     path: ast_map::path,\n-    par_doc: ebml::Doc) -> Option<ast::inlined_item>;\n+    par_doc: ebml2::Doc) -> Option<ast::inlined_item>;\n \n fn maybe_get_item_ast(intr: @ident_interner, cdata: cmd, tcx: ty::ctxt,\n                       id: ast::node_id,\n@@ -571,7 +571,7 @@ fn maybe_get_item_ast(intr: @ident_interner, cdata: cmd, tcx: ty::ctxt,\n fn get_enum_variants(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n                      tcx: ty::ctxt) -> ~[ty::variant_info] {\n     let data = cdata.data;\n-    let items = ebml::get_doc(ebml::Doc(data), tag_items);\n+    let items = ebml2::get_doc(ebml2::Doc(data), tag_items);\n     let item = find_item(id, items);\n     let mut infos: ~[ty::variant_info] = ~[];\n     let variant_ids = enum_variant_ids(item, cdata);\n@@ -609,7 +609,7 @@ type method_info = {\n \n type _impl = {did: ast::def_id, ident: ast::ident, methods: ~[@method_info]};\n \n-fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n+fn get_self_ty(item: ebml2::Doc) -> ast::self_ty_ {\n     fn get_mutability(ch: u8) -> ast::mutability {\n         match ch as char {\n             'i' => { ast::m_imm }\n@@ -621,8 +621,8 @@ fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n         }\n     }\n \n-    let self_type_doc = ebml::get_doc(item, tag_item_trait_method_self_ty);\n-    let string = ebml::doc_as_str(self_type_doc);\n+    let self_type_doc = ebml2::get_doc(item, tag_item_trait_method_self_ty);\n+    let string = ebml2::doc_as_str(self_type_doc);\n \n     let self_ty_kind = string[0];\n     match self_ty_kind as char {\n@@ -638,11 +638,11 @@ fn get_self_ty(item: ebml::Doc) -> ast::self_ty_ {\n     }\n }\n \n-fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n+fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml2::Doc,\n                      base_tps: uint) -> ~[@method_info] {\n     let mut rslt = ~[];\n-    for ebml::tagged_docs(item, tag_item_impl_method) |doc| {\n-        let m_did = ebml::with_doc_data(doc, |d| parse_def_id(d));\n+    for ebml2::tagged_docs(item, tag_item_impl_method) |doc| {\n+        let m_did = ebml2::with_doc_data(doc, |d| parse_def_id(d));\n         let mth_item = lookup_item(m_did.node, cdata.data);\n         let self_ty = get_self_ty(mth_item);\n         rslt.push(@{did: translate_def_id(cdata, m_did),\n@@ -662,8 +662,8 @@ fn get_impls_for_mod(intr: @ident_interner, cdata: cmd,\n     let data = cdata.data;\n     let mod_item = lookup_item(m_id, data);\n     let mut result = ~[];\n-    for ebml::tagged_docs(mod_item, tag_mod_impl) |doc| {\n-        let did = ebml::with_doc_data(doc, |d| parse_def_id(d));\n+    for ebml2::tagged_docs(mod_item, tag_mod_impl) |doc| {\n+        let did = ebml2::with_doc_data(doc, |d| parse_def_id(d));\n         let local_did = translate_def_id(cdata, did);\n         debug!(\"(get impls for mod) getting did %? for '%?'\",\n                local_did, name);\n@@ -690,7 +690,7 @@ fn get_trait_methods(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    for ebml::tagged_docs(item, tag_item_trait_method) |mth| {\n+    for ebml2::tagged_docs(item, tag_item_trait_method) |mth| {\n         let bounds = item_ty_param_bounds(mth, tcx, cdata);\n         let name = item_name(intr, mth);\n         let ty = doc_type(mth, tcx, cdata);\n@@ -722,7 +722,7 @@ fn get_method_names_if_trait(intr: @ident_interner, cdata: cmd,\n     }\n \n     let resulting_methods = @DVec();\n-    for ebml::tagged_docs(item, tag_item_trait_method) |method| {\n+    for ebml2::tagged_docs(item, tag_item_trait_method) |method| {\n         resulting_methods.push(\n             (item_name(intr, method), get_self_ty(method)));\n     }\n@@ -734,8 +734,8 @@ fn get_item_attrs(cdata: cmd,\n                   f: fn(~[@ast::meta_item])) {\n \n     let item = lookup_item(node_id, cdata.data);\n-    for ebml::tagged_docs(item, tag_attributes) |attributes| {\n-        for ebml::tagged_docs(attributes, tag_attribute) |attribute| {\n+    for ebml2::tagged_docs(item, tag_attributes) |attributes| {\n+        for ebml2::tagged_docs(attributes, tag_attribute) |attribute| {\n             f(get_meta_items(attribute));\n         }\n     }\n@@ -747,7 +747,7 @@ fn get_class_members(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n-    for ebml::tagged_docs(item, tag_item_field) |an_item| {\n+    for ebml2::tagged_docs(item, tag_item_field) |an_item| {\n        let f = item_family(an_item);\n        if p(f) {\n           let name = item_name(intr, an_item);\n@@ -787,15 +787,15 @@ fn family_names_type(fam: Family) -> bool {\n     match fam { Type | Mod | Trait => true, _ => false }\n }\n \n-fn read_path(d: ebml::Doc) -> {path: ~str, pos: uint} {\n-    let desc = ebml::doc_data(d);\n+fn read_path(d: ebml2::Doc) -> {path: ~str, pos: uint} {\n+    let desc = ebml2::doc_data(d);\n     let pos = io::u64_from_be_bytes(desc, 0u, 4u) as uint;\n     let pathbytes = vec::slice::<u8>(desc, 4u, vec::len::<u8>(desc));\n     let path = str::from_bytes(pathbytes);\n     return {path: path, pos: pos};\n }\n \n-fn describe_def(items: ebml::Doc, id: ast::def_id) -> ~str {\n+fn describe_def(items: ebml2::Doc, id: ast::def_id) -> ~str {\n     if id.crate != ast::local_crate { return ~\"external\"; }\n     let it = match maybe_find_item(id.node, items) {\n         Some(it) => it,\n@@ -830,36 +830,36 @@ fn item_family_to_str(fam: Family) -> ~str {\n     }\n }\n \n-fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n+fn get_meta_items(md: ebml2::Doc) -> ~[@ast::meta_item] {\n     let mut items: ~[@ast::meta_item] = ~[];\n-    for ebml::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n-        let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::from_bytes(ebml::doc_data(nd));\n+    for ebml2::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n+        let nd = ebml2::get_doc(meta_item_doc, tag_meta_item_name);\n+        let n = str::from_bytes(ebml2::doc_data(nd));\n         items.push(attr::mk_word_item(n));\n     };\n-    for ebml::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n-        let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        let vd = ebml::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = str::from_bytes(ebml::doc_data(nd));\n-        let v = str::from_bytes(ebml::doc_data(vd));\n+    for ebml2::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n+        let nd = ebml2::get_doc(meta_item_doc, tag_meta_item_name);\n+        let vd = ebml2::get_doc(meta_item_doc, tag_meta_item_value);\n+        let n = str::from_bytes(ebml2::doc_data(nd));\n+        let v = str::from_bytes(ebml2::doc_data(vd));\n         // FIXME (#623): Should be able to decode meta_name_value variants,\n         // but currently the encoder just drops them\n         items.push(attr::mk_name_value_item_str(n, v));\n     };\n-    for ebml::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n-        let nd = ebml::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = str::from_bytes(ebml::doc_data(nd));\n+    for ebml2::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n+        let nd = ebml2::get_doc(meta_item_doc, tag_meta_item_name);\n+        let n = str::from_bytes(ebml2::doc_data(nd));\n         let subitems = get_meta_items(meta_item_doc);\n         items.push(attr::mk_list_item(n, subitems));\n     };\n     return items;\n }\n \n-fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n+fn get_attributes(md: ebml2::Doc) -> ~[ast::attribute] {\n     let mut attrs: ~[ast::attribute] = ~[];\n-    match ebml::maybe_get_doc(md, tag_attributes) {\n+    match ebml2::maybe_get_doc(md, tag_attributes) {\n       option::Some(attrs_d) => {\n-        for ebml::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n+        for ebml2::tagged_docs(attrs_d, tag_attribute) |attr_doc| {\n             let meta_items = get_meta_items(attr_doc);\n             // Currently it's only possible to have a single meta item on\n             // an attribute\n@@ -877,13 +877,13 @@ fn get_attributes(md: ebml::Doc) -> ~[ast::attribute] {\n }\n \n fn list_meta_items(intr: @ident_interner,\n-                   meta_items: ebml::Doc, out: io::Writer) {\n+                   meta_items: ebml2::Doc, out: io::Writer) {\n     for get_meta_items(meta_items).each |mi| {\n         out.write_str(fmt!(\"%s\\n\", pprust::meta_item_to_str(*mi, intr)));\n     }\n }\n \n-fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: ~str,\n+fn list_crate_attributes(intr: @ident_interner, md: ebml2::Doc, hash: ~str,\n                          out: io::Writer) {\n     out.write_str(fmt!(\"=Crate Attributes (%s)=\\n\", hash));\n \n@@ -895,21 +895,21 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: ~str,\n }\n \n fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n-    return get_attributes(ebml::Doc(data));\n+    return get_attributes(ebml2::Doc(data));\n }\n \n type crate_dep = {cnum: ast::crate_num, name: ast::ident,\n                   vers: ~str, hash: ~str};\n \n fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n-    let cratedoc = ebml::Doc(data);\n-    let depsdoc = ebml::get_doc(cratedoc, tag_crate_deps);\n+    let cratedoc = ebml2::Doc(data);\n+    let depsdoc = ebml2::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n-    fn docstr(doc: ebml::Doc, tag_: uint) -> ~str {\n-        str::from_bytes(ebml::doc_data(ebml::get_doc(doc, tag_)))\n+    fn docstr(doc: ebml2::Doc, tag_: uint) -> ~str {\n+        str::from_bytes(ebml2::doc_data(ebml2::get_doc(doc, tag_)))\n     }\n-    for ebml::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n+    for ebml2::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         deps.push({cnum: crate_num,\n                   name: intr.intern(@docstr(depdoc, tag_crate_dep_name)),\n                   vers: docstr(depdoc, tag_crate_dep_vers),\n@@ -932,9 +932,9 @@ fn list_crate_deps(intr: @ident_interner, data: @~[u8], out: io::Writer) {\n }\n \n fn get_crate_hash(data: @~[u8]) -> ~str {\n-    let cratedoc = ebml::Doc(data);\n-    let hashdoc = ebml::get_doc(cratedoc, tag_crate_hash);\n-    return str::from_bytes(ebml::doc_data(hashdoc));\n+    let cratedoc = ebml2::Doc(data);\n+    let hashdoc = ebml2::get_doc(cratedoc, tag_crate_hash);\n+    return str::from_bytes(ebml2::doc_data(hashdoc));\n }\n \n fn get_crate_vers(data: @~[u8]) -> ~str {\n@@ -988,7 +988,7 @@ fn get_crate_module_paths(intr: @ident_interner, cdata: cmd)\n fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n                        out: io::Writer) {\n     let hash = get_crate_hash(bytes);\n-    let md = ebml::Doc(bytes);\n+    let md = ebml2::Doc(bytes);\n     list_crate_attributes(intr, md, hash, out);\n     list_crate_deps(intr, bytes, out);\n }"}, {"sha": "95696a14156699058d947e210fedcce7442cffb6", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 48, "deletions": 43, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=e1c517ca4815273285ac5699a88ccf0bcdb6103e", "patch": "@@ -2,10 +2,10 @@\n \n use util::ppaux::ty_to_str;\n \n-use std::{ebml, map};\n+use std::{ebml2, map};\n use std::map::HashMap;\n use io::WriterUtil;\n-use ebml::Writer;\n+use ebml2::Serializer;\n use syntax::ast::*;\n use syntax::print::pprust;\n use syntax::{ast_util, visit};\n@@ -40,7 +40,7 @@ export encode_def_id;\n type abbrev_map = map::HashMap<ty::t, tyencode::ty_abbrev>;\n \n type encode_inlined_item = fn@(ecx: @encode_ctxt,\n-                               ebml_w: ebml::Writer,\n+                               ebml_w: ebml2::Serializer,\n                                path: ast_map::path,\n                                ii: ast::inlined_item);\n \n@@ -86,25 +86,25 @@ fn reachable(ecx: @encode_ctxt, id: node_id) -> bool {\n     ecx.reachable.contains_key(id)\n }\n \n-fn encode_name(ecx: @encode_ctxt, ebml_w: ebml::Writer, name: ident) {\n+fn encode_name(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, name: ident) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, ecx.tcx.sess.str_of(name));\n }\n \n-fn encode_def_id(ebml_w: ebml::Writer, id: def_id) {\n+fn encode_def_id(ebml_w: ebml2::Serializer, id: def_id) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n+fn encode_region_param(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n                        it: @ast::item) {\n     let opt_rp = ecx.tcx.region_paramd_items.find(it.id);\n     for opt_rp.each |rp| {\n         do ebml_w.wr_tag(tag_region_param) {\n-            ty::serialize_region_variance(ebml_w, *rp);\n+            (*rp).serialize(&ebml_w);\n         }\n     }\n }\n \n-fn encode_mutability(ebml_w: ebml::Writer, mt: class_mutability) {\n+fn encode_mutability(ebml_w: ebml2::Serializer, mt: class_mutability) {\n     do ebml_w.wr_tag(tag_class_mut) {\n         let val = match mt {\n           class_immutable => 'a',\n@@ -116,7 +116,7 @@ fn encode_mutability(ebml_w: ebml::Writer, mt: class_mutability) {\n \n type entry<T> = {val: T, pos: uint};\n \n-fn add_to_index(ecx: @encode_ctxt, ebml_w: ebml::Writer, path: &[ident],\n+fn add_to_index(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, path: &[ident],\n                 index: &mut ~[entry<~str>], name: ident) {\n     let mut full_path = ~[];\n     full_path.push_all(path);\n@@ -127,23 +127,24 @@ fn add_to_index(ecx: @encode_ctxt, ebml_w: ebml::Writer, path: &[ident],\n          pos: ebml_w.writer.tell()});\n }\n \n-fn encode_trait_ref(ebml_w: ebml::Writer, ecx: @encode_ctxt, t: @trait_ref) {\n+fn encode_trait_ref(ebml_w: ebml2::Serializer, ecx: @encode_ctxt,\n+                    t: @trait_ref) {\n     ebml_w.start_tag(tag_impl_trait);\n     encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, t.ref_id));\n     ebml_w.end_tag();\n }\n \n \n // Item info table encoding\n-fn encode_family(ebml_w: ebml::Writer, c: char) {\n+fn encode_family(ebml_w: ebml2::Serializer, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n     ebml_w.writer.write(&[c as u8]);\n     ebml_w.end_tag();\n }\n \n fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n-fn encode_ty_type_param_bounds(ebml_w: ebml::Writer, ecx: @encode_ctxt,\n+fn encode_ty_type_param_bounds(ebml_w: ebml2::Serializer, ecx: @encode_ctxt,\n                                params: @~[ty::param_bounds]) {\n     let ty_str_ctxt = @{diag: ecx.diag,\n                         ds: def_to_str,\n@@ -157,21 +158,21 @@ fn encode_ty_type_param_bounds(ebml_w: ebml::Writer, ecx: @encode_ctxt,\n     }\n }\n \n-fn encode_type_param_bounds(ebml_w: ebml::Writer, ecx: @encode_ctxt,\n+fn encode_type_param_bounds(ebml_w: ebml2::Serializer, ecx: @encode_ctxt,\n                             params: ~[ty_param]) {\n     let ty_param_bounds =\n         @params.map(|param| ecx.tcx.ty_param_bounds.get(param.id));\n     encode_ty_type_param_bounds(ebml_w, ecx, ty_param_bounds);\n }\n \n \n-fn encode_variant_id(ebml_w: ebml::Writer, vid: def_id) {\n+fn encode_variant_id(ebml_w: ebml2::Serializer, vid: def_id) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n     ebml_w.writer.write(str::to_bytes(def_to_str(vid)));\n     ebml_w.end_tag();\n }\n \n-fn write_type(ecx: @encode_ctxt, ebml_w: ebml::Writer, typ: ty::t) {\n+fn write_type(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, typ: ty::t) {\n     let ty_str_ctxt =\n         @{diag: ecx.diag,\n           ds: def_to_str,\n@@ -181,7 +182,8 @@ fn write_type(ecx: @encode_ctxt, ebml_w: ebml::Writer, typ: ty::t) {\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n-fn write_vstore(ecx: @encode_ctxt, ebml_w: ebml::Writer, vstore: ty::vstore) {\n+fn write_vstore(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+                vstore: ty::vstore) {\n     let ty_str_ctxt =\n         @{diag: ecx.diag,\n           ds: def_to_str,\n@@ -191,13 +193,13 @@ fn write_vstore(ecx: @encode_ctxt, ebml_w: ebml::Writer, vstore: ty::vstore) {\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n-fn encode_type(ecx: @encode_ctxt, ebml_w: ebml::Writer, typ: ty::t) {\n+fn encode_type(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n     ebml_w.end_tag();\n }\n \n-fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::Writer, id: node_id) {\n+fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     let sym = match ecx.item_symbols.find(id) {\n       Some(x) => x,\n@@ -210,25 +212,27 @@ fn encode_symbol(ecx: @encode_ctxt, ebml_w: ebml::Writer, id: node_id) {\n     ebml_w.end_tag();\n }\n \n-fn encode_discriminant(ecx: @encode_ctxt, ebml_w: ebml::Writer, id: node_id) {\n+fn encode_discriminant(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+                       id: node_id) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     ebml_w.writer.write(str::to_bytes(ecx.discrim_symbols.get(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: ebml::Writer, disr_val: int) {\n+fn encode_disr_val(_ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+                   disr_val: int) {\n     ebml_w.start_tag(tag_disr_val);\n     ebml_w.writer.write(str::to_bytes(int::to_str(disr_val,10u)));\n     ebml_w.end_tag();\n }\n \n-fn encode_parent_item(ebml_w: ebml::Writer, id: def_id) {\n+fn encode_parent_item(ebml_w: ebml2::Serializer, id: def_id) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n     ebml_w.writer.write(str::to_bytes(def_to_str(id)));\n     ebml_w.end_tag();\n }\n \n-fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n+fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n                             id: node_id, variants: ~[variant],\n                             path: ast_map::path, index: @mut ~[entry<int>],\n                             ty_params: ~[ty_param]) {\n@@ -265,9 +269,9 @@ fn encode_enum_variant_info(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n     }\n }\n \n-fn encode_path(ecx: @encode_ctxt, ebml_w: ebml::Writer, path: ast_map::path,\n-               name: ast_map::path_elt) {\n-    fn encode_path_elt(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n+fn encode_path(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+               path: ast_map::path, name: ast_map::path_elt) {\n+    fn encode_path_elt(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n                        elt: ast_map::path_elt) {\n         let (tag, name) = match elt {\n           ast_map::path_mod(name) => (tag_path_elt_mod, name),\n@@ -286,7 +290,7 @@ fn encode_path(ecx: @encode_ctxt, ebml_w: ebml::Writer, path: ast_map::path,\n     }\n }\n \n-fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::Writer, md: _mod,\n+fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml2::Serializer, md: _mod,\n                        id: node_id, path: ast_map::path, name: ident) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n@@ -344,15 +348,15 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: ebml::Writer, md: _mod,\n     ebml_w.end_tag();\n }\n \n-fn encode_visibility(ebml_w: ebml::Writer, visibility: visibility) {\n+fn encode_visibility(ebml_w: ebml2::Serializer, visibility: visibility) {\n     encode_family(ebml_w, match visibility {\n         public => 'g',\n         private => 'j',\n         inherited => 'N'\n     });\n }\n \n-fn encode_self_type(ebml_w: ebml::Writer, self_type: ast::self_ty_) {\n+fn encode_self_type(ebml_w: ebml2::Serializer, self_type: ast::self_ty_) {\n     ebml_w.start_tag(tag_item_trait_method_self_ty);\n \n     // Encode the base self type.\n@@ -385,7 +389,7 @@ fn encode_self_type(ebml_w: ebml::Writer, self_type: ast::self_ty_) {\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n+fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n                          id: node_id, path: ast_map::path,\n                          class_tps: ~[ty_param],\n                          fields: ~[@struct_field],\n@@ -441,7 +445,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n }\n \n // This is for encoding info for ctors and dtors\n-fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n+fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n                         id: node_id, ident: ident, path: ast_map::path,\n                         item: Option<inlined_item>, tps: ~[ty_param]) {\n         ebml_w.start_tag(tag_items_data_item);\n@@ -466,7 +470,7 @@ fn encode_info_for_ctor(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n         ebml_w.end_tag();\n }\n \n-fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n+fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n                           impl_path: ast_map::path, should_inline: bool,\n                           parent_id: node_id,\n                           m: @method, all_tps: ~[ty_param]) {\n@@ -516,8 +520,9 @@ fn should_inline(attrs: ~[attribute]) -> bool {\n }\n \n \n-fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n-                        index: @mut ~[entry<int>], path: ast_map::path) {\n+fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n+                        item: @item, index: @mut ~[entry<int>],\n+                        path: ast_map::path) {\n \n     let tcx = ecx.tcx;\n     let must_write =\n@@ -528,7 +533,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n         };\n     if !must_write && !reachable(ecx, item.id) { return; }\n \n-    fn add_to_index_(item: @item, ebml_w: ebml::Writer,\n+    fn add_to_index_(item: @item, ebml_w: ebml2::Serializer,\n                      index: @mut ~[entry<int>]) {\n         index.push({val: item.id, pos: ebml_w.writer.tell()});\n     }\n@@ -805,7 +810,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::Writer, item: @item,\n     }\n }\n \n-fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n+fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n                                 path: ast_map::path, abi: foreign_abi) {\n@@ -838,7 +843,7 @@ fn encode_info_for_foreign_item(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n     ebml_w.end_tag();\n }\n \n-fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n+fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n                          crate: @crate) -> ~[entry<int>] {\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n@@ -893,7 +898,7 @@ fn create_index<T: Copy Hash IterBytes>(index: ~[entry<T>]) ->\n     return buckets_frozen;\n }\n \n-fn encode_index<T>(ebml_w: ebml::Writer, buckets: ~[@~[entry<T>]],\n+fn encode_index<T>(ebml_w: ebml2::Serializer, buckets: ~[@~[entry<T>]],\n                    write_fn: fn(io::Writer, T)) {\n     let writer = ebml_w.writer;\n     ebml_w.start_tag(tag_index);\n@@ -928,7 +933,7 @@ fn write_int(writer: io::Writer, &&n: int) {\n     writer.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: ebml::Writer, mi: meta_item) {\n+fn encode_meta_item(ebml_w: ebml2::Serializer, mi: meta_item) {\n     match mi.node {\n       meta_word(name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n@@ -965,7 +970,7 @@ fn encode_meta_item(ebml_w: ebml::Writer, mi: meta_item) {\n     }\n }\n \n-fn encode_attributes(ebml_w: ebml::Writer, attrs: ~[attribute]) {\n+fn encode_attributes(ebml_w: ebml2::Serializer, attrs: ~[attribute]) {\n     ebml_w.start_tag(tag_attributes);\n     for attrs.each |attr| {\n         ebml_w.start_tag(tag_attribute);\n@@ -1026,7 +1031,7 @@ fn synthesize_crate_attrs(ecx: @encode_ctxt, crate: @crate) -> ~[attribute] {\n     return attrs;\n }\n \n-fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n+fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n                      cstore: cstore::cstore) {\n \n     fn get_ordered_deps(ecx: @encode_ctxt, cstore: cstore::cstore)\n@@ -1072,7 +1077,7 @@ fn encode_crate_deps(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n+fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: ebml2::Serializer,\n                     dep: decoder::crate_dep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_name);\n@@ -1087,7 +1092,7 @@ fn encode_crate_dep(ecx: @encode_ctxt, ebml_w: ebml::Writer,\n     ebml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: ebml::Writer, hash: ~str) {\n+fn encode_hash(ebml_w: ebml2::Serializer, hash: ~str) {\n     ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(str::to_bytes(hash));\n     ebml_w.end_tag();\n@@ -1125,7 +1130,7 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n         type_abbrevs: ty::new_ty_hash()\n      });\n \n-    let ebml_w = ebml::Writer(wr as io::Writer);\n+    let ebml_w = ebml2::Serializer(wr as io::Writer);\n \n     encode_hash(ebml_w, ecx.link_meta.extras_hash);\n "}, {"sha": "39ec58c079ed9e19378022a272ea316d3408874a", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=e1c517ca4815273285ac5699a88ccf0bcdb6103e", "patch": "@@ -7,23 +7,21 @@ use syntax::visit;\n use syntax::ast_map;\n use syntax::ast_util;\n use syntax::codemap::span;\n-use std::ebml;\n-use std::ebml::Writer;\n-use std::ebml::get_doc;\n+use std::ebml2;\n+use std::ebml2::Serializer;\n+use std::ebml2::get_doc;\n use std::map::HashMap;\n-use std::serialization::Serializer;\n-use std::serialization::Deserializer;\n-use std::serialization::SerializerHelpers;\n-use std::serialization::DeserializerHelpers;\n-use std::prettyprint::Serializer;\n+use std::serialization2;\n+use std::serialization2::{Serializable,\n+                          SerializerHelpers,\n+                          DeserializerHelpers,\n+                          deserialize};\n use middle::{ty, typeck};\n use middle::typeck::{method_origin, method_map_entry,\n                      vtable_res,\n                      vtable_origin};\n use driver::session::session;\n-use middle::freevars::{freevar_entry,\n-                          serialize_freevar_entry,\n-                          deserialize_freevar_entry};\n+use middle::freevars::freevar_entry;\n use c = metadata::common;\n use e = metadata::encoder;\n use cstore = metadata::cstore;\n@@ -76,7 +74,7 @@ trait tr {\n // Top-level methods.\n \n fn encode_inlined_item(ecx: @e::encode_ctxt,\n-                       ebml_w: ebml::Writer,\n+                       ebml_w: ebml2::Serializer,\n                        path: ast_map::path,\n                        ii: ast::inlined_item,\n                        maps: maps) {\n@@ -87,7 +85,7 @@ fn encode_inlined_item(ecx: @e::encode_ctxt,\n \n     let id_range = ast_util::compute_id_range_for_inlined_item(ii);\n     do ebml_w.wr_tag(c::tag_ast as uint) {\n-        ast_util::serialize_id_range(ebml_w, id_range);\n+        id_range.serialize(&ebml_w);\n         encode_ast(ebml_w, simplify_ast(ii));\n         encode_side_tables_for_ii(ecx, maps, ebml_w, ii);\n     }\n@@ -102,15 +100,15 @@ fn decode_inlined_item(cdata: cstore::crate_metadata,\n                        tcx: ty::ctxt,\n                        maps: maps,\n                        path: ast_map::path,\n-                       par_doc: ebml::Doc) -> Option<ast::inlined_item> {\n+                       par_doc: ebml2::Doc) -> Option<ast::inlined_item> {\n     let dcx = @{cdata: cdata, tcx: tcx, maps: maps};\n     match par_doc.opt_child(c::tag_ast) {\n       None => None,\n       Some(ast_doc) => {\n         debug!(\"> Decoding inlined fn: %s::?\",\n                ast_map::path_to_str(path, tcx.sess.parse_sess.interner));\n-        let ast_dsr = ebml::ebml_deserializer(ast_doc);\n-        let from_id_range = ast_util::deserialize_id_range(ast_dsr);\n+        let ast_dsr = &ebml2::Deserializer(ast_doc);\n+        let from_id_range = deserialize(ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n         let xcx = extended_decode_ctxt_(@{dcx: dcx,\n                                           from_id_range: from_id_range,\n@@ -187,20 +185,20 @@ trait def_id_serializer_helpers {\n     fn emit_def_id(did: ast::def_id);\n }\n \n-impl<S: Serializer> S: def_id_serializer_helpers {\n+impl<S: serialization2::Serializer> S: def_id_serializer_helpers {\n     fn emit_def_id(did: ast::def_id) {\n-        ast::serialize_def_id(self, did)\n+        did.serialize(&self)\n     }\n }\n \n trait def_id_deserializer_helpers {\n     fn read_def_id(xcx: extended_decode_ctxt) -> ast::def_id;\n }\n \n-impl<D: Deserializer> D: def_id_deserializer_helpers {\n+impl<D: serialization2::Deserializer> D: def_id_deserializer_helpers {\n \n     fn read_def_id(xcx: extended_decode_ctxt) -> ast::def_id {\n-        let did = ast::deserialize_def_id(self);\n+        let did: ast::def_id = deserialize(&self);\n         did.tr(xcx)\n     }\n }\n@@ -220,9 +218,9 @@ impl<D: Deserializer> D: def_id_deserializer_helpers {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: ebml::Writer, item: ast::inlined_item) {\n+fn encode_ast(ebml_w: ebml2::Serializer, item: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n-        ast::serialize_inlined_item(ebml_w, item)\n+        item.serialize(&ebml_w)\n     }\n }\n \n@@ -280,10 +278,10 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n     }\n }\n \n-fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n+fn decode_ast(par_doc: ebml2::Doc) -> ast::inlined_item {\n     let chi_doc = par_doc[c::tag_tree as uint];\n-    let d = ebml::ebml_deserializer(chi_doc);\n-    ast::deserialize_inlined_item(d)\n+    let d = &ebml2::Deserializer(chi_doc);\n+    deserialize(d)\n }\n \n fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n@@ -334,13 +332,13 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n // ______________________________________________________________________\n // Encoding and decoding of ast::def\n \n-fn encode_def(ebml_w: ebml::Writer, def: ast::def) {\n-    ast::serialize_def(ebml_w, def)\n+fn encode_def(ebml_w: ebml2::Serializer, def: ast::def) {\n+    def.serialize(&ebml_w)\n }\n \n-fn decode_def(xcx: extended_decode_ctxt, doc: ebml::Doc) -> ast::def {\n-    let dsr = ebml::ebml_deserializer(doc);\n-    let def = ast::deserialize_def(dsr);\n+fn decode_def(xcx: extended_decode_ctxt, doc: ebml2::Doc) -> ast::def {\n+    let dsr = &ebml2::Deserializer(doc);\n+    let def: ast::def = deserialize(dsr);\n     def.tr(xcx)\n }\n \n@@ -425,17 +423,17 @@ impl ty::bound_region: tr {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(ebml_w: ebml::Writer, fv: freevar_entry) {\n-    serialize_freevar_entry(ebml_w, fv)\n+fn encode_freevar_entry(ebml_w: ebml2::Serializer, fv: @freevar_entry) {\n+    (*fv).serialize(&ebml_w)\n }\n \n trait ebml_deserializer_helper {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry;\n }\n \n-impl ebml::EbmlDeserializer: ebml_deserializer_helper {\n+impl ebml2::Deserializer: ebml_deserializer_helper {\n     fn read_freevar_entry(xcx: extended_decode_ctxt) -> freevar_entry {\n-        let fv = deserialize_freevar_entry(self);\n+        let fv: freevar_entry = deserialize(&self);\n         fv.tr(xcx)\n     }\n }\n@@ -454,28 +452,29 @@ trait read_method_map_entry_helper {\n }\n \n fn serialize_method_map_entry(ecx: @e::encode_ctxt,\n-                              ebml_w: ebml::Writer,\n+                              ebml_w: ebml2::Serializer,\n                               mme: method_map_entry) {\n     do ebml_w.emit_rec {\n-        do ebml_w.emit_rec_field(~\"self_arg\", 0u) {\n+        do ebml_w.emit_field(~\"self_arg\", 0u) {\n             ebml_w.emit_arg(ecx, mme.self_arg);\n         }\n-        do ebml_w.emit_rec_field(~\"origin\", 1u) {\n-            typeck::serialize_method_origin(ebml_w, mme.origin);\n+        do ebml_w.emit_field(~\"origin\", 1u) {\n+            mme.origin.serialize(&ebml_w);\n         }\n     }\n }\n \n-impl ebml::EbmlDeserializer: read_method_map_entry_helper {\n+impl ebml2::Deserializer: read_method_map_entry_helper {\n     fn read_method_map_entry(xcx: extended_decode_ctxt) -> method_map_entry {\n         do self.read_rec {\n             {self_arg:\n-                 self.read_rec_field(~\"self_arg\", 0u, || {\n+                 self.read_field(~\"self_arg\", 0u, || {\n                      self.read_arg(xcx)\n                  }),\n              origin:\n-                 self.read_rec_field(~\"origin\", 1u, || {\n-                     typeck::deserialize_method_origin(self).tr(xcx)\n+                 self.read_field(~\"origin\", 1u, || {\n+                     let method_origin: method_origin = deserialize(&self);\n+                     method_origin.tr(xcx)\n                  })}\n         }\n     }\n@@ -504,19 +503,19 @@ impl method_origin: tr {\n // Encoding and decoding vtable_res\n \n fn encode_vtable_res(ecx: @e::encode_ctxt,\n-                     ebml_w: ebml::Writer,\n+                     ebml_w: ebml2::Serializer,\n                      dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic serialization of\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written serialization routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n     do ebml_w.emit_from_vec(*dr) |vtable_origin| {\n-        encode_vtable_origin(ecx, ebml_w, vtable_origin)\n+        encode_vtable_origin(ecx, ebml_w, *vtable_origin)\n     }\n }\n \n fn encode_vtable_origin(ecx: @e::encode_ctxt,\n-                      ebml_w: ebml::Writer,\n+                      ebml_w: ebml2::Serializer,\n                       vtable_origin: typeck::vtable_origin) {\n     do ebml_w.emit_enum(~\"vtable_origin\") {\n         match vtable_origin {\n@@ -563,7 +562,7 @@ trait vtable_deserialization_helpers {\n     fn read_vtable_origin(xcx: extended_decode_ctxt) -> typeck::vtable_origin;\n }\n \n-impl ebml::EbmlDeserializer: vtable_deserialization_helpers {\n+impl ebml2::Deserializer: vtable_deserialization_helpers {\n     fn read_vtable_res(xcx: extended_decode_ctxt) -> typeck::vtable_res {\n         @self.read_to_vec(|| self.read_vtable_origin(xcx) )\n     }\n@@ -640,7 +639,7 @@ trait ebml_writer_helpers {\n     fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty);\n }\n \n-impl ebml::Writer: ebml_writer_helpers {\n+impl ebml2::Serializer: ebml_writer_helpers {\n     fn emit_ty(ecx: @e::encode_ctxt, ty: ty::t) {\n         do self.emit_opaque {\n             e::write_type(ecx, self, ty)\n@@ -661,7 +660,7 @@ impl ebml::Writer: ebml_writer_helpers {\n \n     fn emit_tys(ecx: @e::encode_ctxt, tys: ~[ty::t]) {\n         do self.emit_from_vec(tys) |ty| {\n-            self.emit_ty(ecx, ty)\n+            self.emit_ty(ecx, *ty)\n         }\n     }\n \n@@ -673,17 +672,15 @@ impl ebml::Writer: ebml_writer_helpers {\n \n     fn emit_tpbt(ecx: @e::encode_ctxt, tpbt: ty::ty_param_bounds_and_ty) {\n         do self.emit_rec {\n-            do self.emit_rec_field(~\"bounds\", 0u) {\n+            do self.emit_field(~\"bounds\", 0u) {\n                 do self.emit_from_vec(*tpbt.bounds) |bs| {\n-                    self.emit_bounds(ecx, bs);\n+                    self.emit_bounds(ecx, *bs);\n                 }\n             }\n-            do self.emit_rec_field(~\"region_param\", 1u) {\n-                ty::serialize_opt_region_variance(\n-                    self,\n-                    tpbt.region_param);\n+            do self.emit_field(~\"region_param\", 1u) {\n+                tpbt.region_param.serialize(&self);\n             }\n-            do self.emit_rec_field(~\"ty\", 2u) {\n+            do self.emit_field(~\"ty\", 2u) {\n                 self.emit_ty(ecx, tpbt.ty);\n             }\n         }\n@@ -695,7 +692,7 @@ trait write_tag_and_id {\n     fn id(id: ast::node_id);\n }\n \n-impl ebml::Writer: write_tag_and_id {\n+impl ebml2::Serializer: write_tag_and_id {\n     fn tag(tag_id: c::astencode_tag, f: fn()) {\n         do self.wr_tag(tag_id as uint) { f() }\n     }\n@@ -707,7 +704,7 @@ impl ebml::Writer: write_tag_and_id {\n \n fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n                              maps: maps,\n-                             ebml_w: ebml::Writer,\n+                             ebml_w: ebml2::Serializer,\n                              ii: ast::inlined_item) {\n     do ebml_w.wr_tag(c::tag_table as uint) {\n         ast_util::visit_ids_for_inlined_item(\n@@ -723,7 +720,7 @@ fn encode_side_tables_for_ii(ecx: @e::encode_ctxt,\n \n fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n                              maps: maps,\n-                             ebml_w: ebml::Writer,\n+                             ebml_w: ebml2::Serializer,\n                              id: ast::node_id) {\n     let tcx = ecx.tcx;\n \n@@ -733,7 +730,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         do ebml_w.tag(c::tag_table_def) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                ast::serialize_def(ebml_w, *def)\n+                (*def).serialize(&ebml_w)\n             }\n         }\n     }\n@@ -810,7 +807,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n                 do ebml_w.emit_from_vec((*m).get()) |id| {\n-                    ebml_w.emit_int(id);\n+                    id.serialize(&ebml_w);\n                 }\n             }\n         }\n@@ -838,7 +835,7 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n         do ebml_w.tag(c::tag_table_adjustments) {\n             ebml_w.id(id);\n             do ebml_w.tag(c::tag_table_val) {\n-                ty::serialize_AutoAdjustment(ebml_w, **adj)\n+                (**adj).serialize(&ebml_w)\n             }\n         }\n     }\n@@ -852,13 +849,13 @@ fn encode_side_tables_for_id(ecx: @e::encode_ctxt,\n \n trait doc_decoder_helpers {\n     fn as_int() -> int;\n-    fn opt_child(tag: c::astencode_tag) -> Option<ebml::Doc>;\n+    fn opt_child(tag: c::astencode_tag) -> Option<ebml2::Doc>;\n }\n \n-impl ebml::Doc: doc_decoder_helpers {\n-    fn as_int() -> int { ebml::doc_as_u64(self) as int }\n-    fn opt_child(tag: c::astencode_tag) -> Option<ebml::Doc> {\n-        ebml::maybe_get_doc(self, tag as uint)\n+impl ebml2::Doc: doc_decoder_helpers {\n+    fn as_int() -> int { ebml2::doc_as_u64(self) as int }\n+    fn opt_child(tag: c::astencode_tag) -> Option<ebml2::Doc> {\n+        ebml2::maybe_get_doc(self, tag as uint)\n     }\n }\n \n@@ -871,7 +868,7 @@ trait ebml_deserializer_decoder_helpers {\n                                 -> ty::ty_param_bounds_and_ty;\n }\n \n-impl ebml::EbmlDeserializer: ebml_deserializer_decoder_helpers {\n+impl ebml2::Deserializer: ebml_deserializer_decoder_helpers {\n \n     fn read_arg(xcx: extended_decode_ctxt) -> ty::arg {\n         do self.read_opaque |doc| {\n@@ -911,13 +908,13 @@ impl ebml::EbmlDeserializer: ebml_deserializer_decoder_helpers {\n     {\n         do self.read_rec {\n             {\n-                bounds: self.read_rec_field(~\"bounds\", 0u, || {\n+                bounds: self.read_field(~\"bounds\", 0u, || {\n                     @self.read_to_vec(|| self.read_bounds(xcx) )\n                 }),\n-                region_param: self.read_rec_field(~\"region_param\", 1u, || {\n-                    ty::deserialize_opt_region_variance(self)\n+                region_param: self.read_field(~\"region_param\", 1u, || {\n+                    deserialize(&self)\n                 }),\n-                ty: self.read_rec_field(~\"ty\", 2u, || {\n+                ty: self.read_field(~\"ty\", 2u, || {\n                     self.read_ty(xcx)\n                 })\n             }\n@@ -926,10 +923,10 @@ impl ebml::EbmlDeserializer: ebml_deserializer_decoder_helpers {\n }\n \n fn decode_side_tables(xcx: extended_decode_ctxt,\n-                      ast_doc: ebml::Doc) {\n+                      ast_doc: ebml2::Doc) {\n     let dcx = xcx.dcx;\n     let tbl_doc = ast_doc[c::tag_table as uint];\n-    for ebml::docs(tbl_doc) |tag, entry_doc| {\n+    for ebml2::docs(tbl_doc) |tag, entry_doc| {\n         let id0 = entry_doc[c::tag_table_id as uint].as_int();\n         let id = xcx.tr_id(id0);\n \n@@ -943,7 +940,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n             dcx.tcx.legacy_boxed_traits.insert(id, ());\n         } else {\n             let val_doc = entry_doc[c::tag_table_val as uint];\n-            let val_dsr = ebml::ebml_deserializer(val_doc);\n+            let val_dsr = &ebml2::Deserializer(val_doc);\n             if tag == (c::tag_table_def as uint) {\n                 let def = decode_def(xcx, val_doc);\n                 dcx.tcx.def_map.insert(id, def);\n@@ -979,7 +976,8 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n                 dcx.maps.vtable_map.insert(id,\n                                            val_dsr.read_vtable_res(xcx));\n             } else if tag == (c::tag_table_adjustments as uint) {\n-                let adj = @ty::deserialize_AutoAdjustment(val_dsr).tr(xcx);\n+                let adj: @ty::AutoAdjustment = @deserialize(val_dsr);\n+                adj.tr(xcx);\n                 dcx.tcx.adjustments.insert(id, adj);\n             } else {\n                 xcx.dcx.tcx.sess.bug(\n@@ -995,17 +993,17 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: ebml::Writer, item: @ast::item) {\n+fn encode_item_ast(ebml_w: ebml2::Serializer, item: @ast::item) {\n     do ebml_w.wr_tag(c::tag_tree as uint) {\n-        ast::serialize_item(ebml_w, *item);\n+        (*item).serialize(&ebml_w)\n     }\n }\n \n #[cfg(test)]\n-fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n+fn decode_item_ast(par_doc: ebml2::Doc) -> @ast::item {\n     let chi_doc = par_doc[c::tag_tree as uint];\n-    let d = ebml::ebml_deserializer(chi_doc);\n-    @ast::deserialize_item(d)\n+    let d = &ebml2::Deserializer(chi_doc);\n+    @deserialize(d)\n }\n \n #[cfg(test)]\n@@ -1031,16 +1029,18 @@ fn mk_ctxt() -> fake_ext_ctxt {\n #[cfg(test)]\n fn roundtrip(in_item: @ast::item) {\n     let bytes = do io::with_bytes_writer |wr| {\n-        let ebml_w = ebml::Writer(wr);\n+        let ebml_w = ebml2::Serializer(wr);\n         encode_item_ast(ebml_w, in_item);\n     };\n-    let ebml_doc = ebml::Doc(@bytes);\n+    let ebml_doc = ebml2::Doc(@bytes);\n     let out_item = decode_item_ast(ebml_doc);\n \n-    let exp_str =\n-        io::with_str_writer(|w| ast::serialize_item(w, *in_item) );\n-    let out_str =\n-        io::with_str_writer(|w| ast::serialize_item(w, *out_item) );\n+    let exp_str = do io::with_str_writer |w| {\n+        in_item.serialize(&std::prettyprint2::Serializer(w))\n+    };\n+    let out_str = do io::with_str_writer |w| {\n+        out_item.serialize(&std::prettyprint2::Serializer(w))\n+    };\n \n     debug!(\"expected string: %s\", exp_str);\n     debug!(\"actual string  : %s\", out_str);"}, {"sha": "d26b9566c97e7f732197e0089c135493ca769258", "filename": "src/rustc/middle/freevars.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Frustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Frustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ffreevars.rs?ref=e1c517ca4815273285ac5699a88ccf0bcdb6103e", "patch": "@@ -5,19 +5,19 @@ use syntax::print::pprust::path_to_str;\n use std::map::*;\n use option::*;\n use syntax::{ast, ast_util, visit};\n-use syntax::ast::{serialize_span, deserialize_span};\n use syntax::codemap::span;\n \n export annotate_freevars;\n export freevar_map;\n export freevar_info;\n-export freevar_entry, serialize_freevar_entry, deserialize_freevar_entry;\n+export freevar_entry;\n export get_freevars;\n export has_freevars;\n \n // A vector of defs representing the free variables referred to in a function.\n // (The def_upvar will already have been stripped).\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type freevar_entry = {\n     def: ast::def, //< The variable being accessed free.\n     span: span     //< First span where it is accessed (there can be multiple)"}, {"sha": "bbc3a06fb67523006e248ae7c296b66446bc7df4", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=e1c517ca4815273285ac5699a88ccf0bcdb6103e", "patch": "@@ -18,10 +18,6 @@ use middle::lint::{get_lint_level, allow};\n use syntax::ast::*;\n use syntax::print::pprust::*;\n use util::ppaux::{ty_to_str, proto_ty_to_str, tys_to_str};\n-use std::serialization::{serialize_Option,\n-                         deserialize_Option,\n-                         serialize_uint,\n-                         deserialize_uint};\n \n export TyVid, IntVid, FnVid, RegionVid, vid;\n export br_hashmap;\n@@ -173,7 +169,6 @@ export mach_sty;\n export ty_sort_str;\n export normalize_ty;\n export to_str;\n-export borrow, serialize_borrow, deserialize_borrow;\n export bound_const;\n export terr_no_integral_type, terr_ty_param_size, terr_self_substs;\n export terr_in_field, terr_record_fields, terr_vstores_differ, terr_arg_count;\n@@ -192,12 +187,10 @@ export is_blockish;\n export method_call_bounds;\n export hash_region;\n export region_variance, rv_covariant, rv_invariant, rv_contravariant;\n-export serialize_region_variance, deserialize_region_variance;\n export opt_region_variance;\n-export serialize_opt_region_variance, deserialize_opt_region_variance;\n export determine_inherited_purity;\n export provided_trait_methods;\n-export AutoAdjustment, serialize_AutoAdjustment, deserialize_AutoAdjustment;\n+export AutoAdjustment;\n export AutoRef, AutoRefKind, AutoSlice, AutoPtr;\n \n // Data types\n@@ -218,7 +211,8 @@ type method = {ident: ast::ident,\n \n type mt = {ty: t, mutbl: ast::mutability};\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum vstore {\n     vstore_fixed(uint),\n     vstore_uniq,\n@@ -275,10 +269,10 @@ enum ast_ty_to_ty_cache_entry {\n     atttce_resolved(t)  /* resolved to a type, irrespective of region */\n }\n \n-#[auto_serialize]\n type opt_region_variance = Option<region_variance>;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum region_variance { rv_covariant, rv_invariant, rv_contravariant }\n \n impl region_variance : cmp::Eq {\n@@ -295,20 +289,23 @@ impl region_variance : cmp::Eq {\n     pure fn ne(other: &region_variance) -> bool { !self.eq(other) }\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type AutoAdjustment = {\n     autoderefs: uint,\n     autoref: Option<AutoRef>\n };\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type AutoRef = {\n     kind: AutoRefKind,\n     region: region,\n     mutbl: ast::mutability\n };\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum AutoRefKind {\n     /// Convert from @[]/~[] to &[] (or str)\n     AutoSlice,\n@@ -512,7 +509,8 @@ impl param_ty : to_bytes::IterBytes {\n \n \n /// Representation of regions:\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum region {\n     /// Bound regions are found (primarily) in function types.  They indicate\n     /// region parameters that have yet to be replaced with actual regions\n@@ -540,7 +538,8 @@ enum region {\n     re_var(RegionVid)\n }\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum bound_region {\n     /// The self region for classes, impls (&T in a type defn or &self/T)\n     br_self,\n@@ -670,7 +669,8 @@ enum param_bound {\n enum TyVid = uint;\n enum IntVid = uint;\n enum FnVid = uint;\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum RegionVid = uint;\n \n enum InferTy {"}, {"sha": "c2bd7f26badec7724f1b6ed904f6317e4847555a", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1c517ca4815273285ac5699a88ccf0bcdb6103e/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=e1c517ca4815273285ac5699a88ccf0bcdb6103e", "patch": "@@ -56,7 +56,6 @@ use middle::ty::{vstore_uniq};\n use std::smallintmap;\n use std::map;\n use std::map::HashMap;\n-use std::serialization::{serialize_uint, deserialize_uint};\n use syntax::print::pprust::*;\n use util::ppaux::{ty_to_str, tys_to_str, region_to_str,\n                   bound_region_to_str, vstore_to_str, expr_repr};\n@@ -67,17 +66,17 @@ use list::{List, Nil, Cons};\n export check_crate;\n export infer;\n export method_map;\n-export method_origin, serialize_method_origin, deserialize_method_origin;\n-export method_map_entry, serialize_method_map_entry;\n-export deserialize_method_map_entry;\n+export method_origin;\n+export method_map_entry;\n export vtable_map;\n export vtable_res;\n export vtable_origin;\n export method_static, method_param, method_trait, method_self;\n export vtable_static, vtable_param, vtable_trait;\n export provided_methods_map;\n \n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n enum method_origin {\n     // fully statically resolved method\n     method_static(ast::def_id),\n@@ -94,7 +93,8 @@ enum method_origin {\n \n // details for a method invoked with a receiver whose type is a type parameter\n // with a bounded trait.\n-#[auto_serialize]\n+#[auto_serialize2]\n+#[auto_deserialize2]\n type method_param = {\n     // the trait containing the method to be invoked\n     trait_id: ast::def_id,"}]}