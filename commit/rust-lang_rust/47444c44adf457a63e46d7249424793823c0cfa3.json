{"sha": "47444c44adf457a63e46d7249424793823c0cfa3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3NDQ0YzQ0YWRmNDU3YTYzZTQ2ZDcyNDk0MjQ3OTM4MjNjMGNmYTM=", "commit": {"author": {"name": "pJunger", "email": "pJunger@users.noreply.github.com", "date": "2019-05-12T12:46:16Z"}, "committer": {"name": "pJunger", "email": "pJunger@users.noreply.github.com", "date": "2019-05-18T07:33:25Z"}, "message": "Added lint for TryFrom for checked integer conversion rust-lang#3947.", "tree": {"sha": "04998ff5d57371b94411c5e10fdb637e213a4673", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04998ff5d57371b94411c5e10fdb637e213a4673"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47444c44adf457a63e46d7249424793823c0cfa3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47444c44adf457a63e46d7249424793823c0cfa3", "html_url": "https://github.com/rust-lang/rust/commit/47444c44adf457a63e46d7249424793823c0cfa3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47444c44adf457a63e46d7249424793823c0cfa3/comments", "author": {"login": "pJunger", "id": 16426009, "node_id": "MDQ6VXNlcjE2NDI2MDA5", "avatar_url": "https://avatars.githubusercontent.com/u/16426009?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pJunger", "html_url": "https://github.com/pJunger", "followers_url": "https://api.github.com/users/pJunger/followers", "following_url": "https://api.github.com/users/pJunger/following{/other_user}", "gists_url": "https://api.github.com/users/pJunger/gists{/gist_id}", "starred_url": "https://api.github.com/users/pJunger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pJunger/subscriptions", "organizations_url": "https://api.github.com/users/pJunger/orgs", "repos_url": "https://api.github.com/users/pJunger/repos", "events_url": "https://api.github.com/users/pJunger/events{/privacy}", "received_events_url": "https://api.github.com/users/pJunger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pJunger", "id": 16426009, "node_id": "MDQ6VXNlcjE2NDI2MDA5", "avatar_url": "https://avatars.githubusercontent.com/u/16426009?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pJunger", "html_url": "https://github.com/pJunger", "followers_url": "https://api.github.com/users/pJunger/followers", "following_url": "https://api.github.com/users/pJunger/following{/other_user}", "gists_url": "https://api.github.com/users/pJunger/gists{/gist_id}", "starred_url": "https://api.github.com/users/pJunger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pJunger/subscriptions", "organizations_url": "https://api.github.com/users/pJunger/orgs", "repos_url": "https://api.github.com/users/pJunger/repos", "events_url": "https://api.github.com/users/pJunger/events{/privacy}", "received_events_url": "https://api.github.com/users/pJunger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60a609acaed3bf2b3ec6ab995bccf0f03bc26060", "url": "https://api.github.com/repos/rust-lang/rust/commits/60a609acaed3bf2b3ec6ab995bccf0f03bc26060", "html_url": "https://github.com/rust-lang/rust/commit/60a609acaed3bf2b3ec6ab995bccf0f03bc26060"}], "stats": {"total": 489, "additions": 489, "deletions": 0}, "files": [{"sha": "08fcbc127b89cf07dfdac428235c5d2344f8131e", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47444c44adf457a63e46d7249424793823c0cfa3/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/47444c44adf457a63e46d7249424793823c0cfa3/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=47444c44adf457a63e46d7249424793823c0cfa3", "patch": "@@ -846,6 +846,7 @@ All notable changes to this project will be documented in this file.\n [`char_lit_as_u8`]: https://rust-lang.github.io/rust-clippy/master/index.html#char_lit_as_u8\n [`chars_last_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_last_cmp\n [`chars_next_cmp`]: https://rust-lang.github.io/rust-clippy/master/index.html#chars_next_cmp\n+[`checked_conversions`]: https://rust-lang.github.io/rust-clippy/master/index.html#checked_conversions\n [`clone_double_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_double_ref\n [`clone_on_copy`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_copy\n [`clone_on_ref_ptr`]: https://rust-lang.github.io/rust-clippy/master/index.html#clone_on_ref_ptr"}, {"sha": "55a496f1fce6bd911df4cb029061c567d60a561e", "filename": "clippy_lints/src/checked_conversions.rs", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/47444c44adf457a63e46d7249424793823c0cfa3/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47444c44adf457a63e46d7249424793823c0cfa3/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=47444c44adf457a63e46d7249424793823c0cfa3", "patch": "@@ -0,0 +1,332 @@\n+//! lint on manually implemented checked conversions that could be transformed into try_from\n+\n+use if_chain::if_chain;\n+use rustc::hir::*;\n+use rustc::lint::{in_external_macro, LateContext, LateLintPass, LintArray, LintContext, LintPass};\n+use rustc::{declare_lint_pass, declare_tool_lint};\n+use syntax::ast::LitKind;\n+\n+use crate::utils::{span_lint, SpanlessEq};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for explicit bounds checking when casting.\n+    ///\n+    /// **Why is this bad?** Reduces the readability of statements & is error prone.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let foo: u32 = 5;\n+    /// # let _ =\n+    /// foo <= i32::max_value() as u32\n+    /// # ;\n+    /// ```\n+    ///\n+    /// Could be written:\n+    ///\n+    /// ```rust\n+    /// # let _ =\n+    /// i32::try_from(foo).is_ok()\n+    /// # ;\n+    /// ```\n+    pub CHECKED_CONVERSIONS,\n+    pedantic,\n+    \"`try_from` could replace manual bounds checking when casting\"\n+}\n+\n+declare_lint_pass!(CheckedConversions => [CHECKED_CONVERSIONS]);\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CheckedConversions {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, item: &Expr) {\n+        let result = if_chain! {\n+            if !in_external_macro(cx.sess(), item.span);\n+            if let ExprKind::Binary(op, ref left, ref right) = &item.node;\n+\n+            then {\n+                match op.node {\n+                    BinOpKind::Ge | BinOpKind::Le => single_check(item),\n+                    BinOpKind::And => double_check(cx, left, right),\n+                    _ => None,\n+                }\n+            } else {\n+                None\n+            }\n+        };\n+\n+        if let Some(cv) = result {\n+            span_lint(\n+                cx,\n+                CHECKED_CONVERSIONS,\n+                item.span,\n+                &format!(\n+                    \"Checked cast can be simplified: `{}::try_from`\",\n+                    cv.to_type.unwrap_or(\"IntegerType\".to_string()),\n+                ),\n+            );\n+        }\n+    }\n+}\n+\n+/// Searches for a single check from unsigned to _ is done\n+/// todo: check for case signed -> larger unsigned == only x >= 0\n+fn single_check(expr: &Expr) -> Option<Conversion<'_>> {\n+    check_upper_bound(expr).filter(|cv| cv.cvt == ConversionType::FromUnsigned)\n+}\n+\n+/// Searches for a combination of upper & lower bound checks\n+fn double_check<'a>(cx: &LateContext<'_, '_>, left: &'a Expr, right: &'a Expr) -> Option<Conversion<'a>> {\n+    let upper_lower = |l, r| {\n+        let upper = check_upper_bound(l);\n+        let lower = check_lower_bound(r);\n+\n+        transpose(upper, lower).and_then(|(l, r)| l.combine(r, cx))\n+    };\n+\n+    upper_lower(left, right).or_else(|| upper_lower(right, left))\n+}\n+\n+/// Contains the result of a tried conversion check\n+#[derive(Clone, Debug)]\n+struct Conversion<'a> {\n+    cvt: ConversionType,\n+    expr_to_cast: &'a Expr,\n+    to_type: Option<String>,\n+}\n+\n+/// The kind of conversion that is checked\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+enum ConversionType {\n+    SignedToUnsigned,\n+    SignedToSigned,\n+    FromUnsigned,\n+}\n+\n+impl<'a> Conversion<'a> {\n+    /// Combine multiple conversions if the are compatible\n+    pub fn combine(self, other: Self, cx: &LateContext<'_, '_>) -> Option<Conversion<'a>> {\n+        if self.is_compatible(&other, cx) {\n+            // Prefer a Conversion that contains a type-constraint\n+            Some(if self.to_type.is_some() { self } else { other })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Checks if two conversions are compatible\n+    /// same type of conversion, same 'castee' and same 'to type'\n+    pub fn is_compatible(&self, other: &Self, cx: &LateContext<'_, '_>) -> bool {\n+        (self.cvt == other.cvt)\n+            && (SpanlessEq::new(cx).eq_expr(self.expr_to_cast, other.expr_to_cast))\n+            && (self.has_compatible_to_type(other))\n+    }\n+\n+    /// Checks if the to-type is the same (if there is a type constraint)\n+    fn has_compatible_to_type(&self, other: &Self) -> bool {\n+        transpose(self.to_type.as_ref(), other.to_type.as_ref())\n+            .map(|(l, r)| l == r)\n+            .unwrap_or(true)\n+    }\n+\n+    /// Try to construct a new conversion if the conversion type is valid\n+    fn try_new<'b>(expr_to_cast: &'a Expr, from_type: &'b str, to_type: String) -> Option<Conversion<'a>> {\n+        ConversionType::try_new(from_type, &to_type).map(|cvt| Conversion {\n+            cvt,\n+            expr_to_cast,\n+            to_type: Some(to_type),\n+        })\n+    }\n+\n+    /// Construct a new conversion without type constraint\n+    fn new_any(expr_to_cast: &'a Expr) -> Conversion<'a> {\n+        Conversion {\n+            cvt: ConversionType::SignedToUnsigned,\n+            expr_to_cast,\n+            to_type: None,\n+        }\n+    }\n+}\n+\n+impl ConversionType {\n+    /// Creates a conversion type if the type is allowed & conversion is valid\n+    fn try_new(from: &str, to: &str) -> Option<ConversionType> {\n+        if UNSIGNED_TYPES.contains(&from) {\n+            Some(ConversionType::FromUnsigned)\n+        } else if SIGNED_TYPES.contains(&from) {\n+            if UNSIGNED_TYPES.contains(&to) {\n+                Some(ConversionType::SignedToUnsigned)\n+            } else if SIGNED_TYPES.contains(&to) {\n+                Some(ConversionType::SignedToSigned)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Check for `expr <= (to_type::max_value() as from_type)`\n+fn check_upper_bound(expr: &Expr) -> Option<Conversion<'_>> {\n+    if_chain! {\n+         if let ExprKind::Binary(ref op, ref left, ref right) = &expr.node;\n+         if let Some((candidate, check)) = normalize_le_ge(op, left, right);\n+         if let Some((from, to)) = get_types_from_cast(check, \"max_value\", INT_TYPES);\n+\n+         then {\n+             Conversion::try_new(candidate, &from, to)\n+         } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Check for `expr >= 0|(to_type::min_value() as from_type)`\n+fn check_lower_bound(expr: &Expr) -> Option<Conversion<'_>> {\n+    fn check_function<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Conversion<'a>> {\n+        (check_lower_bound_zero(candidate, check)).or_else(|| (check_lower_bound_min(candidate, check)))\n+    }\n+\n+    // First of we need a binary containing the expression & the cast\n+    if let ExprKind::Binary(ref op, ref left, ref right) = &expr.node {\n+        normalize_le_ge(op, right, left).and_then(|(l, r)| check_function(l, r))\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Check for `expr >= 0`\n+fn check_lower_bound_zero<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Conversion<'a>> {\n+    if_chain! {\n+        if let ExprKind::Lit(ref lit) = &check.node;\n+        if let LitKind::Int(0, _) = &lit.node;\n+\n+        then {\n+            Some(Conversion::new_any(candidate))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Check for `expr >= (to_type::min_value() as from_type)`\n+fn check_lower_bound_min<'a>(candidate: &'a Expr, check: &'a Expr) -> Option<Conversion<'a>> {\n+    if let Some((from, to)) = get_types_from_cast(check, \"min_value\", SIGNED_TYPES) {\n+        Conversion::try_new(candidate, &from, to)\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Tries to extract the from- and to-type from a cast expression\n+fn get_types_from_cast(expr: &Expr, func: &str, types: &[&str]) -> Option<(String, String)> {\n+    // `to_type::maxmin_value() as from_type`\n+    let call_from_cast: Option<(&Expr, String)> = if_chain! {\n+        // to_type::maxmin_value(), from_type\n+        if let ExprKind::Cast(ref limit, ref from_type) = &expr.node;\n+        if let TyKind::Path(ref from_type_path) = &from_type.node;\n+        if let Some(from_type_str) = int_ty_to_str(from_type_path);\n+\n+        then {\n+            Some((limit, from_type_str.to_string()))\n+        } else {\n+            None\n+        }\n+    };\n+\n+    // `from_type::from(to_type::maxmin_value())`\n+    let limit_from: Option<(&Expr, String)> = call_from_cast.or_else(|| {\n+        if_chain! {\n+            // `from_type::from, to_type::maxmin_value()`\n+            if let ExprKind::Call(ref from_func, ref args) = &expr.node;\n+            // `to_type::maxmin_value()`\n+            if args.len() == 1;\n+            if let limit = &args[0];\n+            // `from_type::from`\n+            if let ExprKind::Path(ref path) = &from_func.node;\n+            if let Some(from_type) = get_implementing_type(path, INT_TYPES, \"from\");\n+\n+            then {\n+                Some((limit, from_type))\n+            } else {\n+                None\n+            }\n+        }\n+    });\n+\n+    if let Some((limit, from_type)) = limit_from {\n+        if_chain! {\n+            if let ExprKind::Call(ref fun_name, _) = &limit.node;\n+            // `to_type, maxmin_value`\n+            if let ExprKind::Path(ref path) = &fun_name.node;\n+            // `to_type`\n+            if let Some(to_type) = get_implementing_type(path, types, func);\n+\n+            then {\n+                Some((from_type, to_type))\n+            } else {\n+                None\n+            }\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Gets the type which implements the called function\n+fn get_implementing_type(path: &QPath, candidates: &[&str], function: &str) -> Option<String> {\n+    if_chain! {\n+        if let QPath::TypeRelative(ref ty, ref path) = &path;\n+        if path.ident.name == function;\n+        if let TyKind::Path(QPath::Resolved(None, ref tp)) = &ty.node;\n+        if let [int] = &*tp.segments;\n+        let name = int.ident.as_str().get();\n+        if candidates.contains(&name);\n+\n+        then {\n+            Some(name.to_string())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Gets the type as a string, if it is a supported integer\n+fn int_ty_to_str(path: &QPath) -> Option<&str> {\n+    if_chain! {\n+        if let QPath::Resolved(_, ref path) = *path;\n+        if let [ty] = &*path.segments;\n+\n+        then {\n+            INT_TYPES\n+                .into_iter()\n+                .find(|c| (&ty.ident.name) == *c)\n+                .cloned()\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// (Option<T>, Option<U>) -> Option<(T, U)>\n+fn transpose<T, U>(lhs: Option<T>, rhs: Option<U>) -> Option<(T, U)> {\n+    match (lhs, rhs) {\n+        (Some(l), Some(r)) => Some((l, r)),\n+        _ => None,\n+    }\n+}\n+\n+/// Will return the expressions as if they were expr1 <= expr2\n+fn normalize_le_ge<'a>(op: &'a BinOp, left: &'a Expr, right: &'a Expr) -> Option<(&'a Expr, &'a Expr)> {\n+    match op.node {\n+        BinOpKind::Le => Some((left, right)),\n+        BinOpKind::Ge => Some((right, left)),\n+        _ => None,\n+    }\n+}\n+\n+const UNSIGNED_TYPES: &[&str] = &[\"u8\", \"u16\", \"u32\", \"u64\", \"u128\", \"usize\"];\n+const SIGNED_TYPES: &[&str] = &[\"i8\", \"i16\", \"i32\", \"i64\", \"i128\", \"isize\"];\n+const INT_TYPES: &[&str] = &[\n+    \"u8\", \"u16\", \"u32\", \"u64\", \"u128\", \"usize\", \"i8\", \"i16\", \"i32\", \"i64\", \"i128\", \"isize\",\n+];"}, {"sha": "3049ff672c57358a79788839d155e0b23fb0719d", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47444c44adf457a63e46d7249424793823c0cfa3/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47444c44adf457a63e46d7249424793823c0cfa3/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=47444c44adf457a63e46d7249424793823c0cfa3", "patch": "@@ -154,6 +154,7 @@ pub mod block_in_if_condition;\n pub mod booleans;\n pub mod bytecount;\n pub mod cargo_common_metadata;\n+pub mod checked_conversions;\n pub mod cognitive_complexity;\n pub mod collapsible_if;\n pub mod const_static_lifetime;\n@@ -605,6 +606,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry<'_>, conf: &Conf) {\n \n     reg.register_lint_group(\"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n         attrs::INLINE_ALWAYS,\n+        checked_conversions::CHECKED_CONVERSIONS,\n         copies::MATCH_SAME_ARMS,\n         copy_iterator::COPY_ITERATOR,\n         default_trait_access::DEFAULT_TRAIT_ACCESS,"}, {"sha": "71699a0733d8ea48ec5f90b944ffbb94bcbf00a9", "filename": "tests/ui/checked_conversions.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/47444c44adf457a63e46d7249424793823c0cfa3/tests%2Fui%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47444c44adf457a63e46d7249424793823c0cfa3/tests%2Fui%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_conversions.rs?ref=47444c44adf457a63e46d7249424793823c0cfa3", "patch": "@@ -0,0 +1,102 @@\n+#![warn(clippy::checked_conversions)]\n+#![allow(clippy::cast_lossless)]\n+\n+// Positive tests\n+\n+// Signed to unsigned\n+\n+fn i64_to_u32(value: i64) -> Option<u32> {\n+    if value <= (u32::max_value() as i64) && value >= 0 {\n+        Some(value as u32)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn i64_to_u16(value: i64) -> Option<u16> {\n+    if value <= i64::from(u16::max_value()) && value >= 0 {\n+        Some(value as u16)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn isize_to_u8(value: isize) -> Option<u8> {\n+    if value <= (u8::max_value() as isize) && value >= 0 {\n+        Some(value as u8)\n+    } else {\n+        None\n+    }\n+}\n+\n+// Signed to signed\n+\n+fn i64_to_i32(value: i64) -> Option<i32> {\n+    if value <= (i32::max_value() as i64) && value >= (i32::min_value() as i64) {\n+        Some(value as i32)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn i64_to_i16(value: i64) -> Option<i16> {\n+    if value <= i64::from(i16::max_value()) && value >= i64::from(i16::min_value()) {\n+        Some(value as i16)\n+    } else {\n+        None\n+    }\n+}\n+\n+// Unsigned to X\n+\n+fn u32_to_i32(value: u32) -> Option<i32> {\n+    if value <= i32::max_value() as u32 {\n+        Some(value as i32)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn usize_to_isize(value: usize) -> isize {\n+    if value <= isize::max_value() as usize && value as i32 == 5 {\n+        5\n+    } else {\n+        1\n+    }\n+}\n+\n+fn u32_to_u16(value: u32) -> isize {\n+    if value <= u16::max_value() as u32 && value as i32 == 5 {\n+        5\n+    } else {\n+        1\n+    }\n+}\n+\n+// Negative tests\n+\n+fn no_i64_to_i32(value: i64) -> Option<i32> {\n+    if value <= (i32::max_value() as i64) && value >= 0 {\n+        Some(value as i32)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn no_isize_to_u8(value: isize) -> Option<u8> {\n+    if value <= (u8::max_value() as isize) && value >= (u8::min_value() as isize) {\n+        Some(value as u8)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn i8_to_u8(value: i8) -> Option<u8> {\n+    if value >= 0 {\n+        Some(value as u8)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a3fed35eccca72547423bbc5f5c3abe6a0b29353", "filename": "tests/ui/checked_conversions.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/47444c44adf457a63e46d7249424793823c0cfa3/tests%2Fui%2Fchecked_conversions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/47444c44adf457a63e46d7249424793823c0cfa3/tests%2Fui%2Fchecked_conversions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_conversions.stderr?ref=47444c44adf457a63e46d7249424793823c0cfa3", "patch": "@@ -0,0 +1,52 @@\n+error: Checked cast can be simplified: `u32::try_from`\n+  --> $DIR/checked_conversions.rs:9:8\n+   |\n+LL |     if value <= (u32::max_value() as i64) && value >= 0 {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::checked-conversions` implied by `-D warnings`\n+\n+error: Checked cast can be simplified: `u16::try_from`\n+  --> $DIR/checked_conversions.rs:17:8\n+   |\n+LL |     if value <= i64::from(u16::max_value()) && value >= 0 {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Checked cast can be simplified: `u8::try_from`\n+  --> $DIR/checked_conversions.rs:25:8\n+   |\n+LL |     if value <= (u8::max_value() as isize) && value >= 0 {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Checked cast can be simplified: `i32::try_from`\n+  --> $DIR/checked_conversions.rs:35:8\n+   |\n+LL |     if value <= (i32::max_value() as i64) && value >= (i32::min_value() as i64) {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Checked cast can be simplified: `i16::try_from`\n+  --> $DIR/checked_conversions.rs:43:8\n+   |\n+LL |     if value <= i64::from(i16::max_value()) && value >= i64::from(i16::min_value()) {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Checked cast can be simplified: `i32::try_from`\n+  --> $DIR/checked_conversions.rs:53:8\n+   |\n+LL |     if value <= i32::max_value() as u32 {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Checked cast can be simplified: `isize::try_from`\n+  --> $DIR/checked_conversions.rs:61:8\n+   |\n+LL |     if value <= isize::max_value() as usize && value as i32 == 5 {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Checked cast can be simplified: `u16::try_from`\n+  --> $DIR/checked_conversions.rs:69:8\n+   |\n+LL |     if value <= u16::max_value() as u32 && value as i32 == 5 {\n+   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "tests/ui/checked_conversions.stdout", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/47444c44adf457a63e46d7249424793823c0cfa3/tests%2Fui%2Fchecked_conversions.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/47444c44adf457a63e46d7249424793823c0cfa3/tests%2Fui%2Fchecked_conversions.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_conversions.stdout?ref=47444c44adf457a63e46d7249424793823c0cfa3"}]}