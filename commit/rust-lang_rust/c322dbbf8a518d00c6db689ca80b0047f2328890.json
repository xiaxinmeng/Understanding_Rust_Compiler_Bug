{"sha": "c322dbbf8a518d00c6db689ca80b0047f2328890", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMjJkYmJmOGE1MThkMDBjNmRiNjg5Y2E4MGIwMDQ3ZjIzMjg4OTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-19T20:56:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-19T20:56:51Z"}, "message": "Auto merge of #24333 - arielb1:implement-rfc401, r=nrc", "tree": {"sha": "ac2c9c3f341d636046f5f653259ff9a20bbf4938", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac2c9c3f341d636046f5f653259ff9a20bbf4938"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c322dbbf8a518d00c6db689ca80b0047f2328890", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c322dbbf8a518d00c6db689ca80b0047f2328890", "html_url": "https://github.com/rust-lang/rust/commit/c322dbbf8a518d00c6db689ca80b0047f2328890", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c322dbbf8a518d00c6db689ca80b0047f2328890/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f34ff7af7362053e8aee7a35365d6320ed6e88b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/f34ff7af7362053e8aee7a35365d6320ed6e88b8", "html_url": "https://github.com/rust-lang/rust/commit/f34ff7af7362053e8aee7a35365d6320ed6e88b8"}, {"sha": "e7e1fd20deb95f74c4a33c76921907e039dff894", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7e1fd20deb95f74c4a33c76921907e039dff894", "html_url": "https://github.com/rust-lang/rust/commit/e7e1fd20deb95f74c4a33c76921907e039dff894"}], "stats": {"total": 1555, "additions": 1071, "deletions": 484}, "files": [{"sha": "97e85b114b06079dd07d0eeb6b751538673233be", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -394,7 +394,9 @@ impl<T: ?Sized> Drop for Arc<T> {\n         // it's run more than once)\n         let ptr = *self._ptr;\n         // if ptr.is_null() { return }\n-        if ptr as usize == 0 || ptr as usize == mem::POST_DROP_USIZE { return }\n+        if ptr as *mut u8 as usize == 0 || ptr as *mut u8 as usize == mem::POST_DROP_USIZE {\n+            return\n+        }\n \n         // Because `fetch_sub` is already atomic, we do not need to synchronize\n         // with other threads unless we are going to delete the object. This\n@@ -524,7 +526,9 @@ impl<T: ?Sized> Drop for Weak<T> {\n         let ptr = *self._ptr;\n \n         // see comments above for why this check is here\n-        if ptr as usize == 0 || ptr as usize == mem::POST_DROP_USIZE { return }\n+        if ptr as *mut u8 as usize == 0 || ptr as *mut u8 as usize == mem::POST_DROP_USIZE {\n+            return\n+        }\n \n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about"}, {"sha": "b8d8e6ad0a1b5c23755e27212c1bd246cbc73a86", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -543,7 +543,7 @@ impl<T: ?Sized> Drop for Rc<T> {\n         unsafe {\n             let ptr = *self._ptr;\n             if !(*(&ptr as *const _ as *const *const ())).is_null() &&\n-               ptr as usize != mem::POST_DROP_USIZE {\n+               ptr as *const () as usize != mem::POST_DROP_USIZE {\n                 self.dec_strong();\n                 if self.strong() == 0 {\n                     // destroy the contained object\n@@ -1051,7 +1051,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n         unsafe {\n             let ptr = *self._ptr;\n             if !(*(&ptr as *const _ as *const *const ())).is_null() &&\n-               ptr as usize != mem::POST_DROP_USIZE {\n+               ptr as *const () as usize != mem::POST_DROP_USIZE {\n                 self.dec_weak();\n                 // the weak count starts at 1, and will only go to zero if all\n                 // the strong pointers have disappeared."}, {"sha": "f5cb1bd25d60da512b5a725778be7e76d3e73296", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -801,7 +801,6 @@ struct Foo<T: 'static> {\n \n register_diagnostics! {\n     E0011,\n-    E0012,\n     E0014,\n     E0016,\n     E0017,"}, {"sha": "993d0dcf115df3313d638dbe3c533cf28956ce49", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -94,6 +94,7 @@ pub mod back {\n pub mod middle {\n     pub mod astconv_util;\n     pub mod astencode;\n+    pub mod cast;\n     pub mod cfg;\n     pub mod check_const;\n     pub mod check_static_recursion;"}, {"sha": "478c0f2f564f8dce1ab0860766bebc019ce4c60e", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -148,6 +148,7 @@ enum_from_u32! {\n         tag_table_capture_modes = 0x67,\n         tag_table_object_cast_map = 0x68,\n         tag_table_const_qualif = 0x69,\n+        tag_table_cast_kinds = 0x6a,\n     }\n }\n "}, {"sha": "e325c03d52db6bdc9060c8723c71dedbda0c5672", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -23,6 +23,7 @@ use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n+use middle::cast;\n use middle::check_const::ConstQualif;\n use middle::mem_categorization::Typer;\n use middle::privacy::{AllPublic, LastMod};\n@@ -688,6 +689,10 @@ pub fn encode_closure_kind(ebml_w: &mut Encoder, kind: ty::ClosureKind) {\n     kind.encode(ebml_w).unwrap();\n }\n \n+pub fn encode_cast_kind(ebml_w: &mut Encoder, kind: cast::CastKind) {\n+    kind.encode(ebml_w).unwrap();\n+}\n+\n pub trait vtable_decoder_helpers<'tcx> {\n     fn read_vec_per_param_space<T, F>(&mut self, f: F) -> VecPerParamSpace<T> where\n         F: FnMut(&mut Self) -> T;\n@@ -1248,6 +1253,13 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n+    if let Some(cast_kind) = tcx.cast_kinds.borrow().get(&id) {\n+        rbml_w.tag(c::tag_table_cast_kinds, |rbml_w| {\n+            rbml_w.id(id);\n+            encode_cast_kind(rbml_w, *cast_kind)\n+        })\n+    }\n+\n     for &qualif in tcx.const_qualif_map.borrow().get(&id).iter() {\n         rbml_w.tag(c::tag_table_const_qualif, |rbml_w| {\n             rbml_w.id(id);\n@@ -1289,6 +1301,8 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                            -> subst::Substs<'tcx>;\n     fn read_auto_adjustment<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                     -> ty::AutoAdjustment<'tcx>;\n+    fn read_cast_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n+                                 -> cast::CastKind;\n     fn read_closure_kind<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                                  -> ty::ClosureKind;\n     fn read_closure_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1641,6 +1655,12 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }).unwrap()\n     }\n \n+    fn read_cast_kind<'b, 'c>(&mut self, _dcx: &DecodeContext<'b, 'c, 'tcx>)\n+                              -> cast::CastKind\n+    {\n+        Decodable::decode(self).unwrap()\n+    }\n+\n     fn read_closure_kind<'b, 'c>(&mut self, _dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                  -> ty::ClosureKind\n     {\n@@ -1801,6 +1821,11 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         dcx.tcx.closure_kinds.borrow_mut().insert(ast_util::local_def(id),\n                                                                   closure_kind);\n                     }\n+                    c::tag_table_cast_kinds => {\n+                        let cast_kind =\n+                            val_dsr.read_cast_kind(dcx);\n+                        dcx.tcx.cast_kinds.borrow_mut().insert(id, cast_kind);\n+                    }\n                     c::tag_table_const_qualif => {\n                         let qualif: ConstQualif = Decodable::decode(val_dsr).unwrap();\n                         dcx.tcx.const_qualif_map.borrow_mut().insert(id, qualif);"}, {"sha": "c534a3ca0389fdafa3818743bf49a69805949863", "filename": "src/librustc/middle/cast.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Fmiddle%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Fmiddle%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcast.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Helpers for handling cast expressions, used in both\n+// typeck and trans.\n+\n+use middle::ty::{self, Ty};\n+\n+use syntax::ast;\n+\n+/// Types that are represented as ints.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum IntTy {\n+    U(ast::UintTy),\n+    I,\n+    CEnum,\n+    Bool,\n+    Char\n+}\n+\n+// Valid types for the result of a non-coercion cast\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum CastTy<'tcx> {\n+    /// Various types that are represented as ints and handled mostly\n+    /// in the same way, merged for easier matching.\n+    Int(IntTy),\n+    /// Floating-Point types\n+    Float,\n+    /// Function Pointers\n+    FnPtr,\n+    /// Raw pointers\n+    Ptr(&'tcx ty::mt<'tcx>),\n+    /// References\n+    RPtr(&'tcx ty::mt<'tcx>),\n+}\n+\n+/// Cast Kind. See RFC 401 (or librustc_typeck/check/cast.rs)\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub enum CastKind {\n+    CoercionCast,\n+    PtrPtrCast,\n+    PtrAddrCast,\n+    AddrPtrCast,\n+    NumericCast,\n+    EnumCast,\n+    PrimIntCast,\n+    U8CharCast,\n+    ArrayPtrCast,\n+    FnPtrPtrCast,\n+    FnPtrAddrCast\n+}\n+\n+impl<'tcx> CastTy<'tcx> {\n+    pub fn from_ty(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>)\n+                   -> Option<CastTy<'tcx>> {\n+        match t.sty {\n+            ty::ty_bool => Some(CastTy::Int(IntTy::Bool)),\n+            ty::ty_char => Some(CastTy::Int(IntTy::Char)),\n+            ty::ty_int(_) => Some(CastTy::Int(IntTy::I)),\n+            ty::ty_uint(u) => Some(CastTy::Int(IntTy::U(u))),\n+            ty::ty_float(_) => Some(CastTy::Float),\n+            ty::ty_enum(..) if ty::type_is_c_like_enum(\n+                tcx, t) => Some(CastTy::Int(IntTy::CEnum)),\n+            ty::ty_ptr(ref mt) => Some(CastTy::Ptr(mt)),\n+            ty::ty_rptr(_, ref mt) => Some(CastTy::RPtr(mt)),\n+            ty::ty_bare_fn(..) => Some(CastTy::FnPtr),\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "794cc4ff38d341c3eb0c5519fbee623fb366a510", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -24,6 +24,7 @@\n // - It's not possible to take the address of a static item with unsafe interior. This is enforced\n // by borrowck::gather_loans\n \n+use middle::cast::{CastKind};\n use middle::const_eval;\n use middle::def;\n use middle::expr_use_visitor as euv;\n@@ -32,11 +33,10 @@ use middle::mem_categorization as mc;\n use middle::traits;\n use middle::ty::{self, Ty};\n use util::nodemap::NodeMap;\n-use util::ppaux;\n+use util::ppaux::Repr;\n \n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::print::pprust;\n use syntax::visit::{self, Visitor};\n \n use std::collections::hash_map::Entry;\n@@ -197,7 +197,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item) {\n-        debug!(\"visit_item(item={})\", pprust::item_to_string(i));\n+        debug!(\"visit_item(item={})\", i.repr(self.tcx));\n         match i.node {\n             ast::ItemStatic(_, ast::MutImmutable, ref expr) => {\n                 self.check_static_type(&**expr);\n@@ -440,26 +440,17 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n         ast::ExprCast(ref from, _) => {\n-            let toty = ty::expr_ty(v.tcx, e);\n-            let fromty = ty::expr_ty(v.tcx, &**from);\n-            let is_legal_cast =\n-                ty::type_is_numeric(toty) ||\n-                ty::type_is_unsafe_ptr(toty) ||\n-                (ty::type_is_bare_fn(toty) && ty::type_is_bare_fn_item(fromty));\n-            if !is_legal_cast {\n-                v.add_qualif(ConstQualif::NOT_CONST);\n-                if v.mode != Mode::Var {\n-                    span_err!(v.tcx.sess, e.span, E0012,\n-                              \"can not cast to `{}` in {}s\",\n-                              ppaux::ty_to_string(v.tcx, toty), v.msg());\n-                }\n-            }\n-            if ty::type_is_unsafe_ptr(fromty) && ty::type_is_numeric(toty) {\n-                v.add_qualif(ConstQualif::NOT_CONST);\n-                if v.mode != Mode::Var {\n-                    span_err!(v.tcx.sess, e.span, E0018,\n-                              \"can not cast a pointer to an integer in {}s\", v.msg());\n+            debug!(\"Checking const cast(id={})\", from.id);\n+            match v.tcx.cast_kinds.borrow().get(&from.id) {\n+                None => v.tcx.sess.span_bug(e.span, \"no kind for cast\"),\n+                Some(&CastKind::PtrAddrCast) | Some(&CastKind::FnPtrAddrCast) => {\n+                    v.add_qualif(ConstQualif::NOT_CONST);\n+                    if v.mode != Mode::Var {\n+                        span_err!(v.tcx.sess, e.span, E0018,\n+                                  \"can't cast a pointer to an integer in {}s\", v.msg());\n+                    }\n                 }\n+                _ => {}\n             }\n         }\n         ast::ExprPath(..) => {"}, {"sha": "03de553e648d8d49dd47c39d9c70c03accc29c7e", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -1002,7 +1002,7 @@ fn cast_const<'tcx>(tcx: &ty::ctxt<'tcx>, val: const_val, ty: Ty) -> CastResult\n     macro_rules! convert_val {\n         ($intermediate_ty:ty, $const_type:ident, $target_ty:ty) => {\n             match val {\n-                const_bool(b) => Ok($const_type(b as $intermediate_ty as $target_ty)),\n+                const_bool(b) => Ok($const_type(b as u64 as $intermediate_ty as $target_ty)),\n                 const_uint(u) => Ok($const_type(u as $intermediate_ty as $target_ty)),\n                 const_int(i) => Ok($const_type(i as $intermediate_ty as $target_ty)),\n                 const_float(f) => Ok($const_type(f as $intermediate_ty as $target_ty)),"}, {"sha": "15e1ac2f2c65e1867f8be316ad02d20cca743425", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -41,6 +41,7 @@ use session::Session;\n use lint;\n use metadata::csearch;\n use middle;\n+use middle::cast;\n use middle::check_const;\n use middle::const_eval;\n use middle::def::{self, DefMap, ExportMap};\n@@ -288,15 +289,6 @@ pub struct field_ty {\n     pub origin: ast::DefId,  // The DefId of the struct in which the field is declared.\n }\n \n-// Contains information needed to resolve types and (in the future) look up\n-// the types of AST nodes.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct creader_cache_key {\n-    pub cnum: CrateNum,\n-    pub pos: usize,\n-    pub len: usize\n-}\n-\n #[derive(Clone, PartialEq, RustcDecodable, RustcEncodable)]\n pub struct ItemVariances {\n     pub types: VecPerParamSpace<Variance>,\n@@ -562,6 +554,15 @@ pub enum vtable_origin<'tcx> {\n // expr to the associated trait ref.\n pub type ObjectCastMap<'tcx> = RefCell<NodeMap<ty::PolyTraitRef<'tcx>>>;\n \n+// Contains information needed to resolve types and (in the future) look up\n+// the types of AST nodes.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct creader_cache_key {\n+    pub cnum: CrateNum,\n+    pub pos: usize,\n+    pub len: usize\n+}\n+\n /// A restriction that certain types must be the same size. The use of\n /// `transmute` gives rise to these restrictions. These generally\n /// cannot be checked until trans; therefore, each call to `transmute`\n@@ -827,6 +828,10 @@ pub struct ctxt<'tcx> {\n \n     /// Caches CoerceUnsized kinds for impls on custom types.\n     pub custom_coerce_unsized_kinds: RefCell<DefIdMap<CustomCoerceUnsized>>,\n+\n+    /// Maps a cast expression to its kind. This is keyed on the\n+    /// *from* expression of the cast, not the cast itself.\n+    pub cast_kinds: RefCell<NodeMap<cast::CastKind>>,\n }\n \n impl<'tcx> ctxt<'tcx> {\n@@ -2817,6 +2822,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         type_impls_sized_cache: RefCell::new(HashMap::new()),\n         const_qualif_map: RefCell::new(NodeMap()),\n         custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n+        cast_kinds: RefCell::new(NodeMap()),\n    }\n }\n "}, {"sha": "3716ee395bfd4ffae49db92b71123849f41f90cb", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -206,7 +206,7 @@ impl LintPass for TypeLimits {\n                                 let (min, max) = int_ty_range(int_type);\n                                 let negative = self.negated_expr_id == e.id;\n \n-                                if (negative && v > (min.abs() as u64)) ||\n+                                if (negative && v > min.wrapping_neg() as u64) ||\n                                    (!negative && v > (max.abs() as u64)) {\n                                     cx.span_lint(OVERFLOWING_LITERALS, e.span,\n                                                  &*format!(\"literal out of range for {:?}\", t));"}, {"sha": "6d4c72c132a592ae1b060648dba77f7869e7b884", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -795,43 +795,40 @@ pub fn trans_switch<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-\n+pub fn is_discr_signed<'tcx>(r: &Repr<'tcx>) -> bool {\n+    match *r {\n+        CEnum(ity, _, _) => ity.is_signed(),\n+        General(ity, _, _) => ity.is_signed(),\n+        Univariant(..) => false,\n+        RawNullablePointer { .. } => false,\n+        StructWrappedNullablePointer { .. } => false,\n+    }\n+}\n \n /// Obtain the actual discriminant of a value.\n pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n                                    scrutinee: ValueRef, cast_to: Option<Type>)\n     -> ValueRef {\n-    let signed;\n-    let val;\n     debug!(\"trans_get_discr r: {:?}\", r);\n-    match *r {\n-        CEnum(ity, min, max) => {\n-            val = load_discr(bcx, ity, scrutinee, min, max);\n-            signed = ity.is_signed();\n-        }\n+    let val = match *r {\n+        CEnum(ity, min, max) => load_discr(bcx, ity, scrutinee, min, max),\n         General(ity, ref cases, _) => {\n             let ptr = GEPi(bcx, scrutinee, &[0, 0]);\n-            val = load_discr(bcx, ity, ptr, 0, (cases.len() - 1) as Disr);\n-            signed = ity.is_signed();\n-        }\n-        Univariant(..) => {\n-            val = C_u8(bcx.ccx(), 0);\n-            signed = false;\n+            load_discr(bcx, ity, ptr, 0, (cases.len() - 1) as Disr)\n         }\n+        Univariant(..) => C_u8(bcx.ccx(), 0),\n         RawNullablePointer { nndiscr, nnty, .. } =>  {\n             let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n             let llptrty = type_of::sizing_type_of(bcx.ccx(), nnty);\n-            val = ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty), DebugLoc::None);\n-            signed = false;\n+            ICmp(bcx, cmp, Load(bcx, scrutinee), C_null(llptrty), DebugLoc::None)\n         }\n         StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n-            val = struct_wrapped_nullable_bitdiscr(bcx, nndiscr, discrfield, scrutinee);\n-            signed = false;\n+            struct_wrapped_nullable_bitdiscr(bcx, nndiscr, discrfield, scrutinee)\n         }\n-    }\n+    };\n     match cast_to {\n         None => val,\n-        Some(llty) => if signed { SExt(bcx, val, llty) } else { ZExt(bcx, val, llty) }\n+        Some(llty) => if is_discr_signed(r) { SExt(bcx, val, llty) } else { ZExt(bcx, val, llty) }\n     }\n }\n "}, {"sha": "0684150112409100826b81636d369fa6ff9ed1fa", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -869,8 +869,7 @@ pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n {\n     let _icx = push_ctxt(\"with_cond\");\n \n-    if bcx.unreachable.get() ||\n-            (common::is_const(val) && common::const_to_uint(val) == 0) {\n+    if bcx.unreachable.get() || common::const_to_opt_uint(val) == Some(0) {\n         return bcx;\n     }\n "}, {"sha": "758702f54c049f7e5283ef3645e496cbed298a23", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -919,12 +919,6 @@ pub fn const_get_elt(cx: &CrateContext, v: ValueRef, us: &[c_uint])\n     }\n }\n \n-pub fn is_const(v: ValueRef) -> bool {\n-    unsafe {\n-        llvm::LLVMIsConstant(v) == True\n-    }\n-}\n-\n pub fn const_to_int(v: ValueRef) -> i64 {\n     unsafe {\n         llvm::LLVMConstIntGetSExtValue(v)"}, {"sha": "5ca14b63bce09ad731e6588f3f8ba664df4d429f", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -29,6 +29,7 @@ use trans::declare;\n use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n+use middle::cast::{CastTy,IntTy};\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use util::ppaux::{Repr, ty_to_string};\n@@ -616,53 +617,64 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               }\n           }\n           ast::ExprCast(ref base, _) => {\n-            let llty = type_of::type_of(cx, ety);\n-            let (v, basety) = const_expr(cx, &**base, param_substs);\n-            if expr::cast_is_noop(basety, ety) {\n+            let t_cast = ety;\n+            let llty = type_of::type_of(cx, t_cast);\n+            let (v, t_expr) = const_expr(cx, &**base, param_substs);\n+            debug!(\"trans_const_cast({} as {})\", t_expr.repr(cx.tcx()), t_cast.repr(cx.tcx()));\n+            if expr::cast_is_noop(cx.tcx(), base, t_expr, t_cast) {\n                 return v;\n             }\n-            match (expr::cast_type_kind(cx.tcx(), basety),\n-                   expr::cast_type_kind(cx.tcx(), ety)) {\n-\n-              (expr::cast_integral, expr::cast_integral) => {\n-                let s = ty::type_is_signed(basety) as Bool;\n+            if type_is_fat_ptr(cx.tcx(), t_expr) {\n+                // Fat pointer casts.\n+                let t_cast_inner = ty::deref(t_cast, true).expect(\"cast to non-pointer\").ty;\n+                let ptr_ty = type_of::in_memory_type_of(cx, t_cast_inner).ptr_to();\n+                let addr = ptrcast(const_get_elt(cx, v, &[abi::FAT_PTR_ADDR as u32]),\n+                                   ptr_ty);\n+                if type_is_fat_ptr(cx.tcx(), t_cast) {\n+                    let info = const_get_elt(cx, v, &[abi::FAT_PTR_EXTRA as u32]);\n+                    return C_struct(cx, &[addr, info], false)\n+                } else {\n+                    return addr;\n+                }\n+            }\n+            match (CastTy::from_ty(cx.tcx(), t_expr).expect(\"bad input type for cast\"),\n+                   CastTy::from_ty(cx.tcx(), t_cast).expect(\"bad output type for cast\")) {\n+              (CastTy::Int(IntTy::CEnum), CastTy::Int(_)) => {\n+                let repr = adt::represent_type(cx, t_expr);\n+                let discr = adt::const_get_discrim(cx, &*repr, v);\n+                let iv = C_integral(cx.int_type(), discr, false);\n+                let s = adt::is_discr_signed(&*repr) as Bool;\n+                llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n+              }\n+              (CastTy::Int(_), CastTy::Int(_)) => {\n+                let s = ty::type_is_signed(t_expr) as Bool;\n                 llvm::LLVMConstIntCast(v, llty.to_ref(), s)\n               }\n-              (expr::cast_integral, expr::cast_float) => {\n-                if ty::type_is_signed(basety) {\n+              (CastTy::Int(_), CastTy::Float) => {\n+                if ty::type_is_signed(t_expr) {\n                     llvm::LLVMConstSIToFP(v, llty.to_ref())\n                 } else {\n                     llvm::LLVMConstUIToFP(v, llty.to_ref())\n                 }\n               }\n-              (expr::cast_float, expr::cast_float) => {\n+              (CastTy::Float, CastTy::Float) => {\n                 llvm::LLVMConstFPCast(v, llty.to_ref())\n               }\n-              (expr::cast_float, expr::cast_integral) => {\n-                if ty::type_is_signed(ety) { llvm::LLVMConstFPToSI(v, llty.to_ref()) }\n-                else { llvm::LLVMConstFPToUI(v, llty.to_ref()) }\n+              (CastTy::Float, CastTy::Int(IntTy::I)) => {\n+                llvm::LLVMConstFPToSI(v, llty.to_ref())\n               }\n-              (expr::cast_enum, expr::cast_integral) => {\n-                let repr = adt::represent_type(cx, basety);\n-                let discr = adt::const_get_discrim(cx, &*repr, v);\n-                let iv = C_integral(cx.int_type(), discr, false);\n-                let ety_cast = expr::cast_type_kind(cx.tcx(), ety);\n-                match ety_cast {\n-                    expr::cast_integral => {\n-                        let s = ty::type_is_signed(ety) as Bool;\n-                        llvm::LLVMConstIntCast(iv, llty.to_ref(), s)\n-                    }\n-                    _ => cx.sess().bug(\"enum cast destination is not \\\n-                                        integral\")\n-                }\n+              (CastTy::Float, CastTy::Int(_)) => {\n+                llvm::LLVMConstFPToUI(v, llty.to_ref())\n               }\n-              (expr::cast_pointer, expr::cast_pointer) => {\n+              (CastTy::Ptr(_), CastTy::Ptr(_)) | (CastTy::FnPtr, CastTy::Ptr(_))\n+                    | (CastTy::RPtr(_), CastTy::Ptr(_)) => {\n                 ptrcast(v, llty)\n               }\n-              (expr::cast_integral, expr::cast_pointer) => {\n+              (CastTy::FnPtr, CastTy::FnPtr) => ptrcast(v, llty), // isn't this a coercion?\n+              (CastTy::Int(_), CastTy::Ptr(_)) => {\n                 llvm::LLVMConstIntToPtr(v, llty.to_ref())\n               }\n-              (expr::cast_pointer, expr::cast_integral) => {\n+              (CastTy::Ptr(_), CastTy::Int(_)) | (CastTy::FnPtr, CastTy::Int(_)) => {\n                 llvm::LLVMConstPtrToInt(v, llty.to_ref())\n               }\n               _ => {"}, {"sha": "ab8cfa0ce3b7eaa72508ab75824b002b2ceb3530", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -166,31 +166,24 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let cond_val = unpack_result!(bcx, expr::trans(bcx, cond).to_llbool());\n \n     // Drop branches that are known to be impossible\n-    if is_const(cond_val) && !is_undef(cond_val) {\n-        if const_to_uint(cond_val) == 1 {\n-            match els {\n-                Some(elexpr) => {\n-                    let mut trans = TransItemVisitor { ccx: bcx.fcx.ccx };\n-                    trans.visit_expr(&*elexpr);\n-                }\n-                None => {}\n-            }\n+    if let Some(cv) = const_to_opt_uint(cond_val) {\n+        if cv == 1 {\n             // if true { .. } [else { .. }]\n             bcx = trans_block(bcx, &*thn, dest);\n             trans::debuginfo::clear_source_location(bcx.fcx);\n+\n+            if let Some(elexpr) = els {\n+                let mut trans = TransItemVisitor { ccx: bcx.fcx.ccx };\n+                trans.visit_expr(&*elexpr);\n+            }\n         } else {\n-            let mut trans = TransItemVisitor { ccx: bcx.fcx.ccx } ;\n+            // if false { .. } [else { .. }]\n+            let mut trans = TransItemVisitor { ccx: bcx.fcx.ccx };\n             trans.visit_block(&*thn);\n \n-            match els {\n-                // if false { .. } else { .. }\n-                Some(elexpr) => {\n-                    bcx = expr::trans_into(bcx, &*elexpr, dest);\n-                    trans::debuginfo::clear_source_location(bcx.fcx);\n-                }\n-\n-                // if false { .. }\n-                None => { }\n+            if let Some(elexpr) = els {\n+                bcx = expr::trans_into(bcx, &*elexpr, dest);\n+                trans::debuginfo::clear_source_location(bcx.fcx);\n             }\n         }\n "}, {"sha": "33eb3814087f52e21a95e215142e45e5ca0d2db8", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 112, "deletions": 142, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -48,7 +48,6 @@\n \n #![allow(non_camel_case_types)]\n \n-pub use self::cast_kind::*;\n pub use self::Dest::*;\n use self::lazy_binop_ty::*;\n \n@@ -73,6 +72,7 @@ use trans::meth;\n use trans::monomorphize;\n use trans::tvec;\n use trans::type_of;\n+use middle::cast::{CastKind, CastTy};\n use middle::ty::{struct_fields, tup_fields};\n use middle::ty::{AdjustDerefRef, AdjustReifyFnPointer, AdjustUnsafeFnPointer};\n use middle::ty::{self, Ty};\n@@ -1981,177 +1981,147 @@ fn trans_overloaded_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     bcx\n }\n \n-fn int_cast(bcx: Block,\n-            lldsttype: Type,\n-            llsrctype: Type,\n-            llsrc: ValueRef,\n-            signed: bool)\n-            -> ValueRef {\n-    let _icx = push_ctxt(\"int_cast\");\n-    let srcsz = llsrctype.int_width();\n-    let dstsz = lldsttype.int_width();\n-    return if dstsz == srcsz {\n-        BitCast(bcx, llsrc, lldsttype)\n-    } else if srcsz > dstsz {\n-        TruncOrBitCast(bcx, llsrc, lldsttype)\n-    } else if signed {\n-        SExtOrBitCast(bcx, llsrc, lldsttype)\n-    } else {\n-        ZExtOrBitCast(bcx, llsrc, lldsttype)\n-    }\n-}\n-\n-fn float_cast(bcx: Block,\n-              lldsttype: Type,\n-              llsrctype: Type,\n-              llsrc: ValueRef)\n-              -> ValueRef {\n-    let _icx = push_ctxt(\"float_cast\");\n-    let srcsz = llsrctype.float_width();\n-    let dstsz = lldsttype.float_width();\n-    return if dstsz > srcsz {\n-        FPExt(bcx, llsrc, lldsttype)\n-    } else if srcsz > dstsz {\n-        FPTrunc(bcx, llsrc, lldsttype)\n-    } else { llsrc };\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Debug)]\n-pub enum cast_kind {\n-    cast_pointer,\n-    cast_fat_ptr,\n-    cast_integral,\n-    cast_float,\n-    cast_enum,\n-    cast_other,\n-}\n-\n-pub fn cast_type_kind<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> cast_kind {\n-    match t.sty {\n-        ty::ty_char        => cast_integral,\n-        ty::ty_float(..)   => cast_float,\n-        ty::ty_rptr(_, mt) | ty::ty_ptr(mt) => {\n-            if type_is_sized(tcx, mt.ty) {\n-                cast_pointer\n-            } else {\n-                cast_fat_ptr\n-            }\n-        }\n-        ty::ty_bare_fn(..) => cast_pointer,\n-        ty::ty_int(..)     => cast_integral,\n-        ty::ty_uint(..)    => cast_integral,\n-        ty::ty_bool        => cast_integral,\n-        ty::ty_enum(..)    => cast_enum,\n-        _                  => cast_other\n+pub fn cast_is_noop<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                          expr: &ast::Expr,\n+                          t_in: Ty<'tcx>,\n+                          t_out: Ty<'tcx>)\n+                          -> bool {\n+    if let Some(&CastKind::CoercionCast) = tcx.cast_kinds.borrow().get(&expr.id) {\n+        return true;\n     }\n-}\n \n-pub fn cast_is_noop<'tcx>(t_in: Ty<'tcx>, t_out: Ty<'tcx>) -> bool {\n     match (ty::deref(t_in, true), ty::deref(t_out, true)) {\n         (Some(ty::mt{ ty: t_in, .. }), Some(ty::mt{ ty: t_out, .. })) => {\n             t_in == t_out\n         }\n-        _ => false\n+        _ => {\n+            // This condition isn't redundant with the check for CoercionCast:\n+            // different types can be substituted into the same type, and\n+            // == equality can be overconservative if there are regions.\n+            t_in == t_out\n+        }\n     }\n }\n \n fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               expr: &ast::Expr,\n                               id: ast::NodeId)\n-                              -> DatumBlock<'blk, 'tcx, Expr> {\n+                              -> DatumBlock<'blk, 'tcx, Expr>\n+{\n+    use middle::cast::CastTy::*;\n+    use middle::cast::IntTy::*;\n+\n+    fn int_cast(bcx: Block,\n+                lldsttype: Type,\n+                llsrctype: Type,\n+                llsrc: ValueRef,\n+                signed: bool)\n+                -> ValueRef\n+    {\n+        let _icx = push_ctxt(\"int_cast\");\n+        let srcsz = llsrctype.int_width();\n+        let dstsz = lldsttype.int_width();\n+        return if dstsz == srcsz {\n+            BitCast(bcx, llsrc, lldsttype)\n+        } else if srcsz > dstsz {\n+            TruncOrBitCast(bcx, llsrc, lldsttype)\n+        } else if signed {\n+            SExtOrBitCast(bcx, llsrc, lldsttype)\n+        } else {\n+            ZExtOrBitCast(bcx, llsrc, lldsttype)\n+        }\n+    }\n+\n+    fn float_cast(bcx: Block,\n+                  lldsttype: Type,\n+                  llsrctype: Type,\n+                  llsrc: ValueRef)\n+                  -> ValueRef\n+    {\n+        let _icx = push_ctxt(\"float_cast\");\n+        let srcsz = llsrctype.float_width();\n+        let dstsz = lldsttype.float_width();\n+        return if dstsz > srcsz {\n+            FPExt(bcx, llsrc, lldsttype)\n+        } else if srcsz > dstsz {\n+            FPTrunc(bcx, llsrc, lldsttype)\n+        } else { llsrc };\n+    }\n+\n     let _icx = push_ctxt(\"trans_cast\");\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();\n \n     let t_in = expr_ty_adjusted(bcx, expr);\n     let t_out = node_id_type(bcx, id);\n-    let k_in = cast_type_kind(bcx.tcx(), t_in);\n-    let k_out = cast_type_kind(bcx.tcx(), t_out);\n-    let s_in = k_in == cast_integral && ty::type_is_signed(t_in);\n-    let ll_t_in = type_of::arg_type_of(ccx, t_in);\n-    let ll_t_out = type_of::arg_type_of(ccx, t_out);\n \n+    debug!(\"trans_cast({} as {})\", t_in.repr(bcx.tcx()), t_out.repr(bcx.tcx()));\n+    let mut ll_t_in = type_of::arg_type_of(ccx, t_in);\n+    let ll_t_out = type_of::arg_type_of(ccx, t_out);\n     // Convert the value to be cast into a ValueRef, either by-ref or\n     // by-value as appropriate given its type:\n     let mut datum = unpack_datum!(bcx, trans(bcx, expr));\n \n     let datum_ty = monomorphize_type(bcx, datum.ty);\n-    if cast_is_noop(datum_ty, t_out) {\n+\n+    if cast_is_noop(bcx.tcx(), expr, datum_ty, t_out) {\n         datum.ty = t_out;\n         return DatumBlock::new(bcx, datum);\n     }\n \n-    let newval = match (k_in, k_out) {\n-        (cast_integral, cast_integral) => {\n-            let llexpr = datum.to_llscalarish(bcx);\n-            int_cast(bcx, ll_t_out, ll_t_in, llexpr, s_in)\n-        }\n-        (cast_float, cast_float) => {\n-            let llexpr = datum.to_llscalarish(bcx);\n-            float_cast(bcx, ll_t_out, ll_t_in, llexpr)\n-        }\n-        (cast_integral, cast_float) => {\n-            let llexpr = datum.to_llscalarish(bcx);\n-            if s_in {\n-                SIToFP(bcx, llexpr, ll_t_out)\n-            } else { UIToFP(bcx, llexpr, ll_t_out) }\n-        }\n-        (cast_float, cast_integral) => {\n-            let llexpr = datum.to_llscalarish(bcx);\n-            if ty::type_is_signed(t_out) {\n-                FPToSI(bcx, llexpr, ll_t_out)\n-            } else { FPToUI(bcx, llexpr, ll_t_out) }\n-        }\n-        (cast_integral, cast_pointer) => {\n-            let llexpr = datum.to_llscalarish(bcx);\n-            IntToPtr(bcx, llexpr, ll_t_out)\n-        }\n-        (cast_pointer, cast_integral) => {\n-            let llexpr = datum.to_llscalarish(bcx);\n-            PtrToInt(bcx, llexpr, ll_t_out)\n-        }\n-        (cast_fat_ptr, cast_integral) => {\n-            let data_ptr = Load(bcx, get_dataptr(bcx, datum.val));\n-            PtrToInt(bcx, data_ptr, ll_t_out)\n-        }\n-        (cast_pointer, cast_pointer) => {\n-            let llexpr = datum.to_llscalarish(bcx);\n-            PointerCast(bcx, llexpr, ll_t_out)\n-        }\n-        (cast_fat_ptr, cast_pointer) => {\n-            let data_ptr = Load(bcx, get_dataptr(bcx, datum.val));\n-            PointerCast(bcx, data_ptr, ll_t_out)\n+    if type_is_fat_ptr(bcx.tcx(), t_in) {\n+        assert!(datum.kind.is_by_ref());\n+        if type_is_fat_ptr(bcx.tcx(), t_out) {\n+            return DatumBlock::new(bcx, Datum::new(\n+                PointerCast(bcx, datum.val, ll_t_out.ptr_to()),\n+                t_out,\n+                Rvalue::new(ByRef)\n+            )).to_expr_datumblock();\n+        } else {\n+            // Return the address\n+            return immediate_rvalue_bcx(bcx,\n+                                        PointerCast(bcx,\n+                                                    Load(bcx, get_dataptr(bcx, datum.val)),\n+                                                    ll_t_out),\n+                                        t_out).to_expr_datumblock();\n         }\n-        (cast_enum, cast_integral) |\n-        (cast_enum, cast_float) => {\n-            let mut bcx = bcx;\n-            let repr = adt::represent_type(ccx, t_in);\n-            let datum = unpack_datum!(\n-                bcx, datum.to_lvalue_datum(bcx, \"trans_imm_cast\", expr.id));\n-            let llexpr_ptr = datum.to_llref();\n-            let lldiscrim_a =\n-                adt::trans_get_discr(bcx, &*repr, llexpr_ptr, Some(Type::i64(ccx)));\n-            match k_out {\n-                cast_integral => int_cast(bcx, ll_t_out,\n-                                          val_ty(lldiscrim_a),\n-                                          lldiscrim_a, true),\n-                cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n-                _ => {\n-                    ccx.sess().bug(&format!(\"translating unsupported cast: \\\n-                                            {} ({:?}) -> {} ({:?})\",\n-                                            t_in.repr(bcx.tcx()),\n-                                            k_in,\n-                                            t_out.repr(bcx.tcx()),\n-                                            k_out))\n-                }\n-            }\n+    }\n+\n+    let r_t_in = CastTy::from_ty(bcx.tcx(), t_in).expect(\"bad input type for cast\");\n+    let r_t_out = CastTy::from_ty(bcx.tcx(), t_out).expect(\"bad output type for cast\");\n+\n+    let (llexpr, signed) = if let Int(CEnum) = r_t_in {\n+        let repr = adt::represent_type(ccx, t_in);\n+        let datum = unpack_datum!(\n+            bcx, datum.to_lvalue_datum(bcx, \"trans_imm_cast\", expr.id));\n+        let llexpr_ptr = datum.to_llref();\n+        let discr = adt::trans_get_discr(bcx, &*repr, llexpr_ptr, Some(Type::i64(ccx)));\n+        ll_t_in = val_ty(discr);\n+        (discr, adt::is_discr_signed(&*repr))\n+    } else {\n+        (datum.to_llscalarish(bcx), ty::type_is_signed(t_in))\n+    };\n+\n+    let newval = match (r_t_in, r_t_out) {\n+        (Ptr(_), Ptr(_)) | (FnPtr, Ptr(_)) | (RPtr(_), Ptr(_)) => {\n+            PointerCast(bcx, llexpr, ll_t_out)\n         }\n-        _ => ccx.sess().bug(&format!(\"translating unsupported cast: \\\n-                                    {} ({:?}) -> {} ({:?})\",\n-                                    t_in.repr(bcx.tcx()),\n-                                    k_in,\n-                                    t_out.repr(bcx.tcx()),\n-                                    k_out))\n+        (Ptr(_), Int(_)) | (FnPtr, Int(_)) => PtrToInt(bcx, llexpr, ll_t_out),\n+        (Int(_), Ptr(_)) => IntToPtr(bcx, llexpr, ll_t_out),\n+\n+        (Int(_), Int(_)) => int_cast(bcx, ll_t_out, ll_t_in, llexpr, signed),\n+        (Float, Float) => float_cast(bcx, ll_t_out, ll_t_in, llexpr),\n+        (Int(_), Float) if signed => SIToFP(bcx, llexpr, ll_t_out),\n+        (Int(_), Float) => UIToFP(bcx, llexpr, ll_t_out),\n+        (Float, Int(I)) => FPToSI(bcx, llexpr, ll_t_out),\n+        (Float, Int(_)) => FPToUI(bcx, llexpr, ll_t_out),\n+\n+        _ => ccx.sess().span_bug(expr.span,\n+                                  &format!(\"translating unsupported cast: \\\n+                                            {} -> {}\",\n+                                           t_in.repr(bcx.tcx()),\n+                                           t_out.repr(bcx.tcx()))\n+                                 )\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }"}, {"sha": "5258a77204d60e3f25f949df3ecbced0b7e72ee0", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 322, "deletions": 136, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -9,18 +9,43 @@\n // except according to those terms.\n \n //! Code for type-checking cast expressions.\n+//!\n+//! A cast `e as U` is valid if one of the following holds:\n+//! * `e` has type `T` and `T` coerces to `U`; *coercion-cast*\n+//! * `e` has type `*T`, `U` is `*U_0`, and either `U_0: Sized` or\n+//!    unsize_kind(`T`) = unsize_kind(`U_0`); *ptr-ptr-cast*\n+//! * `e` has type `*T` and `U` is a numeric type, while `T: Sized`; *ptr-addr-cast*\n+//! * `e` is an integer and `U` is `*U_0`, while `U_0: Sized`; *addr-ptr-cast*\n+//! * `e` has type `T` and `T` and `U` are any numeric types; *numeric-cast*\n+//! * `e` is a C-like enum and `U` is an integer type; *enum-cast*\n+//! * `e` has type `bool` or `char` and `U` is an integer; *prim-int-cast*\n+//! * `e` has type `u8` and `U` is `char`; *u8-char-cast*\n+//! * `e` has type `&[T; n]` and `U` is `*const T`; *array-ptr-cast*\n+//! * `e` is a function pointer type and `U` has type `*T`,\n+//!   while `T: Sized`; *fptr-ptr-cast*\n+//! * `e` is a function pointer type and `U` is an integer; *fptr-addr-cast*\n+//!\n+//! where `&.T` and `*T` are references of either mutability,\n+//! and where unsize_kind(`T`) is the kind of the unsize info\n+//! in `T` - a vtable or a length (or `()` if `T: Sized`).\n+//!\n+//! Casting is not transitive, that is, even if `e as U1 as U2` is a valid\n+//! expression, `e as U2` is not necessarily so (in fact it will only be valid if\n+//! `U1` coerces to `U2`).\n \n use super::coercion;\n use super::demand;\n use super::FnCtxt;\n use super::structurally_resolved_type;\n \n use lint;\n-use middle::infer;\n+use middle::cast::{CastKind, CastTy};\n use middle::ty;\n use middle::ty::Ty;\n use syntax::ast;\n+use syntax::ast::UintTy::{TyU8};\n use syntax::codemap::Span;\n+use util::ppaux::Repr;\n \n /// Reifies a cast check to be checked once we have full type information for\n /// a function context.\n@@ -31,6 +56,52 @@ pub struct CastCheck<'tcx> {\n     span: Span,\n }\n \n+/// The kind of the unsize info (length or vtable) - we only allow casts between\n+/// fat pointers if their unsize-infos have the same kind.\n+#[derive(Copy, Clone, PartialEq, Eq)]\n+enum UnsizeKind<'tcx> {\n+    Vtable,\n+    Length,\n+    /// The unsize info of this projection\n+    OfProjection(&'tcx ty::ProjectionTy<'tcx>),\n+    /// The unsize info of this parameter\n+    OfParam(&'tcx ty::ParamTy)\n+}\n+\n+/// Returns the kind of unsize information of t, or None\n+/// if t is sized or it is unknown.\n+fn unsize_kind<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                        t: Ty<'tcx>)\n+                        -> Option<UnsizeKind<'tcx>> {\n+    match t.sty {\n+        ty::ty_vec(_, None) | ty::ty_str => Some(UnsizeKind::Length),\n+        ty::ty_trait(_) => Some(UnsizeKind::Vtable),\n+        ty::ty_struct(did, substs) => {\n+            match ty::struct_fields(fcx.tcx(), did, substs).pop() {\n+                None => None,\n+                Some(f) => unsize_kind(fcx, f.mt.ty)\n+            }\n+        }\n+        // We should really try to normalize here.\n+        ty::ty_projection(ref pi) => Some(UnsizeKind::OfProjection(pi)),\n+        ty::ty_param(ref p) => Some(UnsizeKind::OfParam(p)),\n+        _ => None\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+enum CastError {\n+    CastToBool,\n+    CastToChar,\n+    DifferingKinds,\n+    IllegalCast,\n+    NeedViaPtr,\n+    NeedViaInt,\n+    NeedViaUsize,\n+    NonScalar,\n+    RefToMutPtr\n+}\n+\n impl<'tcx> CastCheck<'tcx> {\n     pub fn new(expr: ast::Expr, expr_ty: Ty<'tcx>, cast_ty: Ty<'tcx>, span: Span)\n                -> CastCheck<'tcx> {\n@@ -41,155 +112,270 @@ impl<'tcx> CastCheck<'tcx> {\n             span: span,\n         }\n     }\n-}\n \n-pub fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n-    fn cast_through_integer_err<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                          span: Span,\n-                                          t_1: Ty<'tcx>,\n-                                          t_e: Ty<'tcx>) {\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"illegal cast; cast through an \\\n-                    integer first: `{}` as `{}`\",\n-                    actual,\n-                    fcx.infcx().ty_to_string(t_1))\n-        }, t_e, None);\n+    fn report_cast_error<'a>(&self, fcx: &FnCtxt<'a, 'tcx>,\n+                             e: CastError) {\n+        match e {\n+            CastError::NeedViaPtr |\n+            CastError::NeedViaInt |\n+            CastError::NeedViaUsize => {\n+                fcx.type_error_message(self.span, |actual| {\n+                    format!(\"illegal cast; cast through {} first: `{}` as `{}`\",\n+                            match e {\n+                                CastError::NeedViaPtr => \"a raw pointer\",\n+                                CastError::NeedViaInt => \"an integer\",\n+                                CastError::NeedViaUsize => \"a usize\",\n+                                _ => unreachable!()\n+                            },\n+                            actual,\n+                            fcx.infcx().ty_to_string(self.cast_ty))\n+                }, self.expr_ty, None)\n+            }\n+            CastError::CastToBool => {\n+                span_err!(fcx.tcx().sess, self.span, E0054,\n+                          \"cannot cast as `bool`, compare with zero instead\");\n+            }\n+            CastError::CastToChar => {\n+                fcx.type_error_message(self.span, |actual| {\n+                    format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n+                }, self.expr_ty, None);\n+            }\n+            CastError::NonScalar => {\n+                fcx.type_error_message(self.span, |actual| {\n+                    format!(\"non-scalar cast: `{}` as `{}`\",\n+                            actual,\n+                            fcx.infcx().ty_to_string(self.cast_ty))\n+                }, self.expr_ty, None);\n+            }\n+            CastError::IllegalCast => {\n+                fcx.type_error_message(self.span, |actual| {\n+                    format!(\"illegal cast: `{}` as `{}`\",\n+                            actual,\n+                            fcx.infcx().ty_to_string(self.cast_ty))\n+                }, self.expr_ty, None);\n+            }\n+            CastError::DifferingKinds => {\n+                fcx.type_error_message(self.span, |actual| {\n+                    format!(\"illegal cast: `{}` as `{}`; vtable kinds may not match\",\n+                            actual,\n+                            fcx.infcx().ty_to_string(self.cast_ty))\n+                }, self.expr_ty, None);\n+            }\n+            CastError::RefToMutPtr => {\n+                span_err!(fcx.tcx().sess, self.span, E0188,\n+                          \"cannot cast an immutable reference to a \\\n+                           mutable pointer\");\n+            }\n+        }\n+    }\n+\n+    fn trivial_cast_lint<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) {\n+        let t_cast = self.cast_ty;\n+        let t_expr = self.expr_ty;\n+        if ty::type_is_numeric(t_cast) && ty::type_is_numeric(t_expr) {\n+            fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n+                                    self.expr.id,\n+                                    self.span,\n+                                    format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n+                                             replaced by coercion, this might require type \\\n+                                             ascription or a temporary variable\",\n+                                            fcx.infcx().ty_to_string(t_expr),\n+                                            fcx.infcx().ty_to_string(t_cast)));\n+        } else {\n+            fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n+                                    self.expr.id,\n+                                    self.span,\n+                                    format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n+                                             replaced by coercion, this might require type \\\n+                                             ascription or a temporary variable\",\n+                                            fcx.infcx().ty_to_string(t_expr),\n+                                            fcx.infcx().ty_to_string(t_cast)));\n+        }\n+\n     }\n \n-    let span = cast.span;\n-    let e = &cast.expr;\n-    let t_e = structurally_resolved_type(fcx, span, cast.expr_ty);\n-    let t_1 = structurally_resolved_type(fcx, span, cast.cast_ty);\n-    let tcx = fcx.tcx();\n-\n-    // Check for trivial casts.\n-    if !ty::type_has_ty_infer(t_1) {\n-        if let Ok(()) = coercion::mk_assignty(fcx, e, t_e, t_1) {\n-            if ty::type_is_numeric(t_1) && ty::type_is_numeric(t_e) {\n-                tcx.sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n-                                  e.id,\n-                                  span,\n-                                  format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n-                                           replaced by coercion, this might require type \\\n-                                           ascription or a temporary variable\",\n-                                          fcx.infcx().ty_to_string(t_e),\n-                                          fcx.infcx().ty_to_string(t_1)));\n-            } else {\n-                tcx.sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n-                                  e.id,\n-                                  span,\n-                                  format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n-                                           replaced by coercion, this might require type \\\n-                                           ascription or a temporary variable\",\n-                                          fcx.infcx().ty_to_string(t_e),\n-                                          fcx.infcx().ty_to_string(t_1)));\n+    pub fn check<'a>(mut self, fcx: &FnCtxt<'a, 'tcx>) {\n+        self.expr_ty = structurally_resolved_type(fcx, self.span, self.expr_ty);\n+        self.cast_ty = structurally_resolved_type(fcx, self.span, self.cast_ty);\n+\n+        debug!(\"check_cast({}, {} as {})\", self.expr.id, self.expr_ty.repr(fcx.tcx()),\n+               self.cast_ty.repr(fcx.tcx()));\n+\n+        if ty::type_is_error(self.expr_ty) || ty::type_is_error(self.cast_ty) {\n+            // No sense in giving duplicate error messages\n+        } else if self.try_coercion_cast(fcx) {\n+            self.trivial_cast_lint(fcx);\n+            debug!(\" -> CoercionCast\");\n+            fcx.tcx().cast_kinds.borrow_mut().insert(self.expr.id,\n+                                                     CastKind::CoercionCast);\n+        } else { match self.do_check(fcx) {\n+            Ok(k) => {\n+                debug!(\" -> {:?}\", k);\n+                fcx.tcx().cast_kinds.borrow_mut().insert(self.expr.id, k);\n             }\n-            return;\n+            Err(e) => self.report_cast_error(fcx, e)\n+        };}\n+    }\n+\n+    /// Check a cast, and report an error if one exists. In some cases, this\n+    /// can return Ok and create type errors in the fcx rather than returning\n+    /// directly. coercion-cast is handled in check instead of here.\n+    fn do_check<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> Result<CastKind, CastError> {\n+        use middle::cast::IntTy::*;\n+        use middle::cast::CastTy::*;\n+\n+        let (t_from, t_cast) = match (CastTy::from_ty(fcx.tcx(), self.expr_ty),\n+                                      CastTy::from_ty(fcx.tcx(), self.cast_ty)) {\n+            (Some(t_from), Some(t_cast)) => (t_from, t_cast),\n+            _ => {\n+                return Err(CastError::NonScalar)\n+            }\n+        };\n+\n+        match (t_from, t_cast) {\n+            // These types have invariants! can't cast into them.\n+            (_, RPtr(_)) | (_, Int(CEnum)) | (_, FnPtr) => Err(CastError::NonScalar),\n+\n+            // * -> Bool\n+            (_, Int(Bool)) => Err(CastError::CastToBool),\n+\n+            // * -> Char\n+            (Int(U(ast::TyU8)), Int(Char)) => Ok(CastKind::U8CharCast), // u8-char-cast\n+            (_, Int(Char)) => Err(CastError::CastToChar),\n+\n+            // prim -> float,ptr\n+            (Int(Bool), Float) | (Int(CEnum), Float) | (Int(Char), Float)\n+                => Err(CastError::NeedViaInt),\n+            (Int(Bool), Ptr(_)) | (Int(CEnum), Ptr(_)) | (Int(Char), Ptr(_))\n+                => Err(CastError::NeedViaUsize),\n+\n+            // ptr -> *\n+            (Ptr(m_e), Ptr(m_c)) => self.check_ptr_ptr_cast(fcx, m_e, m_c), // ptr-ptr-cast\n+            (Ptr(m_expr), Int(_)) => self.check_ptr_addr_cast(fcx, m_expr), // ptr-addr-cast\n+            (Ptr(_), Float) | (FnPtr, Float) => Err(CastError::NeedViaUsize),\n+            (FnPtr, Int(_)) => Ok(CastKind::FnPtrAddrCast),\n+            (RPtr(_), Int(_)) | (RPtr(_), Float) => Err(CastError::NeedViaPtr),\n+            // * -> ptr\n+            (Int(_), Ptr(mt)) => self.check_addr_ptr_cast(fcx, mt), // addr-ptr-cast\n+            (FnPtr, Ptr(mt)) => self.check_fptr_ptr_cast(fcx, mt),\n+            (Float, Ptr(_)) => Err(CastError::NeedViaUsize),\n+            (RPtr(rmt), Ptr(mt)) => self.check_ref_cast(fcx, rmt, mt), // array-ptr-cast\n+\n+            // prim -> prim\n+            (Int(CEnum), Int(_)) => Ok(CastKind::EnumCast),\n+            (Int(Char), Int(_)) | (Int(Bool), Int(_)) => Ok(CastKind::PrimIntCast),\n+\n+            (Int(_), Int(_)) |\n+            (Int(_), Float) |\n+            (Float, Int(_)) |\n+            (Float, Float) => Ok(CastKind::NumericCast),\n+\n         }\n     }\n \n-    let t_e_is_bare_fn_item = ty::type_is_bare_fn_item(t_e);\n-    let t_e_is_scalar = ty::type_is_scalar(t_e);\n-    let t_e_is_integral = ty::type_is_integral(t_e);\n-    let t_e_is_float = ty::type_is_floating_point(t_e);\n-    let t_e_is_c_enum = ty::type_is_c_like_enum(tcx, t_e);\n-\n-    let t_1_is_scalar = ty::type_is_scalar(t_1);\n-    let t_1_is_integral = ty::type_is_integral(t_1);\n-    let t_1_is_char = ty::type_is_char(t_1);\n-    let t_1_is_bare_fn = ty::type_is_bare_fn(t_1);\n-    let t_1_is_float = ty::type_is_floating_point(t_1);\n-    let t_1_is_c_enum = ty::type_is_c_like_enum(tcx, t_1);\n-    let t1_is_fat_ptr = fcx.type_is_fat_ptr(t_1, span);\n-\n-    // casts to scalars other than `char` and `bare fn` are trivial\n-    let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n-\n-    if t_e_is_bare_fn_item && t_1_is_bare_fn {\n-        demand::coerce(fcx, e.span, t_1, &e);\n-    } else if t_1_is_char {\n-        let t_e = fcx.infcx().shallow_resolve(t_e);\n-        if t_e.sty != ty::ty_uint(ast::TyU8) {\n-            fcx.type_error_message(span, |actual| {\n-                format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n-            }, t_e, None);\n+    fn check_ptr_ptr_cast<'a>(&self,\n+                              fcx: &FnCtxt<'a, 'tcx>,\n+                              m_expr: &'tcx ty::mt<'tcx>,\n+                              m_cast: &'tcx ty::mt<'tcx>)\n+                              -> Result<CastKind, CastError>\n+    {\n+        debug!(\"check_ptr_ptr_cast m_expr={} m_cast={}\",\n+               m_expr.repr(fcx.tcx()), m_cast.repr(fcx.tcx()));\n+        // ptr-ptr cast. vtables must match.\n+\n+        // Cast to sized is OK\n+        if fcx.type_is_known_to_be_sized(m_cast.ty, self.span) {\n+            return Ok(CastKind::PtrPtrCast);\n         }\n-    } else if t_1.sty == ty::ty_bool {\n-        span_err!(tcx.sess, span, E0054,\n-                  \"cannot cast as `bool`, compare with zero instead\");\n-    } else if t_e_is_float && (t_1_is_scalar || t_1_is_c_enum) &&\n-        !(t_1_is_integral || t_1_is_float) {\n-        // Casts from float must go through an integer\n-        cast_through_integer_err(fcx, span, t_1, t_e)\n-    } else if t_1_is_float && (t_e_is_scalar || t_e_is_c_enum) &&\n-        !(t_e_is_integral || t_e_is_float || t_e.sty == ty::ty_bool) {\n-        // Casts to float must go through an integer or boolean\n-        cast_through_integer_err(fcx, span, t_1, t_e)\n-    } else if t_e_is_c_enum && t_1_is_trivial {\n-        if ty::type_is_unsafe_ptr(t_1) {\n-            // ... and likewise with C enum -> *T\n-            cast_through_integer_err(fcx, span, t_1, t_e)\n+\n+        // sized -> unsized? report illegal cast (don't complain about vtable kinds)\n+        if fcx.type_is_known_to_be_sized(m_expr.ty, self.span) {\n+            return Err(CastError::IllegalCast);\n         }\n-        // casts from C-like enums are allowed\n-    } else if ty::type_is_region_ptr(t_e) && ty::type_is_unsafe_ptr(t_1) {\n-        fn types_compatible<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                                      t1: Ty<'tcx>, t2: Ty<'tcx>) -> bool {\n-            match t1.sty {\n-                ty::ty_vec(_, Some(_)) => {}\n-                _ => return false\n-            }\n-            if ty::type_needs_infer(t2) {\n-                // This prevents this special case from going off when casting\n-                // to a type that isn't fully specified; e.g. `as *_`. (Issue\n-                // #14893.)\n-                return false\n-            }\n \n-            let el = ty::sequence_element_type(fcx.tcx(), t1);\n-            infer::mk_eqty(fcx.infcx(),\n-                           false,\n-                           infer::Misc(sp),\n-                           el,\n-                           t2).is_ok()\n+        // vtable kinds must match\n+        match (unsize_kind(fcx, m_cast.ty), unsize_kind(fcx, m_expr.ty)) {\n+            (Some(a), Some(b)) if a == b => Ok(CastKind::PtrPtrCast),\n+            _ => Err(CastError::DifferingKinds)\n         }\n+    }\n \n-        // Due to the limitations of LLVM global constants,\n-        // region pointers end up pointing at copies of\n-        // vector elements instead of the original values.\n-        // To allow unsafe pointers to work correctly, we\n-        // need to special-case obtaining an unsafe pointer\n-        // from a region pointer to a vector.\n-\n-        /* this cast is only allowed from &[T, ..n] to *T or\n-        &T to *T. */\n-        match (&t_e.sty, &t_1.sty) {\n-            (&ty::ty_rptr(_, ty::mt { ty: mt1, mutbl: ast::MutImmutable }),\n-             &ty::ty_ptr(ty::mt { ty: mt2, mutbl: ast::MutImmutable }))\n-            if types_compatible(fcx, e.span, mt1, mt2) => {\n-                /* this case is allowed */\n-            }\n-            _ => {\n-                demand::coerce(fcx, e.span, t_1, &e);\n+    fn check_fptr_ptr_cast<'a>(&self,\n+                               fcx: &FnCtxt<'a, 'tcx>,\n+                               m_cast: &'tcx ty::mt<'tcx>)\n+                               -> Result<CastKind, CastError>\n+    {\n+        // fptr-ptr cast. must be to sized ptr\n+\n+        if fcx.type_is_known_to_be_sized(m_cast.ty, self.span) {\n+            Ok(CastKind::FnPtrPtrCast)\n+        } else {\n+            Err(CastError::IllegalCast)\n+        }\n+    }\n+\n+    fn check_ptr_addr_cast<'a>(&self,\n+                               fcx: &FnCtxt<'a, 'tcx>,\n+                               m_expr: &'tcx ty::mt<'tcx>)\n+                               -> Result<CastKind, CastError>\n+    {\n+        // ptr-addr cast. must be from sized ptr\n+\n+        if fcx.type_is_known_to_be_sized(m_expr.ty, self.span) {\n+            Ok(CastKind::PtrAddrCast)\n+        } else {\n+            Err(CastError::NeedViaPtr)\n+        }\n+    }\n+\n+    fn check_ref_cast<'a>(&self,\n+                          fcx: &FnCtxt<'a, 'tcx>,\n+                          m_expr: &'tcx ty::mt<'tcx>,\n+                          m_cast: &'tcx ty::mt<'tcx>)\n+                          -> Result<CastKind, CastError>\n+    {\n+        // array-ptr-cast.\n+\n+        if m_expr.mutbl == ast::MutImmutable && m_cast.mutbl == ast::MutImmutable {\n+            if let ty::ty_vec(ety, Some(_)) = m_expr.ty.sty {\n+                // Due to the limitations of LLVM global constants,\n+                // region pointers end up pointing at copies of\n+                // vector elements instead of the original values.\n+                // To allow unsafe pointers to work correctly, we\n+                // need to special-case obtaining an unsafe pointer\n+                // from a region pointer to a vector.\n+\n+                // this will report a type mismatch if needed\n+                demand::eqtype(fcx, self.span, ety, m_cast.ty);\n+                return Ok(CastKind::ArrayPtrCast);\n             }\n         }\n-    } else if t1_is_fat_ptr {\n-        // FIXME This should be allowed where the lefthandside is also a fat\n-        // pointer and is the same kind of fat pointer, i.e., array to array,\n-        // trait object to trait object. That is a bit looser than the current\n-        // rquirement that they are pointers to the same type.\n-        if !(fcx.type_is_fat_ptr(t_e, span) &&\n-             ty::deref(t_1, true).unwrap().ty == ty::deref(t_e, true).unwrap().ty) {\n-            fcx.type_error_message(span, |actual| {\n-                format!(\"cast to fat pointer: `{}` as `{}`\",\n-                        actual,\n-                        fcx.infcx().ty_to_string(t_1))\n-            }, t_e, None);\n+\n+        Err(CastError::IllegalCast)\n+    }\n+\n+    fn check_addr_ptr_cast<'a>(&self,\n+                               fcx: &FnCtxt<'a, 'tcx>,\n+                               m_cast: &'tcx ty::mt<'tcx>)\n+                               -> Result<CastKind, CastError>\n+    {\n+        // ptr-addr cast. pointer must be thin.\n+        if fcx.type_is_known_to_be_sized(m_cast.ty, self.span) {\n+           Ok(CastKind::AddrPtrCast)\n+        } else {\n+           Err(CastError::IllegalCast)\n         }\n-    } else if !(t_e_is_scalar && t_1_is_trivial) {\n-        fcx.type_error_message(span, |actual| {\n-            format!(\"non-scalar cast: `{}` as `{}`\",\n-                    actual,\n-                    fcx.infcx().ty_to_string(t_1))\n-        }, t_e, None);\n     }\n+\n+    fn try_coercion_cast<'a>(&self, fcx: &FnCtxt<'a, 'tcx>) -> bool {\n+        if let Ok(()) = coercion::mk_assignty(fcx,\n+                                              &self.expr,\n+                                              self.expr_ty,\n+                                              self.cast_ty) {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n }"}, {"sha": "0e64063d6a402f9981cf9de84f8a5e14b0cd1209", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -528,6 +528,9 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             upvar::closure_analyze_fn(&fcx, fn_id, decl, body);\n             fcx.select_all_obligations_or_error();\n             fcx.check_casts();\n+\n+            fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n+\n             regionck::regionck_fn(&fcx, fn_id, fn_span, decl, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n         }\n@@ -1112,20 +1115,20 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          span: Span,\n                                          t_span: Span,\n                                          e_span: Span,\n-                                         t_1: Ty<'tcx>,\n-                                         t_e: Ty<'tcx>,\n+                                         t_cast: Ty<'tcx>,\n+                                         t_expr: Ty<'tcx>,\n                                          id: ast::NodeId) {\n-    let tstr = fcx.infcx().ty_to_string(t_1);\n+    let tstr = fcx.infcx().ty_to_string(t_cast);\n     fcx.type_error_message(span, |actual| {\n         format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n-    }, t_e, None);\n-    match t_e.sty {\n+    }, t_expr, None);\n+    match t_expr.sty {\n         ty::ty_rptr(_, ty::mt { mutbl: mt, .. }) => {\n             let mtstr = match mt {\n                 ast::MutMutable => \"mut \",\n                 ast::MutImmutable => \"\"\n             };\n-            if ty::type_is_trait(t_1) {\n+            if ty::type_is_trait(t_cast) {\n                 match fcx.tcx().sess.codemap().span_to_snippet(t_span) {\n                     Ok(s) => {\n                         fcx.tcx().sess.span_suggestion(t_span,\n@@ -1581,13 +1584,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                                  span)\n     }\n \n-    pub fn type_is_fat_ptr(&self, ty: Ty<'tcx>, span: Span) -> bool {\n-        if let Some(mt) = ty::deref(ty, true) {\n-            return !self.type_is_known_to_be_sized(mt.ty, span);\n-        }\n-        false\n-    }\n-\n     pub fn register_builtin_bound(&self,\n                                   ty: Ty<'tcx>,\n                                   builtin_bound: ty::BuiltinBound,\n@@ -1810,11 +1806,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn check_casts(&self) {\n         let mut deferred_cast_checks = self.inh.deferred_cast_checks.borrow_mut();\n-        for check in deferred_cast_checks.iter() {\n-            cast::check_cast(self, check);\n+        for cast in deferred_cast_checks.drain(..) {\n+            cast.check(self);\n         }\n-\n-        deferred_cast_checks.clear();\n     }\n \n     fn select_all_obligations_and_apply_defaults(&self) {\n@@ -3410,24 +3404,24 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n         // Find the type of `e`. Supply hints based on the type we are casting to,\n         // if appropriate.\n-        let t_1 = fcx.to_ty(t);\n-        let t_1 = structurally_resolved_type(fcx, expr.span, t_1);\n-        check_expr_with_expectation(fcx, e, ExpectCastableToType(t_1));\n-        let t_e = fcx.expr_ty(e);\n+        let t_cast = fcx.to_ty(t);\n+        let t_cast = structurally_resolved_type(fcx, expr.span, t_cast);\n+        check_expr_with_expectation(fcx, e, ExpectCastableToType(t_cast));\n+        let t_expr = fcx.expr_ty(e);\n \n         // Eagerly check for some obvious errors.\n-        if ty::type_is_error(t_e) {\n+        if ty::type_is_error(t_expr) {\n             fcx.write_error(id);\n-        } else if !fcx.type_is_known_to_be_sized(t_1, expr.span) {\n-            report_cast_to_unsized_type(fcx, expr.span, t.span, e.span, t_1, t_e, id);\n+        } else if !fcx.type_is_known_to_be_sized(t_cast, expr.span) {\n+            report_cast_to_unsized_type(fcx, expr.span, t.span, e.span, t_cast, t_expr, id);\n         } else {\n             // Write a type for the whole expression, assuming everything is going\n             // to work out Ok.\n-            fcx.write_ty(id, t_1);\n+            fcx.write_ty(id, t_cast);\n \n             // Defer other checks until we're done type checking.\n             let mut deferred_cast_checks = fcx.inh.deferred_cast_checks.borrow_mut();\n-            let cast_check = cast::CastCheck::new((**e).clone(), t_e, t_1, expr.span);\n+            let cast_check = cast::CastCheck::new((**e).clone(), t_expr, t_cast, expr.span);\n             deferred_cast_checks.push(cast_check);\n         }\n       }"}, {"sha": "c9176f4d7cfcdd5535fb645c53aa5a7eac76258f", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -977,11 +977,11 @@ register_diagnostics! {\n     E0185,\n     E0186,\n     E0187, // can't infer the kind of the closure\n-    E0188, // types differ in mutability\n-    E0189, // can only cast a boxed pointer to a boxed object\n-    E0190, // can only cast a &-pointer to an &-object\n+    E0188, // can not cast a immutable reference to a mutable pointer\n+    E0189, // deprecated: can only cast a boxed pointer to a boxed object\n+    E0190, // deprecated: can only cast a &-pointer to an &-object\n     E0191, // value of the associated type must be specified\n-    E0192, // negative imples are allowed just for `Send` and `Sync`\n+    E0192, // negative impls are allowed just for `Send` and `Sync`\n     E0193, // cannot bound type where clause bounds may only be attached to types\n            // involving type parameters\n     E0194,"}, {"sha": "25602cb0ee3a10841b5233b9c0e0718d056ed91a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -77,7 +77,7 @@ This API is completely unstable and subject to change.\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n-#![feature(collections)]\n+#![feature(collections, collections_drain)]\n #![feature(core)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "c1feb8ac45900a052d0ae393029bd71787c9e5ac", "filename": "src/test/compile-fail/associated-types-incomplete-object.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fassociated-types-incomplete-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fassociated-types-incomplete-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-incomplete-object.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -28,15 +28,15 @@ impl Foo for isize {\n }\n \n pub fn main() {\n-    let a = &42 as &Foo<A=usize, B=char>;\n+    let a = &42isize as &Foo<A=usize, B=char>;\n \n-    let b = &42 as &Foo<A=usize>;\n+    let b = &42isize as &Foo<A=usize>;\n     //~^ ERROR the value of the associated type `B` (from the trait `Foo`) must be specified\n \n-    let c = &42 as &Foo<B=char>;\n+    let c = &42isize as &Foo<B=char>;\n     //~^ ERROR the value of the associated type `A` (from the trait `Foo`) must be specified\n \n-    let d = &42 as &Foo;\n+    let d = &42isize as &Foo;\n     //~^ ERROR the value of the associated type `A` (from the trait `Foo`) must be specified\n     //~| ERROR the value of the associated type `B` (from the trait `Foo`) must be specified\n }"}, {"sha": "7c32e31d23b24f4a92a6d262eeaae2bcb0f66b38", "filename": "src/test/compile-fail/cast-ptr-to-int-const.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fcast-ptr-to-int-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fcast-ptr-to-int-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-ptr-to-int-const.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    const X: u32 = main as u32; //~ ERROR E0018\n+    const Y: u32 = 0;\n+    const Z: u32 = &Y as *const u32 as u32; //~ ERROR E0018\n+}"}, {"sha": "f3537e54135084fcef980615feae4c084c75a10e", "filename": "src/test/compile-fail/cast-rfc0401.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-rfc0401.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn illegal_cast<U:?Sized,V:?Sized>(u: *const U) -> *const V\n+{\n+    u as *const V //~ ERROR vtable kinds\n+}\n+\n+fn illegal_cast_2<U:?Sized>(u: *const U) -> *const str\n+{\n+    u as *const str //~ ERROR vtable kinds\n+}\n+\n+trait Foo { fn foo(&self) {} }\n+impl<T> Foo for T {}\n+\n+enum E {\n+    A, B\n+}\n+\n+fn main()\n+{\n+    let f: f32 = 1.2;\n+    let v = 0 as *const u8;\n+    let fat_v : *const [u8] = unsafe { &*(0 as *const [u8; 1])};\n+    let foo: &Foo = &f;\n+\n+    let _ = v as &u8; //~ ERROR non-scalar\n+    let _ = v as E; //~ ERROR non-scalar\n+    let _ = v as fn(); //~ ERROR non-scalar\n+    let _ = v as (u32,); //~ ERROR non-scalar\n+    let _ = Some(&v) as *const u8; //~ ERROR non-scalar\n+\n+    let _ = v as f32; //~ ERROR through a usize first\n+    let _ = main as f64; //~ ERROR through a usize first\n+    let _ = &v as usize; //~ ERROR through a raw pointer first\n+    let _ = f as *const u8; //~ ERROR through a usize first\n+    let _ = 3 as bool; //~ ERROR compare with zero\n+    let _ = E::A as bool; //~ ERROR compare with zero\n+    let _ = 0x61u32 as char; //~ ERROR only `u8` can be cast\n+\n+    let _ = false as f32; //~ ERROR through an integer first\n+    let _ = E::A as f32; //~ ERROR through an integer first\n+    let _ = 'a' as f32; //~ ERROR through an integer first\n+\n+    let _ = false as *const u8; //~ ERROR through a usize first\n+    let _ = E::A as *const u8; //~ ERROR through a usize first\n+    let _ = 'a' as *const u8; //~ ERROR through a usize first\n+\n+    let _ = 42usize as *const [u8]; //~ ERROR illegal cast\n+    let _ = v as *const [u8]; //~ ERROR illegal cast\n+    let _ = fat_v as *const Foo;\n+    //~^ ERROR `core::marker::Sized` is not implemented for the type `[u8]`\n+    let _ = foo as *const str; //~ ERROR illegal cast\n+    let _ = foo as *mut str; //~ ERROR illegal cast\n+    let _ = main as *mut str; //~ ERROR illegal cast\n+    let _ = &f as *mut f32; //~ ERROR illegal cast\n+    let _ = &f as *const f64; //~ ERROR illegal cast\n+    let _ = fat_v as usize; //~ ERROR through a raw pointer first\n+\n+    let a : *const str = \"hello\";\n+    let _ = a as *const Foo;\n+    //~^ ERROR `core::marker::Sized` is not implemented for the type `str`\n+\n+    // check no error cascade\n+    let _ = main.f as *const u32; //~ ERROR attempted access of field\n+\n+}"}, {"sha": "7cc5c727bc7df786e045124167adf0757df82167", "filename": "src/test/compile-fail/cast-to-bare-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-to-bare-fn.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -13,7 +13,7 @@ fn foo(_x: isize) { }\n fn main() {\n     let v: u64 = 5;\n     let x = foo as extern \"C\" fn() -> isize;\n-    //~^ ERROR mismatched types\n+    //~^ ERROR non-scalar cast\n     let y = v as extern \"Rust\" fn(isize) -> (isize, isize);\n     //~^ ERROR non-scalar cast\n     y(x());"}, {"sha": "e6851f02cb6079b3734119a355ecfd317274a7aa", "filename": "src/test/compile-fail/const-cast-different-types.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-cast-different-types.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -9,18 +9,8 @@\n // except according to those terms.\n \n static a: &'static str = \"foo\";\n-static b: *const u8 = a as *const u8;\n-//~^ ERROR mismatched types\n-//~| expected *const u8\n-//~| found &'static str\n-//~| expected u8\n-//~| found str\n-static c: *const u8 = &a as *const u8;\n-//~^ ERROR mismatched types\n-//~| expected *const u8\n-//~| found &&'static str\n-//~| expected u8\n-//~| found &-ptr\n+static b: *const u8 = a as *const u8; //~ ERROR illegal cast\n+static c: *const u8 = &a as *const u8; //~ ERROR illegal cast\n \n fn main() {\n }"}, {"sha": "08db643df00e4736003e083e012f3e9898fbb587", "filename": "src/test/compile-fail/destructure-trait-ref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdestructure-trait-ref.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -28,29 +28,29 @@ fn main() {\n     // if n > m, it's a type mismatch error.\n \n     // n < m\n-    let &x = &(&1 as &T);\n-    let &x = &&(&1 as &T);\n-    let &&x = &&(&1 as &T);\n+    let &x = &(&1isize as &T);\n+    let &x = &&(&1isize as &T);\n+    let &&x = &&(&1isize as &T);\n \n     // n == m\n-    let &x = &1 as &T;      //~ ERROR type `&T` cannot be dereferenced\n-    let &&x = &(&1 as &T);  //~ ERROR type `&T` cannot be dereferenced\n-    let box x = box 1 as Box<T>; //~ ERROR the trait `core::marker::Sized` is not implemented\n+    let &x = &1isize as &T;      //~ ERROR type `&T` cannot be dereferenced\n+    let &&x = &(&1isize as &T);  //~ ERROR type `&T` cannot be dereferenced\n+    let box x = box 1isize as Box<T>; //~ ERROR the trait `core::marker::Sized` is not implemented\n \n     // n > m\n-    let &&x = &1 as &T;\n+    let &&x = &1isize as &T;\n     //~^ ERROR mismatched types\n     //~| expected `T`\n     //~| found `&_`\n     //~| expected trait T\n     //~| found &-ptr\n-    let &&&x = &(&1 as &T);\n+    let &&&x = &(&1isize as &T);\n     //~^ ERROR mismatched types\n     //~| expected `T`\n     //~| found `&_`\n     //~| expected trait T\n     //~| found &-ptr\n-    let box box x = box 1 as Box<T>;\n+    let box box x = box 1isize as Box<T>;\n     //~^ ERROR mismatched types\n     //~| expected `T`\n     //~| found `Box<_>`"}, {"sha": "25cab09b7cb497ff59f9b933ecb13b69e2b53a53", "filename": "src/test/compile-fail/fat-ptr-cast.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffat-ptr-cast.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -8,20 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Make sure casts between thin pointer <-> fat pointer are illegal.\n-\n-pub trait Trait {}\n+trait Trait {}\n \n+// Make sure casts between thin-pointer <-> fat pointer obey RFC401\n fn main() {\n     let a: &[i32] = &[1, 2, 3];\n     let b: Box<[i32]> = Box::new([1, 2, 3]);\n+    let p = a as *const [i32];\n+    let q = a.as_ptr();\n \n-    a as usize; //~ ERROR non-scalar cast\n+    a as usize; //~ ERROR illegal cast\n     b as usize; //~ ERROR non-scalar cast\n+    p as usize; //~ ERROR illegal cast; cast through a raw pointer\n \n-    let a: usize = 42;\n-    a as *const [i32]; //~ ERROR cast to fat pointer: `usize` as `*const [i32]`\n+    // #22955\n+    q as *const [i32]; //~ ERROR illegal cast\n \n-    let a: *const u8 = &42;\n-    a as *const [u8]; //~ ERROR cast to fat pointer: `*const u8` as `*const [u8]`\n+    // #21397\n+    let t: *mut (Trait + 'static) = 0 as *mut _; //~ ERROR illegal cast\n+    let mut fail: *const str = 0 as *const str; //~ ERROR illegal cast\n }"}, {"sha": "219f08ad35a845917eb139e83b9352440a20e372", "filename": "src/test/compile-fail/issue-14845.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -15,18 +15,8 @@ struct X {\n \n fn main() {\n     let x = X { a: [0] };\n-    let _f = &x.a as *mut u8;\n-    //~^ ERROR mismatched types\n-    //~| expected `*mut u8`\n-    //~| found `&[u8; 1]`\n-    //~| expected u8\n-    //~| found array of 1 elements\n+    let _f = &x.a as *mut u8; //~ ERROR illegal cast\n \n     let local: [u8; 1] = [0];\n-    let _v = &local as *mut u8;\n-    //~^ ERROR mismatched types\n-    //~| expected `*mut u8`\n-    //~| found `&[u8; 1]`\n-    //~| expected u8,\n-    //~| found array of 1 elements\n+    let _v = &local as *mut u8; //~ ERROR illegal cast\n }"}, {"sha": "a079161d42efaf836b452dba541bdc33371a7e6c", "filename": "src/test/compile-fail/issue-17444.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fissue-17444.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fissue-17444.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17444.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -14,5 +14,5 @@ enum Test {\n \n fn main() {\n     let _x = Test::Foo as *const isize;\n-    //~^ ERROR illegal cast; cast through an integer first: `Test` as `*const isize`\n+    //~^ ERROR illegal cast; cast through a usize first: `Test` as `*const isize`\n }"}, {"sha": "a3a9e17cb3c0676592539fbc1fd525f5f269deb8", "filename": "src/test/compile-fail/issue-17458.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17458.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n static X: usize = 0 as *const usize as usize;\n-//~^ ERROR: can not cast a pointer to an integer in statics\n+//~^ ERROR: can't cast a pointer to an integer in statics\n \n fn main() {\n     assert_eq!(X, 0);"}, {"sha": "16ce84715b154ce17e1c4bd1b883d140aaa8c577", "filename": "src/test/compile-fail/issue-21554.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fissue-21554.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fissue-21554.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21554.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -11,5 +11,5 @@\n struct Inches(i32);\n \n fn main() {\n-    Inches as f32; //~ ERROR illegal cast; cast through an integer first\n+    Inches as f32; //~ ERROR illegal cast; cast through a usize first\n }"}, {"sha": "bcbc414d3534bb3245dbd086701a0a2d7c68305e", "filename": "src/test/compile-fail/issue-22289.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22289.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    0 as &std::any::Any; //~ ERROR cast to fat pointer: `i32` as `&core::any::Any`\n+    0 as &std::any::Any; //~ ERROR non-scalar cast\n }"}, {"sha": "b1d96f9b5277885dbb62dea04ef58c23e3b11f34", "filename": "src/test/compile-fail/issue-5153.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -17,6 +17,6 @@ impl Foo for isize {\n }\n \n fn main() {\n-    (&5 as &Foo).foo();\n+    (&5isize as &Foo).foo();\n     //~^ ERROR: no method named `foo` found for type `&Foo` in the current scope\n }"}, {"sha": "988a7837b59bf13d15c3ffe041701eb17db1d12d", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -28,7 +28,6 @@ fn f<T>(val: T) {\n     let a = &t as &Gettable<T>;\n     //~^ ERROR the trait `core::marker::Send` is not implemented\n     //~^^ ERROR the trait `core::marker::Copy` is not implemented\n-    //~^^^ ERROR the parameter type `T` may not live long enough\n }\n \n fn g<T>(val: T) {"}, {"sha": "e10a76c65bcf1f0efa00bc8c54c2772625c4d096", "filename": "src/test/compile-fail/typeck-cast-pointer-to-float.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Ftypeck-cast-pointer-to-float.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Ftypeck-cast-pointer-to-float.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftypeck-cast-pointer-to-float.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -11,5 +11,5 @@\n fn main() {\n     let x : i16 = 22;\n     ((&x) as *const i16) as f32;\n-    //~^ ERROR illegal cast; cast through an integer first: `*const i16` as `f32`\n+    //~^ ERROR illegal cast; cast through a usize first: `*const i16` as `f32`\n }"}, {"sha": "10227f1820d96b0c04a71732dc69f0b090dd93ff", "filename": "src/test/compile-fail/vector-cast-weirdness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -28,7 +28,7 @@ fn main() {\n     let mut x1 = X { y: [0, 0] };\n \n     // This is still an error since we don't allow casts from &mut [T; n] to *mut T.\n-    let p1: *mut u8 = &mut x1.y as *mut _;  //~ ERROR mismatched types\n+    let p1: *mut u8 = &mut x1.y as *mut _;  //~ ERROR illegal cast\n     let t1: *mut [u8; 2] = &mut x1.y as *mut _;\n     let h1: *mut [u8; 2] = &mut x1.y as *mut [u8; 2];\n }"}, {"sha": "0bc1e33ce46956fa2d100ca62c5c4871a79b5bbd", "filename": "src/test/run-pass-valgrind/cast-enum-with-dtor.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+// check dtor calling order when casting enums.\n+\n+use std::sync::atomic;\n+use std::sync::atomic::Ordering;\n+use std::mem;\n+\n+enum E {\n+    A = 0,\n+    B = 1,\n+    C = 2\n+}\n+\n+static FLAG: atomic::AtomicUsize = atomic::ATOMIC_USIZE_INIT;\n+\n+impl Drop for E {\n+    fn drop(&mut self) {\n+        // avoid dtor loop\n+        unsafe { mem::forget(mem::replace(self, E::B)) };\n+\n+        FLAG.store(FLAG.load(Ordering::SeqCst)+1, Ordering::SeqCst);\n+    }\n+}\n+\n+fn main() {\n+    assert_eq!(FLAG.load(Ordering::SeqCst), 0);\n+    {\n+        let e = E::C;\n+        assert_eq!(e as u32, 2);\n+        assert_eq!(FLAG.load(Ordering::SeqCst), 0);\n+    }\n+    assert_eq!(FLAG.load(Ordering::SeqCst), 1);\n+}"}, {"sha": "e53d4af8e36cbda323ba468a4f565d78f7678117", "filename": "src/test/run-pass/cast-rfc0401-vtable-kinds.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-rfc0401-vtable-kinds.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that you can cast between different pointers to trait objects\n+// whose vtable have the same kind (both lengths, or both trait pointers).\n+\n+trait Foo<T> {\n+    fn foo(&self, _: T) -> u32 { 42 }\n+}\n+\n+trait Bar {\n+    fn bar(&self) { println!(\"Bar!\"); }\n+}\n+\n+impl<T> Foo<T> for () {}\n+impl Foo<u32> for u32 { fn foo(&self, _: u32) -> u32 { self+43 } }\n+impl Bar for () {}\n+\n+unsafe fn fool<'a>(t: *const (Foo<u32>+'a)) -> u32 {\n+    let bar : *const Bar = t as *const Bar;\n+    let foo_e : *const Foo<u16> = t as *const _;\n+    let r_1 = foo_e as *mut Foo<u32>;\n+\n+    (&*r_1).foo(0)*(&*(bar as *const Foo<u32>)).foo(0)\n+}\n+\n+#[repr(C)]\n+struct FooS<T:?Sized>(T);\n+#[repr(C)]\n+struct BarS<T:?Sized>(T);\n+\n+fn foo_to_bar<T:?Sized>(u: *const FooS<T>) -> *const BarS<T> {\n+    u as *const BarS<T>\n+}\n+\n+fn main() {\n+    let x = 4u32;\n+    let y : &Foo<u32> = &x;\n+    let fl = unsafe { fool(y as *const Foo<u32>) };\n+    assert_eq!(fl, (43+4)*(43+4));\n+\n+    let s = FooS([0,1,2]);\n+    let u: &FooS<[u32]> = &s;\n+    let u: *const FooS<[u32]> = u;\n+    let bar_ref : *const BarS<[u32]> = foo_to_bar(u);\n+    let z : &BarS<[u32]> = unsafe{&*bar_ref};\n+    assert_eq!(&z.0, &[0,1,2]);\n+}"}, {"sha": "7c64c34fae5ce2285544a7a25a2d866c6894a429", "filename": "src/test/run-pass/cast-rfc0401.rs", "status": "added", "additions": 170, "deletions": 0, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Frun-pass%2Fcast-rfc0401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Frun-pass%2Fcast-rfc0401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-rfc0401.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -0,0 +1,170 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(dead_code)]\n+\n+use std::vec;\n+\n+enum Simple {\n+    A,\n+    B,\n+    C\n+}\n+\n+enum Valued {\n+    H8=163,\n+    Z=0,\n+    X=256,\n+    H7=67,\n+}\n+\n+enum ValuedSigned {\n+    M1=-1,\n+    P1=1\n+}\n+\n+fn main()\n+{\n+    // coercion-cast\n+    let mut it = vec![137].into_iter();\n+    let itr: &mut vec::IntoIter<u32> = &mut it;\n+    assert_eq!((itr as &mut Iterator<Item=u32>).next(), Some(137));\n+    assert_eq!((itr as &mut Iterator<Item=u32>).next(), None);\n+\n+    assert_eq!(Some(4u32) as Option<u32>, Some(4u32));\n+    assert_eq!((1u32,2u32) as (u32,u32), (1,2));\n+\n+    // this isn't prim-int-cast. Check that it works.\n+    assert_eq!(false as bool, false);\n+    assert_eq!(true as bool, true);\n+\n+    // numeric-cast\n+    let l: u64 = 0x8090a0b0c0d0e0f0;\n+    let lsz: usize = l as usize;\n+    assert_eq!(l as u32, 0xc0d0e0f0);\n+\n+    // numeric-cast\n+    assert_eq!(l as u8, 0xf0);\n+    assert_eq!(l as i8,-0x10);\n+    assert_eq!(l as u32, 0xc0d0e0f0);\n+    assert_eq!(l as u32 as usize as u32, l as u32);\n+    assert_eq!(l as i32,-0x3f2f1f10);\n+    assert_eq!(l as i32 as isize as i32, l as i32);\n+    assert_eq!(l as i64,-0x7f6f5f4f3f2f1f10);\n+\n+    assert_eq!(0 as f64, 0f64);\n+    assert_eq!(1 as f64, 1f64);\n+\n+    assert_eq!(l as f64, 9264081114510712022f64);\n+\n+    assert_eq!(l as i64 as f64, -9182662959198838444f64);\n+//  float overflow : needs fixing\n+//  assert_eq!(l as f32 as i64 as u64, 9264082620822882088u64);\n+//  assert_eq!(l as i64 as f32 as i64, 9182664080220408446i64);\n+\n+    assert_eq!(4294967040f32 as u32, 0xffffff00u32);\n+    assert_eq!(1.844674407370955e19f64 as u64, 0xfffffffffffff800u64);\n+\n+    assert_eq!(9.223372036854775e18f64 as i64, 0x7ffffffffffffc00i64);\n+    assert_eq!(-9.223372036854776e18f64 as i64, 0x8000000000000000u64 as i64);\n+\n+    // addr-ptr-cast/ptr-addr-cast (thin ptr)\n+    let p: *const [u8; 1] = lsz as *const [u8; 1];\n+    assert_eq!(p as usize, lsz);\n+\n+    // ptr-ptr-cast (thin ptr)\n+    let w: *const () = p as *const ();\n+    assert_eq!(w as usize, lsz);\n+\n+    // ptr-ptr-cast (fat->thin)\n+    let u: *const [u8] = unsafe{&*p};\n+    assert_eq!(u as *const u8, p as *const u8);\n+    assert_eq!(u as *const u16, p as *const u16);\n+\n+    // ptr-ptr-cast (both vk=Length)\n+    let mut l : [u8; 2] = [0,1];\n+    let w: *mut [u16; 2] = &mut l as *mut [u8; 2] as *mut _;\n+    let w: *mut [u16] = unsafe {&mut *w};\n+    let w_u8 : *const [u8] = w as *const [u8];\n+    assert_eq!(unsafe{&*w_u8}, &l);\n+\n+    let s: *mut str = w as *mut str;\n+    let l_via_str = unsafe{&*(s as *const [u8])};\n+    assert_eq!(&l, l_via_str);\n+\n+    // enum-cast\n+    assert_eq!(Simple::A as u8, 0);\n+    assert_eq!(Simple::B as u8, 1);\n+\n+    assert_eq!(Valued::H8 as i8, -93);\n+    assert_eq!(Valued::H7 as i8, 67);\n+    assert_eq!(Valued::Z as i8, 0);\n+\n+    assert_eq!(Valued::H8 as u8, 163);\n+    assert_eq!(Valued::H7 as u8, 67);\n+    assert_eq!(Valued::Z as u8, 0);\n+\n+    assert_eq!(Valued::H8 as u16, 163);\n+    assert_eq!(Valued::Z as u16, 0);\n+    assert_eq!(Valued::H8 as u16, 163);\n+    assert_eq!(Valued::Z as u16, 0);\n+\n+    assert_eq!(ValuedSigned::M1 as u16, 65535);\n+    assert_eq!(ValuedSigned::M1 as i16, -1);\n+    assert_eq!(ValuedSigned::P1 as u16, 1);\n+    assert_eq!(ValuedSigned::P1 as i16, 1);\n+\n+    // prim-int-cast\n+    assert_eq!(false as u16, 0);\n+    assert_eq!(true as u16, 1);\n+    assert_eq!(false as i64, 0);\n+    assert_eq!(true as i64, 1);\n+    assert_eq!('a' as u32, 0x61);\n+    assert_eq!('a' as u16, 0x61);\n+    assert_eq!('a' as u8, 0x61);\n+    assert_eq!('\u05d0' as u8, 0xd0);\n+    assert_eq!('\u05d0' as u16, 0x5d0);\n+    assert_eq!('\u05d0' as u32, 0x5d0);\n+    assert_eq!('\ud83d\udc35' as u8, 0x35);\n+    assert_eq!('\ud83d\udc35' as u16, 0xf435);\n+    assert_eq!('\ud83d\udc35' as u32, 0x1f435);\n+    assert_eq!('\u82f1' as i16, -0x7d0f);\n+    assert_eq!('\u82f1' as u16, 0x82f1);\n+\n+    // u8-char-cast\n+    assert_eq!(0x61 as char, 'a');\n+    assert_eq!(0u8 as char, '\\0');\n+    assert_eq!(0xd7 as char, '\u00d7');\n+\n+    // array-ptr-cast\n+    let x = [1,2,3];\n+    let first : *const u32 = &x[0];\n+\n+    assert_eq!(first, &x as *const _);\n+    assert_eq!(first, &x as *const u32);\n+\n+    // fptr-addr-cast\n+    fn foo() {\n+        println!(\"foo!\");\n+    }\n+    fn bar() {\n+        println!(\"bar!\");\n+    }\n+\n+    assert!(foo as usize != bar as usize);\n+\n+    assert_eq!(foo as i16, foo as usize as i16);\n+\n+    // fptr-ptr-cast\n+\n+    assert_eq!(foo as *const u8 as usize, foo as usize);\n+    assert!(foo as *const u32 != first);\n+}\n+fn foo() { }"}, {"sha": "91637d111fe4f41d43e1399315ef32ca2a162b4a", "filename": "src/test/run-pass/fat-ptr-cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffat-ptr-cast.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -32,18 +32,18 @@ fn main() {\n     // Test conversion to an address (usize).\n     let a: *const [i32; 3] = &[1, 2, 3];\n     let b: *const [i32] = a;\n-    assert!(a as usize == b as usize);\n+    assert!(a as usize == b as *const () as usize);\n \n     // And conversion to a void pointer/address for trait objects too.\n     let a: *mut Foo = &mut Bar;\n     let b = a as *mut ();\n-    let c = a as usize;\n-\n+    let c = a as *const () as usize;\n     let d = unsafe {\n         let r: raw::TraitObject = mem::transmute(a);\n         r.data\n     };\n \n     assert!(b == d);\n     assert!(c == d as usize);\n+\n }"}, {"sha": "a47ae52f5902cfabfbaa8d1183d3d30b54087aff", "filename": "src/test/run-pass/supported-cast.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Frun-pass%2Fsupported-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c322dbbf8a518d00c6db689ca80b0047f2328890/src%2Ftest%2Frun-pass%2Fsupported-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsupported-cast.rs?ref=c322dbbf8a518d00c6db689ca80b0047f2328890", "patch": "@@ -181,7 +181,6 @@ pub fn main() {\n \n   println!(\"{:?}\", true as isize);\n   println!(\"{:?}\", true as usize);\n-  println!(\"{:?}\", true as *const libc::FILE);\n   println!(\"{:?}\", true as i8);\n   println!(\"{:?}\", true as i16);\n   println!(\"{:?}\", true as i32);\n@@ -190,8 +189,6 @@ pub fn main() {\n   println!(\"{:?}\", true as u16);\n   println!(\"{:?}\", true as u32);\n   println!(\"{:?}\", true as u64);\n-  println!(\"{:?}\", true as f32);\n-  println!(\"{:?}\", true as f64);\n \n   println!(\"{:?}\", 1f32 as isize);\n   println!(\"{:?}\", 1f32 as usize);"}]}