{"sha": "cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNmQ5ZWFiNWQ3NTU4NGVkZmNhZTRmZmRlZjhiMDgzNmRiODBjMWU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-23T02:22:03Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-23T21:28:40Z"}, "message": "Set unstable feature names appropriately\n\n* `core` - for the core crate\n* `hash` - hashing\n* `io` - io\n* `path` - path\n* `alloc` - alloc crate\n* `rand` - rand crate\n* `collections` - collections crate\n* `std_misc` - other parts of std\n* `test` - test crate\n* `rustc_private` - everything else", "tree": {"sha": "fff2c174986eaab33f67390d0a114d508966fe68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fff2c174986eaab33f67390d0a114d508966fe68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "html_url": "https://github.com/rust-lang/rust/commit/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f86bcc1543cb053363c5e6818a2ad44877ea8361", "url": "https://api.github.com/repos/rust-lang/rust/commits/f86bcc1543cb053363c5e6818a2ad44877ea8361", "html_url": "https://github.com/rust-lang/rust/commit/f86bcc1543cb053363c5e6818a2ad44877ea8361"}], "stats": {"total": 1605, "additions": 864, "deletions": 741}, "files": [{"sha": "802fb05796d665d91b8e5ffc0d42ee03aba47a51", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -13,7 +13,6 @@\n #![feature(slicing_syntax, unboxed_closures)]\n #![feature(box_syntax)]\n #![feature(int_uint)]\n-#![feature(unnamed_feature)]\n \n #![deny(warnings)]\n "}, {"sha": "601f130341bf95cb3a436bc45c659248c8561460", "filename": "src/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n #![allow(unknown_features)]\n-#![feature(unnamed_feature)]\n+#![cfg_attr(rustc, feature(rustc_private))]\n+#![cfg_attr(rustdoc, feature(rustdoc))]\n \n #[cfg(rustdoc)]\n extern crate \"rustdoc\" as this;"}, {"sha": "ad4cb2076c2cbc60e4ddab4bcf06aaf194ff76c5", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -126,7 +126,7 @@ unsafe impl<T: Sync + Send> Sync for Arc<T> { }\n /// Weak pointers will not keep the data inside of the `Arc` alive, and can be used to break cycles\n /// between `Arc` pointers.\n #[unsafe_no_drop_flag]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n pub struct Weak<T> {\n     // FIXME #12808: strange name to try to avoid interfering with\n@@ -180,7 +180,7 @@ impl<T> Arc<T> {\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"alloc\",\n                reason = \"Weak pointers may not belong in this module.\")]\n     pub fn downgrade(&self) -> Weak<T> {\n         // See the clone() impl for why this is relaxed\n@@ -202,12 +202,12 @@ impl<T> Arc<T> {\n \n /// Get the number of weak references to this value.\n #[inline]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"alloc\")]\n pub fn weak_count<T>(this: &Arc<T>) -> uint { this.inner().weak.load(SeqCst) - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"alloc\")]\n pub fn strong_count<T>(this: &Arc<T>) -> uint { this.inner().strong.load(SeqCst) }\n \n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n@@ -273,7 +273,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n     /// let mut_five = five.make_unique();\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"alloc\")]\n     pub fn make_unique(&mut self) -> &mut T {\n         // Note that we hold a strong reference, which also counts as a weak reference, so we only\n         // clone if there is an additional reference of either kind.\n@@ -357,7 +357,7 @@ impl<T: Sync + Send> Drop for Arc<T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T: Sync + Send> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n@@ -396,7 +396,7 @@ impl<T: Sync + Send> Weak<T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T: Sync + Send> Clone for Weak<T> {\n     /// Makes a clone of the `Weak<T>`."}, {"sha": "ed371e577a6231be26ca2ac3db8e447a4d284529", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -44,7 +44,7 @@ use core::ops::{Deref, DerefMut};\n /// }\n /// ```\n #[lang = \"exchange_heap\"]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"alloc\",\n            reason = \"may be renamed; uncertain about custom allocator design\")]\n pub static HEAP: () = ();\n \n@@ -126,7 +126,7 @@ impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n }\n \n /// Extension methods for an owning `Any` trait object.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"alloc\",\n            reason = \"this trait will likely disappear once compiler bugs blocking \\\n                      a direct impl on `Box<Any>` have been fixed \")]\n // FIXME(#18737): this should be a direct impl on `Box<Any>`. If you're"}, {"sha": "9a72d7d05108ae54a4c9953e6dc53ec373d4668d", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -80,7 +80,7 @@ pub fn usable_size(size: uint, align: uint) -> uint {\n ///\n /// These statistics may be inconsistent if other threads use the allocator\n /// during the call.\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"alloc\")]\n pub fn stats_print() {\n     imp::stats_print();\n }"}, {"sha": "cadb8907cf80cab18cba839f3d4eb05e24ae7801", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -57,7 +57,7 @@\n //! default global allocator. It is not compatible with the libc allocator API.\n \n #![crate_name = \"alloc\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"alloc\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n@@ -70,8 +70,10 @@\n #![feature(lang_items, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(core)]\n+#![feature(hash)]\n+#![feature(libc)]\n \n #[macro_use]\n extern crate core;"}, {"sha": "81336cfd230e28f63771029962a606f56a4320f4", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -268,7 +268,7 @@ impl<T> Rc<T> {\n     /// let weak_five = five.downgrade();\n     /// ```\n     #[cfg(stage0)] // NOTE remove after next snapshot\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"alloc\",\n                reason = \"Weak pointers may not belong in this module\")]\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n@@ -291,7 +291,7 @@ impl<T> Rc<T> {\n     /// let weak_five = five.downgrade();\n     /// ```\n     #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"alloc\",\n                reason = \"Weak pointers may not belong in this module\")]\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n@@ -301,12 +301,12 @@ impl<T> Rc<T> {\n \n /// Get the number of weak references to this value.\n #[inline]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"alloc\")]\n pub fn weak_count<T>(this: &Rc<T>) -> uint { this.weak() - 1 }\n \n /// Get the number of strong references to this value.\n #[inline]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"alloc\")]\n pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n \n /// Returns true if there are no other `Rc` or `Weak<T>` values that share the same inner value.\n@@ -322,7 +322,7 @@ pub fn strong_count<T>(this: &Rc<T>) -> uint { this.strong() }\n /// rc::is_unique(&five);\n /// ```\n #[inline]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"alloc\")]\n pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n     weak_count(rc) == 0 && strong_count(rc) == 1\n }\n@@ -344,7 +344,7 @@ pub fn is_unique<T>(rc: &Rc<T>) -> bool {\n /// assert_eq!(rc::try_unwrap(x), Err(Rc::new(4u)));\n /// ```\n #[inline]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"alloc\")]\n pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n     if is_unique(&rc) {\n         unsafe {\n@@ -378,7 +378,7 @@ pub fn try_unwrap<T>(rc: Rc<T>) -> Result<T, Rc<T>> {\n /// assert!(rc::get_mut(&mut x).is_none());\n /// ```\n #[inline]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"alloc\")]\n pub fn get_mut<'a, T>(rc: &'a mut Rc<T>) -> Option<&'a mut T> {\n     if is_unique(rc) {\n         let inner = unsafe { &mut **rc._ptr };\n@@ -404,7 +404,7 @@ impl<T: Clone> Rc<T> {\n     /// let mut_five = five.make_unique();\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"alloc\")]\n     pub fn make_unique(&mut self) -> &mut T {\n         if !is_unique(self) {\n             *self = Rc::new((**self).clone())\n@@ -695,7 +695,7 @@ impl<S: hash::Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"Show is experimental.\")]\n+#[unstable(feature = \"alloc\", reason = \"Show is experimental.\")]\n impl<T: fmt::Show> fmt::Show for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"Rc({:?})\", **self)\n@@ -716,7 +716,7 @@ impl<T: fmt::String> fmt::String for Rc<T> {\n /// See the [module level documentation](../index.html) for more.\n #[unsafe_no_drop_flag]\n #[cfg(stage0)] // NOTE remove impl after next snapshot\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n pub struct Weak<T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n@@ -732,7 +732,7 @@ pub struct Weak<T> {\n ///\n /// See the [module level documentation](../index.html) for more.\n #[unsafe_no_drop_flag]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n pub struct Weak<T> {\n@@ -748,7 +748,7 @@ impl<T> !marker::Send for Weak<T> {}\n impl<T> !marker::Sync for Weak<T> {}\n \n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n@@ -850,7 +850,7 @@ impl<T> Drop for Weak<T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n impl<T> Clone for Weak<T> {\n     /// Makes a clone of the `Weak<T>`.\n@@ -894,7 +894,7 @@ impl<T> Clone for Weak<T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"Show is experimental.\")]\n+#[unstable(feature = \"alloc\", reason = \"Show is experimental.\")]\n impl<T: fmt::Show> fmt::Show for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"(Weak)\")"}, {"sha": "de0f15dd08df75cc70b04cc0332e0aa7afdec1df", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -20,7 +20,7 @@\n //! more complex, slower arena which can hold objects of any type.\n \n #![crate_name = \"arena\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n@@ -33,9 +33,10 @@\n #![feature(unsafe_destructor)]\n #![feature(unboxed_closures)]\n #![feature(box_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![allow(missing_docs)]\n+#![feature(alloc)]\n+#![feature(core)]\n \n extern crate alloc;\n "}, {"sha": "3e02ac2137d1e0889ac52ae153899cbc1d90443a", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -551,7 +551,7 @@ impl<T: Ord> BinaryHeap<T> {\n \n     /// Clears the binary heap, returning an iterator over the removed elements.\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain { iter: self.data.drain() }\n@@ -623,7 +623,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// An iterator that drains a `BinaryHeap`.\n-#[unstable(feature = \"unnamed_feature\", reason = \"recent addition\")]\n+#[unstable(feature = \"collections\", reason = \"recent addition\")]\n pub struct Drain<'a, T: 'a> {\n     iter: vec::Drain<'a, T>,\n }"}, {"sha": "867e034e4429b0fc97fda476e1d781156676ac59", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -156,7 +156,7 @@ static FALSE: bool = false;\n /// println!(\"{:?}\", bv);\n /// println!(\"total bits set to true: {}\", bv.iter().filter(|x| *x).count());\n /// ```\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n pub struct Bitv {\n     /// Internal representation of the bit vector\n@@ -403,7 +403,7 @@ impl Bitv {\n     /// assert_eq!(bv[3], true);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"panic semantics are likely to change in the future\")]\n     pub fn set(&mut self, i: uint, x: bool) {\n         assert!(i < self.nbits);\n@@ -1109,7 +1109,7 @@ impl<'a> RandomAccessIterator for Iter<'a> {\n /// assert!(bv[3]);\n /// ```\n #[derive(Clone)]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n pub struct BitvSet {\n     bitv: Bitv,"}, {"sha": "f6873855b3e9867b50dbc19b8c136e0fb34a1ec2", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -136,7 +136,7 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single entry in a map, which may either be vacant or occupied.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"precise API still under development\")]\n pub enum Entry<'a, K:'a, V:'a> {\n     /// A vacant Entry\n@@ -146,15 +146,15 @@ pub enum Entry<'a, K:'a, V:'a> {\n }\n \n /// A vacant Entry.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"precise API still under development\")]\n pub struct VacantEntry<'a, K:'a, V:'a> {\n     key: K,\n     stack: stack::SearchStack<'a, K, V, node::handle::Edge, node::handle::Leaf>,\n }\n \n /// An occupied Entry.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"precise API still under development\")]\n pub struct OccupiedEntry<'a, K:'a, V:'a> {\n     stack: stack::SearchStack<'a, K, V, node::handle::KV, node::handle::LeafOrInternal>,\n@@ -1099,7 +1099,7 @@ impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n }\n \n impl<'a, K: Ord, V> Entry<'a, K, V> {\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n@@ -1113,7 +1113,7 @@ impl<'a, K: Ord, V> Entry<'a, K, V> {\n impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         self.stack.insert(self.key, value)\n@@ -1122,37 +1122,37 @@ impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n \n impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the value in the entry.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn get(&self) -> &V {\n         self.stack.peek()\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.stack.peek_mut()\n     }\n \n     /// Converts the entry into a mutable reference to its value.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.stack.into_top()\n     }\n \n     /// Sets the value of the entry with the OccupiedEntry's key,\n     /// and returns the entry's old value.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn insert(&mut self, mut value: V) -> V {\n         mem::swap(self.stack.peek_mut(), &mut value);\n         value\n     }\n \n     /// Takes the value of the entry out of the map, and returns it.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n     pub fn remove(self) -> V {\n         self.stack.remove()\n@@ -1480,7 +1480,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// }\n     /// assert_eq!(Some((&5u, &\"b\")), map.range(Included(&4), Unbounded).next());\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range<'a>(&'a self, min: Bound<&K>, max: Bound<&K>) -> Range<'a, K, V> {\n         range_impl!(&self.root, min, max, as_slices_internal, iter, Range, edges, [])\n@@ -1507,7 +1507,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     ///     println!(\"{} => {}\", name, balance);\n     /// }\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range_mut<'a>(&'a mut self, min: Bound<&K>, max: Bound<&K>) -> RangeMut<'a, K, V> {\n         range_impl!(&mut self.root, min, max, as_slices_internal_mut, iter_mut, RangeMut,\n@@ -1540,7 +1540,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(count[\"a\"], 3u);\n     /// ```\n     /// The key must have the same ordering before or after `.to_owned()` is called.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"precise API still under development\")]\n     pub fn entry<'a>(&'a mut self, mut key: K) -> Entry<'a, K, V> {\n         // same basic logic of `swap` and `pop`, blended together"}, {"sha": "dd281e0836b0cabf2f30ae6095dc17dd46c33b4f", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -102,7 +102,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// Makes a new BTreeSet with the given B.\n     ///\n     /// B cannot be less than 2.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"probably want this to be on the type, eventually\")]\n     pub fn with_b(b: uint) -> BTreeSet<T> {\n         BTreeSet { map: BTreeMap::with_b(b) }\n@@ -173,7 +173,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// }\n     /// assert_eq!(Some(&5u), set.range(Included(&4), Unbounded).next());\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn range<'a>(&'a self, min: Bound<&T>, max: Bound<&T>) -> Range<'a, T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }"}, {"sha": "6dc988219eaee122669fda6f21e29dbc3ed8e157", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -770,7 +770,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// }\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"this is probably better handled by a cursor type -- we'll see\")]\n     pub fn insert_next(&mut self, elt: A) {\n         self.insert_next_node(box Node::new(elt))\n@@ -792,7 +792,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// assert_eq!(it.next().unwrap(), &2);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"this is probably better handled by a cursor type -- we'll see\")]\n     pub fn peek_next(&mut self) -> Option<&mut A> {\n         if self.nelem == 0 {"}, {"sha": "fddea51c534fdaa9ae532b9a9278cedf25aec2da", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -82,21 +82,21 @@ fn bit<E:CLike>(e: &E) -> uint {\n \n impl<E:CLike> EnumSet<E> {\n     /// Returns an empty `EnumSet`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn new() -> EnumSet<E> {\n         EnumSet {bits: 0}\n     }\n \n     /// Returns the number of elements in the given `EnumSet`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn len(&self) -> uint {\n         self.bits.count_ones()\n     }\n \n     /// Returns true if the `EnumSet` is empty.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_empty(&self) -> bool {\n         self.bits == 0\n@@ -107,21 +107,21 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Returns `false` if the `EnumSet` contains any enum of the given `EnumSet`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_disjoint(&self, other: &EnumSet<E>) -> bool {\n         (self.bits & other.bits) == 0\n     }\n \n     /// Returns `true` if a given `EnumSet` is included in this `EnumSet`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_superset(&self, other: &EnumSet<E>) -> bool {\n         (self.bits & other.bits) == other.bits\n     }\n \n     /// Returns `true` if this `EnumSet` is included in the given `EnumSet`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn is_subset(&self, other: &EnumSet<E>) -> bool {\n         other.is_superset(self)\n@@ -138,7 +138,7 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Adds an enum to the `EnumSet`, and returns `true` if it wasn't there before\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn insert(&mut self, e: E) -> bool {\n         let result = !self.contains(&e);\n@@ -147,7 +147,7 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Removes an enum from the EnumSet\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn remove(&mut self, e: &E) -> bool {\n         let result = self.contains(e);\n@@ -156,14 +156,14 @@ impl<E:CLike> EnumSet<E> {\n     }\n \n     /// Returns `true` if an `EnumSet` contains a given enum.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn contains(&self, e: &E) -> bool {\n         (self.bits & bit(e)) != 0\n     }\n \n     /// Returns an iterator over an `EnumSet`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn iter(&self) -> Iter<E> {\n         Iter::new(self.bits)"}, {"sha": "b836fe61a75c9b1f8cf79a9c0318cb5028b64636", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -14,7 +14,7 @@\n \n \n #![crate_name = \"collections\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"collections\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n@@ -27,9 +27,12 @@\n #![feature(unsafe_destructor, slicing_syntax)]\n #![feature(box_syntax)]\n #![feature(unboxed_closures)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![no_std]\n+#![feature(core)]\n+#![feature(alloc)]\n+#![feature(unicode)]\n+#![feature(hash)]\n \n #[macro_use]\n extern crate core;\n@@ -71,13 +74,13 @@ pub mod string;\n pub mod vec;\n pub mod vec_map;\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n pub mod bitv {\n     pub use bit::{Bitv, Iter};\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"RFC 509\")]\n pub mod bitv_set {\n     pub use bit::{BitvSet, Union, Intersection, Difference, SymmetricDifference};"}, {"sha": "72b5eba8aaa5ed335b1be988537a6c107833bc1b", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -480,7 +480,7 @@ impl<T> RingBuf<T> {\n     /// assert_eq!(buf.len(), 1);\n     /// assert_eq!(Some(&5), buf.get(0));\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification; waiting on panic semantics\")]\n     pub fn truncate(&mut self, len: uint) {\n         for _ in range(len, self.len()) {\n@@ -550,7 +550,7 @@ impl<T> RingBuf<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `RingBuf`.\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn as_slices<'a>(&'a self) -> (&'a [T], &'a [T]) {\n         unsafe {\n@@ -570,7 +570,7 @@ impl<T> RingBuf<T> {\n     /// Returns a pair of slices which contain, in order, the contents of the\n     /// `RingBuf`.\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn as_mut_slices<'a>(&'a mut self) -> (&'a mut [T], &'a mut [T]) {\n         unsafe {\n@@ -635,7 +635,7 @@ impl<T> RingBuf<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         Drain {\n@@ -876,7 +876,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(10);\n     /// assert_eq!(buf.swap_back_remove(1), Some(99));\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"the naming of this function may be altered\")]\n     pub fn swap_back_remove(&mut self, index: uint) -> Option<T> {\n         let length = self.len();\n@@ -909,7 +909,7 @@ impl<T> RingBuf<T> {\n     /// buf.push_back(20i);\n     /// assert_eq!(buf.swap_front_remove(3), Some(99));\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"the naming of this function may be altered\")]\n     pub fn swap_front_remove(&mut self, index: uint) -> Option<T> {\n         let length = self.len();\n@@ -1310,7 +1310,7 @@ impl<T: Clone> RingBuf<T> {\n     ///     assert_eq!(a, b);\n     /// }\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification; waiting on panic semantics\")]\n     pub fn resize(&mut self, new_len: uint, value: T) {\n         let len = self.len();\n@@ -1500,7 +1500,7 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n impl<T> ExactSizeIterator for IntoIter<T> {}\n \n /// A draining RingBuf iterator\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, T: 'a> {\n     inner: &'a mut RingBuf<T>,"}, {"sha": "6765eda4cb70afe9f3524d1bcded16ea6e1da079", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -166,7 +166,7 @@ pub trait SliceExt {\n     /// assert_eq!(num_moved, 3);\n     /// assert!(a == [6i, 7, 8, 4, 5]);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"uncertain about this API approach\")]\n     fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n \n@@ -176,7 +176,7 @@ pub trait SliceExt {\n     /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n \n@@ -185,7 +185,7 @@ pub trait SliceExt {\n     /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     fn slice_from(&self, start: uint) -> &[Self::Item];\n \n@@ -194,7 +194,7 @@ pub trait SliceExt {\n     /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     fn slice_to(&self, end: uint) -> &[Self::Item];\n \n@@ -288,11 +288,11 @@ pub trait SliceExt {\n     fn first(&self) -> Option<&Self::Item>;\n \n     /// Returns all but the first element of a slice.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"likely to be renamed\")]\n+    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n     fn tail(&self) -> &[Self::Item];\n \n     /// Returns all but the last element of a slice.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"likely to be renamed\")]\n+    #[unstable(feature = \"collections\", reason = \"likely to be renamed\")]\n     fn init(&self) -> &[Self::Item];\n \n     /// Returns the last element of a slice, or `None` if it is empty.\n@@ -388,7 +388,7 @@ pub trait SliceExt {\n     /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n     ///\n     /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n \n@@ -397,7 +397,7 @@ pub trait SliceExt {\n     /// Panics when `start` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n \n@@ -406,7 +406,7 @@ pub trait SliceExt {\n     /// Panics when `end` is strictly greater than the length of the original slice.\n     ///\n     /// Slicing to `0` yields an empty slice.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"will be replaced by slice syntax\")]\n     fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n \n@@ -419,12 +419,12 @@ pub trait SliceExt {\n     fn first_mut(&mut self) -> Option<&mut Self::Item>;\n \n     /// Returns all but the first element of a mutable slice\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"likely to be renamed or removed\")]\n     fn tail_mut(&mut self) -> &mut [Self::Item];\n \n     /// Returns all but the last element of a mutable slice\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"likely to be renamed or removed\")]\n     fn init_mut(&mut self) -> &mut [Self::Item];\n \n@@ -577,7 +577,7 @@ pub trait SliceExt {\n     /// assert_eq!(Some(vec![1i, 3, 2]), perms.next());\n     /// assert_eq!(Some(vec![3i, 1, 2]), perms.next());\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"collections\")]\n     fn permutations(&self) -> Permutations<Self::Item> where Self::Item: Clone;\n \n     /// Copies as many elements from `src` as it can into `self` (the\n@@ -597,7 +597,7 @@ pub trait SliceExt {\n     /// assert!(dst.clone_from_slice(&src2) == 3);\n     /// assert!(dst == [3i, 4, 5]);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"collections\")]\n     fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n \n     /// Sorts the slice, in place.\n@@ -663,7 +663,7 @@ pub trait SliceExt {\n     /// let b: &mut [_] = &mut [1i, 0, 2];\n     /// assert!(v == b);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"uncertain if this merits inclusion in std\")]\n     fn next_permutation(&mut self) -> bool where Self::Item: Ord;\n \n@@ -683,16 +683,16 @@ pub trait SliceExt {\n     /// let b: &mut [_] = &mut [0i, 1, 2];\n     /// assert!(v == b);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"uncertain if this merits inclusion in std\")]\n     fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n \n     /// Find the first index containing a matching value.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"collections\")]\n     fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n \n     /// Find the last index containing a matching value.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"collections\")]\n     fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n \n     /// Return true if the slice contains an element with the given value.\n@@ -708,7 +708,7 @@ pub trait SliceExt {\n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     /// Convert `self` into a vector without clones or allocation.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"collections\")]\n     fn into_vec(self: Box<Self>) -> Vec<Self::Item>;\n }\n \n@@ -1000,7 +1000,7 @@ impl<T> SliceExt for [T] {\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n-#[unstable(feature = \"unnamed_feature\", reason = \"U should be an associated type\")]\n+#[unstable(feature = \"collections\", reason = \"U should be an associated type\")]\n /// An extension trait for concatenating slices\n pub trait SliceConcatExt<T: ?Sized, U> {\n     /// Flattens a slice of `T` into a single value `U`.\n@@ -1045,7 +1045,7 @@ impl<T: Clone, V: AsSlice<T>> SliceConcatExt<T, Vec<T>> for [V] {\n ///\n /// The last generated swap is always (0, 1), and it returns the\n /// sequence to its initial order.\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n #[derive(Clone)]\n pub struct ElementSwaps {\n     sdir: Vec<SizeDirection>,\n@@ -1057,7 +1057,7 @@ pub struct ElementSwaps {\n \n impl ElementSwaps {\n     /// Creates an `ElementSwaps` iterator for a sequence of `length` elements.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"collections\")]\n     pub fn new(length: uint) -> ElementSwaps {\n         // Initialize `sdir` with a direction that position should move in\n         // (all negative at the beginning) and the `size` of the\n@@ -1074,17 +1074,17 @@ impl ElementSwaps {\n // Standard trait implementations for slices\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is unstable\")]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl<T> BorrowFrom<Vec<T>> for [T] {\n     fn borrow_from(owned: &Vec<T>) -> &[T] { &owned[] }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is unstable\")]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl<T> BorrowFromMut<Vec<T>> for [T] {\n     fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { &mut owned[] }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is unstable\")]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl<T: Clone> ToOwned<Vec<T>> for [T] {\n     fn to_owned(&self) -> Vec<T> { self.to_vec() }\n }\n@@ -1166,13 +1166,13 @@ impl Iterator for ElementSwaps {\n /// swap applied.\n ///\n /// Generates even and odd permutations alternately.\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n pub struct Permutations<T> {\n     swaps: ElementSwaps,\n     v: Vec<T>,\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is unstable\")]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl<T: Clone> Iterator for Permutations<T> {\n     type Item = Vec<T>;\n "}, {"sha": "57db5d6decf17628b01fd3512bd439db460a26c5", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -165,7 +165,7 @@ enum DecompositionType {\n /// External iterator for a string's decomposition's characters.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n pub struct Decompositions<'a> {\n     kind: DecompositionType,\n     iter: Chars<'a>,\n@@ -255,7 +255,7 @@ enum RecompositionState {\n /// External iterator for a string's recomposition's characters.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n pub struct Recompositions<'a> {\n     iter: Decompositions<'a>,\n     state: RecompositionState,\n@@ -352,7 +352,7 @@ impl<'a> Iterator for Recompositions<'a> {\n /// External iterator for a string's UTF16 codeunits.\n /// Use with the `std::iter` module.\n #[derive(Clone)]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n pub struct Utf16Units<'a> {\n     encoder: Utf16Encoder<Chars<'a>>\n }\n@@ -384,12 +384,12 @@ macro_rules! utf8_acc_cont_byte {\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is unstable\")]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl BorrowFrom<String> for str {\n     fn borrow_from(owned: &String) -> &str { &owned[] }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is unstable\")]\n+#[unstable(feature = \"collections\", reason = \"trait is unstable\")]\n impl ToOwned<String> for str {\n     fn to_owned(&self) -> String {\n         unsafe {\n@@ -410,14 +410,14 @@ Section: Trait implementations\n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait StrExt: Index<FullRange, Output = str> {\n     /// Escapes each char in `s` with `char::escape_default`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"return type may change to be an iterator\")]\n     fn escape_default(&self) -> String {\n         self.chars().flat_map(|c| c.escape_default()).collect()\n     }\n \n     /// Escapes each char in `s` with `char::escape_unicode`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"return type may change to be an iterator\")]\n     fn escape_unicode(&self) -> String {\n         self.chars().flat_map(|c| c.escape_unicode()).collect()\n@@ -463,7 +463,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// Returns an iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"this functionality may be moved to libunicode\")]\n     fn nfd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n@@ -477,7 +477,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// Returns an iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"this functionality may be moved to libunicode\")]\n     fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n@@ -491,7 +491,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// An Iterator over the string in Unicode Normalization Form C\n     /// (canonical decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"this functionality may be moved to libunicode\")]\n     fn nfc_chars<'a>(&'a self) -> Recompositions<'a> {\n         Recompositions {\n@@ -506,7 +506,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// An Iterator over the string in Unicode Normalization Form KC\n     /// (compatibility decomposition followed by canonical composition).\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"this functionality may be moved to libunicode\")]\n     fn nfkc_chars<'a>(&'a self) -> Recompositions<'a> {\n         Recompositions {\n@@ -545,7 +545,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```rust\n     /// assert!(\"hello\".contains_char('e'));\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"might get removed in favour of a more generic contains()\")]\n     fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n         core_str::StrExt::contains_char(&self[], pat)\n@@ -658,7 +658,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\", reason = \"might get removed\")]\n+    #[unstable(feature = \"collections\", reason = \"might get removed\")]\n     fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n         core_str::StrExt::split_terminator(&self[], pat)\n     }\n@@ -704,7 +704,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<(uint, uint)> = \"ababa\".match_indices(\"aba\").collect();\n     /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"might have its iterator type changed\")]\n     fn match_indices<'a>(&'a self, pat: &'a str) -> MatchIndices<'a> {\n         core_str::StrExt::match_indices(&self[], pat)\n@@ -721,7 +721,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n     /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"might get removed in the future in favor of a more generic split()\")]\n     fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a> {\n         core_str::StrExt::split_str(&self[], pat)\n@@ -789,7 +789,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// // byte 100 is outside the string\n     /// // s.slice(3, 100);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"use slice notation [a..b] instead\")]\n     fn slice(&self, begin: uint, end: uint) -> &str {\n         core_str::StrExt::slice(&self[], begin, end)\n@@ -803,7 +803,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// out of bounds.\n     ///\n     /// See also `slice`, `slice_to` and `slice_chars`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"use slice notation [a..] instead\")]\n     fn slice_from(&self, begin: uint) -> &str {\n         core_str::StrExt::slice_from(&self[], begin)\n@@ -818,7 +818,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// out of bounds.\n     ///\n     /// See also `slice`, `slice_from` and `slice_chars`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"use slice notation [..a] instead\")]\n     fn slice_to(&self, end: uint) -> &str {\n         core_str::StrExt::slice_to(&self[], end)\n@@ -847,7 +847,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n     /// assert_eq!(s.slice_chars(5, 7), \"\u8001\u864e\");\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"may have yet to prove its worth\")]\n     fn slice_chars(&self, begin: uint, end: uint) -> &str {\n         core_str::StrExt::slice_chars(&self[], begin, end)\n@@ -971,7 +971,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// // third byte of `\u8001`\n     /// assert!(!s.is_char_boundary(8));\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn is_char_boundary(&self, index: uint) -> bool {\n         core_str::StrExt::is_char_boundary(&self[], index)\n@@ -1030,7 +1030,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than or equal to the length of the string.\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at(&self, start: uint) -> CharRange {\n         core_str::StrExt::char_range_at(&self[], start)\n@@ -1046,7 +1046,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than the length of the string.\n     /// If `i` is not an index following a valid UTF-8 character.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_range_at_reverse(&self, start: uint) -> CharRange {\n         core_str::StrExt::char_range_at_reverse(&self[], start)\n@@ -1067,7 +1067,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than or equal to the length of the string.\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_at(&self, i: uint) -> char {\n         core_str::StrExt::char_at(&self[], i)\n@@ -1079,7 +1079,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     ///\n     /// If `i` is greater than the length of the string.\n     /// If `i` is not an index following a valid UTF-8 character.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"naming is uncertain with container conventions\")]\n     fn char_at_reverse(&self, i: uint) -> char {\n         core_str::StrExt::char_at_reverse(&self[], i)\n@@ -1172,7 +1172,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n     /// assert_eq!(s.find_str(\"muffin man\"), None);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"might get removed in favor of a more generic find in the future\")]\n     fn find_str(&self, needle: &str) -> Option<uint> {\n         core_str::StrExt::find_str(&self[], needle)\n@@ -1196,7 +1196,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(c, '\u00f6');\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"awaiting conventions about shifting and slices\")]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n         core_str::StrExt::slice_shift_char(&self[])\n@@ -1216,7 +1216,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n     /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"awaiting convention about comparability of arbitrary slices\")]\n     fn subslice_offset(&self, inner: &str) -> uint {\n         core_str::StrExt::subslice_offset(&self[], inner)\n@@ -1234,7 +1234,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     }\n \n     /// Return an iterator of `u16` over the string encoded as UTF-16.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     fn utf16_units(&self) -> Utf16Units {\n         Utf16Units { encoder: Utf16Encoder::new(self[].chars()) }\n@@ -1276,7 +1276,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// assert_eq!(\"j\".parse::<u32>(), None);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"this method was just created\")]\n     fn parse<F: FromStr>(&self) -> Option<F> {\n         core_str::StrExt::parse(&self[])\n@@ -1301,7 +1301,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let b: &[_] = &[\"a\", \"\\r\\n\", \"b\", \"\ud83c\uddf7\ud83c\uddfa\ud83c\uddf8\ud83c\uddf9\"];\n     /// assert_eq!(gr2.as_slice(), b);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     fn graphemes(&self, is_extended: bool) -> Graphemes {\n         UnicodeStr::graphemes(&self[], is_extended)\n@@ -1317,7 +1317,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n     /// assert_eq!(gr_inds.as_slice(), b);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n         UnicodeStr::grapheme_indices(&self[], is_extended)\n@@ -1348,7 +1348,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n     /// recommends that these characters be treated as 1 column (i.e.,\n     /// `is_cjk` = `false`) if the locale is unknown.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"this functionality may only be provided by libunicode\")]\n     fn width(&self, is_cjk: bool) -> uint {\n         UnicodeStr::width(&self[], is_cjk)"}, {"sha": "86adf89b749c24947a17d42bb26cf352db473483", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -92,7 +92,7 @@ impl String {\n     /// assert_eq!(s.as_slice(), \"hello\");\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"needs investigation to see if to_string() can match perf\")]\n     pub fn from_str(string: &str) -> String {\n         String { vec: ::slice::SliceExt::to_vec(string.as_bytes()) }\n@@ -725,7 +725,7 @@ impl<'a> FromIterator<&'a str> for String {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"waiting on Extend stabilization\")]\n impl Extend<char> for String {\n     fn extend<I:Iterator<Item=char>>(&mut self, mut iterator: I) {\n@@ -737,7 +737,7 @@ impl Extend<char> for String {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"waiting on Extend stabilization\")]\n impl<'a> Extend<&'a str> for String {\n     fn extend<I: Iterator<Item=&'a str>>(&mut self, mut iterator: I) {\n@@ -798,7 +798,7 @@ impl<'a, 'b> PartialEq<CowString<'a>> for &'b str {\n     fn ne(&self, other: &CowString<'a>) -> bool { PartialEq::ne(&**self, &**other) }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"waiting on Str stabilization\")]\n+#[unstable(feature = \"collections\", reason = \"waiting on Str stabilization\")]\n impl Str for String {\n     #[inline]\n     #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n@@ -824,23 +824,23 @@ impl fmt::String for String {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"waiting on fmt stabilization\")]\n+#[unstable(feature = \"collections\", reason = \"waiting on fmt stabilization\")]\n impl fmt::Show for String {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Show::fmt(&**self, f)\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"waiting on Hash stabilization\")]\n+#[unstable(feature = \"collections\", reason = \"waiting on Hash stabilization\")]\n impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         (**self).hash(hasher)\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"recent addition, needs more experience\")]\n impl<'a> Add<&'a str> for String {\n     type Output = String;\n@@ -892,7 +892,7 @@ impl ops::Deref for String {\n }\n \n /// Wrapper type providing a `&String` reference via `Deref`.\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n pub struct DerefString<'a> {\n     x: DerefVec<'a, u8>\n }\n@@ -920,7 +920,7 @@ impl<'a> Deref for DerefString<'a> {\n /// let string = as_string(\"foo\").clone();\n /// string_consumer(string);\n /// ```\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n pub fn as_string<'a>(x: &'a str) -> DerefString<'a> {\n     DerefString { x: as_vec(x.as_bytes()) }\n }"}, {"sha": "cdf04d18a9f304348c385ed7892abf99df11c70c", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -255,7 +255,7 @@ impl<T> Vec<T> {\n     /// owned by the returned `Vec<T>`. The elements of the buffer are copied into the vector\n     /// without cloning, as if `ptr::read()` were called on them.\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"may be better expressed via composition\")]\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: uint) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n@@ -377,7 +377,7 @@ impl<T> Vec<T> {\n     /// Note that this will drop any excess capacity. Calling this and\n     /// converting back to a vector with `into_vec()` is equivalent to calling\n     /// `shrink_to_fit()`.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"collections\")]\n     pub fn into_boxed_slice(mut self) -> Box<[T]> {\n         self.shrink_to_fit();\n         unsafe {\n@@ -697,7 +697,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec2, vec![]);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"new API, waiting for dust to settle\")]\n     pub fn append(&mut self, other: &mut Self) {\n         if mem::size_of::<T>() == 0 {\n@@ -734,7 +734,7 @@ impl<T> Vec<T> {\n     /// assert!(v.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, T> {\n         unsafe {\n@@ -817,7 +817,7 @@ impl<T> Vec<T> {\n     /// let newtyped_bytes = bytes.map_in_place(|x| Newtype(x));\n     /// assert_eq!(newtyped_bytes.as_slice(), [Newtype(0x11), Newtype(0x22)].as_slice());\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"API may change to provide stronger guarantees\")]\n     pub fn map_in_place<U, F>(self, mut f: F) -> Vec<U> where F: FnMut(T) -> U {\n         // FIXME: Assert statically that the types `T` and `U` have the same\n@@ -1012,7 +1012,7 @@ impl<T: Clone> Vec<T> {\n     /// vec.resize(2, 0);\n     /// assert_eq!(vec, vec![1, 2]);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification; waiting for dust to settle\")]\n     pub fn resize(&mut self, new_len: uint, value: T) {\n         let len = self.len();\n@@ -1037,7 +1037,7 @@ impl<T: Clone> Vec<T> {\n     /// assert_eq!(vec, vec![1, 2, 3, 4]);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"likely to be replaced by a more optimized extend\")]\n     pub fn push_all(&mut self, other: &[T]) {\n         self.reserve(other.len());\n@@ -1206,7 +1206,7 @@ unsafe fn dealloc<T>(ptr: *mut T, len: uint) {\n // Common trait implementations for Vec\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n impl<T:Clone> Clone for Vec<T> {\n     fn clone(&self) -> Vec<T> { ::slice::SliceExt::to_vec(self.as_slice()) }\n \n@@ -1235,7 +1235,7 @@ impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"waiting on Index stability\")]\n+#[unstable(feature = \"collections\", reason = \"waiting on Index stability\")]\n impl<T> Index<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1339,7 +1339,7 @@ impl<T> FromIterator<T> for Vec<T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"waiting on Extend stability\")]\n+#[unstable(feature = \"collections\", reason = \"waiting on Extend stability\")]\n impl<T> Extend<T> for Vec<T> {\n     #[inline]\n     fn extend<I: Iterator<Item=T>>(&mut self, mut iterator: I) {\n@@ -1414,7 +1414,7 @@ macro_rules! impl_eq_for_cowvec {\n impl_eq_for_cowvec! { &'b [B] }\n impl_eq_for_cowvec! { &'b mut [B] }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"waiting on PartialOrd stability\")]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n     #[inline]\n@@ -1423,10 +1423,10 @@ impl<T: PartialOrd> PartialOrd for Vec<T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"waiting on Eq stability\")]\n+#[unstable(feature = \"collections\", reason = \"waiting on Eq stability\")]\n impl<T: Eq> Eq for Vec<T> {}\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"waiting on Ord stability\")]\n+#[unstable(feature = \"collections\", reason = \"waiting on Ord stability\")]\n impl<T: Ord> Ord for Vec<T> {\n     #[inline]\n     fn cmp(&self, other: &Vec<T>) -> Ordering {\n@@ -1457,7 +1457,7 @@ impl<T> AsSlice<T> for Vec<T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"recent addition, needs more experience\")]\n impl<'a, T: Clone> Add<&'a [T]> for Vec<T> {\n     type Output = Vec<T>;\n@@ -1494,7 +1494,7 @@ impl<T> Default for Vec<T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"waiting on Show stability\")]\n+#[unstable(feature = \"collections\", reason = \"waiting on Show stability\")]\n impl<T: fmt::Show> fmt::Show for Vec<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Show::fmt(self.as_slice(), f)\n@@ -1512,12 +1512,12 @@ impl<'a> fmt::Writer for Vec<u8> {\n // Clone-on-write\n ////////////////////////////////////////////////////////////////////////////////\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"unclear how valuable this alias is\")]\n /// A clone-on-write vector\n pub type CowVec<'a, T> = Cow<'a, Vec<T>, [T]>;\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n impl<'a, T> FromIterator<T> for CowVec<'a, T> where T: Clone {\n     fn from_iter<I: Iterator<Item=T>>(it: I) -> CowVec<'a, T> {\n         Cow::Owned(FromIterator::from_iter(it))\n@@ -1555,7 +1555,7 @@ unsafe impl<T: Sync> Sync for IntoIter<T> { }\n impl<T> IntoIter<T> {\n     #[inline]\n     /// Drops all items that have not yet been moved and returns the empty vector.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"collections\")]\n     pub fn into_inner(mut self) -> Vec<T> {\n         unsafe {\n             for _x in self { }\n@@ -1646,7 +1646,7 @@ impl<T> Drop for IntoIter<T> {\n \n /// An iterator that drains a vector.\n #[unsafe_no_drop_flag]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"collections\",\n            reason = \"recently added as part of collections reform 2\")]\n pub struct Drain<'a, T> {\n     ptr: *const T,\n@@ -1735,13 +1735,13 @@ impl<'a, T> Drop for Drain<'a, T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Wrapper type providing a `&Vec<T>` reference via `Deref`.\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n pub struct DerefVec<'a, T> {\n     x: Vec<T>,\n     l: ContravariantLifetime<'a>\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n impl<'a, T> Deref for DerefVec<'a, T> {\n     type Target = Vec<T>;\n \n@@ -1761,7 +1761,7 @@ impl<'a, T> Drop for DerefVec<'a, T> {\n }\n \n /// Convert a slice to a wrapper type providing a `&Vec<T>` reference.\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n pub fn as_vec<'a, T>(x: &'a [T]) -> DerefVec<'a, T> {\n     unsafe {\n         DerefVec {"}, {"sha": "93af9a10b4c5dc357d559a549439c17747475c89", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -310,7 +310,7 @@ impl<V> VecMap<V> {\n     ///\n     /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain<'a>(&'a mut self) -> Drain<'a, V> {\n         fn filter<A>((i, v): (uint, Option<A>)) -> Option<(uint, A)> {\n@@ -700,7 +700,7 @@ pub struct IntoIter<V> {\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n pub struct Drain<'a, V> {\n     iter: FilterMap<\n     (uint, Option<V>),\n@@ -709,15 +709,15 @@ pub struct Drain<'a, V> {\n     fn((uint, Option<V>)) -> Option<(uint, V)>>\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n impl<'a, V> Iterator for Drain<'a, V> {\n     type Item = (uint, V);\n \n     fn next(&mut self) -> Option<(uint, V)> { self.iter.next() }\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"collections\")]\n impl<'a, V> DoubleEndedIterator for Drain<'a, V> {\n     fn next_back(&mut self) -> Option<(uint, V)> { self.iter.next_back() }\n }"}, {"sha": "259c749c7c14ac7d61cda40e73559906ebc72e7a", "filename": "src/libcore/any.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -89,7 +89,7 @@ use intrinsics;\n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub trait Any: 'static {\n     /// Get the `TypeId` of `self`\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"this method will likely be replaced by an associated static\")]\n     fn get_type_id(&self) -> TypeId;\n }\n@@ -177,7 +177,7 @@ impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been\n     /// instantiated with\n     #[cfg(not(stage0))]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"may grow a `Reflect` bound soon via marker traits\")]\n     pub fn of<T: ?Sized + 'static>() -> TypeId {\n         TypeId {"}, {"sha": "3d6549073487ab27f1e490575a04eba8361cb994", "filename": "src/libcore/array.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -12,7 +12,7 @@\n //! up to a certain length. Eventually we should able to generalize\n //! to all lengths.\n \n-#![unstable(feature = \"unnamed_feature\")] // not yet reviewed\n+#![unstable(feature = \"core\")] // not yet reviewed\n \n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n@@ -39,7 +39,7 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable(feature = \"unnamed_feature\",\n+            #[unstable(feature = \"core\",\n                        reason = \"waiting for Show to stabilize\")]\n             impl<T:fmt::Show> fmt::Show for [T; $N] {\n                 fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"}, {"sha": "e4e6fcd3afc525a207ba054b8b510a5ddb8b569d", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -1036,7 +1036,7 @@ pub fn fence(order: Ordering) {\n     }\n }\n \n-#[deprecated(feature = \"unnamed_feature\", since = \"1.0.0\",\n+#[deprecated(feature = \"core\", since = \"1.0.0\",\n              reason = \"renamed to AtomicIsize\")]\n #[allow(missing_docs)]\n pub struct AtomicInt {\n@@ -1045,7 +1045,7 @@ pub struct AtomicInt {\n \n unsafe impl Sync for AtomicInt {}\n \n-#[deprecated(feature = \"unnamed_feature\", since = \"1.0.0\",\n+#[deprecated(feature = \"core\", since = \"1.0.0\",\n              reason = \"renamed to AtomicUsize\")]\n #[allow(missing_docs)]\n pub struct AtomicUint {\n@@ -1054,12 +1054,12 @@ pub struct AtomicUint {\n \n unsafe impl Sync for AtomicUint {}\n \n-#[deprecated(feature = \"unnamed_feature\", since = \"1.0.0\",\n+#[deprecated(feature = \"core\", since = \"1.0.0\",\n              reason = \"use ATOMIC_ISIZE_INIT instead\")]\n #[allow(missing_docs, deprecated)]\n pub const ATOMIC_INT_INIT: AtomicInt =\n         AtomicInt { v: UnsafeCell { value: 0 } };\n-#[deprecated(feature = \"unnamed_feature\", since = \"1.0.0\",\n+#[deprecated(feature = \"core\", since = \"1.0.0\",\n              reason = \"use ATOMIC_USIZE_INIT instead\")]\n #[allow(missing_docs, deprecated)]\n pub const ATOMIC_UINT_INIT: AtomicUint ="}, {"sha": "0acff877927c7cc68fe40413fe168a68aed3202a", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -42,7 +42,7 @@\n //! is desired, `to_mut` will obtain a mutable references to an owned\n //! value, cloning if necessary.\n \n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"core\",\n             reason = \"recently added as part of collections reform\")]\n \n use clone::Clone;"}, {"sha": "dfb8d9be81b4eaa42caa1724a28ac483ce389e99", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -201,7 +201,7 @@ impl<T:Copy> Cell<T> {\n     ///\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"core\")]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n         &self.value\n     }\n@@ -271,7 +271,7 @@ impl<T> RefCell<T> {\n     /// immutable borrows can be taken out at the same time.\n     ///\n     /// Returns `None` if the value is currently mutably borrowed.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"may be renamed or removed\")]\n+    #[unstable(feature = \"core\", reason = \"may be renamed or removed\")]\n     pub fn try_borrow<'a>(&'a self) -> Option<Ref<'a, T>> {\n         match BorrowRef::new(&self.borrow) {\n             Some(b) => Some(Ref { _value: unsafe { &*self.value.get() }, _borrow: b }),\n@@ -301,7 +301,7 @@ impl<T> RefCell<T> {\n     /// cannot be borrowed while this borrow is active.\n     ///\n     /// Returns `None` if the value is currently borrowed.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"may be renamed or removed\")]\n+    #[unstable(feature = \"core\", reason = \"may be renamed or removed\")]\n     pub fn try_borrow_mut<'a>(&'a self) -> Option<RefMut<'a, T>> {\n         match BorrowRefMut::new(&self.borrow) {\n             Some(b) => Some(RefMut { _value: unsafe { &mut *self.value.get() }, _borrow: b }),\n@@ -331,7 +331,7 @@ impl<T> RefCell<T> {\n     ///\n     /// This function is `unsafe` because `UnsafeCell`'s field is public.\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"core\")]\n     pub unsafe fn as_unsafe_cell<'a>(&'a self) -> &'a UnsafeCell<T> {\n         &self.value\n     }\n@@ -423,7 +423,7 @@ impl<'b, T> Deref for Ref<'b, T> {\n ///\n /// A `Clone` implementation would interfere with the widespread\n /// use of `r.borrow().clone()` to clone the contents of a `RefCell`.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to be moved to a method, pending language changes\")]\n pub fn clone_ref<'b, T:Clone>(orig: &Ref<'b, T>) -> Ref<'b, T> {\n     Ref {\n@@ -528,7 +528,7 @@ pub struct UnsafeCell<T> {\n     ///\n     /// This field should not be accessed directly, it is made public for static\n     /// initializers.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"core\")]\n     pub value: T,\n }\n "}, {"sha": "e0b3cb1c1ecb2dff6e96e97bbc6961be01be196e", "filename": "src/libcore/char.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -92,7 +92,7 @@ pub fn from_u32(i: u32) -> Option<char> {\n /// Panics if given an `radix` > 36.\n ///\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"pending integer conventions\")]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n     if radix > 36 {\n         panic!(\"from_digit: radix is too high (maximum 36)\");\n@@ -126,7 +126,7 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix > 36.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool;\n \n@@ -141,7 +141,7 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix outside the range [0..36].\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint>;\n \n@@ -198,13 +198,13 @@ pub trait CharExt {\n \n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl CharExt for char {\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool {\n         self.to_digit(radix).is_some()\n     }\n \n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint> {\n         if radix > 36 {\n@@ -260,7 +260,7 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> {\n         // Marked #[inline] to allow llvm optimizing it away\n@@ -289,7 +289,7 @@ impl CharExt for char {\n     }\n \n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> {\n         // Marked #[inline] to allow llvm optimizing it away\n@@ -320,7 +320,7 @@ pub struct EscapeUnicode {\n }\n \n #[derive(Clone)]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n enum EscapeUnicodeState {\n     Backslash,\n     Type,\n@@ -382,7 +382,7 @@ pub struct EscapeDefault {\n }\n \n #[derive(Clone)]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n enum EscapeDefaultState {\n     Backslash(char),\n     Char(char),"}, {"sha": "360bcdddc852625bfa6b8b699538f851edc03f3b", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -36,7 +36,7 @@ pub trait Clone : Sized {\n     /// but can be overridden to reuse the resources of `a` to avoid unnecessary\n     /// allocations.\n     #[inline(always)]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"this function is rarely used\")]\n     fn clone_from(&mut self, source: &Self) {\n         *self = source.clone()\n@@ -82,7 +82,7 @@ clone_impl! { char }\n \n macro_rules! extern_fn_clone {\n     ($($A:ident),*) => (\n-        #[unstable(feature = \"unnamed_feature\",\n+        #[unstable(feature = \"core\",\n                    reason = \"this may not be sufficient for fns with region parameters\")]\n         impl<$($A,)* ReturnType> Clone for extern \"Rust\" fn($($A),*) -> ReturnType {\n             /// Return a copy of a function pointer"}, {"sha": "8a2188f543a7bda2d2eba309591ca1550a9a799c", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -290,7 +290,7 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n #[inline]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n         Some(Less) | Some(Equal) => Some(v1),\n@@ -303,7 +303,7 @@ pub fn partial_min<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n ///\n /// Returns the first argument if the comparison determines them to be equal.\n #[inline]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub fn partial_max<T: PartialOrd>(v1: T, v2: T) -> Option<T> {\n     match v1.partial_cmp(&v2) {\n         Some(Less) => Some(v2),"}, {"sha": "2bd90e7c964a14a73c7aa47e9c2292eb14b9b179", "filename": "src/libcore/finally.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffinally.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -30,7 +30,7 @@\n //! })\n //! ```\n \n-#![deprecated(feature = \"unnamed_feature\", since = \"1.0.0\",\n+#![deprecated(feature = \"core\", since = \"1.0.0\",\n               reason = \"It is unclear if this module is more robust than implementing \\\n                         Drop on a custom type, and this module is being removed with no \\\n                         replacement. Use a custom Drop implementation to regain existing \\"}, {"sha": "1503d5858874f8c8521ffb62289c1e7460292008", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -36,7 +36,7 @@ mod num;\n mod float;\n pub mod rt;\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"core and I/O reconciliation may alter this definition\")]\n /// The type returned by formatter methods.\n pub type Result = result::Result<(), Error>;\n@@ -46,7 +46,7 @@ pub type Result = result::Result<(), Error>;\n /// This type does not support transmission of an error other than that an error\n /// occurred. Any extra information must be arranged to be transmitted through\n /// some other means.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"core and I/O reconciliation may alter this definition\")]\n #[derive(Copy)]\n pub struct Error;\n@@ -60,7 +60,7 @@ pub struct Error;\n /// This trait should generally not be implemented by consumers of the standard\n /// library. The `write!` macro accepts an instance of `io::Writer`, and the\n /// `io::Writer` trait is favored over implementing this trait.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"waiting for core and I/O reconciliation\")]\n pub trait Writer {\n     /// Writes a slice of bytes into this writer, returning whether the write\n@@ -104,7 +104,7 @@ pub trait Writer {\n /// A struct to represent both where to emit formatting strings to and how they\n /// should be formatted. A mutable version of this is passed to all formatting\n /// traits.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"name may change and implemented traits are also unstable\")]\n pub struct Formatter<'a> {\n     flags: uint,\n@@ -127,7 +127,7 @@ enum Void {}\n /// family of functions. It contains a function to format the given value. At\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"implementation detail of the `format_args!` macro\")]\n #[derive(Copy)]\n pub struct Argument<'a> {\n@@ -167,7 +167,7 @@ impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure.\n     #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"implementation detail of the `format_args!` macro\")]\n     pub fn new(pieces: &'a [&'a str],\n                args: &'a [Argument<'a>]) -> Arguments<'a> {\n@@ -185,7 +185,7 @@ impl<'a> Arguments<'a> {\n     /// created with `argumentuint`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"implementation detail of the `format_args!` macro\")]\n     pub fn with_placeholders(pieces: &'a [&'a str],\n                              fmt: &'a [rt::Argument],\n@@ -236,7 +236,7 @@ impl<'a> String for Arguments<'a> {\n \n /// Format trait for the `:?` format. Useful for debugging, most all types\n /// should implement this.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n pub trait Show {\n     /// Formats the value using the given formatter.\n@@ -245,7 +245,7 @@ pub trait Show {\n \n /// When a value can be semantically expressed as a String, this trait may be\n /// used. It corresponds to the default format, `{}`.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n pub trait String {\n     /// Formats the value using the given formatter.\n@@ -254,55 +254,55 @@ pub trait String {\n \n \n /// Format trait for the `o` character\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n pub trait Octal {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `b` character\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n pub trait Binary {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `x` character\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n pub trait LowerHex {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `X` character\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n pub trait UpperHex {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `p` character\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n pub trait Pointer {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `e` character\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n pub trait LowerExp {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n /// Format trait for the `E` character\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"I/O and core have yet to be reconciled\")]\n pub trait UpperExp {\n     /// Formats the value using the given formatter.\n@@ -317,7 +317,7 @@ pub trait UpperExp {\n ///\n ///   * output - the buffer to write output to\n ///   * args - the precompiled arguments generated by `format_args!`\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"libcore and I/O have yet to be reconciled, and this is an \\\n                      implementation detail which should not otherwise be exported\")]\n pub fn write(output: &mut Writer, args: Arguments) -> Result {\n@@ -415,7 +415,7 @@ impl<'a> Formatter<'a> {\n     ///\n     /// This function will correctly account for the flags provided as well as\n     /// the minimum width. It will not take precision into account.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"definition may change slightly over time\")]\n     pub fn pad_integral(&mut self,\n                         is_positive: bool,\n@@ -492,7 +492,7 @@ impl<'a> Formatter<'a> {\n     ///               is longer than this length\n     ///\n     /// Notably this function ignored the `flag` parameters\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"definition may change slightly over time\")]\n     pub fn pad(&mut self, s: &str) -> Result {\n         // Make sure there's a fast path up front\n@@ -570,38 +570,38 @@ impl<'a> Formatter<'a> {\n \n     /// Writes some data to the underlying buffer contained within this\n     /// formatter.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"reconciling core and I/O may alter this definition\")]\n     pub fn write_str(&mut self, data: &str) -> Result {\n         self.buf.write_str(data)\n     }\n \n     /// Writes some formatted information into this instance\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"reconciling core and I/O may alter this definition\")]\n     pub fn write_fmt(&mut self, fmt: Arguments) -> Result {\n         write(self.buf, fmt)\n     }\n \n     /// Flags for formatting (packed version of rt::Flag)\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"return type may change and method was just created\")]\n     pub fn flags(&self) -> uint { self.flags }\n \n     /// Character used as 'fill' whenever there is alignment\n-    #[unstable(feature = \"unnamed_feature\", reason = \"method was just created\")]\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn fill(&self) -> char { self.fill }\n \n     /// Flag indicating what form of alignment was requested\n-    #[unstable(feature = \"unnamed_feature\", reason = \"method was just created\")]\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn align(&self) -> rt::Alignment { self.align }\n \n     /// Optionally specified integer width that the output should be\n-    #[unstable(feature = \"unnamed_feature\", reason = \"method was just created\")]\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn width(&self) -> Option<uint> { self.width }\n \n     /// Optionally specified precision for numeric types\n-    #[unstable(feature = \"unnamed_feature\", reason = \"method was just created\")]\n+    #[unstable(feature = \"core\", reason = \"method was just created\")]\n     pub fn precision(&self) -> Option<uint> { self.precision }\n }\n \n@@ -614,7 +614,7 @@ impl Show for Error {\n /// This is a function which calls are emitted to by the compiler itself to\n /// create the Argument structures that are passed into the `format` function.\n #[doc(hidden)] #[inline]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"implementation detail of the `format_args!` macro\")]\n pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n                        t: &'a T) -> Argument<'a> {\n@@ -624,7 +624,7 @@ pub fn argument<'a, T>(f: fn(&T, &mut Formatter) -> Result,\n /// When the compiler determines that the type of an argument *must* be a uint\n /// (such as for width and precision), then it invokes this method.\n #[doc(hidden)] #[inline]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"implementation detail of the `format_args!` macro\")]\n pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n     Argument::from_uint(s)\n@@ -879,7 +879,7 @@ impl<T: Copy + Show> Show for Cell<T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<T: Show> Show for RefCell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match self.try_borrow() {"}, {"sha": "83397e5dc99a9f82e33e71e471bf9b4a2c8b706d", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -111,7 +111,7 @@ radix! { UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n \n /// A radix with in the range of `2..36`.\n #[derive(Clone, Copy, PartialEq)]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"may be renamed or move to a different module\")]\n pub struct Radix {\n     base: u8,\n@@ -136,7 +136,7 @@ impl GenericRadix for Radix {\n }\n \n /// A helper type for formatting radixes.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"may be renamed or move to a different module\")]\n #[derive(Copy)]\n pub struct RadixFmt<T, R>(T, R);\n@@ -149,7 +149,7 @@ pub struct RadixFmt<T, R>(T, R);\n /// use std::fmt::radix;\n /// assert_eq!(format!(\"{}\", radix(55i, 36)), \"1j\".to_string());\n /// ```\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"may be renamed or move to a different module\")]\n pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n     RadixFmt(x, Radix::new(base))"}, {"sha": "0b2c1efbc5dee1682228f5e2ea263589265c2ee0", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -14,7 +14,7 @@\n //! These definitions are similar to their `ct` equivalents, but differ in that\n //! these can be statically allocated and are slightly optimized for the runtime\n \n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"core\",\n             reason = \"implementation detail of the `format_args!` macro\")]\n \n pub use self::Alignment::*;"}, {"sha": "5a4d2fffade6348598849c7ac29aafabc8078aa7", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -56,7 +56,7 @@\n //! assert_eq!(hash::<_, SipHasher>(&person1), hash::<_, SipHasher>(&person2));\n //! ```\n \n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"hash\",\n             reason = \"module was recently redesigned\")]\n \n use prelude::*;\n@@ -96,7 +96,7 @@ pub trait Hasher {\n \n /// A common bound on the `Hasher` parameter to `Hash` implementations in order\n /// to generically hash an aggregate.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"hash\",\n            reason = \"this trait will likely be replaced by io::Writer\")]\n #[allow(missing_docs)]\n pub trait Writer {"}, {"sha": "872b2d031f6976a3603c8ae243a33693cf1e176e", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -39,7 +39,7 @@\n //!   guaranteed to happen in order. This is the standard mode for working\n //!   with atomic types and is equivalent to Java's `volatile`.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"core\")]\n #![allow(missing_docs)]\n \n use marker::Sized;\n@@ -303,7 +303,7 @@ extern \"rust-intrinsic\" {\n     ///     }\n     /// }\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"core\")]\n     pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n@@ -333,12 +333,12 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     ///\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"core\")]\n     pub fn copy_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `dst` to `c`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"uncertain about naming and semantics\")]\n     pub fn set_memory<T>(dst: *mut T, val: u8, count: uint);\n "}, {"sha": "fef11ecba186ed86ea4fc517de34b5ee4f16acb3", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -564,7 +564,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(even, vec![2, 4]);\n     /// assert_eq!(odd, vec![1, 3]);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"recently added as part of collections reform\")]\n     fn partition<B, F>(mut self, mut f: F) -> (B, B) where\n         B: Default + Extend<Self::Item>,\n@@ -760,7 +760,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// let v = [1i, 1, 1, 1];\n     /// assert!(v.iter().min_max() == MinMax(&1, &1));\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\", reason = \"return type may change\")]\n+    #[unstable(feature = \"core\", reason = \"return type may change\")]\n     fn min_max(mut self) -> MinMaxResult<Self::Item> where Self::Item: Ord\n     {\n         let (mut min, mut max) = match self.next() {\n@@ -817,7 +817,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"may want to produce an Ordering directly; see #15311\")]\n     fn max_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where\n         F: FnMut(&Self::Item) -> B,\n@@ -847,7 +847,7 @@ pub trait IteratorExt: Iterator + Sized {\n     /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"may want to produce an Ordering directly; see #15311\")]\n     fn min_by<B: Ord, F>(self, mut f: F) -> Option<Self::Item> where\n         F: FnMut(&Self::Item) -> B,\n@@ -887,7 +887,7 @@ pub trait IteratorExt: Iterator + Sized {\n     ///\n     /// Loops through the entire iterator, collecting the first component of\n     /// each item into one new container, and the second component into another.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"recent addition\")]\n+    #[unstable(feature = \"core\", reason = \"recent addition\")]\n     fn unzip<A, B, FromA, FromB>(mut self) -> (FromA, FromB) where\n         FromA: Default + Extend<A>,\n         FromB: Default + Extend<B>,\n@@ -920,7 +920,7 @@ pub trait IteratorExt: Iterator + Sized {\n \n     /// Creates an iterator that clones the elements it yields. Useful for converting an\n     /// Iterator<&T> to an Iterator<T>.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"recent addition\")]\n+    #[unstable(feature = \"core\", reason = \"recent addition\")]\n     fn cloned<T, D>(self) -> Cloned<Self> where\n         Self: Iterator<Item=D>,\n         D: Deref<Target=T>,\n@@ -948,7 +948,7 @@ pub trait IteratorExt: Iterator + Sized {\n     }\n \n     /// Use an iterator to reverse a container in place.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"uncertain about placement or widespread use\")]\n     fn reverse_in_place<'a, T: 'a>(&mut self) where\n         Self: Iterator<Item=&'a mut T> + DoubleEndedIterator\n@@ -982,7 +982,7 @@ pub trait DoubleEndedIterator: Iterator {\n /// Calling `next()` or `next_back()` on a `RandomAccessIterator`\n /// reduces the indexable range accordingly. That is, `it.idx(1)` will become `it.idx(0)`\n /// after `it.next()` is called.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"not widely used, may be better decomposed into Index and ExactSizeIterator\")]\n pub trait RandomAccessIterator: Iterator {\n     /// Return the number of indexable elements. At most `std::uint::MAX`\n@@ -1058,7 +1058,7 @@ impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n     fn next_back(&mut self) -> Option<<I as Iterator>::Item> { self.iter.next() }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Rev<I> where I: DoubleEndedIterator + RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint { self.iter.indexable() }\n@@ -1093,7 +1093,7 @@ impl<'a, I> DoubleEndedIterator for ByRef<'a, I> where I: 'a + DoubleEndedIterat\n }\n \n /// A trait for iterators over elements which can be added together\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"needs to be re-evaluated as part of numerics reform\")]\n pub trait AdditiveIterator<A> {\n     /// Iterates over the entire iterator, summing up all the elements\n@@ -1112,7 +1112,7 @@ pub trait AdditiveIterator<A> {\n \n macro_rules! impl_additive {\n     ($A:ty, $init:expr) => {\n-        #[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+        #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n         impl<T: Iterator<Item=$A>> AdditiveIterator<$A> for T {\n             #[inline]\n             fn sum(self) -> $A {\n@@ -1135,7 +1135,7 @@ impl_additive! { f32,  0.0 }\n impl_additive! { f64,  0.0 }\n \n /// A trait for iterators over elements which can be multiplied together.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"needs to be re-evaluated as part of numerics reform\")]\n pub trait MultiplicativeIterator<A> {\n     /// Iterates over the entire iterator, multiplying all the elements\n@@ -1157,7 +1157,7 @@ pub trait MultiplicativeIterator<A> {\n \n macro_rules! impl_multiplicative {\n     ($A:ty, $init:expr) => {\n-        #[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+        #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n         impl<T: Iterator<Item=$A>> MultiplicativeIterator<$A> for T {\n             #[inline]\n             fn product(self) -> $A {\n@@ -1181,7 +1181,7 @@ impl_multiplicative! { f64,  1.0 }\n \n /// `MinMaxResult` is an enum returned by `min_max`. See `IteratorOrdExt::min_max` for more detail.\n #[derive(Clone, PartialEq, Show)]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"unclear whether such a fine-grained result is widely useful\")]\n pub enum MinMaxResult<T> {\n     /// Empty iterator\n@@ -1214,7 +1214,7 @@ impl<T: Clone> MinMaxResult<T> {\n     /// let r = MinMax(1i,2i);\n     /// assert_eq!(r.into_option(), Some((1,2)));\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\", reason = \"type is unstable\")]\n+    #[unstable(feature = \"core\", reason = \"type is unstable\")]\n     pub fn into_option(self) -> Option<(T,T)> {\n         match self {\n             NoElements => None,\n@@ -1225,7 +1225,7 @@ impl<T: Clone> MinMaxResult<T> {\n }\n \n /// An iterator that clones the elements of an underlying iterator\n-#[unstable(feature = \"unnamed_feature\", reason = \"recent addition\")]\n+#[unstable(feature = \"core\", reason = \"recent addition\")]\n #[must_use = \"iterator adaptors are lazy and do nothing unless consumed\"]\n #[derive(Clone)]\n pub struct Cloned<I> {\n@@ -1299,7 +1299,7 @@ impl<I> Iterator for Cycle<I> where I: Clone + Iterator {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Cycle<I> where\n     I: Clone + RandomAccessIterator,\n {\n@@ -1384,7 +1384,7 @@ impl<T, A, B> DoubleEndedIterator for Chain<A, B> where\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<T, A, B> RandomAccessIterator for Chain<A, B> where\n     A: RandomAccessIterator<Item=T>,\n     B: RandomAccessIterator<Item=T>,\n@@ -1476,7 +1476,7 @@ impl<T, U, A, B> DoubleEndedIterator for Zip<A, B> where\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<T, U, A, B> RandomAccessIterator for Zip<A, B> where\n     A: RandomAccessIterator<Item=T>,\n     B: RandomAccessIterator<Item=U>,\n@@ -1558,7 +1558,7 @@ impl<A, B, I, F> DoubleEndedIterator for Map<A, B, I, F> where\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<A, B, I, F> RandomAccessIterator for Map<A, B, I, F> where\n     I: RandomAccessIterator<Item=A>,\n     F: FnMut(A) -> B,\n@@ -1747,7 +1747,7 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Enumerate<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1973,7 +1973,7 @@ impl<I> Iterator for Skip<I> where I: Iterator {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Skip<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -2028,7 +2028,7 @@ impl<I> Iterator for Take<I> where I: Iterator{\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Take<I> where I: RandomAccessIterator{\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -2241,7 +2241,7 @@ impl<I> DoubleEndedIterator for Fuse<I> where I: DoubleEndedIterator {\n }\n \n // Allow RandomAccessIterators to be fused without affecting random-access behavior\n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<I> RandomAccessIterator for Fuse<I> where I: RandomAccessIterator {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -2258,7 +2258,7 @@ impl<I> Fuse<I> {\n     /// Resets the fuse such that the next call to .next() or .next_back() will\n     /// call the underlying iterator again even if it previously returned None.\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\", reason = \"seems marginal\")]\n+    #[unstable(feature = \"core\", reason = \"seems marginal\")]\n     pub fn reset_fuse(&mut self) {\n         self.done = false\n     }\n@@ -2327,7 +2327,7 @@ impl<A, I, F> DoubleEndedIterator for Inspect<A, I, F> where\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n     I: RandomAccessIterator<Item=A>,\n     F: FnMut(&A),\n@@ -2376,7 +2376,7 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n ///     println!(\"{}\", i);\n /// }\n /// ```\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub struct Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     f: F,\n     /// Internal state that will be passed to the closure on the next iteration\n@@ -2397,7 +2397,7 @@ impl<A, St, F> Clone for Unfold<A, St, F> where\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<A, St, F> Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the closure\n@@ -2429,7 +2429,7 @@ impl<A, St, F> Iterator for Unfold<A, St, F> where F: FnMut(&mut St) -> Option<A\n /// An infinite iterator starting at `start` and advancing by `step` with each\n /// iteration\n #[derive(Clone, Copy)]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"may be renamed or replaced by range notation adapaters\")]\n pub struct Counter<A> {\n     /// The current state the counter is at (next value to be yielded)\n@@ -2440,7 +2440,7 @@ pub struct Counter<A> {\n \n /// Creates a new counter with the specified start/step\n #[inline]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"may be renamed or replaced by range notation adapaters\")]\n pub fn count<A>(start: A, step: A) -> Counter<A> {\n     Counter{state: start, step: step}\n@@ -2465,7 +2465,7 @@ impl<A: Add<Output=A> + Clone> Iterator for Counter<A> {\n \n /// An iterator over the range [start, stop)\n #[derive(Clone, Copy)]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"will be replaced by range notation\")]\n pub struct Range<A> {\n     state: A,\n@@ -2487,7 +2487,7 @@ pub struct Range<A> {\n /// }\n /// ```\n #[inline]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"will be replaced by range notation\")]\n pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n     Range {\n@@ -2498,7 +2498,7 @@ pub fn range<A: Int>(start: A, stop: A) -> Range<A> {\n }\n \n // FIXME: #10414: Unfortunate type bound\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"will be replaced by range notation\")]\n impl<A: Int + ToPrimitive> Iterator for Range<A> {\n     type Item = A;\n@@ -2549,7 +2549,7 @@ impl<A: Int + ToPrimitive> Iterator for Range<A> {\n \n /// `Int` is required to ensure the range will be the same regardless of\n /// the direction it is consumed.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"will be replaced by range notation\")]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n     #[inline]\n@@ -2565,7 +2565,7 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for Range<A> {\n \n /// An iterator over the range [start, stop]\n #[derive(Clone)]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n pub struct RangeInclusive<A> {\n     range: Range<A>,\n@@ -2574,7 +2574,7 @@ pub struct RangeInclusive<A> {\n \n /// Return an iterator over the range [start, stop]\n #[inline]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n     RangeInclusive {\n@@ -2583,7 +2583,7 @@ pub fn range_inclusive<A: Int>(start: A, stop: A) -> RangeInclusive<A> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     type Item = A;\n@@ -2619,7 +2619,7 @@ impl<A: Int + ToPrimitive> Iterator for RangeInclusive<A> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n     #[inline]\n@@ -2639,7 +2639,7 @@ impl<A: Int + ToPrimitive> DoubleEndedIterator for RangeInclusive<A> {\n \n /// An iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[derive(Clone)]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n pub struct RangeStep<A> {\n     state: A,\n@@ -2650,14 +2650,14 @@ pub struct RangeStep<A> {\n \n /// Return an iterator over the range [start, stop) by `step`. It handles overflow by stopping.\n #[inline]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n pub fn range_step<A: Int>(start: A, stop: A, step: A) -> RangeStep<A> {\n     let rev = step < Int::zero();\n     RangeStep{state: start, stop: stop, step: step, rev: rev}\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int> Iterator for RangeStep<A> {\n     type Item = A;\n@@ -2679,7 +2679,7 @@ impl<A: Int> Iterator for RangeStep<A> {\n \n /// An iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[derive(Clone)]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n pub struct RangeStepInclusive<A> {\n     state: A,\n@@ -2691,7 +2691,7 @@ pub struct RangeStepInclusive<A> {\n \n /// Return an iterator over the range [start, stop] by `step`. It handles overflow by stopping.\n #[inline]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepInclusive<A> {\n     let rev = step < Int::zero();\n@@ -2704,7 +2704,7 @@ pub fn range_step_inclusive<A: Int>(start: A, stop: A, step: A) -> RangeStepIncl\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to be replaced by range notation and adapters\")]\n impl<A: Int> Iterator for RangeStepInclusive<A> {\n     type Item = A;\n@@ -2730,7 +2730,7 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n /// directions. The `steps_between` function provides a way to\n /// compare two Step objects (it could be provided using `step()` and `Ord`,\n /// but the implementation would be so inefficient as to be useless).\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"design of range notation/iteration is in flux\")]\n pub trait Step: Ord {\n     /// Change self to the next object.\n@@ -2746,7 +2746,7 @@ pub trait Step: Ord {\n \n macro_rules! step_impl {\n     ($($t:ty)*) => ($(\n-        #[unstable(feature = \"unnamed_feature\", reason = \"Trait is unstable.\")]\n+        #[unstable(feature = \"core\", reason = \"Trait is unstable.\")]\n         impl Step for $t {\n             #[inline]\n             fn step(&mut self) { *self += 1; }\n@@ -2763,7 +2763,7 @@ macro_rules! step_impl {\n \n macro_rules! step_impl_no_between {\n     ($($t:ty)*) => ($(\n-        #[unstable(feature = \"unnamed_feature\", reason = \"Trait is unstable.\")]\n+        #[unstable(feature = \"core\", reason = \"Trait is unstable.\")]\n         impl Step for $t {\n             #[inline]\n             fn step(&mut self) { *self += 1; }\n@@ -2807,7 +2807,7 @@ impl<A: Clone> DoubleEndedIterator for Repeat<A> {\n     fn next_back(&mut self) -> Option<A> { self.idx(0) }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<A: Clone> RandomAccessIterator for Repeat<A> {\n     #[inline]\n     fn indexable(&self) -> uint { uint::MAX }\n@@ -2819,12 +2819,12 @@ type IterateState<T, F> = (F, Option<T>, bool);\n \n /// An iterator that repeatedly applies a given function, starting\n /// from a given seed value.\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub type Iterate<T, F> = Unfold<T, IterateState<T, F>, fn(&mut IterateState<T, F>) -> Option<T>>;\n \n /// Create a new iterator that produces an infinite sequence of\n /// repeated applications of the given function `f`.\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n     T: Clone,\n     F: FnMut(T) -> T,\n@@ -2867,7 +2867,7 @@ pub fn repeat<T: Clone>(elt: T) -> Repeat<T> {\n ///\n /// If two sequences are equal up until the point where one ends,\n /// the shorter sequence compares less.\n-#[unstable(feature = \"unnamed_feature\", reason = \"needs review and revision\")]\n+#[unstable(feature = \"core\", reason = \"needs review and revision\")]\n pub mod order {\n     use cmp;\n     use cmp::{Eq, Ord, PartialOrd, PartialEq};"}, {"sha": "ea697ed769d3676b7a53fbd36f92c6ea40b91fc7", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -48,7 +48,7 @@\n // separate crate, libcoretest, to avoid bizarre issues.\n \n #![crate_name = \"core\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"core\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]"}, {"sha": "87f21e91c6290724ab010ffb2d29c5cd7329eb75", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -235,7 +235,7 @@ macro_rules! writeln {\n /// }\n /// ```\n #[macro_export]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"relationship with panic is unclear\")]\n macro_rules! unreachable {\n     () => ({\n@@ -252,7 +252,7 @@ macro_rules! unreachable {\n /// A standardised placeholder for marking unfinished code. It panics with the\n /// message `\"not yet implemented\"` when executed.\n #[macro_export]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"relationship with panic is unclear\")]\n macro_rules! unimplemented {\n     () => (panic!(\"not yet implemented\"))"}, {"sha": "96f65a2b73281d5c7b88ef54f885c1dbf451c0b4", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -28,7 +28,7 @@\n use clone::Clone;\n \n /// Types able to be transferred across task boundaries.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n #[lang=\"send\"]\n pub unsafe trait Send: 'static {\n@@ -192,7 +192,7 @@ pub trait Copy {\n /// around the value(s) which can be mutated when behind a `&`\n /// reference; not doing this is undefined behaviour (for example,\n /// `transmute`-ing from `&T` to `&mut T` is illegal).\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"will be overhauled with new lifetime rules; see RFC 458\")]\n #[lang=\"sync\"]\n pub unsafe trait Sync {\n@@ -237,7 +237,7 @@ pub unsafe trait Sync {\n /// `S<T>` is a subtype of `S<U>` if `T` is a subtype of `U`\n /// (for example, `S<&'static int>` is a subtype of `S<&'a int>`\n /// for some lifetime `'a`, but not the other way around).\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n #[lang=\"covariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n@@ -287,7 +287,7 @@ impl<T: ?Sized> Clone for CovariantType<T> {\n /// subtype of `S<U>` if `U` is a subtype of `T`; given that the\n /// function requires arguments of type `T`, it must also accept\n /// arguments of type `U`, hence such a conversion is safe.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n #[lang=\"contravariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n@@ -318,16 +318,16 @@ impl<T: ?Sized> Clone for ContravariantType<T> {\n /// The type system would infer that `value` is only read here and\n /// never written, but in fact `Cell` uses unsafe code to achieve\n /// interior mutability.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n #[lang=\"invariant_type\"]\n #[derive(PartialEq, Eq, PartialOrd, Ord)]\n pub struct InvariantType<T: ?Sized>;\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n impl<T: ?Sized> Copy for InvariantType<T> {}\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n impl<T: ?Sized> Clone for InvariantType<T> {\n     fn clone(&self) -> InvariantType<T> { *self }\n@@ -349,7 +349,7 @@ impl<T: ?Sized> Clone for InvariantType<T> {\n ///\n /// For more information about variance, refer to this Wikipedia\n /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n #[lang=\"covariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n@@ -367,7 +367,7 @@ pub struct CovariantLifetime<'a>;\n ///\n /// For more information about variance, refer to this Wikipedia\n /// article <http://en.wikipedia.org/wiki/Variance_%28computer_science%29>.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n #[lang=\"contravariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n@@ -380,7 +380,7 @@ pub struct ContravariantLifetime<'a>;\n /// pointer that is actually a pointer into memory with lifetime `'a`,\n /// and this pointer is itself stored in an inherently mutable\n /// location (such as a `Cell`).\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n #[lang=\"invariant_lifetime\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n@@ -390,7 +390,7 @@ pub struct InvariantLifetime<'a>;\n /// be safely sent between tasks, even if it is owned. This is\n /// typically embedded in other types, such as `Gc`, to ensure that\n /// their instances remain thread-local.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n #[lang=\"no_send_bound\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n@@ -400,7 +400,7 @@ pub struct NoSend;\n /// A type which is considered \"not POD\", meaning that it is not\n /// implicitly copyable. This is typically embedded in other types to\n /// ensure that they are never copied, even if they lack a destructor.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n #[lang=\"no_copy_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]\n@@ -410,7 +410,7 @@ pub struct NoCopy;\n /// A type which is considered \"not sync\", meaning that\n /// its contents are not threadsafe, hence they cannot be\n /// shared between tasks.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n #[lang=\"no_sync_bound\"]\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n@@ -419,7 +419,7 @@ pub struct NoSync;\n \n /// A type which is considered managed by the GC. This is typically\n /// embedded in other types.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"likely to change with new variance strategy\")]\n #[lang=\"managed_bound\"]\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]"}, {"sha": "001b58c2460e97829db8f5e450cea87da4503508", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -318,7 +318,7 @@ pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n \n /// Transforms lifetime of the second pointer to match the first.\n #[inline]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"this function may be removed in the future due to its \\\n                      questionable utility\")]\n pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n@@ -328,7 +328,7 @@ pub unsafe fn copy_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a S,\n \n /// Transforms lifetime of the second mutable pointer to match the first.\n #[inline]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"this function may be removed in the future due to its \\\n                      questionable utility\")]\n pub unsafe fn copy_mut_lifetime<'a, S: ?Sized, T: ?Sized + 'a>(_ptr: &'a mut S,"}, {"sha": "7c8be79d075cba1ac66aac0db038888e6af5bf9c", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -32,7 +32,7 @@ unsafe impl Zeroable for u64 {}\n /// NULL or 0 that might allow certain optimizations.\n #[lang=\"non_zero\"]\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Show)]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub struct NonZero<T: Zeroable>(T);\n \n impl<T: Zeroable> NonZero<T> {"}, {"sha": "8e28bb18aef62072dd6650cee7dc11c2fd54c3bf", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -22,12 +22,12 @@ use num::Float;\n use num::FpCategory as Fp;\n use option::Option;\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"pending integer conventions\")]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const RADIX: uint = 2u;\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"pending integer conventions\")]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MANTISSA_DIGITS: uint = 24u;\n-#[unstable(feature = \"unnamed_feature\", reason = \"pending integer conventions\")]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const DIGITS: uint = 6u;\n \n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n@@ -43,14 +43,14 @@ pub const MIN_POS_VALUE: f32 = 1.17549435e-38_f32;\n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const MAX_VALUE: f32 = 3.40282347e+38_f32;\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"pending integer conventions\")]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MIN_EXP: int = -125;\n-#[unstable(feature = \"unnamed_feature\", reason = \"pending integer conventions\")]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MAX_EXP: int = 128;\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"pending integer conventions\")]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MIN_10_EXP: int = -37;\n-#[unstable(feature = \"unnamed_feature\", reason = \"pending integer conventions\")]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MAX_10_EXP: int = 38;\n \n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n@@ -61,7 +61,7 @@ pub const INFINITY: f32 = 1.0_f32/0.0_f32;\n pub const NEG_INFINITY: f32 = -1.0_f32/0.0_f32;\n \n /// Various useful constants.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"naming scheme needs to be revisited\")]\n pub mod consts {\n     // FIXME: replace with mathematical constants from cmath.\n@@ -118,7 +118,7 @@ pub mod consts {\n     pub const LN_10: f32 = 2.30258509299404568401799145468436421_f32;\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is unstable\")]\n+#[unstable(feature = \"core\", reason = \"trait is unstable\")]\n impl Float for f32 {\n     #[inline]\n     fn nan() -> f32 { NAN }"}, {"sha": "4fee89e923cc73596d9d1af3d32fb9f40eb7a1bd", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -26,11 +26,11 @@ use option::Option;\n // constants are implemented in favour of referencing the respective\n // members of `Bounded` and `Float`.\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"pending integer conventions\")]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const RADIX: uint = 2u;\n \n pub const MANTISSA_DIGITS: uint = 53u;\n-#[unstable(feature = \"unnamed_feature\", reason = \"pending integer conventions\")]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const DIGITS: uint = 15u;\n \n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n@@ -46,14 +46,14 @@ pub const MIN_POS_VALUE: f64 = 2.2250738585072014e-308_f64;\n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub const MAX_VALUE: f64 = 1.7976931348623157e+308_f64;\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"pending integer conventions\")]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MIN_EXP: int = -1021;\n-#[unstable(feature = \"unnamed_feature\", reason = \"pending integer conventions\")]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MAX_EXP: int = 1024;\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"pending integer conventions\")]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MIN_10_EXP: int = -307;\n-#[unstable(feature = \"unnamed_feature\", reason = \"pending integer conventions\")]\n+#[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n pub const MAX_10_EXP: int = 308;\n \n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n@@ -64,7 +64,7 @@ pub const INFINITY: f64 = 1.0_f64/0.0_f64;\n pub const NEG_INFINITY: f64 = -1.0_f64/0.0_f64;\n \n /// Various useful constants.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"naming scheme needs to be revisited\")]\n pub mod consts {\n     // FIXME: replace with mathematical constants from cmath.\n@@ -125,7 +125,7 @@ pub mod consts {\n     pub const LN_10: f64 = 2.30258509299404568401799145468436421_f64;\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is unstable\")]\n+#[unstable(feature = \"core\", reason = \"trait is unstable\")]\n impl Float for f64 {\n     #[inline]\n     fn nan() -> f64 { NAN }"}, {"sha": "899f08fb62230364fe37d13a142c07d247a6f191", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -14,11 +14,11 @@ macro_rules! int_module { ($T:ty, $bits:expr) => (\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub const BITS : uint = $bits;\n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub const BYTES : uint = ($bits / 8);\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of"}, {"sha": "5e4956dfccf11006b4c3c1c0302a9afe286a34ae", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -50,25 +50,25 @@ pub trait Int\n {\n     /// Returns the `0` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"unsure about its place in the world\")]\n     fn zero() -> Self;\n \n     /// Returns the `1` value of this integer type.\n     // FIXME (#5527): Should be an associated constant\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"unsure about its place in the world\")]\n     fn one() -> Self;\n \n     /// Returns the smallest value that can be represented by this integer type.\n     // FIXME (#5527): Should be and associated constant\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"unsure about its place in the world\")]\n     fn min_value() -> Self;\n \n     /// Returns the largest value that can be represented by this integer type.\n     // FIXME (#5527): Should be and associated constant\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"unsure about its place in the world\")]\n     fn max_value() -> Self;\n \n@@ -83,7 +83,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.count_ones(), 3);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     fn count_ones(self) -> uint;\n \n@@ -98,7 +98,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.count_zeros(), 5);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n     fn count_zeros(self) -> uint {\n@@ -117,7 +117,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.leading_zeros(), 10);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     fn leading_zeros(self) -> uint;\n \n@@ -133,7 +133,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.trailing_zeros(), 3);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     fn trailing_zeros(self) -> uint;\n \n@@ -150,7 +150,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.rotate_left(12), m);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     fn rotate_left(self, n: uint) -> Self;\n \n@@ -167,7 +167,7 @@ pub trait Int\n     ///\n     /// assert_eq!(n.rotate_right(12), m);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     fn rotate_right(self, n: uint) -> Self;\n \n@@ -368,7 +368,7 @@ pub trait Int\n     ///\n     /// assert_eq!(2i.pow(4), 16);\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n     #[inline]\n     fn pow(self, mut exp: uint) -> Self {\n@@ -632,7 +632,7 @@ pub trait SignedInt\n {\n     /// Computes the absolute value of `self`. `Int::min_value()` will be\n     /// returned if the number is `Int::min_value()`.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"overflow in debug builds?\")]\n+    #[unstable(feature = \"core\", reason = \"overflow in debug builds?\")]\n     fn abs(self) -> Self;\n \n     /// Returns a number representing sign of `self`.\n@@ -737,7 +737,7 @@ impl UnsignedInt for u32 {}\n impl UnsignedInt for u64 {}\n \n /// A generic trait for converting a value to a number.\n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait ToPrimitive {\n     /// Converts the value of `self` to an `int`.\n     #[inline]\n@@ -1002,7 +1002,7 @@ impl_to_primitive_float! { f32 }\n impl_to_primitive_float! { f64 }\n \n /// A generic trait for converting a number to a value.\n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait FromPrimitive : ::marker::Sized {\n     /// Convert an `int` to return an optional value of this type. If the\n     /// value cannot be represented by this value, the `None` is returned.\n@@ -1084,73 +1084,73 @@ pub trait FromPrimitive : ::marker::Sized {\n }\n \n /// A utility function that just calls `FromPrimitive::from_int`.\n-#[unstable(feature = \"unnamed_feature\", reason = \"likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_int<A: FromPrimitive>(n: int) -> Option<A> {\n     FromPrimitive::from_int(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i8`.\n-#[unstable(feature = \"unnamed_feature\", reason = \"likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_i8<A: FromPrimitive>(n: i8) -> Option<A> {\n     FromPrimitive::from_i8(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i16`.\n-#[unstable(feature = \"unnamed_feature\", reason = \"likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_i16<A: FromPrimitive>(n: i16) -> Option<A> {\n     FromPrimitive::from_i16(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i32`.\n-#[unstable(feature = \"unnamed_feature\", reason = \"likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_i32<A: FromPrimitive>(n: i32) -> Option<A> {\n     FromPrimitive::from_i32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_i64`.\n-#[unstable(feature = \"unnamed_feature\", reason = \"likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_i64<A: FromPrimitive>(n: i64) -> Option<A> {\n     FromPrimitive::from_i64(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_uint`.\n-#[unstable(feature = \"unnamed_feature\", reason = \"likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_uint<A: FromPrimitive>(n: uint) -> Option<A> {\n     FromPrimitive::from_uint(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u8`.\n-#[unstable(feature = \"unnamed_feature\", reason = \"likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_u8<A: FromPrimitive>(n: u8) -> Option<A> {\n     FromPrimitive::from_u8(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u16`.\n-#[unstable(feature = \"unnamed_feature\", reason = \"likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_u16<A: FromPrimitive>(n: u16) -> Option<A> {\n     FromPrimitive::from_u16(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u32`.\n-#[unstable(feature = \"unnamed_feature\", reason = \"likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_u32<A: FromPrimitive>(n: u32) -> Option<A> {\n     FromPrimitive::from_u32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_u64`.\n-#[unstable(feature = \"unnamed_feature\", reason = \"likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_u64<A: FromPrimitive>(n: u64) -> Option<A> {\n     FromPrimitive::from_u64(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_f32`.\n-#[unstable(feature = \"unnamed_feature\", reason = \"likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_f32<A: FromPrimitive>(n: f32) -> Option<A> {\n     FromPrimitive::from_f32(n)\n }\n \n /// A utility function that just calls `FromPrimitive::from_f64`.\n-#[unstable(feature = \"unnamed_feature\", reason = \"likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n     FromPrimitive::from_f64(n)\n }\n@@ -1201,13 +1201,13 @@ impl_from_primitive! { f64, to_f64 }\n /// ```\n ///\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"likely to be removed\")]\n pub fn cast<T: NumCast,U: NumCast>(n: T) -> Option<U> {\n     NumCast::from(n)\n }\n \n /// An interface for casting between machine scalars.\n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is likely to be removed\")]\n+#[unstable(feature = \"core\", reason = \"trait is likely to be removed\")]\n pub trait NumCast: ToPrimitive {\n     /// Creates a number from another value that can be converted into a primitive via the\n     /// `ToPrimitive` trait.\n@@ -1242,7 +1242,7 @@ impl_num_cast! { f64,   to_f64 }\n \n /// Used for representing the classification of floating point numbers\n #[derive(Copy, PartialEq, Show)]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be renamed\")]\n+#[unstable(feature = \"core\", reason = \"may be renamed\")]\n pub enum FpCategory {\n     /// \"Not a Number\", often obtained by dividing by zero\n     Nan,\n@@ -1262,7 +1262,7 @@ pub enum FpCategory {\n //\n // FIXME(#8888): Several of these functions have a parameter named\n //               `unused_self`. Removing it requires #8888 to be fixed.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"distribution of methods between core/std is unclear\")]\n pub trait Float\n     : Copy + Clone\n@@ -1418,20 +1418,20 @@ pub trait Float\n }\n \n /// A generic trait for converting a string with a radix (base) to a value\n-#[unstable(feature = \"unnamed_feature\", reason = \"might need to return Result\")]\n+#[unstable(feature = \"core\", reason = \"might need to return Result\")]\n pub trait FromStrRadix {\n     fn from_str_radix(str: &str, radix: uint) -> Option<Self>;\n }\n \n /// A utility function that just calls FromStrRadix::from_str_radix.\n-#[unstable(feature = \"unnamed_feature\", reason = \"might need to return Result\")]\n+#[unstable(feature = \"core\", reason = \"might need to return Result\")]\n pub fn from_str_radix<T: FromStrRadix>(str: &str, radix: uint) -> Option<T> {\n     FromStrRadix::from_str_radix(str, radix)\n }\n \n macro_rules! from_str_radix_float_impl {\n     ($T:ty) => {\n-        #[unstable(feature = \"unnamed_feature\",\n+        #[unstable(feature = \"core\",\n                    reason = \"might need to return Result\")]\n         impl FromStr for $T {\n             /// Convert a string in base 10 to a float.\n@@ -1465,7 +1465,7 @@ macro_rules! from_str_radix_float_impl {\n             }\n         }\n \n-        #[unstable(feature = \"unnamed_feature\",\n+        #[unstable(feature = \"core\",\n                    reason = \"might need to return Result\")]\n         impl FromStrRadix for $T {\n             /// Convert a string in a given base to a float.\n@@ -1630,7 +1630,7 @@ from_str_radix_float_impl! { f64 }\n \n macro_rules! from_str_radix_int_impl {\n     ($T:ty) => {\n-        #[unstable(feature = \"unnamed_feature\",\n+        #[unstable(feature = \"core\",\n                    reason = \"might need to return Result\")]\n         impl FromStr for $T {\n             #[inline]\n@@ -1639,7 +1639,7 @@ macro_rules! from_str_radix_int_impl {\n             }\n         }\n \n-        #[unstable(feature = \"unnamed_feature\",\n+        #[unstable(feature = \"core\",\n                    reason = \"might need to return Result\")]\n         impl FromStrRadix for $T {\n             fn from_str_radix(src: &str, radix: uint) -> Option<$T> {"}, {"sha": "c18333892d933cdda1e154f336817d0c94f7de20", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -12,9 +12,9 @@\n \n macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => (\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub const BITS : uint = $bits;\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub const BYTES : uint = ($bits / 8);\n \n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]"}, {"sha": "1ba4f62939013428e233b70d3225d60ff8bae093", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -108,7 +108,7 @@ pub trait Drop {\n // based on \"op T\" where T is expected to be `Copy`able\n macro_rules! forward_ref_unop {\n     (impl $imp:ident, $method:ident for $t:ty) => {\n-        #[unstable(feature = \"unnamed_feature\",\n+        #[unstable(feature = \"core\",\n                    reason = \"recently added, waiting for dust to settle\")]\n         impl<'a> $imp for &'a $t {\n             type Output = <$t as $imp>::Output;\n@@ -125,7 +125,7 @@ macro_rules! forward_ref_unop {\n // based on \"T op U\" where T and U are expected to be `Copy`able\n macro_rules! forward_ref_binop {\n     (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n-        #[unstable(feature = \"unnamed_feature\",\n+        #[unstable(feature = \"core\",\n                    reason = \"recently added, waiting for dust to settle\")]\n         impl<'a> $imp<$u> for &'a $t {\n             type Output = <$t as $imp<$u>>::Output;\n@@ -136,7 +136,7 @@ macro_rules! forward_ref_binop {\n             }\n         }\n \n-        #[unstable(feature = \"unnamed_feature\",\n+        #[unstable(feature = \"core\",\n                    reason = \"recently added, waiting for dust to settle\")]\n         impl<'a> $imp<&'a $u> for $t {\n             type Output = <$t as $imp<$u>>::Output;\n@@ -147,7 +147,7 @@ macro_rules! forward_ref_binop {\n             }\n         }\n \n-        #[unstable(feature = \"unnamed_feature\",\n+        #[unstable(feature = \"core\",\n                    reason = \"recently added, waiting for dust to settle\")]\n         impl<'a, 'b> $imp<&'a $u> for &'b $t {\n             type Output = <$t as $imp<$u>>::Output;\n@@ -974,10 +974,10 @@ pub trait IndexMut<Index: ?Sized> {\n /// An unbounded range.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"full_range\"]\n-#[unstable(feature = \"unnamed_feature\", reason = \"API still in development\")]\n+#[unstable(feature = \"core\", reason = \"API still in development\")]\n pub struct FullRange;\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"API still in development\")]\n+#[unstable(feature = \"core\", reason = \"API still in development\")]\n impl fmt::Show for FullRange {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Show::fmt(\"..\", fmt)\n@@ -987,15 +987,15 @@ impl fmt::Show for FullRange {\n /// A (half-open) range which is bounded at both ends.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range\"]\n-#[unstable(feature = \"unnamed_feature\", reason = \"API still in development\")]\n+#[unstable(feature = \"core\", reason = \"API still in development\")]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"API still in development\")]\n+#[unstable(feature = \"core\", reason = \"API still in development\")]\n impl<Idx: Clone + Step> Iterator for Range<Idx> {\n     type Item = Idx;\n \n@@ -1020,7 +1020,7 @@ impl<Idx: Clone + Step> Iterator for Range<Idx> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"API still in development\")]\n+#[unstable(feature = \"core\", reason = \"API still in development\")]\n impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n     #[inline]\n     fn next_back(&mut self) -> Option<Idx> {\n@@ -1033,10 +1033,10 @@ impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"API still in development\")]\n+#[unstable(feature = \"core\", reason = \"API still in development\")]\n impl<Idx: Clone + Step> ExactSizeIterator for Range<Idx> {}\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"API still in development\")]\n+#[unstable(feature = \"core\", reason = \"API still in development\")]\n impl<Idx: fmt::Show> fmt::Show for Range<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..{:?}\", self.start, self.end)\n@@ -1046,13 +1046,13 @@ impl<Idx: fmt::Show> fmt::Show for Range<Idx> {\n /// A range which is only bounded below.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_from\"]\n-#[unstable(feature = \"unnamed_feature\", reason = \"API still in development\")]\n+#[unstable(feature = \"core\", reason = \"API still in development\")]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"API still in development\")]\n+#[unstable(feature = \"core\", reason = \"API still in development\")]\n impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n     type Item = Idx;\n \n@@ -1065,7 +1065,7 @@ impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"API still in development\")]\n+#[unstable(feature = \"core\", reason = \"API still in development\")]\n impl<Idx: fmt::Show> fmt::Show for RangeFrom<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..\", self.start)\n@@ -1075,13 +1075,13 @@ impl<Idx: fmt::Show> fmt::Show for RangeFrom<Idx> {\n /// A range which is only bounded above.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_to\"]\n-#[unstable(feature = \"unnamed_feature\", reason = \"API still in development\")]\n+#[unstable(feature = \"core\", reason = \"API still in development\")]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"API still in development\")]\n+#[unstable(feature = \"core\", reason = \"API still in development\")]\n impl<Idx: fmt::Show> fmt::Show for RangeTo<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"..{:?}\", self.end)\n@@ -1196,7 +1196,7 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n \n /// A version of the call operator that takes an immutable receiver.\n #[lang=\"fn\"]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n pub trait Fn<Args,Result> {\n     /// This is called when the call operator is used.\n@@ -1205,7 +1205,7 @@ pub trait Fn<Args,Result> {\n \n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n pub trait FnMut<Args,Result> {\n     /// This is called when the call operator is used.\n@@ -1214,7 +1214,7 @@ pub trait FnMut<Args,Result> {\n \n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"uncertain about variadic generics, input versus associated types\")]\n pub trait FnOnce<Args,Result> {\n     /// This is called when the call operator is used."}, {"sha": "8e27c039aa2a179a410b8f6e93fa329f0b036d07", "filename": "src/libcore/option.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -285,7 +285,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x, Some(\"Dirt\"));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"waiting for mut conventions\")]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n         match *self {\n@@ -477,7 +477,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.ok_or(0i), Err(0i));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"core\")]\n     pub fn ok_or<E>(self, err: E) -> Result<T, E> {\n         match self {\n             Some(v) => Ok(v),\n@@ -498,7 +498,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.ok_or_else(|| 0i), Err(0i));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"core\")]\n     pub fn ok_or_else<E, F: FnOnce() -> E>(self, err: F) -> Result<T, E> {\n         match self {\n             Some(v) => Ok(v),\n@@ -543,7 +543,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.iter_mut().next(), None);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"waiting for iterator conventions\")]\n     pub fn iter_mut(&mut self) -> IterMut<T> {\n         IterMut { inner: Item { opt: self.as_mut() } }\n@@ -704,7 +704,7 @@ impl<T> Option<T> {\n impl<'a, T: Clone, D: Deref<Target=T>> Option<D> {\n     /// Maps an Option<D> to an Option<T> by dereffing and cloning the contents of the Option.\n     /// Useful for converting an Option<&T> to an Option<T>.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"recently added as part of collections reform\")]\n     pub fn cloned(self) -> Option<T> {\n         self.map(|t| t.deref().clone())\n@@ -748,7 +748,7 @@ impl<T: Default> Option<T> {\n // Trait implementations\n /////////////////////////////////////////////////////////////////////////////\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"waiting on the stability of the trait itself\")]\n impl<T> AsSlice<T> for Option<T> {\n     /// Convert from `Option<T>` to `&[T]` (without copying)"}, {"sha": "9b6d5bfc71f0c531b3256d3119ebd14ad5f3a94e", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -99,13 +99,13 @@ use cmp::Ordering::{self, Less, Equal, Greater};\n \n // FIXME #19649: intrinsic docs don't render, so these have no docs :(\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub use intrinsics::copy_nonoverlapping_memory;\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub use intrinsics::copy_memory;\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"uncertain about naming and semantics\")]\n pub use intrinsics::set_memory;\n \n@@ -146,7 +146,7 @@ pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n /// Beyond accepting a raw pointer, this is unsafe because it will not drop the\n /// contents of `dst`, and may be used to create invalid instances of `T`.\n #[inline]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"may play a larger role in std::ptr future extensions\")]\n pub unsafe fn zero_memory<T>(dst: *mut T, count: uint) {\n     set_memory(dst, 0, count);\n@@ -215,7 +215,7 @@ pub unsafe fn read<T>(src: *const T) -> T {\n ///\n /// This is unsafe for the same reasons that `read` is unsafe.\n #[inline(always)]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"may play a larger role in std::ptr future extensions\")]\n pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     // Copy the data out from `dest`:\n@@ -262,7 +262,7 @@ pub trait PtrExt: Sized {\n     /// null-safety, it is important to note that this is still an unsafe\n     /// operation because the returned value could be pointing to invalid\n     /// memory.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"Option is not clearly the right return type, and we may want \\\n                          to tie the return lifetime to a borrow of the raw pointer\")]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a Self::Target>;\n@@ -291,7 +291,7 @@ pub trait MutPtrExt {\n     ///\n     /// As with `as_ref`, this is unsafe because it cannot verify the validity\n     /// of the returned pointer.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"Option is not clearly the right return type, and we may want \\\n                          to tie the return lifetime to a borrow of the raw pointer\")]\n     unsafe fn as_mut<'a>(&self) -> Option<&'a mut Self::Target>;\n@@ -312,7 +312,7 @@ impl<T> PtrExt for *const T {\n     }\n \n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"return value does not necessarily convey all possible \\\n                          information\")]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n@@ -339,7 +339,7 @@ impl<T> PtrExt for *mut T {\n     }\n \n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"return value does not necessarily convey all possible \\\n                          information\")]\n     unsafe fn as_ref<'a>(&self) -> Option<&'a T> {\n@@ -356,7 +356,7 @@ impl<T> MutPtrExt for *mut T {\n     type Target = T;\n \n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"return value does not necessarily convey all possible \\\n                          information\")]\n     unsafe fn as_mut<'a>(&self) -> Option<&'a mut T> {\n@@ -521,33 +521,33 @@ impl<T> PartialOrd for *mut T {\n /// raw `*mut T` (which conveys no particular ownership semantics).\n /// Useful for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n-#[unstable(feature = \"unnamed_feature\", reason = \"recently added to this module\")]\n+#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n pub struct Unique<T>(pub *mut T);\n \n /// `Unique` pointers are `Send` if `T` is `Send` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n-#[unstable(feature = \"unnamed_feature\", reason = \"recently added to this module\")]\n+#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n unsafe impl<T:Send> Send for Unique<T> { }\n \n /// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n-#[unstable(feature = \"unnamed_feature\", reason = \"recently added to this module\")]\n+#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n unsafe impl<T:Sync> Sync for Unique<T> { }\n \n impl<T> Unique<T> {\n     /// Returns a null Unique.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"recently added to this module\")]\n     pub fn null() -> Unique<T> {\n         Unique(null_mut())\n     }\n \n     /// Return an (unsafe) pointer into the memory owned by `self`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"recently added to this module\")]\n     pub unsafe fn offset(self, offset: int) -> *mut T {\n         self.0.offset(offset)"}, {"sha": "3fd244b46e30f4d27d897c29accbb7c7ddc53a77", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(missing_docs)]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"core\")]\n \n //! Contains struct definitions for the layout of compiler built-in types.\n //!"}, {"sha": "2965cf71c18ea01615544d0e5b78c64566c2e8d7", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -417,7 +417,7 @@ impl<T, E> Result<T, E> {\n     /// assert!(x.as_mut_slice().is_empty());\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"core\",\n                reason = \"waiting for mut conventions\")]\n     pub fn as_mut_slice(&mut self) -> &mut [T] {\n         match *self {\n@@ -950,7 +950,7 @@ impl<A, E, V: FromIterator<A>> FromIterator<Result<A, E>> for Result<V, E> {\n /// If an `Err` is encountered, it is immediately returned.\n /// Otherwise, the folded value is returned.\n #[inline]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub fn fold<T,\n             V,\n             E,"}, {"sha": "4a1c123668f27171b9907711bd3469cd8c75949c", "filename": "src/libcore/simd.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsimd.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -36,7 +36,7 @@\n #![allow(non_camel_case_types)]\n #![allow(missing_docs)]\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n@@ -45,26 +45,26 @@ pub struct i8x16(pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8,\n                  pub i8, pub i8, pub i8, pub i8);\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i16x8(pub i16, pub i16, pub i16, pub i16,\n                  pub i16, pub i16, pub i16, pub i16);\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i32x4(pub i32, pub i32, pub i32, pub i32);\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct i64x2(pub i64, pub i64);\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n@@ -73,32 +73,32 @@ pub struct u8x16(pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8,\n                  pub u8, pub u8, pub u8, pub u8);\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u16x8(pub u16, pub u16, pub u16, pub u16,\n                  pub u16, pub u16, pub u16, pub u16);\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u32x4(pub u32, pub u32, pub u32, pub u32);\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct u64x2(pub u64, pub u64);\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]\n pub struct f32x4(pub f32, pub f32, pub f32, pub f32);\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n #[simd]\n #[derive(Copy, Show)]\n #[repr(C)]"}, {"sha": "7095fa319d08405a7611d8e95812102150221fec", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -131,7 +131,7 @@ pub trait SliceExt {\n     fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n@@ -258,7 +258,7 @@ impl<T> SliceExt for [T] {\n         self.repr().data\n     }\n \n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"core\")]\n     fn binary_search_by<F>(&self, mut f: F) -> Result<uint, uint> where\n         F: FnMut(&T) -> Ordering\n     {\n@@ -452,12 +452,12 @@ impl<T> SliceExt for [T] {\n         m >= n && needle == &self[(m-n)..]\n     }\n \n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"core\")]\n     fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"core\")]\n     fn next_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n@@ -488,7 +488,7 @@ impl<T> SliceExt for [T] {\n         true\n     }\n \n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"core\")]\n     fn prev_permutation(&mut self) -> bool where T: Ord {\n         // These cases only have 1 permutation each, so we can't do anything.\n         if self.len() < 2 { return false; }\n@@ -630,26 +630,26 @@ impl<T> ops::IndexMut<ops::FullRange> for [T] {\n ////////////////////////////////////////////////////////////////////////////////\n \n /// Data that is viewable as a slice.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"will be replaced by slice syntax\")]\n pub trait AsSlice<T> {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<T> AsSlice<T> for [T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { self }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T, U: ?Sized + AsSlice<T>> AsSlice<T> for &'a mut U {\n     #[inline(always)]\n     fn as_slice(&self) -> &[T] { AsSlice::as_slice(*self) }\n@@ -755,7 +755,7 @@ pub struct Iter<'a, T: 'a> {\n     marker: marker::ContravariantLifetime<'a>\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -764,7 +764,7 @@ impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -773,7 +773,7 @@ impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -782,7 +782,7 @@ impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::FullRange> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -796,7 +796,7 @@ impl<'a, T> Iter<'a, T> {\n     ///\n     /// This has the same lifetime as the original slice, and so the\n     /// iterator can continue to be used while this exists.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"core\")]\n     pub fn as_slice(&self) -> &'a [T] {\n         make_slice!(T => &'a [T]: self.ptr, self.end)\n     }\n@@ -814,7 +814,7 @@ impl<'a, T> Clone for Iter<'a, T> {\n     fn clone(&self) -> Iter<'a, T> { *self }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -848,31 +848,31 @@ pub struct IterMut<'a, T: 'a> {\n }\n \n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::Range<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeTo<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::RangeFrom<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.index(&ops::FullRange).index(index)\n     }\n }\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::Index<ops::FullRange> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -881,31 +881,31 @@ impl<'a, T> ops::Index<ops::FullRange> for IterMut<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::Range<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeTo<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::RangeFrom<uint>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         self.index_mut(&ops::FullRange).index_mut(index)\n     }\n }\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n impl<'a, T> ops::IndexMut<ops::FullRange> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n@@ -922,7 +922,7 @@ impl<'a, T> IterMut<'a, T> {\n     /// to consume the iterator. Consider using the `Slice` and\n     /// `SliceMut` implementations for obtaining slices with more\n     /// restricted lifetimes that do not consume the iterator.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"core\")]\n     pub fn into_slice(self) -> &'a mut [T] {\n         make_slice!(T => &'a mut [T]: self.ptr, self.end)\n     }\n@@ -1270,7 +1270,7 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"trait is experimental\")]\n+#[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n@@ -1354,15 +1354,15 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n //\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub fn ref_slice<'a, A>(s: &'a A) -> &'a [A] {\n     unsafe {\n         transmute(RawSlice { data: s, len: 1 })\n     }\n }\n \n /// Converts a pointer to A into a slice of length 1 (without copying).\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n     unsafe {\n         let ptr: *const A = transmute(s);\n@@ -1396,7 +1396,7 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n /// }\n /// ```\n #[inline]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"should be renamed to from_raw_parts\")]\n pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n     transmute(RawSlice { data: *p, len: len })\n@@ -1409,7 +1409,7 @@ pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n /// not being able to provide a non-aliasing guarantee of the returned mutable\n /// slice.\n #[inline]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"should be renamed to from_raw_parts_mut\")]\n pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n     transmute(RawSlice { data: *p, len: len })\n@@ -1420,7 +1420,7 @@ pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n //\n \n /// Operations on `[u8]`.\n-#[unstable(feature = \"unnamed_feature\", reason = \"needs review\")]\n+#[unstable(feature = \"core\", reason = \"needs review\")]\n pub mod bytes {\n     use ptr;\n     use slice::SliceExt;\n@@ -1508,7 +1508,7 @@ impl<T: PartialOrd> PartialOrd for [T] {\n }\n \n /// Extension methods for slices containing integers.\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"core\")]\n pub trait IntSliceExt<U, S> {\n     /// Converts the slice to an immutable slice of unsigned integers with the same width.\n     fn as_unsigned<'a>(&'a self) -> &'a [U];\n@@ -1523,7 +1523,7 @@ pub trait IntSliceExt<U, S> {\n \n macro_rules! impl_int_slice {\n     ($u:ty, $s:ty, $t:ty) => {\n-        #[unstable(feature = \"unnamed_feature\")]\n+        #[unstable(feature = \"core\")]\n         impl IntSliceExt<$u, $s> for [$t] {\n             #[inline]\n             fn as_unsigned(&self) -> &[$u] { unsafe { transmute(self) } }"}, {"sha": "8daf71edb33758cd93c6da7673847e2a2d756b2c", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -108,7 +108,7 @@ macro_rules! delegate_iter {\n /// A trait to abstract the idea of creating a new instance of a type from a\n /// string.\n // FIXME(#17307): there should be an `E` associated type for a `Result` return\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"will return a Result once associated types are working\")]\n pub trait FromStr {\n     /// Parses a string `s` to return an optional value of this type. If the\n@@ -144,7 +144,7 @@ Section: Creating a string\n \n /// Errors which can occur when attempting to interpret a byte slice as a `str`.\n #[derive(Copy, Eq, PartialEq, Clone, Show)]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"error enumeration recently added and definitions may be refined\")]\n pub enum Utf8Error {\n     /// An invalid byte was detected at the byte offset given.\n@@ -208,7 +208,7 @@ pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n }\n \n /// Something that can be used to compare against a character\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"definition may change as pattern-related methods are stabilized\")]\n pub trait CharEq {\n     /// Determine if the splitter should split at the given character\n@@ -861,7 +861,7 @@ impl Searcher {\n /// An iterator over the start and end indices of the matches of a\n /// substring within a larger string\n #[derive(Clone)]\n-#[unstable(feature = \"unnamed_feature\", reason = \"type may be removed\")]\n+#[unstable(feature = \"core\", reason = \"type may be removed\")]\n pub struct MatchIndices<'a> {\n     // constants\n     haystack: &'a str,\n@@ -872,7 +872,7 @@ pub struct MatchIndices<'a> {\n /// An iterator over the substrings of a string separated by a given\n /// search string\n #[derive(Clone)]\n-#[unstable(feature = \"unnamed_feature\", reason = \"type may be removed\")]\n+#[unstable(feature = \"core\", reason = \"type may be removed\")]\n pub struct SplitStr<'a> {\n     it: MatchIndices<'a>,\n     last_end: uint,\n@@ -1056,7 +1056,7 @@ static UTF8_CHAR_WIDTH: [u8; 256] = [\n /// the next `char` in a string.  This can be used as a data structure\n /// for iterating over the UTF-8 bytes of a string.\n #[derive(Copy)]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"naming is uncertain with container conventions\")]\n pub struct CharRange {\n     /// Current `char`\n@@ -1151,7 +1151,7 @@ mod traits {\n }\n \n /// Any string that can be represented as a slice\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"Instead of taking this bound generically, this trait will be \\\n                      replaced with one of slicing syntax, deref coercions, or \\\n                      a more generic conversion trait\")]\n@@ -1178,7 +1178,7 @@ delegate_iter!{pattern &'a str : Split<'a, P>}\n \n /// Return type of `StrExt::split_terminator`\n #[derive(Clone)]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"core\",\n            reason = \"might get removed in favour of a constructor method on Split\")]\n pub struct SplitTerminator<'a, P>(CharSplits<'a, P>);\n delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}"}, {"sha": "0d371dbe15375bd1c0d14c210939ee160f2d920c", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -11,7 +11,6 @@\n #![feature(unsafe_destructor, slicing_syntax)]\n #![feature(unboxed_closures)]\n #![feature(box_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n \n extern crate core;"}, {"sha": "5f3a68a9e344db215cf23204d157238f310eea1a", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -15,16 +15,18 @@\n //! [mz]: https://code.google.com/p/miniz/\n \n #![crate_name = \"flate\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![feature(unnamed_feature)]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n+#![feature(hash)]\n+#![feature(core)]\n+#![feature(libc)]\n \n #[cfg(test)] #[macro_use] extern crate log;\n "}, {"sha": "d76e4b2ed956aa232afd6f296a61578686c602db", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -15,7 +15,7 @@\n //! generated instead.\n \n #![crate_name = \"fmt_macros\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n@@ -27,7 +27,9 @@\n \n #![feature(slicing_syntax)]\n #![allow(unknown_features)] #![feature(int_uint)]\n-#![feature(unnamed_feature)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(unicode)]\n \n pub use self::Piece::*;\n pub use self::Position::*;"}, {"sha": "c7ccebb7ce8b6b0b2ecab3db2de254868b94dbe9", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -78,7 +78,7 @@\n //! ```\n \n #![crate_name = \"getopts\"]\n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"rustc_private\",\n             reason = \"use the crates.io `getopts` library instead\")]\n #![feature(staged_api)]\n #![staged_api]\n@@ -89,9 +89,10 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(slicing_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![deny(missing_docs)]\n+#![feature(collections)]\n+#![feature(core)]\n \n #[cfg(test)] #[macro_use] extern crate log;\n "}, {"sha": "23597af68bc06c5549ee091982560209565ae387", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -265,7 +265,7 @@\n //! * [DOT language](http://www.graphviz.org/doc/info/lang.html)\n \n #![crate_name = \"graphviz\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n@@ -274,8 +274,11 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n #![feature(slicing_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(path)]\n \n use self::LabelText::*;\n "}, {"sha": "c1de5a627be44595c67c097c4e8e604e0541c622", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -11,10 +11,10 @@\n #![crate_name = \"libc\"]\n #![crate_type = \"rlib\"]\n #![cfg_attr(not(feature = \"cargo-build\"),\n-            unstable(feature = \"unnamed_feature\"))]\n+            unstable(feature = \"libc\"))]\n #![cfg_attr(not(feature = \"cargo-build\"), feature(staged_api))]\n #![cfg_attr(not(feature = \"cargo-build\"), staged_api)]\n-#![cfg_attr(not(feature = \"cargo-build\"), feature(unnamed_feature))]\n+#![cfg_attr(not(feature = \"cargo-build\"), feature(core))]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![no_std]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -75,7 +75,6 @@\n //! one from Berkeley after the lawsuits died down and the CSRG dissolved.\n \n #![allow(bad_style, raw_pointer_derive)]\n-#![cfg_attr(not(feature = \"cargo-build\"), feature(unnamed_feature))]\n #[cfg(feature = \"cargo-build\")] extern crate \"std\" as core;\n #[cfg(not(feature = \"cargo-build\"))] extern crate core;\n "}, {"sha": "6fe789f3e31132c2d3fa118f39a9f5a215e26c11", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -156,7 +156,7 @@\n //! if logging is disabled, none of the components of the log will be executed.\n \n #![crate_name = \"log\"]\n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"rustc_private\",\n             reason = \"use the crates.io `log` library instead\")]\n #![feature(staged_api)]\n #![staged_api]\n@@ -170,9 +170,14 @@\n #![allow(unknown_features)]\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![deny(missing_docs)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(os)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n \n extern crate regex;\n "}, {"sha": "25c205b2bf2a8d1a02614e400b32ab1f488bbe0c", "filename": "src/librand/distributions/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Fmod.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -17,7 +17,7 @@\n //! internally. The `IndependentSample` trait is for generating values\n //! that do not need to record state.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rand\")]\n \n use core::prelude::*;\n use core::num::{Float, Int};"}, {"sha": "762581518505f675b349e5b2696773fa12890438", "filename": "src/librand/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -22,12 +22,12 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![no_std]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rand\")]\n #![feature(staged_api)]\n #![staged_api]\n+#![feature(core)]\n \n #[macro_use]\n extern crate core;"}, {"sha": "40a29b88b9970eba253220e5615ce78501ad7aec", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -16,7 +16,7 @@\n //!     http://www.matroska.org/technical/specs/rfc/index.html\n \n #![crate_name = \"rbml\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n@@ -27,8 +27,11 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n #![feature(slicing_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(rustc_private)]\n \n extern crate serialize;\n #[macro_use] extern crate log;"}, {"sha": "9631eb36056b334850b072f48e67a8683b65acc2", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -16,7 +16,7 @@\n #![crate_name = \"regex\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"rustc_private\",\n             reason = \"use the crates.io `regex` library instead\")]\n #![feature(staged_api)]\n #![staged_api]\n@@ -28,9 +28,11 @@\n #![allow(unknown_features)]\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![deny(missing_docs)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(unicode)]\n \n #[cfg(test)]\n extern crate \"test\" as stdtest;"}, {"sha": "8c9df74635a714d05b5ab19938b607c6d3d8e1a1", "filename": "src/libregex/re.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -255,7 +255,6 @@ impl Regex {\n     }\n \n     #[doc(hidden)]\n-    #[unstable(feature = \"unnamed_feature\")]\n     pub fn names_iter<'a>(&'a self) -> NamesIter<'a> {\n         match *self {\n             Native(ref n) => NamesIterNative(n.names.iter()),"}, {"sha": "a5ae9e9f40a35b7bea7daba011a1bda6cbab286d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -15,7 +15,7 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n@@ -28,9 +28,18 @@\n #![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(box_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(libc)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n+#![feature(hash)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "13dec65d13ea70c6f7e9e949acf0712e11c19707", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -22,7 +22,7 @@\n //! build speedups.\n \n #![crate_name = \"rustc_back\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n@@ -32,8 +32,14 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n #![allow(unknown_features)]\n #![feature(slicing_syntax, box_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(hash)]\n+#![feature(io)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "e0f5b5c387f9ab11829a2fbf7ef4c86561b20396", "filename": "src/librustc_bitflags/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_bitflags%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_bitflags%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_bitflags%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -14,7 +14,7 @@\n #![staged_api]\n #![crate_type = \"rlib\"]\n #![no_std]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n \n //! A typesafe bitmask flag generator.\n "}, {"sha": "0182c90df1c1d7f16661f27109cba70df1ea5fed", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_borrowck\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n@@ -22,9 +22,11 @@\n #![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![allow(non_camel_case_types)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(rustc_private)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "772d72e59b6b3195a7a38a943239964e42cb797f", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -15,7 +15,7 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc_driver\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n@@ -29,8 +29,16 @@\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(libc)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "18ed2987c1ce3f587b38daa4be16ed78bca3d105", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -14,7 +14,7 @@\n #![allow(dead_code)]\n \n #![crate_name = \"rustc_llvm\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n@@ -26,8 +26,12 @@\n #![allow(unknown_features)]\n #![feature(link_args)]\n #![feature(box_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(libc)]\n+#![feature(path)]\n+#![feature(std_misc)]\n \n extern crate libc;\n #[macro_use] #[no_link] extern crate rustc_bitflags;"}, {"sha": "83ace21721b6ccd63f8295e07dab34d40c892114", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_privacy\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n@@ -19,8 +19,10 @@\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n #![feature(rustc_diagnostic_macros)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(rustc_private)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "a2e72fa1c557f59365fe16d32b58f998342ae681", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_name = \"rustc_resolve\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n@@ -20,8 +20,12 @@\n \n #![feature(slicing_syntax)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(alloc)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "049cc0bd0daa7ae935992d8d05e50d7798dbf500", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -15,7 +15,7 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc_trans\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n@@ -29,8 +29,17 @@\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(alloc)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(libc)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n \n extern crate arena;\n extern crate flate;"}, {"sha": "ced77ebe8923c64ed021d713035494da4fc67076", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -64,7 +64,7 @@ This API is completely unstable and subject to change.\n */\n \n #![crate_name = \"rustc_typeck\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n@@ -78,9 +78,12 @@ This API is completely unstable and subject to change.\n #![feature(slicing_syntax, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(rustc_diagnostic_macros)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![allow(non_camel_case_types)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "1f5d153830283fa2b614a93b865ab200e770b1be", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![crate_name = \"rustdoc\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustdoc\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n@@ -20,8 +20,17 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(libc)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(test)]\n+#![feature(unicode)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "9dac8e09ad29e813d7fe3ba97318792aa3879f74", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -15,7 +15,7 @@ Core encoding and decoding interfaces.\n */\n \n #![crate_name = \"serialize\"]\n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"rustc_private\",\n             reason = \"deprecated in favor of rustc-serialize on crates.io\")]\n #![feature(staged_api)]\n #![staged_api]\n@@ -29,8 +29,14 @@ Core encoding and decoding interfaces.\n #![feature(box_syntax)]\n #![feature(old_impl_check)]\n #![feature(slicing_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n \n // test harness access\n #[cfg(test)] extern crate test;"}, {"sha": "9aa38e711e70f3501b1ccd49d5e736a20e46c13e", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -12,7 +12,7 @@\n \n //! Operations on ASCII strings and characters\n \n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"std_misc\",\n             reason = \"unsure about placement and naming\")]\n \n use iter::IteratorExt;\n@@ -23,7 +23,7 @@ use string::String;\n use vec::Vec;\n \n /// Extension methods for ASCII-subset only operations on owned strings\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"would prefer to do this in a more general way\")]\n pub trait OwnedAsciiExt {\n     /// Convert the string to ASCII upper case:\n@@ -38,7 +38,7 @@ pub trait OwnedAsciiExt {\n }\n \n /// Extension methods for ASCII-subset only operations on string slices\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"would prefer to do this in a more general way\")]\n pub trait AsciiExt<T = Self> {\n     /// Check if within the ASCII range.\n@@ -60,7 +60,7 @@ pub trait AsciiExt<T = Self> {\n     fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt<String> for str {\n     #[inline]\n@@ -86,7 +86,7 @@ impl AsciiExt<String> for str {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"would prefer to do this in a more general way\")]\n impl OwnedAsciiExt for String {\n     #[inline]\n@@ -102,7 +102,7 @@ impl OwnedAsciiExt for String {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt<Vec<u8>> for [u8] {\n     #[inline]\n@@ -129,7 +129,7 @@ impl AsciiExt<Vec<u8>> for [u8] {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"would prefer to do this in a more general way\")]\n impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n@@ -149,7 +149,7 @@ impl OwnedAsciiExt for Vec<u8> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt for u8 {\n     #[inline]\n@@ -173,7 +173,7 @@ impl AsciiExt for u8 {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"would prefer to do this in a more general way\")]\n impl AsciiExt for char {\n     #[inline]\n@@ -216,7 +216,7 @@ impl AsciiExt for char {\n /// - Any other chars in the range [0x20,0x7e] are not escaped.\n /// - Any other chars are given hex escapes.\n /// - Unicode escapes are never generated by this function.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"needs to be updated to use an iterator\")]\n pub fn escape_default<F>(c: u8, mut f: F) where\n     F: FnMut(u8),"}, {"sha": "0a0aaa9da870dd5be6c91bbc3b6ead4eaa5b0e8f", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -539,7 +539,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\", reason = \"hasher stuff is unclear\")]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n     pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> {\n         HashMap {\n             hash_state:    hash_state,\n@@ -567,7 +567,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\", reason = \"hasher stuff is unclear\")]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n     pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n                                         -> HashMap<K, V, S> {\n         let resize_policy = DefaultResizePolicy::new();\n@@ -928,7 +928,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     }\n \n     /// Gets the given key's corresponding entry in the map for in-place manipulation.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"precise API still being fleshed out\")]\n     pub fn entry<'a>(&'a mut self, key: K) -> Entry<'a, K, V>\n     {\n@@ -990,7 +990,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// assert!(a.is_empty());\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<K, V> {\n         fn last_two<A, B, C>((_, b, c): (A, B, C)) -> (B, C) { (b, c) }\n@@ -1339,7 +1339,7 @@ impl<'a, K, V> Clone for Values<'a, K, V> {\n }\n \n /// HashMap drain iterator\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"matches collection reform specification, waiting for dust to settle\")]\n pub struct Drain<'a, K: 'a, V: 'a> {\n     inner: iter::Map<\n@@ -1351,14 +1351,14 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single occupied location in a HashMap\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"precise API still being fleshed out\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n \n /// A view into a single empty location in a HashMap\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"precise API still being fleshed out\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n@@ -1367,7 +1367,7 @@ pub struct VacantEntry<'a, K: 'a, V: 'a> {\n }\n \n /// A view into a single location in a map, which may be vacant or occupied\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"precise API still being fleshed out\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied Entry\n@@ -1457,7 +1457,7 @@ impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n     #[inline] fn len(&self) -> usize { self.inner.len() }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K, V> Entry<'a, K, V> {\n     /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n@@ -1469,7 +1469,7 @@ impl<'a, K, V> Entry<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the value in the entry\n@@ -1501,7 +1501,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"matches collection reform v2 specification, waiting for dust to settle\")]\n impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// Sets the value of the entry with the VacantEntry's key,\n@@ -1554,14 +1554,14 @@ impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n /// instances are unlikely to produce the same result for the same values.\n #[derive(Clone)]\n #[allow(missing_copy_implementations)]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"hashing an hash maps may be altered\")]\n pub struct RandomState {\n     k0: u64,\n     k1: u64,\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"hashing an hash maps may be altered\")]\n impl RandomState {\n     /// Construct a new `RandomState` that is initialized with random keys.\n@@ -1572,7 +1572,7 @@ impl RandomState {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"hashing an hash maps may be altered\")]\n impl HashState for RandomState {\n     type Hasher = Hasher;\n@@ -1581,7 +1581,7 @@ impl HashState for RandomState {\n     }\n }\n \n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"hashing an hash maps may be altered\")]\n impl Default for RandomState {\n     #[inline]"}, {"sha": "98c67186a3c091992dea839621ae271b5661006b", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -147,7 +147,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.insert(2u);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\", reason = \"hasher stuff is unclear\")]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n     pub fn with_hash_state(hash_state: S) -> HashSet<T, S> {\n         HashSet::with_capacity_and_hash_state(INITIAL_CAPACITY, hash_state)\n     }\n@@ -171,7 +171,7 @@ impl<T, S, H> HashSet<T, S>\n     /// set.insert(1i);\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\", reason = \"hasher stuff is unclear\")]\n+    #[unstable(feature = \"std_misc\", reason = \"hasher stuff is unclear\")]\n     pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n                                         -> HashSet<T, S> {\n         HashSet {\n@@ -419,7 +419,7 @@ impl<T, S, H> HashSet<T, S>\n \n     /// Clears the set, returning all elements in an iterator.\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n     pub fn drain(&mut self) -> Drain<T> {\n         fn first<A, B>((a, _): (A, B)) -> A { a }"}, {"sha": "fae17af472c7136515d18b4d8cec3781ff275443", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -337,7 +337,7 @@ pub mod hash_set {\n \n /// Experimental support for providing custom hash algorithms to a HashMap and\n /// HashSet.\n-#[unstable(feature = \"unnamed_feature\", reason = \"module was recently added\")]\n+#[unstable(feature = \"std_misc\", reason = \"module was recently added\")]\n pub mod hash_state {\n     pub use super::hash::state::*;\n }"}, {"sha": "f35f63143ef8275cdeab063398d4da89c16e0adf", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -12,7 +12,7 @@\n //!\n //! A simple wrapper over the platform's dynamic library facilities\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n #![allow(missing_docs)]\n \n use prelude::v1::*;"}, {"sha": "df949ab03aaa3dad22b35a741aef248d1c9df719", "filename": "src/libstd/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -86,7 +86,7 @@ use str::Utf8Error;\n use string::{FromUtf8Error, FromUtf16Error};\n \n /// Base functionality for all errors in Rust.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"the exact API of this trait may change\")]\n pub trait Error {\n     /// A short description of the error; usually a static string."}, {"sha": "028973a1cf13a227e8ca250f7eeecf3f47c36726", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n \n use prelude::v1::*;\n "}, {"sha": "8c11a2584d3402ed6ec7df327214da61b8d230ee", "filename": "src/libstd/ffi/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fmod.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -10,7 +10,7 @@\n \n //! Utilities related to FFI bindings.\n \n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"std_misc\",\n             reason = \"module just underwent fairly large reorganization and the dust \\\n                       still needs to settle\")]\n "}, {"sha": "57b57bdfe95e4cc848accd8b3f0e3317da3d806c", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -403,7 +403,7 @@\n //! them with the same character. For example, the `{` character is escaped with\n //! `{{` and the `}` character is escaped with `}}`.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n \n use string;\n \n@@ -432,7 +432,7 @@ pub use core::fmt::{argument, argumentuint};\n /// let s = fmt::format(format_args!(\"Hello, {}!\", \"world\"));\n /// assert_eq!(s, \"Hello, world!\".to_string());\n /// ```\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"this is an implementation detail of format! and should not \\\n                      be called directly\")]\n pub fn format(args: Arguments) -> string::String {"}, {"sha": "dc3cfa7ead8aae77337ef9566416abe3e4764d34", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -219,7 +219,7 @@\n //! concerned with error handling; instead its caller is responsible for\n //! responding to errors that may occur while attempting to read the numbers.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"io\")]\n #![deny(unused_must_use)]\n \n pub use self::SeekStyle::*;\n@@ -1743,15 +1743,15 @@ pub struct FileStat {\n     ///\n     /// Usage of this field is discouraged, but if access is desired then the\n     /// fields are located here.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"io\")]\n     pub unstable: UnstableFileStat,\n }\n \n /// This structure represents all of the possible information which can be\n /// returned from a `stat` syscall which is not contained in the `FileStat`\n /// structure. This information is not necessarily platform independent, and may\n /// have different meanings or no meaning at all on some platforms.\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"io\")]\n #[derive(Copy, Hash)]\n pub struct UnstableFileStat {\n     /// The ID of the device containing the file."}, {"sha": "ac7e9ce5ddee05d3a4bee584a3772fc931fcf986", "filename": "src/libstd/io/net/pipe.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fpipe.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -68,7 +68,7 @@ impl UnixStream {\n     ///\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"io\",\n                reason = \"the timeout argument is likely to change types\")]\n     pub fn connect_timeout<P>(path: P, timeout: Duration)\n                               -> IoResult<UnixStream>\n@@ -108,7 +108,7 @@ impl UnixStream {\n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"io\",\n                reason = \"the timeout argument may change in type and value\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n@@ -117,7 +117,7 @@ impl UnixStream {\n     /// Sets the read timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"io\",\n                reason = \"the timeout argument may change in type and value\")]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_read_timeout(timeout_ms)\n@@ -126,7 +126,7 @@ impl UnixStream {\n     /// Sets the write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"io\",\n                reason = \"the timeout argument may change in type and value\")]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_write_timeout(timeout_ms)\n@@ -221,7 +221,7 @@ impl UnixAcceptor {\n     /// When using this method, it is likely necessary to reset the timeout as\n     /// appropriate, the timeout specified is specific to this object, not\n     /// specific to the next request.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"io\",\n                reason = \"the name and arguments to this function are likely \\\n                          to change\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n@@ -232,7 +232,7 @@ impl UnixAcceptor {\n     ///\n     /// This function has the same semantics as `TcpAcceptor::close_accept`, and\n     /// more information can be found in that documentation.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"io\")]\n     pub fn close_accept(&mut self) -> IoResult<()> {\n         self.inner.close_accept()\n     }"}, {"sha": "d5feb5977fbe8f7bc898be3bb6824965f5a755d5", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -85,7 +85,7 @@ impl TcpStream {\n     ///\n     /// If a `timeout` with zero or negative duration is specified then\n     /// the function returns `Err`, with the error kind set to `TimedOut`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"io\",\n                reason = \"the timeout argument may eventually change types\")]\n     pub fn connect_timeout<A: ToSocketAddr>(addr: A,\n                                             timeout: Duration) -> IoResult<TcpStream> {\n@@ -110,7 +110,7 @@ impl TcpStream {\n     }\n \n     /// Sets the nodelay flag on this connection to the boolean specified\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"io\")]\n     pub fn set_nodelay(&mut self, nodelay: bool) -> IoResult<()> {\n         self.inner.set_nodelay(nodelay)\n     }\n@@ -120,7 +120,7 @@ impl TcpStream {\n     /// If the value specified is `None`, then the keepalive flag is cleared on\n     /// this connection. Otherwise, the keepalive timeout will be set to the\n     /// specified time, in seconds.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"io\")]\n     pub fn set_keepalive(&mut self, delay_in_seconds: Option<uint>) -> IoResult<()> {\n         self.inner.set_keepalive(delay_in_seconds)\n     }\n@@ -188,7 +188,7 @@ impl TcpStream {\n     ///\n     /// For clarification on the semantics of interrupting a read and a write,\n     /// take a look at `set_read_timeout` and `set_write_timeout`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"io\",\n                reason = \"the timeout argument may change in type and value\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n@@ -206,7 +206,7 @@ impl TcpStream {\n     /// action is taken. Otherwise, the read operation will be scheduled to\n     /// promptly return. If a timeout error is returned, then no data was read\n     /// during the timeout period.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"io\",\n                reason = \"the timeout argument may change in type and value\")]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_read_timeout(timeout_ms)\n@@ -234,7 +234,7 @@ impl TcpStream {\n     /// does not know how many bytes were written as part of the timeout\n     /// operation. It may be the case that bytes continue to be written in an\n     /// asynchronous fashion after the call to write returns.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"io\",\n                reason = \"the timeout argument may change in type and value\")]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_write_timeout(timeout_ms)\n@@ -398,7 +398,7 @@ impl TcpAcceptor {\n     /// a.set_timeout(None);\n     /// let socket = a.accept();\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"io\",\n                reason = \"the type of the argument and name of this function are \\\n                          subject to change\")]\n     pub fn set_timeout(&mut self, ms: Option<u64>) { self.inner.set_timeout(ms); }\n@@ -445,7 +445,7 @@ impl TcpAcceptor {\n     /// // Signal our accept loop to exit\n     /// assert!(a.close_accept().is_ok());\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"io\")]\n     pub fn close_accept(&mut self) -> IoResult<()> {\n         self.inner.close_accept()\n     }"}, {"sha": "6e336168b16632a99ec324511491f9bc8359aeb0", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -92,47 +92,47 @@ impl UdpSocket {\n     }\n \n     /// Joins a multicast IP address (becomes a member of it)\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"io\")]\n     pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n         self.inner.join_multicast(multi)\n     }\n \n     /// Leaves a multicast IP address (drops membership from it)\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"io\")]\n     pub fn leave_multicast(&mut self, multi: IpAddr) -> IoResult<()> {\n         self.inner.leave_multicast(multi)\n     }\n \n     /// Set the multicast loop flag to the specified value\n     ///\n     /// This lets multicast packets loop back to local sockets (if enabled)\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"io\")]\n     pub fn set_multicast_loop(&mut self, on: bool) -> IoResult<()> {\n         self.inner.set_multicast_loop(on)\n     }\n \n     /// Sets the multicast TTL\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"io\")]\n     pub fn set_multicast_ttl(&mut self, ttl: int) -> IoResult<()> {\n         self.inner.multicast_time_to_live(ttl)\n     }\n \n     /// Sets this socket's TTL\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"io\")]\n     pub fn set_ttl(&mut self, ttl: int) -> IoResult<()> {\n         self.inner.time_to_live(ttl)\n     }\n \n     /// Sets the broadcast flag on or off\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"io\")]\n     pub fn set_broadcast(&mut self, broadcast: bool) -> IoResult<()> {\n         self.inner.set_broadcast(broadcast)\n     }\n \n     /// Sets the read/write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"io\",\n                reason = \"the timeout argument may change in type and value\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_timeout(timeout_ms)\n@@ -141,7 +141,7 @@ impl UdpSocket {\n     /// Sets the read timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"io\",\n                reason = \"the timeout argument may change in type and value\")]\n     pub fn set_read_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_read_timeout(timeout_ms)\n@@ -150,7 +150,7 @@ impl UdpSocket {\n     /// Sets the write timeout for this socket.\n     ///\n     /// For more information, see `TcpStream::set_timeout`\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"io\",\n                reason = \"the timeout argument may change in type and value\")]\n     pub fn set_write_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.inner.set_write_timeout(timeout_ms)"}, {"sha": "6b09ac9a58ffec2c36b968c8eb7d10a9aba2bdad", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -689,7 +689,7 @@ impl Process {\n     ///     p.wait()\n     /// }\n     /// ```\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"io\",\n                reason = \"the type of the timeout is likely to change\")]\n     pub fn set_timeout(&mut self, timeout_ms: Option<u64>) {\n         self.deadline = timeout_ms.map(|i| i + sys::timer::now()).unwrap_or(0);"}, {"sha": "025552e60947bfacecee6373083c82f0a1d2d435", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -114,7 +114,13 @@\n #![feature(optin_builtin_traits)]\n #![feature(int_uint)]\n #![feature(int_uint)]\n-#![feature(unnamed_feature)]\n+#![feature(core)]\n+#![feature(libc)]\n+#![feature(alloc)]\n+#![feature(unicode)]\n+#![feature(collections)]\n+#![feature(rand)]\n+#![feature(hash)]\n \n // Don't link to std. We are std.\n #![no_std]"}, {"sha": "7c9ee95bc2046c3090cd5e448b4f4ba4a3ec1763", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -14,7 +14,7 @@\n //! library. Each macro is available for use when linking against the standard\n //! library.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n \n /// The entry point for panic of Rust tasks.\n ///\n@@ -148,7 +148,7 @@ macro_rules! try {\n ///\n /// For more information about select, see the `std::sync::mpsc::Select` structure.\n #[macro_export]\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"std_misc\")]\n macro_rules! select {\n     (\n         $($name:pat = $rx:ident.$meth:ident() => $code:expr),+"}, {"sha": "5413f3a900fbf6d61ca9a814d1e6ebf8d2f00c6b", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -366,7 +366,7 @@ impl Float for f32 {\n ///\n /// * num - The float value\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_string(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigAll, ExpNone, false);\n@@ -379,7 +379,7 @@ pub fn to_string(num: f32) -> String {\n ///\n /// * num - The float value\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_hex(num: f32) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, SignNeg, DigAll, ExpNone, false);\n@@ -394,7 +394,7 @@ pub fn to_str_hex(num: f32) -> String {\n /// * num - The float value\n /// * radix - The base to use\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n@@ -407,7 +407,7 @@ pub fn to_str_radix_special(num: f32, rdx: uint) -> (String, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exact(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n@@ -422,7 +422,7 @@ pub fn to_str_exact(num: f32, dig: uint) -> String {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_digits(num: f32, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n@@ -438,7 +438,7 @@ pub fn to_str_digits(num: f32, dig: uint) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n@@ -454,7 +454,7 @@ pub fn to_str_exp_exact(num: f32, dig: uint, upper: bool) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);"}, {"sha": "1fd4f056a2dc4d90391de7c4ceba3aad9a2cab6b", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -375,7 +375,7 @@ impl Float for f64 {\n ///\n /// * num - The float value\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_string(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigAll, ExpNone, false);\n@@ -388,7 +388,7 @@ pub fn to_string(num: f64) -> String {\n ///\n /// * num - The float value\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_hex(num: f64) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 16u, true, SignNeg, DigAll, ExpNone, false);\n@@ -403,7 +403,7 @@ pub fn to_str_hex(num: f64) -> String {\n /// * num - The float value\n /// * radix - The base to use\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n     strconv::float_to_str_common(num, rdx, true, SignNeg, DigAll, ExpNone, false)\n }\n@@ -416,7 +416,7 @@ pub fn to_str_radix_special(num: f64, rdx: uint) -> (String, bool) {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exact(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpNone, false);\n@@ -431,7 +431,7 @@ pub fn to_str_exact(num: f64, dig: uint) -> String {\n /// * num - The float value\n /// * digits - The number of significant digits\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_digits(num: f64, dig: uint) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpNone, false);\n@@ -447,7 +447,7 @@ pub fn to_str_digits(num: f64, dig: uint) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigExact(dig), ExpDec, upper);\n@@ -463,7 +463,7 @@ pub fn to_str_exp_exact(num: f64, dig: uint, upper: bool) -> String {\n /// * digits - The number of digits after the decimal point\n /// * upper - Use `E` instead of `e` for the exponent sign\n #[inline]\n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n     let (r, _) = strconv::float_to_str_common(\n         num, 10u, true, SignNeg, DigMax(dig), ExpDec, upper);"}, {"sha": "2b730cd6f9ad81e8755db53e25b420bbef9b1643", "filename": "src/libstd/num/float_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat_macros.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n #![doc(hidden)]\n \n macro_rules! assert_approx_eq {"}, {"sha": "af1976d5750932db4eb3d5187a2db2f778dfecc7", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n #![doc(hidden)]\n \n macro_rules! int_module { ($T:ty) => ("}, {"sha": "b73882c76c1ccd6661f489089b5d387d756f2d4c", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -33,7 +33,7 @@ pub use core::num::{FpCategory};\n \n use option::Option;\n \n-#[unstable(feature = \"unnamed_feature\", reason = \"may be removed or relocated\")]\n+#[unstable(feature = \"std_misc\", reason = \"may be removed or relocated\")]\n pub mod strconv;\n \n /// Mathematical operations on primitive floating point numbers.\n@@ -52,27 +52,27 @@ pub trait Float\n {\n     // inlined methods from `num::Float`\n     /// Returns the NaN value.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn nan() -> Self;\n     /// Returns the infinite value.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn infinity() -> Self;\n     /// Returns the negative infinite value.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn neg_infinity() -> Self;\n     /// Returns the `0` value.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn zero() -> Self;\n     /// Returns -0.0.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn neg_zero() -> Self;\n     /// Returns the `1` value.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn one() -> Self;\n \n@@ -109,37 +109,37 @@ pub trait Float\n     fn max_10_exp(unused_self: Option<Self>) -> int;\n \n     /// Returns the smallest finite value that this type can represent.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn min_value() -> Self;\n     /// Returns the smallest normalized positive number that this type can represent.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn min_pos_value(unused_self: Option<Self>) -> Self;\n     /// Returns the largest finite value that this type can represent.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn max_value() -> Self;\n \n     /// Returns true if this value is NaN and false otherwise.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"position is undecided\")]\n+    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n     fn is_nan(self) -> bool;\n     /// Returns true if this value is positive infinity or negative infinity and\n     /// false otherwise.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"position is undecided\")]\n+    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n     fn is_infinite(self) -> bool;\n     /// Returns true if this number is neither infinite nor NaN.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"position is undecided\")]\n+    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n     fn is_finite(self) -> bool;\n     /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"position is undecided\")]\n+    #[unstable(feature = \"std_misc\", reason = \"position is undecided\")]\n     fn is_normal(self) -> bool;\n     /// Returns the category that this number falls into.\n     #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn classify(self) -> FpCategory;\n \n     /// Returns the mantissa, exponent and sign as integers, respectively.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"signature is undecided\")]\n+    #[unstable(feature = \"std_misc\", reason = \"signature is undecided\")]\n     fn integer_decode(self) -> (u64, i16, i8);\n \n     /// Return the largest integer less than or equal to a number.\n@@ -182,11 +182,11 @@ pub trait Float\n     /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n     /// error. This produces a more accurate result with better performance than\n     /// a separate multiplication operation followed by an add.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn mul_add(self, a: Self, b: Self) -> Self;\n     /// Take the reciprocal (inverse) of a number, `1/x`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn recip(self) -> Self;\n \n@@ -205,7 +205,7 @@ pub trait Float\n     #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn sqrt(self) -> Self;\n     /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn rsqrt(self) -> Self;\n \n@@ -229,15 +229,15 @@ pub trait Float\n     fn log10(self) -> Self;\n \n     /// Convert radians to degrees.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"desirability is unclear\")]\n+    #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n     fn to_degrees(self) -> Self;\n     /// Convert degrees to radians.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"desirability is unclear\")]\n+    #[unstable(feature = \"std_misc\", reason = \"desirability is unclear\")]\n     fn to_radians(self) -> Self;\n \n     /// Constructs a floating point number created by multiplying `x` by 2\n     /// raised to the power of `exp`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n     fn ldexp(x: Self, exp: int) -> Self;\n     /// Breaks the number into a normalized fraction and a base-2 exponent,\n@@ -246,13 +246,13 @@ pub trait Float\n     ///  * `self = x * pow(2, exp)`\n     ///\n     ///  * `0.5 <= abs(x) < 1.0`\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"pending integer conventions\")]\n     fn frexp(self) -> (Self, int);\n \n     /// Returns the next representable floating-point value in the direction of\n     /// `other`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn next_after(self, other: Self) -> Self;\n \n@@ -266,15 +266,15 @@ pub trait Float\n     /// The positive difference of two numbers. Returns `0.0` if the number is\n     /// less than or equal to `other`, otherwise the difference between`self`\n     /// and `other` is returned.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"may be renamed\")]\n+    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n     fn abs_sub(self, other: Self) -> Self;\n \n     /// Take the cubic root of a number.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"may be renamed\")]\n+    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n     fn cbrt(self) -> Self;\n     /// Calculate the length of the hypotenuse of a right-angle triangle given\n     /// legs of length `x` and `y`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure about its place in the world\")]\n     fn hypot(self, other: Self) -> Self;\n \n@@ -313,11 +313,11 @@ pub trait Float\n \n     /// Returns the exponential of the number, minus 1, in a way that is\n     /// accurate even if the number is close to zero.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"may be renamed\")]\n+    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n     fn exp_m1(self) -> Self;\n     /// Returns the natural logarithm of the number plus 1 (`ln(1+n)`) more\n     /// accurately than if the operations were performed separately.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"may be renamed\")]\n+    #[unstable(feature = \"std_misc\", reason = \"may be renamed\")]\n     fn ln_1p(self) -> Self;\n \n     /// Hyperbolic sine function."}, {"sha": "82c55d7b5b83c43df529cdea4fa88a9fe078fc81", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n #![doc(hidden)]\n #![allow(unsigned_negation)]\n "}, {"sha": "efd571be9e2a66c0d4e307899ff68399ab1f2b49", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -22,7 +22,7 @@\n //! so we will not _hide_ the facts of which OS the user is on -- they should be given the\n //! opportunity to write OS-ignorant code by default.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"os\")]\n \n #![allow(missing_docs)]\n #![allow(non_snake_case)]"}, {"sha": "7a34a1d8c3802c13f111734ed74d4cbb405bebf1", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -59,7 +59,7 @@\n //! println!(\"path exists: {}\", path.exists());\n //! ```\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"path\")]\n \n use core::marker::Sized;\n use ffi::CString;"}, {"sha": "3251656cd16712d540895dfca63d25deb9b34081", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -19,7 +19,7 @@\n #[doc(no_inline)] pub use ops::{Drop, Fn, FnMut, FnOnce};\n \n // TEMPORARY\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"std_misc\")]\n #[doc(no_inline)] pub use ops::FullRange;\n \n // Reexported functions"}, {"sha": "5844cc85c31fc40c5b6461f6446f1818ff7cdb6e", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -219,7 +219,7 @@\n //! }\n //! ```\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rand\")]\n \n use cell::RefCell;\n use clone::Clone;"}, {"sha": "7e19f1cac2c5bf5a0c74c7d25e3f0823061ba086", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -16,7 +16,7 @@\n //! and should be considered as private implementation details for the\n //! time being.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n \n // FIXME: this should not be here.\n #![allow(missing_docs)]"}, {"sha": "7d886f9936fc3027efb4a2c7c2a431ca210e141e", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -582,7 +582,7 @@ fn begin_unwind_inner(msg: Box<Any + Send>, file_line: &(&'static str, uint)) ->\n /// Only a limited number of callbacks can be registered, and this function\n /// returns whether the callback was successfully registered or not. It is not\n /// currently possible to unregister a callback once it has been registered.\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"std_misc\")]\n pub unsafe fn register(f: Callback) -> bool {\n     match CALLBACK_CNT.fetch_add(1, Ordering::SeqCst) {\n         // The invocation code has knowledge of this window where the count has"}, {"sha": "06b6816248709abc66379bda43b11f596e103767", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -12,7 +12,7 @@\n //! the standard library This varies per-platform, but these libraries are\n //! necessary for running libstd.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n \n // All platforms need to link to rustrt\n #[cfg(not(test))]"}, {"sha": "e36dd94338614b6e40f24bb4d5ff74795946aacf", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -76,7 +76,7 @@ unsafe impl Sync for Condvar {}\n ///\n /// static CVAR: StaticCondvar = CONDVAR_INIT;\n /// ```\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"may be merged with Condvar in the future\")]\n pub struct StaticCondvar {\n     inner: sys::Condvar,\n@@ -87,7 +87,7 @@ unsafe impl Send for StaticCondvar {}\n unsafe impl Sync for StaticCondvar {}\n \n /// Constant initializer for a statically allocated condition variable.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"may be merged with Condvar in the future\")]\n pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n     inner: sys::CONDVAR_INIT,\n@@ -156,7 +156,7 @@ impl Condvar {\n     ///\n     /// Like `wait`, the lock specified will be re-acquired when this function\n     /// returns, regardless of whether the timeout elapsed or not.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>, dur: Duration)\n                            -> LockResult<(MutexGuard<'a, T>, bool)> {\n         unsafe {\n@@ -171,7 +171,7 @@ impl Condvar {\n     /// The semantics of this function are equivalent to `wait_timeout` except\n     /// that the implementation will repeatedly wait while the duration has not\n     /// passed and the provided function returns `false`.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn wait_timeout_with<'a, T, F>(&self,\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n@@ -217,7 +217,7 @@ impl StaticCondvar {\n     /// notification.\n     ///\n     /// See `Condvar::wait`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn wait<'a, T>(&'static self, guard: MutexGuard<'a, T>)\n                        -> LockResult<MutexGuard<'a, T>> {\n@@ -238,7 +238,7 @@ impl StaticCondvar {\n     /// specified duration.\n     ///\n     /// See `Condvar::wait_timeout`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn wait_timeout<'a, T>(&'static self, guard: MutexGuard<'a, T>, dur: Duration)\n                                -> LockResult<(MutexGuard<'a, T>, bool)> {\n@@ -262,7 +262,7 @@ impl StaticCondvar {\n     /// passed and the function returns `false`.\n     ///\n     /// See `Condvar::wait_timeout_with`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn wait_timeout_with<'a, T, F>(&'static self,\n                                        guard: MutexGuard<'a, T>,\n@@ -303,14 +303,14 @@ impl StaticCondvar {\n     /// Wake up one blocked thread on this condvar.\n     ///\n     /// See `Condvar::notify_one`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn notify_one(&'static self) { unsafe { self.inner.notify_one() } }\n \n     /// Wake up all blocked threads on this condvar.\n     ///\n     /// See `Condvar::notify_all`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn notify_all(&'static self) { unsafe { self.inner.notify_all() } }\n \n@@ -320,7 +320,7 @@ impl StaticCondvar {\n     /// active users of the condvar, and this also doesn't prevent any future\n     /// users of the condvar. This method is required to be called to not leak\n     /// memory on all platforms.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub unsafe fn destroy(&'static self) {\n         self.inner.destroy()"}, {"sha": "a79fb684f477036b861258463ed78ce0e5c0a845", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -27,7 +27,7 @@\n //! ```\n \n #![allow(missing_docs)]\n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"std_misc\",\n             reason = \"futures as-is have yet to be deeply reevaluated with recent \\\n                       core changes to Rust's synchronization story, and will likely \\\n                       become stable in the future but are unstable until that time\")]"}, {"sha": "8afd8e5997994ae8e13de78dc3393bf05b0c8169", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -35,7 +35,7 @@\n //! method, and see the method for more information about it. Due to this\n //! caveat, this queue may not be appropriate for all use-cases.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n \n // http://www.1024cores.net/home/lock-free-algorithms\n //                         /queues/non-intrusive-mpsc-node-based-queue"}, {"sha": "ee4d3a5548182393ff32721f05041b25cbc324d7", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -46,7 +46,7 @@\n //! ```\n \n #![allow(dead_code)]\n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"std_misc\",\n             reason = \"This implementation, while likely sufficient, is unsafe and \\\n                       likely to be error prone. At some point in the future this \\\n                       module will likely be replaced, and it is currently \\"}, {"sha": "893260415ebdccdf7b473bedb46425d82bd601e7", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -33,7 +33,7 @@\n //! concurrently between two tasks. This data structure is safe to use and\n //! enforces the semantics that there is one pusher and one popper.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n \n use core::prelude::*;\n "}, {"sha": "0d18c05f71a957bda17e9163d85b59285840b705", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -145,7 +145,7 @@ unsafe impl<T:Send> Sync for Mutex<T> { }\n /// }\n /// // lock is unlocked here.\n /// ```\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"may be merged with Mutex in the future\")]\n pub struct StaticMutex {\n     lock: sys::Mutex,\n@@ -192,7 +192,7 @@ impl<'a, T> !marker::Send for MutexGuard<'a, T> {}\n \n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"may be merged with Mutex in the future\")]\n pub const MUTEX_INIT: StaticMutex = StaticMutex {\n     lock: sys::MUTEX_INIT,\n@@ -267,7 +267,7 @@ static DUMMY: Dummy = Dummy(UnsafeCell { value: () });\n impl StaticMutex {\n     /// Acquires this lock, see `Mutex::lock`\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with Mutex in the future\")]\n     pub fn lock(&'static self) -> LockResult<MutexGuard<()>> {\n         unsafe { self.lock.lock() }\n@@ -276,7 +276,7 @@ impl StaticMutex {\n \n     /// Attempts to grab this lock, see `Mutex::try_lock`\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with Mutex in the future\")]\n     pub fn try_lock(&'static self) -> TryLockResult<MutexGuard<()>> {\n         if unsafe { self.lock.try_lock() } {\n@@ -296,7 +296,7 @@ impl StaticMutex {\n     /// *all* platforms. It may be the case that some platforms do not leak\n     /// memory if this method is not called, but this is not guaranteed to be\n     /// true on all platforms.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with Mutex in the future\")]\n     pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()"}, {"sha": "d2362eefcf154fa5637f0b836c2bc9acfbb15c30", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -110,17 +110,17 @@ impl<T> PoisonError<T> {\n \n     /// Consumes this error indicating that a lock is poisoned, returning the\n     /// underlying guard to allow access regardless.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn into_inner(self) -> T { self.guard }\n \n     /// Reaches into this error indicating that a lock is poisoned, returning a\n     /// reference to the underlying guard to allow access regardless.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn get_ref(&self) -> &T { &self.guard }\n \n     /// Reaches into this error indicating that a lock is poisoned, returning a\n     /// mutable reference to the underlying guard to allow access regardless.\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn get_mut(&mut self) -> &mut T { &mut self.guard }\n }\n "}, {"sha": "abed6fd99a5ecf326ebfa59b1bf2b3580492c812", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -90,7 +90,7 @@ unsafe impl<T> Sync for RwLock<T> {}\n /// }\n /// unsafe { LOCK.destroy() } // free all resources\n /// ```\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"may be merged with RwLock in the future\")]\n pub struct StaticRwLock {\n     lock: sys::RWLock,\n@@ -101,7 +101,7 @@ unsafe impl Send for StaticRwLock {}\n unsafe impl Sync for StaticRwLock {}\n \n /// Constant initialization for a statically-initialized rwlock.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"may be merged with RwLock in the future\")]\n pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n     lock: sys::RWLOCK_INIT,\n@@ -276,7 +276,7 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::read`.\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with RwLock in the future\")]\n     pub fn read(&'static self) -> LockResult<RwLockReadGuard<'static, ()>> {\n         unsafe { self.lock.read() }\n@@ -287,7 +287,7 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::try_read`.\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with RwLock in the future\")]\n     pub fn try_read(&'static self)\n                     -> TryLockResult<RwLockReadGuard<'static, ()>> {\n@@ -303,7 +303,7 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::write`.\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with RwLock in the future\")]\n     pub fn write(&'static self) -> LockResult<RwLockWriteGuard<'static, ()>> {\n         unsafe { self.lock.write() }\n@@ -314,7 +314,7 @@ impl StaticRwLock {\n     ///\n     /// See `RwLock::try_write`.\n     #[inline]\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with RwLock in the future\")]\n     pub fn try_write(&'static self)\n                      -> TryLockResult<RwLockWriteGuard<'static, ()>> {\n@@ -331,7 +331,7 @@ impl StaticRwLock {\n     /// active users of the lock, and this also doesn't prevent any future users\n     /// of this lock. This method is required to be called to not leak memory on\n     /// all platforms.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may be merged with RwLock in the future\")]\n     pub unsafe fn destroy(&'static self) {\n         self.lock.destroy()"}, {"sha": "25f31d6e147883148862a2860644e06ee1b1f4e4", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"std_misc\",\n             reason = \"the interaction between semaphores and the acquisition/release \\\n                       of resources is currently unclear\")]\n "}, {"sha": "3fac998d3e72d0e52452e45e9845da74687bbd55", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -10,7 +10,7 @@\n \n //! Abstraction of a thread pool for basic parallelism.\n \n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"std_misc\",\n             reason = \"the semantics of a failing task and whether a thread is \\\n                       re-attached to a thread pool are somewhat unclear, and the \\\n                       utility of this type in `std::sync` is questionable with \\"}, {"sha": "5edcc3745ac43e3c2662987e864be5899c258f8d", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -29,7 +29,7 @@\n //! }\n //! ```\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n \n use sys_common::AsInner;\n use libc;"}, {"sha": "c078bc21be65b5e43f0e3b07bc3269f15ff416b4", "filename": "src/libstd/sys/windows/ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -14,7 +14,7 @@\n //! descriptors, and sockets, but its functionality will grow over\n //! time.\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n \n use sys_common::AsInner;\n use libc;"}, {"sha": "1012edfc2fe86a1795f73666b2072975974f2131", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -207,15 +207,15 @@ impl Builder {\n     }\n \n     /// Redirect thread-local stdout.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"Will likely go away after proc removal\")]\n     pub fn stdout(mut self, stdout: Box<Writer + Send>) -> Builder {\n         self.stdout = Some(stdout);\n         self\n     }\n \n     /// Redirect thread-local stderr.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"Will likely go away after proc removal\")]\n     pub fn stderr(mut self, stderr: Box<Writer + Send>) -> Builder {\n         self.stderr = Some(stderr);\n@@ -225,7 +225,7 @@ impl Builder {\n     /// Spawn a new detached thread, and return a handle to it.\n     ///\n     /// See `Thead::spawn` and the module doc for more details.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may change with specifics of new Send semantics\")]\n     pub fn spawn<F>(self, f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n         let (native, thread) = self.spawn_inner(Thunk::new(f), Thunk::with_arg(|_| {}));\n@@ -237,7 +237,7 @@ impl Builder {\n     /// scope, and return a `JoinGuard`.\n     ///\n     /// See `Thead::scoped` and the module doc for more details.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may change with specifics of new Send semantics\")]\n     pub fn scoped<'a, T, F>(self, f: F) -> JoinGuard<'a, T> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n@@ -354,7 +354,7 @@ impl Thread {\n     /// main thread; the whole process is terminated when the main thread\n     /// finishes.) The thread handle can be used for low-level\n     /// synchronization. See the module documentation for additional details.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may change with specifics of new Send semantics\")]\n     pub fn spawn<F>(f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n         Builder::new().spawn(f)\n@@ -368,7 +368,7 @@ impl Thread {\n     /// current thread's stack (hence the \"scoped\" name), it cannot be detached;\n     /// it *must* be joined before the relevant stack frame is popped. See the\n     /// module documentation for additional details.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"may change with specifics of new Send semantics\")]\n     pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n@@ -383,7 +383,7 @@ impl Thread {\n     }\n \n     /// Cooperatively give up a timeslice to the OS scheduler.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"name may change\")]\n+    #[unstable(feature = \"std_misc\", reason = \"name may change\")]\n     pub fn yield_now() {\n         unsafe { imp::yield_now() }\n     }\n@@ -404,7 +404,7 @@ impl Thread {\n     // future, this will be implemented in a more efficient way, perhaps along the lines of\n     //   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n     // or futuxes, and in either case may allow spurious wakeups.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"recently introduced\")]\n+    #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n     pub fn park() {\n         let thread = Thread::current();\n         let mut guard = thread.inner.lock.lock().unwrap();\n@@ -417,7 +417,7 @@ impl Thread {\n     /// Atomically makes the handle's token available if it is not already.\n     ///\n     /// See the module doc for more detail.\n-    #[unstable(feature = \"unnamed_feature\", reason = \"recently introduced\")]\n+    #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n     pub fn unpark(&self) {\n         let mut guard = self.inner.lock.lock().unwrap();\n         if !*guard {\n@@ -453,7 +453,7 @@ unsafe impl<T> Sync for Packet<T> {}\n ///\n /// The type `T` is the return type for the thread's main function.\n #[must_use]\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"may change with specifics of new Send semantics\")]\n pub struct JoinGuard<'a, T: 'a> {\n     native: imp::rust_thread,\n@@ -490,7 +490,7 @@ impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n \n impl<T: Send> JoinGuard<'static, T> {\n     /// Detaches the child thread, allowing it to outlive its parent.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"unsure whether this API imposes limitations elsewhere\")]\n     pub fn detach(mut self) {\n         unsafe { imp::detach(self.native) };"}, {"sha": "94e5d19d61bef329ff8e0d154b5d95c140431700", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -218,7 +218,7 @@ macro_rules! __thread_local_inner {\n }\n \n /// Indicator of the state of a thread local storage key.\n-#[unstable(feature = \"unnamed_feature\",\n+#[unstable(feature = \"std_misc\",\n            reason = \"state querying was recently added\")]\n #[derive(Eq, PartialEq, Copy)]\n pub enum State {\n@@ -302,7 +302,7 @@ impl<T: 'static> Key<T> {\n     /// initialization does not panic. Keys in the `Valid` state are guaranteed\n     /// to be able to be accessed. Keys in the `Destroyed` state will panic on\n     /// any call to `with`.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"std_misc\",\n                reason = \"state querying was recently added\")]\n     pub fn state(&'static self) -> State {\n         unsafe {"}, {"sha": "1a20612d60a8475b2072de79a0856719d4899cf5", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -38,7 +38,7 @@\n //! });\n //! ```\n \n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"std_misc\",\n             reason = \"scoped TLS has yet to have wide enough use to fully consider \\\n                       stabilizing its interface\")]\n "}, {"sha": "2e53d0ceecbdfc0b00b1602d34d9b06ca43afd37", "filename": "src/libstd/thunk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fthunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Fthunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthunk.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -10,7 +10,7 @@\n \n // Because this module is temporary...\n #![allow(missing_docs)]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n \n use alloc::boxed::Box;\n use core::marker::Send;"}, {"sha": "1bf3454eaa141a3abaccf0f195b593eaf240dc70", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -10,7 +10,7 @@\n \n //! Temporal quantification\n \n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"std_misc\")]\n \n use {fmt, i64};\n use ops::{Add, Sub, Mul, Div, Neg, FnOnce};"}, {"sha": "ff4c7b565cbbe469375cac7706eb8b0bf8882c4a", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -15,7 +15,7 @@\n //! This API is completely unstable and subject to change.\n \n #![crate_name = \"syntax\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"rustc_private\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"dylib\"]\n@@ -28,8 +28,17 @@\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n #![feature(quote, unsafe_destructor)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(hash)]\n+#![feature(io)]\n+#![feature(libc)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n \n extern crate arena;\n extern crate fmt_macros;"}, {"sha": "213b7ba11b77353b23d2e1f97712dd821b399c91", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -39,7 +39,7 @@\n //! [ti]: https://en.wikipedia.org/wiki/Terminfo\n \n #![crate_name = \"term\"]\n-#![unstable(feature = \"unnamed_feature\",\n+#![unstable(feature = \"rustc_private\",\n             reason = \"use the crates.io `term` library instead\")]\n #![feature(staged_api)]\n #![staged_api]\n@@ -53,9 +53,16 @@\n #![allow(unknown_features)]\n #![feature(slicing_syntax)]\n #![feature(box_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![deny(missing_docs)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n+#![feature(unicode)]\n \n #[macro_use] extern crate log;\n "}, {"sha": "512120243c3163bc3a4c456ae2c364b8b729ec70", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -24,7 +24,7 @@\n // build off of.\n \n #![crate_name = \"test\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"test\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n@@ -35,8 +35,14 @@\n #![allow(unknown_features)]\n #![feature(asm, slicing_syntax)]\n #![feature(box_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(std_misc)]\n \n extern crate getopts;\n extern crate regex;"}, {"sha": "6d64d3d3d357a53444f99dbae47f836c1033c90f", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -21,7 +21,7 @@\n //! (yet) aim to provide a full set of Unicode tables.\n \n #![crate_name = \"unicode\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"unicode\")]\n #![feature(staged_api)]\n #![staged_api]\n #![crate_type = \"rlib\"]\n@@ -31,8 +31,8 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![no_std]\n #![feature(slicing_syntax)]\n-#![feature(unnamed_feature)]\n #![allow(unknown_features)] #![feature(int_uint)]\n+#![feature(core)]\n \n extern crate core;\n "}, {"sha": "31007d8b5b379899f376d69e36e6897e65456bba", "filename": "src/libunicode/u_char.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -34,7 +34,7 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix > 36.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool;\n \n@@ -49,7 +49,7 @@ pub trait CharExt {\n     /// # Panics\n     ///\n     /// Panics if given a radix outside the range [0..36].\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint>;\n \n@@ -92,7 +92,7 @@ pub trait CharExt {\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;\n \n@@ -101,7 +101,7 @@ pub trait CharExt {\n     ///\n     /// If the buffer is not large enough, nothing will be written into it\n     /// and a `None` will be returned.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;\n \n@@ -116,7 +116,7 @@ pub trait CharExt {\n     /// 'XID_Start' is a Unicode Derived Property specified in\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to ID_Start but modified for closure under NFKx.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"mainly needed for compiler internals\")]\n     fn is_xid_start(self) -> bool;\n \n@@ -126,7 +126,7 @@ pub trait CharExt {\n     /// 'XID_Continue' is a Unicode Derived Property specified in\n     /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n     /// mostly similar to 'ID_Continue' but modified for closure under NFKx.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"mainly needed for compiler internals\")]\n     fn is_xid_continue(self) -> bool;\n \n@@ -177,7 +177,7 @@ pub trait CharExt {\n     ///\n     /// Returns the lowercase equivalent of the character, or the character\n     /// itself if no conversion is possible.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"pending case transformation decisions\")]\n     fn to_lowercase(self) -> char;\n \n@@ -201,7 +201,7 @@ pub trait CharExt {\n     /// [`SpecialCasing`.txt`]: ftp://ftp.unicode.org/Public/UNIDATA/SpecialCasing.txt\n     ///\n     /// [2]: http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"pending case transformation decisions\")]\n     fn to_uppercase(self) -> char;\n \n@@ -214,17 +214,17 @@ pub trait CharExt {\n     /// [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)\n     /// recommends that these characters be treated as 1 column (i.e.,\n     /// `is_cjk` = `false`) if the context cannot be reliably determined.\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n     fn width(self, is_cjk: bool) -> Option<uint>;\n }\n \n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n impl CharExt for char {\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n     fn is_digit(self, radix: uint) -> bool { C::is_digit(self, radix) }\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n     fn to_digit(self, radix: uint) -> Option<uint> { C::to_digit(self, radix) }\n     #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n@@ -235,10 +235,10 @@ impl CharExt for char {\n     fn len_utf8(self) -> uint { C::len_utf8(self) }\n     #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     fn len_utf16(self) -> uint { C::len_utf16(self) }\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> { C::encode_utf8(self, dst) }\n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n     fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> { C::encode_utf16(self, dst) }\n \n@@ -251,11 +251,11 @@ impl CharExt for char {\n         }\n     }\n \n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"mainly needed for compiler internals\")]\n     fn is_xid_start(self) -> bool { derived_property::XID_Start(self) }\n \n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"mainly needed for compiler internals\")]\n     fn is_xid_continue(self) -> bool { derived_property::XID_Continue(self) }\n \n@@ -303,15 +303,15 @@ impl CharExt for char {\n         }\n     }\n \n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"pending case transformation decisions\")]\n     fn to_lowercase(self) -> char { conversions::to_lower(self) }\n \n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"pending case transformation decisions\")]\n     fn to_uppercase(self) -> char { conversions::to_upper(self) }\n \n-    #[unstable(feature = \"unnamed_feature\",\n+    #[unstable(feature = \"unicode\",\n                reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n     fn width(self, is_cjk: bool) -> Option<uint> { charwidth::width(self, is_cjk) }\n }"}, {"sha": "6d9078c668735ca3e6d108279923de2c76dc3dfe", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -9,7 +9,13 @@\n // except according to those terms.\n \n #![feature(slicing_syntax, box_syntax)]\n-#![feature(unnamed_feature)]\n+#![feature(collections)]\n+#![feature(core)]\n+#![feature(io)]\n+#![feature(os)]\n+#![feature(path)]\n+#![feature(rustc_private)]\n+#![feature(rustdoc)]\n \n extern crate regex;\n "}, {"sha": "1fb3e4656f8655ee86d658172beb93324939fa26", "filename": "src/test/auxiliary/inherited_stability.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fauxiliary%2Finherited_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Finherited_stability.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n #![crate_name=\"inherited_stability\"]\n #![crate_type = \"lib\"]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"test_feature\")]\n #![feature(staged_api)]\n #![staged_api]\n \n@@ -26,9 +26,9 @@ pub mod stable_mod {\n     pub fn stable() {}\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"test_feature\")]\n pub mod unstable_mod {\n-    #[deprecated(feature = \"unnamed_feature\", since = \"1.0.0\")]\n+    #[deprecated(feature = \"test_feature\", since = \"1.0.0\")]\n     pub fn deprecated() {}\n \n     pub fn unstable() {}"}, {"sha": "c6b1579cecb804c64b3b706620337b5fc7ee32ab", "filename": "src/test/auxiliary/lint_output_format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fauxiliary%2Flint_output_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_output_format.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -12,19 +12,19 @@\n #![crate_type = \"lib\"]\n #![feature(staged_api)]\n #![staged_api]\n-#![unstable(feature = \"unnamed_feature\")]\n+#![unstable(feature = \"test_feature\")]\n \n #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n pub fn foo() -> uint {\n     20\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"test_feature\")]\n pub fn bar() -> uint {\n     40\n }\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"test_feature\")]\n pub fn baz() -> uint {\n     30\n }"}, {"sha": "0f2749b0b196a4bc86e32a21a6d970d4c1c197b9", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -17,9 +17,9 @@ pub fn deprecated() {}\n #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"text\")]\n pub fn deprecated_text() {}\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"test_feature\")]\n pub fn unstable() {}\n-#[unstable(feature = \"unnamed_feature\", reason = \"text\")]\n+#[unstable(feature = \"test_feature\", reason = \"text\")]\n pub fn unstable_text() {}\n \n pub fn unmarked() {}\n@@ -38,9 +38,9 @@ impl MethodTester {\n     #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"text\")]\n     pub fn method_deprecated_text(&self) {}\n \n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"test_feature\")]\n     pub fn method_unstable(&self) {}\n-    #[unstable(feature = \"unnamed_feature\", reason = \"text\")]\n+    #[unstable(feature = \"test_feature\", reason = \"text\")]\n     pub fn method_unstable_text(&self) {}\n \n     pub fn method_unmarked(&self) {}\n@@ -67,9 +67,9 @@ pub trait Trait {\n     #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"text\")]\n     fn trait_deprecated_text(&self) {}\n \n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"test_feature\")]\n     fn trait_unstable(&self) {}\n-    #[unstable(feature = \"unnamed_feature\", reason = \"text\")]\n+    #[unstable(feature = \"test_feature\", reason = \"text\")]\n     fn trait_unstable_text(&self) {}\n \n     fn trait_unmarked(&self) {}\n@@ -92,20 +92,20 @@ pub trait Trait {\n \n impl Trait for MethodTester {}\n \n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"test_feature\")]\n pub trait UnstableTrait {}\n \n #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n pub struct DeprecatedStruct { pub i: int }\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"test_feature\")]\n pub struct UnstableStruct { pub i: int }\n pub struct UnmarkedStruct { pub i: int }\n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n pub struct StableStruct { pub i: int }\n \n #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n pub struct DeprecatedUnitStruct;\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"test_feature\")]\n pub struct UnstableUnitStruct;\n pub struct UnmarkedUnitStruct;\n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n@@ -114,7 +114,7 @@ pub struct StableUnitStruct;\n pub enum Enum {\n     #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     DeprecatedVariant,\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"test_feature\")]\n     UnstableVariant,\n \n     UnmarkedVariant,\n@@ -124,7 +124,7 @@ pub enum Enum {\n \n #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n pub struct DeprecatedTupleStruct(pub int);\n-#[unstable(feature = \"unnamed_feature\")]\n+#[unstable(feature = \"test_feature\")]\n pub struct UnstableTupleStruct(pub int);\n pub struct UnmarkedTupleStruct(pub int);\n #[stable(feature = \"grandfathered\", since = \"1.0.0\")]"}, {"sha": "3a92cf59611cf95f105382c64b05e0445e14954d", "filename": "src/test/auxiliary/stability_cfg1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstability_cfg1.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n #![cfg_attr(foo, experimental)]\n-#![cfg_attr(not(foo), stable(feature = \"unnamed_feature\", since = \"1.0.0\"))]\n+#![cfg_attr(not(foo), stable(feature = \"test_feature\", since = \"1.0.0\"))]\n #![feature(staged_api)]\n #![staged_api]"}, {"sha": "d9ed76e5c58e766ba8fbe7a4ad3ac718e5bd95ef", "filename": "src/test/auxiliary/stability_cfg2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fstability_cfg2.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags:--cfg foo\n \n-#![cfg_attr(foo, unstable(feature = \"unnamed_feature\"))]\n-#![cfg_attr(not(foo), stable(feature = \"unnamed_feature\", since = \"1.0.0\"))]\n+#![cfg_attr(foo, unstable(feature = \"test_feature\"))]\n+#![cfg_attr(not(foo), stable(feature = \"test_feature\", since = \"1.0.0\"))]\n #![feature(staged_api)]\n #![staged_api]"}, {"sha": "c65b2366bf10f7360f69e167aa453f57e18bb4d9", "filename": "src/test/compile-fail/enable-unstable-lib-feature.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Fenable-unstable-lib-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Fenable-unstable-lib-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenable-unstable-lib-feature.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -12,7 +12,7 @@\n \n // aux-build:stability_cfg2.rs\n \n-#![feature(unnamed_feature)]\n+#![feature(test_feature)]\n #![deny(non_snake_case)] // To trigger a hard error\n \n // Shouldn't generate a warning about unstable features"}, {"sha": "9923db3c56636ad25accf1e3032652cace5b9faa", "filename": "src/test/compile-fail/fail-no-dead-code-core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffail-no-dead-code-core.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -10,7 +10,7 @@\n \n #![deny(dead_code)]\n #![allow(unreachable_code)]\n-#![feature(unnamed_feature)]\n+#![feature(core)]\n \n #[macro_use] extern crate core;\n "}, {"sha": "a8804a6df061a5297900bbb11d970b7c2a8296cd", "filename": "src/test/compile-fail/issue-17999.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17999.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![deny(unused_variables)]\n-#![feature(unnamed_feature)]\n+#![feature(core)]\n \n fn main() {\n     for _ in range(1is, 101) {"}, {"sha": "3f25e9c7b76aac34ea92298574f4584b3faf16c2", "filename": "src/test/compile-fail/lint-ctypes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![deny(improper_ctypes)]\n-#![feature(unnamed_feature)]\n+#![feature(libc)]\n \n extern crate libc;\n "}, {"sha": "dc59194373124a9c70b0b99af684b384d0956a5d", "filename": "src/test/compile-fail/lint-dead-code-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-1.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -14,7 +14,7 @@\n #![allow(non_upper_case_globals)]\n #![allow(missing_copy_implementations)]\n #![deny(dead_code)]\n-#![feature(unnamed_feature)]\n+#![feature(core)]\n \n #![crate_type=\"lib\"]\n "}, {"sha": "be135978d2dad3b1aba763429954e0db391b4546", "filename": "src/test/compile-fail/lint-dead-code-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -11,7 +11,7 @@\n #![allow(unused_variables)]\n #![allow(non_camel_case_types)]\n #![deny(dead_code)]\n-#![feature(unnamed_feature)]\n+#![feature(libc)]\n \n #![crate_type=\"lib\"]\n "}, {"sha": "22570bad616963c3cfca4da05c7510c2bfc5d86d", "filename": "src/test/compile-fail/lint-dead-code-4.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -11,7 +11,9 @@\n #![allow(unused_variables)]\n #![allow(non_camel_case_types)]\n #![deny(dead_code)]\n-#![feature(unnamed_feature)]\n+#![feature(libc)]\n+#![feature(core)]\n+#![feature(collections)]\n \n extern crate libc;\n "}, {"sha": "98853a2e9a119948669b9bf9bf985d4d82dcabe4", "filename": "src/test/compile-fail/lint-exceeding-bitshifts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-exceeding-bitshifts.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -11,7 +11,7 @@\n #![deny(exceeding_bitshifts)]\n #![allow(unused_variables)]\n #![allow(dead_code)]\n-#![feature(unnamed_feature)]\n+#![feature(core)]\n \n fn main() {\n       let n = 1u8 << 7;"}, {"sha": "e89151aa746779f5c507d561c76b1d83eba30267", "filename": "src/test/compile-fail/lint-stability.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-stability.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -43,9 +43,9 @@ mod cross_crate {\n         foo.method_unstable(); //~ WARNING use of unstable library feature\n         foo.trait_unstable(); //~ WARNING use of unstable library feature\n \n-        unstable_text(); //~ WARNING use of unstable library feature 'unnamed_feature': text\n-        foo.method_unstable_text(); //~ WARNING use of unstable library feature 'unnamed_feature': text\n-        foo.trait_unstable_text(); //~ WARNING use of unstable library feature 'unnamed_feature': text\n+        unstable_text(); //~ WARNING use of unstable library feature 'test_feature': text\n+        foo.method_unstable_text(); //~ WARNING use of unstable library feature 'test_feature': text\n+        foo.trait_unstable_text(); //~ WARNING use of unstable library feature 'test_feature': text\n \n         unmarked(); //~ ERROR use of unmarked library feature\n         foo.method_unmarked(); //~ ERROR use of unmarked library feature\n@@ -94,7 +94,7 @@ mod cross_crate {\n         foo.trait_deprecated(); //~ ERROR use of deprecated item\n         foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n         foo.trait_unstable(); //~ WARNING use of unstable library feature\n-        foo.trait_unstable_text(); //~ WARNING use of unstable library feature 'unnamed_feature': text\n+        foo.trait_unstable_text(); //~ WARNING use of unstable library feature 'test_feature': text\n         foo.trait_unmarked(); //~ ERROR use of unmarked library feature\n         foo.trait_stable();\n     }\n@@ -103,7 +103,7 @@ mod cross_crate {\n         foo.trait_deprecated(); //~ ERROR use of deprecated item\n         foo.trait_deprecated_text(); //~ ERROR use of deprecated item: text\n         foo.trait_unstable(); //~ WARNING use of unstable library feature\n-        foo.trait_unstable_text(); //~ WARNING use of unstable library feature 'unnamed_feature': text\n+        foo.trait_unstable_text(); //~ WARNING use of unstable library feature 'test_feature': text\n         foo.trait_unmarked(); //~ ERROR use of unmarked library feature\n         foo.trait_stable();\n     }\n@@ -144,9 +144,9 @@ mod this_crate {\n     #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"text\")]\n     pub fn deprecated_text() {}\n \n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"test_feature\")]\n     pub fn unstable() {}\n-    #[unstable(feature = \"unnamed_feature\", reason = \"text\")]\n+    #[unstable(feature = \"test_feature\", reason = \"text\")]\n     pub fn unstable_text() {}\n \n     pub fn unmarked() {}\n@@ -165,9 +165,9 @@ mod this_crate {\n         #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"text\")]\n         pub fn method_deprecated_text(&self) {}\n \n-        #[unstable(feature = \"unnamed_feature\")]\n+        #[unstable(feature = \"test_feature\")]\n         pub fn method_unstable(&self) {}\n-        #[unstable(feature = \"unnamed_feature\", reason = \"text\")]\n+        #[unstable(feature = \"test_feature\", reason = \"text\")]\n         pub fn method_unstable_text(&self) {}\n \n         pub fn method_unmarked(&self) {}\n@@ -184,9 +184,9 @@ mod this_crate {\n         #[deprecated(feature = \"oldstuff\", since = \"1.0.0\", reason = \"text\")]\n         fn trait_deprecated_text(&self) {}\n \n-        #[unstable(feature = \"unnamed_feature\")]\n+        #[unstable(feature = \"test_feature\")]\n         fn trait_unstable(&self) {}\n-        #[unstable(feature = \"unnamed_feature\", reason = \"text\")]\n+        #[unstable(feature = \"test_feature\", reason = \"text\")]\n         fn trait_unstable_text(&self) {}\n \n         fn trait_unmarked(&self) {}\n@@ -201,15 +201,15 @@ mod this_crate {\n \n     #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     pub struct DeprecatedStruct { i: isize }\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"test_feature\")]\n     pub struct UnstableStruct { i: isize }\n     pub struct UnmarkedStruct { i: isize }\n     #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n     pub struct StableStruct { i: isize }\n \n     #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     pub struct DeprecatedUnitStruct;\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"test_feature\")]\n     pub struct UnstableUnitStruct;\n     pub struct UnmarkedUnitStruct;\n     #[stable(feature = \"grandfathered\", since = \"1.0.0\")]\n@@ -218,7 +218,7 @@ mod this_crate {\n     pub enum Enum {\n         #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n         DeprecatedVariant,\n-        #[unstable(feature = \"unnamed_feature\")]\n+        #[unstable(feature = \"test_feature\")]\n         UnstableVariant,\n \n         UnmarkedVariant,\n@@ -228,7 +228,7 @@ mod this_crate {\n \n     #[deprecated(feature = \"oldstuff\", since = \"1.0.0\")]\n     pub struct DeprecatedTupleStruct(isize);\n-    #[unstable(feature = \"unnamed_feature\")]\n+    #[unstable(feature = \"test_feature\")]\n     pub struct UnstableTupleStruct(isize);\n     pub struct UnmarkedTupleStruct(isize);\n     #[stable(feature = \"grandfathered\", since = \"1.0.0\")]"}, {"sha": "03bb7cc1f15e049091b6916e637260703e3ccf6f", "filename": "src/test/compile-fail/lint-unused-extern-crate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unused-extern-crate.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -12,7 +12,9 @@\n \n #![deny(unused_extern_crates)]\n #![allow(unused_variables)]\n-#![feature(unnamed_feature)]\n+#![feature(libc)]\n+#![feature(collections)]\n+#![feature(rand)]\n \n extern crate libc; //~ ERROR: unused extern crate\n "}, {"sha": "6b3c680749f6b1b358f512b93794fd809a2b44cc", "filename": "src/test/compile-fail/lint-uppercase-variables.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-uppercase-variables.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -12,7 +12,8 @@\n \n #![allow(dead_code)]\n #![deny(non_snake_case)]\n-#![feature(unnamed_feature)]\n+#![feature(path)]\n+#![feature(io)]\n \n use std::io::File;\n use std::io::IoError;"}, {"sha": "4a3f7e9cad972b9f8b564ce87b04849e42f9e172", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -11,7 +11,8 @@\n #![deny(unused_variables)]\n #![deny(unused_assignments)]\n #![allow(dead_code, non_camel_case_types)]\n-#![feature(unnamed_feature)]\n+#![feature(core)]\n+#![feature(os)]\n \n fn f1(x: isize) {\n     //~^ ERROR unused variable: `x`"}, {"sha": "50217ff9e5dc6c37826c05e35b4f11c58778a8bf", "filename": "src/test/compile-fail/unused-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Funused-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd6d9eab5d75584edfcae4ffdef8b0836db80c1e/src%2Ftest%2Fcompile-fail%2Funused-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funused-attr.rs?ref=cd6d9eab5d75584edfcae4ffdef8b0836db80c1e", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n #![deny(unused_attributes)]\n #![allow(dead_code, unused_imports)]\n-#![feature(unnamed_feature)]\n+#![feature(core)]\n \n #![foo] //~ ERROR unused attribute\n "}]}