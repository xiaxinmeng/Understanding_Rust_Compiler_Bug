{"sha": "d0934f14c7fd95c0517c98a2c0dc549ec40b03e7", "node_id": "C_kwDOAAsO6NoAKGQwOTM0ZjE0YzdmZDk1YzA1MTdjOThhMmMwZGM1NDllYzQwYjAzZTc", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-08T20:32:28Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-02-20T18:25:37Z"}, "message": "Merge if-let and match.", "tree": {"sha": "691aa3a4445c34059712d6b472ca57ed3a5e20b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/691aa3a4445c34059712d6b472ca57ed3a5e20b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d0934f14c7fd95c0517c98a2c0dc549ec40b03e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d0934f14c7fd95c0517c98a2c0dc549ec40b03e7", "html_url": "https://github.com/rust-lang/rust/commit/d0934f14c7fd95c0517c98a2c0dc549ec40b03e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d0934f14c7fd95c0517c98a2c0dc549ec40b03e7/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a75995fbd0c5a342fe0556eba080e1ae7fe0802", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a75995fbd0c5a342fe0556eba080e1ae7fe0802", "html_url": "https://github.com/rust-lang/rust/commit/4a75995fbd0c5a342fe0556eba080e1ae7fe0802"}], "stats": {"total": 130, "additions": 63, "deletions": 67}, "files": [{"sha": "2de8079a4dfb45b4565943e265659041e4d04212", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 63, "deletions": 67, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/d0934f14c7fd95c0517c98a2c0dc549ec40b03e7/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d0934f14c7fd95c0517c98a2c0dc549ec40b03e7/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=d0934f14c7fd95c0517c98a2c0dc549ec40b03e7", "patch": "@@ -917,84 +917,80 @@ impl<'tcx> MutVisitor<'tcx> for ConstPropagator<'_, 'tcx> {\n         trace!(\"visit_statement: {:?}\", statement);\n         let source_info = statement.source_info;\n         self.source_info = Some(source_info);\n-        if let StatementKind::Assign(box (place, ref mut rval)) = statement.kind {\n-            let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n-            if let Some(()) = self.const_prop(rval, place) {\n-                // This will return None if the above `const_prop` invocation only \"wrote\" a\n-                // type whose creation requires no write. E.g. a generator whose initial state\n-                // consists solely of uninitialized memory (so it doesn't capture any locals).\n-                if let Some(ref value) = self.get_const(place) && self.should_const_prop(value) {\n-                    trace!(\"replacing {:?} with {:?}\", rval, value);\n-                    self.replace_with_const(rval, value, source_info);\n-                    if can_const_prop == ConstPropMode::FullConstProp\n-                        || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n-                    {\n-                        trace!(\"propagated into {:?}\", place);\n+        match statement.kind {\n+            StatementKind::Assign(box (place, ref mut rval)) => {\n+                let can_const_prop = self.ecx.machine.can_const_prop[place.local];\n+                if let Some(()) = self.const_prop(rval, place) {\n+                    // This will return None if the above `const_prop` invocation only \"wrote\" a\n+                    // type whose creation requires no write. E.g. a generator whose initial state\n+                    // consists solely of uninitialized memory (so it doesn't capture any locals).\n+                    if let Some(ref value) = self.get_const(place) && self.should_const_prop(value) {\n+                        trace!(\"replacing {:?} with {:?}\", rval, value);\n+                        self.replace_with_const(rval, value, source_info);\n+                        if can_const_prop == ConstPropMode::FullConstProp\n+                            || can_const_prop == ConstPropMode::OnlyInsideOwnBlock\n+                        {\n+                            trace!(\"propagated into {:?}\", place);\n+                        }\n                     }\n-                }\n-                match can_const_prop {\n-                    ConstPropMode::OnlyInsideOwnBlock => {\n-                        trace!(\n-                            \"found local restricted to its block. \\\n+                    match can_const_prop {\n+                        ConstPropMode::OnlyInsideOwnBlock => {\n+                            trace!(\n+                                \"found local restricted to its block. \\\n                                 Will remove it from const-prop after block is finished. Local: {:?}\",\n-                            place.local\n-                        );\n-                    }\n-                    ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                        trace!(\"can't propagate into {:?}\", place);\n-                        if place.local != RETURN_PLACE {\n-                            Self::remove_const(&mut self.ecx, place.local);\n+                                place.local\n+                            );\n                         }\n-                    }\n-                    ConstPropMode::FullConstProp => {}\n-                }\n-            } else {\n-                // Const prop failed, so erase the destination, ensuring that whatever happens\n-                // from here on, does not know about the previous value.\n-                // This is important in case we have\n-                // ```rust\n-                // let mut x = 42;\n-                // x = SOME_MUTABLE_STATIC;\n-                // // x must now be uninit\n-                // ```\n-                // FIXME: we overzealously erase the entire local, because that's easier to\n-                // implement.\n-                trace!(\n-                    \"propagation into {:?} failed.\n-                        Nuking the entire site from orbit, it's the only way to be sure\",\n-                    place,\n-                );\n-                Self::remove_const(&mut self.ecx, place.local);\n-            }\n-        } else {\n-            match statement.kind {\n-                StatementKind::SetDiscriminant { ref place, .. } => {\n-                    match self.ecx.machine.can_const_prop[place.local] {\n-                        ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n-                            if self.use_ecx(|this| this.ecx.statement(statement)).is_some() {\n-                                trace!(\"propped discriminant into {:?}\", place);\n-                            } else {\n+                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n+                            trace!(\"can't propagate into {:?}\", place);\n+                            if place.local != RETURN_PLACE {\n                                 Self::remove_const(&mut self.ecx, place.local);\n                             }\n                         }\n-                        ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n-                            Self::remove_const(&mut self.ecx, place.local);\n-                        }\n+                        ConstPropMode::FullConstProp => {}\n                     }\n+                } else {\n+                    // Const prop failed, so erase the destination, ensuring that whatever happens\n+                    // from here on, does not know about the previous value.\n+                    // This is important in case we have\n+                    // ```rust\n+                    // let mut x = 42;\n+                    // x = SOME_MUTABLE_STATIC;\n+                    // // x must now be uninit\n+                    // ```\n+                    // FIXME: we overzealously erase the entire local, because that's easier to\n+                    // implement.\n+                    trace!(\n+                        \"propagation into {:?} failed.\n+                        Nuking the entire site from orbit, it's the only way to be sure\",\n+                        place,\n+                    );\n+                    Self::remove_const(&mut self.ecx, place.local);\n                 }\n-                StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n-                    let frame = self.ecx.frame_mut();\n-                    frame.locals[local].value =\n-                        if let StatementKind::StorageLive(_) = statement.kind {\n-                            LocalValue::Live(interpret::Operand::Immediate(\n-                                interpret::Immediate::Uninit,\n-                            ))\n+            }\n+            StatementKind::SetDiscriminant { ref place, .. } => {\n+                match self.ecx.machine.can_const_prop[place.local] {\n+                    ConstPropMode::FullConstProp | ConstPropMode::OnlyInsideOwnBlock => {\n+                        if self.use_ecx(|this| this.ecx.statement(statement)).is_some() {\n+                            trace!(\"propped discriminant into {:?}\", place);\n                         } else {\n-                            LocalValue::Dead\n-                        };\n+                            Self::remove_const(&mut self.ecx, place.local);\n+                        }\n+                    }\n+                    ConstPropMode::OnlyPropagateInto | ConstPropMode::NoPropagation => {\n+                        Self::remove_const(&mut self.ecx, place.local);\n+                    }\n                 }\n-                _ => {}\n             }\n+            StatementKind::StorageLive(local) | StatementKind::StorageDead(local) => {\n+                let frame = self.ecx.frame_mut();\n+                frame.locals[local].value = if let StatementKind::StorageLive(_) = statement.kind {\n+                    LocalValue::Live(interpret::Operand::Immediate(interpret::Immediate::Uninit))\n+                } else {\n+                    LocalValue::Dead\n+                };\n+            }\n+            _ => {}\n         }\n \n         self.super_statement(statement, location);"}]}