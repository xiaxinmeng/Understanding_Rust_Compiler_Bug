{"sha": "dcb4378e18571fa01e20ef63820d960f1c2cc865", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjYjQzNzhlMTg1NzFmYTAxZTIwZWY2MzgyMGQ5NjBmMWMyY2M4NjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-25T09:01:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-25T09:01:53Z"}, "message": "Auto merge of #44646 - petrochenkov:scompress, r=michaelwoerister\n\nCompress most of spans to 32 bits\n\nAs described in https://internals.rust-lang.org/t/rfc-compiler-refactoring-spans/1357/28\n\nCloses https://github.com/rust-lang/rust/issues/15594\nr? @michaelwoerister", "tree": {"sha": "02da3710751084628f99d78367cd1e37582ef2ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02da3710751084628f99d78367cd1e37582ef2ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcb4378e18571fa01e20ef63820d960f1c2cc865", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcb4378e18571fa01e20ef63820d960f1c2cc865", "html_url": "https://github.com/rust-lang/rust/commit/dcb4378e18571fa01e20ef63820d960f1c2cc865", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcb4378e18571fa01e20ef63820d960f1c2cc865/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd93969ec4fb2d0bc2b5376aec269cf08491187b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd93969ec4fb2d0bc2b5376aec269cf08491187b", "html_url": "https://github.com/rust-lang/rust/commit/cd93969ec4fb2d0bc2b5376aec269cf08491187b"}, {"sha": "52251cd930dca697804b0c7c1582671683cc6a6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/52251cd930dca697804b0c7c1582671683cc6a6c", "html_url": "https://github.com/rust-lang/rust/commit/52251cd930dca697804b0c7c1582671683cc6a6c"}], "stats": {"total": 220, "additions": 188, "deletions": 32}, "files": [{"sha": "581f47dc13cdf466415b57b6e34ff54beb2a3e79", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcb4378e18571fa01e20ef63820d960f1c2cc865/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb4378e18571fa01e20ef63820d960f1c2cc865/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=dcb4378e18571fa01e20ef63820d960f1c2cc865", "patch": "@@ -221,7 +221,7 @@ macro_rules! define_maps {\n \n                 profq_msg!(tcx,\n                     ProfileQueriesMsg::QueryBegin(\n-                        span.clone(),\n+                        span.data(),\n                         QueryMsg::$name(profq_key!(tcx, key))\n                     )\n                 );"}, {"sha": "9e566d2b9071f46d1dccb28c259707dc14cb9a3c", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcb4378e18571fa01e20ef63820d960f1c2cc865/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb4378e18571fa01e20ef63820d960f1c2cc865/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=dcb4378e18571fa01e20ef63820d960f1c2cc865", "patch": "@@ -20,7 +20,7 @@ use std::path::Path;\n use std::time::{Duration, Instant};\n \n use std::sync::mpsc::{Sender};\n-use syntax_pos::{Span};\n+use syntax_pos::{SpanData};\n use ty::maps::{QueryMsg};\n use dep_graph::{DepNode};\n \n@@ -61,7 +61,8 @@ pub enum ProfileQueriesMsg {\n     /// end a task\n     TaskEnd,\n     /// begin a new query\n-    QueryBegin(Span, QueryMsg),\n+    /// can't use `Span` because queries are sent to other thread\n+    QueryBegin(SpanData, QueryMsg),\n     /// query is satisfied by using an already-known value for the given key\n     CacheHit,\n     /// query requires running a provider; providers may nest, permitting queries to nest."}, {"sha": "280f3c8c79677d26e1228e506fa85db151fe9f3c", "filename": "src/librustc_driver/profile/trace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcb4378e18571fa01e20ef63820d960f1c2cc865/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb4378e18571fa01e20ef63820d960f1c2cc865/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs?ref=dcb4378e18571fa01e20ef63820d960f1c2cc865", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use super::*;\n-use syntax_pos::Span;\n+use syntax_pos::SpanData;\n use rustc::ty::maps::QueryMsg;\n use std::fs::File;\n use std::time::{Duration, Instant};\n@@ -18,7 +18,7 @@ use rustc::dep_graph::{DepNode};\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct Query {\n-    pub span: Span,\n+    pub span: SpanData,\n     pub msg: QueryMsg,\n }\n pub enum Effect {"}, {"sha": "4790fa0a7edc2ed430640f4bc0ce21d742ec58b9", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcb4378e18571fa01e20ef63820d960f1c2cc865/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb4378e18571fa01e20ef63820d960f1c2cc865/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=dcb4378e18571fa01e20ef63820d960f1c2cc865", "patch": "@@ -25,7 +25,7 @@ use std::fmt;\n \n /// A SyntaxContext represents a chain of macro expansions (represented by marks).\n #[derive(Clone, Copy, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n-pub struct SyntaxContext(u32);\n+pub struct SyntaxContext(pub(super) u32);\n \n #[derive(Copy, Clone, Default)]\n pub struct SyntaxContextData {"}, {"sha": "582f27981813417d7bcd3cd97d45e3441cf5c201", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/dcb4378e18571fa01e20ef63820d960f1c2cc865/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb4378e18571fa01e20ef63820d960f1c2cc865/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=dcb4378e18571fa01e20ef63820d960f1c2cc865", "patch": "@@ -25,11 +25,10 @@\n #![feature(optin_builtin_traits)]\n #![allow(unused_attributes)]\n #![feature(specialization)]\n-#![feature(staged_api)]\n \n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n-use std::cmp;\n+use std::cmp::{self, Ordering};\n use std::fmt;\n use std::hash::Hasher;\n use std::ops::{Add, Sub};\n@@ -47,6 +46,9 @@ extern crate serialize as rustc_serialize; // used by deriving\n pub mod hygiene;\n pub use hygiene::{SyntaxContext, ExpnInfo, ExpnFormat, NameAndSpan, CompilerDesugaringKind};\n \n+mod span_encoding;\n+pub use span_encoding::{Span, DUMMY_SP};\n+\n pub mod symbol;\n \n pub type FileName = String;\n@@ -59,23 +61,33 @@ pub type FileName = String;\n /// able to use many of the functions on spans in codemap and you cannot assume\n /// that the length of the span = hi - lo; there may be space in the BytePos\n /// range between files.\n+///\n+/// `SpanData` is public because `Span` uses a thread-local interner and can't be\n+/// sent to other threads, but some pieces of performance infra run in a separate thread.\n+/// Using `Span` is generally preferred.\n #[derive(Clone, Copy, Hash, PartialEq, Eq, Ord, PartialOrd)]\n-pub struct Span {\n-    #[unstable(feature = \"rustc_private\", issue = \"27812\")]\n-    #[rustc_deprecated(since = \"1.21\", reason = \"use getters/setters instead\")]\n+pub struct SpanData {\n     pub lo: BytePos,\n-    #[unstable(feature = \"rustc_private\", issue = \"27812\")]\n-    #[rustc_deprecated(since = \"1.21\", reason = \"use getters/setters instead\")]\n     pub hi: BytePos,\n     /// Information about where the macro came from, if this piece of\n     /// code was created by a macro expansion.\n-    #[unstable(feature = \"rustc_private\", issue = \"27812\")]\n-    #[rustc_deprecated(since = \"1.21\", reason = \"use getters/setters instead\")]\n     pub ctxt: SyntaxContext,\n }\n \n-#[allow(deprecated)]\n-pub const DUMMY_SP: Span = Span { lo: BytePos(0), hi: BytePos(0), ctxt: NO_EXPANSION };\n+// The interner in thread-local, so `Span` shouldn't move between threads.\n+impl !Send for Span {}\n+impl !Sync for Span {}\n+\n+impl PartialOrd for Span {\n+    fn partial_cmp(&self, rhs: &Self) -> Option<Ordering> {\n+        PartialOrd::partial_cmp(&self.data(), &rhs.data())\n+    }\n+}\n+impl Ord for Span {\n+    fn cmp(&self, rhs: &Self) -> Ordering {\n+        Ord::cmp(&self.data(), &rhs.data())\n+    }\n+}\n \n /// A collection of spans. Spans have two orthogonal attributes:\n ///\n@@ -90,38 +102,32 @@ pub struct MultiSpan {\n }\n \n impl Span {\n-    #[allow(deprecated)]\n-    #[inline]\n-    pub fn new(lo: BytePos, hi: BytePos, ctxt: SyntaxContext) -> Self {\n-        if lo <= hi { Span { lo, hi, ctxt } } else { Span { lo: hi, hi: lo, ctxt } }\n-    }\n-\n-    #[allow(deprecated)]\n     #[inline]\n     pub fn lo(self) -> BytePos {\n-        self.lo\n+        self.data().lo\n     }\n     #[inline]\n     pub fn with_lo(self, lo: BytePos) -> Span {\n-        Span::new(lo, self.hi(), self.ctxt())\n+        let base = self.data();\n+        Span::new(lo, base.hi, base.ctxt)\n     }\n-    #[allow(deprecated)]\n     #[inline]\n     pub fn hi(self) -> BytePos {\n-        self.hi\n+        self.data().hi\n     }\n     #[inline]\n     pub fn with_hi(self, hi: BytePos) -> Span {\n-        Span::new(self.lo(), hi, self.ctxt())\n+        let base = self.data();\n+        Span::new(base.lo, hi, base.ctxt)\n     }\n-    #[allow(deprecated)]\n     #[inline]\n     pub fn ctxt(self) -> SyntaxContext {\n-        self.ctxt\n+        self.data().ctxt\n     }\n     #[inline]\n     pub fn with_ctxt(self, ctxt: SyntaxContext) -> Span {\n-        Span::new(self.lo(), self.hi(), ctxt)\n+        let base = self.data();\n+        Span::new(base.lo, base.hi, ctxt)\n     }\n \n     /// Returns a new span representing just the end-point of this span\n@@ -342,6 +348,12 @@ impl fmt::Debug for Span {\n     }\n }\n \n+impl fmt::Debug for SpanData {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        SPAN_DEBUG.with(|span_debug| span_debug.get()(Span::new(self.lo, self.hi, self.ctxt), f))\n+    }\n+}\n+\n impl MultiSpan {\n     pub fn new() -> MultiSpan {\n         MultiSpan {"}, {"sha": "c2b32171a9a98313c52f6c6bbbe793b59ffd0959", "filename": "src/libsyntax_pos/span_encoding.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/dcb4378e18571fa01e20ef63820d960f1c2cc865/src%2Flibsyntax_pos%2Fspan_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcb4378e18571fa01e20ef63820d960f1c2cc865/src%2Flibsyntax_pos%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fspan_encoding.rs?ref=dcb4378e18571fa01e20ef63820d960f1c2cc865", "patch": "@@ -0,0 +1,143 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Spans are encoded using 1-bit tag and 2 different encoding formats (one for each tag value).\n+// One format is used for keeping span data inline,\n+// another contains index into an out-of-line span interner.\n+// The encoding format for inline spans were obtained by optimizing over crates in rustc/libstd.\n+// See https://internals.rust-lang.org/t/rfc-compiler-refactoring-spans/1357/28\n+\n+use {BytePos, SpanData};\n+use hygiene::SyntaxContext;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use std::cell::RefCell;\n+\n+/// A compressed span.\n+/// Contains either fields of `SpanData` inline if they are small, or index into span interner.\n+/// The primary goal of `Span` is to be as small as possible and fit into other structures\n+/// (that's why it uses `packed` as well). Decoding speed is the second priority.\n+/// See `SpanData` for the info on span fields in decoded representation.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[repr(packed)]\n+pub struct Span(u32);\n+\n+/// Dummy span, both position and length are zero, syntax context is zero as well.\n+/// This span is kept inline and encoded with format 0.\n+pub const DUMMY_SP: Span = Span(0);\n+\n+impl Span {\n+    #[inline]\n+    pub fn new(lo: BytePos, hi: BytePos, ctxt: SyntaxContext) -> Self {\n+        encode(&match lo <= hi {\n+            true => SpanData { lo, hi, ctxt },\n+            false => SpanData { lo: hi, hi: lo, ctxt },\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn data(self) -> SpanData {\n+        decode(self)\n+    }\n+}\n+\n+// Tags\n+const TAG_INLINE: u32 = 0;\n+const TAG_INTERNED: u32 = 1;\n+const TAG_MASK: u32 = 1;\n+\n+// Fields indexes\n+const BASE_INDEX: usize = 0;\n+const LEN_INDEX: usize = 1;\n+const CTXT_INDEX: usize = 2;\n+\n+// Tag = 0, inline format.\n+// -----------------------------------\n+// | base 31:8  | len 7:1  | tag 0:0 |\n+// -----------------------------------\n+const INLINE_SIZES: [u32; 3] = [24, 7, 0];\n+const INLINE_OFFSETS: [u32; 3] = [8, 1, 1];\n+\n+// Tag = 1, interned format.\n+// ------------------------\n+// | index 31:1 | tag 0:0 |\n+// ------------------------\n+const INTERNED_INDEX_SIZE: u32 = 31;\n+const INTERNED_INDEX_OFFSET: u32 = 1;\n+\n+#[inline]\n+fn encode(sd: &SpanData) -> Span {\n+    let (base, len, ctxt) = (sd.lo.0, sd.hi.0 - sd.lo.0, sd.ctxt.0);\n+\n+    let val = if (base >> INLINE_SIZES[BASE_INDEX]) == 0 &&\n+                 (len >> INLINE_SIZES[LEN_INDEX]) == 0 &&\n+                 (ctxt >> INLINE_SIZES[CTXT_INDEX]) == 0 {\n+        (base << INLINE_OFFSETS[BASE_INDEX]) | (len << INLINE_OFFSETS[LEN_INDEX]) |\n+        (ctxt << INLINE_OFFSETS[CTXT_INDEX]) | TAG_INLINE\n+    } else {\n+        let index = with_span_interner(|interner| interner.intern(sd));\n+        (index << INTERNED_INDEX_OFFSET) | TAG_INTERNED\n+    };\n+    Span(val)\n+}\n+\n+#[inline]\n+fn decode(span: Span) -> SpanData {\n+    let val = span.0;\n+\n+    // Extract a field at position `pos` having size `size`.\n+    let extract = |pos: u32, size: u32| {\n+        let mask = ((!0u32) as u64 >> (32 - size)) as u32; // Can't shift u32 by 32\n+        (val >> pos) & mask\n+    };\n+\n+    let (base, len, ctxt) = if val & TAG_MASK == TAG_INLINE {(\n+        extract(INLINE_OFFSETS[BASE_INDEX], INLINE_SIZES[BASE_INDEX]),\n+        extract(INLINE_OFFSETS[LEN_INDEX], INLINE_SIZES[LEN_INDEX]),\n+        extract(INLINE_OFFSETS[CTXT_INDEX], INLINE_SIZES[CTXT_INDEX]),\n+    )} else {\n+        let index = extract(INTERNED_INDEX_OFFSET, INTERNED_INDEX_SIZE);\n+        return with_span_interner(|interner| *interner.get(index));\n+    };\n+    SpanData { lo: BytePos(base), hi: BytePos(base + len), ctxt: SyntaxContext(ctxt) }\n+}\n+\n+#[derive(Default)]\n+struct SpanInterner {\n+    spans: FxHashMap<SpanData, u32>,\n+    span_data: Vec<SpanData>,\n+}\n+\n+impl SpanInterner {\n+    fn intern(&mut self, span_data: &SpanData) -> u32 {\n+        if let Some(index) = self.spans.get(span_data) {\n+            return *index;\n+        }\n+\n+        let index = self.spans.len() as u32;\n+        self.span_data.push(*span_data);\n+        self.spans.insert(*span_data, index);\n+        index\n+    }\n+\n+    #[inline]\n+    fn get(&self, index: u32) -> &SpanData {\n+        &self.span_data[index as usize]\n+    }\n+}\n+\n+// If an interner exists in TLS, return it. Otherwise, prepare a fresh one.\n+#[inline]\n+fn with_span_interner<T, F: FnOnce(&mut SpanInterner) -> T>(f: F) -> T {\n+    thread_local!(static INTERNER: RefCell<SpanInterner> = {\n+        RefCell::new(SpanInterner::default())\n+    });\n+    INTERNER.with(|interner| f(&mut *interner.borrow_mut()))\n+}"}]}