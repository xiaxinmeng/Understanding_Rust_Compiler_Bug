{"sha": "3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiMGI5ZTBlMDYxNzZhNmU0ZjQ5YWE2YzFhZWM4OGVkZTkwNGJhMTE=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-02-08T22:48:11Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-02-08T22:51:30Z"}, "message": "Merge remote-tracking branch 'origin/master' into regex_macro", "tree": {"sha": "76ebfc07214c1157207e19e9597f53e3b90e4e1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76ebfc07214c1157207e19e9597f53e3b90e4e1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "html_url": "https://github.com/rust-lang/rust/commit/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "652547121490c642f033668043711ba7009b8169", "url": "https://api.github.com/repos/rust-lang/rust/commits/652547121490c642f033668043711ba7009b8169", "html_url": "https://github.com/rust-lang/rust/commit/652547121490c642f033668043711ba7009b8169"}, {"sha": "d68dc8e25a85819c7ef5679ef6d98c049457238f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d68dc8e25a85819c7ef5679ef6d98c049457238f", "html_url": "https://github.com/rust-lang/rust/commit/d68dc8e25a85819c7ef5679ef6d98c049457238f"}], "stats": {"total": 738, "additions": 611, "deletions": 127}, "files": [{"sha": "cbb8646c672386c31db95569dfff1af3962976cb", "filename": "README.md", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 113 lints included in this crate:\n+There are 117 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -34,6 +34,7 @@ name\n [drop_ref](https://github.com/Manishearth/rust-clippy/wiki#drop_ref)                                           | warn    | call to `std::mem::drop` with a reference instead of an owned value, which will not call the `Drop::drop` method on the underlying value\n [duplicate_underscore_argument](https://github.com/Manishearth/rust-clippy/wiki#duplicate_underscore_argument) | warn    | Function arguments having names which only differ by an underscore\n [empty_loop](https://github.com/Manishearth/rust-clippy/wiki#empty_loop)                                       | warn    | empty `loop {}` detected\n+[enum_glob_use](https://github.com/Manishearth/rust-clippy/wiki#enum_glob_use)                                 | allow   | finds use items that import all variants of an enum\n [enum_variant_names](https://github.com/Manishearth/rust-clippy/wiki#enum_variant_names)                       | warn    | finds enums where all variants share a prefix/postfix\n [eq_op](https://github.com/Manishearth/rust-clippy/wiki#eq_op)                                                 | warn    | equal operands on both sides of a comparison or bitwise combination (e.g. `x == x`)\n [expl_impl_clone_on_copy](https://github.com/Manishearth/rust-clippy/wiki#expl_impl_clone_on_copy)             | warn    | implementing `Clone` explicitly on `Copy` types\n@@ -46,6 +47,8 @@ name\n [for_loop_over_option](https://github.com/Manishearth/rust-clippy/wiki#for_loop_over_option)                   | warn    | for-looping over an `Option`, which is more clearly expressed as an `if let`\n [for_loop_over_result](https://github.com/Manishearth/rust-clippy/wiki#for_loop_over_result)                   | warn    | for-looping over a `Result`, which is more clearly expressed as an `if let`\n [identity_op](https://github.com/Manishearth/rust-clippy/wiki#identity_op)                                     | warn    | using identity operations, e.g. `x + 0` or `y / 1`\n+[if_same_then_else](https://github.com/Manishearth/rust-clippy/wiki#if_same_then_else)                         | warn    | if with the same *then* and *else* blocks\n+[ifs_same_cond](https://github.com/Manishearth/rust-clippy/wiki#ifs_same_cond)                                 | warn    | consecutive `ifs` with the same condition\n [ineffective_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#ineffective_bit_mask)                   | warn    | expressions where a bit mask will be rendered useless by a comparison, e.g. `(x | 1) > 2`\n [inline_always](https://github.com/Manishearth/rust-clippy/wiki#inline_always)                                 | warn    | `#[inline(always)]` is a bad idea in most cases\n [invalid_regex](https://github.com/Manishearth/rust-clippy/wiki#invalid_regex)                                 | deny    | finds invalid regular expressions in `Regex::new(_)` invocations\n@@ -88,6 +91,7 @@ name\n [range_zip_with_len](https://github.com/Manishearth/rust-clippy/wiki#range_zip_with_len)                       | warn    | zipping iterator with a range when enumerate() would do\n [redundant_closure](https://github.com/Manishearth/rust-clippy/wiki#redundant_closure)                         | warn    | using redundant closures, i.e. `|a| foo(a)` (which can be written as just `foo`)\n [redundant_pattern](https://github.com/Manishearth/rust-clippy/wiki#redundant_pattern)                         | warn    | using `name @ _` in a pattern\n+[regex_macro](https://github.com/Manishearth/rust-clippy/wiki#regex_macro)                                     | warn    | finds use of `regex!(_)`, suggests `Regex::new(_)` instead\n [result_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#result_unwrap_used)                       | allow   | using `Result.unwrap()`, which might be better handled\n [reverse_range_loop](https://github.com/Manishearth/rust-clippy/wiki#reverse_range_loop)                       | warn    | Iterating over an empty range, such as `10..0` or `5..5`\n [search_is_some](https://github.com/Manishearth/rust-clippy/wiki#search_is_some)                               | warn    | using an iterator search followed by `is_some()`, which is more succinctly expressed as a call to `any()`"}, {"sha": "d18785ab81859cdd56f150ecf7afdd1ec099641c", "filename": "src/approx_const.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fapprox_const.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -2,9 +2,7 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use std::f64::consts as f64;\n use utils::span_lint;\n-use syntax::ast::Lit_::*;\n-use syntax::ast::Lit;\n-use syntax::ast::FloatTy::*;\n+use syntax::ast::{Lit, Lit_, FloatTy};\n \n /// **What it does:** This lint checks for floating point literals that approximate constants which are defined in [`std::f32::consts`](https://doc.rust-lang.org/stable/std/f32/consts/#constants) or [`std::f64::consts`](https://doc.rust-lang.org/stable/std/f64/consts/#constants), respectively, suggesting to use the predefined constant.\n ///\n@@ -57,9 +55,9 @@ impl LateLintPass for ApproxConstant {\n \n fn check_lit(cx: &LateContext, lit: &Lit, e: &Expr) {\n     match lit.node {\n-        LitFloat(ref s, TyF32) => check_known_consts(cx, e, s, \"f32\"),\n-        LitFloat(ref s, TyF64) => check_known_consts(cx, e, s, \"f64\"),\n-        LitFloatUnsuffixed(ref s) => check_known_consts(cx, e, s, \"f{32, 64}\"),\n+        Lit_::LitFloat(ref s, FloatTy::TyF32) => check_known_consts(cx, e, s, \"f32\"),\n+        Lit_::LitFloat(ref s, FloatTy::TyF64) => check_known_consts(cx, e, s, \"f64\"),\n+        Lit_::LitFloatUnsuffixed(ref s) => check_known_consts(cx, e, s, \"f{32, 64}\"),\n         _ => (),\n     }\n }"}, {"sha": "6de00167571b37868bd3055a7930a39e299e8352", "filename": "src/bit_mask.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -4,7 +4,7 @@ use rustc::middle::def::{Def, PathResolution};\n use rustc_front::hir::*;\n use rustc_front::util::is_comparison_binop;\n use syntax::codemap::Span;\n-use syntax::ast::Lit_::*;\n+use syntax::ast::Lit_;\n \n use utils::span_lint;\n \n@@ -254,7 +254,7 @@ fn check_ineffective_gt(cx: &LateContext, span: Span, m: u64, c: u64, op: &str)\n fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u64> {\n     match lit.node {\n         ExprLit(ref lit_ptr) => {\n-            if let LitInt(value, _) = lit_ptr.node {\n+            if let Lit_::LitInt(value, _) = lit_ptr.node {\n                 Some(value) //TODO: Handle sign\n             } else {\n                 None"}, {"sha": "5f40aff92cce5a40423568b16ce6400ba6dfe3c7", "filename": "src/consts.rs", "status": "modified", "additions": 42, "deletions": 68, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -12,14 +12,10 @@ use std::cmp::Ordering::{self, Greater, Less, Equal};\n use std::rc::Rc;\n use std::ops::Deref;\n use std::fmt;\n-use self::FloatWidth::*;\n \n-use syntax::ast::Lit_::*;\n use syntax::ast::Lit_;\n-use syntax::ast::LitIntType::*;\n use syntax::ast::LitIntType;\n use syntax::ast::{UintTy, FloatTy, StrStyle};\n-use syntax::ast::FloatTy::*;\n use syntax::ast::Sign::{self, Plus, Minus};\n \n \n@@ -33,8 +29,8 @@ pub enum FloatWidth {\n impl From<FloatTy> for FloatWidth {\n     fn from(ty: FloatTy) -> FloatWidth {\n         match ty {\n-            TyF32 => Fw32,\n-            TyF64 => Fw64,\n+            FloatTy::TyF32 => FloatWidth::Fw32,\n+            FloatTy::TyF64 => FloatWidth::Fw64,\n         }\n     }\n }\n@@ -107,6 +103,7 @@ impl PartialEq for Constant {\n                 lv == rv && (is_negative(lty) & (lv != 0)) == (is_negative(rty) & (rv != 0))\n             }\n             (&Constant::Float(ref ls, lw), &Constant::Float(ref rs, rw)) => {\n+                use self::FloatWidth::*;\n                 if match (lw, rw) {\n                     (FwAny, _) | (_, FwAny) | (Fw32, Fw32) | (Fw64, Fw64) => true,\n                     _ => false,\n@@ -149,6 +146,7 @@ impl PartialOrd for Constant {\n                 })\n             }\n             (&Constant::Float(ref ls, lw), &Constant::Float(ref rs, rw)) => {\n+                use self::FloatWidth::*;\n                 if match (lw, rw) {\n                     (FwAny, _) | (_, FwAny) | (Fw32, Fw32) | (Fw64, Fw64) => true,\n                     _ => false,\n@@ -261,76 +259,51 @@ impl fmt::Display for Constant {\n \n fn lit_to_constant(lit: &Lit_) -> Constant {\n     match *lit {\n-        LitStr(ref is, style) => Constant::Str(is.to_string(), style),\n-        LitByte(b) => Constant::Byte(b),\n-        LitByteStr(ref s) => Constant::Binary(s.clone()),\n-        LitChar(c) => Constant::Char(c),\n-        LitInt(value, ty) => Constant::Int(value, ty),\n-        LitFloat(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n-        LitFloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FwAny),\n-        LitBool(b) => Constant::Bool(b),\n+        Lit_::LitStr(ref is, style) => Constant::Str(is.to_string(), style),\n+        Lit_::LitByte(b) => Constant::Byte(b),\n+        Lit_::LitByteStr(ref s) => Constant::Binary(s.clone()),\n+        Lit_::LitChar(c) => Constant::Char(c),\n+        Lit_::LitInt(value, ty) => Constant::Int(value, ty),\n+        Lit_::LitFloat(ref is, ty) => Constant::Float(is.to_string(), ty.into()),\n+        Lit_::LitFloatUnsuffixed(ref is) => Constant::Float(is.to_string(), FloatWidth::FwAny),\n+        Lit_::LitBool(b) => Constant::Bool(b),\n     }\n }\n \n fn constant_not(o: Constant) -> Option<Constant> {\n-    Some(match o {\n-        Constant::Bool(b) => Constant::Bool(!b),\n-        Constant::Int(value, ty) => {\n-            let (nvalue, nty) = match ty {\n-                SignedIntLit(ity, Plus) => {\n-                    if value == ::std::u64::MAX {\n-                        return None;\n-                    }\n-                    (value + 1, SignedIntLit(ity, Minus))\n-                }\n-                SignedIntLit(ity, Minus) => {\n-                    if value == 0 {\n-                        (1, SignedIntLit(ity, Minus))\n-                    } else {\n-                        (value - 1, SignedIntLit(ity, Plus))\n-                    }\n-                }\n-                UnsignedIntLit(ity) => {\n-                    let mask = match ity {\n-                        UintTy::TyU8 => ::std::u8::MAX as u64,\n-                        UintTy::TyU16 => ::std::u16::MAX as u64,\n-                        UintTy::TyU32 => ::std::u32::MAX as u64,\n-                        UintTy::TyU64 => ::std::u64::MAX,\n-                        UintTy::TyUs => {\n-                            return None;\n-                        }  // refuse to guess\n-                    };\n-                    (!value & mask, UnsignedIntLit(ity))\n-                }\n-                UnsuffixedIntLit(_) => {\n+    use syntax::ast::LitIntType::*;\n+    use self::Constant::*;\n+    match o {\n+        Bool(b) => Some(Bool(!b)),\n+        Int(::std::u64::MAX, SignedIntLit(_, Plus)) => None,\n+        Int(value, SignedIntLit(ity, Plus)) => Some(Int(value + 1, SignedIntLit(ity, Minus))),\n+        Int(0, SignedIntLit(ity, Minus)) => Some(Int(1, SignedIntLit(ity, Minus))),\n+        Int(value, SignedIntLit(ity, Minus)) => Some(Int(value - 1, SignedIntLit(ity, Plus))),\n+        Int(value, UnsignedIntLit(ity)) => {\n+            let mask = match ity {\n+                UintTy::TyU8 => ::std::u8::MAX as u64,\n+                UintTy::TyU16 => ::std::u16::MAX as u64,\n+                UintTy::TyU32 => ::std::u32::MAX as u64,\n+                UintTy::TyU64 => ::std::u64::MAX,\n+                UintTy::TyUs => {\n                     return None;\n                 }  // refuse to guess\n             };\n-            Constant::Int(nvalue, nty)\n-        }\n-        _ => {\n-            return None;\n-        }\n-    })\n+            Some(Int(!value & mask, UnsignedIntLit(ity)))\n+        },\n+        _ => None,\n+    }\n }\n \n fn constant_negate(o: Constant) -> Option<Constant> {\n-    Some(match o {\n-        Constant::Int(value, ty) => {\n-            Constant::Int(value,\n-                        match ty {\n-                            SignedIntLit(ity, sign) => SignedIntLit(ity, neg_sign(sign)),\n-                            UnsuffixedIntLit(sign) => UnsuffixedIntLit(neg_sign(sign)),\n-                            _ => {\n-                                return None;\n-                            }\n-                        })\n-        }\n-        Constant::Float(is, ty) => Constant::Float(neg_float_str(is), ty),\n-        _ => {\n-            return None;\n-        }\n-    })\n+    use syntax::ast::LitIntType::*;\n+    use self::Constant::*;\n+    match o {\n+        Int(value, SignedIntLit(ity, sign)) => Some(Int(value, SignedIntLit(ity, neg_sign(sign)))),\n+        Int(value, UnsuffixedIntLit(sign)) => Some(Int(value, UnsuffixedIntLit(neg_sign(sign)))),\n+        Float(is, ty) => Some(Float(neg_float_str(is), ty)),\n+        _ => None,\n+    }\n }\n \n fn neg_sign(s: Sign) -> Sign {\n@@ -357,12 +330,13 @@ fn neg_float_str(s: String) -> String {\n /// ```\n pub fn is_negative(ty: LitIntType) -> bool {\n     match ty {\n-        SignedIntLit(_, sign) | UnsuffixedIntLit(sign) => sign == Minus,\n-        UnsignedIntLit(_) => false,\n+        LitIntType::SignedIntLit(_, sign) | LitIntType::UnsuffixedIntLit(sign) => sign == Minus,\n+        LitIntType::UnsignedIntLit(_) => false,\n     }\n }\n \n fn unify_int_type(l: LitIntType, r: LitIntType, s: Sign) -> Option<LitIntType> {\n+    use syntax::ast::LitIntType::*;\n     match (l, r) {\n         (SignedIntLit(lty, _), SignedIntLit(rty, _)) => {\n             if lty == rty {"}, {"sha": "525c7b7a6fde2e8acd5c6209deef94f69447bab6", "filename": "src/copies.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcopies.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -0,0 +1,102 @@\n+use rustc::lint::*;\n+use rustc_front::hir::*;\n+use utils::{get_parent_expr, in_macro, is_block_equal, is_exp_equal, span_lint, span_note_and_lint};\n+\n+/// **What it does:** This lint checks for consecutive `ifs` with the same condition. This lint is\n+/// `Warn` by default.\n+///\n+/// **Why is this bad?** This is probably a copy & paste error.\n+///\n+/// **Known problems:** Hopefully none.\n+///\n+/// **Example:** `if a == b { .. } else if a == b { .. }`\n+declare_lint! {\n+    pub IFS_SAME_COND,\n+    Warn,\n+    \"consecutive `ifs` with the same condition\"\n+}\n+\n+/// **What it does:** This lint checks for `if/else` with the same body as the *then* part and the\n+/// *else* part. This lint is `Warn` by default.\n+///\n+/// **Why is this bad?** This is probably a copy & paste error.\n+///\n+/// **Known problems:** Hopefully none.\n+///\n+/// **Example:** `if .. { 42 } else { 42 }`\n+declare_lint! {\n+    pub IF_SAME_THEN_ELSE,\n+    Warn,\n+    \"if with the same *then* and *else* blocks\"\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct CopyAndPaste;\n+\n+impl LintPass for CopyAndPaste {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array![\n+            IFS_SAME_COND,\n+            IF_SAME_THEN_ELSE\n+        ]\n+    }\n+}\n+\n+impl LateLintPass for CopyAndPaste {\n+    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        if !in_macro(cx, expr.span) {\n+            lint_same_then_else(cx, expr);\n+            lint_same_cond(cx, expr);\n+        }\n+    }\n+}\n+\n+/// Implementation of `IF_SAME_THEN_ELSE`.\n+fn lint_same_then_else(cx: &LateContext, expr: &Expr) {\n+    if let ExprIf(_, ref then_block, Some(ref else_expr)) = expr.node {\n+        if let ExprBlock(ref else_block) = else_expr.node {\n+            if is_block_equal(cx, &then_block, &else_block, false) {\n+                span_lint(cx, IF_SAME_THEN_ELSE, expr.span, \"this if has the same then and else blocks\");\n+            }\n+        }\n+    }\n+}\n+\n+/// Implementation of `IFS_SAME_COND`.\n+fn lint_same_cond(cx: &LateContext, expr: &Expr) {\n+    // skip ifs directly in else, it will be checked in the parent if\n+    if let Some(&Expr{node: ExprIf(_, _, Some(ref else_expr)), ..}) = get_parent_expr(cx, expr) {\n+        if else_expr.id == expr.id {\n+            return;\n+        }\n+    }\n+\n+    let conds = condition_sequence(expr);\n+\n+    for (n, i) in conds.iter().enumerate() {\n+        for j in conds.iter().skip(n+1) {\n+            if is_exp_equal(cx, i, j, true) {\n+                span_note_and_lint(cx, IFS_SAME_COND, j.span, \"this if has the same condition as a previous if\", i.span, \"same as this\");\n+            }\n+        }\n+    }\n+}\n+\n+/// Return the list of condition expressions in a sequence of `if/else`.\n+/// Eg. would return `[a, b]` for the expression `if a {..} else if b {..}`.\n+fn condition_sequence(mut expr: &Expr) -> Vec<&Expr> {\n+    let mut result = vec![];\n+\n+    while let ExprIf(ref cond, _, ref else_expr) = expr.node {\n+        result.push(&**cond);\n+\n+        if let Some(ref else_expr) = *else_expr {\n+            expr = else_expr;\n+        }\n+        else {\n+            break;\n+        }\n+    }\n+\n+    result\n+}"}, {"sha": "d5bb086fc213712beb89e7a3152035e9f5f69b23", "filename": "src/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fentry.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -89,7 +89,7 @@ fn check_for_insert(cx: &LateContext, span: Span, map: &Expr, key: &Expr, expr:\n             params.len() == 3,\n             name.node.as_str() == \"insert\",\n             get_item_name(cx, map) == get_item_name(cx, &*params[0]),\n-            is_exp_equal(cx, key, &params[1])\n+            is_exp_equal(cx, key, &params[1], false)\n         ], {\n             let help = if sole_expr {\n                 format!(\"{}.entry({}).or_insert({})\","}, {"sha": "c6561461e04f02e933bcbcbb2cc776ea09fcf36a", "filename": "src/enum_glob_use.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fenum_glob_use.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -0,0 +1,63 @@\n+//! lint on `use`ing all variants of an enum\n+\n+use rustc::lint::{LateLintPass, LintPass, LateContext, LintArray, LintContext};\n+use rustc_front::hir::*;\n+use rustc::front::map::Node::NodeItem;\n+use rustc::front::map::definitions::DefPathData;\n+use rustc::middle::ty::TyEnum;\n+use utils::span_lint;\n+use syntax::codemap::Span;\n+use syntax::ast::NodeId;\n+\n+/// **What it does:** Warns when `use`ing all variants of an enum\n+///\n+/// **Why is this bad?** It is usually better style to use the prefixed name of an enum variant, rather than importing variants\n+///\n+/// **Known problems:** Old-style enums that prefix the variants are still around\n+///\n+/// **Example:** `use std::cmp::Ordering::*;`\n+declare_lint! { pub ENUM_GLOB_USE, Allow,\n+    \"finds use items that import all variants of an enum\" }\n+\n+pub struct EnumGlobUse;\n+\n+impl LintPass for EnumGlobUse {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(ENUM_GLOB_USE)\n+    }\n+}\n+\n+impl LateLintPass for EnumGlobUse {\n+    fn check_mod(&mut self, cx: &LateContext, m: &Mod, _: Span, _: NodeId) {\n+        // only check top level `use` statements\n+        for item in &m.item_ids {\n+            self.lint_item(cx, cx.krate.item(item.id));\n+        }\n+    }\n+}\n+\n+impl EnumGlobUse {\n+    fn lint_item(&self, cx: &LateContext, item: &Item) {\n+        if item.vis == Visibility::Public {\n+            return; // re-exports are fine\n+        }\n+        if let ItemUse(ref item_use) = item.node {\n+            if let ViewPath_::ViewPathGlob(_) = item_use.node {\n+                let def = cx.tcx.def_map.borrow()[&item.id];\n+                if let Some(NodeItem(it)) = cx.tcx.map.get_if_local(def.def_id()) {\n+                    if let ItemEnum(..) = it.node {\n+                        span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n+                    }\n+                } else {\n+                    if let Some(dp) = cx.sess().cstore.def_path(def.def_id()).last() {\n+                        if let DefPathData::Type(_) = dp.data {\n+                            if let TyEnum(..) = cx.sess().cstore.item_type(&cx.tcx, def.def_id()).ty.sty {\n+                                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "aecd0693ff1f2acdb31bb1e2904e4de4b77e895e", "filename": "src/eq_op.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -4,9 +4,11 @@ use rustc_front::util as ast_util;\n \n use utils::{is_exp_equal, span_lint};\n \n-/// **What it does:** This lint checks for equal operands to comparisons and bitwise binary operators (`&`, `|` and `^`).\n+/// **What it does:** This lint checks for equal operands to comparison, logical and bitwise,\n+/// difference and division binary operators (`==`, `>`, etc., `&&`, `||`, `&`, `|`, `^`, `-` and\n+/// `/`).\n ///\n-/// **Why is this bad?** This is usually just a typo.\n+/// **Why is this bad?** This is usually just a typo or a copy and paste error.\n ///\n /// **Known problems:** False negatives: We had some false positives regarding calls (notably [racer](https://github.com/phildawes/racer) had one instance of `x.pop() && x.pop()`), so we removed matching any function or method calls. We may introduce a whitelist of known pure functions in the future.\n ///\n@@ -29,19 +31,21 @@ impl LintPass for EqOp {\n impl LateLintPass for EqOp {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n-            if is_cmp_or_bit(op) && is_exp_equal(cx, left, right) {\n+            if is_valid_operator(op) && is_exp_equal(cx, left, right, true) {\n                 span_lint(cx,\n                           EQ_OP,\n                           e.span,\n-                          &format!(\"equal expressions as operands to {}\", ast_util::binop_to_string(op.node)));\n+                          &format!(\"equal expressions as operands to `{}`\", ast_util::binop_to_string(op.node)));\n             }\n         }\n     }\n }\n \n \n-fn is_cmp_or_bit(op: &BinOp) -> bool {\n+fn is_valid_operator(op: &BinOp) -> bool {\n     match op.node {\n+        BiSub |\n+        BiDiv |\n         BiEq |\n         BiLt |\n         BiLe |"}, {"sha": "ea0c873cb5483dd768a447e9d008accc7c378a42", "filename": "src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flen_zero.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -6,8 +6,7 @@ use syntax::codemap::{Span, Spanned};\n use rustc::middle::def_id::DefId;\n use rustc::middle::ty::{self, MethodTraitItemId, ImplOrTraitItemId};\n \n-use syntax::ast::Lit_::*;\n-use syntax::ast::Lit;\n+use syntax::ast::{Lit, Lit_};\n \n use utils::{get_item_name, snippet, span_lint, walk_ptrs_ty};\n \n@@ -152,7 +151,7 @@ fn check_cmp(cx: &LateContext, span: Span, left: &Expr, right: &Expr, op: &str)\n }\n \n fn check_len_zero(cx: &LateContext, span: Span, name: &Name, args: &[P<Expr>], lit: &Lit, op: &str) {\n-    if let Spanned{node: LitInt(0, _), ..} = *lit {\n+    if let Spanned{node: Lit_::LitInt(0, _), ..} = *lit {\n         if name.as_str() == \"len\" && args.len() == 1 && has_is_empty(cx, &args[0]) {\n             span_lint(cx,\n                       LEN_ZERO,"}, {"sha": "728aa124a18c7484dec008507cde5ce5f92fbde6", "filename": "src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -37,9 +37,11 @@ use rustc_plugin::Registry;\n \n #[macro_use]\n pub mod utils;\n+pub mod copies;\n pub mod consts;\n pub mod types;\n pub mod misc;\n+pub mod enum_glob_use;\n pub mod eq_op;\n pub mod bit_mask;\n pub mod ptr_arg;\n@@ -99,6 +101,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box misc::CmpNan);\n     reg.register_late_lint_pass(box eq_op::EqOp);\n     reg.register_early_lint_pass(box enum_variants::EnumVariantNames);\n+    reg.register_late_lint_pass(box enum_glob_use::EnumGlobUse);\n     reg.register_late_lint_pass(box bit_mask::BitMask);\n     reg.register_late_lint_pass(box ptr_arg::PtrArg);\n     reg.register_late_lint_pass(box needless_bool::NeedlessBool);\n@@ -155,8 +158,10 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_late_lint_pass(box drop_ref::DropRefPass);\n     reg.register_late_lint_pass(box types::AbsurdUnsignedComparisons);\n     reg.register_late_lint_pass(box regex::RegexPass);\n+    reg.register_late_lint_pass(box copies::CopyAndPaste);\n \n     reg.register_lint_group(\"clippy_pedantic\", vec![\n+        enum_glob_use::ENUM_GLOB_USE,\n         matches::SINGLE_MATCH_ELSE,\n         methods::OPTION_UNWRAP_USED,\n         methods::RESULT_UNWRAP_USED,\n@@ -187,6 +192,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_EXPR,\n         block_in_if_condition::BLOCK_IN_IF_CONDITION_STMT,\n         collapsible_if::COLLAPSIBLE_IF,\n+        copies::IF_SAME_THEN_ELSE,\n+        copies::IFS_SAME_COND,\n         cyclomatic_complexity::CYCLOMATIC_COMPLEXITY,\n         derive::DERIVE_HASH_NOT_EQ,\n         derive::EXPL_IMPL_CLONE_ON_COPY,"}, {"sha": "03e2d0a4ec3de157f98a28098c91f2d2a95bbc2b", "filename": "src/minmax.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fminmax.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -1,8 +1,7 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::ptr::P;\n-use std::cmp::PartialOrd;\n-use std::cmp::Ordering::*;\n+use std::cmp::{PartialOrd, Ordering};\n \n use consts::{Constant, constant_simple};\n use utils::{match_def_path, span_lint};\n@@ -37,7 +36,7 @@ impl LateLintPass for MinMaxPass {\n                     return;\n                 }\n                 match (outer_max, outer_c.partial_cmp(&inner_c)) {\n-                    (_, None) | (Max, Some(Less)) | (Min, Some(Greater)) => (),\n+                    (_, None) | (Max, Some(Ordering::Less)) | (Min, Some(Ordering::Greater)) => (),\n                     _ => {\n                         span_lint(cx, MIN_MAX, expr.span, \"this min/max combination leads to constant result\");\n                     }"}, {"sha": "bfd819edcb6743f954d0b9c8a383a16ad3e04249", "filename": "src/needless_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -5,7 +5,7 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n \n-use syntax::ast::Lit_::*;\n+use syntax::ast::Lit_;\n \n use utils::{span_lint, snippet};\n \n@@ -90,7 +90,7 @@ fn fetch_bool_expr(expr: &Expr) -> Option<bool> {\n     match expr.node {\n         ExprBlock(ref block) => fetch_bool_block(block),\n         ExprLit(ref lit_ptr) => {\n-            if let LitBool(value) = lit_ptr.node {\n+            if let Lit_::LitBool(value) = lit_ptr.node {\n                 Some(value)\n             } else {\n                 None"}, {"sha": "b78db7f4b7718f6fc657463de2636c8c23494e8b", "filename": "src/strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -84,7 +84,7 @@ impl LateLintPass for StringAdd {\n                     if let Some(ref p) = parent {\n                         if let ExprAssign(ref target, _) = p.node {\n                             // avoid duplicate matches\n-                            if is_exp_equal(cx, target, left) {\n+                            if is_exp_equal(cx, target, left, false) {\n                                 return;\n                             }\n                         }\n@@ -113,7 +113,7 @@ fn is_string(cx: &LateContext, e: &Expr) -> bool {\n \n fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n-        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) => is_exp_equal(cx, target, left),\n+        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) => is_exp_equal(cx, target, left, false),\n         ExprBlock(ref block) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n         }"}, {"sha": "7034b0d2ddb578edb96720ecc1a7926208dd90d7", "filename": "src/types.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -5,9 +5,7 @@ use rustc_front::util::{is_comparison_binop, binop_to_string};\n use syntax::codemap::Span;\n use rustc_front::intravisit::{FnKind, Visitor, walk_ty};\n use rustc::middle::ty;\n-use syntax::ast::IntTy::*;\n-use syntax::ast::UintTy::*;\n-use syntax::ast::FloatTy::*;\n+use syntax::ast::{IntTy, UintTy, FloatTy};\n \n use utils::*;\n \n@@ -236,7 +234,7 @@ fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n \n fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n     match typ.sty {\n-        ty::TyInt(TyIs) | ty::TyUint(TyUs) => true,\n+        ty::TyInt(IntTy::TyIs) | ty::TyUint(UintTy::TyUs) => true,\n         _ => false,\n     }\n }\n@@ -361,7 +359,7 @@ impl LateLintPass for CastPass {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n                         let from_nbits = int_ty_to_nbits(cast_from);\n-                        let to_nbits = if let ty::TyFloat(TyF32) = cast_to.sty {\n+                        let to_nbits = if let ty::TyFloat(FloatTy::TyF32) = cast_to.sty {\n                             32\n                         } else {\n                             64\n@@ -392,7 +390,7 @@ impl LateLintPass for CastPass {\n                         check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n                     }\n                     (false, false) => {\n-                        if let (&ty::TyFloat(TyF64), &ty::TyFloat(TyF32)) = (&cast_from.sty, &cast_to.sty) {\n+                        if let (&ty::TyFloat(FloatTy::TyF64), &ty::TyFloat(FloatTy::TyF32)) = (&cast_from.sty, &cast_to.sty) {\n                             span_lint(cx,\n                                       CAST_POSSIBLE_TRUNCATION,\n                                       expr.span,"}, {"sha": "f363eace713dce6dd5032a303f90d19aeb3f76aa", "filename": "src/unicode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Funicode.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Span;\n \n-use syntax::ast::Lit_::*;\n+use syntax::ast::Lit_;\n \n use unicode_normalization::UnicodeNormalization;\n \n@@ -59,7 +59,7 @@ impl LintPass for Unicode {\n impl LateLintPass for Unicode {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n         if let ExprLit(ref lit) = expr.node {\n-            if let LitStr(_, _) = lit.node {\n+            if let Lit_::LitStr(_, _) = lit.node {\n                 check_str(cx, lit.span)\n             }\n         }"}, {"sha": "a8890f31cb03d820ede398c6adf9d05ed45576f1", "filename": "src/utils.rs", "status": "modified", "additions": 177, "deletions": 21, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -1,7 +1,7 @@\n use consts::constant;\n use reexport::*;\n-use rustc::front::map::Node::*;\n-use rustc::lint::*;\n+use rustc::front::map::Node;\n+use rustc::lint::{LintContext, LateContext, Level, Lint};\n use rustc::middle::def_id::DefId;\n use rustc::middle::{cstore, def, infer, ty, traits};\n use rustc::session::Session;\n@@ -10,7 +10,7 @@ use std::borrow::Cow;\n use std::mem;\n use std::ops::{Deref, DerefMut};\n use std::str::FromStr;\n-use syntax::ast::Lit_::*;\n+use syntax::ast::Lit_;\n use syntax::ast;\n use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n@@ -296,9 +296,9 @@ pub fn method_chain_args<'a>(expr: &'a Expr, methods: &[&str]) -> Option<Vec<&'a\n pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     let parent_id = cx.tcx.map.get_parent(expr.id);\n     match cx.tcx.map.find(parent_id) {\n-        Some(NodeItem(&Item{ ref name, .. })) |\n-        Some(NodeTraitItem(&TraitItem{ ref name, .. })) |\n-        Some(NodeImplItem(&ImplItem{ ref name, .. })) => Some(*name),\n+        Some(Node::NodeItem(&Item{ ref name, .. })) |\n+        Some(Node::NodeTraitItem(&TraitItem{ ref name, .. })) |\n+        Some(Node::NodeImplItem(&ImplItem{ ref name, .. })) => Some(*name),\n         _ => None,\n     }\n }\n@@ -408,7 +408,7 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n         return None;\n     }\n     map.find(parent_id).and_then(|node| {\n-        if let NodeExpr(parent) = node {\n+        if let Node::NodeExpr(parent) = node {\n             Some(parent)\n         } else {\n             None\n@@ -422,8 +422,8 @@ pub fn get_enclosing_block<'c>(cx: &'c LateContext, node: NodeId) -> Option<&'c\n                             .and_then(|enclosing_id| map.find(enclosing_id));\n     if let Some(node) = enclosing_node {\n         match node {\n-            NodeBlock(ref block) => Some(block),\n-            NodeItem(&Item{ node: ItemFn(_, _, _, _, _, ref block), .. }) => Some(block),\n+            Node::NodeBlock(ref block) => Some(block),\n+            Node::NodeItem(&Item{ node: ItemFn(_, _, _, _, _, ref block), .. }) => Some(block),\n             _ => None,\n         }\n     } else {\n@@ -529,7 +529,7 @@ pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n pub fn is_integer_literal(expr: &Expr, value: u64) -> bool {\n     // FIXME: use constant folding\n     if let ExprLit(ref spanned) = expr.node {\n-        if let LitInt(v, _) = spanned.node {\n+        if let Lit_::LitInt(v, _) = spanned.node {\n             return v == value;\n         }\n     }\n@@ -575,7 +575,7 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n         }\n         if let ast::MetaNameValue(ref key, ref value) = attr.value.node {\n             if *key == name {\n-                if let LitStr(ref s, _) = value.node {\n+                if let Lit_::LitStr(ref s, _) = value.node {\n                     if let Ok(value) = FromStr::from_str(s) {\n                         f(value)\n                     } else {\n@@ -589,29 +589,183 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n     }\n }\n \n-pub fn is_exp_equal(cx: &LateContext, left: &Expr, right: &Expr) -> bool {\n+/// Check whether two statements are the same.\n+/// See also `is_exp_equal`.\n+pub fn is_stmt_equal(cx: &LateContext, left: &Stmt, right: &Stmt, ignore_fn: bool) -> bool {\n+    match (&left.node, &right.node) {\n+        (&StmtDecl(ref l, _), &StmtDecl(ref r, _)) => {\n+            if let (&DeclLocal(ref l), &DeclLocal(ref r)) = (&l.node, &r.node) {\n+                // TODO: tys\n+                l.ty.is_none() && r.ty.is_none() &&\n+                    both(&l.init, &r.init, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n+            }\n+            else {\n+                false\n+            }\n+        }\n+        (&StmtExpr(ref l, _), &StmtExpr(ref r, _)) => is_exp_equal(cx, l, r, ignore_fn),\n+        (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => is_exp_equal(cx, l, r, ignore_fn),\n+        _ => false,\n+    }\n+}\n+\n+/// Check whether two blocks are the same.\n+/// See also `is_exp_equal`.\n+pub fn is_block_equal(cx: &LateContext, left: &Block, right: &Block, ignore_fn: bool) -> bool {\n+    over(&left.stmts, &right.stmts, |l, r| is_stmt_equal(cx, l, r, ignore_fn)) &&\n+        both(&left.expr, &right.expr, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n+}\n+\n+/// Check whether two pattern are the same.\n+/// See also `is_exp_equal`.\n+pub fn is_pat_equal(cx: &LateContext, left: &Pat, right: &Pat, ignore_fn: bool) -> bool {\n+    match (&left.node, &right.node) {\n+        (&PatBox(ref l), &PatBox(ref r)) => {\n+            is_pat_equal(cx, l, r, ignore_fn)\n+        }\n+        (&PatEnum(ref lp, ref la), &PatEnum(ref rp, ref ra)) => {\n+            is_path_equal(lp, rp) &&\n+                both(la, ra, |l, r| {\n+                    over(l, r, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n+                })\n+        }\n+        (&PatIdent(ref lb, ref li, ref lp), &PatIdent(ref rb, ref ri, ref rp)) => {\n+            lb == rb && li.node.name.as_str() == ri.node.name.as_str() &&\n+                both(lp, rp, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n+        }\n+        (&PatLit(ref l), &PatLit(ref r)) => {\n+            is_exp_equal(cx, l, r, ignore_fn)\n+        }\n+        (&PatQPath(ref ls, ref lp), &PatQPath(ref rs, ref rp)) => {\n+            is_qself_equal(ls, rs) && is_path_equal(lp, rp)\n+        }\n+        (&PatTup(ref l), &PatTup(ref r)) => {\n+            over(l, r, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n+        }\n+        (&PatRange(ref ls, ref le), &PatRange(ref rs, ref re)) => {\n+            is_exp_equal(cx, ls, rs, ignore_fn) &&\n+                is_exp_equal(cx, le, re, ignore_fn)\n+        }\n+        (&PatRegion(ref le, ref lm), &PatRegion(ref re, ref rm)) => {\n+            lm == rm && is_pat_equal(cx, le, re, ignore_fn)\n+        }\n+        (&PatVec(ref ls, ref li, ref le), &PatVec(ref rs, ref ri, ref re)) => {\n+            over(ls, rs, |l, r| is_pat_equal(cx, l, r, ignore_fn)) &&\n+                over(le, re, |l, r| is_pat_equal(cx, l, r, ignore_fn)) &&\n+                both(li, ri, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n+        }\n+        (&PatWild, &PatWild) => true,\n+        _ => false,\n+    }\n+}\n+\n+/// Check whether two expressions are the same. This is different from the operator `==` on\n+/// expression as this operator would compare true equality with ID and span.\n+/// If `ignore_fn` is true, never consider as equal fonction calls.\n+///\n+/// Note that some expression kinds are not considered but could be added.\n+#[allow(cyclomatic_complexity)] // ok, it\u2019s a big function, but mostly one big match with simples cases\n+pub fn is_exp_equal(cx: &LateContext, left: &Expr, right: &Expr, ignore_fn: bool) -> bool {\n     if let (Some(l), Some(r)) = (constant(cx, left), constant(cx, right)) {\n         if l == r {\n             return true;\n         }\n     }\n+\n     match (&left.node, &right.node) {\n+        (&ExprAddrOf(ref lmut, ref le), &ExprAddrOf(ref rmut, ref re)) => {\n+            lmut == rmut && is_exp_equal(cx, le, re, ignore_fn)\n+        }\n+        (&ExprAgain(li), &ExprAgain(ri)) => {\n+            both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str())\n+        }\n+        (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => {\n+            is_exp_equal(cx, ll, rl, ignore_fn) && is_exp_equal(cx, lr, rr, ignore_fn)\n+        }\n+        (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n+            lo.node == ro.node && is_exp_equal(cx, ll, rl, ignore_fn) && is_exp_equal(cx, lr, rr, ignore_fn)\n+        }\n+        (&ExprBlock(ref l), &ExprBlock(ref r)) => {\n+            is_block_equal(cx, l, r, ignore_fn)\n+        }\n+        (&ExprBinary(lop, ref ll, ref lr), &ExprBinary(rop, ref rl, ref rr)) => {\n+            lop.node == rop.node && is_exp_equal(cx, ll, rl, ignore_fn) && is_exp_equal(cx, lr, rr, ignore_fn)\n+        }\n+        (&ExprBreak(li), &ExprBreak(ri)) => {\n+            both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str())\n+        }\n+        (&ExprBox(ref l), &ExprBox(ref r)) => {\n+            is_exp_equal(cx, l, r, ignore_fn)\n+        }\n+        (&ExprCall(ref lfun, ref largs), &ExprCall(ref rfun, ref rargs)) => {\n+            !ignore_fn &&\n+                is_exp_equal(cx, lfun, rfun, ignore_fn) &&\n+                is_exps_equal(cx, largs, rargs, ignore_fn)\n+        }\n+        (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) => {\n+            is_exp_equal(cx, lx, rx, ignore_fn) && is_cast_ty_equal(lt, rt)\n+        }\n         (&ExprField(ref lfexp, ref lfident), &ExprField(ref rfexp, ref rfident)) => {\n-            lfident.node == rfident.node && is_exp_equal(cx, lfexp, rfexp)\n+            lfident.node == rfident.node && is_exp_equal(cx, lfexp, rfexp, ignore_fn)\n+        }\n+        (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => {\n+            is_exp_equal(cx, la, ra, ignore_fn) && is_exp_equal(cx, li, ri, ignore_fn)\n+        }\n+        (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n+            is_exp_equal(cx, lc, rc, ignore_fn) &&\n+                is_block_equal(cx, lt, rt, ignore_fn) &&\n+                both(le, re, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n         }\n         (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n+        (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n+            ls == rs &&\n+                is_exp_equal(cx, le, re, ignore_fn) &&\n+                over(la, ra, |l, r| {\n+                    is_exp_equal(cx, &l.body, &r.body, ignore_fn) &&\n+                        both(&l.guard, &r.guard, |l, r| is_exp_equal(cx, l, r, ignore_fn)) &&\n+                        over(&l.pats, &r.pats, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n+                })\n+        }\n+        (&ExprMethodCall(ref lname, ref ltys, ref largs), &ExprMethodCall(ref rname, ref rtys, ref rargs)) => {\n+            // TODO: tys\n+            !ignore_fn &&\n+                lname.node == rname.node &&\n+                ltys.is_empty() &&\n+                rtys.is_empty() &&\n+                is_exps_equal(cx, largs, rargs, ignore_fn)\n+        }\n+        (&ExprRange(ref lb, ref le), &ExprRange(ref rb, ref re)) => {\n+            both(lb, rb, |l, r| is_exp_equal(cx, l, r, ignore_fn)) &&\n+            both(le, re, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n+        }\n+        (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => {\n+            is_exp_equal(cx, le, re, ignore_fn) && is_exp_equal(cx, ll, rl, ignore_fn)\n+        }\n+        (&ExprRet(ref l), &ExprRet(ref r)) => {\n+            both(l, r, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n+        }\n         (&ExprPath(ref lqself, ref lsubpath), &ExprPath(ref rqself, ref rsubpath)) => {\n             both(lqself, rqself, is_qself_equal) && is_path_equal(lsubpath, rsubpath)\n         }\n-        (&ExprTup(ref ltup), &ExprTup(ref rtup)) => is_exps_equal(cx, ltup, rtup),\n-        (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(cx, l, r),\n-        (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) => is_exp_equal(cx, lx, rx) && is_cast_ty_equal(lt, rt),\n+        (&ExprTup(ref ltup), &ExprTup(ref rtup)) => is_exps_equal(cx, ltup, rtup, ignore_fn),\n+        (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => {\n+            li.node == ri.node && is_exp_equal(cx, le, re, ignore_fn)\n+        }\n+        (&ExprUnary(lop, ref le), &ExprUnary(rop, ref re)) => {\n+            lop == rop && is_exp_equal(cx, le, re, ignore_fn)\n+        }\n+        (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(cx, l, r, ignore_fn),\n+        (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n+            is_exp_equal(cx, lc, rc, ignore_fn) &&\n+                is_block_equal(cx, lb, rb, ignore_fn) &&\n+                both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n+        }\n         _ => false,\n     }\n }\n \n-fn is_exps_equal(cx: &LateContext, left: &[P<Expr>], right: &[P<Expr>]) -> bool {\n-    over(left, right, |l, r| is_exp_equal(cx, l, r))\n+fn is_exps_equal(cx: &LateContext, left: &[P<Expr>], right: &[P<Expr>], ignore_fn: bool) -> bool {\n+    over(left, right, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n }\n \n fn is_path_equal(left: &Path, right: &Path) -> bool {\n@@ -620,20 +774,22 @@ fn is_path_equal(left: &Path, right: &Path) -> bool {\n     left.global == right.global &&\n     over(&left.segments,\n          &right.segments,\n-         |l, r| l.identifier.name == r.identifier.name && l.parameters == r.parameters)\n+         |l, r| l.identifier.name.as_str() == r.identifier.name.as_str() && l.parameters == r.parameters)\n }\n \n fn is_qself_equal(left: &QSelf, right: &QSelf) -> bool {\n     left.ty.node == right.ty.node && left.position == right.position\n }\n \n-fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n+/// Check if two slices are equal as per `eq_fn`.\n+pub fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n     where F: FnMut(&X, &X) -> bool\n {\n     left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n }\n \n-fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n+/// Check if the two `Option`s are both `None` or some equal values as per `eq_fn`.\n+pub fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n     where F: FnMut(&X, &X) -> bool\n {\n     l.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false, |y| eq_fn(x, y)))"}, {"sha": "0f57b619ccc83d27e874f8e3dcefd84bfe0f1958", "filename": "tests/compile-fail/copies.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -0,0 +1,135 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+\n+#![allow(dead_code)]\n+#![allow(let_and_return)]\n+#![allow(needless_return)]\n+#![allow(unused_variables)]\n+#![deny(if_same_then_else)]\n+#![deny(ifs_same_cond)]\n+\n+fn foo() -> bool { unimplemented!() }\n+\n+fn if_same_then_else() -> &'static str {\n+    if true { //~ERROR this if has the same then and else blocks\n+        foo();\n+    }\n+    else {\n+        foo();\n+    }\n+\n+    if true {\n+        foo();\n+        foo();\n+    }\n+    else {\n+        foo();\n+    }\n+\n+    let _ = if true { //~ERROR this if has the same then and else blocks\n+        foo();\n+        42\n+    }\n+    else {\n+        foo();\n+        42\n+    };\n+\n+    if true {\n+        foo();\n+    }\n+\n+    let _ = if true { //~ERROR this if has the same then and else blocks\n+        42\n+    }\n+    else {\n+        42\n+    };\n+\n+    if true { //~ERROR this if has the same then and else blocks\n+        let bar = if true {\n+            42\n+        }\n+        else {\n+            43\n+        };\n+\n+        while foo() { break; }\n+        bar + 1;\n+    }\n+    else {\n+        let bar = if true {\n+            42\n+        }\n+        else {\n+            43\n+        };\n+\n+        while foo() { break; }\n+        bar + 1;\n+    }\n+\n+    if true { //~ERROR this if has the same then and else blocks\n+        match 42 {\n+            42 => (),\n+            a if a > 0 => (),\n+            10...15 => (),\n+            _ => (),\n+        }\n+    }\n+    else {\n+        match 42 {\n+            42 => (),\n+            a if a > 0 => (),\n+            10...15 => (),\n+            _ => (),\n+        }\n+    }\n+\n+    if true { //~ERROR this if has the same then and else blocks\n+        if let Some(a) = Some(42) {}\n+    }\n+    else {\n+        if let Some(a) = Some(42) {}\n+    }\n+\n+    if true { //~ERROR this if has the same then and else blocks\n+        let foo = \"\";\n+        return &foo[0..];\n+    }\n+    else {\n+        let foo = \"\";\n+        return &foo[0..];\n+    }\n+}\n+\n+fn ifs_same_cond() {\n+    let a = 0;\n+\n+    if a == 1 {\n+    }\n+    else if a == 1 { //~ERROR this if has the same condition as a previous if\n+    }\n+\n+    if 2*a == 1 {\n+    }\n+    else if 2*a == 2 {\n+    }\n+    else if 2*a == 1 { //~ERROR this if has the same condition as a previous if\n+    }\n+    else if a == 1 {\n+    }\n+\n+    let mut v = vec![1];\n+    if v.pop() == None { // ok, functions\n+    }\n+    else if v.pop() == None {\n+    }\n+\n+    if v.len() == 42 { // ok, functions\n+    }\n+    else if v.len() == 42 {\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "fc5f531ba90d7ce417cc304f02006e6e17920a3a", "filename": "tests/compile-fail/enum_glob_use.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Fcompile-fail%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Fcompile-fail%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fenum_glob_use.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -0,0 +1,20 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![deny(clippy, clippy_pedantic)]\n+#![allow(unused_imports, dead_code)]\n+\n+use std::cmp::Ordering::*; //~ ERROR: don't use glob imports for enum variants\n+\n+enum Enum {}\n+\n+use self::Enum::*; //~ ERROR: don't use glob imports for enum variants\n+\n+fn blarg() {\n+    use self::Enum::*; // ok, just for a function\n+}\n+\n+mod blurg {\n+    pub use std::cmp::Ordering::*; // ok, re-export\n+}\n+\n+fn main() {}"}, {"sha": "7be5ef11ce6a65d5185da4a3fe75163c45924eec", "filename": "tests/compile-fail/eq_op.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Fcompile-fail%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Fcompile-fail%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Feq_op.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -19,9 +19,9 @@ fn main() {\n     // unary and binary operators\n     (-(2) < -(2));  //~ERROR equal expressions\n     ((1 + 1) & (1 + 1) == (1 + 1) & (1 + 1));\n-          //~^ ERROR equal expressions\n-                    //~^^ ERROR equal expressions\n-                               //~^^^ ERROR equal expressions\n+          //~^ ERROR equal expressions as operands to `==`\n+                    //~^^ ERROR equal expressions as operands to `&`\n+                               //~^^^ ERROR equal expressions as operands to `&`\n     (1 * 2) + (3 * 4) == 1 * 2 + 3 * 4; //~ERROR equal expressions\n \n     // various other things\n@@ -31,5 +31,16 @@ fn main() {\n \n     // const folding\n     1 + 1 == 2; //~ERROR equal expressions\n-    1 - 1 == 0; //~ERROR equal expressions\n+    1 - 1 == 0; //~ERROR equal expressions as operands to `==`\n+                //~^ ERROR equal expressions as operands to `-`\n+\n+    1 - 1; //~ERROR equal expressions\n+    1 / 1; //~ERROR equal expressions\n+    true && true; //~ERROR equal expressions\n+    true || true; //~ERROR equal expressions\n+\n+    let mut a = vec![1];\n+    a == a; //~ERROR equal expressions\n+    2*a.len() == 2*a.len(); // ok, functions\n+    a.pop() == a.pop(); // ok, functions\n }"}, {"sha": "c1141e0b460f2c03d23ebbaea5cb6cb93136bfc4", "filename": "tests/compile-fail/identity_op.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Fcompile-fail%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Fcompile-fail%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fidentity_op.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -5,6 +5,7 @@ const ONE : i64 = 1;\n const NEG_ONE : i64 = -1;\n const ZERO : i64 = 0;\n \n+#[allow(eq_op)]\n #[deny(identity_op)]\n fn main() {\n     let x = 0;"}, {"sha": "c2ad24bc4eeed63a9a17aa63b109e5948c1b21d3", "filename": "tests/compile-fail/needless_bool.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Fcompile-fail%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Fcompile-fail%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fneedless_bool.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -1,6 +1,7 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n+#[allow(if_same_then_else)]\n #[deny(needless_bool)]\n fn main() {\n     let x = true;"}, {"sha": "c422e83873b09b855f5c515cbc2ce3e552fc619a", "filename": "tests/compile-fail/zero_div_zero.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Fcompile-fail%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Fcompile-fail%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzero_div_zero.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -5,9 +5,13 @@\n #[deny(zero_divided_by_zero)]\n fn main() {\n     let nan = 0.0 / 0.0; //~ERROR constant division of 0.0 with 0.0 will always result in NaN\n+                         //~^ equal expressions as operands to `/`\n     let f64_nan = 0.0 / 0.0f64; //~ERROR constant division of 0.0 with 0.0 will always result in NaN\n+                         //~^ equal expressions as operands to `/`\n     let other_f64_nan = 0.0f64 / 0.0; //~ERROR constant division of 0.0 with 0.0 will always result in NaN\n+                         //~^ equal expressions as operands to `/`\n     let one_more_f64_nan = 0.0f64/0.0f64; //~ERROR constant division of 0.0 with 0.0 will always result in NaN\n+                         //~^ equal expressions as operands to `/`\n     let zero = 0.0;\n     let other_zero = 0.0;\n     let other_nan = zero / other_zero; // fine - this lint doesn't propegate constants."}, {"sha": "822d9339ba3eaf00dc664dd28882fd4921b54eca", "filename": "tests/compile-test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -21,5 +21,6 @@ fn run_mode(mode: &'static str) {\n \n #[test]\n fn compile_test() {\n+    run_mode(\"run-pass\");\n     run_mode(\"compile-fail\");\n }"}, {"sha": "5b54698605a73cfb7b2f78e64268786efd29f5f3", "filename": "tests/run-pass/enum-glob-import-crate.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Frun-pass%2Fenum-glob-import-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/tests%2Frun-pass%2Fenum-glob-import-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fenum-glob-import-crate.rs?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -0,0 +1,7 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![deny(clippy)]\n+\n+use std::*;\n+\n+fn main() { }"}, {"sha": "d3467a410124728eb6c779ea0a9386641eabe399", "filename": "util/update_wiki.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/util%2Fupdate_wiki.py", "raw_url": "https://github.com/rust-lang/rust/raw/3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11/util%2Fupdate_wiki.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/util%2Fupdate_wiki.py?ref=3b0b9e0e06176a6e4f49aa6c1aec88ede904ba11", "patch": "@@ -79,7 +79,7 @@ def parse_file(d, f):\n \"\"\"\n \n \n-template = \"\"\"# `%s`\n+template = \"\"\"\\n# `%s`\n \n **Default level:** %s\n "}]}