{"sha": "5891a64165ea4819ca331f5a35f5318a91e1be3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4OTFhNjQxNjVlYTQ4MTljYTMzMWY1YTM1ZjUzMThhOTFlMWJlM2Y=", "commit": {"author": {"name": "oliver-giersch", "email": "oliver.giersch@googlemail.com", "date": "2018-10-15T12:37:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-15T12:37:54Z"}, "message": "Merge pull request #4 from rust-lang/master\n\nsync with upstream", "tree": {"sha": "e2da4d1f0bf89c9bce5c29783744f12039b3dd33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e2da4d1f0bf89c9bce5c29783744f12039b3dd33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5891a64165ea4819ca331f5a35f5318a91e1be3f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbxIoiCRBK7hj4Ov3rIwAAdHIIAHijBM385es/wp5f8I4JZOXI\nHqVJmCIhs4WKa2WYNA7LLy6EHturVxHUfDmFMEKn0LsbMP0c2zlefLqDI0o2yMLu\nxpCsk8/xKYtriDd0ZP0DiFe6/U7bZ3zO1Y3KQbcT9Gt8fX98Ju43YaxGOXVROlaB\ndXlP0u8oYKgqBGSjR+4f2wmuKBIxxI71nKePDhrtCyUDxnAeq5PCj74ELlQ+eyAd\nhOurp0nqh20ElYvSt88uwfvZ3CKMg6PG086vSToY+LdTMPHoXtD4TtPYI2lYjNp6\n0oWqxOPbJPwZE0o1tH3Qtc4Rl+Z75w6Dn2kMZV09taLBZ3Dqp6cQ7JhZ4NS/llc=\n=Qhip\n-----END PGP SIGNATURE-----\n", "payload": "tree e2da4d1f0bf89c9bce5c29783744f12039b3dd33\nparent fa76d42b3e547bd3a0e049cc2c1e00f6b9560d6c\nparent 42f401dd02fd418e038d9b2829d60d69407e9aab\nauthor oliver-giersch <oliver.giersch@googlemail.com> 1539607074 +0200\ncommitter GitHub <noreply@github.com> 1539607074 +0200\n\nMerge pull request #4 from rust-lang/master\n\nsync with upstream"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5891a64165ea4819ca331f5a35f5318a91e1be3f", "html_url": "https://github.com/rust-lang/rust/commit/5891a64165ea4819ca331f5a35f5318a91e1be3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5891a64165ea4819ca331f5a35f5318a91e1be3f/comments", "author": {"login": "oliver-giersch", "id": 19815381, "node_id": "MDQ6VXNlcjE5ODE1Mzgx", "avatar_url": "https://avatars.githubusercontent.com/u/19815381?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oliver-giersch", "html_url": "https://github.com/oliver-giersch", "followers_url": "https://api.github.com/users/oliver-giersch/followers", "following_url": "https://api.github.com/users/oliver-giersch/following{/other_user}", "gists_url": "https://api.github.com/users/oliver-giersch/gists{/gist_id}", "starred_url": "https://api.github.com/users/oliver-giersch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oliver-giersch/subscriptions", "organizations_url": "https://api.github.com/users/oliver-giersch/orgs", "repos_url": "https://api.github.com/users/oliver-giersch/repos", "events_url": "https://api.github.com/users/oliver-giersch/events{/privacy}", "received_events_url": "https://api.github.com/users/oliver-giersch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa76d42b3e547bd3a0e049cc2c1e00f6b9560d6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa76d42b3e547bd3a0e049cc2c1e00f6b9560d6c", "html_url": "https://github.com/rust-lang/rust/commit/fa76d42b3e547bd3a0e049cc2c1e00f6b9560d6c"}, {"sha": "42f401dd02fd418e038d9b2829d60d69407e9aab", "url": "https://api.github.com/repos/rust-lang/rust/commits/42f401dd02fd418e038d9b2829d60d69407e9aab", "html_url": "https://github.com/rust-lang/rust/commit/42f401dd02fd418e038d9b2829d60d69407e9aab"}], "stats": {"total": 1271, "additions": 767, "deletions": 504}, "files": [{"sha": "52314b0ac8998360869c5501a21dbafe6f2e536a", "filename": "src/Cargo.lock", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -204,7 +204,7 @@ dependencies = [\n  \"env_logger 0.5.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"failure 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"filetime 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flate2 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fs2 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fwdansi 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"git2 0.7.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -737,7 +737,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"flate2\"\n-version = \"1.0.2\"\n+version = \"1.0.3\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"libc 0.2.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -959,7 +959,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"error-chain 0.12.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flate2 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rayon 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"tar 0.4.16 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1649,7 +1649,7 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.6\"\n+version = \"2.1.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1797,7 +1797,7 @@ dependencies = [\n  \"log 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ordslice 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"racer 2.1.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"racer 2.1.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rayon 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1814,6 +1814,7 @@ dependencies = [\n  \"serde 1.0.75 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_derive 1.0.75 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"serde_json 1.0.31 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"toml 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"url 1.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"walkdir 2.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n@@ -1889,7 +1890,7 @@ dependencies = [\n  \"bitflags 1.0.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"byteorder 1.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"chalk-engine 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"flate2 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"fmt_macros 0.0.0\",\n  \"graphviz 0.0.0\",\n  \"jobserver 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2133,7 +2134,7 @@ dependencies = [\n name = \"rustc_codegen_utils\"\n version = \"0.0.0\"\n dependencies = [\n- \"flate2 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n@@ -2276,7 +2277,7 @@ dependencies = [\n name = \"rustc_metadata\"\n version = \"0.0.0\"\n dependencies = [\n- \"flate2 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flate2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n  \"rustc 0.0.0\",\n@@ -3222,7 +3223,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum failure_derive 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"946d0e98a50d9831f5d589038d2ca7f8f455b1c21028c0db0e84116a12696426\"\n \"checksum filetime 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"da4b9849e77b13195302c174324b5ba73eec9b236b24c221a61000daefb95c5f\"\n \"checksum fixedbitset 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"86d4de0081402f5e88cdac65c8dcdcc73118c1a7a465e2a05f0da05843a8ea33\"\n-\"checksum flate2 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"37847f133aae7acf82bb9577ccd8bda241df836787642654286e79679826a54b\"\n+\"checksum flate2 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4af030962d89d62aa52cd9492083b1cd9b2d1a77764878102a6c0f86b4d5444d\"\n \"checksum fnv 1.0.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2fad85553e09a6f881f739c29f0b00b0f01357c743266d478b68951ce23285f3\"\n \"checksum foreign-types 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f6f339eb8adc052cd2ca78910fda869aefa38d22d5cb648e6485e4d3fc06f3b1\"\n \"checksum foreign-types-shared 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"00b0228411908ca8685dba7fc2cdd70ec9990a6e753e89b6ac91a84c40fbaf4b\"\n@@ -3319,7 +3320,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n \"checksum quote 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9949cfe66888ffe1d53e6ec9d9f3b70714083854be20fd5e271b232a017401e8\"\n \"checksum quote 0.6.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd636425967c33af890042c483632d33fa7a18f19ad1d7ea72e8998c6ef8dea5\"\n-\"checksum racer 2.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"99e820b7f7701c834c3f6f8226f388c19c0ea948a3ef79ddc96aa7398b5ba87a\"\n+\"checksum racer 2.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0beefbfaed799c3554021a48856113ad53862311395f6d75376192884ba5fbe6\"\n \"checksum rand 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8356f47b32624fef5b3301c1be97e5944ecdd595409cc5da11d05f211db6cfbd\"\n \"checksum rand 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e464cd887e869cddcae8792a4ee31d23c7edd516700695608f5b98c67ee0131c\"\n \"checksum rand_core 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"edecf0f94da5551fc9b492093e30b041a891657db7940ee221f9d2f66e82eef2\""}, {"sha": "cf79d4f777ae094cf2c5aa62cb212362ab8f1a6e", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -1263,14 +1263,16 @@ impl Step for Clippy {\n         builder.install(&cargoclippy, &image.join(\"bin\"), 0o755);\n         let doc = image.join(\"share/doc/clippy\");\n         builder.install(&src.join(\"README.md\"), &doc, 0o644);\n-        builder.install(&src.join(\"LICENSE\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n \n         // Prepare the overlay\n         let overlay = tmp.join(\"clippy-overlay\");\n         drop(fs::remove_dir_all(&overlay));\n         t!(fs::create_dir_all(&overlay));\n         builder.install(&src.join(\"README.md\"), &overlay, 0o644);\n-        builder.install(&src.join(\"LICENSE\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-APACHE\"), &doc, 0o644);\n+        builder.install(&src.join(\"LICENSE-MIT\"), &doc, 0o644);\n         builder.create(&overlay.join(\"version\"), &version);\n \n         // Generate the installer tarball"}, {"sha": "c09de02ab51c711458cc7f442873096d47168a92", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -1288,6 +1288,9 @@ impl Build {\n         t!(fs::create_dir_all(dstdir));\n         drop(fs::remove_file(&dst));\n         {\n+            if !src.exists() {\n+                panic!(\"Error: File \\\"{}\\\" not found!\", src.display());\n+            }\n             let mut s = t!(fs::File::open(&src));\n             let mut d = t!(fs::File::create(&dst));\n             io::copy(&mut s, &mut d).expect(\"failed to copy\");"}, {"sha": "a2e68a223f16b49f3d1f06a7ecdccc835e5b394f", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -152,7 +152,7 @@\n //! Additionally, the return value of this function is [`fmt::Result`] which is a\n //! type alias of [`Result`]`<(), `[`std::fmt::Error`]`>`. Formatting implementations\n //! should ensure that they propagate errors from the [`Formatter`][`Formatter`] (e.g., when\n-//! calling [`write!`]) however, they should never return errors spuriously. That\n+//! calling [`write!`]). However, they should never return errors spuriously. That\n //! is, a formatting implementation must and may only return an error if the\n //! passed-in [`Formatter`] returns an error. This is because, contrary to what\n //! the function signature might suggest, string formatting is an infallible"}, {"sha": "40bb2faa3623b0f357b983fd3ac0d7d3a9461eca", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -867,7 +867,7 @@ impl<T: ?Sized> Clone for Rc<T> {\n     ///\n     /// let five = Rc::new(5);\n     ///\n-    /// Rc::clone(&five);\n+    /// let _ = Rc::clone(&five);\n     /// ```\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n@@ -1304,7 +1304,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n     ///\n     /// let weak_five = Rc::downgrade(&Rc::new(5));\n     ///\n-    /// Weak::clone(&weak_five);\n+    /// let _ = Weak::clone(&weak_five);\n     /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {"}, {"sha": "35935861fb18297ef11646d7e26feada3b2c8356", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -713,7 +713,7 @@ impl<T: ?Sized> Clone for Arc<T> {\n     ///\n     /// let five = Arc::new(5);\n     ///\n-    /// Arc::clone(&five);\n+    /// let _ = Arc::clone(&five);\n     /// ```\n     #[inline]\n     fn clone(&self) -> Arc<T> {\n@@ -1135,7 +1135,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n     ///\n     /// let weak_five = Arc::downgrade(&Arc::new(5));\n     ///\n-    /// Weak::clone(&weak_five);\n+    /// let _ = Weak::clone(&weak_five);\n     /// ```\n     #[inline]\n     fn clone(&self) -> Weak<T> {"}, {"sha": "817e9ffcbb55d786bbcb9ab7f56269472241d038", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -418,9 +418,7 @@ fn fundamental_ty(tcx: TyCtxt<'_, '_, '_>, ty: Ty<'_>) -> bool {\n     match ty.sty {\n         ty::Ref(..) => true,\n         ty::Adt(def, _) => def.is_fundamental(),\n-        ty::Dynamic(ref data, ..) => {\n-            data.principal().map_or(false, |p| tcx.has_attr(p.def_id(), \"fundamental\"))\n-        }\n+        ty::Dynamic(ref data, ..) => tcx.has_attr(data.principal().def_id(), \"fundamental\"),\n         _ => false\n     }\n }\n@@ -467,11 +465,7 @@ fn ty_is_local_constructor(ty: Ty<'_>, in_crate: InCrate) -> bool {\n         ty::Adt(def, _) => def_id_is_local(def.did, in_crate),\n         ty::Foreign(did) => def_id_is_local(did, in_crate),\n \n-        ty::Dynamic(ref tt, ..) => {\n-            tt.principal().map_or(false, |p|\n-                def_id_is_local(p.def_id(), in_crate)\n-            )\n-        }\n+        ty::Dynamic(ref tt, ..) => def_id_is_local(tt.principal().def_id(), in_crate),\n \n         ty::Error => true,\n "}, {"sha": "8e8024e51da7f43b4ce54854d055c9c23c1f71b8", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -2088,10 +2088,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                         return;\n                     }\n \n-                    match data.principal() {\n-                        Some(p) => p.with_self_ty(this.tcx(), self_ty),\n-                        None => return,\n-                    }\n+                    data.principal().with_self_ty(this.tcx(), self_ty)\n                 }\n                 ty::Infer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n@@ -2183,15 +2180,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 //\n                 // We always upcast when we can because of reason\n                 // #2 (region bounds).\n-                match (data_a.principal(), data_b.principal()) {\n-                    (Some(a), Some(b)) => {\n-                        a.def_id() == b.def_id()\n-                            && data_b.auto_traits()\n-                            // All of a's auto traits need to be in b's auto traits.\n-                            .all(|b| data_a.auto_traits().any(|a| a == b))\n-                    }\n-                    _ => false,\n-                }\n+                data_a.principal().def_id() == data_b.principal().def_id()\n+                    && data_b.auto_traits()\n+                    // All of a's auto traits need to be in b's auto traits.\n+                    .all(|b| data_a.auto_traits().any(|a| a == b))\n             }\n \n             // T -> Trait.\n@@ -2981,7 +2973,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n             ty::Dynamic(ref data, ..) => {\n-                data.principal().unwrap().with_self_ty(self.tcx(), self_ty)\n+                data.principal().with_self_ty(self.tcx(), self_ty)\n             }\n             _ => span_bug!(obligation.cause.span, \"object candidate with non-object\"),\n         };\n@@ -3244,10 +3236,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             (&ty::Dynamic(ref data_a, r_a), &ty::Dynamic(ref data_b, r_b)) => {\n                 // See assemble_candidates_for_unsizing for more info.\n                 let existential_predicates = data_a.map_bound(|data_a| {\n-                    let principal = data_a.principal();\n-                    let iter = principal\n-                        .into_iter()\n-                        .map(ty::ExistentialPredicate::Trait)\n+                    let iter = iter::once(ty::ExistentialPredicate::Trait(data_a.principal()))\n                         .chain(\n                             data_a\n                                 .projection_bounds()\n@@ -3285,7 +3274,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // T -> Trait.\n             (_, &ty::Dynamic(ref data, r)) => {\n                 let mut object_dids = data.auto_traits()\n-                    .chain(data.principal().map(|p| p.def_id()));\n+                    .chain(iter::once(data.principal().def_id()));\n                 if let Some(did) = object_dids.find(|did| !tcx.is_object_safe(*did)) {\n                     return Err(TraitNotObjectSafe(did));\n                 }"}, {"sha": "d886d5ed204139d22deaede765828a80f14cdad0", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -208,8 +208,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             ty::FnDef(..) => \"fn item\".into(),\n             ty::FnPtr(_) => \"fn pointer\".into(),\n             ty::Dynamic(ref inner, ..) => {\n-                inner.principal().map_or_else(|| \"trait\".into(),\n-                    |p| format!(\"trait {}\", tcx.item_path_str(p.def_id())).into())\n+                format!(\"trait {}\", tcx.item_path_str(inner.principal().def_id())).into()\n             }\n             ty::Closure(..) => \"closure\".into(),\n             ty::Generator(..) => \"generator\".into(),"}, {"sha": "e6aaf8b1bb20604a7046b991d1f520b0afccc27a", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -78,7 +78,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::Array(..) | ty::Slice(_) => Some(ArraySimplifiedType),\n         ty::RawPtr(_) => Some(PtrSimplifiedType),\n         ty::Dynamic(ref trait_info, ..) => {\n-            trait_info.principal().map(|p| TraitSimplifiedType(p.def_id()))\n+            Some(TraitSimplifiedType(trait_info.principal().def_id()))\n         }\n         ty::Ref(_, ty, _) => {\n             // since we introduce auto-refs during method lookup, we"}, {"sha": "c4a25971da3ad15145514e407ad45874c7d80130", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -436,7 +436,7 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n     match ty.sty {\n         ty::Adt(adt_def, _) => Some(adt_def.did),\n \n-        ty::Dynamic(data, ..) => data.principal().map(|p| p.def_id()),\n+        ty::Dynamic(data, ..) => Some(data.principal().def_id()),\n \n         ty::Array(subty, _) |\n         ty::Slice(subty) => characteristic_def_id_of_type(subty),"}, {"sha": "cc6e6b2861ecb8578cb48180132d475185793aa6", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -559,10 +559,10 @@ impl<'a, 'gcx, 'tcx> Binder<ExistentialPredicate<'tcx>> {\n impl<'tcx> serialize::UseSpecializedDecodable for &'tcx List<ExistentialPredicate<'tcx>> {}\n \n impl<'tcx> List<ExistentialPredicate<'tcx>> {\n-    pub fn principal(&self) -> Option<ExistentialTraitRef<'tcx>> {\n-        match self.get(0) {\n-            Some(&ExistentialPredicate::Trait(tr)) => Some(tr),\n-            _ => None,\n+    pub fn principal(&self) -> ExistentialTraitRef<'tcx> {\n+        match self[0] {\n+            ExistentialPredicate::Trait(tr) => tr,\n+            other => bug!(\"first predicate is {:?}\", other),\n         }\n     }\n \n@@ -589,8 +589,8 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n }\n \n impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n-    pub fn principal(&self) -> Option<PolyExistentialTraitRef<'tcx>> {\n-        self.skip_binder().principal().map(Binder::bind)\n+    pub fn principal(&self) -> PolyExistentialTraitRef<'tcx> {\n+        Binder::bind(self.skip_binder().principal())\n     }\n \n     #[inline]\n@@ -1825,9 +1825,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             }\n             Dynamic(ref obj, region) => {\n                 let mut v = vec![region];\n-                if let Some(p) = obj.principal() {\n-                    v.extend(p.skip_binder().substs.regions());\n-                }\n+                v.extend(obj.principal().skip_binder().substs.regions());\n                 v\n             }\n             Adt(_, substs) | Opaque(_, substs) => {"}, {"sha": "27747970f76b2ca74caf955f9198ba8a85baa647", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -387,7 +387,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n                     let cause = self.cause(traits::MiscObligation);\n                     let component_traits =\n-                        data.auto_traits().chain(data.principal().map(|p| p.def_id()));\n+                        data.auto_traits().chain(once(data.principal().def_id()));\n                     self.out.extend(\n                         component_traits.map(|did| traits::Obligation::new(\n                             cause.clone(),"}, {"sha": "f3b5503b8d0fc7df660296fb7ab503bb2f93bc14", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -621,16 +621,16 @@ define_print! {\n                 // Use a type that can't appear in defaults of type parameters.\n                 let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n \n-                if let Some(p) = self.principal() {\n-                    let principal = tcx.lift(&p).expect(\"could not lift TraitRef for printing\")\n-                        .with_self_ty(tcx, dummy_self);\n-                    let projections = self.projection_bounds().map(|p| {\n-                        tcx.lift(&p)\n-                            .expect(\"could not lift projection for printing\")\n-                            .with_self_ty(tcx, dummy_self)\n-                    }).collect::<Vec<_>>();\n-                    cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n-                }\n+                let principal = tcx\n+                    .lift(&self.principal())\n+                    .expect(\"could not lift TraitRef for printing\")\n+                    .with_self_ty(tcx, dummy_self);\n+                let projections = self.projection_bounds().map(|p| {\n+                    tcx.lift(&p)\n+                        .expect(\"could not lift projection for printing\")\n+                        .with_self_ty(tcx, dummy_self)\n+                }).collect::<Vec<_>>();\n+                cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n \n                 // Builtin bounds.\n                 for did in self.auto_traits() {"}, {"sha": "7b93d3e795ed8f29c41132a2ba11f65e87b1ccb6", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -536,7 +536,10 @@ impl<'tcx> FnTypeExt<'tcx> for FnType<'tcx, Ty<'tcx>> {\n                     // Note that the platform intrinsic ABI is exempt here as\n                     // that's how we connect up to LLVM and it's unstable\n                     // anyway, we control all calls to it in libstd.\n-                    layout::Abi::Vector { .. } if abi != Abi::PlatformIntrinsic => {\n+                    layout::Abi::Vector { .. }\n+                        if abi != Abi::PlatformIntrinsic &&\n+                            cx.sess().target.target.options.simd_types_indirect =>\n+                    {\n                         arg.make_indirect();\n                         return\n                     }"}, {"sha": "e619742373801770920da7f89326fa0862f90f72", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -59,7 +59,7 @@ pub struct CodegenCx<'a, 'tcx: 'a> {\n     /// Cache instances of monomorphic and polymorphic items\n     pub instances: RefCell<FxHashMap<Instance<'tcx>, &'a Value>>,\n     /// Cache generated vtables\n-    pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>),\n+    pub vtables: RefCell<FxHashMap<(Ty<'tcx>, ty::PolyExistentialTraitRef<'tcx>),\n                                    &'a Value>>,\n     /// Cache of constant strings,\n     pub const_cstr_cache: RefCell<FxHashMap<LocalInternedString, &'a Value>>,"}, {"sha": "6eff086a2ba0517b7d6c6524c55622c9466fe6df", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -435,12 +435,7 @@ fn trait_pointer_metadata(\n     // But it does not describe the trait's methods.\n \n     let containing_scope = match trait_type.sty {\n-        ty::Dynamic(ref data, ..) => if let Some(principal) = data.principal() {\n-            let def_id = principal.def_id();\n-            Some(get_namespace_for_item(cx, def_id))\n-        } else {\n-            NO_SCOPE_METADATA\n-        },\n+        ty::Dynamic(ref data, ..) => Some(get_namespace_for_item(cx, data.principal().def_id())),\n         _ => {\n             bug!(\"debuginfo: Unexpected trait-object type in \\\n                   trait_pointer_metadata(): {:?}\","}, {"sha": "06b9318a5e8300037f413e9eb4ba178a5ae60a53", "filename": "src/librustc_codegen_llvm/debuginfo/type_names.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Ftype_names.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -116,14 +116,12 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>,\n             }\n         },\n         ty::Dynamic(ref trait_data, ..) => {\n-            if let Some(principal) = trait_data.principal() {\n-                let principal = cx.tcx.normalize_erasing_late_bound_regions(\n-                    ty::ParamEnv::reveal_all(),\n-                    &principal,\n-                );\n-                push_item_name(cx, principal.def_id, false, output);\n-                push_type_params(cx, principal.substs, output);\n-            }\n+            let principal = cx.tcx.normalize_erasing_late_bound_regions(\n+                ty::ParamEnv::reveal_all(),\n+                &trait_data.principal(),\n+            );\n+            push_item_name(cx, principal.def_id, false, output);\n+            push_type_params(cx, principal.substs, output);\n         },\n         ty::FnDef(..) | ty::FnPtr(_) => {\n             let sig = t.fn_sig(cx.tcx);"}, {"sha": "db06b87f44e1ed99fd4e47846f3d48be58b97d66", "filename": "src/librustc_codegen_llvm/meth.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_codegen_llvm%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmeth.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'tcx> VirtualIndex {\n pub fn get_vtable(\n     cx: &CodegenCx<'ll, 'tcx>,\n     ty: Ty<'tcx>,\n-    trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n+    trait_ref: ty::PolyExistentialTraitRef<'tcx>,\n ) -> &'ll Value {\n     let tcx = cx.tcx;\n \n@@ -86,23 +86,19 @@ pub fn get_vtable(\n     // Not in the cache. Build it.\n     let nullptr = C_null(Type::i8p(cx));\n \n+    let methods = tcx.vtable_methods(trait_ref.with_self_ty(tcx, ty));\n+    let methods = methods.iter().cloned().map(|opt_mth| {\n+        opt_mth.map_or(nullptr, |(def_id, substs)| {\n+            callee::resolve_and_get_fn(cx, def_id, substs)\n+        })\n+    });\n+\n     let (size, align) = cx.size_and_align_of(ty);\n-    let mut components: Vec<_> = [\n+    let components: Vec<_> = [\n         callee::get_fn(cx, monomorphize::resolve_drop_in_place(cx.tcx, ty)),\n         C_usize(cx, size.bytes()),\n         C_usize(cx, align.abi())\n-    ].iter().cloned().collect();\n-\n-    if let Some(trait_ref) = trait_ref {\n-        let trait_ref = trait_ref.with_self_ty(tcx, ty);\n-        let methods = tcx.vtable_methods(trait_ref);\n-        let methods = methods.iter().cloned().map(|opt_mth| {\n-            opt_mth.map_or(nullptr, |(def_id, substs)| {\n-                callee::resolve_and_get_fn(cx, def_id, substs)\n-            })\n-        });\n-        components.extend(methods);\n-    }\n+    ].iter().cloned().chain(methods).collect();\n \n     let vtable_const = C_struct(cx, &components, false);\n     let align = cx.data_layout().pointer_align;"}, {"sha": "b4f95b915eb8d26817de3f7aa17d861832889bd7", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -44,7 +44,7 @@ use serialize::json;\n \n use std::any::Any;\n use std::env;\n-use std::ffi::{OsStr, OsString};\n+use std::ffi::OsString;\n use std::fs;\n use std::io::{self, Write};\n use std::iter;\n@@ -1021,6 +1021,7 @@ where\n             .cloned()\n             .collect();\n         missing_fragment_specifiers.sort();\n+\n         for span in missing_fragment_specifiers {\n             let lint = lint::builtin::MISSING_FRAGMENT_SPECIFIER;\n             let msg = \"missing fragment specifier\";\n@@ -1472,7 +1473,7 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, out_filenames: &[Pa\n             .collect();\n         let mut file = fs::File::create(&deps_filename)?;\n         for path in out_filenames {\n-            write!(file, \"{}: {}\\n\\n\", path.display(), files.join(\" \"))?;\n+            writeln!(file, \"{}: {}\\n\", path.display(), files.join(\" \"))?;\n         }\n \n         // Emit a fake target for each input file to the compilation. This\n@@ -1484,15 +1485,12 @@ fn write_out_deps(sess: &Session, outputs: &OutputFilenames, out_filenames: &[Pa\n         Ok(())\n     })();\n \n-    match result {\n-        Ok(()) => {}\n-        Err(e) => {\n-            sess.fatal(&format!(\n-                \"error writing dependencies to `{}`: {}\",\n-                deps_filename.display(),\n-                e\n-            ));\n-        }\n+    if let Err(e) = result {\n+        sess.fatal(&format!(\n+            \"error writing dependencies to `{}`: {}\",\n+            deps_filename.display(),\n+            e\n+        ));\n     }\n }\n \n@@ -1520,6 +1518,7 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n                             Symbol::intern(\"proc-macro\"),\n                             Symbol::intern(\"bin\")\n                         ];\n+\n                         if let ast::MetaItemKind::NameValue(spanned) = a.meta().unwrap().node {\n                             let span = spanned.span;\n                             let lev_candidate = find_best_match_for_name(\n@@ -1551,7 +1550,7 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n                         }\n                         None\n                     }\n-                    _ => {\n+                    None => {\n                         session\n                             .struct_span_err(a.span, \"`crate_type` requires a value\")\n                             .note(\"for example: `#![crate_type=\\\"lib\\\"]`\")\n@@ -1581,25 +1580,26 @@ pub fn collect_crate_types(session: &Session, attrs: &[ast::Attribute]) -> Vec<c\n             base.push(::rustc_codegen_utils::link::default_output_for_target(\n                 session,\n             ));\n+        } else {\n+            base.sort();\n+            base.dedup();\n         }\n-        base.sort();\n-        base.dedup();\n     }\n \n-    base.into_iter()\n-        .filter(|crate_type| {\n-            let res = !::rustc_codegen_utils::link::invalid_output_for_target(session, *crate_type);\n+    base.retain(|crate_type| {\n+        let res = !::rustc_codegen_utils::link::invalid_output_for_target(session, *crate_type);\n \n-            if !res {\n-                session.warn(&format!(\n-                    \"dropping unsupported crate type `{}` for target `{}`\",\n-                    *crate_type, session.opts.target_triple\n-                ));\n-            }\n+        if !res {\n+            session.warn(&format!(\n+                \"dropping unsupported crate type `{}` for target `{}`\",\n+                *crate_type, session.opts.target_triple\n+            ));\n+        }\n \n-            res\n-        })\n-        .collect()\n+        res\n+    });\n+\n+    base\n }\n \n pub fn compute_crate_disambiguator(session: &Session) -> CrateDisambiguator {\n@@ -1650,17 +1650,14 @@ pub fn build_output_filenames(\n             // \"-\" as input file will cause the parser to read from stdin so we\n             // have to make up a name\n             // We want to toss everything after the final '.'\n-            let dirpath = match *odir {\n-                Some(ref d) => d.clone(),\n-                None => PathBuf::new(),\n-            };\n+            let dirpath = (*odir).as_ref().cloned().unwrap_or_default();\n \n             // If a crate name is present, we use it as the link name\n             let stem = sess.opts\n                 .crate_name\n                 .clone()\n                 .or_else(|| attr::find_crate_name(attrs).map(|n| n.to_string()))\n-                .unwrap_or(input.filestem());\n+                .unwrap_or_else(|| input.filestem());\n \n             OutputFilenames {\n                 out_directory: dirpath,\n@@ -1693,13 +1690,11 @@ pub fn build_output_filenames(\n                 sess.warn(\"ignoring -C extra-filename flag due to -o flag\");\n             }\n \n-            let cur_dir = Path::new(\"\");\n-\n             OutputFilenames {\n-                out_directory: out_file.parent().unwrap_or(cur_dir).to_path_buf(),\n+                out_directory: out_file.parent().unwrap_or_else(|| Path::new(\"\")).to_path_buf(),\n                 out_filestem: out_file\n                     .file_stem()\n-                    .unwrap_or(OsStr::new(\"\"))\n+                    .unwrap_or_default()\n                     .to_str()\n                     .unwrap()\n                     .to_string(),"}, {"sha": "276b7290c2ef012de4ac7e0c83b48a1a77702232", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 73, "deletions": 101, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -89,6 +89,7 @@ use rustc_codegen_utils::codegen_backend::CodegenBackend;\n use serialize::json::ToJson;\n \n use std::any::Any;\n+use std::borrow::Cow;\n use std::cmp::max;\n use std::default::Default;\n use std::env::consts::{DLL_PREFIX, DLL_SUFFIX};\n@@ -136,9 +137,7 @@ pub mod target_features {\n                              codegen_backend: &dyn CodegenBackend) {\n         let tf = Symbol::intern(\"target_feature\");\n \n-        for feat in codegen_backend.target_features(sess) {\n-            cfg.insert((tf, Some(feat)));\n-        }\n+        cfg.extend(codegen_backend.target_features(sess).into_iter().map(|feat| (tf, Some(feat))));\n \n         if sess.crt_static_feature() {\n             cfg.insert((tf, Some(Symbol::intern(\"crt-static\"))));\n@@ -152,21 +151,14 @@ pub const EXIT_SUCCESS: isize = 0;\n /// Exit status code used for compilation failures and  invalid flags.\n pub const EXIT_FAILURE: isize = 1;\n \n-const BUG_REPORT_URL: &'static str = \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.\\\n-                                      md#bug-reports\";\n-\n-const ICE_REPORT_COMPILER_FLAGS: &'static [&'static str] = &[\n-    \"Z\",\n-    \"C\",\n-    \"crate-type\",\n-];\n-const ICE_REPORT_COMPILER_FLAGS_EXCLUDE: &'static [&'static str] = &[\n-    \"metadata\",\n-    \"extra-filename\",\n-];\n-const ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE: &'static [&'static str] = &[\n-    \"incremental\",\n-];\n+const BUG_REPORT_URL: &str = \"https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.\\\n+                              md#bug-reports\";\n+\n+const ICE_REPORT_COMPILER_FLAGS: &[&str] = &[\"Z\", \"C\", \"crate-type\"];\n+\n+const ICE_REPORT_COMPILER_FLAGS_EXCLUDE: &[&str] = &[\"metadata\", \"extra-filename\"];\n+\n+const ICE_REPORT_COMPILER_FLAGS_STRIP_VALUE: &[&str] = &[\"incremental\"];\n \n pub fn abort_on_err<T>(result: Result<T, CompileIncomplete>, sess: &Session) -> T {\n     match result {\n@@ -195,14 +187,16 @@ pub fn run<F>(run_compiler: F) -> isize\n                     }\n                     None => {\n                         let emitter =\n-                            errors::emitter::EmitterWriter::stderr(errors::ColorConfig::Auto,\n-                                                                None,\n-                                                                true,\n-                                                                false);\n+                            errors::emitter::EmitterWriter::stderr(\n+                                errors::ColorConfig::Auto,\n+                                None,\n+                                true,\n+                                false\n+                            );\n                         let handler = errors::Handler::with_emitter(true, false, Box::new(emitter));\n                         handler.emit(&MultiSpan::new(),\n-                                    \"aborting due to previous error(s)\",\n-                                    errors::Level::Fatal);\n+                                     \"aborting due to previous error(s)\",\n+                                     errors::Level::Fatal);\n                         panic::resume_unwind(Box::new(errors::FatalErrorMarker));\n                     }\n                 }\n@@ -224,15 +218,10 @@ fn load_backend_from_dylib(path: &Path) -> fn() -> Box<dyn CodegenBackend> {\n     // available for future dynamic libraries opened. This is currently used by\n     // loading LLVM and then making its symbols available for other dynamic\n     // libraries.\n-    let lib = match DynamicLibrary::open_global_now(path) {\n-        Ok(lib) => lib,\n-        Err(err) => {\n-            let err = format!(\"couldn't load codegen backend {:?}: {:?}\",\n-                              path,\n-                              err);\n-            early_error(ErrorOutputType::default(), &err);\n-        }\n-    };\n+    let lib = DynamicLibrary::open_global_now(path).unwrap_or_else(|err| {\n+        let err = format!(\"couldn't load codegen backend {:?}: {:?}\", path, err);\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n     unsafe {\n         match lib.symbol(\"__rustc_codegen_backend\") {\n             Ok(f) => {\n@@ -328,37 +317,30 @@ fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n     let sysroot = sysroot_candidates.iter()\n         .map(|sysroot| {\n             let libdir = filesearch::relative_target_lib_path(&sysroot, &target);\n-            sysroot.join(libdir)\n-                .with_file_name(option_env!(\"CFG_CODEGEN_BACKENDS_DIR\")\n-                                .unwrap_or(\"codegen-backends\"))\n+            sysroot.join(libdir).with_file_name(\n+                option_env!(\"CFG_CODEGEN_BACKENDS_DIR\").unwrap_or(\"codegen-backends\"))\n         })\n         .filter(|f| {\n             info!(\"codegen backend candidate: {}\", f.display());\n             f.exists()\n         })\n         .next();\n-    let sysroot = match sysroot {\n-        Some(path) => path,\n-        None => {\n-            let candidates = sysroot_candidates.iter()\n-                .map(|p| p.display().to_string())\n-                .collect::<Vec<_>>()\n-                .join(\"\\n* \");\n-            let err = format!(\"failed to find a `codegen-backends` folder \\\n-                               in the sysroot candidates:\\n* {}\", candidates);\n-            early_error(ErrorOutputType::default(), &err);\n-        }\n-    };\n+    let sysroot = sysroot.unwrap_or_else(|| {\n+        let candidates = sysroot_candidates.iter()\n+            .map(|p| p.display().to_string())\n+            .collect::<Vec<_>>()\n+            .join(\"\\n* \");\n+        let err = format!(\"failed to find a `codegen-backends` folder \\\n+                           in the sysroot candidates:\\n* {}\", candidates);\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n     info!(\"probing {} for a codegen backend\", sysroot.display());\n \n-    let d = match sysroot.read_dir() {\n-        Ok(d) => d,\n-        Err(e) => {\n-            let err = format!(\"failed to load default codegen backend, couldn't \\\n-                               read `{}`: {}\", sysroot.display(), e);\n-            early_error(ErrorOutputType::default(), &err);\n-        }\n-    };\n+    let d = sysroot.read_dir().unwrap_or_else(|e| {\n+        let err = format!(\"failed to load default codegen backend, couldn't \\\n+                           read `{}`: {}\", sysroot.display(), e);\n+        early_error(ErrorOutputType::default(), &err);\n+    });\n \n     let mut file: Option<PathBuf> = None;\n \n@@ -378,8 +360,8 @@ fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n         }\n         if let Some(ref prev) = file {\n             let err = format!(\"duplicate codegen backends found\\n\\\n-                first:  {}\\n\\\n-                second: {}\\n\\\n+                               first:  {}\\n\\\n+                               second: {}\\n\\\n             \", prev.display(), path.display());\n             early_error(ErrorOutputType::default(), &err);\n         }\n@@ -391,7 +373,7 @@ fn get_codegen_sysroot(backend_name: &str) -> fn() -> Box<dyn CodegenBackend> {\n         None => {\n             let err = format!(\"failed to load default codegen backend for `{}`, \\\n                                no appropriate codegen dylib found in `{}`\",\n-                               backend_name, sysroot.display());\n+                              backend_name, sysroot.display());\n             early_error(ErrorOutputType::default(), &err);\n         }\n     }\n@@ -578,7 +560,7 @@ pub fn set_sigpipe_handler() {\n     unsafe {\n         // Set the SIGPIPE signal handler, so that an EPIPE\n         // will cause rustc to terminate, as expected.\n-        assert!(libc::signal(libc::SIGPIPE, libc::SIG_DFL) != libc::SIG_ERR);\n+        assert_ne!(libc::signal(libc::SIGPIPE, libc::SIG_DFL), libc::SIG_ERR);\n     }\n }\n \n@@ -996,7 +978,7 @@ impl RustcDefaultCalls {\n                          input: &Input)\n                          -> Compilation {\n         let r = matches.opt_strs(\"Z\");\n-        if r.contains(&(\"ls\".to_string())) {\n+        if r.iter().any(|s| *s == \"ls\") {\n             match input {\n                 &Input::File(ref ifile) => {\n                     let path = &(*ifile);\n@@ -1015,7 +997,7 @@ impl RustcDefaultCalls {\n             return Compilation::Stop;\n         }\n \n-        return Compilation::Continue;\n+        Compilation::Continue\n     }\n \n \n@@ -1028,7 +1010,7 @@ impl RustcDefaultCalls {\n         use rustc::session::config::PrintRequest::*;\n         // PrintRequest::NativeStaticLibs is special - printed during linking\n         // (empty iterator returns true)\n-        if sess.opts.prints.iter().all(|&p| p==PrintRequest::NativeStaticLibs) {\n+        if sess.opts.prints.iter().all(|&p| p == PrintRequest::NativeStaticLibs) {\n             return Compilation::Continue;\n         }\n \n@@ -1055,10 +1037,8 @@ impl RustcDefaultCalls {\n                 Sysroot => println!(\"{}\", sess.sysroot().display()),\n                 TargetSpec => println!(\"{}\", sess.target.target.to_json().pretty()),\n                 FileNames | CrateName => {\n-                    let input = match input {\n-                        Some(input) => input,\n-                        None => early_error(ErrorOutputType::default(), \"no input file provided\"),\n-                    };\n+                    let input = input.unwrap_or_else(||\n+                        early_error(ErrorOutputType::default(), \"no input file provided\"));\n                     let attrs = attrs.as_ref().unwrap();\n                     let t_outputs = driver::build_output_filenames(input, odir, ofile, attrs, sess);\n                     let id = rustc_codegen_utils::link::find_crate_name(Some(sess), attrs, input);\n@@ -1074,18 +1054,14 @@ impl RustcDefaultCalls {\n                             &id,\n                             &t_outputs\n                         );\n-                        println!(\"{}\",\n-                                 fname.file_name()\n-                                      .unwrap()\n-                                      .to_string_lossy());\n+                        println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n                     }\n                 }\n                 Cfg => {\n                     let allow_unstable_cfg = UnstableFeatures::from_environment()\n                         .is_nightly_build();\n \n-                    let mut cfgs = Vec::new();\n-                    for &(name, ref value) in sess.parse_sess.config.iter() {\n+                    let mut cfgs = sess.parse_sess.config.iter().filter_map(|&(name, ref value)| {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n                             ident: ast::Path::from_ident(ast::Ident::with_empty_ctxt(name)),\n                             node: ast::MetaItemKind::Word,\n@@ -1104,16 +1080,16 @@ impl RustcDefaultCalls {\n                         let value = value.as_ref().map(|s| s.as_ref());\n                         if name != \"target_feature\" || value != Some(\"crt-static\") {\n                             if !allow_unstable_cfg && gated_cfg.is_some() {\n-                                continue;\n+                                return None\n                             }\n                         }\n \n-                        cfgs.push(if let Some(value) = value {\n-                            format!(\"{}=\\\"{}\\\"\", name, value)\n+                        if let Some(value) = value {\n+                            Some(format!(\"{}=\\\"{}\\\"\", name, value))\n                         } else {\n-                            name.to_string()\n-                        });\n-                    }\n+                            Some(name.to_string())\n+                        }\n+                    }).collect::<Vec<String>>();\n \n                     cfgs.sort();\n                     for cfg in cfgs {\n@@ -1150,9 +1126,8 @@ fn commit_date_str() -> Option<&'static str> {\n pub fn version(binary: &str, matches: &getopts::Matches) {\n     let verbose = matches.opt_present(\"verbose\");\n \n-    println!(\"{} {}\",\n-             binary,\n-             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"));\n+    println!(\"{} {}\", binary, option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"));\n+\n     if verbose {\n         fn unw(x: Option<&str>) -> &str {\n             x.unwrap_or(\"unknown\")\n@@ -1176,7 +1151,7 @@ fn usage(verbose: bool, include_unstable_options: bool) {\n     for option in groups.iter().filter(|x| include_unstable_options || x.is_stable()) {\n         (option.apply)(&mut options);\n     }\n-    let message = \"Usage: rustc [OPTIONS] INPUT\".to_string();\n+    let message = \"Usage: rustc [OPTIONS] INPUT\";\n     let nightly_help = if nightly_options::is_nightly_build() {\n         \"\\n    -Z help             Print internal options for debugging rustc\"\n     } else {\n@@ -1191,7 +1166,7 @@ fn usage(verbose: bool, include_unstable_options: bool) {\n     -C help             Print codegen options\n     -W help             \\\n               Print 'lint' options and default settings{}{}\\n\",\n-             options.usage(&message),\n+             options.usage(message),\n              nightly_help,\n              verbose_help);\n }\n@@ -1273,8 +1248,6 @@ Available lint options:\n \n     print_lints(builtin);\n \n-\n-\n     let max_name_len = max(\"warnings\".len(),\n                            plugin_groups.iter()\n                                         .chain(&builtin_groups)\n@@ -1407,10 +1380,8 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     for option in config::rustc_optgroups() {\n         (option.apply)(&mut options);\n     }\n-    let matches = match options.parse(args) {\n-        Ok(m) => m,\n-        Err(f) => early_error(ErrorOutputType::default(), &f.to_string()),\n-    };\n+    let matches = options.parse(args).unwrap_or_else(|f|\n+        early_error(ErrorOutputType::default(), &f.to_string()));\n \n     // For all options we just parsed, we check a few aspects:\n     //\n@@ -1452,6 +1423,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     let cg_flags = matches.opt_strs(\"C\");\n+\n     if cg_flags.iter().any(|x| *x == \"help\") {\n         describe_codegen_flags();\n         return None;\n@@ -1462,7 +1434,7 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n                    \"the --no-stack-check flag is deprecated and does nothing\");\n     }\n \n-    if cg_flags.contains(&\"passes=list\".to_string()) {\n+    if cg_flags.iter().any(|x| *x == \"passes=list\") {\n         get_codegen_sysroot(\"llvm\")().print_passes();\n         return None;\n     }\n@@ -1500,7 +1472,7 @@ pub fn in_named_rustc_thread<F, R>(name: String, f: F) -> Result<R, Box<dyn Any\n     // Temporarily have stack size set to 16MB to deal with nom-using crates failing\n     const STACK_SIZE: usize = 16 * 1024 * 1024; // 16MB\n \n-    #[cfg(all(unix,not(target_os = \"haiku\")))]\n+    #[cfg(all(unix, not(target_os = \"haiku\")))]\n     let spawn_thread = unsafe {\n         // Fetch the current resource limits\n         let mut rlim = libc::rlimit {\n@@ -1554,7 +1526,7 @@ pub fn in_named_rustc_thread<F, R>(name: String, f: F) -> Result<R, Box<dyn Any\n         }\n     };\n \n-    #[cfg(not(any(windows,unix)))]\n+    #[cfg(not(any(windows, unix)))]\n     let spawn_thread = true;\n \n     // The or condition is added from backward compatibility.\n@@ -1632,7 +1604,7 @@ fn extra_compiler_flags() -> Option<(Vec<String>, bool)> {\n         }\n     }\n \n-    if result.len() > 0 {\n+    if !result.is_empty() {\n         Some((result, excluded_cargo_defaults))\n     } else {\n         None\n@@ -1680,25 +1652,25 @@ pub fn monitor<F: FnOnce() + Send + 'static>(f: F) -> Result<(), CompilationFail\n                              errors::Level::Bug);\n             }\n \n-            let mut xs = vec![\n-                \"the compiler unexpectedly panicked. this is a bug.\".to_string(),\n-                format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL),\n+            let mut xs: Vec<Cow<'static, str>> = vec![\n+                \"the compiler unexpectedly panicked. this is a bug.\".into(),\n+                format!(\"we would appreciate a bug report: {}\", BUG_REPORT_URL).into(),\n                 format!(\"rustc {} running on {}\",\n                         option_env!(\"CFG_VERSION\").unwrap_or(\"unknown_version\"),\n-                        config::host_triple()),\n+                        config::host_triple()).into(),\n             ];\n \n             if let Some((flags, excluded_cargo_defaults)) = extra_compiler_flags() {\n-                xs.push(format!(\"compiler flags: {}\", flags.join(\" \")));\n+                xs.push(format!(\"compiler flags: {}\", flags.join(\" \")).into());\n \n                 if excluded_cargo_defaults {\n-                    xs.push(\"some of the compiler flags provided by cargo are hidden\".to_string());\n+                    xs.push(\"some of the compiler flags provided by cargo are hidden\".into());\n                 }\n             }\n \n             for note in &xs {\n                 handler.emit(&MultiSpan::new(),\n-                             &note,\n+                             note,\n                              errors::Level::Note);\n             }\n "}, {"sha": "b4f6d10b1f829f91f96004b13b60429b7ff643a9", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -167,10 +167,10 @@ pub fn parse_pretty(sess: &Session,\n impl PpSourceMode {\n     /// Constructs a `PrinterSupport` object and passes it to `f`.\n     fn call_with_pp_support<'tcx, A, F>(&self,\n-                                           sess: &'tcx Session,\n-                                           hir_map: Option<&hir_map::Map<'tcx>>,\n-                                           f: F)\n-                                           -> A\n+                                        sess: &'tcx Session,\n+                                        hir_map: Option<&hir_map::Map<'tcx>>,\n+                                        f: F)\n+                                        -> A\n         where F: FnOnce(&dyn PrinterSupport) -> A\n     {\n         match *self {\n@@ -198,17 +198,18 @@ impl PpSourceMode {\n             _ => panic!(\"Should use call_with_pp_support_hir\"),\n         }\n     }\n-    fn call_with_pp_support_hir<'tcx, A, F>(&self,\n-                                               sess: &'tcx Session,\n-                                               cstore: &'tcx CStore,\n-                                               hir_map: &hir_map::Map<'tcx>,\n-                                               analysis: &ty::CrateAnalysis,\n-                                               resolutions: &Resolutions,\n-                                               arenas: &'tcx AllArenas<'tcx>,\n-                                               output_filenames: &OutputFilenames,\n-                                               id: &str,\n-                                               f: F)\n-                                               -> A\n+    fn call_with_pp_support_hir<'tcx, A, F>(\n+        &self,\n+        sess: &'tcx Session,\n+        cstore: &'tcx CStore,\n+        hir_map: &hir_map::Map<'tcx>,\n+        analysis: &ty::CrateAnalysis,\n+        resolutions: &Resolutions,\n+        arenas: &'tcx AllArenas<'tcx>,\n+        output_filenames: &OutputFilenames,\n+        id: &str,\n+        f: F\n+    ) -> A\n         where F: FnOnce(&dyn HirPrinterSupport, &hir::Crate) -> A\n     {\n         match *self {\n@@ -855,7 +856,7 @@ fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n                     break n.body();\n                 }\n                 let parent = tcx.hir.get_parent_node(node_id);\n-                assert!(node_id != parent);\n+                assert_ne!(node_id, parent);\n                 node_id = parent;\n             }\n         }\n@@ -952,18 +953,17 @@ pub fn print_after_parsing(sess: &Session,\n         // Silently ignores an identified node.\n         let out: &mut dyn Write = &mut out;\n         s.call_with_pp_support(sess, None, move |annotation| {\n-                debug!(\"pretty printing source code {:?}\", s);\n-                let sess = annotation.sess();\n-                pprust::print_crate(sess.source_map(),\n-                                    &sess.parse_sess,\n-                                    krate,\n-                                    src_name,\n-                                    &mut rdr,\n-                                    box out,\n-                                    annotation.pp_ann(),\n-                                    false)\n-            })\n-            .unwrap()\n+            debug!(\"pretty printing source code {:?}\", s);\n+            let sess = annotation.sess();\n+            pprust::print_crate(sess.source_map(),\n+                                &sess.parse_sess,\n+                                krate,\n+                                src_name,\n+                                &mut rdr,\n+                                box out,\n+                                annotation.pp_ann(),\n+                                false)\n+        }).unwrap()\n     } else {\n         unreachable!();\n     };"}, {"sha": "d334a9476ce249d0d2f271fc5706b68ce0bb688c", "filename": "src/librustc_driver/profile/mod.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Fmod.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -23,7 +23,7 @@ pub fn begin(sess: &Session) {\n     use std::sync::mpsc::{channel};\n     let (tx, rx) = channel();\n     if profq_set_chan(sess, tx) {\n-        thread::spawn(move||profile_queries_thread(rx));\n+        thread::spawn(move || profile_queries_thread(rx));\n     }\n }\n \n@@ -34,11 +34,12 @@ pub fn begin(sess: &Session) {\n pub fn dump(sess: &Session, path: String) {\n     use std::sync::mpsc::{channel};\n     let (tx, rx) = channel();\n-    let params = ProfQDumpParams{\n-        path, ack:tx,\n+    let params = ProfQDumpParams {\n+        path,\n+        ack: tx,\n         // FIXME: Add another compiler flag to toggle whether this log\n         // is written; false for now\n-        dump_profq_msg_log:true,\n+        dump_profq_msg_log: true,\n     };\n     profq_msg(sess, ProfileQueriesMsg::Dump(params));\n     let _ = rx.recv().unwrap();\n@@ -63,20 +64,20 @@ struct StackFrame {\n }\n \n fn total_duration(traces: &[trace::Rec]) -> Duration {\n-    let mut sum : Duration = Duration::new(0,0);\n+    let mut sum : Duration = Duration::new(0, 0);\n     for t in traces.iter() { sum += t.dur_total; }\n     return sum\n }\n \n // profiling thread; retains state (in local variables) and dump traces, upon request.\n-fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n+fn profile_queries_thread(r: Receiver<ProfileQueriesMsg>) {\n     use self::trace::*;\n     use std::fs::File;\n     use std::time::{Instant};\n \n-    let mut profq_msgs : Vec<ProfileQueriesMsg> = vec![];\n-    let mut frame : StackFrame = StackFrame{ parse_st:ParseState::Clear, traces:vec![] };\n-    let mut stack : Vec<StackFrame> = vec![];\n+    let mut profq_msgs: Vec<ProfileQueriesMsg> = vec![];\n+    let mut frame: StackFrame = StackFrame { parse_st: ParseState::Clear, traces: vec![] };\n+    let mut stack: Vec<StackFrame> = vec![];\n     loop {\n         let msg = r.recv();\n         if let Err(_recv_err) = msg {\n@@ -90,7 +91,7 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n         match msg {\n             ProfileQueriesMsg::Halt => return,\n             ProfileQueriesMsg::Dump(params) => {\n-                assert!(stack.len() == 0);\n+                assert!(stack.is_empty());\n                 assert!(frame.parse_st == ParseState::Clear);\n                 {\n                     // write log of all messages\n@@ -109,17 +110,14 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n                     let counts_path = format!(\"{}.counts.txt\", params.path);\n                     let mut counts_file = File::create(&counts_path).unwrap();\n \n-                    write!(html_file, \"<html>\\n\").unwrap();\n-                    write!(html_file,\n-                           \"<head>\\n<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\",\n-                           \"profile_queries.css\").unwrap();\n-                    write!(html_file, \"<style>\\n\").unwrap();\n+                    writeln!(html_file,\n+                        \"<html>\\n<head>\\n<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\",\n+                        \"profile_queries.css\").unwrap();\n+                    writeln!(html_file, \"<style>\").unwrap();\n                     trace::write_style(&mut html_file);\n-                    write!(html_file, \"</style>\\n\").unwrap();\n-                    write!(html_file, \"</head>\\n\").unwrap();\n-                    write!(html_file, \"<body>\\n\").unwrap();\n+                    writeln!(html_file, \"</style>\\n</head>\\n<body>\").unwrap();\n                     trace::write_traces(&mut html_file, &mut counts_file, &frame.traces);\n-                    write!(html_file, \"</body>\\n</html>\\n\").unwrap();\n+                    writeln!(html_file, \"</body>\\n</html>\").unwrap();\n \n                     let ack_path = format!(\"{}.ack\", params.path);\n                     let ack_file = File::create(&ack_path).unwrap();\n@@ -141,10 +139,10 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n \n                     // Parse State: Clear\n                     (ParseState::Clear,\n-                     ProfileQueriesMsg::QueryBegin(span,querymsg)) => {\n+                     ProfileQueriesMsg::QueryBegin(span, querymsg)) => {\n                         let start = Instant::now();\n                         frame.parse_st = ParseState::HaveQuery\n-                            (Query{span:span, msg:querymsg}, start)\n+                            (Query { span, msg: querymsg }, start)\n                     },\n                     (ParseState::Clear,\n                      ProfileQueriesMsg::CacheHit) => {\n@@ -287,8 +285,6 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n                         frame = StackFrame{parse_st:ParseState::Clear, traces:vec![]};\n                     },\n \n-                    //\n-                    //\n                     // Parse errors:\n \n                     (ParseState::HaveQuery(q,_),\n@@ -310,7 +306,6 @@ fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n                         unreachable!()\n                     },\n                 }\n-\n             }\n         }\n     }"}, {"sha": "9589ae2a8dbe0032848633a6b04342987109a3cf", "filename": "src/librustc_driver/profile/trace.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -43,18 +43,18 @@ pub struct QueryMetric {\n     pub dur_total: Duration,\n }\n \n+fn cons(s: &str) -> String {\n+    let first = s.split(|d| d == '(' || d == '{').next();\n+    assert!(first.is_some() && first != Some(\"\"));\n+    first.unwrap().to_owned()\n+}\n+\n pub fn cons_of_query_msg(q: &trace::Query) -> String {\n-    let s = format!(\"{:?}\", q.msg);\n-    let cons: Vec<&str> = s.split(|d| d == '(' || d == '{').collect();\n-    assert!(cons.len() > 0 && cons[0] != \"\");\n-    cons[0].to_string()\n+    cons(&format!(\"{:?}\", q.msg))\n }\n \n pub fn cons_of_key(k: &DepNode) -> String {\n-    let s = format!(\"{:?}\", k);\n-    let cons: Vec<&str> = s.split(|d| d == '(' || d == '{').collect();\n-    assert!(cons.len() > 0 && cons[0] != \"\");\n-    cons[0].to_string()\n+    cons(&format!(\"{:?}\", k))\n }\n \n // First return value is text; second return value is a CSS class\n@@ -84,35 +84,33 @@ pub fn html_of_effect(eff: &Effect) -> (String, String) {\n // First return value is text; second return value is a CSS class\n fn html_of_duration(_start: &Instant, dur: &Duration) -> (String, String) {\n     use rustc::util::common::duration_to_secs_str;\n-    (duration_to_secs_str(dur.clone()),\n-     String::new()\n-    )\n+    (duration_to_secs_str(dur.clone()), String::new())\n }\n \n-fn html_of_fraction(frac: f64) -> (String, String) {\n+fn html_of_fraction(frac: f64) -> (String, &'static str) {\n     let css = {\n-        if       frac > 0.50  { \"frac-50\".to_string() }\n-        else if  frac > 0.40  { \"frac-40\".to_string() }\n-        else if  frac > 0.30  { \"frac-30\".to_string() }\n-        else if  frac > 0.20  { \"frac-20\".to_string() }\n-        else if  frac > 0.10  { \"frac-10\".to_string() }\n-        else if  frac > 0.05  { \"frac-05\".to_string() }\n-        else if  frac > 0.02  { \"frac-02\".to_string() }\n-        else if  frac > 0.01  { \"frac-01\".to_string() }\n-        else if  frac > 0.001 { \"frac-001\".to_string() }\n-        else                  { \"frac-0\".to_string() }\n+        if       frac > 0.50  { \"frac-50\" }\n+        else if  frac > 0.40  { \"frac-40\" }\n+        else if  frac > 0.30  { \"frac-30\" }\n+        else if  frac > 0.20  { \"frac-20\" }\n+        else if  frac > 0.10  { \"frac-10\" }\n+        else if  frac > 0.05  { \"frac-05\" }\n+        else if  frac > 0.02  { \"frac-02\" }\n+        else if  frac > 0.01  { \"frac-01\" }\n+        else if  frac > 0.001 { \"frac-001\" }\n+        else                  { \"frac-0\" }\n     };\n     let percent = frac * 100.0;\n-    if percent > 0.1 { (format!(\"{:.1}%\", percent), css) }\n-    else { (\"< 0.1%\".to_string(), css) }\n+\n+    if percent > 0.1 {\n+        (format!(\"{:.1}%\", percent), css)\n+    } else {\n+        (\"< 0.1%\".to_string(), css)\n+    }\n }\n \n fn total_duration(traces: &[Rec]) -> Duration {\n-    let mut sum : Duration = Duration::new(0,0);\n-    for t in traces.iter() {\n-        sum += t.dur_total;\n-    }\n-    return sum\n+    Duration::new(0, 0) + traces.iter().map(|t| t.dur_total).sum()\n }\n \n fn duration_div(nom: Duration, den: Duration) -> f64 {\n@@ -130,64 +128,65 @@ fn write_traces_rec(file: &mut File, traces: &[Rec], total: Duration, depth: usi\n         let fraction = duration_div(t.dur_total, total);\n         let percent = fraction * 100.0;\n         let (frc_text, frc_css_classes) = html_of_fraction(fraction);\n-        write!(file, \"<div class=\\\"trace depth-{} extent-{}{} {} {} {}\\\">\\n\",\n-               depth,\n-               t.extent.len(),\n-               /* Heuristic for 'important' CSS class: */\n-               if t.extent.len() > 5 || percent >= 1.0 {\n-                   \" important\" }\n-               else { \"\" },\n-               eff_css_classes,\n-               dur_css_classes,\n-               frc_css_classes,\n+        writeln!(file, \"<div class=\\\"trace depth-{} extent-{}{} {} {} {}\\\">\",\n+                 depth,\n+                 t.extent.len(),\n+                 /* Heuristic for 'important' CSS class: */\n+                 if t.extent.len() > 5 || percent >= 1.0 { \" important\" } else { \"\" },\n+                 eff_css_classes,\n+                 dur_css_classes,\n+                 frc_css_classes,\n         ).unwrap();\n-        write!(file, \"<div class=\\\"eff\\\">{}</div>\\n\", eff_text).unwrap();\n-        write!(file, \"<div class=\\\"dur\\\">{}</div>\\n\", dur_text).unwrap();\n-        write!(file, \"<div class=\\\"frc\\\">{}</div>\\n\", frc_text).unwrap();\n+        writeln!(file, \"<div class=\\\"eff\\\">{}</div>\", eff_text).unwrap();\n+        writeln!(file, \"<div class=\\\"dur\\\">{}</div>\", dur_text).unwrap();\n+        writeln!(file, \"<div class=\\\"frc\\\">{}</div>\", frc_text).unwrap();\n         write_traces_rec(file, &t.extent, total, depth + 1);\n-        write!(file, \"</div>\\n\").unwrap();\n+        writeln!(file, \"</div>\").unwrap();\n     }\n }\n \n fn compute_counts_rec(counts: &mut FxHashMap<String,QueryMetric>, traces: &[Rec]) {\n+    counts.reserve(traces.len());\n     for t in traces.iter() {\n         match t.effect {\n             Effect::TimeBegin(ref msg) => {\n                 let qm = match counts.get(msg) {\n-                    Some(_qm) => { panic!(\"TimeBegin with non-unique, repeat message\") }\n-                    None => QueryMetric{\n+                    Some(_qm) => panic!(\"TimeBegin with non-unique, repeat message\"),\n+                    None => QueryMetric {\n                         count: 1,\n                         dur_self: t.dur_self,\n                         dur_total: t.dur_total,\n-                    }};\n+                    }\n+                };\n                 counts.insert(msg.clone(), qm);\n             },\n             Effect::TaskBegin(ref key) => {\n                 let cons = cons_of_key(key);\n                 let qm = match counts.get(&cons) {\n                     Some(qm) =>\n-                        QueryMetric{\n+                        QueryMetric {\n                             count: qm.count + 1,\n                             dur_self: qm.dur_self + t.dur_self,\n                             dur_total: qm.dur_total + t.dur_total,\n                         },\n-                    None => QueryMetric{\n+                    None => QueryMetric {\n                         count: 1,\n                         dur_self: t.dur_self,\n                         dur_total: t.dur_total,\n-                    }};\n+                    }\n+                };\n                 counts.insert(cons, qm);\n             },\n             Effect::QueryBegin(ref qmsg, ref _cc) => {\n                 let qcons = cons_of_query_msg(qmsg);\n                 let qm = match counts.get(&qcons) {\n                     Some(qm) =>\n-                        QueryMetric{\n+                        QueryMetric {\n                             count: qm.count + 1,\n                             dur_total: qm.dur_total + t.dur_total,\n                             dur_self: qm.dur_self + t.dur_self\n                         },\n-                    None => QueryMetric{\n+                    None => QueryMetric {\n                         count: 1,\n                         dur_total: t.dur_total,\n                         dur_self: t.dur_self,\n@@ -200,19 +199,20 @@ fn compute_counts_rec(counts: &mut FxHashMap<String,QueryMetric>, traces: &[Rec]\n     }\n }\n \n-pub fn write_counts(count_file: &mut File, counts: &mut FxHashMap<String,QueryMetric>) {\n+pub fn write_counts(count_file: &mut File, counts: &mut FxHashMap<String, QueryMetric>) {\n     use rustc::util::common::duration_to_secs_str;\n     use std::cmp::Reverse;\n \n     let mut data = counts.iter().map(|(ref cons, ref qm)|\n         (cons.clone(), qm.count.clone(), qm.dur_total.clone(), qm.dur_self.clone())\n     ).collect::<Vec<_>>();\n+\n     data.sort_by_key(|k| Reverse(k.3));\n     for (cons, count, dur_total, dur_self) in data {\n-        write!(count_file, \"{}, {}, {}, {}\\n\",\n-               cons, count,\n-               duration_to_secs_str(dur_total),\n-               duration_to_secs_str(dur_self)\n+        writeln!(count_file, \"{}, {}, {}, {}\",\n+                 cons, count,\n+                 duration_to_secs_str(dur_total),\n+                 duration_to_secs_str(dur_self)\n         ).unwrap();\n     }\n }\n@@ -223,12 +223,12 @@ pub fn write_traces(html_file: &mut File, counts_file: &mut File, traces: &[Rec]\n     compute_counts_rec(&mut counts, traces);\n     write_counts(counts_file, &mut counts);\n \n-    let total : Duration = total_duration(traces);\n+    let total: Duration = total_duration(traces);\n     write_traces_rec(html_file, traces, total, 0)\n }\n \n pub fn write_style(html_file: &mut File) {\n-    write!(html_file,\"{}\", \"\n+    write!(html_file, \"{}\", \"\n body {\n     font-family: sans-serif;\n     background: black;"}, {"sha": "7d178d209672052da3c96d13b16611b572454cb8", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -80,10 +80,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                 match callee.node {\n                     hir::ExprKind::Path(ref qpath) => {\n                         let def = cx.tables.qpath_def(qpath, callee.hir_id);\n-                        if let Def::Fn(_) = def {\n-                            Some(def)\n-                        } else {  // `Def::Local` if it was a closure, for which we\n-                            None  // do not currently support must-use linting\n+                        match def {\n+                            Def::Fn(_) | Def::Method(_) => Some(def),\n+                            // `Def::Local` if it was a closure, for which we\n+                            // do not currently support must-use linting\n+                            _ => None\n                         }\n                     },\n                     _ => None"}, {"sha": "f4ddfa5293e1e93df12af2908a1d0b61d6594549", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -327,7 +327,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait\n-                let trait_ref = data.principal().unwrap().with_self_ty(\n+                let trait_ref = data.principal().with_self_ty(\n                     *self.tcx,\n                     src_pointee_ty,\n                 );"}, {"sha": "dd83d3157ba61dbc9c87c0fecae14b0ac3152852", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -907,22 +907,20 @@ fn create_mono_items_for_vtable_methods<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             !impl_ty.needs_subst() && !impl_ty.has_escaping_regions());\n \n     if let ty::Dynamic(ref trait_ty, ..) = trait_ty.sty {\n-        if let Some(principal) = trait_ty.principal() {\n-            let poly_trait_ref = principal.with_self_ty(tcx, impl_ty);\n-            assert!(!poly_trait_ref.has_escaping_regions());\n-\n-            // Walk all methods of the trait, including those of its supertraits\n-            let methods = tcx.vtable_methods(poly_trait_ref);\n-            let methods = methods.iter().cloned().filter_map(|method| method)\n-                .map(|(def_id, substs)| ty::Instance::resolve(\n-                        tcx,\n-                        ty::ParamEnv::reveal_all(),\n-                        def_id,\n-                        substs).unwrap())\n-                .filter(|&instance| should_monomorphize_locally(tcx, &instance))\n-                .map(|instance| create_fn_mono_item(instance));\n-            output.extend(methods);\n-        }\n+        let poly_trait_ref = trait_ty.principal().with_self_ty(tcx, impl_ty);\n+        assert!(!poly_trait_ref.has_escaping_regions());\n+\n+        // Walk all methods of the trait, including those of its supertraits\n+        let methods = tcx.vtable_methods(poly_trait_ref);\n+        let methods = methods.iter().cloned().filter_map(|method| method)\n+            .map(|(def_id, substs)| ty::Instance::resolve(\n+                    tcx,\n+                    ty::ParamEnv::reveal_all(),\n+                    def_id,\n+                    substs).unwrap())\n+            .filter(|&instance| should_monomorphize_locally(tcx, &instance))\n+            .map(|instance| create_fn_mono_item(instance));\n+        output.extend(methods);\n         // Also add the destructor\n         visit_drop_use(tcx, impl_ty, false, output);\n     }"}, {"sha": "4c4d56c8938386af83b716168b4c2ea82f12f9cf", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -320,12 +320,13 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n                 output.push(']');\n             },\n             ty::Dynamic(ref trait_data, ..) => {\n-                if let Some(principal) = trait_data.principal() {\n-                    self.push_def_path(principal.def_id(), output);\n-                    self.push_type_params(principal.skip_binder().substs,\n-                        trait_data.projection_bounds(),\n-                        output);\n-                }\n+                let principal = trait_data.principal();\n+                self.push_def_path(principal.def_id(), output);\n+                self.push_type_params(\n+                    principal.skip_binder().substs,\n+                    trait_data.projection_bounds(),\n+                    output,\n+                );\n             },\n             ty::Foreign(did) => self.push_def_path(did, output),\n             ty::FnDef(..) |"}, {"sha": "5963f1a481c659942fca679b6ce4d13ea7696718", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -19,7 +19,7 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n use rustc::mir::*;\n use rustc::mir::visit::*;\n-use rustc::ty::{self, Instance, Ty, TyCtxt};\n+use rustc::ty::{self, Instance, InstanceDef, Ty, TyCtxt};\n use rustc::ty::subst::{Subst,Substs};\n \n use std::collections::VecDeque;\n@@ -100,12 +100,21 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                                                                       param_env,\n                                                                       callee_def_id,\n                                                                       substs) {\n-                                callsites.push_back(CallSite {\n-                                    callee: instance.def_id(),\n-                                    substs: instance.substs,\n-                                    bb,\n-                                    location: terminator.source_info\n-                                });\n+                                let is_virtual =\n+                                    if let InstanceDef::Virtual(..) = instance.def {\n+                                        true\n+                                    } else {\n+                                        false\n+                                    };\n+\n+                                if !is_virtual {\n+                                    callsites.push_back(CallSite {\n+                                        callee: instance.def_id(),\n+                                        substs: instance.substs,\n+                                        bb,\n+                                        location: terminator.source_info\n+                                    });\n+                                }\n                             }\n                         }\n                     }"}, {"sha": "989851bb1b9b4d126bed1496346b6ce77716e19c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -93,8 +93,7 @@ impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n         let ty_def_id = match self.tcx.type_of(item_def_id).sty {\n             ty::Adt(adt, _) => adt.did,\n             ty::Foreign(did) => did,\n-            ty::Dynamic(ref obj, ..) if obj.principal().is_some() =>\n-                obj.principal().unwrap().def_id(),\n+            ty::Dynamic(ref obj, ..) => obj.principal().def_id(),\n             ty::Projection(ref proj) => proj.trait_ref(self.tcx).def_id,\n             _ => return Some(AccessLevel::Public)\n         };\n@@ -484,7 +483,7 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n         let ty_def_id = match ty.sty {\n             ty::Adt(adt, _) => Some(adt.did),\n             ty::Foreign(did) => Some(did),\n-            ty::Dynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n+            ty::Dynamic(ref obj, ..) => Some(obj.principal().def_id()),\n             ty::Projection(ref proj) => Some(proj.item_def_id),\n             ty::FnDef(def_id, ..) |\n             ty::Closure(def_id, ..) |\n@@ -1456,7 +1455,7 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n         let ty_def_id = match ty.sty {\n             ty::Adt(adt, _) => Some(adt.did),\n             ty::Foreign(did) => Some(did),\n-            ty::Dynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n+            ty::Dynamic(ref obj, ..) => Some(obj.principal().def_id()),\n             ty::Projection(ref proj) => {\n                 if self.required_visibility == ty::Visibility::Invisible {\n                     // Conservatively approximate the whole type alias as public without"}, {"sha": "9ee4582fabf7b3b594f444209a6c31d5d9dc2356", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -680,6 +680,12 @@ pub struct TargetOptions {\n     /// typically because the platform needs to unwind for things like stack\n     /// unwinders.\n     pub requires_uwtable: bool,\n+\n+    /// Whether or not SIMD types are passed by reference in the Rust ABI,\n+    /// typically required if a target can be compiled with a mixed set of\n+    /// target features. This is `true` by default, and `false` for targets like\n+    /// wasm32 where the whole program either has simd or not.\n+    pub simd_types_indirect: bool,\n }\n \n impl Default for TargetOptions {\n@@ -760,6 +766,7 @@ impl Default for TargetOptions {\n             embed_bitcode: false,\n             emit_debug_gdb_scripts: true,\n             requires_uwtable: false,\n+            simd_types_indirect: true,\n         }\n     }\n }\n@@ -1041,6 +1048,7 @@ impl Target {\n         key!(embed_bitcode, bool);\n         key!(emit_debug_gdb_scripts, bool);\n         key!(requires_uwtable, bool);\n+        key!(simd_types_indirect, bool);\n \n         if let Some(array) = obj.find(\"abi-blacklist\").and_then(Json::as_array) {\n             for name in array.iter().filter_map(|abi| abi.as_string()) {\n@@ -1250,6 +1258,7 @@ impl ToJson for Target {\n         target_option_val!(embed_bitcode);\n         target_option_val!(emit_debug_gdb_scripts);\n         target_option_val!(requires_uwtable);\n+        target_option_val!(simd_types_indirect);\n \n         if default.abi_blacklist != self.options.abi_blacklist {\n             d.insert(\"abi-blacklist\".to_string(), self.options.abi_blacklist.iter()"}, {"sha": "46353068bd04588840787936f803949adc1d8d17", "filename": "src/librustc_target/spec/wasm32_unknown_unknown.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_unknown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_unknown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwasm32_unknown_unknown.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -54,6 +54,12 @@ pub fn target() -> Result<Target, String> {\n         linker: Some(\"rust-lld\".to_owned()),\n         lld_flavor: LldFlavor::Wasm,\n \n+        // No need for indirection here, simd types can always be passed by\n+        // value as the whole module either has simd or not, which is different\n+        // from x86 (for example) where programs can have functions that don't\n+        // enable simd features.\n+        simd_types_indirect: false,\n+\n         .. Default::default()\n     };\n     Ok(Target {"}, {"sha": "e0ee26cba082842aab75d16aa133f5b5f0a903d3", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -73,7 +73,7 @@ enum PointerKind<'tcx> {\n     /// No metadata attached, ie pointer to sized type or foreign type\n     Thin,\n     /// A trait object\n-    Vtable(Option<DefId>),\n+    Vtable(DefId),\n     /// Slice\n     Length,\n     /// The unsize info of this projection\n@@ -105,7 +105,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         Ok(match t.sty {\n             ty::Slice(_) | ty::Str => Some(PointerKind::Length),\n             ty::Dynamic(ref tty, ..) =>\n-                Some(PointerKind::Vtable(tty.principal().map(|p| p.def_id()))),\n+                Some(PointerKind::Vtable(tty.principal().def_id())),\n             ty::Adt(def, substs) if def.is_struct() => {\n                 match def.non_enum_variant().fields.last() {\n                     None => Some(PointerKind::Thin),"}, {"sha": "940fa4d3916bc3a0fdc1459200f748f5a37c680b", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -198,9 +198,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.deduce_sig_from_projection(None, &pb)\n                     })\n                     .next();\n-                let kind = object_type\n-                    .principal()\n-                    .and_then(|p| self.tcx.lang_items().fn_trait_kind(p.def_id()));\n+                let kind = self.tcx.lang_items().fn_trait_kind(object_type.principal().def_id());\n                 (sig, kind)\n             }\n             ty::Infer(ty::TyVar(vid)) => self.deduce_expectations_from_obligations(vid),"}, {"sha": "75f5bf74c6aef32e40019bf29f57f2f75ea754a7", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -290,7 +290,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             .include_raw_pointers()\n             .filter_map(|(ty, _)|\n                 match ty.sty {\n-                    ty::Dynamic(ref data, ..) => data.principal().map(|p| closure(self, ty, p)),\n+                    ty::Dynamic(ref data, ..) => Some(closure(self, ty, data.principal())),\n                     _ => None,\n                 }\n             )"}, {"sha": "ae02cd64c38916bf0c03413e5dd21f87ffd2fd3b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -452,10 +452,9 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         match self_ty.sty {\n             ty::Dynamic(ref data, ..) => {\n-                if let Some(p) = data.principal() {\n-                    self.assemble_inherent_candidates_from_object(self_ty, p);\n-                    self.assemble_inherent_impl_candidates_for_type(p.def_id());\n-                }\n+                let p = data.principal();\n+                self.assemble_inherent_candidates_from_object(self_ty, p);\n+                self.assemble_inherent_impl_candidates_for_type(p.def_id());\n             }\n             ty::Adt(def, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(def.did);"}, {"sha": "2006796a1008927f9dcd011c2d0d27d734208b44", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -663,8 +663,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 ty::Adt(def, _) => def.did.is_local(),\n                 ty::Foreign(did) => did.is_local(),\n \n-                ty::Dynamic(ref tr, ..) => tr.principal()\n-                    .map_or(false, |p| p.def_id().is_local()),\n+                ty::Dynamic(ref tr, ..) => tr.principal().def_id().is_local(),\n \n                 ty::Param(_) => true,\n "}, {"sha": "ec979dea4fd03fb0a03ba73cb85140f53c12b7b3", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -108,8 +108,8 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for InherentCollect<'a, 'tcx> {\n             ty::Foreign(did) => {\n                 self.check_def_id(item, did);\n             }\n-            ty::Dynamic(ref data, ..) if data.principal().is_some() => {\n-                self.check_def_id(item, data.principal().unwrap().def_id());\n+            ty::Dynamic(ref data, ..) => {\n+                self.check_def_id(item, data.principal().def_id());\n             }\n             ty::Char => {\n                 self.check_primitive_impl(def_id,"}, {"sha": "9b17654d4690c7f24add30b5ac58919e8e7240b3", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -181,13 +181,12 @@ fn check_impl_overlap<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeI\n         // This is something like impl Trait1 for Trait2. Illegal\n         // if Trait1 is a supertrait of Trait2 or Trait2 is not object safe.\n \n-        if data.principal().map_or(true, |p| !tcx.is_object_safe(p.def_id())) {\n+        if !tcx.is_object_safe(data.principal().def_id()) {\n             // This is an error, but it will be reported by wfcheck.  Ignore it here.\n             // This is tested by `coherence-impl-trait-for-trait-object-safe.rs`.\n         } else {\n             let mut supertrait_def_ids =\n-                traits::supertrait_def_ids(tcx,\n-                                           data.principal().unwrap().def_id());\n+                traits::supertrait_def_ids(tcx, data.principal().def_id());\n             if supertrait_def_ids.any(|d| d == trait_def_id) {\n                 let sp = tcx.sess.source_map().def_span(tcx.span_of_impl(impl_def_id).unwrap());\n                 struct_span_err!(tcx.sess,"}, {"sha": "132da8f5cea8dc472ad3119bce6817aad1fc2f89", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -203,28 +203,27 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 debug!(\"Dynamic\");\n                 debug!(\"field_ty = {}\", &field_ty);\n                 debug!(\"ty in field = {}\", &ty);\n-                if let Some(ex_trait_ref) = obj.principal() {\n-                    // Here, we are passing the type `usize` as a\n-                    // placeholder value with the function\n-                    // `with_self_ty`, since there is no concrete type\n-                    // `Self` for a `dyn Trait` at this\n-                    // stage. Therefore when checking explicit\n-                    // predicates in `check_explicit_predicates` we\n-                    // need to ignore checking the explicit_map for\n-                    // Self type.\n-                    let substs = ex_trait_ref\n-                        .with_self_ty(tcx, tcx.types.usize)\n-                        .skip_binder()\n-                        .substs;\n-                    check_explicit_predicates(\n-                        tcx,\n-                        &ex_trait_ref.skip_binder().def_id,\n-                        substs,\n-                        required_predicates,\n-                        explicit_map,\n-                        IgnoreSelfTy(true),\n-                    );\n-                }\n+                let ex_trait_ref = obj.principal();\n+                // Here, we are passing the type `usize` as a\n+                // placeholder value with the function\n+                // `with_self_ty`, since there is no concrete type\n+                // `Self` for a `dyn Trait` at this\n+                // stage. Therefore when checking explicit\n+                // predicates in `check_explicit_predicates` we\n+                // need to ignore checking the explicit_map for\n+                // Self type.\n+                let substs = ex_trait_ref\n+                    .with_self_ty(tcx, tcx.types.usize)\n+                    .skip_binder()\n+                    .substs;\n+                check_explicit_predicates(\n+                    tcx,\n+                    &ex_trait_ref.skip_binder().def_id,\n+                    substs,\n+                    required_predicates,\n+                    explicit_map,\n+                    IgnoreSelfTy(true),\n+                );\n             }\n \n             ty::Projection(obj) => {"}, {"sha": "3e523c0c7f559c1481e400ea98c9c2f4a72fa011", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -311,11 +311,11 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(current, r, contra);\n \n-                if let Some(p) = data.principal() {\n-                    let poly_trait_ref = p.with_self_ty(self.tcx(), self.tcx().types.err);\n-                    self.add_constraints_from_trait_ref(\n-                        current, *poly_trait_ref.skip_binder(), variance);\n-                }\n+                let poly_trait_ref = data\n+                    .principal()\n+                    .with_self_ty(self.tcx(), self.tcx().types.err);\n+                self.add_constraints_from_trait_ref(\n+                    current, *poly_trait_ref.skip_binder(), variance);\n \n                 for projection in data.projection_bounds() {\n                     self.add_constraints_from_ty("}, {"sha": "2ba1f103971f074548fae0f23f5c994178435f8f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -2632,47 +2632,44 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 }\n             }\n             ty::Dynamic(ref obj, ref reg) => {\n-                if let Some(principal) = obj.principal() {\n-                    let did = principal.def_id();\n+                let principal = obj.principal();\n+                let did = principal.def_id();\n+                inline::record_extern_fqn(cx, did, TypeKind::Trait);\n+\n+                let mut typarams = vec![];\n+                reg.clean(cx).map(|b| typarams.push(GenericBound::Outlives(b)));\n+                for did in obj.auto_traits() {\n+                    let empty = cx.tcx.intern_substs(&[]);\n+                    let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n+                        Some(did), false, vec![], empty);\n                     inline::record_extern_fqn(cx, did, TypeKind::Trait);\n+                    let bound = GenericBound::TraitBound(PolyTrait {\n+                        trait_: ResolvedPath {\n+                            path,\n+                            typarams: None,\n+                            did,\n+                            is_generic: false,\n+                        },\n+                        generic_params: Vec::new(),\n+                    }, hir::TraitBoundModifier::None);\n+                    typarams.push(bound);\n+                }\n \n-                    let mut typarams = vec![];\n-                    reg.clean(cx).map(|b| typarams.push(GenericBound::Outlives(b)));\n-                    for did in obj.auto_traits() {\n-                        let empty = cx.tcx.intern_substs(&[]);\n-                        let path = external_path(cx, &cx.tcx.item_name(did).as_str(),\n-                            Some(did), false, vec![], empty);\n-                        inline::record_extern_fqn(cx, did, TypeKind::Trait);\n-                        let bound = GenericBound::TraitBound(PolyTrait {\n-                            trait_: ResolvedPath {\n-                                path,\n-                                typarams: None,\n-                                did,\n-                                is_generic: false,\n-                            },\n-                            generic_params: Vec::new(),\n-                        }, hir::TraitBoundModifier::None);\n-                        typarams.push(bound);\n-                    }\n-\n-                    let mut bindings = vec![];\n-                    for pb in obj.projection_bounds() {\n-                        bindings.push(TypeBinding {\n-                            name: cx.tcx.associated_item(pb.item_def_id()).ident.name.clean(cx),\n-                            ty: pb.skip_binder().ty.clean(cx)\n-                        });\n-                    }\n+                let mut bindings = vec![];\n+                for pb in obj.projection_bounds() {\n+                    bindings.push(TypeBinding {\n+                        name: cx.tcx.associated_item(pb.item_def_id()).ident.name.clean(cx),\n+                        ty: pb.skip_binder().ty.clean(cx)\n+                    });\n+                }\n \n-                    let path = external_path(cx, &cx.tcx.item_name(did).as_str(), Some(did),\n-                        false, bindings, principal.skip_binder().substs);\n-                    ResolvedPath {\n-                        path,\n-                        typarams: Some(typarams),\n-                        did,\n-                        is_generic: false,\n-                    }\n-                } else {\n-                    Never\n+                let path = external_path(cx, &cx.tcx.item_name(did).as_str(), Some(did),\n+                    false, bindings, principal.skip_binder().substs);\n+                ResolvedPath {\n+                    path,\n+                    typarams: Some(typarams),\n+                    did,\n+                    is_generic: false,\n                 }\n             }\n             ty::Tuple(ref t) => Tuple(t.clean(cx)),"}, {"sha": "cd1e3438fc372f1d6726344e3510bbdb1ede821f", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -48,4 +48,13 @@ jemalloc = [\"alloc_jemalloc\"]\n force_alloc_system = []\n panic-unwind = [\"panic_unwind\"]\n profiler = [\"profiler_builtins\"]\n+\n+# An off-by-default feature which enables a linux-syscall-like ABI for libstd to\n+# interoperate with the host environment. Currently not well documented and\n+# requires rebuilding the standard library to use it.\n wasm_syscall = []\n+\n+# An off-by-default features to enable libstd to assume that wasm-bindgen is in\n+# the environment for hooking up some thread-related information like the\n+# current thread id and accessing/getting the current thread's TCB\n+wasm-bindgen-threads = []"}, {"sha": "762e807096fde5f2a310b06568f22e4361e8b6d0", "filename": "src/libstd/sys/wasm/mutex_atomics.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fmutex_atomics.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -11,7 +11,8 @@\n use arch::wasm32::atomic;\n use cell::UnsafeCell;\n use mem;\n-use sync::atomic::{AtomicUsize, AtomicU64, Ordering::SeqCst};\n+use sync::atomic::{AtomicUsize, AtomicU32, Ordering::SeqCst};\n+use sys::thread;\n \n pub struct Mutex {\n     locked: AtomicUsize,\n@@ -70,7 +71,7 @@ impl Mutex {\n }\n \n pub struct ReentrantMutex {\n-    owner: AtomicU64,\n+    owner: AtomicU32,\n     recursions: UnsafeCell<u32>,\n }\n \n@@ -91,7 +92,7 @@ unsafe impl Sync for ReentrantMutex {}\n impl ReentrantMutex {\n     pub unsafe fn uninitialized() -> ReentrantMutex {\n         ReentrantMutex {\n-            owner: AtomicU64::new(0),\n+            owner: AtomicU32::new(0),\n             recursions: UnsafeCell::new(0),\n         }\n     }\n@@ -101,20 +102,20 @@ impl ReentrantMutex {\n     }\n \n     pub unsafe fn lock(&self) {\n-        let me = thread_id();\n+        let me = thread::my_id();\n         while let Err(owner) = self._try_lock(me) {\n-            let val = atomic::wait_i64(self.ptr(), owner as i64, -1);\n+            let val = atomic::wait_i32(self.ptr(), owner as i32, -1);\n             debug_assert!(val == 0 || val == 1);\n         }\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        self._try_lock(thread_id()).is_ok()\n+        self._try_lock(thread::my_id()).is_ok()\n     }\n \n     #[inline]\n-    unsafe fn _try_lock(&self, id: u64) -> Result<(), u64> {\n+    unsafe fn _try_lock(&self, id: u32) -> Result<(), u32> {\n         let id = id.checked_add(1).unwrap(); // make sure `id` isn't 0\n         match self.owner.compare_exchange(0, id, SeqCst, SeqCst) {\n             // we transitioned from unlocked to locked\n@@ -153,11 +154,7 @@ impl ReentrantMutex {\n     }\n \n     #[inline]\n-    fn ptr(&self) -> *mut i64 {\n-        &self.owner as *const AtomicU64 as *mut i64\n+    fn ptr(&self) -> *mut i32 {\n+        &self.owner as *const AtomicU32 as *mut i32\n     }\n }\n-\n-fn thread_id() -> u64 {\n-    panic!(\"thread ids not implemented on wasm with atomics yet\")\n-}"}, {"sha": "4ad89c42b92dca0bfa921c1caabd5d2aeb3d5730", "filename": "src/libstd/sys/wasm/thread.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -69,3 +69,49 @@ pub mod guard {\n     pub unsafe fn init() -> Option<Guard> { None }\n     pub unsafe fn deinit() {}\n }\n+\n+cfg_if! {\n+    if #[cfg(all(target_feature = \"atomics\", feature = \"wasm-bindgen-threads\"))] {\n+        #[link(wasm_import_module = \"__wbindgen_thread_xform__\")]\n+        extern {\n+            fn __wbindgen_current_id() -> u32;\n+            fn __wbindgen_tcb_get() -> u32;\n+            fn __wbindgen_tcb_set(ptr: u32);\n+        }\n+        pub fn my_id() -> u32 {\n+            unsafe { __wbindgen_current_id() }\n+        }\n+\n+        // These are currently only ever used in `thread_local_atomics.rs`, if\n+        // you'd like to use them be sure to update that and make sure everyone\n+        // agrees what's what.\n+        pub fn tcb_get() -> *mut u8 {\n+            use mem;\n+            assert_eq!(mem::size_of::<*mut u8>(), mem::size_of::<u32>());\n+            unsafe { __wbindgen_tcb_get() as *mut u8 }\n+        }\n+\n+        pub fn tcb_set(ptr: *mut u8) {\n+            unsafe { __wbindgen_tcb_set(ptr as u32); }\n+        }\n+\n+        // FIXME: still need something for hooking exiting a thread to free\n+        // data...\n+\n+    } else if #[cfg(target_feature = \"atomics\")] {\n+        pub fn my_id() -> u32 {\n+            panic!(\"thread ids not implemented on wasm with atomics yet\")\n+        }\n+\n+        pub fn tcb_get() -> *mut u8 {\n+            panic!(\"thread local data not implemented on wasm with atomics yet\")\n+        }\n+\n+        pub fn tcb_set(ptr: *mut u8) {\n+            panic!(\"thread local data not implemented on wasm with atomics yet\")\n+        }\n+    } else {\n+        // stubbed out because no functions actually access these intrinsics\n+        // unless atomics are enabled\n+    }\n+}"}, {"sha": "acfe60719f2f75206067f02bccc4972b5e341e13", "filename": "src/libstd/sys/wasm/thread_local_atomics.rs", "status": "modified", "additions": 46, "deletions": 7, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwasm%2Fthread_local_atomics.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -8,22 +8,61 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use sys::thread;\n+use sync::atomic::{AtomicUsize, Ordering::SeqCst};\n+\n+const MAX_KEYS: usize = 128;\n+static NEXT_KEY: AtomicUsize = AtomicUsize::new(0);\n+\n+struct ThreadControlBlock {\n+    keys: [*mut u8; MAX_KEYS],\n+}\n+\n+impl ThreadControlBlock {\n+    fn new() -> ThreadControlBlock {\n+        ThreadControlBlock {\n+            keys: [0 as *mut u8; MAX_KEYS],\n+        }\n+    }\n+\n+    fn get() -> *mut ThreadControlBlock {\n+        let ptr = thread::tcb_get();\n+        if !ptr.is_null() {\n+            return ptr as *mut ThreadControlBlock\n+        }\n+        let tcb = Box::into_raw(Box::new(ThreadControlBlock::new()));\n+        thread::tcb_set(tcb as *mut u8);\n+        tcb\n+    }\n+}\n+\n pub type Key = usize;\n \n-pub unsafe fn create(_dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n-    panic!(\"TLS on wasm with atomics not implemented yet\");\n+pub unsafe fn create(dtor: Option<unsafe extern fn(*mut u8)>) -> Key {\n+    drop(dtor); // FIXME: need to figure out how to hook thread exit to run this\n+    let key = NEXT_KEY.fetch_add(1, SeqCst);\n+    if key >= MAX_KEYS {\n+        NEXT_KEY.store(MAX_KEYS, SeqCst);\n+        panic!(\"cannot allocate space for more TLS keys\");\n+    }\n+    // offset by 1 so we never hand out 0. This is currently required by\n+    // `sys_common/thread_local.rs` where it can't cope with keys of value 0\n+    // because it messes up the atomic management.\n+    return key + 1\n }\n \n-pub unsafe fn set(_key: Key, _value: *mut u8) {\n-    panic!(\"TLS on wasm with atomics not implemented yet\");\n+pub unsafe fn set(key: Key, value: *mut u8) {\n+    (*ThreadControlBlock::get()).keys[key - 1] = value;\n }\n \n-pub unsafe fn get(_key: Key) -> *mut u8 {\n-    panic!(\"TLS on wasm with atomics not implemented yet\");\n+pub unsafe fn get(key: Key) -> *mut u8 {\n+    (*ThreadControlBlock::get()).keys[key - 1]\n }\n \n pub unsafe fn destroy(_key: Key) {\n-    panic!(\"TLS on wasm with atomics not implemented yet\");\n+    // FIXME: should implement this somehow, this isn't typically called but it\n+    // can be called if two threads race to initialize a TLS slot and one ends\n+    // up not being needed.\n }\n \n #[inline]"}, {"sha": "59f100fad1bb9a1eda0aa41d72fa42c6b7c506d6", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -172,16 +172,22 @@ macro_rules! __thread_local_inner {\n                 &'static $crate::cell::UnsafeCell<\n                     $crate::option::Option<$t>>>\n             {\n-                #[cfg(target_arch = \"wasm32\")]\n+                #[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n                 static __KEY: $crate::thread::__StaticLocalKeyInner<$t> =\n                     $crate::thread::__StaticLocalKeyInner::new();\n \n                 #[thread_local]\n-                #[cfg(all(target_thread_local, not(target_arch = \"wasm32\")))]\n+                #[cfg(all(\n+                    target_thread_local,\n+                    not(all(target_arch = \"wasm32\", not(target_feature = \"atomics\"))),\n+                ))]\n                 static __KEY: $crate::thread::__FastLocalKeyInner<$t> =\n                     $crate::thread::__FastLocalKeyInner::new();\n \n-                #[cfg(all(not(target_thread_local), not(target_arch = \"wasm32\")))]\n+                #[cfg(all(\n+                    not(target_thread_local),\n+                    not(all(target_arch = \"wasm32\", not(target_feature = \"atomics\"))),\n+                ))]\n                 static __KEY: $crate::thread::__OsLocalKeyInner<$t> =\n                     $crate::thread::__OsLocalKeyInner::new();\n \n@@ -302,7 +308,7 @@ impl<T: 'static> LocalKey<T> {\n /// On some platforms like wasm32 there's no threads, so no need to generate\n /// thread locals and we can instead just use plain statics!\n #[doc(hidden)]\n-#[cfg(target_arch = \"wasm32\")]\n+#[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n pub mod statik {\n     use cell::UnsafeCell;\n     use fmt;"}, {"sha": "796b2bd3eed8709715ee96a99b319d4e56fa0d8a", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -203,7 +203,7 @@ pub use self::local::{LocalKey, AccessError};\n // where available, but both are needed.\n \n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n-#[cfg(target_arch = \"wasm32\")]\n+#[cfg(all(target_arch = \"wasm32\", not(target_feature = \"atomics\")))]\n #[doc(hidden)] pub use self::local::statik::Key as __StaticLocalKeyInner;\n #[unstable(feature = \"libstd_thread_internals\", issue = \"0\")]\n #[cfg(target_thread_local)]"}, {"sha": "84122688c83d26d1ff089d96d83646edc04f2447", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -499,6 +499,9 @@ declare_features! (\n \n     // #[cfg_attr(predicate, multiple, attributes, here)]\n     (active, cfg_attr_multi, \"1.31.0\", Some(54881), None),\n+\n+    // Allows `const _: TYPE = VALUE`\n+    (active, underscore_const_names, \"1.31.0\", Some(54912), None),\n );\n \n declare_features! (\n@@ -1583,6 +1586,13 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 }\n             }\n \n+            ast::ItemKind::Const(_,_) => {\n+                if i.ident.name == \"_\" {\n+                    gate_feature_post!(&self, underscore_const_names, i.span,\n+                                        \"naming constants with `_` is unstable\");\n+                }\n+            }\n+\n             ast::ItemKind::ForeignMod(ref foreign_module) => {\n                 self.check_abi(foreign_module.abi, i.span);\n             }"}, {"sha": "c7089a295fc3dca4787d0b8b40e0f4ca0fde56ff", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -6346,7 +6346,13 @@ impl<'a> Parser<'a> {\n     }\n \n     fn parse_item_const(&mut self, m: Option<Mutability>) -> PResult<'a, ItemInfo> {\n-        let id = self.parse_ident()?;\n+        let id = match self.token {\n+                token::Ident(ident, false) if ident.name == keywords::Underscore.name() => {\n+                    self.bump(); // `_`\n+                    ident.gensym()\n+                    },\n+                _ => self.parse_ident()?,\n+            };\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n         self.expect(&token::Eq)?;"}, {"sha": "6e931a84bacb9f6f7d5175f6eab3f49043eb55c2", "filename": "src/stage0.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Fstage0.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Fstage0.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstage0.txt?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -12,7 +12,7 @@\n # source tarball for a stable release you'll likely see `1.x.0` for rustc and\n # `0.x.0` for Cargo where they were released on `date`.\n \n-date: 2018-09-23\n+date: 2018-10-13\n rustc: beta\n cargo: beta\n "}, {"sha": "0f79f43ee2df07e8cc07457b4277270133d1e675", "filename": "src/test/mir-opt/inline-trait-method.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fmir-opt%2Finline-trait-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fmir-opt%2Finline-trait-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-trait-method.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -0,0 +1,31 @@\n+// compile-flags: -Z span_free_formats\n+\n+fn main() {\n+    println!(\"{}\", test(&()));\n+}\n+\n+fn test(x: &dyn X) -> u32 {\n+    x.y()\n+}\n+\n+trait X {\n+    fn y(&self) -> u32 {\n+        1\n+    }\n+}\n+\n+impl X for () {\n+    fn y(&self) -> u32 {\n+        2\n+    }\n+}\n+\n+// END RUST SOURCE\n+// START rustc.test.Inline.after.mir\n+// ...\n+// bb0: {\n+// ...\n+//     _0 = const X::y(move _2) -> bb1;\n+// }\n+// ...\n+// END rustc.test.Inline.after.mir"}, {"sha": "bf6e686bb7bb4a14d5cdda862648d4f12c571917", "filename": "src/test/run-pass/resolve-pseudo-shadowing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Frun-pass%2Fresolve-pseudo-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Frun-pass%2Fresolve-pseudo-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fresolve-pseudo-shadowing.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -12,7 +12,7 @@\n \n fn check<Clone>(_c: Clone) {\n     fn check2() {\n-        <() as std::clone::Clone>::clone(&());\n+        let _ = <() as std::clone::Clone>::clone(&());\n     }\n     check2();\n }"}, {"sha": "9995b00a9a76d9487b646254e9fd0098d591fa57", "filename": "src/test/ui/closure-expected-type/README.md", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa76d42b3e547bd3a0e049cc2c1e00f6b9560d6c/src%2Ftest%2Fui%2Fclosure-expected-type%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/fa76d42b3e547bd3a0e049cc2c1e00f6b9560d6c/src%2Ftest%2Fui%2Fclosure-expected-type%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2FREADME.md?ref=fa76d42b3e547bd3a0e049cc2c1e00f6b9560d6c", "patch": "@@ -1 +0,0 @@\n-See `src/test/run-pass/closure-expected-type`."}, {"sha": "b3c50a74a325e2f1d86e9c62c9707ed398b63d2a", "filename": "src/test/ui/closure-expected-type/issue-24421.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Fclosure-expected-type%2Fissue-24421.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Fclosure-expected-type%2Fissue-24421.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-expected-type%2Fissue-24421.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+fn test<F: Fn(&u64, &u64)>(f: F) {}\n+\n+fn main() {\n+    test(|x,      y     | {});\n+    test(|x:&u64, y:&u64| {});\n+    test(|x:&u64, y     | {});\n+    test(|x,      y:&u64| {});\n+}"}, {"sha": "b283e28651487c427bec09e160c8ab4806bcbd94", "filename": "src/test/ui/feature-gate-underscore_const_names.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Ffeature-gate-underscore_const_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Ffeature-gate-underscore_const_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-underscore_const_names.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2012-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(const_let)]\n+\n+trait Trt {}\n+struct Str {}\n+\n+impl Trt for Str {}\n+\n+const _ : () = {\n+    use std::marker::PhantomData;\n+    struct ImplementsTrait<T: Trt>(PhantomData<T>);\n+    let _ = ImplementsTrait::<Str>(PhantomData);\n+    ()\n+};\n+\n+fn main() {}"}, {"sha": "ab90ef8f11f7cf22bcc5ef847013210b9ff5bb59", "filename": "src/test/ui/feature-gate-underscore_const_names.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Ffeature-gate-underscore_const_names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Ffeature-gate-underscore_const_names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-underscore_const_names.stderr?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -0,0 +1,16 @@\n+error[E0658]: naming constants with `_` is unstable (see issue #54912)\n+  --> $DIR/feature-gate-underscore_const_names.rs:17:1\n+   |\n+LL | / const _ : () = {\n+LL | |     use std::marker::PhantomData;\n+LL | |     struct ImplementsTrait<T: Trt>(PhantomData<T>);\n+LL | |     let _ = ImplementsTrait::<Str>(PhantomData);\n+LL | |     ()\n+LL | | };\n+   | |__^\n+   |\n+   = help: add #![feature(underscore_const_names)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "e3e20bc89b462694f5017f192673898e72cf7ba4", "filename": "src/test/ui/fn_must_use.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Ffn_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Ffn_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn_must_use.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -22,6 +22,11 @@ impl MyStruct {\n     fn need_to_use_this_method_value(&self) -> usize {\n         self.n\n     }\n+\n+    #[must_use]\n+    fn need_to_use_this_associated_function_value() -> isize {\n+        -1\n+    }\n }\n \n trait EvenNature {\n@@ -66,6 +71,9 @@ fn main() {\n     m.is_even(); // trait method!\n     //~^ WARN unused return value\n \n+    MyStruct::need_to_use_this_associated_function_value();\n+    //~^ WARN unused return value\n+\n     m.replace(3); // won't warn (annotation needs to be in trait definition)\n \n     // comparison methods are `must_use`"}, {"sha": "1bce8abbbf055be9f372e6e21833892738580bc6", "filename": "src/test/ui/fn_must_use.stderr", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Ffn_must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Ffn_must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn_must_use.stderr?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -1,5 +1,5 @@\n warning: unused return value of `need_to_use_this_value` which must be used\n-  --> $DIR/fn_must_use.rs:60:5\n+  --> $DIR/fn_must_use.rs:65:5\n    |\n LL |     need_to_use_this_value(); //~ WARN unused return value\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -12,39 +12,45 @@ LL | #![warn(unused_must_use)]\n    = note: it's important\n \n warning: unused return value of `MyStruct::need_to_use_this_method_value` which must be used\n-  --> $DIR/fn_must_use.rs:65:5\n+  --> $DIR/fn_must_use.rs:70:5\n    |\n LL |     m.need_to_use_this_method_value(); //~ WARN unused return value\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n warning: unused return value of `EvenNature::is_even` which must be used\n-  --> $DIR/fn_must_use.rs:66:5\n+  --> $DIR/fn_must_use.rs:71:5\n    |\n LL |     m.is_even(); // trait method!\n    |     ^^^^^^^^^^^^\n    |\n    = note: no side effects\n \n+warning: unused return value of `MyStruct::need_to_use_this_associated_function_value` which must be used\n+  --> $DIR/fn_must_use.rs:74:5\n+   |\n+LL |     MyStruct::need_to_use_this_associated_function_value();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n warning: unused return value of `std::cmp::PartialEq::eq` which must be used\n-  --> $DIR/fn_must_use.rs:72:5\n+  --> $DIR/fn_must_use.rs:80:5\n    |\n LL |     2.eq(&3); //~ WARN unused return value\n    |     ^^^^^^^^^\n \n warning: unused return value of `std::cmp::PartialEq::eq` which must be used\n-  --> $DIR/fn_must_use.rs:73:5\n+  --> $DIR/fn_must_use.rs:81:5\n    |\n LL |     m.eq(&n); //~ WARN unused return value\n    |     ^^^^^^^^^\n \n warning: unused comparison which must be used\n-  --> $DIR/fn_must_use.rs:76:5\n+  --> $DIR/fn_must_use.rs:84:5\n    |\n LL |     2 == 3; //~ WARN unused comparison\n    |     ^^^^^^\n \n warning: unused comparison which must be used\n-  --> $DIR/fn_must_use.rs:77:5\n+  --> $DIR/fn_must_use.rs:85:5\n    |\n LL |     m == n; //~ WARN unused comparison\n    |     ^^^^^^"}, {"sha": "69b663b17d3407f30acd11011854ccbd044ce727", "filename": "src/test/ui/issues/issue-52240.nll.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Fissues%2Fissue-52240.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Fissues%2Fissue-52240.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52240.nll.stderr?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -0,0 +1,9 @@\n+error[E0596]: cannot borrow data in a `&` reference as mutable\n+  --> $DIR/issue-52240.rs:9:27\n+   |\n+LL |     if let (Some(Foo::Bar(ref mut val)), _) = (&arr.get(0), 0) {\n+   |                           ^^^^^^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "9ac7e9905da3ad34c8f00b671b62d1108d320162", "filename": "src/test/ui/issues/issue-52240.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Fissues%2Fissue-52240.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Fissues%2Fissue-52240.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52240.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -0,0 +1,16 @@\n+// issue-52240: Can turn immutable into mut with `ref mut`\n+\n+enum Foo {\n+    Bar(i32),\n+}\n+\n+fn main() {\n+    let arr = vec!(Foo::Bar(0));\n+    if let (Some(Foo::Bar(ref mut val)), _) = (&arr.get(0), 0) {\n+        //~^ ERROR cannot borrow field of immutable binding as mutable\n+        *val = 9001;\n+    }\n+    match arr[0] {\n+        Foo::Bar(ref s) => println!(\"{}\", s)\n+    }\n+}"}, {"sha": "c2c2524816dc18ad84de3d69b2d6203f09aae2bc", "filename": "src/test/ui/issues/issue-52240.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Fissues%2Fissue-52240.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Fissues%2Fissue-52240.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52240.stderr?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -0,0 +1,9 @@\n+error[E0596]: cannot borrow field of immutable binding as mutable\n+  --> $DIR/issue-52240.rs:9:27\n+   |\n+LL |     if let (Some(Foo::Bar(ref mut val)), _) = (&arr.get(0), 0) {\n+   |                           ^^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}, {"sha": "0ed3c4b3ca9453cb1e40d37c76a0b96682dcc5b1", "filename": "src/test/ui/issues/issue-54966.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Fissues%2Fissue-54966.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Fissues%2Fissue-54966.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54966.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -0,0 +1,6 @@\n+// issue-54966: ICE returning an unknown type with impl FnMut\n+\n+fn generate_duration() -> Oper<impl FnMut()> {}\n+//~^ ERROR cannot find type `Oper` in this scope\n+\n+fn main() {}"}, {"sha": "aa9a61cb592d1bf7434bdea41208c6434dfdf1df", "filename": "src/test/ui/issues/issue-54966.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Fissues%2Fissue-54966.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Fissues%2Fissue-54966.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-54966.stderr?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -0,0 +1,9 @@\n+error[E0412]: cannot find type `Oper` in this scope\n+  --> $DIR/issue-54966.rs:3:27\n+   |\n+LL | fn generate_duration() -> Oper<impl FnMut()> {}\n+   |                           ^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0412`."}, {"sha": "8d31fd0b1e93d6dd415804ba2dfa4309e99bef8d", "filename": "src/test/ui/underscore_const_names.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Funderscore_const_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5891a64165ea4819ca331f5a35f5318a91e1be3f/src%2Ftest%2Fui%2Funderscore_const_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore_const_names.rs?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2012-2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![feature(const_let)]\n+#![feature(underscore_const_names)]\n+\n+trait Trt {}\n+struct Str {}\n+impl Trt for Str {}\n+\n+macro_rules! check_impl {\n+    ($struct:ident,$trait:ident) => {\n+        const _ : () = {\n+            use std::marker::PhantomData;\n+            struct ImplementsTrait<T: $trait>(PhantomData<T>);\n+            let _ = ImplementsTrait::<$struct>(PhantomData);\n+            ()\n+        };\n+    }\n+}\n+\n+#[deny(unused)]\n+const _ : () = ();\n+\n+const _ : i32 = 42;\n+const _ : Str = Str{};\n+\n+check_impl!(Str, Trt);\n+check_impl!(Str, Trt);\n+\n+fn main() {\n+  check_impl!(Str, Trt);\n+  check_impl!(Str, Trt);\n+}"}, {"sha": "5dbac98885199bbd7c0f189d7405b5523434d1e3", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -1 +1 @@\n-Subproject commit ad6e5c0037d88602a1c95051e42b392ed5ffcbe8\n+Subproject commit 5dbac98885199bbd7c0f189d7405b5523434d1e3"}, {"sha": "9d3373137b74a403281b293b19ab9346773af073", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -1 +1 @@\n-Subproject commit 32b1d1fc157f71ed2f10b60fe28abe087a743618\n+Subproject commit 9d3373137b74a403281b293b19ab9346773af073"}, {"sha": "8b14b03368429e6ee2a8ac0e0c876505606ab1f1", "filename": "src/tools/miri", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -1 +1 @@\n-Subproject commit 26f9d617c347185433b77c481a5c50c55d9b72ce\n+Subproject commit 8b14b03368429e6ee2a8ac0e0c876505606ab1f1"}, {"sha": "440a9855b73b6bf9b5345cf3a79565566f6ef345", "filename": "src/tools/rls", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frls?ref=5891a64165ea4819ca331f5a35f5318a91e1be3f", "patch": "@@ -1 +1 @@\n-Subproject commit 15d4d4a5b0cf3c0155195f3322cc7a61148e5567\n+Subproject commit 440a9855b73b6bf9b5345cf3a79565566f6ef345"}]}