{"sha": "1413253a41de87ce7da73f0733aa3f433b1f5a3b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MTMyNTNhNDFkZTg3Y2U3ZGE3M2YwNzMzYWEzZjQzM2IxZjVhM2I=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-15T02:36:13Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-15T02:36:13Z"}, "message": "Merge remote-tracking branch 'origin/master' into gen", "tree": {"sha": "111cba46a53aaaa0733b6b8ba19aece25b6f8533", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/111cba46a53aaaa0733b6b8ba19aece25b6f8533"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1413253a41de87ce7da73f0733aa3f433b1f5a3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1413253a41de87ce7da73f0733aa3f433b1f5a3b", "html_url": "https://github.com/rust-lang/rust/commit/1413253a41de87ce7da73f0733aa3f433b1f5a3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1413253a41de87ce7da73f0733aa3f433b1f5a3b/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b045c201b2086073f43d76290b9cb2a5a8e16f89", "url": "https://api.github.com/repos/rust-lang/rust/commits/b045c201b2086073f43d76290b9cb2a5a8e16f89", "html_url": "https://github.com/rust-lang/rust/commit/b045c201b2086073f43d76290b9cb2a5a8e16f89"}, {"sha": "56fe3b2ad0055bb28325f412395577e2b842719a", "url": "https://api.github.com/repos/rust-lang/rust/commits/56fe3b2ad0055bb28325f412395577e2b842719a", "html_url": "https://github.com/rust-lang/rust/commit/56fe3b2ad0055bb28325f412395577e2b842719a"}], "stats": {"total": 7055, "additions": 5059, "deletions": 1996}, "files": [{"sha": "9c54dfd33883d161d9260e1fd260816408510da1", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -99,7 +99,7 @@ Before you can start building the compiler you need to configure the build for\n your system. In most cases, that will just mean using the defaults provided\n for Rust.\n \n-To change configuration, you must copy the file `src/bootstrap/config.toml.example`\n+To change configuration, you must copy the file `config.toml.example`\n to `config.toml` in the directory from which you will be running the build, and\n change the settings provided.\n \n@@ -237,10 +237,13 @@ Some common invocations of `x.py` are:\n ## Pull Requests\n \n Pull requests are the primary mechanism we use to change Rust. GitHub itself\n-has some [great documentation][pull-requests] on using the Pull Request\n-feature. We use the 'fork and pull' model described there.\n+has some [great documentation][pull-requests] on using the Pull Request feature.\n+We use the \"fork and pull\" model [described here][development-models], where\n+contributors push changes to their personal fork and create pull requests to\n+bring those changes into the source repository.\n \n-[pull-requests]: https://help.github.com/articles/using-pull-requests/\n+[pull-requests]: https://help.github.com/articles/about-pull-requests/\n+[development-models]: https://help.github.com/articles/about-collaborative-development-models/\n \n Please make pull requests against the `master` branch.\n "}, {"sha": "b6ff6df0aec94283a4f2a0bc7eb1b2f1448ed6fb", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -39,7 +39,7 @@ Read [\"Installation\"] from [The Book].\n     ```\n \n     > ***Note:*** Install locations can be adjusted by copying the config file\n-    > from `./src/bootstrap/config.toml.example` to `./config.toml`, and\n+    > from `./config.toml.example` to `./config.toml`, and\n     > adjusting the `prefix` option under `[install]`. Various other options, such\n     > as enabling debug information, are also supported, and are documented in\n     > the config file."}, {"sha": "962be2e608501659cfafe2e0a7d559e1a0c1263a", "filename": "config.toml.example", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -258,6 +258,9 @@\n # saying that the FileCheck executable is missing, you may want to disable this.\n #codegen-tests = true\n \n+# Flag indicating whether git info will be retrieved from .git automatically.\n+#ignore-git = false\n+\n # =============================================================================\n # Options for specific targets\n #", "previous_filename": "src/bootstrap/config.toml.example"}, {"sha": "65c1088f5473fcf6aedcb0e43df9be81e6a6626c", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -80,7 +80,7 @@ handled naturally.\n \n Next, rustbuild offers a TOML-based configuration system with a `config.toml`\n file in the same location as `config.mk`. An example of this configuration can\n-be found at `src/bootstrap/config.toml.example`, and the configuration file\n+be found at `config.toml.example`, and the configuration file\n can also be passed as `--config path/to/config.toml` if the build system is\n being invoked manually (via the python script).\n "}, {"sha": "d02bc7972ae9a0980c7a7768446b206bc0f7b010", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -21,11 +21,10 @@ extern crate bootstrap;\n \n use std::env;\n \n-use bootstrap::{Flags, Config, Build};\n+use bootstrap::{Config, Build};\n \n fn main() {\n     let args = env::args().skip(1).collect::<Vec<_>>();\n-    let flags = Flags::parse(&args);\n-    let config = Config::parse(&flags.build, flags.config.clone());\n-    Build::new(flags, config).build();\n+    let config = Config::parse(&args);\n+    Build::new(config).build();\n }"}, {"sha": "5f1830081adbf115a45a380106eea480672fd6e8", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -120,28 +120,19 @@ impl StepDescription {\n     fn maybe_run(&self, builder: &Builder, path: Option<&Path>) {\n         let build = builder.build;\n         let hosts = if self.only_build_targets || self.only_build {\n-            &build.config.host[..1]\n+            build.build_triple()\n         } else {\n             &build.hosts\n         };\n \n-        // Determine the actual targets participating in this rule.\n-        // NOTE: We should keep the full projection from build triple to\n-        // the hosts for the dist steps, now that the hosts array above is\n-        // truncated to avoid duplication of work in that case. Therefore\n-        // the original non-shadowed hosts array is used below.\n+        // Determine the targets participating in this rule.\n         let targets = if self.only_hosts {\n-            // If --target was specified but --host wasn't specified,\n-            // don't run any host-only tests. Also, respect any `--host`\n-            // overrides as done for `hosts`.\n-            if build.flags.host.len() > 0 {\n-                &build.flags.host[..]\n-            } else if build.flags.target.len() > 0 {\n+            if build.config.run_host_only {\n                 &[]\n             } else if self.only_build {\n-                &build.config.host[..1]\n+                build.build_triple()\n             } else {\n-                &build.config.host[..]\n+                &build.hosts\n             }\n         } else {\n             &build.targets\n@@ -288,7 +279,7 @@ impl<'a> Builder<'a> {\n \n         let builder = Builder {\n             build: build,\n-            top_stage: build.flags.stage.unwrap_or(2),\n+            top_stage: build.config.stage.unwrap_or(2),\n             kind: kind,\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n@@ -307,7 +298,7 @@ impl<'a> Builder<'a> {\n     }\n \n     pub fn run(build: &Build) {\n-        let (kind, paths) = match build.flags.cmd {\n+        let (kind, paths) = match build.config.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n             Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n             Subcommand::Test { ref paths, .. } => (Kind::Test, &paths[..]),\n@@ -319,7 +310,7 @@ impl<'a> Builder<'a> {\n \n         let builder = Builder {\n             build: build,\n-            top_stage: build.flags.stage.unwrap_or(2),\n+            top_stage: build.config.stage.unwrap_or(2),\n             kind: kind,\n             cache: Cache::new(),\n             stack: RefCell::new(Vec::new()),\n@@ -333,7 +324,7 @@ impl<'a> Builder<'a> {\n         StepDescription::run(&Builder::get_step_descriptions(Kind::Doc), self, paths);\n     }\n \n-    /// Obtain a compiler at a given stage and for a given host. Explictly does\n+    /// Obtain a compiler at a given stage and for a given host. Explicitly does\n     /// not take `Compiler` since all `Compiler` instances are meant to be\n     /// obtained through this function, since it ensures that they are valid\n     /// (i.e., built and assembled).\n@@ -414,22 +405,19 @@ impl<'a> Builder<'a> {\n         }\n     }\n \n-    pub fn rustdoc(&self, compiler: Compiler) -> PathBuf {\n-        self.ensure(tool::Rustdoc { target_compiler: compiler })\n+    pub fn rustdoc(&self, host: Interned<String>) -> PathBuf {\n+        self.ensure(tool::Rustdoc { host })\n     }\n \n-    pub fn rustdoc_cmd(&self, compiler: Compiler) -> Command {\n+    pub fn rustdoc_cmd(&self, host: Interned<String>) -> Command {\n         let mut cmd = Command::new(&self.out.join(\"bootstrap/debug/rustdoc\"));\n+        let compiler = self.compiler(self.top_stage, host);\n         cmd\n             .env(\"RUSTC_STAGE\", compiler.stage.to_string())\n-            .env(\"RUSTC_SYSROOT\", if compiler.is_snapshot(&self.build) {\n-                INTERNER.intern_path(self.build.rustc_snapshot_libdir())\n-            } else {\n-                self.sysroot(compiler)\n-            })\n-            .env(\"RUSTC_LIBDIR\", self.rustc_libdir(compiler))\n+            .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n+            .env(\"RUSTC_LIBDIR\", self.sysroot_libdir(compiler, self.build.build))\n             .env(\"CFG_RELEASE_CHANNEL\", &self.build.config.channel)\n-            .env(\"RUSTDOC_REAL\", self.rustdoc(compiler));\n+            .env(\"RUSTDOC_REAL\", self.rustdoc(host));\n         cmd\n     }\n \n@@ -483,7 +471,7 @@ impl<'a> Builder<'a> {\n              .env(\"RUSTC_RPATH\", self.config.rust_rpath.to_string())\n              .env(\"RUSTDOC\", self.out.join(\"bootstrap/debug/rustdoc\"))\n              .env(\"RUSTDOC_REAL\", if cmd == \"doc\" || cmd == \"test\" {\n-                 self.rustdoc(compiler)\n+                 self.rustdoc(compiler.host)\n              } else {\n                  PathBuf::from(\"/path/to/nowhere/rustdoc/not/required\")\n              })\n@@ -501,7 +489,7 @@ impl<'a> Builder<'a> {\n             // crates). Let's say, for example that rustc itself depends on the\n             // bitflags crate. If an external crate then depends on the\n             // bitflags crate as well, we need to make sure they don't\n-            // conflict, even if they pick the same verison of bitflags. We'll\n+            // conflict, even if they pick the same version of bitflags. We'll\n             // want to make sure that e.g. a plugin and rustc each get their\n             // own copy of bitflags.\n \n@@ -543,12 +531,12 @@ impl<'a> Builder<'a> {\n         // Ignore incremental modes except for stage0, since we're\n         // not guaranteeing correctness across builds if the compiler\n         // is changing under your feet.`\n-        if self.flags.incremental && compiler.stage == 0 {\n+        if self.config.incremental && compiler.stage == 0 {\n             let incr_dir = self.incremental_dir(compiler);\n             cargo.env(\"RUSTC_INCREMENTAL\", incr_dir);\n         }\n \n-        if let Some(ref on_fail) = self.flags.on_fail {\n+        if let Some(ref on_fail) = self.config.on_fail {\n             cargo.env(\"RUSTC_ON_FAIL\", on_fail);\n         }\n "}, {"sha": "0f25da8a238d012d2d39af45f1bd695a3e796fc2", "filename": "src/bootstrap/cc.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -32,6 +32,7 @@\n //! everything.\n \n use std::process::Command;\n+use std::iter;\n \n use build_helper::{cc2ar, output};\n use gcc;\n@@ -43,47 +44,41 @@ use cache::Interned;\n pub fn find(build: &mut Build) {\n     // For all targets we're going to need a C compiler for building some shims\n     // and such as well as for being a linker for Rust code.\n-    //\n-    // This includes targets that aren't necessarily passed on the commandline\n-    // (FIXME: Perhaps it shouldn't?)\n-    for target in &build.config.target {\n+    for target in build.targets.iter().chain(&build.hosts).cloned().chain(iter::once(build.build)) {\n         let mut cfg = gcc::Config::new();\n         cfg.cargo_metadata(false).opt_level(0).debug(false)\n-           .target(target).host(&build.build);\n+           .target(&target).host(&build.build);\n \n         let config = build.config.target_config.get(&target);\n         if let Some(cc) = config.and_then(|c| c.cc.as_ref()) {\n             cfg.compiler(cc);\n         } else {\n-            set_compiler(&mut cfg, \"gcc\", *target, config, build);\n+            set_compiler(&mut cfg, \"gcc\", target, config, build);\n         }\n \n         let compiler = cfg.get_compiler();\n-        let ar = cc2ar(compiler.path(), target);\n-        build.verbose(&format!(\"CC_{} = {:?}\", target, compiler.path()));\n+        let ar = cc2ar(compiler.path(), &target);\n+        build.verbose(&format!(\"CC_{} = {:?}\", &target, compiler.path()));\n         if let Some(ref ar) = ar {\n-            build.verbose(&format!(\"AR_{} = {:?}\", target, ar));\n+            build.verbose(&format!(\"AR_{} = {:?}\", &target, ar));\n         }\n-        build.cc.insert(*target, (compiler, ar));\n+        build.cc.insert(target, (compiler, ar));\n     }\n \n     // For all host triples we need to find a C++ compiler as well\n-    //\n-    // This includes hosts that aren't necessarily passed on the commandline\n-    // (FIXME: Perhaps it shouldn't?)\n-    for host in &build.config.host {\n+    for host in build.hosts.iter().cloned().chain(iter::once(build.build)) {\n         let mut cfg = gcc::Config::new();\n         cfg.cargo_metadata(false).opt_level(0).debug(false).cpp(true)\n-           .target(host).host(&build.build);\n-        let config = build.config.target_config.get(host);\n+           .target(&host).host(&build.build);\n+        let config = build.config.target_config.get(&host);\n         if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n             cfg.compiler(cxx);\n         } else {\n-            set_compiler(&mut cfg, \"g++\", *host, config, build);\n+            set_compiler(&mut cfg, \"g++\", host, config, build);\n         }\n         let compiler = cfg.get_compiler();\n         build.verbose(&format!(\"CXX_{} = {:?}\", host, compiler.path()));\n-        build.cxx.insert(*host, compiler);\n+        build.cxx.insert(host, compiler);\n     }\n }\n "}, {"sha": "9c1ae83d3828189362fe6af0a9e8858f5bcdd37a", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -21,6 +21,7 @@ use std::process::Command;\n use build_helper::output;\n \n use Build;\n+use config::Config;\n \n // The version number\n pub const CFG_RELEASE_NUM: &str = \"1.21.0\";\n@@ -41,9 +42,9 @@ struct Info {\n }\n \n impl GitInfo {\n-    pub fn new(dir: &Path) -> GitInfo {\n+    pub fn new(config: &Config, dir: &Path) -> GitInfo {\n         // See if this even begins to look like a git dir\n-        if !dir.join(\".git\").exists() {\n+        if config.ignore_git || !dir.join(\".git\").exists() {\n             return GitInfo { inner: None }\n         }\n "}, {"sha": "1823dd4ebc0434bc16607c2361e07e49fe593249", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -164,7 +164,7 @@ impl Step for Cargotest {\n         try_run(build, cmd.arg(&build.initial_cargo)\n                           .arg(&out_dir)\n                           .env(\"RUSTC\", builder.rustc(compiler))\n-                          .env(\"RUSTDOC\", builder.rustdoc(compiler)));\n+                          .env(\"RUSTDOC\", builder.rustdoc(compiler.host)));\n     }\n }\n \n@@ -565,7 +565,7 @@ impl Step for Compiletest {\n \n         // Avoid depending on rustdoc when we don't need it.\n         if mode == \"rustdoc\" || mode == \"run-make\" {\n-            cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler));\n+            cmd.arg(\"--rustdoc-path\").arg(builder.rustdoc(compiler.host));\n         }\n \n         cmd.arg(\"--src-base\").arg(build.src.join(\"src/test\").join(suite));\n@@ -618,14 +618,8 @@ impl Step for Compiletest {\n         if let Some(ref dir) = build.lldb_python_dir {\n             cmd.arg(\"--lldb-python-dir\").arg(dir);\n         }\n-        let llvm_config = build.llvm_config(target);\n-        let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n-        cmd.arg(\"--llvm-version\").arg(llvm_version);\n-        if !build.is_rust_llvm(target) {\n-            cmd.arg(\"--system-llvm\");\n-        }\n \n-        cmd.args(&build.flags.cmd.test_args());\n+        cmd.args(&build.config.cmd.test_args());\n \n         if build.is_verbose() {\n             cmd.arg(\"--verbose\");\n@@ -635,17 +629,32 @@ impl Step for Compiletest {\n             cmd.arg(\"--quiet\");\n         }\n \n-        // Only pass correct values for these flags for the `run-make` suite as it\n-        // requires that a C++ compiler was configured which isn't always the case.\n-        if suite == \"run-make\" {\n-            let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n-            let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n-            cmd.arg(\"--cc\").arg(build.cc(target))\n-               .arg(\"--cxx\").arg(build.cxx(target).unwrap())\n-               .arg(\"--cflags\").arg(build.cflags(target).join(\" \"))\n-               .arg(\"--llvm-components\").arg(llvm_components.trim())\n-               .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n-        } else {\n+        if build.config.llvm_enabled {\n+            let llvm_config = build.llvm_config(target);\n+            let llvm_version = output(Command::new(&llvm_config).arg(\"--version\"));\n+            cmd.arg(\"--llvm-version\").arg(llvm_version);\n+            if !build.is_rust_llvm(target) {\n+                cmd.arg(\"--system-llvm\");\n+            }\n+\n+            // Only pass correct values for these flags for the `run-make` suite as it\n+            // requires that a C++ compiler was configured which isn't always the case.\n+            if suite == \"run-make\" {\n+                let llvm_components = output(Command::new(&llvm_config).arg(\"--components\"));\n+                let llvm_cxxflags = output(Command::new(&llvm_config).arg(\"--cxxflags\"));\n+                cmd.arg(\"--cc\").arg(build.cc(target))\n+                .arg(\"--cxx\").arg(build.cxx(target).unwrap())\n+                .arg(\"--cflags\").arg(build.cflags(target).join(\" \"))\n+                .arg(\"--llvm-components\").arg(llvm_components.trim())\n+                .arg(\"--llvm-cxxflags\").arg(llvm_cxxflags.trim());\n+            }\n+        }\n+        if suite == \"run-make\" && !build.config.llvm_enabled {\n+            println!(\"Ignoring run-make test suite as they generally dont work without LLVM\");\n+            return;\n+        }\n+\n+        if suite != \"run-make\" {\n             cmd.arg(\"--cc\").arg(\"\")\n                .arg(\"--cxx\").arg(\"\")\n                .arg(\"--cflags\").arg(\"\")\n@@ -814,13 +823,13 @@ fn markdown_test(builder: &Builder, compiler: Compiler, markdown: &Path) {\n     }\n \n     println!(\"doc tests for: {}\", markdown.display());\n-    let mut cmd = builder.rustdoc_cmd(compiler);\n+    let mut cmd = builder.rustdoc_cmd(compiler.host);\n     build.add_rust_test_threads(&mut cmd);\n     cmd.arg(\"--test\");\n     cmd.arg(markdown);\n     cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n \n-    let test_args = build.flags.cmd.test_args().join(\" \");\n+    let test_args = build.config.cmd.test_args().join(\" \");\n     cmd.arg(\"--test-args\").arg(test_args);\n \n     if build.config.quiet_tests {\n@@ -1051,7 +1060,7 @@ impl Step for Crate {\n         cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n         cargo.arg(\"--\");\n-        cargo.args(&build.flags.cmd.test_args());\n+        cargo.args(&build.config.cmd.test_args());\n \n         if build.config.quiet_tests {\n             cargo.arg(\"--quiet\");\n@@ -1147,6 +1156,7 @@ pub struct Distcheck;\n \n impl Step for Distcheck {\n     type Output = ();\n+    const ONLY_BUILD: bool = true;\n \n     fn should_run(run: ShouldRun) -> ShouldRun {\n         run.path(\"distcheck\")\n@@ -1160,16 +1170,6 @@ impl Step for Distcheck {\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n \n-        if *build.build != *\"x86_64-unknown-linux-gnu\" {\n-            return\n-        }\n-        if !build.config.host.iter().any(|s| s == \"x86_64-unknown-linux-gnu\") {\n-            return\n-        }\n-        if !build.config.target.iter().any(|s| s == \"x86_64-unknown-linux-gnu\") {\n-            return\n-        }\n-\n         println!(\"Distcheck\");\n         let dir = build.out.join(\"tmp\").join(\"distcheck\");\n         let _ = fs::remove_dir_all(&dir);\n@@ -1236,7 +1236,7 @@ impl Step for Bootstrap {\n         if !build.fail_fast {\n             cmd.arg(\"--no-fail-fast\");\n         }\n-        cmd.arg(\"--\").args(&build.flags.cmd.test_args());\n+        cmd.arg(\"--\").args(&build.config.cmd.test_args());\n         try_run(build, &mut cmd);\n     }\n "}, {"sha": "119340a0190c4c11271d61e847ffaa600e61c03a", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -26,7 +26,7 @@ pub fn clean(build: &Build) {\n     rm_rf(&build.out.join(\"tmp\"));\n     rm_rf(&build.out.join(\"dist\"));\n \n-    for host in build.config.host.iter() {\n+    for host in &build.hosts {\n         let entries = match build.out.join(host).read_dir() {\n             Ok(iter) => iter,\n             Err(_) => continue,"}, {"sha": "33c3638a894730a85a0dc6bb2846ae05011f734f", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -32,6 +32,7 @@ use serde_json;\n use util::{exe, libdir, is_dylib, copy};\n use {Build, Compiler, Mode};\n use native;\n+use tool;\n \n use cache::{INTERNER, Interned};\n use builder::{Step, RunConfig, ShouldRun, Builder};\n@@ -198,6 +199,12 @@ impl Step for StdLink {\n             // for reason why the sanitizers are not built in stage0.\n             copy_apple_sanitizer_dylibs(&build.native_dir(target), \"osx\", &libdir);\n         }\n+\n+        builder.ensure(tool::CleanTools {\n+            compiler: target_compiler,\n+            target: target,\n+            mode: Mode::Libstd,\n+        });\n     }\n }\n \n@@ -389,6 +396,11 @@ impl Step for TestLink {\n                 target);\n         add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n                     &libtest_stamp(build, compiler, target));\n+        builder.ensure(tool::CleanTools {\n+            compiler: target_compiler,\n+            target: target,\n+            mode: Mode::Libtest,\n+        });\n     }\n }\n \n@@ -567,6 +579,11 @@ impl Step for RustcLink {\n                  target);\n         add_to_sysroot(&builder.sysroot_libdir(target_compiler, target),\n                        &librustc_stamp(build, compiler, target));\n+        builder.ensure(tool::CleanTools {\n+            compiler: target_compiler,\n+            target: target,\n+            mode: Mode::Librustc,\n+        });\n     }\n }\n \n@@ -679,10 +696,10 @@ impl Step for Assemble {\n         // link to these. (FIXME: Is that correct? It seems to be correct most\n         // of the time but I think we do link to these for stage2/bin compilers\n         // when not performing a full bootstrap).\n-        if builder.build.flags.keep_stage.map_or(false, |s| target_compiler.stage <= s) {\n+        if builder.build.config.keep_stage.map_or(false, |s| target_compiler.stage <= s) {\n             builder.verbose(\"skipping compilation of compiler due to --keep-stage\");\n             let compiler = build_compiler;\n-            for stage in 0..min(target_compiler.stage, builder.flags.keep_stage.unwrap()) {\n+            for stage in 0..min(target_compiler.stage, builder.config.keep_stage.unwrap()) {\n                 let target_compiler = builder.compiler(stage, target_compiler.host);\n                 let target = target_compiler.host;\n                 builder.ensure(StdLink { compiler, target_compiler, target });"}, {"sha": "aa688fc66e267831e71a7a3824720cdc8aa6ea8f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 60, "deletions": 13, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -19,11 +19,14 @@ use std::fs::{self, File};\n use std::io::prelude::*;\n use std::path::PathBuf;\n use std::process;\n+use std::cmp;\n \n use num_cpus;\n use toml;\n use util::{exe, push_exe_path};\n use cache::{INTERNER, Interned};\n+use flags::Flags;\n+pub use flags::Subcommand;\n \n /// Global configuration for the entire build and/or bootstrap.\n ///\n@@ -35,7 +38,7 @@ use cache::{INTERNER, Interned};\n /// Note that this structure is not decoded directly into, but rather it is\n /// filled out from the decoded forms of the structs below. For documentation\n /// each field, see the corresponding fields in\n-/// `src/bootstrap/config.toml.example`.\n+/// `config.toml.example`.\n #[derive(Default)]\n pub struct Config {\n     pub ccache: Option<String>,\n@@ -51,6 +54,17 @@ pub struct Config {\n     pub extended: bool,\n     pub sanitizers: bool,\n     pub profiler: bool,\n+    pub ignore_git: bool,\n+\n+    pub run_host_only: bool,\n+\n+    pub on_fail: Option<String>,\n+    pub stage: Option<u32>,\n+    pub keep_stage: Option<u32>,\n+    pub src: PathBuf,\n+    pub jobs: Option<u32>,\n+    pub cmd: Subcommand,\n+    pub incremental: bool,\n \n     // llvm codegen options\n     pub llvm_enabled: bool,\n@@ -79,8 +93,8 @@ pub struct Config {\n     pub rust_dist_src: bool,\n \n     pub build: Interned<String>,\n-    pub host: Vec<Interned<String>>,\n-    pub target: Vec<Interned<String>>,\n+    pub hosts: Vec<Interned<String>>,\n+    pub targets: Vec<Interned<String>>,\n     pub local_rebuild: bool,\n \n     // dist misc\n@@ -249,6 +263,7 @@ struct Rust {\n     optimize_tests: Option<bool>,\n     debuginfo_tests: Option<bool>,\n     codegen_tests: Option<bool>,\n+    ignore_git: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -265,7 +280,9 @@ struct TomlTarget {\n }\n \n impl Config {\n-    pub fn parse(build: &str, file: Option<PathBuf>) -> Config {\n+    pub fn parse(args: &[String]) -> Config {\n+        let flags = Flags::parse(&args);\n+        let file = flags.config.clone();\n         let mut config = Config::default();\n         config.llvm_enabled = true;\n         config.llvm_optimize = true;\n@@ -277,11 +294,22 @@ impl Config {\n         config.docs = true;\n         config.rust_rpath = true;\n         config.rust_codegen_units = 1;\n-        config.build = INTERNER.intern_str(build);\n         config.channel = \"dev\".to_string();\n         config.codegen_tests = true;\n+        config.ignore_git = false;\n         config.rust_dist_src = true;\n \n+        config.on_fail = flags.on_fail;\n+        config.stage = flags.stage;\n+        config.src = flags.src;\n+        config.jobs = flags.jobs;\n+        config.cmd = flags.cmd;\n+        config.incremental = flags.incremental;\n+        config.keep_stage = flags.keep_stage;\n+\n+        // If --target was specified but --host wasn't specified, don't run any host-only tests.\n+        config.run_host_only = flags.host.is_empty() && !flags.target.is_empty();\n+\n         let toml = file.map(|file| {\n             let mut f = t!(File::open(&file));\n             let mut contents = String::new();\n@@ -298,20 +326,37 @@ impl Config {\n \n         let build = toml.build.clone().unwrap_or(Build::default());\n         set(&mut config.build, build.build.clone().map(|x| INTERNER.intern_string(x)));\n-        config.host.push(config.build.clone());\n+        set(&mut config.build, flags.build);\n+        if config.build.is_empty() {\n+            // set by bootstrap.py\n+            config.build = INTERNER.intern_str(&env::var(\"BUILD\").unwrap());\n+        }\n+        config.hosts.push(config.build.clone());\n         for host in build.host.iter() {\n             let host = INTERNER.intern_str(host);\n-            if !config.host.contains(&host) {\n-                config.host.push(host);\n+            if !config.hosts.contains(&host) {\n+                config.hosts.push(host);\n             }\n         }\n-        for target in config.host.iter().cloned()\n+        for target in config.hosts.iter().cloned()\n             .chain(build.target.iter().map(|s| INTERNER.intern_str(s)))\n         {\n-            if !config.target.contains(&target) {\n-                config.target.push(target);\n+            if !config.targets.contains(&target) {\n+                config.targets.push(target);\n             }\n         }\n+        config.hosts = if !flags.host.is_empty() {\n+            flags.host\n+        } else {\n+            config.hosts\n+        };\n+        config.targets = if !flags.target.is_empty() {\n+            flags.target\n+        } else {\n+            config.targets\n+        };\n+\n+\n         config.nodejs = build.nodejs.map(PathBuf::from);\n         config.gdb = build.gdb.map(PathBuf::from);\n         config.python = build.python.map(PathBuf::from);\n@@ -327,6 +372,7 @@ impl Config {\n         set(&mut config.sanitizers, build.sanitizers);\n         set(&mut config.profiler, build.profiler);\n         set(&mut config.openssl_static, build.openssl_static);\n+        config.verbose = cmp::max(config.verbose, flags.verbose);\n \n         if let Some(ref install) = toml.install {\n             config.prefix = install.prefix.clone().map(PathBuf::from);\n@@ -373,6 +419,7 @@ impl Config {\n             set(&mut config.use_jemalloc, rust.use_jemalloc);\n             set(&mut config.backtrace, rust.backtrace);\n             set(&mut config.channel, rust.channel.clone());\n+            set(&mut config.ignore_git, rust.ignore_git);\n             config.rustc_default_linker = rust.default_linker.clone();\n             config.rustc_default_ar = rust.default_ar.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n@@ -505,11 +552,11 @@ impl Config {\n             match key {\n                 \"CFG_BUILD\" if value.len() > 0 => self.build = INTERNER.intern_str(value),\n                 \"CFG_HOST\" if value.len() > 0 => {\n-                    self.host.extend(value.split(\" \").map(|s| INTERNER.intern_str(s)));\n+                    self.hosts.extend(value.split(\" \").map(|s| INTERNER.intern_str(s)));\n \n                 }\n                 \"CFG_TARGET\" if value.len() > 0 => {\n-                    self.target.extend(value.split(\" \").map(|s| INTERNER.intern_str(s)));\n+                    self.targets.extend(value.split(\" \").map(|s| INTERNER.intern_str(s)));\n                 }\n                 \"CFG_EXPERIMENTAL_TARGETS\" if value.len() > 0 => {\n                     self.llvm_experimental_targets = Some(value.to_string());"}, {"sha": "bfcfb5f9a37f8d994017461956d437aa83f1ef7b", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -413,8 +413,7 @@ impl Step for Rustc {\n             t!(fs::create_dir_all(image.join(\"bin\")));\n             cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n \n-            install(&builder.ensure(tool::Rustdoc { target_compiler: compiler }),\n-                &image.join(\"bin\"), 0o755);\n+            install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n \n             // Copy runtime DLLs needed by the compiler\n             if libdir != \"bin\" {\n@@ -546,7 +545,7 @@ impl Step for Std {\n         // We want to package up as many target libraries as possible\n         // for the `rust-std` package, so if this is a host target we\n         // depend on librustc and otherwise we just depend on libtest.\n-        if build.config.host.iter().any(|t| t == target) {\n+        if build.hosts.iter().any(|t| t == target) {\n             builder.ensure(compile::Rustc { compiler, target });\n         } else {\n             builder.ensure(compile::Test { compiler, target });"}, {"sha": "81a3845ecf76a4ca7d4781349ac6cd84216cbbff", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -260,7 +260,7 @@ fn invoke_rustdoc(builder: &Builder, compiler: Compiler, target: Interned<String\n         t!(t!(File::create(&version_info)).write_all(info.as_bytes()));\n     }\n \n-    let mut cmd = builder.rustdoc_cmd(compiler);\n+    let mut cmd = builder.rustdoc_cmd(compiler.host);\n \n     let out = out.join(\"book\");\n \n@@ -306,7 +306,7 @@ impl Step for Standalone {\n     ///\n     /// This will list all of `src/doc` looking for markdown files and appropriately\n     /// perform transformations like substituting `VERSION`, `SHORT_HASH`, and\n-    /// `STAMP` alongw ith providing the various header/footer HTML we've cutomized.\n+    /// `STAMP` along with providing the various header/footer HTML we've customized.\n     ///\n     /// In the end, this is just a glorified wrapper around rustdoc!\n     fn run(self, builder: &Builder) {\n@@ -343,7 +343,7 @@ impl Step for Standalone {\n             }\n \n             let html = out.join(filename).with_extension(\"html\");\n-            let rustdoc = builder.rustdoc(compiler);\n+            let rustdoc = builder.rustdoc(compiler.host);\n             if up_to_date(&path, &html) &&\n                up_to_date(&footer, &html) &&\n                up_to_date(&favicon, &html) &&\n@@ -353,7 +353,7 @@ impl Step for Standalone {\n                 continue\n             }\n \n-            let mut cmd = builder.rustdoc_cmd(compiler);\n+            let mut cmd = builder.rustdoc_cmd(compiler.host);\n             cmd.arg(\"--html-after-content\").arg(&footer)\n                .arg(\"--html-before-content\").arg(&version_info)\n                .arg(\"--html-in-header\").arg(&favicon)\n@@ -408,7 +408,7 @@ impl Step for Std {\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n-        let rustdoc = builder.rustdoc(compiler);\n+        let rustdoc = builder.rustdoc(compiler.host);\n         let compiler = if build.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n@@ -493,7 +493,7 @@ impl Step for Test {\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n-        let rustdoc = builder.rustdoc(compiler);\n+        let rustdoc = builder.rustdoc(compiler.host);\n         let compiler = if build.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {\n@@ -554,7 +554,7 @@ impl Step for Rustc {\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n-        let rustdoc = builder.rustdoc(compiler);\n+        let rustdoc = builder.rustdoc(compiler.host);\n         let compiler = if build.force_use_stage1(compiler, target) {\n             builder.compiler(1, compiler.host)\n         } else {"}, {"sha": "a9cefb65f4963af4b6c4979ee7856e2ddd1fd5fd", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -33,7 +33,8 @@ pub struct Flags {\n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n     pub keep_stage: Option<u32>,\n-    pub build: Interned<String>,\n+    pub build: Option<Interned<String>>,\n+\n     pub host: Vec<Interned<String>>,\n     pub target: Vec<Interned<String>>,\n     pub config: Option<PathBuf>,\n@@ -68,6 +69,14 @@ pub enum Subcommand {\n     },\n }\n \n+impl Default for Subcommand {\n+    fn default() -> Subcommand {\n+        Subcommand::Build {\n+            paths: vec![PathBuf::from(\"nowhere\")],\n+        }\n+    }\n+}\n+\n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n         let mut extra_help = String::new();\n@@ -243,10 +252,8 @@ Arguments:\n \n         // All subcommands can have an optional \"Available paths\" section\n         if matches.opt_present(\"verbose\") {\n-            let flags = Flags::parse(&[\"build\".to_string()]);\n-            let mut config = Config::parse(&flags.build, cfg_file.clone());\n-            config.build = flags.build.clone();\n-            let mut build = Build::new(flags, config);\n+            let config = Config::parse(&[\"build\".to_string()]);\n+            let mut build = Build::new(config);\n             metadata::build(&mut build);\n \n             let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n@@ -320,9 +327,7 @@ Arguments:\n             stage: stage,\n             on_fail: matches.opt_str(\"on-fail\"),\n             keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n-            build: INTERNER.intern_string(matches.opt_str(\"build\").unwrap_or_else(|| {\n-                env::var(\"BUILD\").unwrap()\n-            })),\n+            build: matches.opt_str(\"build\").map(|s| INTERNER.intern_string(s)),\n             host: split(matches.opt_strs(\"host\"))\n                 .into_iter().map(|x| INTERNER.intern_string(x)).collect::<Vec<_>>(),\n             target: split(matches.opt_strs(\"target\"))"}, {"sha": "89690e444d1f6d9bfb997d1b26faba7cb29b0cac", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -28,7 +28,7 @@ pub fn install_docs(builder: &Builder, stage: u32, host: Interned<String>) {\n }\n \n pub fn install_std(builder: &Builder, stage: u32) {\n-    for target in builder.build.config.target.iter() {\n+    for target in &builder.build.targets {\n         install_sh(builder, \"std\", \"rust-std\", stage, Some(*target));\n     }\n }"}, {"sha": "1452a38f6ed283b1433d1a63ea28cc144406473e", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 21, "deletions": 40, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -136,13 +136,13 @@ extern crate toml;\n extern crate libc;\n \n use std::cell::Cell;\n-use std::cmp;\n use std::collections::{HashSet, HashMap};\n use std::env;\n use std::fs::{self, File};\n use std::io::Read;\n use std::path::{PathBuf, Path};\n use std::process::Command;\n+use std::slice;\n \n use build_helper::{run_silent, run_suppressed, try_run_silent, try_run_suppressed, output, mtime};\n \n@@ -187,7 +187,7 @@ mod job {\n }\n \n pub use config::Config;\n-pub use flags::{Flags, Subcommand};\n+use flags::Subcommand;\n use cache::{Interned, INTERNER};\n \n /// A structure representing a Rust compiler.\n@@ -215,9 +215,6 @@ pub struct Build {\n     // User-specified configuration via config.toml\n     config: Config,\n \n-    // User-specified configuration via CLI flags\n-    flags: Flags,\n-\n     // Derived properties from the above two configurations\n     src: PathBuf,\n     out: PathBuf,\n@@ -288,9 +285,9 @@ impl Build {\n     /// line and the filesystem `config`.\n     ///\n     /// By default all build output will be placed in the current directory.\n-    pub fn new(flags: Flags, config: Config) -> Build {\n+    pub fn new(config: Config) -> Build {\n         let cwd = t!(env::current_dir());\n-        let src = flags.src.clone();\n+        let src = config.src.clone();\n         let out = cwd.join(\"build\");\n \n         let is_sudo = match env::var_os(\"SUDO_USER\") {\n@@ -302,43 +299,21 @@ impl Build {\n             }\n             None => false,\n         };\n-        let rust_info = channel::GitInfo::new(&src);\n-        let cargo_info = channel::GitInfo::new(&src.join(\"src/tools/cargo\"));\n-        let rls_info = channel::GitInfo::new(&src.join(\"src/tools/rls\"));\n-\n-        let hosts = if !flags.host.is_empty() {\n-            for host in flags.host.iter() {\n-                if !config.host.contains(host) {\n-                    panic!(\"specified host `{}` is not in configuration\", host);\n-                }\n-            }\n-            flags.host.clone()\n-        } else {\n-            config.host.clone()\n-        };\n-        let targets = if !flags.target.is_empty() {\n-            for target in flags.target.iter() {\n-                if !config.target.contains(target) {\n-                    panic!(\"specified target `{}` is not in configuration\", target);\n-                }\n-            }\n-            flags.target.clone()\n-        } else {\n-            config.target.clone()\n-        };\n+        let rust_info = channel::GitInfo::new(&config, &src);\n+        let cargo_info = channel::GitInfo::new(&config, &src.join(\"src/tools/cargo\"));\n+        let rls_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rls\"));\n \n         Build {\n             initial_rustc: config.initial_rustc.clone(),\n             initial_cargo: config.initial_cargo.clone(),\n             local_rebuild: config.local_rebuild,\n-            fail_fast: flags.cmd.fail_fast(),\n-            verbosity: cmp::max(flags.verbose, config.verbose),\n+            fail_fast: config.cmd.fail_fast(),\n+            verbosity: config.verbose,\n \n-            build: config.host[0].clone(),\n-            hosts: hosts,\n-            targets: targets,\n+            build: config.build,\n+            hosts: config.hosts.clone(),\n+            targets: config.targets.clone(),\n \n-            flags: flags,\n             config: config,\n             src: src,\n             out: out,\n@@ -357,13 +332,19 @@ impl Build {\n         }\n     }\n \n+    pub fn build_triple(&self) -> &[Interned<String>] {\n+        unsafe {\n+            slice::from_raw_parts(&self.build, 1)\n+        }\n+    }\n+\n     /// Executes the entire build, as configured by the flags and configuration.\n     pub fn build(&mut self) {\n         unsafe {\n             job::setup(self);\n         }\n \n-        if let Subcommand::Clean = self.flags.cmd {\n+        if let Subcommand::Clean = self.config.cmd {\n             return clean::clean(self);\n         }\n \n@@ -608,7 +589,7 @@ impl Build {\n     /// Returns the number of parallel jobs that have been configured for this\n     /// build.\n     fn jobs(&self) -> u32 {\n-        self.flags.jobs.unwrap_or_else(|| num_cpus::get() as u32)\n+        self.config.jobs.unwrap_or_else(|| num_cpus::get() as u32)\n     }\n \n     /// Returns the path to the C compiler for the target specified.\n@@ -727,7 +708,7 @@ impl Build {\n     fn force_use_stage1(&self, compiler: Compiler, target: Interned<String>) -> bool {\n         !self.config.full_bootstrap &&\n             compiler.stage >= 2 &&\n-            self.config.host.iter().any(|h| *h == target)\n+            self.hosts.iter().any(|h| *h == target)\n     }\n \n     /// Returns the directory that OpenSSL artifacts are compiled into if"}, {"sha": "436a13500f254054913b0259d0173ed3b847d315", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -85,7 +85,7 @@ pub fn check(build: &mut Build) {\n     }\n \n     // We need cmake, but only if we're actually building LLVM or sanitizers.\n-    let building_llvm = build.config.host.iter()\n+    let building_llvm = build.hosts.iter()\n         .filter_map(|host| build.config.target_config.get(host))\n         .any(|config| config.llvm_config.is_none());\n     if building_llvm || build.config.sanitizers {\n@@ -114,7 +114,7 @@ pub fn check(build: &mut Build) {\n \n     // We're gonna build some custom C code here and there, host triples\n     // also build some C++ shims for LLVM so we need a C++ compiler.\n-    for target in &build.config.target {\n+    for target in &build.targets {\n         // On emscripten we don't actually need the C compiler to just\n         // build the target artifacts, only for testing. For the sake\n         // of easier bot configuration, just skip detection.\n@@ -128,7 +128,7 @@ pub fn check(build: &mut Build) {\n         }\n     }\n \n-    for host in build.config.host.iter() {\n+    for host in &build.hosts {\n         cmd_finder.must_have(build.cxx(*host).unwrap());\n \n         // The msvc hosts don't use jemalloc, turn it off globally to\n@@ -144,7 +144,7 @@ pub fn check(build: &mut Build) {\n         panic!(\"FileCheck executable {:?} does not exist\", filecheck);\n     }\n \n-    for target in &build.config.target {\n+    for target in &build.targets {\n         // Can't compile for iOS unless we're on macOS\n         if target.contains(\"apple-ios\") &&\n            !build.build.contains(\"apple-darwin\") {"}, {"sha": "d798e8de3dffae66fff02079891f75b21586fe9b", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 61, "deletions": 40, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -23,10 +23,10 @@ use channel::GitInfo;\n use cache::Interned;\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-struct CleanTools {\n-    compiler: Compiler,\n-    target: Interned<String>,\n-    mode: Mode,\n+pub struct CleanTools {\n+    pub compiler: Compiler,\n+    pub target: Interned<String>,\n+    pub mode: Mode,\n }\n \n impl Step for CleanTools {\n@@ -82,7 +82,6 @@ impl Step for ToolBuild {\n         let target = self.target;\n         let tool = self.tool;\n \n-        builder.ensure(CleanTools { compiler, target, mode: self.mode });\n         match self.mode {\n             Mode::Libstd => builder.ensure(compile::Std { compiler, target }),\n             Mode::Libtest => builder.ensure(compile::Test { compiler, target }),\n@@ -93,36 +92,46 @@ impl Step for ToolBuild {\n         let _folder = build.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n         println!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target);\n \n-        let mut cargo = builder.cargo(compiler, Mode::Tool, target, \"build\");\n-        let dir = build.src.join(\"src/tools\").join(tool);\n-        cargo.arg(\"--manifest-path\").arg(dir.join(\"Cargo.toml\"));\n-\n-        // We don't want to build tools dynamically as they'll be running across\n-        // stages and such and it's just easier if they're not dynamically linked.\n-        cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n-\n-        if let Some(dir) = build.openssl_install_dir(target) {\n-            cargo.env(\"OPENSSL_STATIC\", \"1\");\n-            cargo.env(\"OPENSSL_DIR\", dir);\n-            cargo.env(\"LIBZ_SYS_STATIC\", \"1\");\n-        }\n+        let mut cargo = prepare_tool_cargo(builder, compiler, target, tool);\n+        build.run(&mut cargo);\n+        build.cargo_out(compiler, Mode::Tool, target).join(exe(tool, &compiler.host))\n+    }\n+}\n \n-        cargo.env(\"CFG_RELEASE_CHANNEL\", &build.config.channel);\n+fn prepare_tool_cargo(\n+    builder: &Builder,\n+    compiler: Compiler,\n+    target: Interned<String>,\n+    tool: &'static str,\n+) -> Command {\n+    let build = builder.build;\n+    let mut cargo = builder.cargo(compiler, Mode::Tool, target, \"build\");\n+    let dir = build.src.join(\"src/tools\").join(tool);\n+    cargo.arg(\"--manifest-path\").arg(dir.join(\"Cargo.toml\"));\n+\n+    // We don't want to build tools dynamically as they'll be running across\n+    // stages and such and it's just easier if they're not dynamically linked.\n+    cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n+    if let Some(dir) = build.openssl_install_dir(target) {\n+        cargo.env(\"OPENSSL_STATIC\", \"1\");\n+        cargo.env(\"OPENSSL_DIR\", dir);\n+        cargo.env(\"LIBZ_SYS_STATIC\", \"1\");\n+    }\n \n-        let info = GitInfo::new(&dir);\n-        if let Some(sha) = info.sha() {\n-            cargo.env(\"CFG_COMMIT_HASH\", sha);\n-        }\n-        if let Some(sha_short) = info.sha_short() {\n-            cargo.env(\"CFG_SHORT_COMMIT_HASH\", sha_short);\n-        }\n-        if let Some(date) = info.commit_date() {\n-            cargo.env(\"CFG_COMMIT_DATE\", date);\n-        }\n+    cargo.env(\"CFG_RELEASE_CHANNEL\", &build.config.channel);\n \n-        build.run(&mut cargo);\n-        build.cargo_out(compiler, Mode::Tool, target).join(exe(tool, &compiler.host))\n+    let info = GitInfo::new(&build.config, &dir);\n+    if let Some(sha) = info.sha() {\n+        cargo.env(\"CFG_COMMIT_HASH\", sha);\n+    }\n+    if let Some(sha_short) = info.sha_short() {\n+        cargo.env(\"CFG_SHORT_COMMIT_HASH\", sha_short);\n     }\n+    if let Some(date) = info.commit_date() {\n+        cargo.env(\"CFG_COMMIT_DATE\", date);\n+    }\n+    cargo\n }\n \n macro_rules! tool {\n@@ -226,7 +235,7 @@ impl Step for RemoteTestServer {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustdoc {\n-    pub target_compiler: Compiler,\n+    pub host: Interned<String>,\n }\n \n impl Step for Rustdoc {\n@@ -240,27 +249,39 @@ impl Step for Rustdoc {\n \n     fn make_run(run: RunConfig) {\n         run.builder.ensure(Rustdoc {\n-            target_compiler: run.builder.compiler(run.builder.top_stage, run.host),\n+            host: run.host,\n         });\n     }\n \n     fn run(self, builder: &Builder) -> PathBuf {\n-        let target_compiler = self.target_compiler;\n+        let build = builder.build;\n+        let target_compiler = builder.compiler(builder.top_stage, self.host);\n+        let target = target_compiler.host;\n         let build_compiler = if target_compiler.stage == 0 {\n             builder.compiler(0, builder.build.build)\n+        } else if target_compiler.stage >= 2 {\n+            // Past stage 2, we consider the compiler to be ABI-compatible and hence capable of\n+            // building rustdoc itself.\n+            builder.compiler(target_compiler.stage, builder.build.build)\n         } else {\n             // Similar to `compile::Assemble`, build with the previous stage's compiler. Otherwise\n             // we'd have stageN/bin/rustc and stageN/bin/rustdoc be effectively different stage\n             // compilers, which isn't what we want.\n             builder.compiler(target_compiler.stage - 1, builder.build.build)\n         };\n \n-        let tool_rustdoc = builder.ensure(ToolBuild {\n-            compiler: build_compiler,\n-            target: target_compiler.host,\n-            tool: \"rustdoc\",\n-            mode: Mode::Librustc,\n-        });\n+        builder.ensure(compile::Rustc { compiler: build_compiler, target });\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n+        println!(\"Building rustdoc for stage{} ({})\", target_compiler.stage, target_compiler.host);\n+\n+        let mut cargo = prepare_tool_cargo(builder, build_compiler, target, \"rustdoc\");\n+        build.run(&mut cargo);\n+        // Cargo adds a number of paths to the dylib search path on windows, which results in\n+        // the wrong rustdoc being executed. To avoid the conflicting rustdocs, we name the \"tool\"\n+        // rustdoc a different name.\n+        let tool_rustdoc = build.cargo_out(build_compiler, Mode::Tool, target)\n+            .join(exe(\"rustdoc-tool-binary\", &target_compiler.host));\n \n         // don't create a stage0-sysroot/bin directory.\n         if target_compiler.stage > 0 {"}, {"sha": "1049cc4284a05379280a456b6f9e807bdddd435f", "filename": "src/doc/rustdoc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2FSUMMARY.md?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -2,7 +2,7 @@\n \n - [What is rustdoc?](what-is-rustdoc.md)\n - [Command-line arguments](command-line-arguments.md)\n-- [In-source directives](in-source-directives.md)\n+- [The `#[doc]` attribute](the-doc-attribute.md)\n - [Documentation tests](documentation-tests.md)\n - [Plugins](plugins.md)\n - [Passes](passes.md)\n\\ No newline at end of file"}, {"sha": "4f7736d8df6bb6cd79fc8448c0b7de1a5a7e0152", "filename": "src/doc/rustdoc/src/documentation-tests.md", "status": "modified", "additions": 237, "deletions": 1, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fdocumentation-tests.md?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -1,3 +1,239 @@\n # Documentation tests\n \n-Coming soon!\n\\ No newline at end of file\n+`rustdoc` supports executing your documentation examples as tests. This makes sure\n+that your tests are up to date and working.\n+\n+The basic idea is this:\n+\n+```rust,ignore\n+/// # Examples\n+///\n+/// ```\n+/// let x = 5;\n+/// ```\n+```\n+\n+The triple backticks start and end code blocks. If this were in a file named `foo.rs`,\n+running `rustdoc --test foo.rs` will extract this example, and then run it as a test.\n+\n+There's some subtlety though! Read on for more details.\n+\n+## Pre-processing examples\n+\n+In the example above, you'll note something strange: there's no `main`\n+function! Forcing you to write `main` for every example, no matter how small,\n+adds friction. So `rustdoc` processes your examples slightly before\n+running them. Here's the full algorithm rustdoc uses to preprocess examples:\n+\n+1. Any leading `#![foo]` attributes are left intact as crate attributes.\n+2. Some common `allow` attributes are inserted, including\n+   `unused_variables`, `unused_assignments`, `unused_mut`,\n+   `unused_attributes`, and `dead_code`. Small examples often trigger\n+   these lints.\n+3. If the example does not contain `extern crate`, then `extern crate\n+   <mycrate>;` is inserted (note the lack of `#[macro_use]`).\n+4. Finally, if the example does not contain `fn main`, the remainder of the\n+   text is wrapped in `fn main() { your_code }`.\n+\n+For more about that caveat in rule 3, see \"Documeting Macros\" below.\n+\n+## Hiding portions of the example\n+\n+Sometimes, you need some setup code, or other things that would distract\n+from your example, but are important to make the tests work. Consider\n+an example block that looks like this:\n+\n+```text\n+/// Some documentation.\n+# fn foo() {}\n+```\n+\n+It will render like this:\n+\n+```rust\n+/// Some documentation.\n+# fn foo() {}\n+```\n+\n+Yes, that's right: you can add lines that start with `# `, and they will\n+be hidden from the output, but will be used when compiling your code. You\n+can use this to your advantage. In this case, documentation comments need\n+to apply to some kind of function, so if I want to show you just a\n+documentation comment, I need to add a little function definition below\n+it. At the same time, it's only there to satisfy the compiler, so hiding\n+it makes the example more clear. You can use this technique to explain\n+longer examples in detail, while still preserving the testability of your\n+documentation.\n+\n+For example, imagine that we wanted to document this code:\n+\n+```rust\n+let x = 5;\n+let y = 6;\n+println!(\"{}\", x + y);\n+```\n+\n+We might want the documentation to end up looking like this:\n+\n+> First, we set `x` to five:\n+>\n+> ```rust\n+> let x = 5;\n+> # let y = 6;\n+> # println!(\"{}\", x + y);\n+> ```\n+>\n+> Next, we set `y` to six:\n+>\n+> ```rust\n+> # let x = 5;\n+> let y = 6;\n+> # println!(\"{}\", x + y);\n+> ```\n+>\n+> Finally, we print the sum of `x` and `y`:\n+>\n+> ```rust\n+> # let x = 5;\n+> # let y = 6;\n+> println!(\"{}\", x + y);\n+> ```\n+\n+To keep each code block testable, we want the whole program in each block, but\n+we don't want the reader to see every line every time.  Here's what we put in\n+our source code:\n+\n+```text\n+    First, we set `x` to five:\n+\n+    ```rust\n+    let x = 5;\n+    # let y = 6;\n+    # println!(\"{}\", x + y);\n+    ```\n+\n+    Next, we set `y` to six:\n+\n+    ```rust\n+    # let x = 5;\n+    let y = 6;\n+    # println!(\"{}\", x + y);\n+    ```\n+\n+    Finally, we print the sum of `x` and `y`:\n+\n+    ```rust\n+    # let x = 5;\n+    # let y = 6;\n+    println!(\"{}\", x + y);\n+    ```\n+```\n+\n+By repeating all parts of the example, you can ensure that your example still\n+compiles, while only showing the parts that are relevant to that part of your\n+explanation.\n+\n+Another case where the use of `#` is handy is when you want to ignore\n+error handling. Lets say you want the following,\n+\n+```rust,ignore\n+/// use std::io;\n+/// let mut input = String::new();\n+/// io::stdin().read_line(&mut input)?;\n+```\n+\n+The problem is that `?` returns a `Result<T, E>` and test functions\n+don't return anything so this will give a mismatched types error.\n+\n+```rust,ignore\n+/// A doc test using ?\n+///\n+/// ```\n+/// use std::io;\n+/// # fn foo() -> io::Result<()> {\n+/// let mut input = String::new();\n+/// io::stdin().read_line(&mut input)?;\n+/// # Ok(())\n+/// # }\n+/// ```\n+# fn foo() {}\n+```\n+\n+You can get around this by wrapping the code in a function. This catches\n+and swallows the `Result<T, E>` when running tests on the docs. This\n+pattern appears regularly in the standard library.\n+\n+### Documenting macros\n+\n+Here\u2019s an example of documenting a macro:\n+\n+```rust\n+/// Panic with a given message unless an expression evaluates to true.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// # #[macro_use] extern crate foo;\n+/// # fn main() {\n+/// panic_unless!(1 + 1 == 2, \u201cMath is broken.\u201d);\n+/// # }\n+/// ```\n+///\n+/// ```rust,should_panic\n+/// # #[macro_use] extern crate foo;\n+/// # fn main() {\n+/// panic_unless!(true == false, \u201cI\u2019m broken.\u201d);\n+/// # }\n+/// ```\n+#[macro_export]\n+macro_rules! panic_unless {\n+    ($condition:expr, $($rest:expr),+) => ({ if ! $condition { panic!($($rest),+); } });\n+}\n+# fn main() {}\n+```\n+\n+You\u2019ll note three things: we need to add our own `extern crate` line, so that\n+we can add the `#[macro_use]` attribute. Second, we\u2019ll need to add our own\n+`main()` as well (for reasons discussed above). Finally, a judicious use of\n+`#` to comment out those two things, so they don\u2019t show up in the output.\n+\n+## Attributes\n+\n+There are a few annotations that are useful to help `rustdoc` do the right\n+thing when testing your code:\n+\n+```rust\n+/// ```ignore\n+/// fn foo() {\n+/// ```\n+# fn foo() {}\n+```\n+\n+The `ignore` directive tells Rust to ignore your code. This is almost never\n+what you want, as it's the most generic. Instead, consider annotating it\n+with `text` if it's not code, or using `#`s to get a working example that\n+only shows the part you care about.\n+\n+```rust\n+/// ```should_panic\n+/// assert!(false);\n+/// ```\n+# fn foo() {}\n+```\n+\n+`should_panic` tells `rustdoc` that the code should compile correctly, but\n+not actually pass as a test.\n+\n+```rust\n+/// ```no_run\n+/// loop {\n+///     println!(\"Hello, world\");\n+/// }\n+/// ```\n+# fn foo() {}\n+```\n+\n+The `no_run` attribute will compile your code, but not run it. This is\n+important for examples such as \"Here's how to retrieve a web page,\"\n+which you would want to ensure compiles, but might be run in a test\n+environment that has no network access.\n\\ No newline at end of file"}, {"sha": "83f677fa7f4c5900bfb80882b4a8072b881a28cc", "filename": "src/doc/rustdoc/src/in-source-directives.md", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b045c201b2086073f43d76290b9cb2a5a8e16f89/src%2Fdoc%2Frustdoc%2Fsrc%2Fin-source-directives.md", "raw_url": "https://github.com/rust-lang/rust/raw/b045c201b2086073f43d76290b9cb2a5a8e16f89/src%2Fdoc%2Frustdoc%2Fsrc%2Fin-source-directives.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fin-source-directives.md?ref=b045c201b2086073f43d76290b9cb2a5a8e16f89", "patch": "@@ -1,3 +0,0 @@\n-# In-source directives\n-\n-Coming soon!\n\\ No newline at end of file"}, {"sha": "978d7656bdd71d77e00cc44d6cd9994251eca035", "filename": "src/doc/rustdoc/src/the-doc-attribute.md", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,178 @@\n+# The `#[doc]` attribute\n+\n+The `#[doc]` attribute lets you control various aspects of how `rustdoc` does\n+its job. \n+\n+The most basic function of `#[doc]` is to handle the actual documentation\n+text. That is, `///` is syntax sugar for `#[doc]`. This means that these two\n+are the same:\n+\n+```rust,ignore\n+/// This is a doc comment.\n+#[doc = \" This is a doc comment.\"]\n+```\n+\n+(Note the leading space in the attribute version.)\n+\n+In most cases, `///` is easier to use than `#[doc]`. One case where the latter is easier is\n+when generating documentation in macros; the `collapse-docs` pass will combine multiple\n+`#[doc]` attributes into a single doc comment, letting you generate code like this:\n+\n+```rust,ignore\n+#[doc = \"This is\"]\n+#[doc = \" a \"]\n+#[doc = \"doc comment\"]\n+```\n+\n+Which can feel more flexible. Note that this would generate this:\n+\n+```rust,ignore\n+#[doc = \"This is\\n a \\ndoc comment\"]\n+```\n+\n+but given that docs are rendered via Markdown, it will remove these newlines.\n+\n+The `doc` attribute has more options though! These don't involve the text of\n+the output, but instead, various aspects of the presentation of the output.\n+We've split them into two kinds below: attributes that are useful at the\n+crate level, and ones that are useful at the item level.\n+\n+## At the crate level\n+\n+These options control how the docs look at a macro level.\n+\n+### `html_favicon_url`\n+\n+This form of the `doc` attribute lets you control the favicon of your docs.\n+\n+```rust,ignore\n+#![doc(html_favicon_url = \"https://example.com/favicon.ico\")]\n+```\n+\n+This will put `<link rel=\"shortcut icon\" href=\"{}\">` into your docs, where\n+the string for the attribute goes into the `{}`.\n+\n+If you don't use this attribute, there will be no favicon.\n+\n+### `html_logo_url`\n+\n+This form of the `doc` attribute lets you control the logo in the upper\n+left hand side of the docs.\n+\n+```rust,ignore\n+#![doc(html_logo_url = \"https://example.com/logo.jpg\")]\n+```\n+\n+This will put `<a href='index.html'><img src='{}' alt='logo' width='100'></a>` into\n+your docs, where the string for the attribute goes into the `{}`.\n+\n+If you don't use this attribute, there will be no logo.\n+\n+### `html_playground_url`\n+\n+This form of the `doc` attribute lets you control where the \"run\" buttons\n+on your documentation examples make requests to.\n+\n+```rust,ignore\n+#![doc(html_playground_url = \"https://playground.example.com/\")]\n+```\n+\n+Now, when you press \"run\", the button will make a request to this domain.\n+\n+If you don't use this attribute, there will be no run buttons.\n+\n+### `issue_tracker_base_url`\n+\n+This form of the `doc` attribute is mostly only useful for the standard library;\n+When a feature is unstable, an issue number for tracking the feature must be\n+given. `rustdoc` uses this number, plus the base URL given here, to link to\n+the tracking issue.\n+\n+```rust,ignore\n+#![doc(issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n+```\n+\n+### `html_no_source`\n+\n+By default, `rustdoc` will include the source code of your program, with links\n+to it in the docs. But if you include this:\n+\n+```rust,ignore\n+#![doc(html_no_source)]\n+```\n+\n+it will not.\n+\n+## At the item level\n+\n+These forms of the `#[doc]` attribute are used on individual items, to control how\n+they are documented.\n+\n+## `#[doc(no_inline)]`/`#[doc(inline)]`\n+\n+These attributes are used on `use` statements, and control where the documentation shows\n+up. For example, consider this Rust code:\n+\n+```rust,ignore\n+pub use bar::Bar;\n+\n+/// bar docs\n+pub mod bar {\n+    /// the docs for Bar\n+    pub struct Bar;\n+}\n+```\n+\n+The documentation will generate a \"Reexports\" section, and say `pub use bar::Bar;`, where\n+`Bar` is a link to its page.\n+\n+If we change the `use` line like this:\n+\n+```rust,ignore\n+#[doc(inline)]\n+pub use bar::Bar;\n+```\n+\n+Instead, `Bar` will appear in a `Structs` section, just like `Bar` was defined at the\n+top level, rather than `pub use`'d.\n+\n+Let's change our original example, by making `bar` private:\n+\n+```rust,ignore\n+pub use bar::Bar;\n+\n+/// bar docs\n+mod bar {\n+    /// the docs for Bar\n+    pub struct Bar;\n+}\n+```\n+\n+Here, because `bar` is not public, `Bar` wouldn't have its own page, so there's nowhere\n+to link to. `rustdoc` will inline these definitions, and so we end up in the same case\n+as the `#[doc(inline)]` above; `Bar` is in a `Structs` section, as if it were defined at\n+the top level. If we add the `no_inline` form of the attribute:\n+\n+```rust,ignore\n+#[doc(no_inline)]\n+pub use bar::Bar;\n+\n+/// bar docs\n+mod bar {\n+    /// the docs for Bar\n+    pub struct Bar;\n+}\n+```\n+\n+Now we'll have a `Reexports` line, and `Bar` will not link to anywhere.\n+\n+## `#[doc(hidden)]`\n+\n+Any item annotated with `#[doc(hidden)]` will not appear in the documentation, unless\n+the `strip-hidden` pass is removed.\n+\n+## `#[doc(primitive)]`\n+\n+Since primitive types are defined in the compiler, there's no place to attach documentation\n+attributes. This attribute is used by the standard library to provide a way to generate\n+documentation for primitive types."}, {"sha": "ddc538e12144ac5ff5a2d692d5aba400c4ca3843", "filename": "src/doc/unstable-book/src/language-features/doc-cfg.md", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-cfg.md", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-cfg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fdoc-cfg.md?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,42 @@\n+# `doc_cfg`\n+\n+The tracking issue for this feature is: [#43781]\n+\n+------\n+\n+The `doc_cfg` feature allows an API be documented as only available in some specific platforms.\n+This attribute has two effects:\n+\n+1. In the annotated item's documentation, there will be a message saying \"This is supported on\n+    (platform) only\".\n+\n+2. The item's doc-tests will only run on the specific platform.\n+\n+This feature was introduced as part of PR [#43348] to allow the platform-specific parts of the\n+standard library be documented.\n+\n+```rust\n+#![feature(doc_cfg)]\n+\n+#[cfg(any(windows, feature = \"documentation\"))]\n+#[doc(cfg(windows))]\n+/// The application's icon in the notification area (a.k.a. system tray).\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// extern crate my_awesome_ui_library;\n+/// use my_awesome_ui_library::current_app;\n+/// use my_awesome_ui_library::windows::notification;\n+///\n+/// let icon = current_app().get::<notification::Icon>();\n+/// icon.show();\n+/// icon.show_message(\"Hello\");\n+/// ```\n+pub struct Icon {\n+    // ...\n+}\n+```\n+\n+[#43781]: https://github.com/rust-lang/rust/issues/43781\n+[#43348]: https://github.com/rust-lang/rust/issues/43348\n\\ No newline at end of file"}, {"sha": "2b3df15f716183062ba1b28cb9ee15c2f96ebd49", "filename": "src/liballoc/allocator.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -40,7 +40,7 @@ fn size_align<T>() -> (usize, usize) {\n ///\n /// (Note however that layouts are *not* required to have positive\n /// size, even though many allocators require that all memory\n-/// requeusts have positive size. A caller to the `Alloc::alloc`\n+/// requests have positive size. A caller to the `Alloc::alloc`\n /// method must either ensure that conditions like this are met, or\n /// use specific allocators with looser requirements.)\n #[derive(Clone, Debug, PartialEq, Eq)]\n@@ -240,7 +240,7 @@ impl Layout {\n     ///\n     /// Returns `Some((k, offset))`, where `k` is layout of the concatenated\n     /// record and `offset` is the relative location, in bytes, of the\n-    /// start of the `next` embedded witnin the concatenated record\n+    /// start of the `next` embedded within the concatenated record\n     /// (assuming that the record itself starts at offset 0).\n     ///\n     /// On arithmetic overflow, returns `None`.\n@@ -297,7 +297,7 @@ impl Layout {\n     ///\n     /// Returns `(k, offset)`, where `k` is layout of the concatenated\n     /// record and `offset` is the relative location, in bytes, of the\n-    /// start of the `next` embedded witnin the concatenated record\n+    /// start of the `next` embedded within the concatenated record\n     /// (assuming that the record itself starts at offset 0).\n     ///\n     /// (The `offset` is always the same as `self.size()`; we use this\n@@ -354,15 +354,19 @@ pub enum AllocErr {\n }\n \n impl AllocErr {\n+    #[inline]\n     pub fn invalid_input(details: &'static str) -> Self {\n         AllocErr::Unsupported { details: details }\n     }\n+    #[inline]\n     pub fn is_memory_exhausted(&self) -> bool {\n         if let AllocErr::Exhausted { .. } = *self { true } else { false }\n     }\n+    #[inline]\n     pub fn is_request_unsupported(&self) -> bool {\n         if let AllocErr::Unsupported { .. } = *self { true } else { false }\n     }\n+    #[inline]\n     pub fn description(&self) -> &str {\n         match *self {\n             AllocErr::Exhausted { .. } => \"allocator memory exhausted\",\n@@ -544,7 +548,7 @@ pub unsafe trait Alloc {\n     /// practice this means implementors should eschew allocating,\n     /// especially from `self` (directly or indirectly).\n     ///\n-    /// Implementions of the allocation and reallocation methods\n+    /// Implementations of the allocation and reallocation methods\n     /// (e.g. `alloc`, `alloc_one`, `realloc`) are discouraged from\n     /// panicking (or aborting) in the event of memory exhaustion;\n     /// instead they should return an appropriate error from the"}, {"sha": "0e61905131f6f3328b472b5a9eabe8d2be030d12", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -132,7 +132,7 @@ impl<K, V> InternalNode<K, V> {\n \n /// An owned pointer to a node. This basically is either `Box<LeafNode<K, V>>` or\n /// `Box<InternalNode<K, V>>`. However, it contains no information as to which of the two types\n-/// of nodes is acutally behind the box, and, partially due to this lack of information, has no\n+/// of nodes is actually behind the box, and, partially due to this lack of information, has no\n /// destructor.\n struct BoxedNode<K, V> {\n     ptr: Unique<LeafNode<K, V>>\n@@ -264,7 +264,7 @@ impl<K, V> Root<K, V> {\n // correct variance.\n /// A reference to a node.\n ///\n-/// This type has a number of paramaters that controls how it acts:\n+/// This type has a number of parameters that controls how it acts:\n /// - `BorrowType`: This can be `Immut<'a>` or `Mut<'a>` for some `'a` or `Owned`.\n ///    When this is `Immut<'a>`, the `NodeRef` acts roughly like `&'a Node`,\n ///    when this is `Mut<'a>`, the `NodeRef` acts roughly like `&'a mut Node`,"}, {"sha": "480fb4b9eaa2bebebaf3e3b21fbf0316e300b951", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 62, "deletions": 37, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -10,16 +10,16 @@\n \n //! Utilities for formatting and printing `String`s\n //!\n-//! This module contains the runtime support for the `format!` syntax extension.\n+//! This module contains the runtime support for the [`format!`] syntax extension.\n //! This macro is implemented in the compiler to emit calls to this module in\n //! order to format arguments at runtime into strings.\n //!\n //! # Usage\n //!\n-//! The `format!` macro is intended to be familiar to those coming from C's\n-//! printf/fprintf functions or Python's `str.format` function.\n+//! The [`format!`] macro is intended to be familiar to those coming from C's\n+//! `printf`/`fprintf` functions or Python's `str.format` function.\n //!\n-//! Some examples of the `format!` extension are:\n+//! Some examples of the [`format!`] extension are:\n //!\n //! ```\n //! format!(\"Hello\");                 // => \"Hello\"\n@@ -67,15 +67,15 @@\n //! ## Named parameters\n //!\n //! Rust itself does not have a Python-like equivalent of named parameters to a\n-//! function, but the `format!` macro is a syntax extension which allows it to\n+//! function, but the [`format!`] macro is a syntax extension which allows it to\n //! leverage named parameters. Named parameters are listed at the end of the\n //! argument list and have the syntax:\n //!\n //! ```text\n //! identifier '=' expression\n //! ```\n //!\n-//! For example, the following `format!` expressions all use named argument:\n+//! For example, the following [`format!`] expressions all use named argument:\n //!\n //! ```\n //! format!(\"{argument}\", argument = \"test\");   // => \"test\"\n@@ -102,30 +102,30 @@\n //!\n //! If this syntax is used, then the number of characters to print precedes the\n //! actual object being formatted, and the number of characters must have the\n-//! type `usize`.\n+//! type [`usize`].\n //!\n //! ## Formatting traits\n //!\n //! When requesting that an argument be formatted with a particular type, you\n //! are actually requesting that an argument ascribes to a particular trait.\n-//! This allows multiple actual types to be formatted via `{:x}` (like `i8` as\n-//! well as `isize`).  The current mapping of types to traits is:\n+//! This allows multiple actual types to be formatted via `{:x}` (like [`i8`] as\n+//! well as [`isize`]).  The current mapping of types to traits is:\n //!\n-//! * *nothing* \u21d2 [`Display`](trait.Display.html)\n-//! * `?` \u21d2 [`Debug`](trait.Debug.html)\n+//! * *nothing* \u21d2 [`Display`]\n+//! * `?` \u21d2 [`Debug`]\n //! * `o` \u21d2 [`Octal`](trait.Octal.html)\n //! * `x` \u21d2 [`LowerHex`](trait.LowerHex.html)\n //! * `X` \u21d2 [`UpperHex`](trait.UpperHex.html)\n //! * `p` \u21d2 [`Pointer`](trait.Pointer.html)\n-//! * `b` \u21d2 [`Binary`](trait.Binary.html)\n+//! * `b` \u21d2 [`Binary`]\n //! * `e` \u21d2 [`LowerExp`](trait.LowerExp.html)\n //! * `E` \u21d2 [`UpperExp`](trait.UpperExp.html)\n //!\n //! What this means is that any type of argument which implements the\n-//! `fmt::Binary` trait can then be formatted with `{:b}`. Implementations\n+//! [`fmt::Binary`][`Binary`] trait can then be formatted with `{:b}`. Implementations\n //! are provided for these traits for a number of primitive types by the\n //! standard library as well. If no format is specified (as in `{}` or `{:6}`),\n-//! then the format trait used is the `Display` trait.\n+//! then the format trait used is the [`Display`] trait.\n //!\n //! When implementing a format trait for your own type, you will have to\n //! implement a method of the signature:\n@@ -144,15 +144,15 @@\n //! should emit output into the `f.buf` stream. It is up to each format trait\n //! implementation to correctly adhere to the requested formatting parameters.\n //! The values of these parameters will be listed in the fields of the\n-//! `Formatter` struct. In order to help with this, the `Formatter` struct also\n+//! [`Formatter`] struct. In order to help with this, the [`Formatter`] struct also\n //! provides some helper methods.\n //!\n-//! Additionally, the return value of this function is `fmt::Result` which is a\n-//! type alias of `Result<(), std::fmt::Error>`. Formatting implementations\n-//! should ensure that they propagate errors from the `Formatter` (e.g., when\n-//! calling `write!`) however, they should never return errors spuriously. That\n+//! Additionally, the return value of this function is [`fmt::Result`] which is a\n+//! type alias of [`Result`]`<(), `[`std::fmt::Error`]`>`. Formatting implementations\n+//! should ensure that they propagate errors from the [`Formatter`][`Formatter`] (e.g., when\n+//! calling [`write!`]) however, they should never return errors spuriously. That\n //! is, a formatting implementation must and may only return an error if the\n-//! passed-in `Formatter` returns an error. This is because, contrary to what\n+//! passed-in [`Formatter`] returns an error. This is because, contrary to what\n //! the function signature might suggest, string formatting is an infallible\n //! operation. This function only returns a result because writing to the\n //! underlying stream might fail and it must provide a way to propagate the fact\n@@ -209,12 +209,12 @@\n //!\n //! These two formatting traits have distinct purposes:\n //!\n-//! - `fmt::Display` implementations assert that the type can be faithfully\n+//! - [`fmt::Display`][`Display`] implementations assert that the type can be faithfully\n //!   represented as a UTF-8 string at all times. It is **not** expected that\n //!   all types implement the `Display` trait.\n-//! - `fmt::Debug` implementations should be implemented for **all** public types.\n+//! - [`fmt::Debug`][`Debug`] implementations should be implemented for **all** public types.\n //!   Output will typically represent the internal state as faithfully as possible.\n-//!   The purpose of the `Debug` trait is to facilitate debugging Rust code. In\n+//!   The purpose of the [`Debug`] trait is to facilitate debugging Rust code. In\n //!   most cases, using `#[derive(Debug)]` is sufficient and recommended.\n //!\n //! Some examples of the output from both traits:\n@@ -227,7 +227,7 @@\n //!\n //! ## Related macros\n //!\n-//! There are a number of related macros in the `format!` family. The ones that\n+//! There are a number of related macros in the [`format!`] family. The ones that\n //! are currently implemented are:\n //!\n //! ```ignore (only-for-syntax-highlight)\n@@ -241,11 +241,11 @@\n //!\n //! ### `write!`\n //!\n-//! This and `writeln` are two macros which are used to emit the format string\n+//! This and [`writeln!`] are two macros which are used to emit the format string\n //! to a specified stream. This is used to prevent intermediate allocations of\n //! format strings and instead directly write the output. Under the hood, this\n-//! function is actually invoking the `write_fmt` function defined on the\n-//! `std::io::Write` trait. Example usage is:\n+//! function is actually invoking the [`write_fmt`] function defined on the\n+//! [`std::io::Write`] trait. Example usage is:\n //!\n //! ```\n //! # #![allow(unused_must_use)]\n@@ -256,7 +256,7 @@\n //!\n //! ### `print!`\n //!\n-//! This and `println` emit their output to stdout. Similarly to the `write!`\n+//! This and [`println!`] emit their output to stdout. Similarly to the [`write!`]\n //! macro, the goal of these macros is to avoid intermediate allocations when\n //! printing output. Example usage is:\n //!\n@@ -288,8 +288,8 @@\n //! my_fmt_fn(format_args!(\", or a {} too\", \"function\"));\n //! ```\n //!\n-//! The result of the `format_args!` macro is a value of type `fmt::Arguments`.\n-//! This structure can then be passed to the `write` and `format` functions\n+//! The result of the [`format_args!`] macro is a value of type [`fmt::Arguments`].\n+//! This structure can then be passed to the [`write`] and [`format`] functions\n //! inside this module in order to process the format string.\n //! The goal of this macro is to even further prevent intermediate allocations\n //! when dealing formatting strings.\n@@ -357,7 +357,7 @@\n //! * `-` - Currently not used\n //! * `#` - This flag is indicates that the \"alternate\" form of printing should\n //!         be used. The alternate forms are:\n-//!     * `#?` - pretty-print the `Debug` formatting\n+//!     * `#?` - pretty-print the [`Debug`] formatting\n //!     * `#x` - precedes the argument with a `0x`\n //!     * `#X` - precedes the argument with a `0x`\n //!     * `#b` - precedes the argument with a `0b`\n@@ -384,9 +384,9 @@\n //! the `0` flag is specified for numerics, then the implicit fill character is\n //! `0`.\n //!\n-//! The value for the width can also be provided as a `usize` in the list of\n+//! The value for the width can also be provided as a [`usize`] in the list of\n //! parameters by using the dollar syntax indicating that the second argument is\n-//! a `usize` specifying the width, for example:\n+//! a [`usize`] specifying the width, for example:\n //!\n //! ```\n //! // All of these print \"Hello x    !\"\n@@ -474,6 +474,29 @@\n //! The literal characters `{` and `}` may be included in a string by preceding\n //! them with the same character. For example, the `{` character is escaped with\n //! `{{` and the `}` character is escaped with `}}`.\n+//!\n+//! [`format!`]: ../../macro.format.html\n+//! [`usize`]: ../../std/primitive.usize.html\n+//! [`isize`]: ../../std/primitive.isize.html\n+//! [`i8`]: ../../std/primitive.i8.html\n+//! [`Display`]: trait.Display.html\n+//! [`Binary`]: trait.Binary.html\n+//! [`fmt::Result`]: type.Result.html\n+//! [`Result`]: ../../std/result/enum.Result.html\n+//! [`std::fmt::Error`]: struct.Error.html\n+//! [`Formatter`]: struct.Formatter.html\n+//! [`write!`]: ../../std/macro.write.html\n+//! [`Debug`]: trait.Debug.html\n+//! [`format!`]: ../../std/macro.format.html\n+//! [`writeln!`]: ../../std/macro.writeln.html\n+//! [`write_fmt`]: ../../std/io/trait.Write.html#method.write_fmt\n+//! [`std::io::Write`]: ../../std/io/trait.Write.html\n+//! [`println!`]: ../../std/macro.println.html\n+//! [`write!`]: ../../std/macro.write.html\n+//! [`format_args!`]: ../../std/macro.format_args.html\n+//! [`fmt::Arguments`]: struct.Arguments.html\n+//! [`write`]: fn.write.html\n+//! [`format`]: fn.format.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -498,10 +521,10 @@ pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n \n use string;\n \n-/// The `format` function takes an `Arguments` struct and returns the resulting\n+/// The `format` function takes an [`Arguments`] struct and returns the resulting\n /// formatted string.\n ///\n-/// The `Arguments` instance can be created with the `format_args!` macro.\n+/// The [`Arguments`] instance can be created with the [`format_args!`] macro.\n ///\n /// # Examples\n ///\n@@ -514,15 +537,17 @@ use string;\n /// assert_eq!(s, \"Hello, world!\");\n /// ```\n ///\n-/// Please note that using [`format!`][format!] might be preferrable.\n+/// Please note that using [`format!`] might be preferrable.\n /// Example:\n ///\n /// ```\n /// let s = format!(\"Hello, {}!\", \"world\");\n /// assert_eq!(s, \"Hello, world!\");\n /// ```\n ///\n-/// [format!]: ../macro.format.html\n+/// [`Arguments`]: struct.Arguments.html\n+/// [`format_args!`]: ../../std/macro.format_args.html\n+/// [`format!`]: ../../std/macro.format.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn format(args: Arguments) -> string::String {\n     let capacity = args.estimated_capacity();"}, {"sha": "820f2d958d9a8fb066bf1bb8598e71f4356cca2d", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -28,6 +28,7 @@ pub mod __core {\n extern \"Rust\" {\n     #[allocator]\n     fn __rust_alloc(size: usize, align: usize, err: *mut u8) -> *mut u8;\n+    #[cold]\n     fn __rust_oom(err: *const u8) -> !;\n     fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);\n     fn __rust_usable_size(layout: *const u8,\n@@ -81,6 +82,7 @@ unsafe impl Alloc for Heap {\n     }\n \n     #[inline]\n+    #[cold]\n     fn oom(&mut self, err: AllocErr) -> ! {\n         unsafe {\n             __rust_oom(&err as *const AllocErr as *const u8)"}, {"sha": "6090fc3942a565c66ac056ab8d3f41e04ddab826", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 127, "deletions": 76, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use allocator::{Alloc, Layout};\n-use core::ptr::{self, Unique};\n+use core::cmp;\n use core::mem;\n+use core::ops::Drop;\n+use core::ptr::{self, Unique};\n use core::slice;\n-use heap::Heap;\n+use heap::{Alloc, Layout, Heap};\n use super::boxed::Box;\n-use core::ops::Drop;\n-use core::cmp;\n \n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n /// a buffer of memory on the heap without having to worry about all the corner cases\n@@ -222,6 +221,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n         &mut self.a\n     }\n \n+    fn current_layout(&self) -> Option<Layout> {\n+        if self.cap == 0 {\n+            None\n+        } else {\n+            // We have an allocated chunk of memory, so we can bypass runtime\n+            // checks to get our current layout.\n+            unsafe {\n+                let align = mem::align_of::<T>();\n+                let size = mem::size_of::<T>() * self.cap;\n+                Some(Layout::from_size_align_unchecked(size, align))\n+            }\n+        }\n+    }\n+\n     /// Doubles the size of the type's backing allocation. This is common enough\n     /// to want to do that it's easiest to just have a dedicated method. Slightly\n     /// more efficient logic can be provided for this than the general case.\n@@ -280,27 +293,40 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // 0, getting to here necessarily means the RawVec is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            let (new_cap, ptr_res) = if self.cap == 0 {\n-                // skip to 4 because tiny Vec's are dumb; but not if that would cause overflow\n-                let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n-                let ptr_res = self.a.alloc_array::<T>(new_cap);\n-                (new_cap, ptr_res)\n-            } else {\n-                // Since we guarantee that we never allocate more than isize::MAX bytes,\n-                // `elem_size * self.cap <= isize::MAX` as a precondition, so this can't overflow\n-                let new_cap = 2 * self.cap;\n-                let new_alloc_size = new_cap * elem_size;\n-                alloc_guard(new_alloc_size);\n-                let ptr_res = self.a.realloc_array(self.ptr, self.cap, new_cap);\n-                (new_cap, ptr_res)\n-            };\n-\n-            // If allocate or reallocate fail, we'll get `null` back\n-            let uniq = match ptr_res {\n-                Err(err) => self.a.oom(err),\n-                Ok(uniq) => uniq,\n+            let (new_cap, uniq) = match self.current_layout() {\n+                Some(cur) => {\n+                    // Since we guarantee that we never allocate more than\n+                    // isize::MAX bytes, `elem_size * self.cap <= isize::MAX` as\n+                    // a precondition, so this can't overflow. Additionally the\n+                    // alignment will never be too large as to \"not be\n+                    // satisfiable\", so `Layout::from_size_align` will always\n+                    // return `Some`.\n+                    //\n+                    // tl;dr; we bypass runtime checks due to dynamic assertions\n+                    // in this module, allowing us to use\n+                    // `from_size_align_unchecked`.\n+                    let new_cap = 2 * self.cap;\n+                    let new_size = new_cap * elem_size;\n+                    let new_layout = Layout::from_size_align_unchecked(new_size, cur.align());\n+                    alloc_guard(new_size);\n+                    let ptr_res = self.a.realloc(self.ptr.as_ptr() as *mut u8,\n+                                                 cur,\n+                                                 new_layout);\n+                    match ptr_res {\n+                        Ok(ptr) => (new_cap, Unique::new_unchecked(ptr as *mut T)),\n+                        Err(e) => self.a.oom(e),\n+                    }\n+                }\n+                None => {\n+                    // skip to 4 because tiny Vec's are dumb; but not if that\n+                    // would cause overflow\n+                    let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n+                    match self.a.alloc_array::<T>(new_cap) {\n+                        Ok(ptr) => (new_cap, ptr),\n+                        Err(e) => self.a.oom(e),\n+                    }\n+                }\n             };\n-\n             self.ptr = uniq;\n             self.cap = new_cap;\n         }\n@@ -323,21 +349,27 @@ impl<T, A: Alloc> RawVec<T, A> {\n     pub fn double_in_place(&mut self) -> bool {\n         unsafe {\n             let elem_size = mem::size_of::<T>();\n+            let old_layout = match self.current_layout() {\n+                Some(layout) => layout,\n+                None => return false, // nothing to double\n+            };\n \n             // since we set the capacity to usize::MAX when elem_size is\n             // 0, getting to here necessarily means the RawVec is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            // Since we guarantee that we never allocate more than isize::MAX bytes,\n-            // `elem_size * self.cap <= isize::MAX` as a precondition, so this can't overflow\n+            // Since we guarantee that we never allocate more than isize::MAX\n+            // bytes, `elem_size * self.cap <= isize::MAX` as a precondition, so\n+            // this can't overflow.\n+            //\n+            // Similarly like with `double` above we can go straight to\n+            // `Layout::from_size_align_unchecked` as we know this won't\n+            // overflow and the alignment is sufficiently small.\n             let new_cap = 2 * self.cap;\n-            let new_alloc_size = new_cap * elem_size;\n-\n-            alloc_guard(new_alloc_size);\n-\n+            let new_size = new_cap * elem_size;\n+            alloc_guard(new_size);\n             let ptr = self.ptr() as *mut _;\n-            let old_layout = Layout::new::<T>().repeat(self.cap).unwrap().0;\n-            let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n+            let new_layout = Layout::from_size_align_unchecked(new_size, old_layout.align());\n             match self.a.grow_in_place(ptr, old_layout, new_layout) {\n                 Ok(_) => {\n                     // We can't directly divide `size`.\n@@ -373,8 +405,6 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// Aborts on OOM\n     pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n         unsafe {\n-            let elem_size = mem::size_of::<T>();\n-\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n             // If we make it past the first branch then we are guaranteed to\n@@ -388,21 +418,22 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // Nothing we can really do about these checks :(\n             let new_cap = used_cap.checked_add(needed_extra_cap).expect(\"capacity overflow\");\n-            let new_alloc_size = new_cap.checked_mul(elem_size).expect(\"capacity overflow\");\n-            alloc_guard(new_alloc_size);\n-\n-            let result = if self.cap == 0 {\n-                self.a.alloc_array::<T>(new_cap)\n-            } else {\n-                self.a.realloc_array(self.ptr, self.cap, new_cap)\n+            let new_layout = match Layout::array::<T>(new_cap) {\n+                Some(layout) => layout,\n+                None => panic!(\"capacity overflow\"),\n             };\n-\n-            // If allocate or reallocate fail, we'll get `null` back\n-            let uniq = match result {\n-                Err(err) => self.a.oom(err),\n-                Ok(uniq) => uniq,\n+            alloc_guard(new_layout.size());\n+            let res = match self.current_layout() {\n+                Some(layout) => {\n+                    let old_ptr = self.ptr.as_ptr() as *mut u8;\n+                    self.a.realloc(old_ptr, layout, new_layout)\n+                }\n+                None => self.a.alloc(new_layout),\n+            };\n+            let uniq = match res {\n+                Ok(ptr) => Unique::new_unchecked(ptr as *mut T),\n+                Err(e) => self.a.oom(e),\n             };\n-\n             self.ptr = uniq;\n             self.cap = new_cap;\n         }\n@@ -411,17 +442,14 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// Calculates the buffer's new size given that it'll hold `used_cap +\n     /// needed_extra_cap` elements. This logic is used in amortized reserve methods.\n     /// Returns `(new_capacity, new_alloc_size)`.\n-    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize) -> (usize, usize) {\n-        let elem_size = mem::size_of::<T>();\n+    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize) -> usize {\n         // Nothing we can really do about these checks :(\n         let required_cap = used_cap.checked_add(needed_extra_cap)\n             .expect(\"capacity overflow\");\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n         let double_cap = self.cap * 2;\n         // `double_cap` guarantees exponential growth.\n-        let new_cap = cmp::max(double_cap, required_cap);\n-        let new_alloc_size = new_cap.checked_mul(elem_size).expect(\"capacity overflow\");\n-        (new_cap, new_alloc_size)\n+        cmp::max(double_cap, required_cap)\n     }\n \n     /// Ensures that the buffer contains at least enough space to hold\n@@ -489,21 +517,25 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 return;\n             }\n \n-            let (new_cap, new_alloc_size) = self.amortized_new_size(used_cap, needed_extra_cap);\n-            // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_alloc_size);\n+            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap);\n \n-            let result = if self.cap == 0 {\n-                self.a.alloc_array::<T>(new_cap)\n-            } else {\n-                self.a.realloc_array(self.ptr, self.cap, new_cap)\n+            let new_layout = match Layout::array::<T>(new_cap) {\n+                Some(layout) => layout,\n+                None => panic!(\"capacity overflow\"),\n             };\n-\n-            let uniq = match result {\n-                Err(err) => self.a.oom(err),\n-                Ok(uniq) => uniq,\n+            // FIXME: may crash and burn on over-reserve\n+            alloc_guard(new_layout.size());\n+            let res = match self.current_layout() {\n+                Some(layout) => {\n+                    let old_ptr = self.ptr.as_ptr() as *mut u8;\n+                    self.a.realloc(old_ptr, layout, new_layout)\n+                }\n+                None => self.a.alloc(new_layout),\n+            };\n+            let uniq = match res {\n+                Ok(ptr) => Unique::new_unchecked(ptr as *mut T),\n+                Err(e) => self.a.oom(e),\n             };\n-\n             self.ptr = uniq;\n             self.cap = new_cap;\n         }\n@@ -536,21 +568,24 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // Don't actually need any more capacity. If the current `cap` is 0, we can't\n             // reallocate in place.\n             // Wrapping in case they give a bad `used_cap`\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap || self.cap == 0 {\n+            let old_layout = match self.current_layout() {\n+                Some(layout) => layout,\n+                None => return false,\n+            };\n+            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n                 return false;\n             }\n \n-            let (new_cap, new_alloc_size) = self.amortized_new_size(used_cap, needed_extra_cap);\n-            // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_alloc_size);\n+            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap);\n \n             // Here, `cap < used_cap + needed_extra_cap <= new_cap`\n             // (regardless of whether `self.cap - used_cap` wrapped).\n             // Therefore we can safely call grow_in_place.\n \n             let ptr = self.ptr() as *mut _;\n-            let old_layout = Layout::new::<T>().repeat(self.cap).unwrap().0;\n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n+            // FIXME: may crash and burn on over-reserve\n+            alloc_guard(new_layout.size());\n             match self.a.grow_in_place(ptr, old_layout, new_layout) {\n                 Ok(_) => {\n                     self.cap = new_cap;\n@@ -599,9 +634,24 @@ impl<T, A: Alloc> RawVec<T, A> {\n             }\n         } else if self.cap != amount {\n             unsafe {\n-                match self.a.realloc_array(self.ptr, self.cap, amount) {\n+                // We know here that our `amount` is greater than zero. This\n+                // implies, via the assert above, that capacity is also greater\n+                // than zero, which means that we've got a current layout that\n+                // \"fits\"\n+                //\n+                // We also know that `self.cap` is greater than `amount`, and\n+                // consequently we don't need runtime checks for creating either\n+                // layout\n+                let old_size = elem_size * self.cap;\n+                let new_size = elem_size * amount;\n+                let align = mem::align_of::<T>();\n+                let old_layout = Layout::from_size_align_unchecked(old_size, align);\n+                let new_layout = Layout::from_size_align_unchecked(new_size, align);\n+                match self.a.realloc(self.ptr.as_ptr() as *mut u8,\n+                                     old_layout,\n+                                     new_layout) {\n+                    Ok(p) => self.ptr = Unique::new_unchecked(p as *mut T),\n                     Err(err) => self.a.oom(err),\n-                    Ok(uniq) => self.ptr = uniq,\n                 }\n             }\n             self.cap = amount;\n@@ -631,10 +681,11 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n     pub unsafe fn dealloc_buffer(&mut self) {\n         let elem_size = mem::size_of::<T>();\n-        if elem_size != 0 && self.cap != 0 {\n-            let ptr = self.ptr() as *mut u8;\n-            let layout = Layout::new::<T>().repeat(self.cap).unwrap().0;\n-            self.a.dealloc(ptr, layout);\n+        if elem_size != 0 {\n+            if let Some(layout) = self.current_layout() {\n+                let ptr = self.ptr() as *mut u8;\n+                self.a.dealloc(ptr, layout);\n+            }\n         }\n     }\n }"}, {"sha": "3ed5d2df1aba5c87306ac22f5d019c651dd686f8", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -653,7 +653,7 @@ impl String {\n     /// * `capacity` needs to be the correct value.\n     ///\n     /// Violating these may cause problems like corrupting the allocator's\n-    /// internal datastructures.\n+    /// internal data structures.\n     ///\n     /// The ownership of `ptr` is effectively transferred to the\n     /// `String` which may then deallocate, reallocate or change the"}, {"sha": "5f68e59289d7664b3499c93645b65c95e0e8c258", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -374,7 +374,7 @@ impl<T> Vec<T> {\n     /// * `capacity` needs to be the capacity that the pointer was allocated with.\n     ///\n     /// Violating these may cause problems like corrupting the allocator's\n-    /// internal datastructures. For example it is **not** safe\n+    /// internal data structures. For example it is **not** safe\n     /// to build a `Vec<u8>` from a pointer to a C `char` array and a `size_t`.\n     ///\n     /// The ownership of `ptr` is effectively transferred to the"}, {"sha": "6068f1a79611e4932cb7884acbb9606389a8cb16", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -571,6 +571,59 @@ impl<T> RefCell<T> {\n         debug_assert!(self.borrow.get() == UNUSED);\n         unsafe { self.value.into_inner() }\n     }\n+\n+    /// Replaces the wrapped value with a new one, returning the old value,\n+    /// without deinitializing either one.\n+    ///\n+    /// This function corresponds to [`std::mem::replace`](../mem/fn.replace.html).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(refcell_replace_swap)]\n+    /// use std::cell::RefCell;\n+    /// let c = RefCell::new(5);\n+    /// let u = c.replace(6);\n+    /// assert_eq!(u, 5);\n+    /// assert_eq!(c, RefCell::new(6));\n+    /// ```\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the `RefCell` has any outstanding borrows,\n+    /// whether or not they are full mutable borrows.\n+    #[inline]\n+    #[unstable(feature = \"refcell_replace_swap\", issue=\"43570\")]\n+    pub fn replace(&self, t: T) -> T {\n+        mem::replace(&mut *self.borrow_mut(), t)\n+    }\n+\n+    /// Swaps the wrapped value of `self` with the wrapped value of `other`,\n+    /// without deinitializing either one.\n+    ///\n+    /// This function corresponds to [`std::mem::swap`](../mem/fn.swap.html).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(refcell_replace_swap)]\n+    /// use std::cell::RefCell;\n+    /// let c = RefCell::new(5);\n+    /// let d = RefCell::new(6);\n+    /// c.swap(&d);\n+    /// assert_eq!(c, RefCell::new(6));\n+    /// assert_eq!(d, RefCell::new(5));\n+    /// ```\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if either `RefCell` has any outstanding borrows,\n+    /// whether or not they are full mutable borrows.\n+    #[inline]\n+    #[unstable(feature = \"refcell_replace_swap\", issue=\"43570\")]\n+    pub fn swap(&self, other: &Self) {\n+        mem::swap(&mut *self.borrow_mut(), &mut *other.borrow_mut())\n+    }\n }\n \n impl<T: ?Sized> RefCell<T> {"}, {"sha": "97839844087ce6525b8f405caf0e63a34cfe0cdc", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -1347,7 +1347,6 @@ impl<'a> Formatter<'a> {\n     /// println!(\"{:?}\", Foo { bar: 10, baz: \"Hello World\".to_string() });\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-    #[inline]\n     pub fn debug_struct<'b>(&'b mut self, name: &str) -> DebugStruct<'b, 'a> {\n         builders::debug_struct_new(self, name)\n     }\n@@ -1375,7 +1374,6 @@ impl<'a> Formatter<'a> {\n     /// println!(\"{:?}\", Foo(10, \"Hello World\".to_string()));\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-    #[inline]\n     pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, 'a> {\n         builders::debug_tuple_new(self, name)\n     }\n@@ -1400,7 +1398,6 @@ impl<'a> Formatter<'a> {\n     /// println!(\"{:?}\", Foo(vec![10, 11]));\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-    #[inline]\n     pub fn debug_list<'b>(&'b mut self) -> DebugList<'b, 'a> {\n         builders::debug_list_new(self)\n     }\n@@ -1425,7 +1422,6 @@ impl<'a> Formatter<'a> {\n     /// println!(\"{:?}\", Foo(vec![10, 11]));\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-    #[inline]\n     pub fn debug_set<'b>(&'b mut self) -> DebugSet<'b, 'a> {\n         builders::debug_set_new(self)\n     }\n@@ -1450,7 +1446,6 @@ impl<'a> Formatter<'a> {\n     /// println!(\"{:?}\", Foo(vec![(\"A\".to_string(), 10), (\"B\".to_string(), 11)]));\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n-    #[inline]\n     pub fn debug_map<'b>(&'b mut self) -> DebugMap<'b, 'a> {\n         builders::debug_map_new(self)\n     }"}, {"sha": "ad776c8605ac83cef3dec2ce8194603fa6f1a5f8", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -1044,20 +1044,23 @@ extern \"rust-intrinsic\" {\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n     ///\n-    /// The volatile parameter is set to `true`, so it will not be optimized out.\n+    /// The volatile parameter is set to `true`, so it will not be optimized out\n+    /// unless size is equal to zero.\n     pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T,\n                                                   count: usize);\n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`\n     ///\n-    /// The volatile parameter is set to `true`, so it will not be optimized out.\n+    /// The volatile parameter is set to `true`, so it will not be optimized out\n+    /// unless size is equal to zero..\n     pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count` * `size_of::<T>()` and an alignment of\n     /// `min_align_of::<T>()`.\n     ///\n-    /// The volatile parameter is set to `true`, so it will not be optimized out.\n+    /// The volatile parameter is set to `true`, so it will not be optimized out\n+    /// unless size is equal to zero.\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Perform a volatile load from the `src` pointer."}, {"sha": "22b997a768e6d6f7d5543c2654b3a56601871c11", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -1035,7 +1035,7 @@ unsafe impl<A, B> TrustedLen for Zip<A, B>\n /// Now consider this twist where we add a call to `rev`. This version will\n /// print `('c', 1), ('b', 2), ('a', 3)`. Note that the letters are reversed,\n /// but the values of the counter still go in order. This is because `map()` is\n-/// still being called lazilly on each item, but we are popping items off the\n+/// still being called lazily on each item, but we are popping items off the\n /// back of the vector now, instead of shifting them from the front.\n ///\n /// ```rust"}, {"sha": "19098f036acd2c428308cc85cfddf32246978b96", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -345,7 +345,7 @@ pub trait Extend<A> {\n /// In a similar fashion to the [`Iterator`] protocol, once a\n /// `DoubleEndedIterator` returns `None` from a `next_back()`, calling it again\n /// may or may not ever return `Some` again. `next()` and `next_back()` are\n-/// interchangable for this purpose.\n+/// interchangeable for this purpose.\n ///\n /// [`Iterator`]: trait.Iterator.html\n ///"}, {"sha": "ccf3950c2ba396920c1500aa650af46aa40cf7e6", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -336,7 +336,7 @@ pub fn algorithm_m<T: RawFloat>(f: &Big, e: i16) -> T {\n     round_by_remainder(v, rem, q, z)\n }\n \n-/// Skip over most AlgorithmM iterations by checking the bit length.\n+/// Skip over most Algorithm M iterations by checking the bit length.\n fn quick_start<T: RawFloat>(u: &mut Big, v: &mut Big, k: &mut i16) {\n     // The bit length is an estimate of the base two logarithm, and log(u / v) = log(u) - log(v).\n     // The estimate is off by at most 1, but always an under-estimate, so the error on log(u)"}, {"sha": "62007caedd3fc425f6c50f05f7fb9a71dce18f01", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 120, "deletions": 182, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -10,15 +10,20 @@\n \n /// The addition operator `+`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory. For\n+/// example, [`std::time::SystemTime`] implements `Add<Duration>`, which permits\n+/// operations of the form `SystemTime = SystemTime + Duration`.\n+///\n+/// [`std::time::SystemTime`]: ../../std/time/struct.SystemTime.html\n+///\n /// # Examples\n ///\n-/// This example creates a `Point` struct that implements the `Add` trait, and\n-/// then demonstrates adding two `Point`s.\n+/// ## `Add`able points\n ///\n /// ```\n /// use std::ops::Add;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point {\n ///     x: i32,\n ///     y: i32,\n@@ -35,31 +40,25 @@\n ///     }\n /// }\n ///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n-///                Point { x: 3, y: 3 });\n-/// }\n+/// assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n+///            Point { x: 3, y: 3 });\n /// ```\n ///\n+/// ## Implementing `Add` with generics\n+///\n /// Here is an example of the same `Point` struct implementing the `Add` trait\n /// using generics.\n ///\n /// ```\n /// use std::ops::Add;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point<T> {\n ///     x: T,\n ///     y: T,\n /// }\n ///\n-/// // Notice that the implementation uses the `Output` associated type\n+/// // Notice that the implementation uses the associated type `Output`.\n /// impl<T: Add<Output=T>> Add for Point<T> {\n ///     type Output = Point<T>;\n ///\n@@ -71,32 +70,18 @@\n ///     }\n /// }\n ///\n-/// impl<T: PartialEq> PartialEq for Point<T> {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n-///                Point { x: 3, y: 3 });\n-/// }\n+/// assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n+///            Point { x: 3, y: 3 });\n /// ```\n-///\n-/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n-/// [std::time::SystemTime] implements `Add<Duration>`, which permits\n-/// operations of the form `SystemTime = SystemTime + Duration`.\n-///\n-/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n #[lang = \"add\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} + {RHS}`\"]\n pub trait Add<RHS=Self> {\n-    /// The resulting type after applying the `+` operator\n+    /// The resulting type after applying the `+` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `+` operator\n+    /// Performs the `+` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn add(self, rhs: RHS) -> Self::Output;\n }\n@@ -120,15 +105,20 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n /// The subtraction operator `-`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory. For\n+/// example, [`std::time::SystemTime`] implements `Sub<Duration>`, which permits\n+/// operations of the form `SystemTime = SystemTime - Duration`.\n+///\n+/// [`std::time::SystemTime`]: ../../std/time/struct.SystemTime.html\n+///\n /// # Examples\n ///\n-/// This example creates a `Point` struct that implements the `Sub` trait, and\n-/// then demonstrates subtracting two `Point`s.\n+/// ## `Sub`tractable points\n ///\n /// ```\n /// use std::ops::Sub;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point {\n ///     x: i32,\n ///     y: i32,\n@@ -145,31 +135,25 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     }\n /// }\n ///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 3, y: 3 } - Point { x: 2, y: 3 },\n-///                Point { x: 1, y: 0 });\n-/// }\n+/// assert_eq!(Point { x: 3, y: 3 } - Point { x: 2, y: 3 },\n+///            Point { x: 1, y: 0 });\n /// ```\n ///\n+/// ## Implementing `Sub` with generics\n+///\n /// Here is an example of the same `Point` struct implementing the `Sub` trait\n /// using generics.\n ///\n /// ```\n /// use std::ops::Sub;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point<T> {\n ///     x: T,\n ///     y: T,\n /// }\n ///\n-/// // Notice that the implementation uses the `Output` associated type\n+/// // Notice that the implementation uses the associated type `Output`.\n /// impl<T: Sub<Output=T>> Sub for Point<T> {\n ///     type Output = Point<T>;\n ///\n@@ -181,32 +165,18 @@ add_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     }\n /// }\n ///\n-/// impl<T: PartialEq> PartialEq for Point<T> {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n-/// fn main() {\n-///     assert_eq!(Point { x: 2, y: 3 } - Point { x: 1, y: 0 },\n-///                Point { x: 1, y: 3 });\n-/// }\n+/// assert_eq!(Point { x: 2, y: 3 } - Point { x: 1, y: 0 },\n+///            Point { x: 1, y: 3 });\n /// ```\n-///\n-/// Note that `RHS = Self` by default, but this is not mandatory. For example,\n-/// [std::time::SystemTime] implements `Sub<Duration>`, which permits\n-/// operations of the form `SystemTime = SystemTime - Duration`.\n-///\n-/// [std::time::SystemTime]: ../../std/time/struct.SystemTime.html\n #[lang = \"sub\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} - {RHS}`\"]\n pub trait Sub<RHS=Self> {\n-    /// The resulting type after applying the `-` operator\n+    /// The resulting type after applying the `-` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `-` operator\n+    /// Performs the `-` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn sub(self, rhs: RHS) -> Self::Output;\n }\n@@ -230,17 +200,19 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n /// The multiplication operator `*`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n-/// Implementing a `Mul`tipliable rational number struct:\n+/// ## `Mul`tipliable rational numbers\n ///\n /// ```\n /// use std::ops::Mul;\n ///\n-/// // The uniqueness of rational numbers in lowest terms is a consequence of\n-/// // the fundamental theorem of arithmetic.\n-/// #[derive(Eq)]\n-/// #[derive(PartialEq, Debug)]\n+/// // By the fundamental theorem of arithmetic, rational numbers in lowest\n+/// // terms are unique. So, by keeping `Rational`s in reduced form, we can\n+/// // derive `Eq` and `PartialEq`.\n+/// #[derive(Debug, Eq, PartialEq)]\n /// struct Rational {\n ///     nominator: usize,\n ///     denominator: usize,\n@@ -291,45 +263,37 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///            Rational::new(1, 2));\n /// ```\n ///\n-/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n-/// implementation which enables multiplication of vectors by scalars, as is\n-/// done in linear algebra.\n+/// ## Multiplying vectors by scalars as in linear algebra\n ///\n /// ```\n /// use std::ops::Mul;\n ///\n-/// struct Scalar {value: usize};\n+/// struct Scalar { value: usize }\n ///\n-/// #[derive(Debug)]\n-/// struct Vector {value: Vec<usize>};\n+/// #[derive(Debug, PartialEq)]\n+/// struct Vector { value: Vec<usize> }\n ///\n-/// impl Mul<Vector> for Scalar {\n+/// impl Mul<Scalar> for Vector {\n ///     type Output = Vector;\n ///\n-///     fn mul(self, rhs: Vector) -> Vector {\n-///         Vector {value: rhs.value.iter().map(|v| self.value * v).collect()}\n+///     fn mul(self, rhs: Scalar) -> Vector {\n+///         Vector { value: self.value.iter().map(|v| v * rhs.value).collect() }\n ///     }\n /// }\n ///\n-/// impl PartialEq<Vector> for Vector {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.value == other.value\n-///     }\n-/// }\n-///\n-/// let scalar = Scalar{value: 3};\n-/// let vector = Vector{value: vec![2, 4, 6]};\n-/// assert_eq!(scalar * vector, Vector{value: vec![6, 12, 18]});\n+/// let vector = Vector { value: vec![2, 4, 6] };\n+/// let scalar = Scalar { value: 3 };\n+/// assert_eq!(vector * scalar, Vector { value: vec![6, 12, 18] });\n /// ```\n #[lang = \"mul\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} * {RHS}`\"]\n pub trait Mul<RHS=Self> {\n-    /// The resulting type after applying the `*` operator\n+    /// The resulting type after applying the `*` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `*` operator\n+    /// Performs the `*` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn mul(self, rhs: RHS) -> Self::Output;\n }\n@@ -353,17 +317,19 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n \n /// The division operator `/`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n-/// Implementing a `Div`idable rational number struct:\n+/// ## `Div`idable rational numbers\n ///\n /// ```\n /// use std::ops::Div;\n ///\n-/// // The uniqueness of rational numbers in lowest terms is a consequence of\n-/// // the fundamental theorem of arithmetic.\n-/// #[derive(Eq)]\n-/// #[derive(PartialEq, Debug)]\n+/// // By the fundamental theorem of arithmetic, rational numbers in lowest\n+/// // terms are unique. So, by keeping `Rational`s in reduced form, we can\n+/// // derive `Eq` and `PartialEq`.\n+/// #[derive(Debug, Eq, PartialEq)]\n /// struct Rational {\n ///     nominator: usize,\n ///     denominator: usize,\n@@ -413,52 +379,42 @@ mul_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     x\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n-///     assert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n-///                Rational::new(2, 3));\n-/// }\n+/// assert_eq!(Rational::new(1, 2), Rational::new(2, 4));\n+/// assert_eq!(Rational::new(1, 2) / Rational::new(3, 4),\n+///            Rational::new(2, 3));\n /// ```\n ///\n-/// Note that `RHS = Self` by default, but this is not mandatory. Here is an\n-/// implementation which enables division of vectors by scalars, as is done in\n-/// linear algebra.\n+/// ## Dividing vectors by scalars as in linear algebra\n ///\n /// ```\n /// use std::ops::Div;\n ///\n-/// struct Scalar {value: f32};\n+/// struct Scalar { value: f32 }\n ///\n-/// #[derive(Debug)]\n-/// struct Vector {value: Vec<f32>};\n+/// #[derive(Debug, PartialEq)]\n+/// struct Vector { value: Vec<f32> }\n ///\n /// impl Div<Scalar> for Vector {\n ///     type Output = Vector;\n ///\n ///     fn div(self, rhs: Scalar) -> Vector {\n-///         Vector {value: self.value.iter().map(|v| v / rhs.value).collect()}\n-///     }\n-/// }\n-///\n-/// impl PartialEq<Vector> for Vector {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.value == other.value\n+///         Vector { value: self.value.iter().map(|v| v / rhs.value).collect() }\n ///     }\n /// }\n ///\n-/// let scalar = Scalar{value: 2f32};\n-/// let vector = Vector{value: vec![2f32, 4f32, 6f32]};\n-/// assert_eq!(vector / scalar, Vector{value: vec![1f32, 2f32, 3f32]});\n+/// let scalar = Scalar { value: 2f32 };\n+/// let vector = Vector { value: vec![2f32, 4f32, 6f32] };\n+/// assert_eq!(vector / scalar, Vector { value: vec![1f32, 2f32, 3f32] });\n /// ```\n #[lang = \"div\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} / {RHS}`\"]\n pub trait Div<RHS=Self> {\n-    /// The resulting type after applying the `/` operator\n+    /// The resulting type after applying the `/` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `/` operator\n+    /// Performs the `/` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn div(self, rhs: RHS) -> Self::Output;\n }\n@@ -499,6 +455,8 @@ div_impl_float! { f32 f64 }\n \n /// The remainder operator `%`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n /// This example implements `Rem` on a `SplitSlice` object. After `Rem` is\n@@ -526,19 +484,19 @@ div_impl_float! { f32 f64 }\n /// }\n ///\n /// // If we were to divide &[0, 1, 2, 3, 4, 5, 6, 7] into slices of size 3,\n-/// // the remainder would be &[6, 7]\n+/// // the remainder would be &[6, 7].\n /// assert_eq!(SplitSlice { slice: &[0, 1, 2, 3, 4, 5, 6, 7] } % 3,\n ///            SplitSlice { slice: &[6, 7] });\n /// ```\n #[lang = \"rem\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} % {RHS}`\"]\n pub trait Rem<RHS=Self> {\n-    /// The resulting type after applying the `%` operator\n+    /// The resulting type after applying the `%` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output = Self;\n \n-    /// The method for the `%` operator\n+    /// Performs the `%` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rem(self, rhs: RHS) -> Self::Output;\n }\n@@ -607,21 +565,21 @@ rem_impl_float! { f32 f64 }\n ///     }\n /// }\n ///\n-/// // a negative positive is a negative\n+/// // A negative positive is a negative.\n /// assert_eq!(-Sign::Positive, Sign::Negative);\n-/// // a double negative is a positive\n+/// // A double negative is a positive.\n /// assert_eq!(-Sign::Negative, Sign::Positive);\n-/// // zero is its own negation\n+/// // Zero is its own negation.\n /// assert_eq!(-Sign::Zero, Sign::Zero);\n /// ```\n #[lang = \"neg\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Neg {\n-    /// The resulting type after applying the `-` operator\n+    /// The resulting type after applying the `-` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the unary `-` operator\n+    /// Performs the unary `-` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn neg(self) -> Self::Output;\n }\n@@ -668,7 +626,7 @@ neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n /// use std::ops::AddAssign;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point {\n ///     x: i32,\n ///     y: i32,\n@@ -683,12 +641,6 @@ neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n ///     }\n /// }\n ///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n /// let mut point = Point { x: 1, y: 0 };\n /// point += Point { x: 2, y: 3 };\n /// assert_eq!(point, Point { x: 3, y: 3 });\n@@ -697,7 +649,7 @@ neg_impl_numeric! { isize i8 i16 i32 i64 i128 f32 f64 }\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} += {Rhs}`\"]\n pub trait AddAssign<Rhs=Self> {\n-    /// The method for the `+=` operator\n+    /// Performs the `+=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn add_assign(&mut self, rhs: Rhs);\n }\n@@ -725,7 +677,7 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n /// ```\n /// use std::ops::SubAssign;\n ///\n-/// #[derive(Debug)]\n+/// #[derive(Debug, PartialEq)]\n /// struct Point {\n ///     x: i32,\n ///     y: i32,\n@@ -740,12 +692,6 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///     }\n /// }\n ///\n-/// impl PartialEq for Point {\n-///     fn eq(&self, other: &Self) -> bool {\n-///         self.x == other.x && self.y == other.y\n-///     }\n-/// }\n-///\n /// let mut point = Point { x: 3, y: 3 };\n /// point -= Point { x: 2, y: 3 };\n /// assert_eq!(point, Point {x: 1, y: 0});\n@@ -754,7 +700,7 @@ add_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} -= {Rhs}`\"]\n pub trait SubAssign<Rhs=Self> {\n-    /// The method for the `-=` operator\n+    /// Performs the `-=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn sub_assign(&mut self, rhs: Rhs);\n }\n@@ -776,31 +722,27 @@ sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `MulAssign`. When `Foo *= Foo` happens, it ends up\n-/// calling `mul_assign`, and therefore, `main` prints `Multiplying!`.\n-///\n /// ```\n /// use std::ops::MulAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Frequency { hertz: f64 }\n ///\n-/// impl MulAssign for Foo {\n-///     fn mul_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Multiplying!\");\n+/// impl MulAssign<f64> for Frequency {\n+///     fn mul_assign(&mut self, rhs: f64) {\n+///         self.hertz *= rhs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo *= Foo;\n-/// }\n+/// let mut frequency = Frequency { hertz: 50.0 };\n+/// frequency *= 4.0;\n+/// assert_eq!(Frequency { hertz: 200.0 }, frequency);\n /// ```\n #[lang = \"mul_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} *= {Rhs}`\"]\n pub trait MulAssign<Rhs=Self> {\n-    /// The method for the `*=` operator\n+    /// Performs the `*=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn mul_assign(&mut self, rhs: Rhs);\n }\n@@ -822,31 +764,27 @@ mul_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `DivAssign`. When `Foo /= Foo` happens, it ends up\n-/// calling `div_assign`, and therefore, `main` prints `Dividing!`.\n-///\n /// ```\n /// use std::ops::DivAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Frequency { hertz: f64 }\n ///\n-/// impl DivAssign for Foo {\n-///     fn div_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Dividing!\");\n+/// impl DivAssign<f64> for Frequency {\n+///     fn div_assign(&mut self, rhs: f64) {\n+///         self.hertz /= rhs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo /= Foo;\n-/// }\n+/// let mut frequency = Frequency { hertz: 200.0 };\n+/// frequency /= 4.0;\n+/// assert_eq!(Frequency { hertz: 50.0 }, frequency);\n /// ```\n #[lang = \"div_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} /= {Rhs}`\"]\n pub trait DivAssign<Rhs=Self> {\n-    /// The method for the `/=` operator\n+    /// Performs the `/=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn div_assign(&mut self, rhs: Rhs);\n }\n@@ -867,31 +805,31 @@ div_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `RemAssign`. When `Foo %= Foo` happens, it ends up\n-/// calling `rem_assign`, and therefore, `main` prints `Remainder-ing!`.\n-///\n /// ```\n /// use std::ops::RemAssign;\n ///\n-/// struct Foo;\n+/// struct CookieJar { cookies: u32 }\n ///\n-/// impl RemAssign for Foo {\n-///     fn rem_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Remainder-ing!\");\n+/// impl RemAssign<u32> for CookieJar {\n+///     fn rem_assign(&mut self, piles: u32) {\n+///         self.cookies %= piles;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo %= Foo;\n-/// }\n+/// let mut jar = CookieJar { cookies: 31 };\n+/// let piles = 4;\n+///\n+/// println!(\"Splitting up {} cookies into {} even piles!\", jar.cookies, piles);\n+///\n+/// jar %= piles;\n+///\n+/// println!(\"{} cookies remain in the cookie jar!\", jar.cookies);\n /// ```\n #[lang = \"rem_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} %= {Rhs}`\"]\n pub trait RemAssign<Rhs=Self> {\n-    /// The method for the `%=` operator\n+    /// Performs the `%=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn rem_assign(&mut self, rhs: Rhs);\n }"}, {"sha": "0bc5e554cb347d7cf2c3e76a94f21b685bf4a5a3", "filename": "src/libcore/ops/bit.rs", "status": "modified", "additions": 128, "deletions": 150, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -41,11 +41,11 @@\n #[lang = \"not\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Not {\n-    /// The resulting type after applying the `!` operator\n+    /// The resulting type after applying the `!` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the unary `!` operator\n+    /// Performs the unary `!` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn not(self) -> Self::Output;\n }\n@@ -68,9 +68,11 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n /// The bitwise AND operator `&`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n-/// In this example, the `&` operator is lifted to a trivial `Scalar` type.\n+/// An implementation of `BitAnd` for a wrapper around `bool`.\n ///\n /// ```\n /// use std::ops::BitAnd;\n@@ -87,16 +89,13 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(Scalar(true) & Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(true) & Scalar(false), Scalar(false));\n-///     assert_eq!(Scalar(false) & Scalar(true), Scalar(false));\n-///     assert_eq!(Scalar(false) & Scalar(false), Scalar(false));\n-/// }\n+/// assert_eq!(Scalar(true) & Scalar(true), Scalar(true));\n+/// assert_eq!(Scalar(true) & Scalar(false), Scalar(false));\n+/// assert_eq!(Scalar(false) & Scalar(true), Scalar(false));\n+/// assert_eq!(Scalar(false) & Scalar(false), Scalar(false));\n /// ```\n ///\n-/// In this example, the `BitAnd` trait is implemented for a `BooleanVector`\n-/// struct.\n+/// An implementation of `BitAnd` for a wrapper around `Vec<bool>`.\n ///\n /// ```\n /// use std::ops::BitAnd;\n@@ -114,22 +113,20 @@ not_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let bv1 = BooleanVector(vec![true, true, false, false]);\n-///     let bv2 = BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![true, false, false, false]);\n-///     assert_eq!(bv1 & bv2, expected);\n-/// }\n+/// let bv1 = BooleanVector(vec![true, true, false, false]);\n+/// let bv2 = BooleanVector(vec![true, false, true, false]);\n+/// let expected = BooleanVector(vec![true, false, false, false]);\n+/// assert_eq!(bv1 & bv2, expected);\n /// ```\n #[lang = \"bitand\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} & {RHS}`\"]\n pub trait BitAnd<RHS=Self> {\n-    /// The resulting type after applying the `&` operator\n+    /// The resulting type after applying the `&` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `&` operator\n+    /// Performs the `&` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitand(self, rhs: RHS) -> Self::Output;\n }\n@@ -152,9 +149,11 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n /// The bitwise OR operator `|`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n-/// In this example, the `|` operator is lifted to a trivial `Scalar` type.\n+/// An implementation of `BitOr` for a wrapper around `bool`.\n ///\n /// ```\n /// use std::ops::BitOr;\n@@ -171,16 +170,13 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(Scalar(true) | Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(true) | Scalar(false), Scalar(true));\n-///     assert_eq!(Scalar(false) | Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(false) | Scalar(false), Scalar(false));\n-/// }\n+/// assert_eq!(Scalar(true) | Scalar(true), Scalar(true));\n+/// assert_eq!(Scalar(true) | Scalar(false), Scalar(true));\n+/// assert_eq!(Scalar(false) | Scalar(true), Scalar(true));\n+/// assert_eq!(Scalar(false) | Scalar(false), Scalar(false));\n /// ```\n ///\n-/// In this example, the `BitOr` trait is implemented for a `BooleanVector`\n-/// struct.\n+/// An implementation of `BitOr` for a wrapper around `Vec<bool>`.\n ///\n /// ```\n /// use std::ops::BitOr;\n@@ -198,22 +194,20 @@ bitand_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let bv1 = BooleanVector(vec![true, true, false, false]);\n-///     let bv2 = BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![true, true, true, false]);\n-///     assert_eq!(bv1 | bv2, expected);\n-/// }\n+/// let bv1 = BooleanVector(vec![true, true, false, false]);\n+/// let bv2 = BooleanVector(vec![true, false, true, false]);\n+/// let expected = BooleanVector(vec![true, true, true, false]);\n+/// assert_eq!(bv1 | bv2, expected);\n /// ```\n #[lang = \"bitor\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} | {RHS}`\"]\n pub trait BitOr<RHS=Self> {\n-    /// The resulting type after applying the `|` operator\n+    /// The resulting type after applying the `|` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `|` operator\n+    /// Performs the `|` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitor(self, rhs: RHS) -> Self::Output;\n }\n@@ -236,9 +230,11 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n \n /// The bitwise XOR operator `^`.\n ///\n+/// Note that `RHS` is `Self` by default, but this is not mandatory.\n+///\n /// # Examples\n ///\n-/// In this example, the `^` operator is lifted to a trivial `Scalar` type.\n+/// An implementation of `BitXor` that lifts `^` to a wrapper around `bool`.\n ///\n /// ```\n /// use std::ops::BitXor;\n@@ -255,16 +251,13 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(Scalar(true) ^ Scalar(true), Scalar(false));\n-///     assert_eq!(Scalar(true) ^ Scalar(false), Scalar(true));\n-///     assert_eq!(Scalar(false) ^ Scalar(true), Scalar(true));\n-///     assert_eq!(Scalar(false) ^ Scalar(false), Scalar(false));\n-/// }\n+/// assert_eq!(Scalar(true) ^ Scalar(true), Scalar(false));\n+/// assert_eq!(Scalar(true) ^ Scalar(false), Scalar(true));\n+/// assert_eq!(Scalar(false) ^ Scalar(true), Scalar(true));\n+/// assert_eq!(Scalar(false) ^ Scalar(false), Scalar(false));\n /// ```\n ///\n-/// In this example, the `BitXor` trait is implemented for a `BooleanVector`\n-/// struct.\n+/// An implementation of `BitXor` trait for a wrapper around `Vec<bool>`.\n ///\n /// ```\n /// use std::ops::BitXor;\n@@ -285,22 +278,20 @@ bitor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let bv1 = BooleanVector(vec![true, true, false, false]);\n-///     let bv2 = BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![false, true, true, false]);\n-///     assert_eq!(bv1 ^ bv2, expected);\n-/// }\n+/// let bv1 = BooleanVector(vec![true, true, false, false]);\n+/// let bv2 = BooleanVector(vec![true, false, true, false]);\n+/// let expected = BooleanVector(vec![false, true, true, false]);\n+/// assert_eq!(bv1 ^ bv2, expected);\n /// ```\n #[lang = \"bitxor\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} ^ {RHS}`\"]\n pub trait BitXor<RHS=Self> {\n-    /// The resulting type after applying the `^` operator\n+    /// The resulting type after applying the `^` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `^` operator\n+    /// Performs the `^` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bitxor(self, rhs: RHS) -> Self::Output;\n }\n@@ -326,7 +317,7 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n /// # Examples\n ///\n /// An implementation of `Shl` that lifts the `<<` operation on integers to a\n-/// `Scalar` struct.\n+/// wrapper around `usize`.\n ///\n /// ```\n /// use std::ops::Shl;\n@@ -342,9 +333,8 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///         Scalar(lhs << rhs)\n ///     }\n /// }\n-/// fn main() {\n-///     assert_eq!(Scalar(4) << Scalar(2), Scalar(16));\n-/// }\n+///\n+/// assert_eq!(Scalar(4) << Scalar(2), Scalar(16));\n /// ```\n ///\n /// An implementation of `Shl` that spins a vector leftward by a given amount.\n@@ -361,7 +351,7 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     type Output = Self;\n ///\n ///     fn shl(self, rhs: usize) -> SpinVector<T> {\n-///         // rotate the vector by `rhs` places\n+///         // Rotate the vector by `rhs` places.\n ///         let (a, b) = self.vec.split_at(rhs);\n ///         let mut spun_vector: Vec<T> = vec![];\n ///         spun_vector.extend_from_slice(b);\n@@ -370,20 +360,18 @@ bitxor_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } << 2,\n-///                SpinVector { vec: vec![2, 3, 4, 0, 1] });\n-/// }\n+/// assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } << 2,\n+///            SpinVector { vec: vec![2, 3, 4, 0, 1] });\n /// ```\n #[lang = \"shl\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} << {RHS}`\"]\n pub trait Shl<RHS> {\n-    /// The resulting type after applying the `<<` operator\n+    /// The resulting type after applying the `<<` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `<<` operator\n+    /// Performs the `<<` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shl(self, rhs: RHS) -> Self::Output;\n }\n@@ -430,7 +418,7 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n /// # Examples\n ///\n /// An implementation of `Shr` that lifts the `>>` operation on integers to a\n-/// `Scalar` struct.\n+/// wrapper around `usize`.\n ///\n /// ```\n /// use std::ops::Shr;\n@@ -446,9 +434,8 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n ///         Scalar(lhs >> rhs)\n ///     }\n /// }\n-/// fn main() {\n-///     assert_eq!(Scalar(16) >> Scalar(2), Scalar(4));\n-/// }\n+///\n+/// assert_eq!(Scalar(16) >> Scalar(2), Scalar(4));\n /// ```\n ///\n /// An implementation of `Shr` that spins a vector rightward by a given amount.\n@@ -465,7 +452,7 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n ///     type Output = Self;\n ///\n ///     fn shr(self, rhs: usize) -> SpinVector<T> {\n-///         // rotate the vector by `rhs` places\n+///         // Rotate the vector by `rhs` places.\n ///         let (a, b) = self.vec.split_at(self.vec.len() - rhs);\n ///         let mut spun_vector: Vec<T> = vec![];\n ///         spun_vector.extend_from_slice(b);\n@@ -474,20 +461,18 @@ shl_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 isize i128 }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } >> 2,\n-///                SpinVector { vec: vec![3, 4, 0, 1, 2] });\n-/// }\n+/// assert_eq!(SpinVector { vec: vec![0, 1, 2, 3, 4] } >> 2,\n+///            SpinVector { vec: vec![3, 4, 0, 1, 2] });\n /// ```\n #[lang = \"shr\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} >> {RHS}`\"]\n pub trait Shr<RHS> {\n-    /// The resulting type after applying the `>>` operator\n+    /// The resulting type after applying the `>>` operator.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output;\n \n-    /// The method for the `>>` operator\n+    /// Performs the `>>` operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn shr(self, rhs: RHS) -> Self::Output;\n }\n@@ -533,7 +518,8 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n ///\n /// # Examples\n ///\n-/// In this example, the `&=` operator is lifted to a trivial `Scalar` type.\n+/// An implementation of `BitAndAssign` that lifts the `&=` operator to a\n+/// wrapper around `bool`.\n ///\n /// ```\n /// use std::ops::BitAndAssign;\n@@ -548,27 +534,25 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let mut scalar = Scalar(true);\n-///     scalar &= Scalar(true);\n-///     assert_eq!(scalar, Scalar(true));\n+/// let mut scalar = Scalar(true);\n+/// scalar &= Scalar(true);\n+/// assert_eq!(scalar, Scalar(true));\n ///\n-///     let mut scalar = Scalar(true);\n-///     scalar &= Scalar(false);\n-///     assert_eq!(scalar, Scalar(false));\n+/// let mut scalar = Scalar(true);\n+/// scalar &= Scalar(false);\n+/// assert_eq!(scalar, Scalar(false));\n ///\n-///     let mut scalar = Scalar(false);\n-///     scalar &= Scalar(true);\n-///     assert_eq!(scalar, Scalar(false));\n+/// let mut scalar = Scalar(false);\n+/// scalar &= Scalar(true);\n+/// assert_eq!(scalar, Scalar(false));\n ///\n-///     let mut scalar = Scalar(false);\n-///     scalar &= Scalar(false);\n-///     assert_eq!(scalar, Scalar(false));\n-/// }\n+/// let mut scalar = Scalar(false);\n+/// scalar &= Scalar(false);\n+/// assert_eq!(scalar, Scalar(false));\n /// ```\n ///\n-/// In this example, the `BitAndAssign` trait is implemented for a\n-/// `BooleanVector` struct.\n+/// Here, the `BitAndAssign` trait is implemented for a wrapper around\n+/// `Vec<bool>`.\n ///\n /// ```\n /// use std::ops::BitAndAssign;\n@@ -577,7 +561,7 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n /// struct BooleanVector(Vec<bool>);\n ///\n /// impl BitAndAssign for BooleanVector {\n-///     // rhs is the \"right-hand side\" of the expression `a &= b`\n+///     // `rhs` is the \"right-hand side\" of the expression `a &= b`.\n ///     fn bitand_assign(&mut self, rhs: Self) {\n ///         assert_eq!(self.0.len(), rhs.0.len());\n ///         *self = BooleanVector(self.0\n@@ -588,18 +572,16 @@ shr_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let mut bv = BooleanVector(vec![true, true, false, false]);\n-///     bv &= BooleanVector(vec![true, false, true, false]);\n-///     let expected = BooleanVector(vec![true, false, false, false]);\n-///     assert_eq!(bv, expected);\n-/// }\n+/// let mut bv = BooleanVector(vec![true, true, false, false]);\n+/// bv &= BooleanVector(vec![true, false, true, false]);\n+/// let expected = BooleanVector(vec![true, false, false, false]);\n+/// assert_eq!(bv, expected);\n /// ```\n #[lang = \"bitand_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} &= {Rhs}`\"]\n pub trait BitAndAssign<Rhs=Self> {\n-    /// The method for the `&=` operator\n+    /// Performs the `&=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitand_assign(&mut self, rhs: Rhs);\n }\n@@ -620,31 +602,31 @@ bitand_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `BitOrAssign`. When `Foo |= Foo` happens, it ends up\n-/// calling `bitor_assign`, and therefore, `main` prints `Bitwise Or-ing!`.\n-///\n /// ```\n /// use std::ops::BitOrAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct PersonalPreferences {\n+///     likes_cats: bool,\n+///     likes_dogs: bool,\n+/// }\n ///\n-/// impl BitOrAssign for Foo {\n-///     fn bitor_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Bitwise Or-ing!\");\n+/// impl BitOrAssign for PersonalPreferences {\n+///     fn bitor_assign(&mut self, rhs: Self) {\n+///         self.likes_cats |= rhs.likes_cats;\n+///         self.likes_dogs |= rhs.likes_dogs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo |= Foo;\n-/// }\n+/// let mut prefs = PersonalPreferences { likes_cats: true, likes_dogs: false };\n+/// prefs |= PersonalPreferences { likes_cats: false, likes_dogs: true };\n+/// assert_eq!(prefs, PersonalPreferences { likes_cats: true, likes_dogs: true });\n /// ```\n #[lang = \"bitor_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} |= {Rhs}`\"]\n pub trait BitOrAssign<Rhs=Self> {\n-    /// The method for the `|=` operator\n+    /// Performs the `|=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitor_assign(&mut self, rhs: Rhs);\n }\n@@ -665,31 +647,31 @@ bitor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `BitXorAssign`. When `Foo ^= Foo` happens, it ends up\n-/// calling `bitxor_assign`, and therefore, `main` prints `Bitwise Xor-ing!`.\n-///\n /// ```\n /// use std::ops::BitXorAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Personality {\n+///     has_soul: bool,\n+///     likes_knitting: bool,\n+/// }\n ///\n-/// impl BitXorAssign for Foo {\n-///     fn bitxor_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Bitwise Xor-ing!\");\n+/// impl BitXorAssign for Personality {\n+///     fn bitxor_assign(&mut self, rhs: Self) {\n+///         self.has_soul ^= rhs.has_soul;\n+///         self.likes_knitting ^= rhs.likes_knitting;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo ^= Foo;\n-/// }\n+/// let mut personality = Personality { has_soul: false, likes_knitting: true };\n+/// personality ^= Personality { has_soul: true, likes_knitting: true };\n+/// assert_eq!(personality, Personality { has_soul: true, likes_knitting: false});\n /// ```\n #[lang = \"bitxor_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} ^= {Rhs}`\"]\n pub trait BitXorAssign<Rhs=Self> {\n-    /// The method for the `^=` operator\n+    /// Performs the `^=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn bitxor_assign(&mut self, rhs: Rhs);\n }\n@@ -710,31 +692,29 @@ bitxor_assign_impl! { bool usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `ShlAssign`. When `Foo <<= Foo` happens, it ends up\n-/// calling `shl_assign`, and therefore, `main` prints `Shifting left!`.\n+/// An implementation of `ShlAssign` for a wrapper around `usize`.\n ///\n /// ```\n /// use std::ops::ShlAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(usize);\n ///\n-/// impl ShlAssign<Foo> for Foo {\n-///     fn shl_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Shifting left!\");\n+/// impl ShlAssign<usize> for Scalar {\n+///     fn shl_assign(&mut self, rhs: usize) {\n+///         self.0 <<= rhs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo <<= Foo;\n-/// }\n+/// let mut scalar = Scalar(4);\n+/// scalar <<= 2;\n+/// assert_eq!(scalar, Scalar(16));\n /// ```\n #[lang = \"shl_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} <<= {Rhs}`\"]\n pub trait ShlAssign<Rhs> {\n-    /// The method for the `<<=` operator\n+    /// Performs the `<<=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn shl_assign(&mut self, rhs: Rhs);\n }\n@@ -776,31 +756,29 @@ shl_assign_impl_all! { u8 u16 u32 u64 u128 usize i8 i16 i32 i64 i128 isize }\n ///\n /// # Examples\n ///\n-/// A trivial implementation of `ShrAssign`. When `Foo >>= Foo` happens, it ends up\n-/// calling `shr_assign`, and therefore, `main` prints `Shifting right!`.\n+/// An implementation of `ShrAssign` for a wrapper around `usize`.\n ///\n /// ```\n /// use std::ops::ShrAssign;\n ///\n-/// struct Foo;\n+/// #[derive(Debug, PartialEq)]\n+/// struct Scalar(usize);\n ///\n-/// impl ShrAssign<Foo> for Foo {\n-///     fn shr_assign(&mut self, _rhs: Foo) {\n-///         println!(\"Shifting right!\");\n+/// impl ShrAssign<usize> for Scalar {\n+///     fn shr_assign(&mut self, rhs: usize) {\n+///         self.0 >>= rhs;\n ///     }\n /// }\n ///\n-/// # #[allow(unused_assignments)]\n-/// fn main() {\n-///     let mut foo = Foo;\n-///     foo >>= Foo;\n-/// }\n+/// let mut scalar = Scalar(16);\n+/// scalar >>= 2;\n+/// assert_eq!(scalar, Scalar(4));\n /// ```\n #[lang = \"shr_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented = \"no implementation for `{Self} >>= {Rhs}`\"]\n pub trait ShrAssign<Rhs=Self> {\n-    /// The method for the `>>=` operator\n+    /// Performs the `>>=` operation.\n     #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n     fn shr_assign(&mut self, rhs: Rhs);\n }"}, {"sha": "a2e7c44cb249fd08f6f36942133c0ecb469d8168", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 78, "deletions": 24, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -8,16 +8,44 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// The `Deref` trait is used to specify the functionality of dereferencing\n-/// operations, like `*v`.\n+/// Used for immutable dereferencing operations, like `*v`.\n ///\n-/// `Deref` also enables ['`Deref` coercions'][coercions].\n+/// In addition to being used for explicit dereferencing operations with the\n+/// (unary) `*` operator in immutable contexts, `Deref` is also used implicitly\n+/// by the compiler in many circumstances. This mechanism is called\n+/// ['`Deref` coercion'][more]. In mutable contexts, [`DerefMut`] is used.\n ///\n-/// [coercions]: ../../book/first-edition/deref-coercions.html\n+/// Implementing `Deref` for smart pointers makes accessing the data behind them\n+/// convenient, which is why they implement `Deref`. On the other hand, the\n+/// rules regarding `Deref` and [`DerefMut`] were designed specifically to\n+/// accomodate smart pointers. Because of this, **`Deref` should only be\n+/// implemented for smart pointers** to avoid confusion.\n+///\n+/// For similar reasons, **this trait should never fail**. Failure during\n+/// dereferencing can be extremely confusing when `Deref` is invoked implicitly.\n+///\n+/// # More on `Deref` coercion\n+///\n+/// If `T` implements `Deref<Target = U>`, and `x` is a value of type `T`, then:\n+/// * In immutable contexts, `*x` on non-pointer types is equivalent to\n+///   `*Deref::deref(&x)`.\n+/// * Values of type `&T` are coerced to values of type `&U`\n+/// * `T` implicitly implements all the (immutable) methods of the type `U`.\n+///\n+/// For more details, visit [the chapter in *The Rust Programming Language*]\n+/// [book] as well as the reference sections on [the dereference operator]\n+/// [ref-deref-op], [the `Deref` trait][ref-deref-trait], and [type coercions].\n+///\n+/// [book]: ../../book/second-edition/ch15-02-deref.html\n+/// [`DerefMut`]: trait.DerefMut.html\n+/// [more]: #more-on-deref-coercion\n+/// [ref-deref-op]: ../../reference/expressions.html#the-dereference-operator\n+/// [ref-deref-trait]: ../../reference/the-deref-trait.html\n+/// [type coercions]: ../../reference/type-coercions.html\n ///\n /// # Examples\n ///\n-/// A struct with a single field which is accessible via dereferencing the\n+/// A struct with a single field which is accessible by dereferencing the\n /// struct.\n ///\n /// ```\n@@ -35,19 +63,17 @@\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let x = DerefExample { value: 'a' };\n-///     assert_eq!('a', *x);\n-/// }\n+/// let x = DerefExample { value: 'a' };\n+/// assert_eq!('a', *x);\n /// ```\n #[lang = \"deref\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Deref {\n-    /// The resulting type after dereferencing\n+    /// The resulting type after dereferencing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Target: ?Sized;\n \n-    /// The method called to dereference a value\n+    /// Dereferences the value.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn deref(&self) -> &Self::Target;\n }\n@@ -66,16 +92,46 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n     fn deref(&self) -> &T { *self }\n }\n \n-/// The `DerefMut` trait is used to specify the functionality of dereferencing\n-/// mutably like `*v = 1;`\n-///\n-/// `DerefMut` also enables ['`Deref` coercions'][coercions].\n-///\n-/// [coercions]: ../../book/first-edition/deref-coercions.html\n+/// Used for mutable dereferencing operations, like in `*v = 1;`.\n+///\n+/// In addition to being used for explicit dereferencing operations with the\n+/// (unary) `*` operator in mutable contexts, `DerefMut` is also used implicitly\n+/// by the compiler in many circumstances. This mechanism is called\n+/// ['`Deref` coercion'][more]. In immutable contexts, [`Deref`] is used.\n+///\n+/// Implementing `DerefMut` for smart pointers makes mutating the data behind\n+/// them convenient, which is why they implement `DerefMut`. On the other hand,\n+/// the rules regarding [`Deref`] and `DerefMut` were designed specifically to\n+/// accomodate smart pointers. Because of this, **`DerefMut` should only be\n+/// implemented for smart pointers** to avoid confusion.\n+///\n+/// For similar reasons, **this trait should never fail**. Failure during\n+/// dereferencing can be extremely confusing when `DerefMut` is invoked\n+/// implicitly.\n+///\n+/// # More on `Deref` coercion\n+///\n+/// If `T` implements `DerefMut<Target = U>`, and `x` is a value of type `T`,\n+/// then:\n+/// * In mutable contexts, `*x` on non-pointer types is equivalent to\n+///   `*Deref::deref(&x)`.\n+/// * Values of type `&mut T` are coerced to values of type `&mut U`\n+/// * `T` implicitly implements all the (mutable) methods of the type `U`.\n+///\n+/// For more details, visit [the chapter in *The Rust Programming Language*]\n+/// [book] as well as the reference sections on [the dereference operator]\n+/// [ref-deref-op], [the `Deref` trait][ref-deref-trait], and [type coercions].\n+///\n+/// [book]: ../../book/second-edition/ch15-02-deref.html\n+/// [`Deref`]: trait.Deref.html\n+/// [more]: #more-on-deref-coercion\n+/// [ref-deref-op]: ../../reference/expressions.html#the-dereference-operator\n+/// [ref-deref-trait]: ../../reference/the-deref-trait.html\n+/// [type coercions]: ../../reference/type-coercions.html\n ///\n /// # Examples\n ///\n-/// A struct with a single field which is modifiable via dereferencing the\n+/// A struct with a single field which is modifiable by dereferencing the\n /// struct.\n ///\n /// ```\n@@ -99,16 +155,14 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let mut x = DerefMutExample { value: 'a' };\n-///     *x = 'b';\n-///     assert_eq!('b', *x);\n-/// }\n+/// let mut x = DerefMutExample { value: 'a' };\n+/// *x = 'b';\n+/// assert_eq!('b', *x);\n /// ```\n #[lang = \"deref_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DerefMut: Deref {\n-    /// The method called to mutably dereference a value\n+    /// Mutably dereferences the value.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn deref_mut(&mut self) -> &mut Self::Target;\n }"}, {"sha": "70ab7b2f3b7ec28aca515533266593be41af72ba", "filename": "src/libcore/ops/drop.rs", "status": "modified", "additions": 40, "deletions": 22, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fdrop.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -8,20 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// The `Drop` trait is used to run some code when a value goes out of scope.\n+/// Used to run some code when a value goes out of scope.\n /// This is sometimes called a 'destructor'.\n ///\n-/// When a value goes out of scope, if it implements this trait, it will have\n-/// its `drop` method called. Then any fields the value contains will also\n+/// When a value goes out of scope, it will have its `drop` method called if\n+/// its type implements `Drop`. Then, any fields the value contains will also\n /// be dropped recursively.\n ///\n-/// Because of the recursive dropping, you do not need to implement this trait\n+/// Because of this recursive dropping, you do not need to implement this trait\n /// unless your type needs its own destructor logic.\n ///\n+/// Refer to [the chapter on `Drop` in *The Rust Programming Language*][book]\n+/// for some more elaboration.\n+///\n+/// [book]: ../../book/second-edition/ch15-03-drop.html\n+///\n /// # Examples\n ///\n-/// A trivial implementation of `Drop`. The `drop` method is called when `_x`\n-/// goes out of scope, and therefore `main` prints `Dropping!`.\n+/// ## Implementing `Drop`\n+///\n+/// The `drop` method is called when `_x` goes out of scope, and therefore\n+/// `main` prints `Dropping!`.\n ///\n /// ```\n /// struct HasDrop;\n@@ -37,9 +44,11 @@\n /// }\n /// ```\n ///\n-/// Showing the recursive nature of `Drop`. When `outer` goes out of scope, the\n-/// `drop` method will be called first for `Outer`, then for `Inner`. Therefore\n-/// `main` prints `Dropping Outer!` and then `Dropping Inner!`.\n+/// ## Dropping is done recursively\n+///\n+/// When `outer` goes out of scope, the `drop` method will be called first for\n+/// `Outer`, then for `Inner`. Therefore, `main` prints `Dropping Outer!` and\n+/// then `Dropping Inner!`.\n ///\n /// ```\n /// struct Inner;\n@@ -62,12 +71,20 @@\n /// }\n /// ```\n ///\n-/// Because variables are dropped in the reverse order they are declared,\n-/// `main` will print `Declared second!` and then `Declared first!`.\n+/// ## Variables are dropped in reverse order of declaration\n+///\n+/// `_first` is declared first and `_second` is declared second, so `main` will\n+/// print `Declared second!` and then `Declared first!`.\n ///\n /// ```\n /// struct PrintOnDrop(&'static str);\n ///\n+/// impl Drop for PrintOnDrop {\n+///     fn drop(&mut self) {\n+///         println!(\"{}\", self.0);\n+///     }\n+/// }\n+///\n /// fn main() {\n ///     let _first = PrintOnDrop(\"Declared first!\");\n ///     let _second = PrintOnDrop(\"Declared second!\");\n@@ -76,24 +93,25 @@\n #[lang = \"drop\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Drop {\n-    /// A method called when the value goes out of scope.\n+    /// Executes the destructor for this type.\n+    ///\n+    /// This method is called implilcitly when the value goes out of scope,\n+    /// and cannot be called explicitly (this is compiler error [E0040]).\n+    /// However, the [`std::mem::drop`] function in the prelude can be\n+    /// used to call the argument's `Drop` implementation.\n     ///\n     /// When this method has been called, `self` has not yet been deallocated.\n-    /// If it were, `self` would be a dangling reference.\n+    /// That only happens after the method is over.\n+    /// If this wasn't the case, `self` would be a dangling reference.\n     ///\n-    /// After this function is over, the memory of `self` will be deallocated.\n+    /// # Panics\n     ///\n-    /// This function cannot be called explicitly. This is compiler error\n-    /// [E0040]. However, the [`std::mem::drop`] function in the prelude can be\n-    /// used to call the argument's `Drop` implementation.\n+    /// Given that a [`panic!`] will call `drop` as it unwinds, any [`panic!`]\n+    /// in a `drop` implementation will likely abort.\n     ///\n     /// [E0040]: ../../error-index.html#E0040\n+    /// [`panic!`]: ../macro.panic.html\n     /// [`std::mem::drop`]: ../../std/mem/fn.drop.html\n-    ///\n-    /// # Panics\n-    ///\n-    /// Given that a `panic!` will call `drop()` as it unwinds, any `panic!` in\n-    /// a `drop()` implementation will likely abort.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn drop(&mut self);\n }"}, {"sha": "d10fcb86b2411723df17dd205a9375ea8c47b6b6", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 104, "deletions": 24, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -8,26 +8,51 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// A version of the call operator that takes an immutable receiver.\n+/// The version of the call operator that takes an immutable receiver.\n ///\n-/// # Examples\n+/// Instances of `Fn` can be called repeatedly without mutating state.\n+///\n+/// *This trait (`Fn`) is not to be confused with [function pointers][]\n+/// (`fn`).*\n+///\n+/// `Fn` is implemented automatically by closures which only take immutable\n+/// references to captured variables or don't capture anything at all, as well\n+/// as (safe) [function pointers][] (with some caveats, see their documentation\n+/// for more details). Additionally, for any type `F` that implements `Fn`, `&F`\n+/// implements `Fn`, too.\n+///\n+/// Since both [`FnMut`] and [`FnOnce`] are supertraits of `Fn`, any\n+/// instance of `Fn` can be used as a parameter where a [`FnMut`] or [`FnOnce`]\n+/// is expected.\n ///\n-/// Closures automatically implement this trait, which allows them to be\n-/// invoked. Note, however, that `Fn` takes an immutable reference to any\n-/// captured variables. To take a mutable capture, implement [`FnMut`], and to\n-/// consume the capture, implement [`FnOnce`].\n+/// Use `Fn` as a bound when you want to accept a parameter of function-like\n+/// type and need to call it repeatedly and without mutating state (e.g. when\n+/// calling it concurrently). If you do not need such strict requirements, use\n+/// [`FnMut`] or [`FnOnce`] as bounds.\n ///\n+/// See the [chapter on closures in *The Rust Programming Language*][book] for\n+/// some more information on this topic.\n+///\n+/// Also of note is the special syntax for `Fn` traits (e.g.\n+/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n+///\n+/// [book]: ../../book/second-edition/ch13-01-closures.html\n /// [`FnMut`]: trait.FnMut.html\n /// [`FnOnce`]: trait.FnOnce.html\n+/// [function pointers]: ../../std/primitive.fn.html\n+/// [nomicon]: ../../nomicon/hrtb.html\n+///\n+/// # Examples\n+///\n+/// ## Calling a closure\n ///\n /// ```\n /// let square = |x| x * x;\n /// assert_eq!(square(5), 25);\n /// ```\n ///\n-/// Closures can also be passed to higher-level functions through a `Fn`\n-/// parameter (or a `FnMut` or `FnOnce` parameter, which are supertraits of\n-/// `Fn`).\n+/// ## Using a `Fn` parameter\n ///\n /// ```\n /// fn call_with_one<F>(func: F) -> usize\n@@ -43,17 +68,46 @@\n #[rustc_paren_sugar]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n pub trait Fn<Args> : FnMut<Args> {\n-    /// This is called when the call operator is used.\n+    /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n }\n \n-/// A version of the call operator that takes a mutable receiver.\n+/// The version of the call operator that takes a mutable receiver.\n+///\n+/// Instances of `FnMut` can be called repeatedly and may mutate state.\n+///\n+/// `FnMut` is implemented automatically by closures which take mutable\n+/// references to captured variables, as well as all types that implement\n+/// [`Fn`], e.g. (safe) [function pointers][] (since `FnMut` is a supertrait of\n+/// [`Fn`]). Additionally, for any type `F` that implements `FnMut`, `&mut F`\n+/// implements `FnMut`, too.\n+///\n+/// Since [`FnOnce`] is a supertrait of `FnMut`, any instance of `FnMut` can be\n+/// used where a [`FnOnce`] is expected, and since [`Fn`] is a subtrait of\n+/// `FnMut`, any instance of [`Fn`] can be used where `FnMut` is expected.\n+///\n+/// Use `FnMut` as a bound when you want to accept a parameter of function-like\n+/// type and need to call it repeatedly, while allowing it to mutate state.\n+/// If you don't want the parameter to mutate state, use [`Fn`] as a\n+/// bound; if you don't need to call it repeatedly, use [`FnOnce`].\n+///\n+/// See the [chapter on closures in *The Rust Programming Language*][book] for\n+/// some more information on this topic.\n+///\n+/// Also of note is the special syntax for `Fn` traits (e.g.\n+/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n+///\n+/// [book]: ../../book/second-edition/ch13-01-closures.html\n+/// [`Fn`]: trait.Fn.html\n+/// [`FnOnce`]: trait.FnOnce.html\n+/// [function pointers]: ../../std/primitive.fn.html\n+/// [nomicon]: ../../nomicon/hrtb.html\n ///\n /// # Examples\n ///\n-/// Closures that mutably capture variables automatically implement this trait,\n-/// which allows them to be invoked.\n+/// ## Calling a mutably capturing closure\n ///\n /// ```\n /// let mut x = 5;\n@@ -64,8 +118,7 @@ pub trait Fn<Args> : FnMut<Args> {\n /// assert_eq!(x, 25);\n /// ```\n ///\n-/// Closures can also be passed to higher-level functions through a `FnMut`\n-/// parameter (or a `FnOnce` parameter, which is a supertrait of `FnMut`).\n+/// ## Using a `FnMut` parameter\n ///\n /// ```\n /// fn do_twice<F>(mut func: F)\n@@ -88,39 +141,66 @@ pub trait Fn<Args> : FnMut<Args> {\n #[rustc_paren_sugar]\n #[fundamental] // so that regex can rely that `&str: !FnMut`\n pub trait FnMut<Args> : FnOnce<Args> {\n-    /// This is called when the call operator is used.\n+    /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n-/// A version of the call operator that takes a by-value receiver.\n+/// The version of the call operator that takes a by-value receiver.\n+///\n+/// Instances of `FnOnce` can be called, but might not be callable multiple\n+/// times. Because of this, if the only thing known about a type is that it\n+/// implements `FnOnce`, it can only be called once.\n+///\n+/// `FnOnce` is implemented automatically by closure that might consume captured\n+/// variables, as well as all types that implement [`FnMut`], e.g. (safe)\n+/// [function pointers][] (since `FnOnce` is a supertrait of [`FnMut`]).\n+///\n+/// Since both [`Fn`] and [`FnMut`] are subtraits of `FnOnce`, any instance of\n+/// [`Fn`] or [`FnMut`] can be used where a `FnOnce` is expected.\n+///\n+/// Use `FnOnce` as a bound when you want to accept a parameter of function-like\n+/// type and only need to call it once. If you need to call the parameter\n+/// repeatedly, use [`FnMut`] as a bound; if you also need it to not mutate\n+/// state, use [`Fn`].\n+///\n+/// See the [chapter on closures in *The Rust Programming Language*][book] for\n+/// some more information on this topic.\n+///\n+/// Also of note is the special syntax for `Fn` traits (e.g.\n+/// `Fn(usize, bool) -> usize`). Those interested in the technical details of\n+/// this can refer to [the relevant section in the *Rustonomicon*][nomicon].\n+///\n+/// [book]: ../../book/second-edition/ch13-01-closures.html\n+/// [`Fn`]: trait.Fn.html\n+/// [`FnMut`]: trait.FnMut.html\n+/// [function pointers]: ../../std/primitive.fn.html\n+/// [nomicon]: ../../nomicon/hrtb.html\n ///\n /// # Examples\n ///\n-/// By-value closures automatically implement this trait, which allows them to\n-/// be invoked.\n+/// ## Calling a by-value closure\n ///\n /// ```\n /// let x = 5;\n /// let square_x = move || x * x;\n /// assert_eq!(square_x(), 25);\n /// ```\n ///\n-/// By-value Closures can also be passed to higher-level functions through a\n-/// `FnOnce` parameter.\n+/// ## Using a `FnOnce` parameter\n ///\n /// ```\n /// fn consume_with_relish<F>(func: F)\n ///     where F: FnOnce() -> String\n /// {\n ///     // `func` consumes its captured variables, so it cannot be run more\n-///     // than once\n+///     // than once.\n ///     println!(\"Consumed: {}\", func());\n ///\n ///     println!(\"Delicious!\");\n ///\n ///     // Attempting to invoke `func()` again will throw a `use of moved\n-///     // value` error for `func`\n+///     // value` error for `func`.\n /// }\n ///\n /// let x = String::from(\"x\");\n@@ -138,7 +218,7 @@ pub trait FnOnce<Args> {\n     #[stable(feature = \"fn_once_output\", since = \"1.12.0\")]\n     type Output;\n \n-    /// This is called when the call operator is used.\n+    /// Performs the call operation.\n     #[unstable(feature = \"fn_traits\", issue = \"29625\")]\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }"}, {"sha": "d65c0aba5048103fe80c67056102347f876ee742", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/// The `Index` trait is used to specify the functionality of indexing operations\n-/// like `container[index]` when used in an immutable context.\n+/// Used for indexing operations (`container[index]`) in immutable contexts.\n ///\n /// `container[index]` is actually syntactic sugar for `*container.index(index)`,\n /// but only when used as an immutable value. If a mutable value is requested,\n /// [`IndexMut`] is used instead. This allows nice things such as\n-/// `let value = v[index]` if `value` implements [`Copy`].\n+/// `let value = v[index]` if the type of `value` implements [`Copy`].\n ///\n /// [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n /// [`Copy`]: ../../std/marker/trait.Copy.html\n@@ -64,25 +63,23 @@\n #[rustc_on_unimplemented = \"the type `{Self}` cannot be indexed by `{Idx}`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Index<Idx: ?Sized> {\n-    /// The returned type after indexing\n+    /// The returned type after indexing.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Output: ?Sized;\n \n-    /// The method for the indexing (`container[index]`) operation\n+    /// Performs the indexing (`container[index]`) operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index(&self, index: Idx) -> &Self::Output;\n }\n \n-/// The `IndexMut` trait is used to specify the functionality of indexing\n-/// operations like `container[index]` when used in a mutable context.\n+/// Used for indexing operations (`container[index]`) in mutable contexts.\n ///\n /// `container[index]` is actually syntactic sugar for\n /// `*container.index_mut(index)`, but only when used as a mutable value. If\n /// an immutable value is requested, the [`Index`] trait is used instead. This\n-/// allows nice things such as `v[index] = value` if `value` implements [`Copy`].\n+/// allows nice things such as `v[index] = value`.\n ///\n /// [`Index`]: ../../std/ops/trait.Index.html\n-/// [`Copy`]: ../../std/marker/trait.Copy.html\n ///\n /// # Examples\n ///\n@@ -106,7 +103,7 @@ pub trait Index<Idx: ?Sized> {\n ///\n /// struct Balance {\n ///     pub left: Weight,\n-///     pub right:Weight,\n+///     pub right: Weight,\n /// }\n ///\n /// impl Index<Side> for Balance {\n@@ -131,28 +128,26 @@ pub trait Index<Idx: ?Sized> {\n ///     }\n /// }\n ///\n-/// fn main() {\n-///     let mut balance = Balance {\n-///         right: Weight::Kilogram(2.5),\n-///         left: Weight::Pound(1.5),\n-///     };\n-///\n-///     // In this case balance[Side::Right] is sugar for\n-///     // *balance.index(Side::Right), since we are only reading\n-///     // balance[Side::Right], not writing it.\n-///     assert_eq!(balance[Side::Right],Weight::Kilogram(2.5));\n-///\n-///     // However in this case balance[Side::Left] is sugar for\n-///     // *balance.index_mut(Side::Left), since we are writing\n-///     // balance[Side::Left].\n-///     balance[Side::Left] = Weight::Kilogram(3.0);\n-/// }\n+/// let mut balance = Balance {\n+///     right: Weight::Kilogram(2.5),\n+///     left: Weight::Pound(1.5),\n+/// };\n+///\n+/// // In this case, `balance[Side::Right]` is sugar for\n+/// // `*balance.index(Side::Right)`, since we are only *reading*\n+/// // `balance[Side::Right]`, not writing it.\n+/// assert_eq!(balance[Side::Right], Weight::Kilogram(2.5));\n+///\n+/// // However, in this case `balance[Side::Left]` is sugar for\n+/// // `*balance.index_mut(Side::Left)`, since we are writing\n+/// // `balance[Side::Left]`.\n+/// balance[Side::Left] = Weight::Kilogram(3.0);\n /// ```\n #[lang = \"index_mut\"]\n #[rustc_on_unimplemented = \"the type `{Self}` cannot be mutably indexed by `{Idx}`\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait IndexMut<Idx: ?Sized>: Index<Idx> {\n-    /// The method for the mutable indexing (`container[index]`) operation\n+    /// Performs the mutable indexing (`container[index]`) operation.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn index_mut(&mut self, index: Idx) -> &mut Self::Output;\n }"}, {"sha": "8975b680ca7fac1e6526c1a923d3d9078c47ce98", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -21,6 +21,12 @@\n //! custom operators are required, you should look toward macros or compiler\n //! plugins to extend Rust's syntax.\n //!\n+//! Implementations of operator traits should be unsurprising in their\n+//! respective contexts, keeping in mind their usual meanings and\n+//! [operator precedence]. For example, when implementing [`Mul`], the operation\n+//! should have some resemblance to multiplication (and share expected\n+//! properties like associativity).\n+//!\n //! Note that the `&&` and `||` operators short-circuit, i.e. they only\n //! evaluate their second operand if it contributes to the result. Since this\n //! behavior is not enforceable by traits, `&&` and `||` are not supported as\n@@ -46,7 +52,7 @@\n //! ```rust\n //! use std::ops::{Add, Sub};\n //!\n-//! #[derive(Debug)]\n+//! #[derive(Debug, PartialEq)]\n //! struct Point {\n //!     x: i32,\n //!     y: i32,\n@@ -67,10 +73,9 @@\n //!         Point {x: self.x - other.x, y: self.y - other.y}\n //!     }\n //! }\n-//! fn main() {\n-//!     println!(\"{:?}\", Point {x: 1, y: 0} + Point {x: 2, y: 3});\n-//!     println!(\"{:?}\", Point {x: 1, y: 0} - Point {x: 2, y: 3});\n-//! }\n+//!\n+//! assert_eq!(Point {x: 3, y: 3}, Point {x: 1, y: 0} + Point {x: 2, y: 3});\n+//! assert_eq!(Point {x: -1, y: -3}, Point {x: 1, y: 0} - Point {x: 2, y: 3});\n //! ```\n //!\n //! See the documentation for each trait for an example implementation.\n@@ -143,7 +148,9 @@\n //! [`FnOnce`]: trait.FnOnce.html\n //! [`Add`]: trait.Add.html\n //! [`Sub`]: trait.Sub.html\n+//! [`Mul`]: trait.Mul.html\n //! [`clone`]: ../clone/trait.Clone.html#tymethod.clone\n+//! [operator precedence]: ../../reference/expressions.html#operator-precedence\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "9fb171e7b924e64478dd11aaaa9e8c2f64e20ca1", "filename": "src/libcore/ops/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fplace.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -66,7 +66,7 @@ pub trait Place<Data: ?Sized> {\n /// or `Copy`, since the `make_place` method takes `self` by value.\n #[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n pub trait Placer<Data: ?Sized> {\n-    /// `Place` is the intermedate agent guarding the\n+    /// `Place` is the intermediate agent guarding the\n     /// uninitialized state for `Data`.\n     type Place: InPlace<Data>;\n "}, {"sha": "463a50491a866e16a884973474a7622bd479dda6", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 111, "deletions": 95, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -10,10 +10,10 @@\n \n use fmt;\n \n-/// An unbounded range. Use `..` (two dots) for its shorthand.\n+/// An unbounded range (`..`).\n ///\n-/// Its primary use case is slicing index. It cannot serve as an iterator\n-/// because it doesn't have a starting point.\n+/// `RangeFull` is primarily used as a [slicing index], its shorthand is `..`.\n+/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n ///\n /// # Examples\n ///\n@@ -23,16 +23,16 @@ use fmt;\n /// assert_eq!((..), std::ops::RangeFull);\n /// ```\n ///\n-/// It does not have an `IntoIterator` implementation, so you can't use it in a\n-/// `for` loop directly. This won't compile:\n+/// It does not have an [`IntoIterator`] implementation, so you can't use it in\n+/// a `for` loop directly. This won't compile:\n ///\n /// ```compile_fail,E0277\n /// for i in .. {\n ///    // ...\n /// }\n /// ```\n ///\n-/// Used as a slicing index, `RangeFull` produces the full array as a slice.\n+/// Used as a [slicing index], `RangeFull` produces the full array as a slice.\n ///\n /// ```\n /// let arr = [0, 1, 2, 3];\n@@ -41,6 +41,10 @@ use fmt;\n /// assert_eq!(arr[1.. ], [  1,2,3]);\n /// assert_eq!(arr[1..3], [  1,2  ]);\n /// ```\n+///\n+/// [`IntoIterator`]: ../iter/trait.Iterator.html\n+/// [`Iterator`]: ../iter/trait.IntoIterator.html\n+/// [slicing index]: ../slice/trait.SliceIndex.html\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFull;\n@@ -52,24 +56,23 @@ impl fmt::Debug for RangeFull {\n     }\n }\n \n-/// A (half-open) range which is bounded at both ends: { x | start <= x < end }.\n-/// Use `start..end` (two dots) for its shorthand.\n+/// A (half-open) range bounded inclusively below and exclusively above\n+/// (`start..end`).\n ///\n-/// See the [`contains`](#method.contains) method for its characterization.\n+/// The `Range` `start..end` contains all values with `x >= start` and\n+/// `x < end`.\n ///\n /// # Examples\n ///\n /// ```\n-/// fn main() {\n-///     assert_eq!((3..5), std::ops::Range{ start: 3, end: 5 });\n-///     assert_eq!(3+4+5, (3..6).sum());\n-///\n-///     let arr = [0, 1, 2, 3];\n-///     assert_eq!(arr[ .. ], [0,1,2,3]);\n-///     assert_eq!(arr[ ..3], [0,1,2  ]);\n-///     assert_eq!(arr[1.. ], [  1,2,3]);\n-///     assert_eq!(arr[1..3], [  1,2  ]);  // Range\n-/// }\n+/// assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });\n+/// assert_eq!(3 + 4 + 5, (3..6).sum());\n+///\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ .. ], [0,1,2,3]);\n+/// assert_eq!(arr[ ..3], [0,1,2  ]);\n+/// assert_eq!(arr[1.. ], [  1,2,3]);\n+/// assert_eq!(arr[1..3], [  1,2  ]);  // Range\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -91,49 +94,49 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> Range<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains)]\n-    /// fn main() {\n-    ///     assert!( ! (3..5).contains(2));\n-    ///     assert!(   (3..5).contains(3));\n-    ///     assert!(   (3..5).contains(4));\n-    ///     assert!( ! (3..5).contains(5));\n     ///\n-    ///     assert!( ! (3..3).contains(3));\n-    ///     assert!( ! (3..2).contains(3));\n-    /// }\n+    /// assert!(!(3..5).contains(2));\n+    /// assert!( (3..5).contains(3));\n+    /// assert!( (3..5).contains(4));\n+    /// assert!(!(3..5).contains(5));\n+    ///\n+    /// assert!(!(3..3).contains(3));\n+    /// assert!(!(3..2).contains(3));\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (self.start <= item) && (item < self.end)\n     }\n }\n \n-/// A range which is only bounded below: { x | start <= x }.\n-/// Use `start..` for its shorthand.\n+/// A range only bounded inclusively below (`start..`).\n ///\n-/// See the [`contains`](#method.contains) method for its characterization.\n+/// The `RangeFrom` `start..` contains all values with `x >= start`.\n ///\n-/// Note: Currently, no overflow checking is done for the iterator\n+/// *Note*: Currently, no overflow checking is done for the [`Iterator`]\n /// implementation; if you use an integer range and the integer overflows, it\n-/// might panic in debug mode or create an endless loop in release mode. This\n-/// overflow behavior might change in the future.\n+/// might panic in debug mode or create an endless loop in release mode. **This\n+/// overflow behavior might change in the future.**\n ///\n /// # Examples\n ///\n /// ```\n-/// fn main() {\n-///     assert_eq!((2..), std::ops::RangeFrom{ start: 2 });\n-///     assert_eq!(2+3+4, (2..).take(3).sum());\n-///\n-///     let arr = [0, 1, 2, 3];\n-///     assert_eq!(arr[ .. ], [0,1,2,3]);\n-///     assert_eq!(arr[ ..3], [0,1,2  ]);\n-///     assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n-///     assert_eq!(arr[1..3], [  1,2  ]);\n-/// }\n+/// assert_eq!((2..), std::ops::RangeFrom { start: 2 });\n+/// assert_eq!(2 + 3 + 4, (2..).take(3).sum());\n+///\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ .. ], [0,1,2,3]);\n+/// assert_eq!(arr[ ..3], [0,1,2  ]);\n+/// assert_eq!(arr[1.. ], [  1,2,3]);  // RangeFrom\n+/// assert_eq!(arr[1..3], [  1,2  ]);\n /// ```\n+///\n+/// [`Iterator`]: ../iter/trait.IntoIterator.html\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeFrom<Idx> {\n@@ -151,46 +154,47 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains)]\n-    /// fn main() {\n-    ///     assert!( ! (3..).contains(2));\n-    ///     assert!(   (3..).contains(3));\n-    ///     assert!(   (3..).contains(1_000_000_000));\n-    /// }\n+    ///\n+    /// assert!(!(3..).contains(2));\n+    /// assert!( (3..).contains(3));\n+    /// assert!( (3..).contains(1_000_000_000));\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (self.start <= item)\n     }\n }\n \n-/// A range which is only bounded above: { x | x < end }.\n-/// Use `..end` (two dots) for its shorthand.\n-///\n-/// See the [`contains`](#method.contains) method for its characterization.\n+/// A range only bounded exclusively above (`..end`).\n ///\n-/// It cannot serve as an iterator because it doesn't have a starting point.\n+/// The `RangeTo` `..end` contains all values with `x < end`.\n+/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n ///\n /// # Examples\n ///\n-/// The `..{integer}` syntax is a `RangeTo`:\n+/// The `..end` syntax is a `RangeTo`:\n ///\n /// ```\n-/// assert_eq!((..5), std::ops::RangeTo{ end: 5 });\n+/// assert_eq!((..5), std::ops::RangeTo { end: 5 });\n /// ```\n ///\n-/// It does not have an `IntoIterator` implementation, so you can't use it in a\n-/// `for` loop directly. This won't compile:\n+/// It does not have an [`IntoIterator`] implementation, so you can't use it in\n+/// a `for` loop directly. This won't compile:\n ///\n /// ```compile_fail,E0277\n+/// // error[E0277]: the trait bound `std::ops::RangeTo<{integer}>:\n+/// // std::iter::Iterator` is not satisfied\n /// for i in ..5 {\n ///     // ...\n /// }\n /// ```\n ///\n-/// When used as a slicing index, `RangeTo` produces a slice of all array\n+/// When used as a [slicing index], `RangeTo` produces a slice of all array\n /// elements before the index indicated by `end`.\n ///\n /// ```\n@@ -200,6 +204,10 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n /// assert_eq!(arr[1.. ], [  1,2,3]);\n /// assert_eq!(arr[1..3], [  1,2  ]);\n /// ```\n+///\n+/// [`IntoIterator`]: ../iter/trait.Iterator.html\n+/// [`Iterator`]: ../iter/trait.IntoIterator.html\n+/// [slicing index]: ../slice/trait.SliceIndex.html\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct RangeTo<Idx> {\n@@ -217,38 +225,38 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains)]\n-    /// fn main() {\n-    ///     assert!(   (..5).contains(-1_000_000_000));\n-    ///     assert!(   (..5).contains(4));\n-    ///     assert!( ! (..5).contains(5));\n-    /// }\n+    ///\n+    /// assert!( (..5).contains(-1_000_000_000));\n+    /// assert!( (..5).contains(4));\n+    /// assert!(!(..5).contains(5));\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (item < self.end)\n     }\n }\n \n-/// An inclusive range which is bounded at both ends: { x | start <= x <= end }.\n-/// Use `start...end` (three dots) for its shorthand.\n+/// An range bounded inclusively below and above (`start...end`).\n ///\n-/// See the [`contains`](#method.contains) method for its characterization.\n+/// The `RangeInclusive` `start...end` contains all values with `x >= start`\n+/// and `x <= end`.\n ///\n /// # Examples\n ///\n /// ```\n /// #![feature(inclusive_range,inclusive_range_syntax)]\n-/// fn main() {\n-///     assert_eq!((3...5), std::ops::RangeInclusive{ start: 3, end: 5 });\n-///     assert_eq!(3+4+5, (3...5).sum());\n ///\n-///     let arr = [0, 1, 2, 3];\n-///     assert_eq!(arr[ ...2], [0,1,2  ]);\n-///     assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n-/// }\n+/// assert_eq!((3...5), std::ops::RangeInclusive { start: 3, end: 5 });\n+/// assert_eq!(3 + 4 + 5, (3...5).sum());\n+///\n+/// let arr = [0, 1, 2, 3];\n+/// assert_eq!(arr[ ...2], [0,1,2  ]);\n+/// assert_eq!(arr[1...2], [  1,2  ]);  // RangeInclusive\n /// ```\n #[derive(Clone, PartialEq, Eq, Hash)]  // not Copy -- see #27186\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n@@ -274,61 +282,68 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains,inclusive_range_syntax)]\n-    /// fn main() {\n-    ///     assert!( ! (3...5).contains(2));\n-    ///     assert!(   (3...5).contains(3));\n-    ///     assert!(   (3...5).contains(4));\n-    ///     assert!(   (3...5).contains(5));\n-    ///     assert!( ! (3...5).contains(6));\n     ///\n-    ///     assert!(   (3...3).contains(3));\n-    ///     assert!( ! (3...2).contains(3));\n-    /// }\n+    /// assert!(!(3...5).contains(2));\n+    /// assert!( (3...5).contains(3));\n+    /// assert!( (3...5).contains(4));\n+    /// assert!( (3...5).contains(5));\n+    /// assert!(!(3...5).contains(6));\n+    ///\n+    /// assert!( (3...3).contains(3));\n+    /// assert!(!(3...2).contains(3));\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         self.start <= item && item <= self.end\n     }\n }\n \n-/// An inclusive range which is only bounded above: { x | x <= end }.\n-/// Use `...end` (three dots) for its shorthand.\n+/// A range only bounded inclusively above (`...end`).\n ///\n-/// See the [`contains`](#method.contains) method for its characterization.\n-///\n-/// It cannot serve as an iterator because it doesn't have a starting point.\n+/// The `RangeToInclusive` `...end` contains all values with `x <= end`.\n+/// It cannot serve as an [`Iterator`] because it doesn't have a starting point.\n ///\n /// # Examples\n ///\n-/// The `...{integer}` syntax is a `RangeToInclusive`:\n+/// The `...end` syntax is a `RangeToInclusive`:\n ///\n /// ```\n /// #![feature(inclusive_range,inclusive_range_syntax)]\n /// assert_eq!((...5), std::ops::RangeToInclusive{ end: 5 });\n /// ```\n ///\n-/// It does not have an `IntoIterator` implementation, so you can't use it in a\n+/// It does not have an [`IntoIterator`] implementation, so you can't use it in a\n /// `for` loop directly. This won't compile:\n ///\n /// ```compile_fail,E0277\n /// #![feature(inclusive_range_syntax)]\n+///\n+/// // error[E0277]: the trait bound `std::ops::RangeToInclusive<{integer}>:\n+/// // std::iter::Iterator` is not satisfied\n /// for i in ...5 {\n ///     // ...\n /// }\n /// ```\n ///\n-/// When used as a slicing index, `RangeToInclusive` produces a slice of all\n+/// When used as a [slicing index], `RangeToInclusive` produces a slice of all\n /// array elements up to and including the index indicated by `end`.\n ///\n /// ```\n /// #![feature(inclusive_range_syntax)]\n+///\n /// let arr = [0, 1, 2, 3];\n /// assert_eq!(arr[ ...2], [0,1,2  ]);  // RangeToInclusive\n /// assert_eq!(arr[1...2], [  1,2  ]);\n /// ```\n+///\n+/// [`IntoIterator`]: ../iter/trait.Iterator.html\n+/// [`Iterator`]: ../iter/trait.IntoIterator.html\n+/// [slicing index]: ../slice/trait.SliceIndex.html\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub struct RangeToInclusive<Idx> {\n@@ -348,15 +363,16 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n \n #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n+    /// Returns `true` if `item` is contained in the range.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n     /// #![feature(range_contains,inclusive_range_syntax)]\n-    /// fn main() {\n-    ///     assert!(   (...5).contains(-1_000_000_000));\n-    ///     assert!(   (...5).contains(5));\n-    ///     assert!( ! (...5).contains(6));\n-    /// }\n+    ///\n+    /// assert!( (...5).contains(-1_000_000_000));\n+    /// assert!( (...5).contains(5));\n+    /// assert!(!(...5).contains(6));\n     /// ```\n     pub fn contains(&self, item: Idx) -> bool {\n         (item <= self.end)"}, {"sha": "58da290cfb694bb8bbb547c09fa90d7147c6bb07", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -24,7 +24,7 @@ use marker::Unsize;\n /// Such an impl can only be written if `Foo<T>` has only a single non-phantomdata\n /// field involving `T`. If the type of that field is `Bar<T>`, an implementation\n /// of `CoerceUnsized<Bar<U>> for Bar<T>` must exist. The coercion will work by\n-/// by coercing the `Bar<T>` field into `Bar<U>` and filling in the rest of the fields\n+/// coercing the `Bar<T>` field into `Bar<U>` and filling in the rest of the fields\n /// from `Foo<T>` to create a `Foo<U>`. This will effectively drill down to a pointer\n /// field and coerce that.\n ///"}, {"sha": "e35777d222c0657475fb1f490a7c7093359c3245", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -384,6 +384,11 @@ pub unsafe fn write_unaligned<T>(dst: *mut T, src: T) {\n /// over time. That being said, the semantics will almost always end up pretty\n /// similar to [C11's definition of volatile][c11].\n ///\n+/// The compiler shouldn't change the relative order or number of volatile\n+/// memory operations. However, volatile memory operations on zero-sized types\n+/// (e.g. if a zero-sized type is passed to `read_volatile`) are no-ops\n+/// and may be ignored.\n+///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n ///\n /// # Safety\n@@ -427,6 +432,11 @@ pub unsafe fn read_volatile<T>(src: *const T) -> T {\n /// over time. That being said, the semantics will almost always end up pretty\n /// similar to [C11's definition of volatile][c11].\n ///\n+/// The compiler shouldn't change the relative order or number of volatile\n+/// memory operations. However, volatile memory operations on zero-sized types\n+/// (e.g. if a zero-sized type is passed to `write_volatile`) are no-ops\n+/// and may be ignored.\n+///\n /// [c11]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\n ///\n /// # Safety"}, {"sha": "cc0ef6a6f17e04b5e7358040d0ef689cb73ea871", "filename": "src/libcore/tests/cell.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Ftests%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Ftests%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcell.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -287,3 +287,20 @@ fn refcell_ref_coercion() {\n         assert_eq!(&*coerced, comp);\n     }\n }\n+\n+#[test]\n+#[should_panic]\n+fn refcell_swap_borrows() {\n+    let x = RefCell::new(0);\n+    let _b = x.borrow();\n+    let y = RefCell::new(1);\n+    x.swap(&y);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn refcell_replace_borrows() {\n+    let x = RefCell::new(0);\n+    let _b = x.borrow();\n+    x.replace(1);\n+}"}, {"sha": "84a3be99c275f5ca2a01956c55172edddcb2579f", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -31,6 +31,7 @@\n #![feature(ord_max_min)]\n #![feature(rand)]\n #![feature(raw)]\n+#![feature(refcell_replace_swap)]\n #![feature(sip_hash_13)]\n #![feature(slice_patterns)]\n #![feature(slice_rotate)]"}, {"sha": "400d53ce51a08cfe2851120074502dc55867e084", "filename": "src/libcore/tests/num/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -566,7 +566,7 @@ assume_usize_width! {\n     );\n }\n \n-/// Conversinos where neither the min nor the max of $source can be represented by\n+/// Conversions where neither the min nor the max of $source can be represented by\n /// $target, but max/min of the target can be represented by the source.\n macro_rules! test_impl_try_from_signed_to_unsigned_err {\n     ($fn_name:ident, $source:ty, $target:ty) => {"}, {"sha": "c01938f5e117435c4b8ef806ffd0e2deedaf977c", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -548,7 +548,7 @@ impl<'a> LabelText<'a> {\n     }\n \n     /// Renders text as string suitable for a label in a .dot file.\n-    /// This includes quotes or suitable delimeters.\n+    /// This includes quotes or suitable delimiters.\n     pub fn to_dot_string(&self) -> String {\n         match self {\n             &LabelStr(ref s) => format!(\"\\\"{}\\\"\", s.escape_default()),"}, {"sha": "6a71e67676ae48a6abb364106b98e925d17358b0", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -111,7 +111,7 @@ impl fmt::Display for TokenStream {\n \n /// `quote!(..)` accepts arbitrary tokens and expands into a `TokenStream` describing the input.\n /// For example, `quote!(a + b)` will produce a expression, that, when evaluated, constructs\n-/// constructs the `TokenStream` `[Word(\"a\"), Op('+', Alone), Word(\"b\")]`.\n+/// the `TokenStream` `[Word(\"a\"), Op('+', Alone), Word(\"b\")]`.\n ///\n /// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n /// To quote `$` itself, use `$$`."}, {"sha": "3e398562242661ea61aff86e277b0c690179084a", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -87,7 +87,7 @@ pub enum NestedVisitorMap<'this, 'tcx: 'this> {\n     /// Do not visit nested item-like things, but visit nested things\n     /// that are inside of an item-like.\n     ///\n-    /// **This is the most common choice.** A very commmon pattern is\n+    /// **This is the most common choice.** A very common pattern is\n     /// to use `visit_all_item_likes()` as an outer loop,\n     /// and to have the visitor that visits the contents of each item\n     /// using this setting."}, {"sha": "f7ffda03f2384d328cb9a65421f849832dd13666", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 119, "deletions": 62, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -158,6 +158,11 @@ enum ParamMode {\n     Optional\n }\n \n+struct LoweredNodeId {\n+    node_id: NodeId,\n+    hir_id: hir::HirId,\n+}\n+\n impl<'a> LoweringContext<'a> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n         /// Full-crate AST visitor that inserts into a fresh\n@@ -281,11 +286,14 @@ impl<'a> LoweringContext<'a> {\n     fn lower_node_id_generic<F>(&mut self,\n                                 ast_node_id: NodeId,\n                                 alloc_hir_id: F)\n-                                -> NodeId\n+                                -> LoweredNodeId\n         where F: FnOnce(&mut Self) -> hir::HirId\n     {\n         if ast_node_id == DUMMY_NODE_ID {\n-            return ast_node_id;\n+            return LoweredNodeId {\n+                node_id: DUMMY_NODE_ID,\n+                hir_id: hir::DUMMY_HIR_ID,\n+            }\n         }\n \n         let min_size = ast_node_id.as_usize() + 1;\n@@ -294,12 +302,22 @@ impl<'a> LoweringContext<'a> {\n             self.node_id_to_hir_id.resize(min_size, hir::DUMMY_HIR_ID);\n         }\n \n-        if self.node_id_to_hir_id[ast_node_id] == hir::DUMMY_HIR_ID {\n+        let existing_hir_id = self.node_id_to_hir_id[ast_node_id];\n+\n+        if existing_hir_id == hir::DUMMY_HIR_ID {\n             // Generate a new HirId\n-            self.node_id_to_hir_id[ast_node_id] = alloc_hir_id(self);\n+            let hir_id = alloc_hir_id(self);\n+            self.node_id_to_hir_id[ast_node_id] = hir_id;\n+            LoweredNodeId {\n+                node_id: ast_node_id,\n+                hir_id,\n+            }\n+        } else {\n+            LoweredNodeId {\n+                node_id: ast_node_id,\n+                hir_id: existing_hir_id,\n+            }\n         }\n-\n-        ast_node_id\n     }\n \n     fn with_hir_id_owner<F>(&mut self, owner: NodeId, f: F)\n@@ -326,7 +344,7 @@ impl<'a> LoweringContext<'a> {\n     /// actually used in the HIR, as that would trigger an assertion in the\n     /// HirIdValidator later on, which makes sure that all NodeIds got mapped\n     /// properly. Calling the method twice with the same NodeId is fine though.\n-    fn lower_node_id(&mut self, ast_node_id: NodeId) -> NodeId {\n+    fn lower_node_id(&mut self, ast_node_id: NodeId) -> LoweredNodeId {\n         self.lower_node_id_generic(ast_node_id, |this| {\n             let &mut (def_index, ref mut local_id_counter) = this.current_hir_id_owner\n                                                                  .last_mut()\n@@ -343,7 +361,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_node_id_with_owner(&mut self,\n                                 ast_node_id: NodeId,\n                                 owner: NodeId)\n-                                -> NodeId {\n+                                -> LoweredNodeId {\n         self.lower_node_id_generic(ast_node_id, |this| {\n             let local_id_counter = this.item_local_id_counters\n                                        .get_mut(&owner)\n@@ -379,7 +397,7 @@ impl<'a> LoweringContext<'a> {\n         id\n     }\n \n-    fn next_id(&mut self) -> NodeId {\n+    fn next_id(&mut self) -> LoweredNodeId {\n         self.lower_node_id(self.sess.next_node_id())\n     }\n \n@@ -408,6 +426,7 @@ impl<'a> LoweringContext<'a> {\n                 format: codemap::CompilerDesugaring(Symbol::intern(reason)),\n                 span: Some(span),\n                 allow_internal_unstable: true,\n+                allow_internal_unsafe: false,\n             },\n         });\n         span.ctxt = SyntaxContext::empty().apply_mark(mark);\n@@ -531,7 +550,7 @@ impl<'a> LoweringContext<'a> {\n         match destination {\n             Some((id, label_ident)) => {\n                 let target = if let Def::Label(loop_id) = self.expect_full_def(id) {\n-                    hir::LoopIdResult::Ok(self.lower_node_id(loop_id))\n+                    hir::LoopIdResult::Ok(self.lower_node_id(loop_id).node_id)\n                 } else {\n                     hir::LoopIdResult::Err(hir::LoopIdError::UnresolvedLabel)\n                 };\n@@ -548,7 +567,7 @@ impl<'a> LoweringContext<'a> {\n                 hir::Destination {\n                     ident: None,\n                     target_id: hir::ScopeTarget::Loop(\n-                        loop_id.map(|id| Ok(self.lower_node_id(id)))\n+                        loop_id.map(|id| Ok(self.lower_node_id(id).node_id))\n                                .unwrap_or(Err(hir::LoopIdError::OutsideLoopScope))\n                                .into())\n                 }\n@@ -571,7 +590,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_ty_binding(&mut self, b: &TypeBinding) -> hir::TypeBinding {\n         hir::TypeBinding {\n-            id: self.lower_node_id(b.id),\n+            id: self.lower_node_id(b.id).node_id,\n             name: self.lower_ident(b.ident),\n             ty: self.lower_ty(&b.ty),\n             span: b.span,\n@@ -608,7 +627,7 @@ impl<'a> LoweringContext<'a> {\n                 return self.lower_ty(ty);\n             }\n             TyKind::Path(ref qself, ref path) => {\n-                let id = self.lower_node_id(t.id);\n+                let id = self.lower_node_id(t.id).node_id;\n                 let qpath = self.lower_qpath(t.id, qself, path, ParamMode::Explicit);\n                 return self.ty_path(id, t.span, qpath);\n             }\n@@ -658,7 +677,7 @@ impl<'a> LoweringContext<'a> {\n         };\n \n         P(hir::Ty {\n-            id: self.lower_node_id(t.id),\n+            id: self.lower_node_id(t.id).node_id,\n             node: kind,\n             span: t.span,\n         })\n@@ -770,7 +789,7 @@ impl<'a> LoweringContext<'a> {\n             // Otherwise, the base path is an implicit `Self` type path,\n             // e.g. `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n             // `<I as Iterator>::Item::default`.\n-            let new_id = self.next_id();\n+            let new_id = self.next_id().node_id;\n             self.ty_path(new_id, p.span, hir::QPath::Resolved(qself, path))\n         };\n \n@@ -794,7 +813,7 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             // Wrap the associated extension in another type node.\n-            let new_id = self.next_id();\n+            let new_id = self.next_id().node_id;\n             ty = self.ty_path(new_id, p.span, qpath);\n         }\n \n@@ -898,8 +917,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_local(&mut self, l: &Local) -> P<hir::Local> {\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(l.id);\n         P(hir::Local {\n-            id: self.lower_node_id(l.id),\n+            id: node_id,\n+            hir_id,\n             ty: l.ty.as_ref().map(|t| self.lower_ty(t)),\n             pat: self.lower_pat(&l.pat),\n             init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n@@ -917,8 +938,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(arg.id);\n         hir::Arg {\n-            id: self.lower_node_id(arg.id),\n+            id: node_id,\n+            hir_id,\n             pat: self.lower_pat(&arg.pat),\n         }\n     }\n@@ -981,7 +1004,7 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         hir::TyParam {\n-            id: self.lower_node_id(tp.id),\n+            id: self.lower_node_id(tp.id).node_id,\n             name,\n             bounds,\n             default: tp.default.as_ref().map(|x| self.lower_ty(x)),\n@@ -999,7 +1022,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n         hir::Lifetime {\n-            id: self.lower_node_id(l.id),\n+            id: self.lower_node_id(l.id).node_id,\n             name: self.lower_ident(l.ident),\n             span: l.span,\n         }\n@@ -1071,7 +1094,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause {\n         hir::WhereClause {\n-            id: self.lower_node_id(wc.id),\n+            id: self.lower_node_id(wc.id).node_id,\n             predicates: wc.predicates\n                           .iter()\n                           .map(|predicate| self.lower_where_predicate(predicate))\n@@ -1110,7 +1133,7 @@ impl<'a> LoweringContext<'a> {\n                                                           ref rhs_ty,\n                                                           span}) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                    id: self.lower_node_id(id),\n+                    id: self.lower_node_id(id).node_id,\n                     lhs_ty: self.lower_ty(lhs_ty),\n                     rhs_ty: self.lower_ty(rhs_ty),\n                     span,\n@@ -1126,16 +1149,16 @@ impl<'a> LoweringContext<'a> {\n                                                .enumerate()\n                                                .map(|f| self.lower_struct_field(f))\n                                                .collect(),\n-                                         self.lower_node_id(id))\n+                                         self.lower_node_id(id).node_id)\n             }\n             VariantData::Tuple(ref fields, id) => {\n                 hir::VariantData::Tuple(fields.iter()\n                                               .enumerate()\n                                               .map(|f| self.lower_struct_field(f))\n                                               .collect(),\n-                                        self.lower_node_id(id))\n+                                        self.lower_node_id(id).node_id)\n             }\n-            VariantData::Unit(id) => hir::VariantData::Unit(self.lower_node_id(id)),\n+            VariantData::Unit(id) => hir::VariantData::Unit(self.lower_node_id(id).node_id),\n         }\n     }\n \n@@ -1146,7 +1169,7 @@ impl<'a> LoweringContext<'a> {\n         };\n         hir::TraitRef {\n             path,\n-            ref_id: self.lower_node_id(p.ref_id),\n+            ref_id: self.lower_node_id(p.ref_id).node_id,\n         }\n     }\n \n@@ -1161,7 +1184,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_struct_field(&mut self, (index, f): (usize, &StructField)) -> hir::StructField {\n         hir::StructField {\n             span: f.span,\n-            id: self.lower_node_id(f.id),\n+            id: self.lower_node_id(f.id).node_id,\n             name: self.lower_ident(match f.ident {\n                 Some(ident) => ident,\n                 // FIXME(jseyfried) positional field hygiene\n@@ -1210,8 +1233,11 @@ impl<'a> LoweringContext<'a> {\n             }\n         }\n \n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(b.id);\n+\n         P(hir::Block {\n-            id: self.lower_node_id(b.id),\n+            id: node_id,\n+            hir_id,\n             stmts: stmts.into(),\n             expr,\n             rules: self.lower_block_check_mode(&b.rules),\n@@ -1261,7 +1287,7 @@ impl<'a> LoweringContext<'a> {\n                                         hir::Visibility::Restricted {\n                                             path: path.clone(),\n                                             // We are allocating a new NodeId here\n-                                            id: this.next_id(),\n+                                            id: this.next_id().node_id,\n                                         }\n                                     }\n                                 };\n@@ -1399,7 +1425,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n         self.with_parent_def(i.id, |this| {\n             hir::TraitItem {\n-                id: this.lower_node_id(i.id),\n+                id: this.lower_node_id(i.id).node_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n@@ -1460,7 +1486,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n         self.with_parent_def(i.id, |this| {\n             hir::ImplItem {\n-                id: this.lower_node_id(i.id),\n+                id: this.lower_node_id(i.id).node_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 vis: this.lower_visibility(&i.vis, None),\n@@ -1552,7 +1578,7 @@ impl<'a> LoweringContext<'a> {\n         });\n \n         Some(hir::Item {\n-            id: self.lower_node_id(i.id),\n+            id: self.lower_node_id(i.id).node_id,\n             name,\n             attrs,\n             node,\n@@ -1564,7 +1590,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> hir::ForeignItem {\n         self.with_parent_def(i.id, |this| {\n             hir::ForeignItem {\n-                id: this.lower_node_id(i.id),\n+                id: this.lower_node_id(i.id).node_id,\n                 name: i.ident.name,\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n@@ -1642,8 +1668,11 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(p.id);\n+\n         P(hir::Pat {\n-            id: self.lower_node_id(p.id),\n+            id: node_id,\n+            hir_id,\n             node: match p.node {\n                 PatKind::Wild => hir::PatKind::Wild,\n                 PatKind::Ident(ref binding_mode, pth1, ref sub) => {\n@@ -1825,7 +1854,7 @@ impl<'a> LoweringContext<'a> {\n                     let call_move_val_init =\n                         hir::StmtSemi(\n                             make_call(self, &move_val_init, hir_vec![ptr, pop_unsafe_expr]),\n-                            self.next_id());\n+                            self.next_id().node_id);\n                     let call_move_val_init = respan(e.span, call_move_val_init);\n \n                     let place = self.expr_ident(e.span, place_ident, place_binding);\n@@ -1895,11 +1924,15 @@ impl<'a> LoweringContext<'a> {\n                             // wrap the if-let expr in a block\n                             let span = els.span;\n                             let els = P(self.lower_expr(els));\n-                            let id = self.next_id();\n+                            let LoweredNodeId {\n+                                node_id,\n+                                hir_id,\n+                            } = self.next_id();\n                             let blk = P(hir::Block {\n                                 stmts: hir_vec![],\n                                 expr: Some(els),\n-                                id,\n+                                id: node_id,\n+                                hir_id,\n                                 rules: hir::DefaultBlock,\n                                 span,\n                                 targeted_by_break: false,\n@@ -2009,8 +2042,11 @@ impl<'a> LoweringContext<'a> {\n                 let struct_path = self.std_path(unstable_span, &struct_path, is_unit);\n                 let struct_path = hir::QPath::Resolved(None, P(struct_path));\n \n+                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+\n                 return hir::Expr {\n-                    id: self.lower_node_id(e.id),\n+                    id: node_id,\n+                    hir_id,\n                     node: if is_unit {\n                         hir::ExprPath(struct_path)\n                     } else {\n@@ -2265,7 +2301,7 @@ impl<'a> LoweringContext<'a> {\n                                                hir::MatchSource::ForLoopDesugar),\n                                 ThinVec::new()))\n                 };\n-                let match_stmt = respan(e.span, hir::StmtExpr(match_expr, self.next_id()));\n+                let match_stmt = respan(e.span, hir::StmtExpr(match_expr, self.next_id().node_id));\n \n                 let next_expr = P(self.expr_ident(e.span, next_ident, next_pat.id));\n \n@@ -2285,7 +2321,7 @@ impl<'a> LoweringContext<'a> {\n                 let body_block = self.with_loop_scope(e.id,\n                                                         |this| this.lower_block(body, false));\n                 let body_expr = P(self.expr_block(body_block, ThinVec::new()));\n-                let body_stmt = respan(e.span, hir::StmtExpr(body_expr, self.next_id()));\n+                let body_stmt = respan(e.span, hir::StmtExpr(body_expr, self.next_id().node_id));\n \n                 let loop_block = P(self.block_all(e.span,\n                                                   hir_vec![next_let,\n@@ -2297,8 +2333,10 @@ impl<'a> LoweringContext<'a> {\n                 // `[opt_ident]: loop { ... }`\n                 let loop_expr = hir::ExprLoop(loop_block, self.lower_opt_sp_ident(opt_ident),\n                                               hir::LoopSource::ForLoop);\n+                let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n                 let loop_expr = P(hir::Expr {\n-                    id: self.lower_node_id(e.id),\n+                    id: node_id,\n+                    hir_id,\n                     node: loop_expr,\n                     span: e.span,\n                     attrs: ThinVec::new(),\n@@ -2437,8 +2475,11 @@ impl<'a> LoweringContext<'a> {\n             ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n         };\n \n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(e.id);\n+\n         hir::Expr {\n-            id: self.lower_node_id(e.id),\n+            id: node_id,\n+            hir_id,\n             node: kind,\n             span: e.span,\n             attrs: e.attrs.clone(),\n@@ -2451,7 +2492,7 @@ impl<'a> LoweringContext<'a> {\n                 node: hir::StmtDecl(P(Spanned {\n                     node: hir::DeclLocal(self.lower_local(l)),\n                     span: s.span,\n-                }), self.lower_node_id(s.id)),\n+                }), self.lower_node_id(s.id).node_id),\n                 span: s.span,\n             },\n             StmtKind::Item(ref it) => {\n@@ -2462,22 +2503,22 @@ impl<'a> LoweringContext<'a> {\n                         node: hir::DeclItem(item_id),\n                         span: s.span,\n                     }), id.take()\n-                          .map(|id| self.lower_node_id(id))\n-                          .unwrap_or_else(|| self.next_id())),\n+                          .map(|id| self.lower_node_id(id).node_id)\n+                          .unwrap_or_else(|| self.next_id().node_id)),\n                     span: s.span,\n                 }).collect();\n             }\n             StmtKind::Expr(ref e) => {\n                 Spanned {\n                     node: hir::StmtExpr(P(self.lower_expr(e)),\n-                                          self.lower_node_id(s.id)),\n+                                          self.lower_node_id(s.id).node_id),\n                     span: s.span,\n                 }\n             }\n             StmtKind::Semi(ref e) => {\n                 Spanned {\n                     node: hir::StmtSemi(P(self.lower_expr(e)),\n-                                          self.lower_node_id(s.id)),\n+                                          self.lower_node_id(s.id).node_id),\n                     span: s.span,\n                 }\n             }\n@@ -2508,9 +2549,9 @@ impl<'a> LoweringContext<'a> {\n                 hir::Visibility::Restricted {\n                     path: P(self.lower_path(id, path, ParamMode::Explicit, true)),\n                     id: if let Some(owner) = explicit_owner {\n-                        self.lower_node_id_with_owner(id, owner)\n+                        self.lower_node_id_with_owner(id, owner).node_id\n                     } else {\n-                        self.lower_node_id(id)\n+                        self.lower_node_id(id).node_id\n                     }\n                 }\n             }\n@@ -2652,8 +2693,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> hir::Expr {\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n         hir::Expr {\n-            id: self.next_id(),\n+            id: node_id,\n+            hir_id,\n             node,\n             span,\n             attrs,\n@@ -2666,17 +2709,20 @@ impl<'a> LoweringContext<'a> {\n                     pat: P<hir::Pat>,\n                     source: hir::LocalSource)\n                     -> hir::Stmt {\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+\n         let local = P(hir::Local {\n             pat,\n             ty: None,\n             init: ex,\n-            id: self.next_id(),\n+            id: node_id,\n+            hir_id,\n             span: sp,\n             attrs: ThinVec::new(),\n             source,\n         });\n         let decl = respan(sp, hir::DeclLocal(local));\n-        respan(sp, hir::StmtDecl(P(decl), self.next_id()))\n+        respan(sp, hir::StmtDecl(P(decl), self.next_id().node_id))\n     }\n \n     fn stmt_let(&mut self, sp: Span, mutbl: bool, ident: Name, ex: P<hir::Expr>)\n@@ -2696,10 +2742,13 @@ impl<'a> LoweringContext<'a> {\n \n     fn block_all(&mut self, span: Span, stmts: hir::HirVec<hir::Stmt>, expr: Option<P<hir::Expr>>)\n                  -> hir::Block {\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+\n         hir::Block {\n             stmts,\n             expr,\n-            id: self.next_id(),\n+            id: node_id,\n+            hir_id,\n             rules: hir::DefaultBlock,\n             span,\n             targeted_by_break: false,\n@@ -2743,18 +2792,22 @@ impl<'a> LoweringContext<'a> {\n \n     fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingAnnotation)\n                               -> P<hir::Pat> {\n-        let id = self.next_id();\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n         let parent_def = self.parent_def.unwrap();\n         let def_id = {\n             let defs = self.resolver.definitions();\n             let def_path_data = DefPathData::Binding(name);\n-            let def_index = defs\n-                .create_def_with_parent(parent_def, id, def_path_data, REGULAR_SPACE, Mark::root());\n+            let def_index = defs.create_def_with_parent(parent_def,\n+                                                        node_id,\n+                                                        def_path_data,\n+                                                        REGULAR_SPACE,\n+                                                        Mark::root());\n             DefId::local(def_index)\n         };\n \n         P(hir::Pat {\n-            id,\n+            id: node_id,\n+            hir_id,\n             node: hir::PatKind::Binding(bm,\n                                         def_id,\n                                         Spanned {\n@@ -2771,8 +2824,10 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn pat(&mut self, span: Span, pat: hir::PatKind) -> P<hir::Pat> {\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n         P(hir::Pat {\n-            id: self.next_id(),\n+            id: node_id,\n+            hir_id,\n             node: pat,\n             span,\n         })\n@@ -2801,11 +2856,13 @@ impl<'a> LoweringContext<'a> {\n                          rule: hir::BlockCheckMode,\n                          attrs: ThinVec<Attribute>)\n                          -> hir::Expr {\n-        let id = self.next_id();\n+        let LoweredNodeId { node_id, hir_id } = self.next_id();\n+\n         let block = P(hir::Block {\n             rules: rule,\n             span,\n-            id,\n+            id: node_id,\n+            hir_id,\n             stmts,\n             expr: Some(expr),\n             targeted_by_break: false,\n@@ -2830,7 +2887,7 @@ impl<'a> LoweringContext<'a> {\n \n                     // The original ID is taken by the `PolyTraitRef`,\n                     // so the `Ty` itself needs a different one.\n-                    id = self.next_id();\n+                    id = self.next_id().node_id;\n \n                     hir::TyTraitObject(hir_vec![principal], self.elided_lifetime(span))\n                 } else {\n@@ -2844,7 +2901,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn elided_lifetime(&mut self, span: Span) -> hir::Lifetime {\n         hir::Lifetime {\n-            id: self.next_id(),\n+            id: self.next_id().node_id,\n             span,\n             name: keywords::Invalid.name()\n         }"}, {"sha": "b371366bc5d5589b5de54be67b052c7583dc7f2a", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -434,18 +434,22 @@ impl Definitions {\n         DefPath::make(LOCAL_CRATE, index, |p| self.def_key(p))\n     }\n \n+    #[inline]\n     pub fn opt_def_index(&self, node: ast::NodeId) -> Option<DefIndex> {\n         self.node_to_def_index.get(&node).cloned()\n     }\n \n+    #[inline]\n     pub fn opt_local_def_id(&self, node: ast::NodeId) -> Option<DefId> {\n         self.opt_def_index(node).map(DefId::local)\n     }\n \n+    #[inline]\n     pub fn local_def_id(&self, node: ast::NodeId) -> DefId {\n         self.opt_local_def_id(node).unwrap()\n     }\n \n+    #[inline]\n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n             let space_index = def_id.index.address_space().index();\n@@ -461,10 +465,27 @@ impl Definitions {\n         }\n     }\n \n+    #[inline]\n     pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n         self.node_to_hir_id[node_id]\n     }\n \n+    pub fn find_node_for_hir_id(&self, hir_id: hir::HirId) -> ast::NodeId {\n+        self.node_to_hir_id\n+            .iter()\n+            .position(|x| *x == hir_id)\n+            .map(|idx| ast::NodeId::new(idx))\n+            .unwrap()\n+    }\n+\n+    #[inline]\n+    pub fn def_index_to_hir_id(&self, def_index: DefIndex) -> hir::HirId {\n+        let space_index = def_index.address_space().index();\n+        let array_index = def_index.as_array_index();\n+        let node_id = self.def_index_to_node[space_index][array_index];\n+        self.node_to_hir_id[node_id]\n+    }\n+\n     /// Add a definition with a parent definition.\n     pub fn create_root_def(&mut self,\n                            crate_name: &str,"}, {"sha": "072da14cdeb2c7db706b4d09152965b2f5c85059", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -250,7 +250,7 @@ pub struct Map<'hir> {\n     pub forest: &'hir Forest,\n \n     /// Same as the dep_graph in forest, just available with one fewer\n-    /// deref. This is a gratuitious micro-optimization.\n+    /// deref. This is a gratuitous micro-optimization.\n     pub dep_graph: DepGraph,\n \n     /// NodeIds are sequential integers from 0, so we can be\n@@ -359,6 +359,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    #[inline]\n     pub fn definitions(&self) -> &Definitions {\n         &self.definitions\n     }\n@@ -379,21 +380,39 @@ impl<'hir> Map<'hir> {\n         self.definitions.def_path(def_id.index)\n     }\n \n+    #[inline]\n     pub fn local_def_id(&self, node: NodeId) -> DefId {\n         self.opt_local_def_id(node).unwrap_or_else(|| {\n             bug!(\"local_def_id: no entry for `{}`, which has a map of `{:?}`\",\n                  node, self.find_entry(node))\n         })\n     }\n \n+    #[inline]\n     pub fn opt_local_def_id(&self, node: NodeId) -> Option<DefId> {\n         self.definitions.opt_local_def_id(node)\n     }\n \n+    #[inline]\n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<NodeId> {\n         self.definitions.as_local_node_id(def_id)\n     }\n \n+    #[inline]\n+    pub fn node_to_hir_id(&self, node_id: NodeId) -> HirId {\n+        self.definitions.node_to_hir_id(node_id)\n+    }\n+\n+    #[inline]\n+    pub fn def_index_to_hir_id(&self, def_index: DefIndex) -> HirId {\n+        self.definitions.def_index_to_hir_id(def_index)\n+    }\n+\n+    #[inline]\n+    pub fn def_index_to_node_id(&self, def_index: DefIndex) -> NodeId {\n+        self.definitions.as_local_node_id(DefId::local(def_index)).unwrap()\n+    }\n+\n     fn entry_count(&self) -> usize {\n         self.map.len()\n     }"}, {"sha": "3704bc36e0be9086f7743d297910cd89a76b6dd1", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -129,9 +129,11 @@ pub const CRATE_HIR_ID: HirId = HirId {\n \n pub const DUMMY_HIR_ID: HirId = HirId {\n     owner: CRATE_DEF_INDEX,\n-    local_id: ItemLocalId(!0)\n+    local_id: DUMMY_ITEM_LOCAL_ID,\n };\n \n+pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId(!0);\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Lifetime {\n     pub id: NodeId,\n@@ -496,7 +498,7 @@ impl Crate {\n         &self.impl_items[&id]\n     }\n \n-    /// Visits all items in the crate in some determinstic (but\n+    /// Visits all items in the crate in some deterministic (but\n     /// unspecified) order. If you just need to process every item,\n     /// but don't care about nesting, this method is the best choice.\n     ///\n@@ -547,6 +549,7 @@ pub struct Block {\n     /// without a semicolon, if any\n     pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n+    pub hir_id: HirId,\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`\n     pub rules: BlockCheckMode,\n     pub span: Span,\n@@ -560,6 +563,7 @@ pub struct Block {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Pat {\n     pub id: NodeId,\n+    pub hir_id: HirId,\n     pub node: PatKind,\n     pub span: Span,\n }\n@@ -897,6 +901,7 @@ pub struct Local {\n     /// Initializer expression to set the value, if any\n     pub init: Option<P<Expr>>,\n     pub id: NodeId,\n+    pub hir_id: HirId,\n     pub span: Span,\n     pub attrs: ThinVec<Attribute>,\n     pub source: LocalSource,\n@@ -987,6 +992,7 @@ pub struct Expr {\n     pub span: Span,\n     pub node: Expr_,\n     pub attrs: ThinVec<Attribute>,\n+    pub hir_id: HirId,\n }\n \n impl fmt::Debug for Expr {\n@@ -1430,6 +1436,7 @@ pub struct InlineAsm {\n pub struct Arg {\n     pub pat: P<Pat>,\n     pub id: NodeId,\n+    pub hir_id: HirId,\n }\n \n /// Represents the header (not the body) of a function declaration"}, {"sha": "218483232d673f66f362f9a565a1808f677a9681", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -14,7 +14,7 @@ use hir::map::DefPathHash;\n use ich::{self, CachingCodemapView};\n use session::config::DebugInfoLevel::NoDebugInfo;\n use ty;\n-use util::nodemap::NodeMap;\n+use util::nodemap::{NodeMap, ItemLocalMap};\n \n use std::hash as std_hash;\n use std::collections::{HashMap, HashSet, BTreeMap};\n@@ -358,6 +358,18 @@ pub fn hash_stable_nodemap<'a, 'tcx, 'gcx, V, W>(\n     });\n }\n \n+pub fn hash_stable_itemlocalmap<'a, 'tcx, 'gcx, V, W>(\n+    hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+    hasher: &mut StableHasher<W>,\n+    map: &ItemLocalMap<V>)\n+    where V: HashStable<StableHashingContext<'a, 'gcx, 'tcx>>,\n+          W: StableHasherResult,\n+{\n+    hash_stable_hashmap(hcx, hasher, map, |_, local_id| {\n+        *local_id\n+    });\n+}\n+\n \n pub fn hash_stable_btreemap<'a, 'tcx, 'gcx, K, V, SK, F, W>(\n     hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,"}, {"sha": "96bfbbaf87033af56d395d3d03d0bbd7a9211024", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -359,6 +359,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::B\n             ref stmts,\n             ref expr,\n             id,\n+            hir_id: _,\n             rules,\n             span,\n             targeted_by_break,\n@@ -423,6 +424,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::P\n \n         let hir::Pat {\n             id,\n+            hir_id: _,\n             ref node,\n             ref span\n         } = *self;\n@@ -504,6 +506,7 @@ impl_stable_hash_for!(struct hir::Local {\n     ty,\n     init,\n     id,\n+    hir_id,\n     span,\n     attrs,\n     source\n@@ -551,6 +554,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::E\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n                 id,\n+                hir_id: _,\n                 ref span,\n                 ref node,\n                 ref attrs\n@@ -1023,7 +1027,8 @@ impl_stable_hash_for!(enum hir::Stmt_ {\n \n impl_stable_hash_for!(struct hir::Arg {\n     pat,\n-    id\n+    id,\n+    hir_id\n });\n \n impl_stable_hash_for!(struct hir::Body {"}, {"sha": "9416427f05f9fe4dc8ffcfad1dcec3acb41a5601", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 63, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -11,7 +11,7 @@\n //! This module contains `HashStable` implementations for various data types\n //! from rustc::ty in no particular order.\n \n-use ich::{self, StableHashingContext, NodeIdHashingMode};\n+use ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n                                            StableHasherResult};\n use std::hash as std_hash;\n@@ -624,68 +624,6 @@ impl_stable_hash_for!(struct ty::ExistentialProjection<'tcx> {\n     ty\n });\n \n-\n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n-for ty::TypeckTables<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::TypeckTables {\n-            ref type_dependent_defs,\n-            ref node_types,\n-            ref node_substs,\n-            ref adjustments,\n-            ref pat_binding_modes,\n-            ref upvar_capture_map,\n-            ref closure_tys,\n-            ref closure_kinds,\n-            ref generator_interiors,\n-            ref generator_sigs,\n-            ref liberated_fn_sigs,\n-            ref fru_field_types,\n-\n-            ref cast_kinds,\n-\n-            ref used_trait_imports,\n-            tainted_by_errors,\n-            ref free_region_map,\n-        } = *self;\n-\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n-            ich::hash_stable_nodemap(hcx, hasher, type_dependent_defs);\n-            ich::hash_stable_nodemap(hcx, hasher, node_types);\n-            ich::hash_stable_nodemap(hcx, hasher, node_substs);\n-            ich::hash_stable_nodemap(hcx, hasher, adjustments);\n-            ich::hash_stable_nodemap(hcx, hasher, pat_binding_modes);\n-            ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n-                let ty::UpvarId {\n-                    var_id,\n-                    closure_expr_id\n-                } = *up_var_id;\n-\n-                let var_def_id = hcx.tcx().hir.local_def_id(var_id);\n-                let closure_def_id = hcx.tcx().hir.local_def_id(closure_expr_id);\n-                (hcx.def_path_hash(var_def_id), hcx.def_path_hash(closure_def_id))\n-            });\n-\n-            ich::hash_stable_nodemap(hcx, hasher, closure_tys);\n-            ich::hash_stable_nodemap(hcx, hasher, closure_kinds);\n-            ich::hash_stable_nodemap(hcx, hasher, generator_interiors);\n-            ich::hash_stable_nodemap(hcx, hasher, generator_sigs);\n-            ich::hash_stable_nodemap(hcx, hasher, liberated_fn_sigs);\n-            ich::hash_stable_nodemap(hcx, hasher, fru_field_types);\n-            ich::hash_stable_nodemap(hcx, hasher, cast_kinds);\n-\n-            ich::hash_stable_hashset(hcx, hasher, used_trait_imports, |hcx, def_id| {\n-                hcx.def_path_hash(*def_id)\n-            });\n-\n-            tainted_by_errors.hash_stable(hcx, hasher);\n-            free_region_map.hash_stable(hcx, hasher);\n-        })\n-    }\n-}\n-\n impl_stable_hash_for!(enum ty::fast_reject::SimplifiedType {\n     BoolSimplifiedType,\n     CharSimplifiedType,"}, {"sha": "dcf84be0eeb3ad192fd6c0b0cc6256fb0bc14c44", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -14,7 +14,7 @@ pub use self::fingerprint::Fingerprint;\n pub use self::caching_codemap_view::CachingCodemapView;\n pub use self::hcx::{StableHashingContext, NodeIdHashingMode, hash_stable_hashmap,\n                     hash_stable_hashset, hash_stable_nodemap,\n-                    hash_stable_btreemap};\n+                    hash_stable_btreemap, hash_stable_itemlocalmap};\n mod fingerprint;\n mod caching_codemap_view;\n mod hcx;"}, {"sha": "3fd7ee276729f392ff93ace1d3c5885e6bd53fa3", "filename": "src/librustc/infer/at.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fat.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -169,7 +169,7 @@ impl<'a, 'gcx, 'tcx> At<'a, 'gcx, 'tcx> {\n     }\n \n     /// Sets the \"trace\" values that will be used for\n-    /// error-repporting, but doesn't actually perform any operation\n+    /// error-reporting, but doesn't actually perform any operation\n     /// yet (this is useful when you want to set the trace using\n     /// distinct values from those you wish to operate upon).\n     pub fn trace<T>(self,"}, {"sha": "b5390da7e852d184158109fae5afb6e16c733529", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -913,7 +913,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n             infer::UpvarRegion(ref upvar_id, _) => {\n                 format!(\" for capture of `{}` by closure\",\n-                        self.tcx.local_var_name_str(upvar_id.var_id).to_string())\n+                        self.tcx.local_var_name_str_def_index(upvar_id.var_id))\n             }\n         };\n "}, {"sha": "22d9a9e313b77b1f7fa256a05f0bf65d5da6ff88", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -8,13 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::{self, Local, Pat, Body};\n+use hir::{self, Local, Pat, Body, HirId};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use infer::InferCtxt;\n use infer::type_variable::TypeVariableOrigin;\n use ty::{self, Ty, TyInfer, TyVar};\n-\n-use syntax::ast::NodeId;\n use syntax_pos::Span;\n \n struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n@@ -26,7 +24,7 @@ struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n-    fn node_matches_type(&mut self, node_id: NodeId) -> bool {\n+    fn node_matches_type(&mut self, node_id: HirId) -> bool {\n         let ty_opt = self.infcx.in_progress_tables.and_then(|tables| {\n             tables.borrow().node_id_to_type_opt(node_id)\n         });\n@@ -56,15 +54,15 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n     }\n \n     fn visit_local(&mut self, local: &'gcx Local) {\n-        if self.found_local_pattern.is_none() && self.node_matches_type(local.id) {\n+        if self.found_local_pattern.is_none() && self.node_matches_type(local.hir_id) {\n             self.found_local_pattern = Some(&*local.pat);\n         }\n         intravisit::walk_local(self, local);\n     }\n \n     fn visit_body(&mut self, body: &'gcx Body) {\n         for argument in &body.arguments {\n-            if self.found_arg_pattern.is_none() && self.node_matches_type(argument.id) {\n+            if self.found_arg_pattern.is_none() && self.node_matches_type(argument.hir_id) {\n                 self.found_arg_pattern = Some(&*argument.pat);\n             }\n         }"}, {"sha": "87047d0df144cca40f03a3f0c83ba835545f8a8d", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -45,8 +45,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 err.span_note(span,\n                               &format!(\"...so that closure can access `{}`\",\n                                        self.tcx\n-                                           .local_var_name_str(upvar_id.var_id)\n-                                           .to_string()));\n+                                           .local_var_name_str_def_index(upvar_id.var_id)));\n             }\n             infer::InfStackClosure(span) => {\n                 err.span_note(span, \"...so that closure does not outlive its stack frame\");\n@@ -176,18 +175,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                E0313,\n                                                \"lifetime of borrowed pointer outlives lifetime \\\n                                                 of captured variable `{}`...\",\n-                                               self.tcx.local_var_name_str(upvar_id.var_id));\n+                                               self.tcx\n+                                                   .local_var_name_str_def_index(upvar_id.var_id));\n                 self.tcx.note_and_explain_region(&mut err,\n                                                  \"...the borrowed pointer is valid for \",\n                                                  sub,\n                                                  \"...\");\n                 self.tcx\n-                    .note_and_explain_region(&mut err,\n-                                             &format!(\"...but `{}` is only valid for \",\n-                                                      self.tcx\n-                                                          .local_var_name_str(upvar_id.var_id)),\n-                                             sup,\n-                                             \"\");\n+                    .note_and_explain_region(\n+                      &mut err,\n+                      &format!(\"...but `{}` is only valid for \",\n+                               self.tcx.local_var_name_str_def_index(upvar_id.var_id)),\n+                      sup,\n+                      \"\");\n                 err\n             }\n             infer::InfStackClosure(span) => {"}, {"sha": "c8f78367420e64e0c00a52c98cb80bdb6999bbb1", "filename": "src/librustc/infer/error_reporting/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Futil.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             .iter()\n                             .enumerate()\n                             .filter_map(|(index, arg)| {\n-                                let ty = tables.borrow().node_id_to_type(arg.id);\n+                                let ty = tables.borrow().node_id_to_type(arg.hir_id);\n                                 let mut found_anon_region = false;\n                                 let new_arg_ty = self.tcx\n                                     .fold_regions(&ty, &mut false, |r, _| if *r == *anon_region {"}, {"sha": "0d02420457e6b76aa31963d6aba895c3aae31a94", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -589,7 +589,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         (result, map)\n     }\n \n-    /// Searches the region constriants created since `snapshot` was started\n+    /// Searches the region constraints created since `snapshot` was started\n     /// and checks to determine whether any of the skolemized regions created\n     /// in `skol_map` would \"escape\" -- meaning that they are related to\n     /// other regions in some way. If so, the higher-ranked subtyping doesn't"}, {"sha": "d5c1163cfc1b1cf52a822ec9d08725a1133a755d", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -46,7 +46,7 @@ pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'f, 'gcx, 'tcx>\n     // the LUB/GLB of `a` and `b` as appropriate.\n     //\n     // Subtle hack: ordering *may* be significant here. This method\n-    // relates `v` to `a` first, which may help us to avoid unecessary\n+    // relates `v` to `a` first, which may help us to avoid unnecessary\n     // type variable obligations. See caller for details.\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n }"}, {"sha": "11f3da3c2081ef2d70b2fc45471c6974e08a00a6", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -358,8 +358,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n     /// Used only by `rustc_typeck` during body type-checking/inference,\n     /// will initialize `in_progress_tables` with fresh `TypeckTables`.\n-    pub fn with_fresh_in_progress_tables(mut self) -> Self {\n-        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty()));\n+    pub fn with_fresh_in_progress_tables(mut self, table_owner: DefId) -> Self {\n+        self.fresh_tables = Some(RefCell::new(ty::TypeckTables::empty(Some(table_owner))));\n         self\n     }\n \n@@ -1331,9 +1331,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     {\n         if let Some(tables) = self.in_progress_tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n                 return tables.borrow()\n-                             .closure_kinds\n-                             .get(&id)\n+                             .closure_kinds()\n+                             .get(hir_id)\n                              .cloned()\n                              .map(|(kind, _)| kind);\n             }\n@@ -1353,7 +1354,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn fn_sig(&self, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n         if let Some(tables) = self.in_progress_tables {\n             if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                if let Some(&ty) = tables.borrow().closure_tys.get(&id) {\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                if let Some(&ty) = tables.borrow().closure_tys().get(hir_id) {\n                     return ty;\n                 }\n             }"}, {"sha": "5588b6d9add166a10c86bf8c6b2e6cfc48c8ea52", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -128,7 +128,7 @@ pub enum UndoLogEntry<'tcx> {\n     /// We added the given `given`\n     AddGiven(Region<'tcx>, ty::RegionVid),\n \n-    /// We added a GLB/LUB \"combinaton variable\"\n+    /// We added a GLB/LUB \"combination variable\"\n     AddCombination(CombineMapType, TwoRegions<'tcx>),\n \n     /// During skolemization, we sometimes purge entries from the undo"}, {"sha": "6a1f8f1d069270ae341a25fab29440b8cc12fbe4", "filename": "src/librustc/infer/resolve.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fresolve.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -111,8 +111,10 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.needs_infer() {\n+        if !t.needs_infer() && !ty::keep_local(&t) {\n             t // micro-optimize -- if there is nothing in this type that this fold affects...\n+                // ^ we need to have the `keep_local` check to un-default\n+                // defaulted tuples.\n         } else {\n             let t = self.infcx.shallow_resolve(t);\n             match t.sty {\n@@ -131,6 +133,12 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for FullTypeResolver<'a, 'gcx, 'tcx>\n                 ty::TyInfer(_) => {\n                     bug!(\"Unexpected type in full type resolver: {:?}\", t);\n                 }\n+                ty::TyTuple(tys, true) => {\n+                    // Un-default defaulted tuples - we are going to a\n+                    // different infcx, and the default will just cause\n+                    // pollution.\n+                    self.tcx().intern_tup(tys, false)\n+                }\n                 _ => {\n                     t.super_fold_with(self)\n                 }"}, {"sha": "40d78d0138bb266cc9c60bacc06a7f4cd7c875c6", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -69,7 +69,7 @@ pub struct LintStore {\n     /// is true if the lint group was added by a plugin.\n     lint_groups: FxHashMap<&'static str, (Vec<LintId>, bool)>,\n \n-    /// Extra info for future incompatibility lints, descibing the\n+    /// Extra info for future incompatibility lints, describing the\n     /// issue or RFC that caused the incompatibility.\n     future_incompatible: FxHashMap<LintId, FutureIncompatibleInfo>,\n }\n@@ -986,7 +986,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n \n     let mut cx = LateContext {\n         tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(None),\n         param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n         access_levels,\n         lint_sess: LintSession::new(&tcx.sess.lint_store),"}, {"sha": "8a2b115e58d3d083b1abf9532f13120a803e20c2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -94,8 +94,8 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn lookup_and_handle_method(&mut self, id: ast::NodeId) {\n-        self.check_def_id(self.tables.type_dependent_defs[&id].def_id());\n+    fn lookup_and_handle_method(&mut self, id: hir::HirId) {\n+        self.check_def_id(self.tables.type_dependent_defs()[id].def_id());\n     }\n \n     fn handle_field_access(&mut self, lhs: &hir::Expr, name: ast::Name) {\n@@ -119,7 +119,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, def: Def,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n-        let variant = match self.tables.node_id_to_type(lhs.id).sty {\n+        let variant = match self.tables.node_id_to_type(lhs.hir_id).sty {\n             ty::TyAdt(adt, _) => adt.variant_of_def(def),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n@@ -235,11 +235,11 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprPath(ref qpath @ hir::QPath::TypeRelative(..)) => {\n-                let def = self.tables.qpath_def(qpath, expr.id);\n+                let def = self.tables.qpath_def(qpath, expr.hir_id);\n                 self.handle_definition(def);\n             }\n             hir::ExprMethodCall(..) => {\n-                self.lookup_and_handle_method(expr.id);\n+                self.lookup_and_handle_method(expr.hir_id);\n             }\n             hir::ExprField(ref lhs, ref name) => {\n                 self.handle_field_access(&lhs, name.node);\n@@ -282,7 +282,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 self.handle_field_pattern_match(pat, path.def, fields);\n             }\n             PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n-                let def = self.tables.qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n                 self.handle_definition(def);\n             }\n             _ => ()\n@@ -425,7 +425,7 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n         tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(None),\n         live_symbols: box FxHashSet(),\n         struct_has_extern_repr: false,\n         ignore_non_const_paths: false,"}, {"sha": "98934d607032840780a28ecf72729fecad7d020b", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n-                let def_id = self.tables.type_dependent_defs[&expr.id].def_id();\n+                let def_id = self.tables.type_dependent_defs()[expr.hir_id].def_id();\n                 let sig = self.tcx.fn_sig(def_id);\n                 debug!(\"effect: method call case, signature is {:?}\",\n                         sig);\n@@ -262,7 +262,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let mut visitor = EffectCheckVisitor {\n         tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(None),\n         body_id: hir::BodyId { node_id: ast::CRATE_NODE_ID },\n         unsafe_context: UnsafeContext::new(SafeContext),\n     };"}, {"sha": "e36e1f470eb699ed015568e68ff9025fe921f0a9", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -296,7 +296,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"consume_body(body={:?})\", body);\n \n         for arg in &body.arguments {\n-            let arg_ty = return_if_err!(self.mc.node_ty(arg.pat.id));\n+            let arg_ty = return_if_err!(self.mc.node_ty(arg.pat.hir_id));\n \n             let fn_body_scope_r = self.tcx().node_scope_region(body.value.id);\n             let arg_cmt = self.mc.cat_rvalue(\n@@ -541,7 +541,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             }\n             ty::TyError => { }\n             _ => {\n-                let def_id = self.mc.tables.type_dependent_defs[&call.id].def_id();\n+                let def_id = self.mc.tables.type_dependent_defs()[call.hir_id].def_id();\n                 match OverloadedCallType::from_method_id(self.tcx(), def_id) {\n                     FnMutOverloadedCall => {\n                         let call_scope_r = self.tcx().node_scope_region(call.id);\n@@ -801,7 +801,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                pat);\n         return_if_err!(self.mc.cat_pattern(cmt_discr, pat, |cmt_pat, pat| {\n             if let PatKind::Binding(..) = pat.node {\n-                let bm = *self.mc.tables.pat_binding_modes.get(&pat.id)\n+                let bm = *self.mc.tables.pat_binding_modes().get(pat.hir_id)\n                                                           .expect(\"missing binding mode\");\n                 match bm {\n                     ty::BindByReference(..) =>\n@@ -827,10 +827,11 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |cmt_pat, pat| {\n             if let PatKind::Binding(_, def_id, ..) = pat.node {\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n-                let bm = *mc.tables.pat_binding_modes.get(&pat.id).expect(\"missing binding mode\");\n+                let bm = *mc.tables.pat_binding_modes().get(pat.hir_id)\n+                                                     .expect(\"missing binding mode\");\n \n                 // pat_ty: the type of the binding being produced.\n-                let pat_ty = return_if_err!(mc.node_ty(pat.id));\n+                let pat_ty = return_if_err!(mc.node_ty(pat.hir_id));\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n@@ -867,7 +868,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 PatKind::Struct(ref qpath, ..) => qpath,\n                 _ => return\n             };\n-            let def = mc.tables.qpath_def(qpath, pat.id);\n+            let def = mc.tables.qpath_def(qpath, pat.hir_id);\n             match def {\n                 Def::Variant(variant_did) |\n                 Def::VariantCtor(variant_did, ..) => {\n@@ -891,10 +892,13 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n \n         self.tcx().with_freevars(closure_expr.id, |freevars| {\n             for freevar in freevars {\n-                let def_id = freevar.def.def_id();\n-                let id_var = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-                let upvar_id = ty::UpvarId { var_id: id_var,\n-                                             closure_expr_id: closure_expr.id };\n+                let var_def_id = freevar.def.def_id();\n+                debug_assert!(var_def_id.is_local());\n+                let closure_def_id = self.tcx().hir.local_def_id(closure_expr.id);\n+                let upvar_id = ty::UpvarId {\n+                    var_id: var_def_id.index,\n+                    closure_expr_id: closure_def_id.index\n+                };\n                 let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n                 let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,\n                                                                    fn_decl_span,\n@@ -927,8 +931,9 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                         -> mc::McResult<mc::cmt<'tcx>> {\n         // Create the cmt for the variable being borrowed, from the\n         // caller's perspective\n-        let var_id = self.tcx().hir.as_local_node_id(upvar_def.def_id()).unwrap();\n-        let var_ty = self.mc.node_ty(var_id)?;\n+        let var_node_id = self.tcx().hir.as_local_node_id(upvar_def.def_id()).unwrap();\n+        let var_hir_id = self.tcx().hir.node_to_hir_id(var_node_id);\n+        let var_ty = self.mc.node_ty(var_hir_id)?;\n         self.mc.cat_def(closure_id, closure_span, var_ty, upvar_def)\n     }\n }"}, {"sha": "0a4e5094cde773b949a07f9ea8b4215b4e581a35", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -146,13 +146,13 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         let def = if let hir::ExprPath(ref qpath) = expr.node {\n-            self.tables.qpath_def(qpath, expr.id)\n+            self.tables.qpath_def(qpath, expr.hir_id)\n         } else {\n             Def::Err\n         };\n         if let Def::Fn(did) = def {\n             if self.def_id_is_transmute(did) {\n-                let typ = self.tables.node_id_to_type(expr.id);\n+                let typ = self.tables.node_id_to_type(expr.hir_id);\n                 let sig = typ.fn_sig(self.tcx);\n                 let from = sig.inputs().skip_binder()[0];\n                 let to = *sig.output().skip_binder();"}, {"sha": "354930be441fa1a3e5589457390589894edc749d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -70,7 +70,7 @@ pub use self::Note::*;\n use self::Aliasability::*;\n \n use middle::region::RegionMaps;\n-use hir::def_id::DefId;\n+use hir::def_id::{DefId, DefIndex};\n use hir::map as hir_map;\n use infer::InferCtxt;\n use hir::def::{Def, CtorKind};\n@@ -190,7 +190,7 @@ pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n pub enum ImmutabilityBlame<'tcx> {\n     ImmLocal(ast::NodeId),\n-    ClosureEnv(ast::NodeId),\n+    ClosureEnv(DefIndex),\n     LocalDeref(ast::NodeId),\n     AdtFieldDeref(&'tcx ty::AdtDef, &'tcx ty::FieldDef)\n }\n@@ -334,7 +334,9 @@ impl MutabilityCategory {\n         let ret = match tcx.hir.get(id) {\n             hir_map::NodeLocal(p) => match p.node {\n                 PatKind::Binding(..) => {\n-                    let bm = *tables.pat_binding_modes.get(&p.id).expect(\"missing binding mode\");\n+                    let bm = *tables.pat_binding_modes()\n+                                    .get(p.hir_id)\n+                                    .expect(\"missing binding mode\");\n                     if bm == ty::BindByValue(hir::MutMutable) {\n                         McDeclared\n                     } else {\n@@ -435,7 +437,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn resolve_type_vars_or_error(&self,\n-                                  id: ast::NodeId,\n+                                  id: hir::HirId,\n                                   ty: Option<Ty<'tcx>>)\n                                   -> McResult<Ty<'tcx>> {\n         match ty {\n@@ -451,33 +453,41 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // FIXME\n             None if self.is_tainted_by_errors() => Err(()),\n             None => {\n+                let id = self.tcx.hir.definitions().find_node_for_hir_id(id);\n                 bug!(\"no type for node {}: {} in mem_categorization\",\n                      id, self.tcx.hir.node_to_string(id));\n             }\n         }\n     }\n \n-    pub fn node_ty(&self, id: ast::NodeId) -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(id, self.tables.node_id_to_type_opt(id))\n+    pub fn node_ty(&self,\n+                   hir_id: hir::HirId)\n+                   -> McResult<Ty<'tcx>> {\n+        self.resolve_type_vars_or_error(hir_id,\n+                                        self.tables.node_id_to_type_opt(hir_id))\n     }\n \n     pub fn expr_ty(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(expr.id, self.tables.expr_ty_opt(expr))\n+        self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_opt(expr))\n     }\n \n     pub fn expr_ty_adjusted(&self, expr: &hir::Expr) -> McResult<Ty<'tcx>> {\n-        self.resolve_type_vars_or_error(expr.id, self.tables.expr_ty_adjusted_opt(expr))\n+        self.resolve_type_vars_or_error(expr.hir_id, self.tables.expr_ty_adjusted_opt(expr))\n     }\n \n     fn pat_ty(&self, pat: &hir::Pat) -> McResult<Ty<'tcx>> {\n-        let base_ty = self.node_ty(pat.id)?;\n+        let base_ty = self.node_ty(pat.hir_id)?;\n         // FIXME (Issue #18207): This code detects whether we are\n         // looking at a `ref x`, and if so, figures out what the type\n         // *being borrowed* is.  But ideally we would put in a more\n         // fundamental fix to this conflated use of the node id.\n         let ret_ty = match pat.node {\n             PatKind::Binding(..) => {\n-                let bm = *self.tables.pat_binding_modes.get(&pat.id).expect(\"missing binding mode\");\n+                let bm = *self.tables\n+                              .pat_binding_modes()\n+                              .get(pat.hir_id)\n+                              .expect(\"missing binding mode\");\n+\n                 if let ty::BindByReference(_) = bm {\n                     // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                     // but what we want here is the type of the underlying value being borrowed.\n@@ -604,7 +614,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n           }\n \n           hir::ExprPath(ref qpath) => {\n-            let def = self.tables.qpath_def(qpath, expr.id);\n+            let def = self.tables.qpath_def(qpath, expr.hir_id);\n             self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n@@ -643,7 +653,13 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 Ok(self.cat_rvalue_node(id, span, expr_ty))\n           }\n \n-          Def::Static(_, mutbl) => {\n+          Def::Static(def_id, mutbl) => {\n+            // `#[thread_local]` statics may not outlive the current function.\n+            for attr in &self.tcx.get_attrs(def_id)[..] {\n+                if attr.check_name(\"thread_local\") {\n+                    return Ok(self.cat_rvalue_node(id, span, expr_ty));\n+                }\n+            }\n               Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,\n@@ -684,6 +700,8 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                  fn_node_id: ast::NodeId)\n                  -> McResult<cmt<'tcx>>\n     {\n+        let fn_hir_id = self.tcx.hir.node_to_hir_id(fn_node_id);\n+\n         // An upvar can have up to 3 components. We translate first to a\n         // `Categorization::Upvar`, which is itself a fiction -- it represents the reference to the\n         // field from the environment.\n@@ -707,7 +725,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // FnMut          | copied -> &'env mut  | upvar -> &'env mut -> &'up bk\n         // FnOnce         | copied               | upvar -> &'up bk\n \n-        let kind = match self.tables.closure_kinds.get(&fn_node_id) {\n+        let kind = match self.tables.closure_kinds().get(fn_hir_id) {\n             Some(&(kind, _)) => kind,\n             None => {\n                 let ty = self.node_ty(fn_node_id)?;\n@@ -718,9 +736,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let upvar_id = ty::UpvarId { var_id,\n-                                     closure_expr_id: fn_node_id };\n-        let var_ty = self.node_ty(var_id)?;\n+        let closure_expr_def_index = self.tcx.hir.local_def_id(fn_node_id).index;\n+        let var_def_index = self.tcx.hir.local_def_id(var_id).index;\n+\n+        let upvar_id = ty::UpvarId {\n+            var_id: var_def_index,\n+            closure_expr_id: closure_expr_def_index\n+        };\n+        let var_hir_id = self.tcx.hir.node_to_hir_id(var_id);\n+        let var_ty = self.node_ty(var_hir_id)?;\n \n         // Mutability of original variable itself\n         let var_mutbl = MutabilityCategory::from_local(self.tcx, self.tables, var_id);\n@@ -755,8 +779,6 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         // If this is a by-ref capture, then the upvar we loaded is\n         // actually a reference, so we have to add an implicit deref\n         // for that.\n-        let upvar_id = ty::UpvarId { var_id,\n-                                     closure_expr_id: fn_node_id };\n         let upvar_capture = self.tables.upvar_capture(upvar_id);\n         let cmt_result = match upvar_capture {\n             ty::UpvarCapture::ByValue => {\n@@ -794,7 +816,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n-            scope: self.tcx.hir.local_def_id(upvar_id.closure_expr_id),\n+            scope: DefId::local(upvar_id.closure_expr_id),\n             bound_region: ty::BrEnv\n         }));\n \n@@ -1130,7 +1152,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         match pat.node {\n           PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n-            let def = self.tables.qpath_def(qpath, pat.id);\n+            let def = self.tables.qpath_def(qpath, pat.hir_id);\n             let (cmt, expected_len) = match def {\n                 Def::Err => {\n                     debug!(\"access to unresolvable pattern {:?}\", pat);\n@@ -1167,7 +1189,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n           PatKind::Struct(ref qpath, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n-            let def = self.tables.qpath_def(qpath, pat.id);\n+            let def = self.tables.qpath_def(qpath, pat.hir_id);\n             let cmt = match def {\n                 Def::Err => {\n                     debug!(\"access to unresolvable pattern {:?}\", pat);"}, {"sha": "666f71cca06bb60e69eca0729b9321e516072062", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -107,10 +107,10 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         let def = match expr.node {\n             hir::ExprPath(ref qpath) => {\n-                Some(self.tables.qpath_def(qpath, expr.id))\n+                Some(self.tables.qpath_def(qpath, expr.hir_id))\n             }\n             hir::ExprMethodCall(..) => {\n-                Some(self.tables.type_dependent_defs[&expr.id])\n+                Some(self.tables.type_dependent_defs()[expr.hir_id])\n             }\n             _ => None\n         };\n@@ -296,6 +296,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Type(_) => {}\n                 }\n             }\n+            hir_map::NodeExpr(&hir::Expr { node: hir::ExprClosure(.., body, _), .. }) => {\n+                self.visit_nested_body(body);\n+            }\n             // Nothing to recurse on for these\n             hir_map::NodeForeignItem(_) |\n             hir_map::NodeVariant(_) |\n@@ -375,7 +378,7 @@ fn reachable_set<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum) ->\n     });\n     let mut reachable_context = ReachableContext {\n         tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(None),\n         reachable_symbols: NodeSet(),\n         worklist: Vec::new(),\n         any_library,"}, {"sha": "abfff023e892f9d9485573ed9d316bc019a57aa4", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -764,7 +764,7 @@ impl<'tcx> Debug for TerminatorKind<'tcx> {\n \n impl<'tcx> TerminatorKind<'tcx> {\n     /// Write the \"head\" part of the terminator; that is, its name and the data it uses to pick the\n-    /// successor basic block, if any. The only information not inlcuded is the list of possible\n+    /// successor basic block, if any. The only information not included is the list of possible\n     /// successors, which may be rendered differently between the text and the graphviz format.\n     pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> fmt::Result {\n         use self::TerminatorKind::*;"}, {"sha": "3aea0722d0e2f8c7c904e01e19221ffdcb560c45", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -112,7 +112,7 @@ pub struct Session {\n \n     /// Map from imported macro spans (which consist of\n     /// the localized span for the macro body) to the\n-    /// macro name and defintion span in the source crate.\n+    /// macro name and definition span in the source crate.\n     pub imported_macro_spans: RefCell<HashMap<Span, (String, Span)>>,\n \n     incr_comp_session: RefCell<IncrCompSession>,\n@@ -828,7 +828,7 @@ pub fn compile_result_from_err_count(err_count: usize) -> CompileResult {\n #[inline(never)]\n pub fn bug_fmt(file: &'static str, line: u32, args: fmt::Arguments) -> ! {\n     // this wrapper mostly exists so I don't have to write a fully\n-    // qualified path of None::<Span> inside the bug!() macro defintion\n+    // qualified path of None::<Span> inside the bug!() macro definition\n     opt_span_bug_fmt(file, line, None::<Span>, args);\n }\n "}, {"sha": "c147c9d56368e107f6ce01a36cc0cca848cc18b7", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -111,8 +111,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    // returns if `cond` not occuring implies that `error` does not occur - i.e. that\n-    // `error` occuring implies that `cond` occurs.\n+    // returns if `cond` not occurring implies that `error` does not occur - i.e. that\n+    // `error` occurring implies that `cond` occurs.\n     fn error_implies(&self,\n                      cond: &ty::Predicate<'tcx>,\n                      error: &ty::Predicate<'tcx>)\n@@ -683,7 +683,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         // Additional context information explaining why the closure only implements\n                         // a particular trait.\n                         if let Some(tables) = self.in_progress_tables {\n-                            match tables.borrow().closure_kinds.get(&node_id) {\n+                            let tables = tables.borrow();\n+                            let closure_hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+                            match tables.closure_kinds().get(closure_hir_id) {\n                                 Some(&(ty::ClosureKind::FnOnce, Some((span, name)))) => {\n                                     err.span_note(span, &format!(\n                                         \"closure is `FnOnce` because it moves the \\"}, {"sha": "ebb6466aa32d004cf104f4b4fd0247c4eeca7317", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -1422,7 +1422,7 @@ impl<'tcx> ProjectionCache<'tcx> {\n     }\n \n     /// Try to start normalize `key`; returns an error if\n-    /// normalization already occured (this error corresponds to a\n+    /// normalization already occurred (this error corresponds to a\n     /// cache hit, so it's actually a good thing).\n     fn try_start(&mut self, key: ty::ProjectionTy<'tcx>)\n                  -> Result<(), ProjectionCacheEntry<'tcx>> {"}, {"sha": "8b31cb599e45dbbaa7f62505af2bcac537f47b2f", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -31,7 +31,7 @@ use util::nodemap::{DefIdMap, FxHashMap};\n ///\n /// - Parent extraction. In particular, the graph can give you the *immediate*\n ///   parents of a given specializing impl, which is needed for extracting\n-///   default items amongst other thigns. In the simple \"chain\" rule, every impl\n+///   default items amongst other things. In the simple \"chain\" rule, every impl\n ///   has at most one parent.\n pub struct Graph {\n     // all impls have a parent; the \"root\" impls have as their parent the def_id\n@@ -95,7 +95,7 @@ impl<'a, 'gcx, 'tcx> Children {\n     }\n \n     /// Attempt to insert an impl into this set of children, while comparing for\n-    /// specialiation relationships.\n+    /// specialization relationships.\n     fn insert(&mut self,\n               tcx: TyCtxt<'a, 'gcx, 'tcx>,\n               impl_def_id: DefId,\n@@ -206,7 +206,7 @@ impl<'a, 'gcx, 'tcx> Graph {\n \n         // if the reference itself contains an earlier error (e.g., due to a\n         // resolution failure), then we just insert the impl at the top level of\n-        // the graph and claim that there's no overlap (in order to supress\n+        // the graph and claim that there's no overlap (in order to suppress\n         // bogus errors).\n         if trait_ref.references_error() {\n             debug!(\"insert: inserting dummy node for erroneous TraitRef {:?}, \\"}, {"sha": "51436660779551319fa781d039d62c8a105880cd", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -29,7 +29,7 @@ use ty::subst::Substs;\n /// by `autoref`, to either a raw or borrowed pointer. In these cases unsize is\n /// `false`.\n ///\n-/// 2. A thin-to-fat coercon involves unsizing the underlying data. We start\n+/// 2. A thin-to-fat coercion involves unsizing the underlying data. We start\n /// with a thin pointer, deref a number of times, unsize the underlying data,\n /// then autoref. The 'unsize' phase may change a fixed length array to a\n /// dynamically sized one, a concrete object to a trait object, or statically\n@@ -52,7 +52,7 @@ use ty::subst::Substs;\n /// that case, we have the pointer we need coming in, so there are no\n /// autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n /// At some point, of course, `Box` should move out of the compiler, in which\n-/// case this is analogous to transformating a struct. E.g., Box<[i32; 4]> ->\n+/// case this is analogous to transforming a struct. E.g., Box<[i32; 4]> ->\n /// Box<[i32]> is an `Adjust::Unsize` with the target `Box<[i32]>`.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct Adjustment<'tcx> {"}, {"sha": "18478f7c61d7265bba7cd235da97aad7b6d0394c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 360, "deletions": 42, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -14,12 +14,13 @@ use dep_graph::DepGraph;\n use errors::DiagnosticBuilder;\n use session::Session;\n use middle;\n-use hir::TraitMap;\n+use hir::{TraitMap};\n use hir::def::{Def, ExportMap};\n use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::DefPathHash;\n use lint::{self, Lint};\n+use ich::{self, StableHashingContext, NodeIdHashingMode};\n use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n use middle::resolve_lifetime;\n@@ -42,15 +43,18 @@ use ty::inhabitedness::DefIdForest;\n use ty::maps;\n use ty::steal::Steal;\n use ty::BindingMode;\n-use util::nodemap::{NodeMap, NodeSet, DefIdSet};\n+use util::nodemap::{NodeMap, NodeSet, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n+                                           StableHasherResult};\n \n use arena::{TypedArena, DroplessArena};\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::borrow::Borrow;\n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering;\n+use std::collections::hash_map::{self, Entry};\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::ops::Deref;\n@@ -207,58 +211,155 @@ pub struct CommonTypes<'tcx> {\n     pub re_erased: Region<'tcx>,\n }\n \n+pub struct LocalTableInContext<'a, V: 'a> {\n+    local_id_root: Option<DefId>,\n+    data: &'a ItemLocalMap<V>\n+}\n+\n+/// Validate that the given HirId (respectively its `local_id` part) can be\n+/// safely used as a key in the tables of a TypeckTable. For that to be\n+/// the case, the HirId must have the same `owner` as all the other IDs in\n+/// this table (signified by `local_id_root`). Otherwise the HirId\n+/// would be in a different frame of reference and using its `local_id`\n+/// would result in lookup errors, or worse, in silently wrong data being\n+/// stored/returned.\n+fn validate_hir_id_for_typeck_tables(local_id_root: Option<DefId>,\n+                                     hir_id: hir::HirId,\n+                                     mut_access: bool) {\n+    if cfg!(debug_assertions) {\n+        if let Some(local_id_root) = local_id_root {\n+            if hir_id.owner != local_id_root.index {\n+                ty::tls::with(|tcx| {\n+                    let node_id = tcx.hir\n+                                     .definitions()\n+                                     .find_node_for_hir_id(hir_id);\n+\n+                    bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n+                          TypeckTables with local_id_root {:?}\",\n+                          tcx.hir.node_to_string(node_id),\n+                          DefId::local(hir_id.owner),\n+                          local_id_root)\n+                });\n+            }\n+        } else {\n+            // We use \"Null Object\" TypeckTables in some of the analysis passes.\n+            // These are just expected to be empty and their `local_id_root` is\n+            // `None`. Therefore we cannot verify whether a given `HirId` would\n+            // be a valid key for the given table. Instead we make sure that\n+            // nobody tries to write to such a Null Object table.\n+            if mut_access {\n+                bug!(\"access to invalid TypeckTables\")\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, V> LocalTableInContext<'a, V> {\n+    pub fn contains_key(&self, id: hir::HirId) -> bool {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        self.data.contains_key(&id.local_id)\n+    }\n+\n+    pub fn get(&self, id: hir::HirId) -> Option<&V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        self.data.get(&id.local_id)\n+    }\n+\n+    pub fn iter(&self) -> hash_map::Iter<hir::ItemLocalId, V> {\n+        self.data.iter()\n+    }\n+}\n+\n+impl<'a, V> ::std::ops::Index<hir::HirId> for LocalTableInContext<'a, V> {\n+    type Output = V;\n+\n+    fn index(&self, key: hir::HirId) -> &V {\n+        self.get(key).expect(\"LocalTableInContext: key not found\")\n+    }\n+}\n+\n+pub struct LocalTableInContextMut<'a, V: 'a> {\n+    local_id_root: Option<DefId>,\n+    data: &'a mut ItemLocalMap<V>\n+}\n+\n+impl<'a, V> LocalTableInContextMut<'a, V> {\n+    pub fn get_mut(&mut self, id: hir::HirId) -> Option<&mut V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        self.data.get_mut(&id.local_id)\n+    }\n+\n+    pub fn entry(&mut self, id: hir::HirId) -> Entry<hir::ItemLocalId, V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        self.data.entry(id.local_id)\n+    }\n+\n+    pub fn insert(&mut self, id: hir::HirId, val: V) -> Option<V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        self.data.insert(id.local_id, val)\n+    }\n+\n+    pub fn remove(&mut self, id: hir::HirId) -> Option<V> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, true);\n+        self.data.remove(&id.local_id)\n+    }\n+}\n+\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct TypeckTables<'tcx> {\n+    /// The HirId::owner all ItemLocalIds in this table are relative to.\n+    pub local_id_root: Option<DefId>,\n+\n     /// Resolved definitions for `<T>::X` associated paths and\n     /// method calls, including those of overloaded operators.\n-    pub type_dependent_defs: NodeMap<Def>,\n+    type_dependent_defs: ItemLocalMap<Def>,\n \n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n     /// typeck::check::fn_ctxt for details.\n-    pub node_types: NodeMap<Ty<'tcx>>,\n+    node_types: ItemLocalMap<Ty<'tcx>>,\n \n     /// Stores the type parameters which were substituted to obtain the type\n     /// of this node.  This only applies to nodes that refer to entities\n     /// parameterized by type parameters, such as generic fns, types, or\n     /// other items.\n-    pub node_substs: NodeMap<&'tcx Substs<'tcx>>,\n+    node_substs: ItemLocalMap<&'tcx Substs<'tcx>>,\n \n-    pub adjustments: NodeMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n+    adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n \n     // Stores the actual binding mode for all instances of hir::BindingAnnotation.\n-    pub pat_binding_modes: NodeMap<BindingMode>,\n+    pat_binding_modes: ItemLocalMap<BindingMode>,\n \n     /// Borrows\n     pub upvar_capture_map: ty::UpvarCaptureMap<'tcx>,\n \n     /// Records the type of each closure.\n-    pub closure_tys: NodeMap<ty::PolyFnSig<'tcx>>,\n+    closure_tys: ItemLocalMap<ty::PolyFnSig<'tcx>>,\n \n     /// Records the kind of each closure and the span and name of the variable\n     /// that caused the closure to be this kind.\n-    pub closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n+    closure_kinds: ItemLocalMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n \n-    pub generator_sigs: NodeMap<Option<ty::GenSig<'tcx>>>,\n+    pub generator_sigs: ItemLocalMap<Option<ty::GenSig<'tcx>>>,\n \n-    pub generator_interiors: NodeMap<ty::GeneratorInterior<'tcx>>,\n+    pub generator_interiors: ItemLocalMap<ty::GeneratorInterior<'tcx>>,\n \n     /// For each fn, records the \"liberated\" types of its arguments\n     /// and return type. Liberated means that all bound regions\n     /// (including late-bound regions) are replaced with free\n     /// equivalents. This table is not used in trans (since regions\n     /// are erased there) and hence is not serialized to metadata.\n-    pub liberated_fn_sigs: NodeMap<ty::FnSig<'tcx>>,\n+    liberated_fn_sigs: ItemLocalMap<ty::FnSig<'tcx>>,\n \n     /// For each FRU expression, record the normalized types of the fields\n     /// of the struct - this is needed because it is non-trivial to\n     /// normalize while preserving regions. This table is used only in\n     /// MIR construction and hence is not serialized to metadata.\n-    pub fru_field_types: NodeMap<Vec<Ty<'tcx>>>,\n+    fru_field_types: ItemLocalMap<Vec<Ty<'tcx>>>,\n \n     /// Maps a cast expression to its kind. This is keyed on the\n     /// *from* expression of the cast, not the cast itself.\n-    pub cast_kinds: NodeMap<ty::cast::CastKind>,\n+    cast_kinds: ItemLocalMap<ty::cast::CastKind>,\n \n     /// Set of trait imports actually used in the method resolution.\n     /// This is used for warning unused imports.\n@@ -275,63 +376,110 @@ pub struct TypeckTables<'tcx> {\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n-    pub fn empty() -> TypeckTables<'tcx> {\n+    pub fn empty(local_id_root: Option<DefId>) -> TypeckTables<'tcx> {\n         TypeckTables {\n-            type_dependent_defs: NodeMap(),\n-            node_types: FxHashMap(),\n-            node_substs: NodeMap(),\n-            adjustments: NodeMap(),\n-            pat_binding_modes: NodeMap(),\n+            local_id_root,\n+            type_dependent_defs: ItemLocalMap(),\n+            node_types: ItemLocalMap(),\n+            node_substs: ItemLocalMap(),\n+            adjustments: ItemLocalMap(),\n+            pat_binding_modes: ItemLocalMap(),\n             upvar_capture_map: FxHashMap(),\n-            generator_sigs: NodeMap(),\n-            generator_interiors: NodeMap(),\n-            closure_tys: NodeMap(),\n-            closure_kinds: NodeMap(),\n-            liberated_fn_sigs: NodeMap(),\n-            fru_field_types: NodeMap(),\n-            cast_kinds: NodeMap(),\n+            generator_sigs: ItemLocalMap(),\n+            generator_interiors: ItemLocalMap(),\n+            closure_tys: ItemLocalMap(),\n+            closure_kinds: ItemLocalMap(),\n+            liberated_fn_sigs: ItemLocalMap(),\n+            fru_field_types: ItemLocalMap(),\n+            cast_kinds: ItemLocalMap(),\n             used_trait_imports: DefIdSet(),\n             tainted_by_errors: false,\n             free_region_map: FreeRegionMap::new(),\n         }\n     }\n \n     /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n-    pub fn qpath_def(&self, qpath: &hir::QPath, id: NodeId) -> Def {\n+    pub fn qpath_def(&self, qpath: &hir::QPath, id: hir::HirId) -> Def {\n         match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.def,\n             hir::QPath::TypeRelative(..) => {\n-                self.type_dependent_defs.get(&id).cloned().unwrap_or(Def::Err)\n+                validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+                self.type_dependent_defs.get(&id.local_id).cloned().unwrap_or(Def::Err)\n             }\n         }\n     }\n \n-    pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n+    pub fn type_dependent_defs(&self) -> LocalTableInContext<Def> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.type_dependent_defs\n+        }\n+    }\n+\n+    pub fn type_dependent_defs_mut(&mut self) -> LocalTableInContextMut<Def> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.type_dependent_defs\n+        }\n+    }\n+\n+    pub fn node_types(&self) -> LocalTableInContext<Ty<'tcx>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.node_types\n+        }\n+    }\n+\n+    pub fn node_types_mut(&mut self) -> LocalTableInContextMut<Ty<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.node_types\n+        }\n+    }\n+\n+    pub fn node_id_to_type(&self, id: hir::HirId) -> Ty<'tcx> {\n         match self.node_id_to_type_opt(id) {\n             Some(ty) => ty,\n             None => {\n                 bug!(\"node_id_to_type: no type for node `{}`\",\n-                     tls::with(|tcx| tcx.hir.node_to_string(id)))\n+                    tls::with(|tcx| {\n+                        let id = tcx.hir.definitions().find_node_for_hir_id(id);\n+                        tcx.hir.node_to_string(id)\n+                    }))\n             }\n         }\n     }\n \n-    pub fn node_id_to_type_opt(&self, id: NodeId) -> Option<Ty<'tcx>> {\n-        self.node_types.get(&id).cloned()\n+    pub fn node_id_to_type_opt(&self, id: hir::HirId) -> Option<Ty<'tcx>> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        self.node_types.get(&id.local_id).cloned()\n+    }\n+\n+    pub fn node_substs_mut(&mut self) -> LocalTableInContextMut<&'tcx Substs<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.node_substs\n+        }\n+    }\n+\n+    pub fn node_substs(&self, id: hir::HirId) -> &'tcx Substs<'tcx> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        self.node_substs.get(&id.local_id).cloned().unwrap_or(Substs::empty())\n     }\n \n-    pub fn node_substs(&self, id: NodeId) -> &'tcx Substs<'tcx> {\n-        self.node_substs.get(&id).cloned().unwrap_or(Substs::empty())\n+    pub fn node_substs_opt(&self, id: hir::HirId) -> Option<&'tcx Substs<'tcx>> {\n+        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n+        self.node_substs.get(&id.local_id).cloned()\n     }\n \n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n     // doesn't provide type parameter substitutions.\n     pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n-        self.node_id_to_type(pat.id)\n+        self.node_id_to_type(pat.hir_id)\n     }\n \n     pub fn pat_ty_opt(&self, pat: &hir::Pat) -> Option<Ty<'tcx>> {\n-        self.node_id_to_type_opt(pat.id)\n+        self.node_id_to_type_opt(pat.hir_id)\n     }\n \n     // Returns the type of an expression as a monotype.\n@@ -345,16 +493,32 @@ impl<'tcx> TypeckTables<'tcx> {\n     // ask for the type of \"id\" in \"id(3)\", it will return \"fn(&isize) -> isize\"\n     // instead of \"fn(ty) -> T with T = isize\".\n     pub fn expr_ty(&self, expr: &hir::Expr) -> Ty<'tcx> {\n-        self.node_id_to_type(expr.id)\n+        self.node_id_to_type(expr.hir_id)\n     }\n \n     pub fn expr_ty_opt(&self, expr: &hir::Expr) -> Option<Ty<'tcx>> {\n-        self.node_id_to_type_opt(expr.id)\n+        self.node_id_to_type_opt(expr.hir_id)\n+    }\n+\n+    pub fn adjustments(&self) -> LocalTableInContext<Vec<ty::adjustment::Adjustment<'tcx>>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.adjustments\n+        }\n+    }\n+\n+    pub fn adjustments_mut(&mut self)\n+                           -> LocalTableInContextMut<Vec<ty::adjustment::Adjustment<'tcx>>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.adjustments\n+        }\n     }\n \n     pub fn expr_adjustments(&self, expr: &hir::Expr)\n                             -> &[ty::adjustment::Adjustment<'tcx>] {\n-        self.adjustments.get(&expr.id).map_or(&[], |a| &a[..])\n+        validate_hir_id_for_typeck_tables(self.local_id_root, expr.hir_id, false);\n+        self.adjustments.get(&expr.hir_id.local_id).map_or(&[], |a| &a[..])\n     }\n \n     /// Returns the type of `expr`, considering any `Adjustment`\n@@ -379,15 +543,169 @@ impl<'tcx> TypeckTables<'tcx> {\n             return false;\n         }\n \n-        match self.type_dependent_defs.get(&expr.id) {\n+        match self.type_dependent_defs().get(expr.hir_id) {\n             Some(&Def::Method(_)) => true,\n             _ => false\n         }\n     }\n \n+    pub fn pat_binding_modes(&self) -> LocalTableInContext<BindingMode> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.pat_binding_modes\n+        }\n+    }\n+\n+    pub fn pat_binding_modes_mut(&mut self)\n+                           -> LocalTableInContextMut<BindingMode> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.pat_binding_modes\n+        }\n+    }\n+\n     pub fn upvar_capture(&self, upvar_id: ty::UpvarId) -> ty::UpvarCapture<'tcx> {\n         self.upvar_capture_map[&upvar_id]\n     }\n+\n+    pub fn closure_tys(&self) -> LocalTableInContext<ty::PolyFnSig<'tcx>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.closure_tys\n+        }\n+    }\n+\n+    pub fn closure_tys_mut(&mut self)\n+                           -> LocalTableInContextMut<ty::PolyFnSig<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.closure_tys\n+        }\n+    }\n+\n+    pub fn closure_kinds(&self) -> LocalTableInContext<(ty::ClosureKind,\n+                                                        Option<(Span, ast::Name)>)> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.closure_kinds\n+        }\n+    }\n+\n+    pub fn closure_kinds_mut(&mut self)\n+            -> LocalTableInContextMut<(ty::ClosureKind, Option<(Span, ast::Name)>)> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.closure_kinds\n+        }\n+    }\n+\n+    pub fn liberated_fn_sigs(&self) -> LocalTableInContext<ty::FnSig<'tcx>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.liberated_fn_sigs\n+        }\n+    }\n+\n+    pub fn liberated_fn_sigs_mut(&mut self) -> LocalTableInContextMut<ty::FnSig<'tcx>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.liberated_fn_sigs\n+        }\n+    }\n+\n+    pub fn fru_field_types(&self) -> LocalTableInContext<Vec<Ty<'tcx>>> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.fru_field_types\n+        }\n+    }\n+\n+    pub fn fru_field_types_mut(&mut self) -> LocalTableInContextMut<Vec<Ty<'tcx>>> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.fru_field_types\n+        }\n+    }\n+\n+    pub fn cast_kinds(&self) -> LocalTableInContext<ty::cast::CastKind> {\n+        LocalTableInContext {\n+            local_id_root: self.local_id_root,\n+            data: &self.cast_kinds\n+        }\n+    }\n+\n+    pub fn cast_kinds_mut(&mut self) -> LocalTableInContextMut<ty::cast::CastKind> {\n+        LocalTableInContextMut {\n+            local_id_root: self.local_id_root,\n+            data: &mut self.cast_kinds\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for TypeckTables<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let ty::TypeckTables {\n+            local_id_root,\n+            ref type_dependent_defs,\n+            ref node_types,\n+            ref node_substs,\n+            ref adjustments,\n+            ref pat_binding_modes,\n+            ref upvar_capture_map,\n+            ref closure_tys,\n+            ref closure_kinds,\n+            ref liberated_fn_sigs,\n+            ref fru_field_types,\n+\n+            ref cast_kinds,\n+\n+            ref used_trait_imports,\n+            tainted_by_errors,\n+            ref free_region_map,\n+        } = *self;\n+\n+        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n+            ich::hash_stable_itemlocalmap(hcx, hasher, type_dependent_defs);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, node_types);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, node_substs);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, adjustments);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, pat_binding_modes);\n+            ich::hash_stable_hashmap(hcx, hasher, upvar_capture_map, |hcx, up_var_id| {\n+                let ty::UpvarId {\n+                    var_id,\n+                    closure_expr_id\n+                } = *up_var_id;\n+\n+                let local_id_root =\n+                    local_id_root.expect(\"trying to hash invalid TypeckTables\");\n+\n+                let var_def_id = DefId {\n+                    krate: local_id_root.krate,\n+                    index: var_id,\n+                };\n+                let closure_def_id = DefId {\n+                    krate: local_id_root.krate,\n+                    index: closure_expr_id,\n+                };\n+                (hcx.def_path_hash(var_def_id), hcx.def_path_hash(closure_def_id))\n+            });\n+\n+            ich::hash_stable_itemlocalmap(hcx, hasher, closure_tys);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, closure_kinds);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, liberated_fn_sigs);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, fru_field_types);\n+            ich::hash_stable_itemlocalmap(hcx, hasher, cast_kinds);\n+\n+            ich::hash_stable_hashset(hcx, hasher, used_trait_imports, |hcx, def_id| {\n+                hcx.def_path_hash(*def_id)\n+            });\n+\n+            tainted_by_errors.hash_stable(hcx, hasher);\n+            free_region_map.hash_stable(hcx, hasher);\n+        })\n+    }\n }\n \n impl<'tcx> CommonTypes<'tcx> {\n@@ -1201,7 +1519,7 @@ macro_rules! direct_interners {\n     }\n }\n \n-fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n+pub fn keep_local<'tcx, T: ty::TypeFoldable<'tcx>>(x: &T) -> bool {\n     x.has_type_flags(ty::TypeFlags::KEEP_IN_LOCAL_TCX)\n }\n "}, {"sha": "27b8d245396c9fdb7ec2c51bba4c275fb71608a8", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -158,7 +158,10 @@ impl FlagComputation {\n                 self.add_ty(m.ty);\n             }\n \n-            &ty::TyTuple(ref ts, _) => {\n+            &ty::TyTuple(ref ts, is_default) => {\n+                if is_default {\n+                    self.add_flags(TypeFlags::KEEP_IN_LOCAL_TCX);\n+                }\n                 self.add_tys(&ts[..]);\n             }\n "}, {"sha": "896682e2370e2a9e7daebf370752e64162a03906", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -24,7 +24,7 @@ use ty::{DefId, DefIdTree};\n #[derive(Clone)]\n pub struct DefIdForest {\n     /// The minimal set of DefIds required to represent the whole set.\n-    /// If A and B are DefIds in the DefIdForest, and A is a desecendant\n+    /// If A and B are DefIds in the DefIdForest, and A is a descendant\n     /// of B, then only B will be in root_ids.\n     /// We use a SmallVec here because (for its use for cacheing inhabitedness)\n     /// its rare that this will contain even two ids.\n@@ -61,7 +61,7 @@ impl<'a, 'gcx, 'tcx> DefIdForest {\n         self.root_ids.is_empty()\n     }\n \n-    /// Test whether the forest conains a given DefId.\n+    /// Test whether the forest contains a given DefId.\n     pub fn contains(&self,\n                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     id: DefId) -> bool"}, {"sha": "3e6af27935de3140e5588a8299e52577dfeab8f7", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -125,7 +125,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// If possible, this pushes a global path resolving to `external_def_id` that is visible\n     /// from at least one local module and returns true. If the crate defining `external_def_id` is\n-    /// declared with an `extern crate`, the path is guarenteed to use the `extern crate`.\n+    /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n     pub fn try_push_visible_item_path<T>(self, buffer: &mut T, external_def_id: DefId) -> bool\n         where T: ItemPathBuffer\n     {"}, {"sha": "5f9c7b551250e26936f2d106613cfeb499ca77d6", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -594,7 +594,7 @@ macro_rules! define_maps {\n                 }\n \n                 // FIXME(eddyb) Get more valid Span's on queries.\n-                // def_span guard is necesary to prevent a recursive loop,\n+                // def_span guard is necessary to prevent a recursive loop,\n                 // default_span calls def_span query internally.\n                 if span == DUMMY_SP && stringify!($name) != \"def_span\" {\n                     span = key.default_span(tcx)"}, {"sha": "794db5b7dd9cbcbc2b532b1139589306bebb50fb", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -77,7 +77,7 @@ pub use self::sty::TypeVariants::*;\n pub use self::binding::BindingMode;\n pub use self::binding::BindingMode::*;\n \n-pub use self::context::{TyCtxt, GlobalArenas, tls};\n+pub use self::context::{TyCtxt, GlobalArenas, tls, keep_local};\n pub use self::context::{Lift, TypeckTables};\n \n pub use self::instance::{Instance, InstanceDef};\n@@ -575,8 +575,8 @@ impl<T> Slice<T> {\n /// by the upvar) and the id of the closure expression.\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UpvarId {\n-    pub var_id: NodeId,\n-    pub closure_expr_id: NodeId,\n+    pub var_id: DefIndex,\n+    pub closure_expr_id: DefIndex,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy)]\n@@ -1986,6 +1986,11 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn local_var_name_str_def_index(self, def_index: DefIndex) -> InternedString {\n+        let node_id = self.hir.as_local_node_id(DefId::local(def_index)).unwrap();\n+        self.local_var_name_str(node_id)\n+    }\n+\n     pub fn expr_is_lval(self, expr: &hir::Expr) -> bool {\n          match expr.node {\n             hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {"}, {"sha": "885be8464eb304ece548de0d6a6c0114845c8c73", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -224,7 +224,7 @@ pub trait MemoizationMap {\n     type Key: Clone;\n     type Value: Clone;\n \n-    /// If `key` is present in the map, return the valuee,\n+    /// If `key` is present in the map, return the value,\n     /// otherwise invoke `op` and store the value in the map.\n     ///\n     /// NB: if the receiver is a `DepTrackingMap`, special care is"}, {"sha": "c397371c5c7672021fcca82928b05eb20ad49199", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -13,19 +13,22 @@\n #![allow(non_snake_case)]\n \n use hir::def_id::DefId;\n+use hir::ItemLocalId;\n use syntax::ast;\n \n pub use rustc_data_structures::fx::FxHashMap;\n pub use rustc_data_structures::fx::FxHashSet;\n \n pub type NodeMap<T> = FxHashMap<ast::NodeId, T>;\n pub type DefIdMap<T> = FxHashMap<DefId, T>;\n+pub type ItemLocalMap<T> = FxHashMap<ItemLocalId, T>;\n \n pub type NodeSet = FxHashSet<ast::NodeId>;\n pub type DefIdSet = FxHashSet<DefId>;\n \n pub fn NodeMap<T>() -> NodeMap<T> { FxHashMap() }\n pub fn DefIdMap<T>() -> DefIdMap<T> { FxHashMap() }\n+pub fn ItemLocalMap<T>() -> ItemLocalMap<T> { FxHashMap() }\n pub fn NodeSet() -> NodeSet { FxHashSet() }\n pub fn DefIdSet() -> DefIdSet { FxHashSet() }\n "}, {"sha": "a5642467474b3bbb5d68e52c9265c7774f6417cb", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -905,9 +905,9 @@ impl<'tcx> fmt::Display for ty::TyS<'tcx> {\n \n impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"UpvarId({};`{}`;{})\",\n+        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n                self.var_id,\n-               ty::tls::with(|tcx| tcx.local_var_name_str(self.var_id)),\n+               ty::tls::with(|tcx| tcx.local_var_name_str_def_index(self.var_id)),\n                self.closure_expr_id)\n     }\n }"}, {"sha": "78b07a33389e2bca110edd7143e412e503537a4b", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -79,6 +79,7 @@ impl<'a> Folder for ExpandAllocatorDirectives<'a> {\n                 format: MacroAttribute(Symbol::intern(name)),\n                 span: None,\n                 allow_internal_unstable: true,\n+                allow_internal_unsafe: false,\n             }\n         });\n         let span = Span {"}, {"sha": "c34bf4c3d284dc5bdcc76853572683e584de4bd2", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -472,7 +472,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n                     if new_loan.span == old_loan.span {\n                         // Both borrows are happening in the same place\n-                        // Meaning the borrow is occuring in a loop\n+                        // Meaning the borrow is occurring in a loop\n                         err.span_label(\n                                 new_loan.span,\n                                 format!(\"mutable borrow starts here in previous \\"}, {"sha": "90e38465dd46d4b8b0f71dbdbed198fe19978151", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -153,7 +153,9 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for GatherLoanCtxt<'a, 'tcx> {\n     }\n \n     fn decl_without_init(&mut self, id: ast::NodeId, _span: Span) {\n-        let ty = self.bccx.tables.node_id_to_type(id);\n+        let ty = self.bccx\n+                     .tables\n+                     .node_id_to_type(self.bccx.tcx.hir.node_to_hir_id(id));\n         gather_moves::gather_decl(self.bccx, &self.move_data, id, ty);\n     }\n }\n@@ -445,7 +447,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     }\n                     None\n                 }\n-                LpUpvar(ty::UpvarId{ var_id: local_id, closure_expr_id: _ }) => {\n+                LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n+                    let local_id = self.tcx().hir.def_index_to_node_id(var_id);\n                     self.tcx().used_mut_nodes.borrow_mut().insert(local_id);\n                     None\n                 }"}, {"sha": "bfd883be84876252e9671819c0980948d79dc78a", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -93,11 +93,11 @@ fn report_move_errors<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>, errors: &Vec<Move\n             }\n         }\n         if let NoteClosureEnv(upvar_id) = error.move_from.note {\n-            err.span_label(bccx.tcx.hir.span(upvar_id.var_id),\n+            let var_node_id = bccx.tcx.hir.def_index_to_node_id(upvar_id.var_id);\n+            err.span_label(bccx.tcx.hir.span(var_node_id),\n                            \"captured outer variable\");\n         }\n         err.emit();\n-\n     }\n }\n "}, {"sha": "6f7c42c2fb6c913d7dc178028c106a820d880d80", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -27,7 +27,7 @@ use rustc::middle::dataflow::DataFlowContext;\n use rustc::middle::dataflow::BitwiseOperator;\n use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n@@ -324,8 +324,9 @@ pub enum LoanPathElem<'tcx> {\n     LpInterior(Option<DefId>, InteriorKind),\n }\n \n-pub fn closure_to_block(closure_id: ast::NodeId,\n-                        tcx: TyCtxt) -> ast::NodeId {\n+fn closure_to_block(closure_id: DefIndex,\n+                    tcx: TyCtxt) -> ast::NodeId {\n+    let closure_id = tcx.hir.def_index_to_node_id(closure_id);\n     match tcx.hir.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n             hir::ExprClosure(.., body_id, _, _) => {\n@@ -597,8 +598,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let need_note = match lp.ty.sty {\n                     ty::TypeVariants::TyClosure(id, _) => {\n                         let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n+                        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n                         if let Some(&(ty::ClosureKind::FnOnce, Some((span, name)))) =\n-                            self.tables.closure_kinds.get(&node_id)\n+                            self.tables.closure_kinds().get(hir_id)\n                         {\n                             err.span_note(span, &format!(\n                                 \"closure cannot be invoked more than once because \\\n@@ -1044,7 +1046,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 } else {\n                     \"consider changing this closure to take self by mutable reference\"\n                 };\n-                err.span_help(self.tcx.hir.span(id), help);\n+                let node_id = self.tcx.hir.def_index_to_node_id(id);\n+                err.span_help(self.tcx.hir.span(node_id), help);\n                 err\n             }\n             _ =>  {\n@@ -1100,8 +1103,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         };\n \n         match pat.node {\n-            hir::PatKind::Binding(..) =>\n-                *self.tables.pat_binding_modes.get(&pat.id).expect(\"missing binding mode\"),\n+            hir::PatKind::Binding(..) => {\n+                *self.tables\n+                     .pat_binding_modes()\n+                     .get(pat.hir_id)\n+                     .expect(\"missing binding mode\")\n+            }\n             _ => bug!(\"local is not a binding: {:?}\", pat)\n         }\n     }\n@@ -1248,7 +1255,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     _ => bug!()\n                 };\n                 if kind == ty::ClosureKind::Fn {\n-                    db.span_help(self.tcx.hir.span(upvar_id.closure_expr_id),\n+                    let closure_node_id =\n+                        self.tcx.hir.def_index_to_node_id(upvar_id.closure_expr_id);\n+                    db.span_help(self.tcx.hir.span(closure_node_id),\n                                  \"consider changing this closure to take \\\n                                   self by mutable reference\");\n                 }\n@@ -1281,7 +1290,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                       loan_path: &LoanPath<'tcx>,\n                                       out: &mut String) {\n         match loan_path.kind {\n-            LpUpvar(ty::UpvarId{ var_id: id, closure_expr_id: _ }) |\n+            LpUpvar(ty::UpvarId { var_id: id, closure_expr_id: _ }) => {\n+                out.push_str(&self.tcx.local_var_name_str_def_index(id));\n+            }\n             LpVar(id) => {\n                 out.push_str(&self.tcx.local_var_name_str(id));\n             }\n@@ -1419,8 +1430,11 @@ impl<'tcx> fmt::Debug for LoanPath<'tcx> {\n             }\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id }) => {\n-                let s = ty::tls::with(|tcx| tcx.hir.node_to_string(var_id));\n-                write!(f, \"$({} captured by id={})\", s, closure_expr_id)\n+                let s = ty::tls::with(|tcx| {\n+                    let var_node_id = tcx.hir.def_index_to_node_id(var_id);\n+                    tcx.hir.node_to_string(var_node_id)\n+                });\n+                write!(f, \"$({} captured by id={:?})\", s, closure_expr_id)\n             }\n \n             LpDowncast(ref lp, variant_def_id) => {\n@@ -1451,7 +1465,10 @@ impl<'tcx> fmt::Display for LoanPath<'tcx> {\n             }\n \n             LpUpvar(ty::UpvarId{ var_id, closure_expr_id: _ }) => {\n-                let s = ty::tls::with(|tcx| tcx.hir.node_to_user_string(var_id));\n+                let s = ty::tls::with(|tcx| {\n+                    let var_node_id = tcx.hir.def_index_to_node_id(var_id);\n+                    tcx.hir.node_to_string(var_node_id)\n+                });\n                 write!(f, \"$({} captured by closure)\", s)\n             }\n "}, {"sha": "ea7deef472425632798f9e6848752942e5d97050", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -188,7 +188,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n             // Then, if the match has no arms, check whether the scrutinee\n             // is uninhabited.\n-            let pat_ty = self.tables.node_id_to_type(scrut.id);\n+            let pat_ty = self.tables.node_id_to_type(scrut.hir_id);\n             let module = self.tcx.hir.get_module_parent(scrut.id);\n             if inlined_arms.is_empty() {\n                 let scrutinee_is_uninhabited = if self.tcx.sess.features.borrow().never_type {\n@@ -217,7 +217,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n                 .flat_map(|arm| &arm.0)\n                 .map(|pat| vec![pat.0])\n                 .collect();\n-            let scrut_ty = self.tables.node_id_to_type(scrut.id);\n+            let scrut_ty = self.tables.node_id_to_type(scrut.hir_id);\n             check_exhaustive(cx, scrut_ty, scrut.span, &matrix);\n         })\n     }\n@@ -269,7 +269,11 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n         if let PatKind::Binding(_, _, name, None) = p.node {\n-            let bm = *cx.tables.pat_binding_modes.get(&p.id).expect(\"missing binding mode\");\n+            let bm = *cx.tables\n+                        .pat_binding_modes()\n+                        .get(p.hir_id)\n+                        .expect(\"missing binding mode\");\n+\n             if bm != ty::BindByValue(hir::MutImmutable) {\n                 // Nothing to check.\n                 return true;\n@@ -458,7 +462,11 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     let mut by_ref_span = None;\n     for pat in pats {\n         pat.each_binding(|_, id, span, _path| {\n-            let bm = *cx.tables.pat_binding_modes.get(&id).expect(\"missing binding mode\");\n+            let hir_id = cx.tcx.hir.node_to_hir_id(id);\n+            let bm = *cx.tables\n+                        .pat_binding_modes()\n+                        .get(hir_id)\n+                        .expect(\"missing binding mode\");\n             if let ty::BindByReference(..) = bm {\n                 by_ref_span = Some(span);\n             }\n@@ -491,10 +499,13 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n     for pat in pats {\n         pat.walk(|p| {\n             if let PatKind::Binding(_, _, _, ref sub) = p.node {\n-                let bm = *cx.tables.pat_binding_modes.get(&p.id).expect(\"missing binding mode\");\n+                let bm = *cx.tables\n+                            .pat_binding_modes()\n+                            .get(p.hir_id)\n+                            .expect(\"missing binding mode\");\n                 match bm {\n                     ty::BindByValue(..) => {\n-                        let pat_ty = cx.tables.node_id_to_type(p.id);\n+                        let pat_ty = cx.tables.node_id_to_type(p.hir_id);\n                         if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n                             check_move(p, sub.as_ref().map(|p| &**p));\n                         }"}, {"sha": "20ca218571c790fd98eda7e2bf81670b94e3e2d7", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -106,7 +106,7 @@ impl<'a, 'tcx> ConstContext<'a, 'tcx> {\n     }\n \n     /// Evaluate a constant expression in a context where the expression isn't\n-    /// guaranteed to be evaluatable.\n+    /// guaranteed to be evaluable.\n     pub fn eval(&self, e: &Expr) -> EvalResult<'tcx> {\n         if self.tables.tainted_by_errors {\n             signal!(e, TypeckError);\n@@ -275,8 +275,8 @@ fn eval_const_expr_partial<'a, 'tcx>(cx: &ConstContext<'a, 'tcx>,\n         }\n       }\n       hir::ExprPath(ref qpath) => {\n-        let substs = cx.tables.node_substs(e.id).subst(tcx, cx.substs);\n-          match cx.tables.qpath_def(qpath, e.id) {\n+        let substs = cx.tables.node_substs(e.hir_id).subst(tcx, cx.substs);\n+          match cx.tables.qpath_def(qpath, e.hir_id) {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                     match tcx.at(e.span).const_eval(cx.param_env.and((def_id, substs))) {"}, {"sha": "d151e817040a9a2733b628eca38798f2ec653fa6", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -303,7 +303,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n     }\n \n     pub fn lower_pattern(&mut self, pat: &hir::Pat) -> Pattern<'tcx> {\n-        let mut ty = self.tables.node_id_to_type(pat.id);\n+        let mut ty = self.tables.node_id_to_type(pat.hir_id);\n \n         let kind = match pat.node {\n             PatKind::Wild => PatternKind::Wild,\n@@ -321,7 +321,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Path(ref qpath) => {\n-                return self.lower_path(qpath, pat.id, pat.id, pat.span);\n+                return self.lower_path(qpath, pat.hir_id, pat.id, pat.span);\n             }\n \n             PatKind::Ref(ref subpattern, _) |\n@@ -330,7 +330,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                let ty = self.tables.node_id_to_type(pat.id);\n+                let ty = self.tables.node_id_to_type(pat.hir_id);\n                 match ty.sty {\n                     ty::TyRef(_, mt) =>\n                         PatternKind::Deref {\n@@ -355,7 +355,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Tuple(ref subpatterns, ddpos) => {\n-                let ty = self.tables.node_id_to_type(pat.id);\n+                let ty = self.tables.node_id_to_type(pat.hir_id);\n                 match ty.sty {\n                     ty::TyTuple(ref tys, _) => {\n                         let subpatterns =\n@@ -376,13 +376,13 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n             PatKind::Binding(_, def_id, ref ident, ref sub) => {\n                 let id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                let var_ty = self.tables.node_id_to_type(pat.id);\n+                let var_ty = self.tables.node_id_to_type(pat.hir_id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _) => Some(r),\n                     _ => None,\n                 };\n-                let bm = *self.tables.pat_binding_modes.get(&pat.id)\n-                                                       .expect(\"missing binding mode\");\n+                let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n+                                                         .expect(\"missing binding mode\");\n                 let (mutability, mode) = match bm {\n                     ty::BindByValue(hir::MutMutable) =>\n                         (Mutability::Mut, BindingMode::ByValue),\n@@ -417,7 +417,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n-                let def = self.tables.qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n                 let adt_def = match ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n@@ -436,7 +436,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tables.qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n                 let adt_def = match ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {\n@@ -590,7 +590,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n \n     fn lower_path(&mut self,\n                   qpath: &hir::QPath,\n-                  id: ast::NodeId,\n+                  id: hir::HirId,\n                   pat_id: ast::NodeId,\n                   span: Span)\n                   -> Pattern<'tcx> {\n@@ -695,8 +695,8 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     hir::ExprPath(ref qpath) => qpath,\n                     _ => bug!()\n                 };\n-                let ty = self.tables.node_id_to_type(callee.id);\n-                let def = self.tables.qpath_def(qpath, callee.id);\n+                let ty = self.tables.node_id_to_type(callee.hir_id);\n+                let def = self.tables.qpath_def(qpath, callee.hir_id);\n                 match def {\n                     Def::Fn(..) | Def::Method(..) => self.lower_lit(expr),\n                     _ => {\n@@ -712,7 +712,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             hir::ExprStruct(ref qpath, ref fields, None) => {\n-                let def = self.tables.qpath_def(qpath, expr.id);\n+                let def = self.tables.qpath_def(qpath, expr.hir_id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => {\n@@ -755,7 +755,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n             }\n \n             hir::ExprPath(ref qpath) => {\n-                return self.lower_path(qpath, expr.id, pat_id, span);\n+                return self.lower_path(qpath, expr.hir_id, pat_id, span);\n             }\n \n             _ => self.lower_lit(expr)"}, {"sha": "1d0e88ee328556cb6000c96750b2afd70bfd6f9d", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -196,6 +196,16 @@ impl<I: Idx, T: Clone> IndexVec<I, T> {\n     }\n }\n \n+impl<I: Idx, T: Ord> IndexVec<I, T> {\n+    #[inline]\n+    pub fn binary_search(&self, value: &T) -> Result<I, I> {\n+        match self.raw.binary_search(value) {\n+            Ok(i) => Ok(Idx::new(i)),\n+            Err(i) => Err(Idx::new(i)),\n+        }\n+    }\n+}\n+\n impl<I: Idx, T> Index<I> for IndexVec<I, T> {\n     type Output = T;\n "}, {"sha": "33c4a041cff882dcf186050450d3ad1097a27b79", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -193,7 +193,7 @@ impl<W> Hasher for StableHasher<W> {\n \n \n /// Something that implements `HashStable<CTX>` can be hashed in a way that is\n-/// stable across multiple compiliation sessions.\n+/// stable across multiple compilation sessions.\n pub trait HashStable<CTX> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut CTX,"}, {"sha": "6c673b2ea2366c0613c310399f32503508e65798", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 29, "deletions": 37, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![cfg_attr(not(feature=\"llvm\"), allow(dead_code))]\n+\n use rustc::hir::{self, map as hir_map};\n use rustc::hir::lowering::lower_crate;\n use rustc::ich::Fingerprint;\n@@ -19,8 +21,6 @@ use rustc::session::config::{self, Input, OutputFilenames, OutputType};\n use rustc::session::search_paths::PathKind;\n use rustc::lint;\n use rustc::middle::{self, stability, reachable};\n-#[cfg(feature=\"llvm\")]\n-use rustc::middle::dependency_format;\n use rustc::middle::privacy::AccessLevels;\n use rustc::mir::transform::{MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED, Passes};\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n@@ -33,9 +33,7 @@ use rustc_incremental::{self, IncrementalHashesMap};\n use rustc_resolve::{MakeGlobMap, Resolver};\n use rustc_metadata::creader::CrateLoader;\n use rustc_metadata::cstore::{self, CStore};\n-#[cfg(feature=\"llvm\")]\n-use rustc_trans::back::{link, write};\n-#[cfg(feature=\"llvm\")]\n+use rustc_trans::back::write;\n use rustc_trans as trans;\n use rustc_typeck as typeck;\n use rustc_privacy;\n@@ -73,11 +71,7 @@ pub fn compile_input(sess: &Session,\n                      output: &Option<PathBuf>,\n                      addl_plugins: Option<Vec<String>>,\n                      control: &CompileController) -> CompileResult {\n-    #[cfg(feature=\"llvm\")]\n     use rustc_trans::back::write::OngoingCrateTranslation;\n-    #[cfg(not(feature=\"llvm\"))]\n-    type OngoingCrateTranslation = ();\n-\n     macro_rules! controller_entry_point {\n         ($point: ident, $tsess: expr, $make_state: expr, $phase_result: expr) => {{\n             let state = &mut $make_state;\n@@ -94,6 +88,23 @@ pub fn compile_input(sess: &Session,\n         }}\n     }\n \n+    if cfg!(not(feature=\"llvm\")) {\n+        use rustc::session::config::CrateType;\n+        if !sess.opts.debugging_opts.no_trans && sess.opts.output_types.should_trans() {\n+            sess.err(\"LLVM is not supported by this rustc. Please use -Z no-trans to compile\")\n+        }\n+\n+        if sess.opts.crate_types.iter().all(|&t|{\n+            t != CrateType::CrateTypeRlib && t != CrateType::CrateTypeExecutable\n+        }) && !sess.opts.crate_types.is_empty() {\n+            sess.err(\n+                \"LLVM is not supported by this rustc, so non rlib libraries are not supported\"\n+            );\n+        }\n+\n+        sess.abort_if_errors();\n+    }\n+\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n@@ -217,7 +228,6 @@ pub fn compile_input(sess: &Session,\n                 tcx.print_debug_stats();\n             }\n \n-            #[cfg(feature=\"llvm\")]\n             let trans = phase_4_translate_to_llvm(tcx, analysis, incremental_hashes_map,\n                                                   &outputs);\n \n@@ -233,24 +243,13 @@ pub fn compile_input(sess: &Session,\n                 }\n             }\n \n-            #[cfg(not(feature=\"llvm\"))]\n-            {\n-                let _ = incremental_hashes_map;\n-                sess.err(&format!(\"LLVM is not supported by this rustc\"));\n-                sess.abort_if_errors();\n-                unreachable!();\n-            }\n-\n-            #[cfg(feature=\"llvm\")]\n             Ok((outputs, trans))\n         })??\n     };\n \n-    #[cfg(not(feature=\"llvm\"))]\n-    {\n-        let _ = outputs;\n-        let _ = trans;\n-        unreachable!();\n+    if cfg!(not(feature=\"llvm\")) {\n+        let (_, _) = (outputs, trans);\n+        sess.fatal(\"LLVM is not supported by this rustc\");\n     }\n \n     #[cfg(feature=\"llvm\")]\n@@ -315,7 +314,7 @@ pub fn source_name(input: &Input) -> String {\n /// This is a somewhat higher level controller than a Session - the Session\n /// controls what happens in each phase, whereas the CompileController controls\n /// whether a phase is run at all and whether other code (from outside the\n-/// the compiler) is run between phases.\n+/// compiler) is run between phases.\n ///\n /// Note that if compilation is set to stop and a callback is provided for a\n /// given entry point, the callback is called before compilation is stopped.\n@@ -393,7 +392,6 @@ pub struct CompileState<'a, 'tcx: 'a> {\n     pub resolutions: Option<&'a Resolutions>,\n     pub analysis: Option<&'a ty::CrateAnalysis>,\n     pub tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n-    #[cfg(feature=\"llvm\")]\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n@@ -420,7 +418,6 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n             resolutions: None,\n             analysis: None,\n             tcx: None,\n-            #[cfg(feature=\"llvm\")]\n             trans: None,\n         }\n     }\n@@ -509,7 +506,6 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n         }\n     }\n \n-    #[cfg(feature=\"llvm\")]\n     fn state_after_llvm(input: &'a Input,\n                         session: &'tcx Session,\n                         out_dir: &'a Option<PathBuf>,\n@@ -523,7 +519,6 @@ impl<'a, 'tcx> CompileState<'a, 'tcx> {\n         }\n     }\n \n-    #[cfg(feature=\"llvm\")]\n     fn state_when_compilation_done(input: &'a Input,\n                                    session: &'tcx Session,\n                                    out_dir: &'a Option<PathBuf>,\n@@ -942,7 +937,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     mir::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_privacy::provide(&mut local_providers);\n-    #[cfg(feature=\"llvm\")]\n     trans::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n@@ -955,7 +949,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let mut extern_providers = ty::maps::Providers::default();\n     cstore::provide(&mut extern_providers);\n-    #[cfg(feature=\"llvm\")]\n     trans::provide(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n     traits::provide_extern(&mut extern_providers);\n@@ -974,7 +967,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     passes.push_pass(MIR_CONST, mir::transform::type_check::TypeckMir);\n     passes.push_pass(MIR_CONST, mir::transform::rustc_peek::SanityCheck);\n \n-    // We compute \"constant qualifications\" betwen MIR_CONST and MIR_VALIDATED.\n+    // We compute \"constant qualifications\" between MIR_CONST and MIR_VALIDATED.\n \n     // What we need to run borrowck etc.\n     passes.push_pass(MIR_VALIDATED, mir::transform::qualify_consts::QualifyAndPromoteConstants);\n@@ -1104,7 +1097,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n /// Run the translation phase to LLVM, after which the AST and analysis can\n /// be discarded.\n-#[cfg(feature=\"llvm\")]\n pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            analysis: ty::CrateAnalysis,\n                                            incremental_hashes_map: IncrementalHashesMap,\n@@ -1114,7 +1106,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     time(time_passes,\n          \"resolving dependency formats\",\n-         || dependency_format::calculate(tcx));\n+         || ::rustc::middle::dependency_format::calculate(tcx));\n \n     let translation =\n         time(time_passes,\n@@ -1149,9 +1141,9 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n pub fn phase_6_link_output(sess: &Session,\n                            trans: &trans::CrateTranslation,\n                            outputs: &OutputFilenames) {\n-    time(sess.time_passes(),\n-         \"linking\",\n-         || link::link_binary(sess, trans, outputs, &trans.crate_name.as_str()));\n+    time(sess.time_passes(), \"linking\", || {\n+        ::rustc_trans::back::link::link_binary(sess, trans, outputs, &trans.crate_name.as_str())\n+    });\n }\n \n fn escape_dep_filename(filename: &str) -> String {"}, {"sha": "f8cd2280cafe1e5779ab0c277e3538ecf3f21d3d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 87, "deletions": 60, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -28,15 +28,10 @@\n #![feature(rustc_diagnostic_macros)]\n #![feature(set_stdio)]\n \n-#[cfg(not(feature=\"llvm\"))]\n-extern crate ar;\n-\n extern crate arena;\n extern crate getopts;\n extern crate graphviz;\n extern crate env_logger;\n-#[cfg(not(feature=\"llvm\"))]\n-extern crate owning_ref;\n extern crate libc;\n extern crate rustc;\n extern crate rustc_allocator;\n@@ -71,8 +66,6 @@ use pretty::{PpMode, UserIdentifiedItem};\n use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n-#[cfg(feature=\"llvm\")]\n-use rustc_trans::back::write::{RELOC_MODEL_ARGS, CODE_GEN_MODEL_ARGS};\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::CompileIncomplete;\n@@ -81,13 +74,9 @@ use rustc::session::config::nightly_options;\n use rustc::session::{early_error, early_warn};\n use rustc::lint::Lint;\n use rustc::lint;\n-#[cfg(not(feature=\"llvm\"))]\n-use rustc::middle::cstore::MetadataLoader as MetadataLoaderTrait;\n use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n use rustc::util::common::{time, ErrorReported};\n-#[cfg(not(feature=\"llvm\"))]\n-use rustc_back::target::Target;\n \n use serialize::json::ToJson;\n \n@@ -100,8 +89,6 @@ use std::ffi::OsString;\n use std::io::{self, Read, Write};\n use std::iter::repeat;\n use std::path::PathBuf;\n-#[cfg(not(feature=\"llvm\"))]\n-use std::path::Path;\n use std::process::{self, Command, Stdio};\n use std::rc::Rc;\n use std::str;\n@@ -114,15 +101,11 @@ use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n use syntax_pos::{DUMMY_SP, MultiSpan};\n \n-#[cfg(not(feature=\"llvm\"))]\n-use owning_ref::{OwningRef, ErasedBoxRef};\n-\n #[cfg(test)]\n pub mod test;\n \n pub mod driver;\n pub mod pretty;\n-#[cfg(feature=\"llvm\")]\n pub mod target_features;\n mod derive_registrar;\n \n@@ -169,48 +152,106 @@ pub fn run<F>(run_compiler: F) -> isize\n }\n \n #[cfg(not(feature=\"llvm\"))]\n-pub struct NoLLvmMetadataLoader;\n-\n-#[cfg(not(feature=\"llvm\"))]\n-pub use NoLLvmMetadataLoader as MetadataLoader;\n+pub use no_llvm_metadata_loader::NoLLvmMetadataLoader as MetadataLoader;\n #[cfg(feature=\"llvm\")]\n pub use rustc_trans::LlvmMetadataLoader as MetadataLoader;\n \n #[cfg(not(feature=\"llvm\"))]\n-impl MetadataLoaderTrait for NoLLvmMetadataLoader {\n-    fn get_rlib_metadata(&self, _: &Target, filename: &Path) -> Result<ErasedBoxRef<[u8]>, String> {\n-        use std::fs::File;\n-        use std::io;\n-        use self::ar::Archive;\n-\n-        let file = File::open(filename).map_err(|e|format!(\"metadata file open err: {:?}\", e))?;\n-        let mut archive = Archive::new(file);\n-\n-        while let Some(entry_result) = archive.next_entry() {\n-            let mut entry = entry_result.map_err(|e|format!(\"metadata section read err: {:?}\", e))?;\n-            if entry.header().identifier() == \"rust.metadata.bin\" {\n-                let mut buf = Vec::new();\n-                io::copy(&mut entry, &mut buf).unwrap();\n-                let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n-                return Ok(buf.map_owner_box().erase_owner());\n+mod no_llvm_metadata_loader {\n+    extern crate ar;\n+    extern crate owning_ref;\n+\n+    use rustc::middle::cstore::MetadataLoader as MetadataLoaderTrait;\n+    use rustc_back::target::Target;\n+    use std::io;\n+    use std::fs::File;\n+    use std::path::Path;\n+\n+    use self::ar::Archive;\n+    use self::owning_ref::{OwningRef, ErasedBoxRef};\n+\n+    pub struct NoLLvmMetadataLoader;\n+\n+    impl MetadataLoaderTrait for NoLLvmMetadataLoader {\n+        fn get_rlib_metadata(\n+            &self,\n+            _: &Target,\n+            filename: &Path\n+        ) -> Result<ErasedBoxRef<[u8]>, String> {\n+            let file = File::open(filename).map_err(|e| {\n+                format!(\"metadata file open err: {:?}\", e)\n+            })?;\n+            let mut archive = Archive::new(file);\n+\n+            while let Some(entry_result) = archive.next_entry() {\n+                let mut entry = entry_result.map_err(|e| {\n+                    format!(\"metadata section read err: {:?}\", e)\n+                })?;\n+                if entry.header().identifier() == \"rust.metadata.bin\" {\n+                    let mut buf = Vec::new();\n+                    io::copy(&mut entry, &mut buf).unwrap();\n+                    let buf: OwningRef<Vec<u8>, [u8]> = OwningRef::new(buf).into();\n+                    return Ok(buf.map_owner_box().erase_owner());\n+                }\n             }\n+\n+            Err(\"Couldnt find metadata section\".to_string())\n         }\n \n-        Err(\"Couldnt find metadata section\".to_string())\n+        fn get_dylib_metadata(&self,\n+                            _target: &Target,\n+                            _filename: &Path)\n+                            -> Result<ErasedBoxRef<[u8]>, String> {\n+            panic!(\"Dylib metadata loading not supported without LLVM\")\n+        }\n     }\n+}\n \n-    fn get_dylib_metadata(&self,\n-                          _target: &Target,\n-                          _filename: &Path)\n-                          -> Result<ErasedBoxRef<[u8]>, String> {\n-        panic!(\"Dylib metadata loading not supported without LLVM\")\n+#[cfg(not(feature=\"llvm\"))]\n+mod rustc_trans {\n+    use syntax_pos::symbol::Symbol;\n+    use rustc::session::Session;\n+    use rustc::session::config::{PrintRequest, OutputFilenames};\n+    use rustc::ty::{TyCtxt, CrateAnalysis};\n+    use rustc::ty::maps::Providers;\n+    use rustc_incremental::IncrementalHashesMap;\n+\n+    use self::back::write::OngoingCrateTranslation;\n+\n+    pub fn init(_sess: &Session) {}\n+    pub fn enable_llvm_debug() {}\n+    pub fn provide(_providers: &mut Providers) {}\n+    pub fn print_version() {}\n+    pub fn print_passes() {}\n+    pub fn print(_req: PrintRequest, _sess: &Session) {}\n+    pub fn target_features(_sess: &Session) -> Vec<Symbol> { vec![] }\n+\n+    pub fn trans_crate<'a, 'tcx>(\n+        _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+        _analysis: CrateAnalysis,\n+        _incr_hashes_map: IncrementalHashesMap,\n+        _output_filenames: &OutputFilenames\n+    ) -> OngoingCrateTranslation {\n+        OngoingCrateTranslation(())\n     }\n+\n+    pub struct CrateTranslation(());\n+\n+    pub mod back {\n+        pub mod write {\n+            pub struct OngoingCrateTranslation(pub (in ::rustc_trans) ());\n+\n+            pub const RELOC_MODEL_ARGS: [(&'static str, ()); 0] = [];\n+            pub const CODE_GEN_MODEL_ARGS: [(&'static str, ()); 0] = [];\n+        }\n+    }\n+\n+    __build_diagnostic_array! { librustc_trans, DIAGNOSTICS }\n }\n \n // Parse args and run the compiler. This is the primary entry point for rustc.\n // See comments on CompilerCalls below for details about the callbacks argument.\n // The FileLoader provides a way to load files from sources other than the file system.\n-#[cfg_attr(not(feature=\"llvm\"), allow(unused_mut))]\n pub fn run_compiler<'a>(args: &[String],\n                         callbacks: &mut CompilerCalls<'a>,\n                         file_loader: Option<Box<FileLoader + 'static>>,\n@@ -232,7 +273,6 @@ pub fn run_compiler<'a>(args: &[String],\n     let (sopts, cfg) = config::build_session_options_and_crate_config(&matches);\n \n     if sopts.debugging_opts.debug_llvm {\n-        #[cfg(feature=\"llvm\")]\n         rustc_trans::enable_llvm_debug();\n     }\n \n@@ -262,12 +302,10 @@ pub fn run_compiler<'a>(args: &[String],\n     let mut sess = session::build_session_with_codemap(\n         sopts, &dep_graph, input_file_path, descriptions, cstore.clone(), codemap, emitter_dest,\n     );\n-    #[cfg(feature=\"llvm\")]\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n \n     let mut cfg = config::build_configuration(&sess, cfg);\n-    #[cfg(feature=\"llvm\")]\n     target_features::add_configuration(&mut cfg, &sess);\n     sess.parse_sess.config = cfg;\n \n@@ -520,7 +558,6 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n         Compilation::Continue\n     }\n \n-    #[cfg_attr(not(feature=\"llvm\"), allow(unused_mut))]\n     fn no_input(&mut self,\n                 matches: &getopts::Matches,\n                 sopts: &config::Options,\n@@ -544,11 +581,9 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n                     None,\n                     descriptions.clone(),\n                     cstore.clone());\n-                #[cfg(feature=\"llvm\")]\n                 rustc_trans::init(&sess);\n                 rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n                 let mut cfg = config::build_configuration(&sess, cfg.clone());\n-                #[cfg(feature=\"llvm\")]\n                 target_features::add_configuration(&mut cfg, &sess);\n                 sess.parse_sess.config = cfg;\n                 let should_stop =\n@@ -802,25 +837,20 @@ impl RustcDefaultCalls {\n                 }\n                 PrintRequest::RelocationModels => {\n                     println!(\"Available relocation models:\");\n-                    #[cfg(feature=\"llvm\")]\n-                    for &(name, _) in RELOC_MODEL_ARGS.iter() {\n+                    for &(name, _) in rustc_trans::back::write::RELOC_MODEL_ARGS.iter() {\n                         println!(\"    {}\", name);\n                     }\n                     println!(\"\");\n                 }\n                 PrintRequest::CodeModels => {\n                     println!(\"Available code models:\");\n-                    #[cfg(feature=\"llvm\")]\n-                    for &(name, _) in CODE_GEN_MODEL_ARGS.iter(){\n+                    for &(name, _) in rustc_trans::back::write::CODE_GEN_MODEL_ARGS.iter(){\n                         println!(\"    {}\", name);\n                     }\n                     println!(\"\");\n                 }\n                 PrintRequest::TargetCPUs | PrintRequest::TargetFeatures => {\n-                    #[cfg(feature=\"llvm\")]\n                     rustc_trans::print(*req, sess);\n-                    #[cfg(not(feature=\"llvm\"))]\n-                    panic!(\"LLVM not supported by this rustc\")\n                 }\n             }\n         }\n@@ -859,7 +889,6 @@ pub fn version(binary: &str, matches: &getopts::Matches) {\n         println!(\"commit-date: {}\", unw(commit_date_str()));\n         println!(\"host: {}\", config::host_triple());\n         println!(\"release: {}\", unw(release_str()));\n-        #[cfg(feature=\"llvm\")]\n         rustc_trans::print_version();\n     }\n }\n@@ -1157,7 +1186,6 @@ pub fn handle_options(args: &[String]) -> Option<getopts::Matches> {\n     }\n \n     if cg_flags.contains(&\"passes=list\".to_string()) {\n-        #[cfg(feature=\"llvm\")]\n         rustc_trans::print_passes();\n         return None;\n     }\n@@ -1285,7 +1313,6 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     all_errors.extend_from_slice(&rustc_borrowck::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n-    #[cfg(feature=\"llvm\")]\n     all_errors.extend_from_slice(&rustc_trans::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_const_eval::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_metadata::DIAGNOSTICS);"}, {"sha": "84d3ab65b1c1f6eab9e44031ba670f51905d9256", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -44,6 +44,7 @@ use std::io::{self, Write};\n use std::option;\n use std::path::Path;\n use std::str::FromStr;\n+use std::mem;\n \n use rustc::hir::map as hir_map;\n use rustc::hir::map::blocks;\n@@ -232,7 +233,7 @@ impl PpSourceMode {\n                                                                  arenas,\n                                                                  id,\n                                                                  |tcx, _, _, _| {\n-                    let empty_tables = ty::TypeckTables::empty();\n+                    let empty_tables = ty::TypeckTables::empty(None);\n                     let annotation = TypedAnnotation {\n                         tcx: tcx,\n                         tables: Cell::new(&empty_tables)\n@@ -618,52 +619,53 @@ impl UserIdentifiedItem {\n     }\n }\n \n-struct ReplaceBodyWithLoop {\n+// Note: Also used by librustdoc, see PR #43348. Consider moving this struct elsewhere.\n+pub struct ReplaceBodyWithLoop {\n     within_static_or_const: bool,\n }\n \n impl ReplaceBodyWithLoop {\n-    fn new() -> ReplaceBodyWithLoop {\n+    pub fn new() -> ReplaceBodyWithLoop {\n         ReplaceBodyWithLoop { within_static_or_const: false }\n     }\n+\n+    fn run<R, F: FnOnce(&mut Self) -> R>(&mut self, is_const: bool, action: F) -> R {\n+        let old_const = mem::replace(&mut self.within_static_or_const, is_const);\n+        let ret = action(self);\n+        self.within_static_or_const = old_const;\n+        ret\n+    }\n }\n \n impl fold::Folder for ReplaceBodyWithLoop {\n     fn fold_item_kind(&mut self, i: ast::ItemKind) -> ast::ItemKind {\n-        match i {\n-            ast::ItemKind::Static(..) |\n-            ast::ItemKind::Const(..) => {\n-                self.within_static_or_const = true;\n-                let ret = fold::noop_fold_item_kind(i, self);\n-                self.within_static_or_const = false;\n-                return ret;\n-            }\n-            _ => fold::noop_fold_item_kind(i, self),\n-        }\n+        let is_const = match i {\n+            ast::ItemKind::Static(..) | ast::ItemKind::Const(..) => true,\n+            ast::ItemKind::Fn(_, _, ref constness, _, _, _) =>\n+                constness.node == ast::Constness::Const,\n+            _ => false,\n+        };\n+        self.run(is_const, |s| fold::noop_fold_item_kind(i, s))\n     }\n \n     fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n-        match i.node {\n-            ast::TraitItemKind::Const(..) => {\n-                self.within_static_or_const = true;\n-                let ret = fold::noop_fold_trait_item(i, self);\n-                self.within_static_or_const = false;\n-                return ret;\n-            }\n-            _ => fold::noop_fold_trait_item(i, self),\n-        }\n+        let is_const = match i.node {\n+            ast::TraitItemKind::Const(..) => true,\n+            ast::TraitItemKind::Method(ast::MethodSig { ref constness, .. }, _) =>\n+                constness.node == ast::Constness::Const,\n+            _ => false,\n+        };\n+        self.run(is_const, |s| fold::noop_fold_trait_item(i, s))\n     }\n \n     fn fold_impl_item(&mut self, i: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n-        match i.node {\n-            ast::ImplItemKind::Const(..) => {\n-                self.within_static_or_const = true;\n-                let ret = fold::noop_fold_impl_item(i, self);\n-                self.within_static_or_const = false;\n-                return ret;\n-            }\n-            _ => fold::noop_fold_impl_item(i, self),\n-        }\n+        let is_const = match i.node {\n+            ast::ImplItemKind::Const(..) => true,\n+            ast::ImplItemKind::Method(ast::MethodSig { ref constness, .. }, _) =>\n+                constness.node == ast::Constness::Const,\n+            _ => false,\n+        };\n+        self.run(is_const, |s| fold::noop_fold_impl_item(i, s))\n     }\n \n     fn fold_block(&mut self, b: P<ast::Block>) -> P<ast::Block> {"}, {"sha": "b187cdaa480ed17fff846ff205846c7827f78178", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -14,7 +14,6 @@ use driver;\n use rustc::dep_graph::DepGraph;\n use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n-#[cfg(feature=\"llvm\")]\n use rustc_trans;\n use rustc::middle::lang_items;\n use rustc::middle::free_region::FreeRegionMap;\n@@ -114,7 +113,6 @@ fn test_env<F>(source_string: &str,\n                                        diagnostic_handler,\n                                        Rc::new(CodeMap::new(FilePathMapping::empty())),\n                                        cstore.clone());\n-    #[cfg(feature=\"llvm\")]\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {"}, {"sha": "3bfe2897de175866e03b8855204424a214d8affa", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -139,7 +139,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n-        let ty = cx.tables.node_id_to_type(e.id);\n+        let ty = cx.tables.node_id_to_type(e.hir_id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n }\n@@ -195,24 +195,35 @@ impl LintPass for UnsafeCode {\n     }\n }\n \n+impl UnsafeCode {\n+    fn report_unsafe(&self, cx: &LateContext, span: Span, desc: &'static str) {\n+        // This comes from a macro that has #[allow_internal_unsafe].\n+        if span.allows_unsafe() {\n+            return;\n+        }\n+\n+        cx.span_lint(UNSAFE_CODE, span, desc);\n+    }\n+}\n+\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n     fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n         if let hir::ExprBlock(ref blk) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             if blk.rules == hir::UnsafeBlock(hir::UserProvided) {\n-                cx.span_lint(UNSAFE_CODE, blk.span, \"usage of an `unsafe` block\");\n+                self.report_unsafe(cx, blk.span, \"usage of an `unsafe` block\");\n             }\n         }\n     }\n \n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n         match it.node {\n             hir::ItemTrait(hir::Unsafety::Unsafe, ..) => {\n-                cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` trait\")\n+                self.report_unsafe(cx, it.span, \"declaration of an `unsafe` trait\")\n             }\n \n             hir::ItemImpl(hir::Unsafety::Unsafe, ..) => {\n-                cx.span_lint(UNSAFE_CODE, it.span, \"implementation of an `unsafe` trait\")\n+                self.report_unsafe(cx, it.span, \"implementation of an `unsafe` trait\")\n             }\n \n             _ => return,\n@@ -228,12 +239,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n                 _: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, _, hir::Unsafety::Unsafe, ..) => {\n-                cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\")\n+                self.report_unsafe(cx, span, \"declaration of an `unsafe` function\")\n             }\n \n             FnKind::Method(_, sig, ..) => {\n                 if sig.unsafety == hir::Unsafety::Unsafe {\n-                    cx.span_lint(UNSAFE_CODE, span, \"implementation of an `unsafe` method\")\n+                    self.report_unsafe(cx, span, \"implementation of an `unsafe` method\")\n                 }\n             }\n \n@@ -244,9 +255,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnsafeCode {\n     fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n         if let hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(_)) = item.node {\n             if sig.unsafety == hir::Unsafety::Unsafe {\n-                cx.span_lint(UNSAFE_CODE,\n-                             item.span,\n-                             \"declaration of an `unsafe` method\")\n+                self.report_unsafe(cx, item.span, \"declaration of an `unsafe` method\")\n             }\n         }\n     }\n@@ -896,7 +905,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             match cx.tcx.hir.get(id) {\n                 hir_map::NodeExpr(&hir::Expr { node: hir::ExprCall(ref callee, _), .. }) => {\n                     let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                        cx.tables.qpath_def(qpath, callee.id)\n+                        cx.tables.qpath_def(qpath, callee.hir_id)\n                     } else {\n                         return false;\n                     };\n@@ -934,8 +943,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n \n             // Check for method calls and overloaded operators.\n             if cx.tables.is_method_call(expr) {\n-                let def_id = cx.tables.type_dependent_defs[&id].def_id();\n-                let substs = cx.tables.node_substs(id);\n+                let hir_id = cx.tcx.hir.definitions().node_to_hir_id(id);\n+                let def_id = cx.tables.type_dependent_defs()[hir_id].def_id();\n+                let substs = cx.tables.node_substs(hir_id);\n                 if method_call_refers_to_method(cx, method, def_id, substs, id) {\n                     return true;\n                 }\n@@ -945,13 +955,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             match expr.node {\n                 hir::ExprCall(ref callee, _) => {\n                     let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                        cx.tables.qpath_def(qpath, callee.id)\n+                        cx.tables.qpath_def(qpath, callee.hir_id)\n                     } else {\n                         return false;\n                     };\n                     match def {\n                         Def::Method(def_id) => {\n-                            let substs = cx.tables.node_substs(callee.id);\n+                            let substs = cx.tables.node_substs(callee.hir_id);\n                             method_call_refers_to_method(cx, method, def_id, substs, id)\n                         }\n                         _ => false,\n@@ -1179,15 +1189,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n              expr: &hir::Expr)\n              -> Option<(&'tcx ty::TypeVariants<'tcx>, &'tcx ty::TypeVariants<'tcx>)> {\n             let def = if let hir::ExprPath(ref qpath) = expr.node {\n-                cx.tables.qpath_def(qpath, expr.id)\n+                cx.tables.qpath_def(qpath, expr.hir_id)\n             } else {\n                 return None;\n             };\n             if let Def::Fn(did) = def {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n-                let sig = cx.tables.node_id_to_type(expr.id).fn_sig(cx.tcx);\n+                let sig = cx.tables.node_id_to_type(expr.hir_id).fn_sig(cx.tcx);\n                 let from = sig.inputs().skip_binder()[0];\n                 let to = *sig.output().skip_binder();\n                 return Some((&from.sty, &to.sty));"}, {"sha": "daf7d743e1235209f1309fd50a0d917d0db88615", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -92,7 +92,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 }\n \n                 if binop.node.is_shift() {\n-                    let opt_ty_bits = match cx.tables.node_id_to_type(l.id).sty {\n+                    let opt_ty_bits = match cx.tables.node_id_to_type(l.hir_id).sty {\n                         ty::TyInt(t) => Some(int_ty_bits(t, cx.sess().target.int_type)),\n                         ty::TyUint(t) => Some(uint_ty_bits(t, cx.sess().target.uint_type)),\n                         _ => None,\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 }\n             }\n             hir::ExprLit(ref lit) => {\n-                match cx.tables.node_id_to_type(e.id).sty {\n+                match cx.tables.node_id_to_type(e.hir_id).sty {\n                     ty::TyInt(t) => {\n                         match lit.node {\n                             ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n             let norm_binop = if swap { rev_binop(binop) } else { binop };\n-            match cx.tables.node_id_to_type(expr.id).sty {\n+            match cx.tables.node_id_to_type(expr.hir_id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n                     let lit_val: i128 = match lit.node {"}, {"sha": "195bd2acce0fe3ed1ee2ad7837f5eb2a5d23e836", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -45,7 +45,8 @@ impl UnusedMut {\n         let mut mutables = FxHashMap();\n         for p in pats {\n             p.each_binding(|_, id, span, path1| {\n-                let bm = match cx.tables.pat_binding_modes.get(&id) {\n+                let hir_id = cx.tcx.hir.node_to_hir_id(id);\n+                let bm = match cx.tables.pat_binding_modes().get(hir_id) {\n                     Some(&bm) => bm,\n                     None => span_bug!(span, \"missing binding mode\"),\n                 };\n@@ -146,20 +147,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n \n         let t = cx.tables.expr_ty(&expr);\n         let ty_warned = match t.sty {\n-            ty::TyAdt(def, _) => check_must_use(cx, def.did, s.span, \"\"),\n+            ty::TyTuple(ref tys, _) if tys.is_empty() => return,\n+            ty::TyNever => return,\n+            ty::TyAdt(def, _) => {\n+                if def.variants.is_empty() {\n+                    return;\n+                } else {\n+                    check_must_use(cx, def.did, s.span, \"\")\n+                }\n+            },\n             _ => false,\n         };\n \n         let mut fn_warned = false;\n         let maybe_def = match expr.node {\n             hir::ExprCall(ref callee, _) => {\n                 match callee.node {\n-                    hir::ExprPath(ref qpath) => Some(cx.tables.qpath_def(qpath, callee.id)),\n+                    hir::ExprPath(ref qpath) => Some(cx.tables.qpath_def(qpath, callee.hir_id)),\n                     _ => None\n                 }\n             },\n             hir::ExprMethodCall(..) => {\n-                cx.tables.type_dependent_defs.get(&expr.id).cloned()\n+                cx.tables.type_dependent_defs().get(expr.hir_id).cloned()\n             },\n             _ => { None }\n         };"}, {"sha": "cb3ad6743a7dc0e49f6ee9525bedc4579721832a", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -90,7 +90,8 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n         } else if let MirSource::Fn(id) = src {\n             // fetch the fully liberated fn signature (that is, all bound\n             // types/lifetimes replaced)\n-            let fn_sig = cx.tables().liberated_fn_sigs[&id].clone();\n+            let fn_hir_id = tcx.hir.node_to_hir_id(id);\n+            let fn_sig = cx.tables().liberated_fn_sigs()[fn_hir_id].clone();\n \n             let ty = tcx.type_of(tcx.hir.local_def_id(id));\n             let mut abi = fn_sig.abi;\n@@ -215,7 +216,8 @@ pub fn closure_self_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              closure_expr_id: ast::NodeId,\n                              body_id: hir::BodyId)\n                              -> Ty<'tcx> {\n-    let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_id);\n+    let closure_expr_hir_id = tcx.hir.node_to_hir_id(closure_expr_id);\n+    let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_hir_id);\n \n     let closure_def_id = tcx.hir.local_def_id(closure_expr_id);\n     let region = ty::ReFree(ty::FreeRegion {\n@@ -382,10 +384,12 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     // Gather the upvars of a closure, if any.\n     let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n         freevars.iter().map(|fv| {\n-            let var_id = tcx.hir.as_local_node_id(fv.def.def_id()).unwrap();\n+            let var_def_id = fv.def.def_id();\n+            let var_node_id = tcx.hir.as_local_node_id(var_def_id).unwrap();\n+            let closure_expr_id = tcx.hir.local_def_id(fn_id).index;\n             let capture = hir.tables().upvar_capture(ty::UpvarId {\n-                var_id: var_id,\n-                closure_expr_id: fn_id\n+                var_id: var_def_id.index,\n+                closure_expr_id,\n             });\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue => false,\n@@ -395,7 +399,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 debug_name: keywords::Invalid.name(),\n                 by_ref: by_ref\n             };\n-            if let Some(hir::map::NodeLocal(pat)) = tcx.hir.find(var_id) {\n+            if let Some(hir::map::NodeLocal(pat)) = tcx.hir.find(var_node_id) {\n                 if let hir::PatKind::Binding(_, _, ref ident, _) = pat.node {\n                     decl.debug_name = ident.node;\n                 }"}, {"sha": "4ef4733c1c78e5657b84ccae9ccb5769c88d327a", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -113,7 +113,7 @@ pub struct Scope<'tcx> {\n     /// for unwinding, for several reasons:\n     ///  * clang doesn't emit llvm.lifetime.end for C++ unwinding\n     ///  * LLVM's memory dependency analysis can't handle it atm\n-    ///  * pollutting the cleanup MIR with StorageDead creates\n+    ///  * polluting the cleanup MIR with StorageDead creates\n     ///    landing pads even though there's no actual destructors\n     ///  * freeing up stack space has no effect during unwinding\n     needs_cleanup: bool,"}, {"sha": "41019799e41de76ef3cd376835d561fff9a289f4", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedLvals<'a, 'tcx> {\n /// you if an l-value *might* be uninitialized at a given point in the\n /// control flow. But `MovingOutStatements` also includes the added\n /// data of *which* particular statement causing the deinitialization\n-/// that the borrow checker's error meessage may need to report.\n+/// that the borrow checker's error message may need to report.\n #[allow(dead_code)]\n pub struct MovingOutStatements<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "eeb9d14807d9a6998903accc7d7046d27449ffc5", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -333,11 +333,11 @@ pub trait BitDenotation {\n     /// basic block) according to the effects of evaluating statement.\n     ///\n     /// This is used, in particular, for building up the\n-    /// \"transfer-function\" represnting the overall-effect of the\n+    /// \"transfer-function\" representing the overall-effect of the\n     /// block, represented via GEN and KILL sets.\n     ///\n     /// The statement is identified as `bb_data[idx_stmt]`, where\n-    /// `bb_data` is the sequence of statements identifed by `bb` in\n+    /// `bb_data` is the sequence of statements identified by `bb` in\n     /// the MIR.\n     fn statement_effect(&self,\n                         sets: &mut BlockSets<Self::Idx>,\n@@ -349,7 +349,7 @@ pub trait BitDenotation {\n     /// the terminator.\n     ///\n     /// This is used, in particular, for building up the\n-    /// \"transfer-function\" represnting the overall-effect of the\n+    /// \"transfer-function\" representing the overall-effect of the\n     /// block, represented via GEN and KILL sets.\n     ///\n     /// The effects applied here cannot depend on which branch the"}, {"sha": "34170a6609c4674d4163d594fb230d5e16aa5e75", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -442,4 +442,5 @@ static A : &'static u32 = &S.a; // ok!\n \n register_diagnostics! {\n     E0526, // shuffle indices are not constant\n+    E0625, // thread-local statics cannot be accessed at compile-time\n }"}, {"sha": "fa54925c6e75e1d2330eabc6070d9858dd2f6b9d", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -95,7 +95,7 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n pub fn to_expr_ref<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    block: &'tcx hir::Block)\n                                    -> ExprRef<'tcx> {\n-    let block_ty = cx.tables().node_id_to_type(block.id);\n+    let block_ty = cx.tables().node_id_to_type(block.hir_id);\n     let temp_lifetime = cx.region_maps.temporary_scope(block.id);\n     let expr = Expr {\n         ty: block_ty,"}, {"sha": "c4eb0008df80b3f41260753105c53de89ffc8d5d", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -217,7 +217,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     None\n                 };\n                 if let Some((adt_def, index)) = adt_data {\n-                    let substs = cx.tables().node_substs(fun.id);\n+                    let substs = cx.tables().node_substs(fun.hir_id);\n                     let field_refs = args.iter()\n                         .enumerate()\n                         .map(|(idx, e)| {\n@@ -236,7 +236,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     }\n                 } else {\n                     ExprKind::Call {\n-                        ty: cx.tables().node_id_to_type(fun.id),\n+                        ty: cx.tables().node_id_to_type(fun.hir_id),\n                         fun: fun.to_ref(),\n                         args: args.to_ref(),\n                     }\n@@ -389,7 +389,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 base: base.as_ref().map(|base| {\n                                     FruInfo {\n                                         base: base.to_ref(),\n-                                        field_types: cx.tables().fru_field_types[&expr.id].clone(),\n+                                        field_types: cx.tables()\n+                                                       .fru_field_types()[expr.hir_id]\n+                                                       .clone(),\n                                     }\n                                 }),\n                             }\n@@ -452,7 +454,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n \n         hir::ExprPath(ref qpath) => {\n-            let def = cx.tables().qpath_def(qpath, expr.id);\n+            let def = cx.tables().qpath_def(qpath, expr.hir_id);\n             convert_path_expr(cx, expr, def)\n         }\n \n@@ -550,7 +552,9 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         hir::ExprCast(ref source, _) => {\n             // Check to see if this cast is a \"coercion cast\", where the cast is actually done\n             // using a coercion (or is a no-op).\n-            if let Some(&TyCastKind::CoercionCast) = cx.tables().cast_kinds.get(&source.id) {\n+            if let Some(&TyCastKind::CoercionCast) = cx.tables()\n+                                                       .cast_kinds()\n+                                                       .get(source.hir_id) {\n                 // Convert the lexpr to a vexpr.\n                 ExprKind::Use { source: source.to_ref() }\n             } else {\n@@ -583,8 +587,8 @@ fn method_callee<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                  -> Expr<'tcx> {\n     let temp_lifetime = cx.region_maps.temporary_scope(expr.id);\n     let (def_id, substs) = custom_callee.unwrap_or_else(|| {\n-        (cx.tables().type_dependent_defs[&expr.id].def_id(),\n-         cx.tables().node_substs(expr.id))\n+        (cx.tables().type_dependent_defs()[expr.hir_id].def_id(),\n+         cx.tables().node_substs(expr.hir_id))\n     });\n     Expr {\n         temp_lifetime: temp_lifetime,\n@@ -622,7 +626,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                      expr: &'tcx hir::Expr,\n                                      def: Def)\n                                      -> ExprKind<'tcx> {\n-    let substs = cx.tables().node_substs(expr.id);\n+    let substs = cx.tables().node_substs(expr.hir_id);\n     match def {\n         // A regular function, constructor function or a constant.\n         Def::Fn(def_id) |\n@@ -644,7 +648,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n         Def::VariantCtor(def_id, CtorKind::Const) => {\n-            match cx.tables().node_id_to_type(expr.id).sty {\n+            match cx.tables().node_id_to_type(expr.hir_id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n                 ty::TyAdt(adt_def, substs) => {\n@@ -680,16 +684,18 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             ExprKind::VarRef { id: node_id }\n         }\n \n-        Def::Upvar(def_id, index, closure_expr_id) => {\n-            let id_var = cx.tcx.hir.as_local_node_id(def_id).unwrap();\n+        Def::Upvar(var_def_id, index, closure_expr_id) => {\n+            let id_var = cx.tcx.hir.as_local_node_id(var_def_id).unwrap();\n             debug!(\"convert_var(upvar({:?}, {:?}, {:?}))\",\n                    id_var,\n                    index,\n                    closure_expr_id);\n-            let var_ty = cx.tables().node_id_to_type(id_var);\n+            let var_ty = cx.tables()\n+                           .node_id_to_type(cx.tcx.hir.node_to_hir_id(id_var));\n \n             // FIXME free regions in closures are not right\n-            let closure_ty = cx.tables().node_id_to_type(closure_expr_id);\n+            let closure_ty = cx.tables()\n+                               .node_id_to_type(cx.tcx.hir.node_to_hir_id(closure_expr_id));\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n@@ -771,8 +777,8 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // ...but the upvar might be an `&T` or `&mut T` capture, at which\n             // point we need an implicit deref\n             let upvar_id = ty::UpvarId {\n-                var_id: id_var,\n-                closure_expr_id: closure_expr_id,\n+                var_id: var_def_id.index,\n+                closure_expr_id: closure_def_id.index,\n             };\n             match cx.tables().upvar_capture(upvar_id) {\n                 ty::UpvarCapture::ByValue => field_kind,\n@@ -883,14 +889,16 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                    freevar: &hir::Freevar,\n                                    freevar_ty: Ty<'tcx>)\n                                    -> ExprRef<'tcx> {\n-    let id_var = cx.tcx.hir.as_local_node_id(freevar.def.def_id()).unwrap();\n+    let var_def_id = freevar.def.def_id();\n+    let var_node_id = cx.tcx.hir.as_local_node_id(var_def_id).unwrap();\n     let upvar_id = ty::UpvarId {\n-        var_id: id_var,\n-        closure_expr_id: closure_expr.id,\n+        var_id: var_def_id.index,\n+        closure_expr_id: cx.tcx.hir.local_def_id(closure_expr.id).index,\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_maps.temporary_scope(closure_expr.id);\n-    let var_ty = cx.tables().node_id_to_type(id_var);\n+    let var_ty = cx.tables()\n+                   .node_id_to_type(cx.tcx.hir.node_to_hir_id(var_node_id));\n     let captured_var = Expr {\n         temp_lifetime: temp_lifetime,\n         ty: var_ty,"}, {"sha": "9bd5df16a14e9ff31f88cc38f844f6d5c3cd157d", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -80,7 +80,7 @@ pub enum StmtKind<'tcx> {\n \n /// The Hair trait implementor translates their expressions (`&'tcx H::Expr`)\n /// into instances of this `Expr` enum. This translation can be done\n-/// basically as lazilly or as eagerly as desired: every recursive\n+/// basically as lazily or as eagerly as desired: every recursive\n /// reference to an expression in this enum is an `ExprRef<'tcx>`, which\n /// may in turn be another instance of this enum (boxed), or else an\n /// untranslated `&'tcx H::Expr`. Note that instances of `Expr` are very"}, {"sha": "89de847231c85e09c1986f42f3d778ccc06e792a", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! This pass erases all early-bound regions from the types occuring in the MIR.\n+//! This pass erases all early-bound regions from the types occurring in the MIR.\n //! We want to do this once just before trans, so trans does not have to take\n //! care erasing regions all over the place.\n //! NOTE:  We do NOT erase regions of statements that are relevant for"}, {"sha": "24e9f4c6c34594f3662cf8f9a3f0c154b5fedb08", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -486,8 +486,20 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     }\n                 }\n             },\n-            Lvalue::Static(_) => {\n+            Lvalue::Static(ref global) => {\n                 self.add(Qualif::STATIC);\n+\n+                if self.mode != Mode::Fn {\n+                    for attr in &self.tcx.get_attrs(global.def_id)[..] {\n+                        if attr.check_name(\"thread_local\") {\n+                            span_err!(self.tcx.sess, self.span, E0625,\n+                                      \"thread-local statics cannot be \\\n+                                       accessed at compile-time\");\n+                            return;\n+                        }\n+                    }\n+                }\n+\n                 if self.mode == Mode::Const || self.mode == Mode::ConstFn {\n                     span_err!(self.tcx.sess, self.span, E0013,\n                               \"{}s cannot refer to statics, use \\\n@@ -1001,6 +1013,12 @@ impl MirPass for QualifyAndPromoteConstants {\n \n         // Statics must be Sync.\n         if mode == Mode::Static {\n+            // `#[thread_local]` statics don't have to be `Sync`.\n+            for attr in &tcx.get_attrs(def_id)[..] {\n+                if attr.check_name(\"thread_local\") {\n+                    return;\n+                }\n+            }\n             let ty = mir.return_ty;\n             tcx.infer_ctxt().enter(|infcx| {\n                 let param_env = ty::ParamEnv::empty(Reveal::UserFacing);"}, {"sha": "b22f8112d7a38e889a85b8f85c9fb7c8e6f788e5", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -94,10 +94,25 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    /// matches '-' lit | lit (cf. parser::Parser::parse_pat_literal_maybe_minus)\n-    fn check_expr_within_pat(&self, expr: &Expr) {\n+    /// matches '-' lit | lit (cf. parser::Parser::parse_pat_literal_maybe_minus),\n+    /// or path for ranges.\n+    ///\n+    /// FIXME: do we want to allow expr -> pattern conversion to create path expressions?\n+    /// That means making this work:\n+    ///\n+    /// ```rust,ignore (FIXME)\n+    ///     struct S;\n+    ///     macro_rules! m {\n+    ///         ($a:expr) => {\n+    ///             let $a = S;\n+    ///         }\n+    ///     }\n+    ///     m!(S);\n+    /// ```\n+    fn check_expr_within_pat(&self, expr: &Expr, allow_paths: bool) {\n         match expr.node {\n-            ExprKind::Lit(..) | ExprKind::Path(..) => {}\n+            ExprKind::Lit(..) => {}\n+            ExprKind::Path(..) if allow_paths => {}\n             ExprKind::Unary(UnOp::Neg, ref inner)\n                 if match inner.node { ExprKind::Lit(_) => true, _ => false } => {}\n             _ => self.err_handler().span_err(expr.span, \"arbitrary expressions aren't allowed \\\n@@ -332,11 +347,11 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_pat(&mut self, pat: &'a Pat) {\n         match pat.node {\n             PatKind::Lit(ref expr) => {\n-                self.check_expr_within_pat(expr);\n+                self.check_expr_within_pat(expr, false);\n             }\n             PatKind::Range(ref start, ref end, _) => {\n-                self.check_expr_within_pat(start);\n-                self.check_expr_within_pat(end);\n+                self.check_expr_within_pat(start, true);\n+                self.check_expr_within_pat(end, true);\n             }\n             _ => {}\n         }"}, {"sha": "d53c4ef45d14a1f8eabe3af7c5622711e74e7d31", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -219,7 +219,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckCrateVisitor<'a, 'tcx> {\n         let outer = self.promotable;\n         self.promotable = true;\n \n-        let node_ty = self.tables.node_id_to_type(ex.id);\n+        let node_ty = self.tables.node_id_to_type(ex.hir_id);\n         check_expr(self, ex, node_ty);\n         check_adjustments(self, ex);\n \n@@ -297,7 +297,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             v.promotable = false;\n         }\n         hir::ExprUnary(op, ref inner) => {\n-            match v.tables.node_id_to_type(inner.id).sty {\n+            match v.tables.node_id_to_type(inner.hir_id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op == hir::UnDeref);\n \n@@ -307,7 +307,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprBinary(op, ref lhs, _) => {\n-            match v.tables.node_id_to_type(lhs.id).sty {\n+            match v.tables.node_id_to_type(lhs.hir_id).sty {\n                 ty::TyRawPtr(_) => {\n                     assert!(op.node == hir::BiEq || op.node == hir::BiNe ||\n                             op.node == hir::BiLe || op.node == hir::BiLt ||\n@@ -320,7 +320,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n         }\n         hir::ExprCast(ref from, _) => {\n             debug!(\"Checking const cast(id={})\", from.id);\n-            match v.tables.cast_kinds.get(&from.id) {\n+            match v.tables.cast_kinds().get(from.hir_id) {\n                 None => span_bug!(e.span, \"no kind for cast\"),\n                 Some(&CastKind::PtrAddrCast) | Some(&CastKind::FnPtrAddrCast) => {\n                     v.promotable = false;\n@@ -329,7 +329,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprPath(ref qpath) => {\n-            let def = v.tables.qpath_def(qpath, e.id);\n+            let def = v.tables.qpath_def(qpath, e.hir_id);\n             match def {\n                 Def::VariantCtor(..) | Def::StructCtor(..) |\n                 Def::Fn(..) | Def::Method(..) => {}\n@@ -365,7 +365,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n             // The callee is an arbitrary expression, it doesn't necessarily have a definition.\n             let def = if let hir::ExprPath(ref qpath) = callee.node {\n-                v.tables.qpath_def(qpath, callee.id)\n+                v.tables.qpath_def(qpath, callee.hir_id)\n             } else {\n                 Def::Err\n             };\n@@ -387,7 +387,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Expr, node\n             }\n         }\n         hir::ExprMethodCall(..) => {\n-            let def_id = v.tables.type_dependent_defs[&e.id].def_id();\n+            let def_id = v.tables.type_dependent_defs()[e.hir_id].def_id();\n             match v.tcx.associated_item(def_id).container {\n                 ty::ImplContainer(_) => v.handle_const_fn_call(def_id, node_ty),\n                 ty::TraitContainer(_) => v.promotable = false\n@@ -474,7 +474,7 @@ fn check_adjustments<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>, e: &hir::Exp\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.hir.krate().visit_all_item_likes(&mut CheckCrateVisitor {\n         tcx: tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(None),\n         in_fn: false,\n         promotable: false,\n         mut_rvalue_borrows: NodeSet(),"}, {"sha": "c6bc045f0de3bf16720bfa3effeaf48bcb1afa8a", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -125,6 +125,11 @@ impl<'v> hir_visit::Visitor<'v> for StatCollector<'v> {\n         self.visit_impl_item(nested_impl_item)\n     }\n \n+    fn visit_nested_body(&mut self, body_id: hir::BodyId) {\n+        let nested_body = self.krate.unwrap().body(body_id);\n+        self.visit_body(nested_body)\n+    }\n+\n     fn visit_item(&mut self, i: &'v hir::Item) {\n         self.record(\"Item\", Id::Node(i.id), i);\n         hir_visit::walk_item(self, i)"}, {"sha": "aac21f2af0d963e4144989873a20dbddc0c1ec57", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -102,9 +102,19 @@ impl<'a> Registry<'a> {\n             panic!(\"user-defined macros may not be named `macro_rules`\");\n         }\n         self.syntax_exts.push((name, match extension {\n-            NormalTT(ext, _, allow_internal_unstable) => {\n+            NormalTT {\n+                expander,\n+                def_info: _,\n+                allow_internal_unstable,\n+                allow_internal_unsafe\n+            } => {\n                 let nid = ast::CRATE_NODE_ID;\n-                NormalTT(ext, Some((nid, self.krate_span)), allow_internal_unstable)\n+                NormalTT {\n+                    expander,\n+                    def_info: Some((nid, self.krate_span)),\n+                    allow_internal_unstable,\n+                    allow_internal_unsafe\n+                }\n             }\n             IdentTT(ext, _, allow_internal_unstable) => {\n                 IdentTT(ext, Some(self.krate_span), allow_internal_unstable)\n@@ -134,8 +144,12 @@ impl<'a> Registry<'a> {\n     /// It builds for you a `NormalTT` that calls `expander`,\n     /// and also takes care of interning the macro's name.\n     pub fn register_macro(&mut self, name: &str, expander: MacroExpanderFn) {\n-        self.register_syntax_extension(Symbol::intern(name),\n-                                       NormalTT(Box::new(expander), None, false));\n+        self.register_syntax_extension(Symbol::intern(name), NormalTT {\n+            expander: Box::new(expander),\n+            def_info: None,\n+            allow_internal_unstable: false,\n+            allow_internal_unsafe: false,\n+        });\n     }\n \n     /// Register a compiler lint pass."}, {"sha": "983f478e07d620d3dec6f58837d7026e504c540c", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 66, "deletions": 12, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -448,6 +448,7 @@ impl<'b, 'a, 'tcx> TypeVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'b\n             ty::TyDynamic(ref obj, ..) => obj.principal().map(|p| p.def_id()),\n             ty::TyProjection(ref proj) => Some(proj.item_def_id),\n             ty::TyFnDef(def_id, ..) |\n+            ty::TyClosure(def_id, ..) |\n             ty::TyAnon(def_id, _) => Some(def_id),\n             _ => None\n         };\n@@ -473,6 +474,7 @@ struct NamePrivacyVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: ast::NodeId,\n+    empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n@@ -489,6 +491,22 @@ impl<'a, 'tcx> NamePrivacyVisitor<'a, 'tcx> {\n     }\n }\n \n+// Set the correct TypeckTables for the given `item_id` (or an empty table if\n+// there is no TypeckTables for the item).\n+fn update_tables<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           item_id: ast::NodeId,\n+                           tables: &mut &'a ty::TypeckTables<'tcx>,\n+                           empty_tables: &'a ty::TypeckTables<'tcx>)\n+                           -> &'a ty::TypeckTables<'tcx> {\n+    let def_id = tcx.hir.local_def_id(item_id);\n+\n+    if tcx.has_typeck_tables(def_id) {\n+        replace(tables, tcx.typeck_tables_of(def_id))\n+    } else {\n+        replace(tables, empty_tables)\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     /// We want to visit items in the context of their containing\n     /// module and so forth, so supply a crate for doing a deep walk.\n@@ -505,14 +523,28 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_current_item = replace(&mut self.current_item, item.id);\n+        let orig_tables = update_tables(self.tcx, item.id, &mut self.tables, self.empty_tables);\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n+        self.tables = orig_tables;\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n+        let orig_tables = update_tables(self.tcx, ti.id, &mut self.tables, self.empty_tables);\n+        intravisit::walk_trait_item(self, ti);\n+        self.tables = orig_tables;\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n+        let orig_tables = update_tables(self.tcx, ii.id, &mut self.tables, self.empty_tables);\n+        intravisit::walk_impl_item(self, ii);\n+        self.tables = orig_tables;\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprStruct(ref qpath, ref fields, ref base) => {\n-                let def = self.tables.qpath_def(qpath, expr.id);\n+                let def = self.tables.qpath_def(qpath, expr.hir_id);\n                 let adt = self.tables.expr_ty(expr).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 if let Some(ref base) = *base {\n@@ -539,7 +571,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n     fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         match pat.node {\n             PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tables.qpath_def(qpath, pat.id);\n+                let def = self.tables.qpath_def(qpath, pat.hir_id);\n                 let adt = self.tables.pat_ty(pat).ty_adt_def().unwrap();\n                 let variant = adt.variant_of_def(def);\n                 for field in fields {\n@@ -564,6 +596,7 @@ struct TypePrivacyVisitor<'a, 'tcx: 'a> {\n     tables: &'a ty::TypeckTables<'tcx>,\n     current_item: DefId,\n     span: Span,\n+    empty_tables: &'a ty::TypeckTables<'tcx>,\n }\n \n impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n@@ -607,7 +640,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Take node ID of an expression or pattern and check its type for privacy.\n-    fn check_expr_pat_type(&mut self, id: ast::NodeId, span: Span) -> bool {\n+    fn check_expr_pat_type(&mut self, id: hir::HirId, span: Span) -> bool {\n         self.span = span;\n         if let Some(ty) = self.tables.node_id_to_type_opt(id) {\n             if ty.visit_with(self) {\n@@ -617,7 +650,7 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n         if self.tables.node_substs(id).visit_with(self) {\n             return true;\n         }\n-        if let Some(adjustments) = self.tables.adjustments.get(&id) {\n+        if let Some(adjustments) = self.tables.adjustments().get(id) {\n             for adjustment in adjustments {\n                 if adjustment.target.visit_with(self) {\n                     return true;\n@@ -703,20 +736,20 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     // Check types of expressions\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if self.check_expr_pat_type(expr.id, expr.span) {\n+        if self.check_expr_pat_type(expr.hir_id, expr.span) {\n             // Do not check nested expressions if the error already happened.\n             return;\n         }\n         match expr.node {\n             hir::ExprAssign(.., ref rhs) | hir::ExprMatch(ref rhs, ..) => {\n                 // Do not report duplicate errors for `x = y` and `match x { ... }`.\n-                if self.check_expr_pat_type(rhs.id, rhs.span) {\n+                if self.check_expr_pat_type(rhs.hir_id, rhs.span) {\n                     return;\n                 }\n             }\n             hir::ExprMethodCall(_, span, _) => {\n                 // Method calls have to be checked specially.\n-                let def_id = self.tables.type_dependent_defs[&expr.id].def_id();\n+                let def_id = self.tables.type_dependent_defs()[expr.hir_id].def_id();\n                 self.span = span;\n                 if self.tcx.type_of(def_id).visit_with(self) {\n                     return;\n@@ -732,7 +765,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         // Inherent associated constants don't have self type in substs,\n         // we have to check it additionally.\n         if let hir::QPath::TypeRelative(..) = *qpath {\n-            if let Some(def) = self.tables.type_dependent_defs.get(&id).cloned() {\n+            let hir_id = self.tcx.hir.node_to_hir_id(id);\n+            if let Some(def) = self.tables.type_dependent_defs().get(hir_id).cloned() {\n                 if let Some(assoc_item) = self.tcx.opt_associated_item(def.def_id()) {\n                     if let ty::ImplContainer(impl_def_id) = assoc_item.container {\n                         if self.tcx.type_of(impl_def_id).visit_with(self) {\n@@ -748,7 +782,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     // Check types of patterns\n     fn visit_pat(&mut self, pattern: &'tcx hir::Pat) {\n-        if self.check_expr_pat_type(pattern.id, pattern.span) {\n+        if self.check_expr_pat_type(pattern.hir_id, pattern.span) {\n             // Do not check nested patterns if the error already happened.\n             return;\n         }\n@@ -758,7 +792,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n     fn visit_local(&mut self, local: &'tcx hir::Local) {\n         if let Some(ref init) = local.init {\n-            if self.check_expr_pat_type(init.id, init.span) {\n+            if self.check_expr_pat_type(init.hir_id, init.span) {\n                 // Do not report duplicate errors for `let x = y`.\n                 return;\n             }\n@@ -770,6 +804,10 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     // Check types in item interfaces\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let orig_current_item = self.current_item;\n+        let orig_tables = update_tables(self.tcx,\n+                                        item.id,\n+                                        &mut self.tables,\n+                                        self.empty_tables);\n \n         match item.node {\n             hir::ItemExternCrate(..) | hir::ItemMod(..) |\n@@ -829,8 +867,21 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n \n         self.current_item = self.tcx.hir.local_def_id(item.id);\n         intravisit::walk_item(self, item);\n+        self.tables = orig_tables;\n         self.current_item = orig_current_item;\n     }\n+\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n+        let orig_tables = update_tables(self.tcx, ti.id, &mut self.tables, self.empty_tables);\n+        intravisit::walk_trait_item(self, ti);\n+        self.tables = orig_tables;\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n+        let orig_tables = update_tables(self.tcx, ii.id, &mut self.tables, self.empty_tables);\n+        intravisit::walk_impl_item(self, ii);\n+        self.tables = orig_tables;\n+    }\n }\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n@@ -1605,22 +1656,25 @@ fn privacy_access_levels<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     assert_eq!(krate, LOCAL_CRATE);\n \n     let krate = tcx.hir.krate();\n+    let empty_tables = ty::TypeckTables::empty(None);\n \n     // Check privacy of names not checked in previous compilation stages.\n     let mut visitor = NamePrivacyVisitor {\n         tcx: tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &empty_tables,\n         current_item: CRATE_NODE_ID,\n+        empty_tables: &empty_tables,\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n \n     // Check privacy of explicitly written types and traits as well as\n     // inferred types of expressions and patterns.\n     let mut visitor = TypePrivacyVisitor {\n         tcx: tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &empty_tables,\n         current_item: DefId::local(CRATE_DEF_INDEX),\n         span: krate.span,\n+        empty_tables: &empty_tables,\n     };\n     intravisit::walk_crate(&mut visitor, krate);\n "}, {"sha": "da170e7fe22ca77f6e1520c44ed15735fd5a621a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -1621,7 +1621,7 @@ impl<'a> Resolver<'a> {\n             return Some(module.parent.unwrap());\n         }\n \n-        let mut module_expansion = module.expansion.modern(); // for backward compatability\n+        let mut module_expansion = module.expansion.modern(); // for backward compatibility\n         while let Some(parent) = module.parent {\n             let parent_expansion = parent.expansion.modern();\n             if module_expansion.is_descendant_of(parent_expansion) &&"}, {"sha": "7572c4aa6802a423ce3d1b3eee1a2d54fed8b0a0", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -313,7 +313,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n     fn check_unused_macros(&self) {\n         for did in self.unused_macros.iter() {\n             let id_span = match *self.macro_map[did] {\n-                SyntaxExtension::NormalTT(_, isp, _) => isp,\n+                SyntaxExtension::NormalTT { def_info, .. } => def_info,\n                 SyntaxExtension::DeclMacro(.., osp) => osp,\n                 _ => None,\n             };"}, {"sha": "658b6dbc4e3535b0334b779ff64e07c566accf65", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 26, "deletions": 49, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -27,7 +27,6 @@\n use rustc::hir::def::Def as HirDef;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::Node;\n-use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n \n@@ -62,7 +61,6 @@ macro_rules! down_cast_data {\n \n pub struct DumpVisitor<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> {\n     save_ctxt: SaveContext<'l, 'tcx>,\n-    sess: &'l Session,\n     tcx: TyCtxt<'l, 'tcx, 'tcx>,\n     dumper: &'ll mut JsonDumper<O>,\n \n@@ -84,7 +82,6 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                -> DumpVisitor<'l, 'tcx, 'll, O> {\n         let span_utils = SpanUtils::new(&save_ctxt.tcx.sess);\n         DumpVisitor {\n-            sess: &save_ctxt.tcx.sess,\n             tcx: save_ctxt.tcx,\n             save_ctxt: save_ctxt,\n             dumper: dumper,\n@@ -147,47 +144,23 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n     // For each prefix, we return the span for the last segment in the prefix and\n     // a str representation of the entire prefix.\n     fn process_path_prefixes(&self, path: &ast::Path) -> Vec<(Span, String)> {\n-        let spans = self.span.spans_for_path_segments(path);\n         let segments = &path.segments[if path.is_global() { 1 } else { 0 }..];\n \n-        // Paths to enums seem to not match their spans - the span includes all the\n-        // variants too. But they seem to always be at the end, so I hope we can cope with\n-        // always using the first ones. So, only error out if we don't have enough spans.\n-        // What could go wrong...?\n-        if spans.len() < segments.len() {\n-            if generated_code(path.span) {\n-                return vec![];\n-            }\n-            error!(\"Mis-calculated spans for path '{}'. Found {} spans, expected {}. Found spans:\",\n-                   path_to_string(path),\n-                   spans.len(),\n-                   segments.len());\n-            for s in &spans {\n-                let loc = self.sess.codemap().lookup_char_pos(s.lo);\n-                error!(\"    '{}' in {}, line {}\",\n-                       self.span.snippet(*s),\n-                       loc.file.name,\n-                       loc.line);\n-            }\n-            error!(\"    master span: {:?}: `{}`\", path.span, self.span.snippet(path.span));\n-            return vec![];\n-        }\n-\n-        let mut result: Vec<(Span, String)> = vec![];\n+        let mut result = Vec::with_capacity(segments.len());\n \n         let mut segs = vec![];\n-        for (i, (seg, span)) in segments.iter().zip(&spans).enumerate() {\n+        for (i, seg) in segments.iter().enumerate() {\n             segs.push(seg.clone());\n             let sub_path = ast::Path {\n-                span: *span, // span for the last segment\n+                span: seg.span, // span for the last segment\n                 segments: segs,\n             };\n             let qualname = if i == 0 && path.is_global() {\n                 format!(\"::{}\", path_to_string(&sub_path))\n             } else {\n                 path_to_string(&sub_path)\n             };\n-            result.push((*span, qualname));\n+            result.push((seg.span, qualname));\n             segs = sub_path.segments;\n         }\n \n@@ -345,7 +318,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             collector.visit_pat(&arg.pat);\n             let span_utils = self.span.clone();\n             for &(id, ref p, ..) in &collector.collected_paths {\n-                let typ = match self.save_ctxt.tables.node_types.get(&id) {\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                let typ = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                     Some(s) => s.to_string(),\n                     None => continue,\n                 };\n@@ -436,13 +410,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                               full_span: Span,\n                               prefix: &str,\n                               id: NodeId) {\n-        // We can't only use visit_generics since we don't have spans for param\n-        // bindings, so we reparse the full_span to get those sub spans.\n-        // However full span is the entire enum/fn/struct block, so we only want\n-        // the first few to match the number of generics we're looking for.\n-        let param_sub_spans = self.span.spans_for_ty_params(full_span,\n-                                                            (generics.ty_params.len() as isize));\n-        for (param, param_ss) in generics.ty_params.iter().zip(param_sub_spans) {\n+        for param in &generics.ty_params {\n+            let param_ss = param.span;\n             let name = escape(self.span.snippet(param_ss));\n             // Append $id to name to make sure each one is unique\n             let qualname = format!(\"{}::{}${}\",\n@@ -499,12 +468,14 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                                     item: &'l ast::Item,\n                                     typ: &'l ast::Ty,\n                                     expr: &'l ast::Expr) {\n-        if let Some(var_data) = self.save_ctxt.get_item_data(item) {\n-            down_cast_data!(var_data, DefData, item.span);\n-            self.dumper.dump_def(item.vis == ast::Visibility::Public, var_data);\n-        }\n-        self.visit_ty(&typ);\n-        self.visit_expr(expr);\n+        self.nest_tables(item.id, |v| {\n+            if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n+                down_cast_data!(var_data, DefData, item.span);\n+                v.dumper.dump_def(item.vis == ast::Visibility::Public, var_data);\n+            }\n+            v.visit_ty(&typ);\n+            v.visit_expr(expr);\n+        });\n     }\n \n     fn process_assoc_const(&mut self,\n@@ -893,7 +864,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         match p.node {\n             PatKind::Struct(ref _path, ref fields, _) => {\n                 // FIXME do something with _path?\n-                let adt = match self.save_ctxt.tables.node_id_to_type_opt(p.id) {\n+                let hir_id = self.tcx.hir.node_to_hir_id(p.id);\n+                let adt = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                     Some(ty) => ty.ty_adt_def().unwrap(),\n                     None => {\n                         visit::walk_pat(self, p);\n@@ -935,7 +907,8 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 ast::Mutability::Immutable => value.to_string(),\n                 _ => String::new(),\n             };\n-            let typ = match self.save_ctxt.tables.node_types.get(&id) {\n+            let hir_id = self.tcx.hir.node_to_hir_id(id);\n+            let typ = match self.save_ctxt.tables.node_id_to_type_opt(hir_id) {\n                 Some(typ) => {\n                     let typ = typ.to_string();\n                     if !value.is_empty() {\n@@ -1466,8 +1439,12 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                     } else {\n                         \"<mutable>\".to_string()\n                     };\n-                    let typ = self.save_ctxt.tables.node_types\n-                                  .get(&id).map(|t| t.to_string()).unwrap_or(String::new());\n+                    let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                    let typ = self.save_ctxt\n+                                  .tables\n+                                  .node_id_to_type_opt(hir_id)\n+                                  .map(|t| t.to_string())\n+                                  .unwrap_or(String::new());\n                     value.push_str(\": \");\n                     value.push_str(&typ);\n "}, {"sha": "8dd191f4375ed1b81c0ac4883c5c6562dd044cee", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -109,7 +109,7 @@ impl<'b, O: DumpOutput + 'b> JsonDumper<O> {\n         }\n         if data.kind == DefKind::Mod && data.span.file_name.to_str().unwrap() != data.value {\n             // If the module is an out-of-line defintion, then we'll make the\n-            // defintion the first character in the module's file and turn the\n+            // definition the first character in the module's file and turn the\n             // the declaration into a reference to it.\n             let rf = Ref {\n                 kind: RefKind::Mod,"}, {"sha": "c3d071d27d6ef76a7218968239b0002c793200c2", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -550,7 +550,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             }\n             ast::ExprKind::MethodCall(..) => {\n-                let method_id = self.tables.type_dependent_defs[&expr.id].def_id();\n+                let expr_hir_id = self.tcx.hir.definitions().node_to_hir_id(expr.id);\n+                let method_id = self.tables.type_dependent_defs()[expr_hir_id].def_id();\n                 let (def_id, decl_id) = match self.tcx.associated_item(method_id).container {\n                     ty::ImplContainer(_) => (Some(method_id), None),\n                     ty::TraitContainer(_) => (None, Some(method_id)),\n@@ -586,7 +587,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             Node::NodePat(&hir::Pat { node: hir::PatKind::Path(ref qpath), .. }) |\n             Node::NodePat(&hir::Pat { node: hir::PatKind::Struct(ref qpath, ..), .. }) |\n             Node::NodePat(&hir::Pat { node: hir::PatKind::TupleStruct(ref qpath, ..), .. }) => {\n-                self.tables.qpath_def(qpath, id)\n+                let hir_id = self.tcx.hir.node_to_hir_id(id);\n+                self.tables.qpath_def(qpath, hir_id)\n             }\n \n             Node::NodeLocal(&hir::Pat { node: hir::PatKind::Binding(_, def_id, ..), .. }) => {\n@@ -975,7 +977,7 @@ pub fn process_crate<'l, 'tcx, H: SaveHandler>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n \n     let save_ctxt = SaveContext {\n         tcx: tcx,\n-        tables: &ty::TypeckTables::empty(),\n+        tables: &ty::TypeckTables::empty(None),\n         analysis: analysis,\n         span_utils: SpanUtils::new(&tcx.sess),\n         config: find_config(config),"}, {"sha": "6ef499694aa4f964e90649832010841df59aab2d", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -387,7 +387,7 @@ impl Sig for ast::Item {\n \n                 sig.text.push('(');\n                 for i in &decl.inputs {\n-                    // FIXME shoudl descend into patterns to add defs.\n+                    // FIXME should descend into patterns to add defs.\n                     sig.text.push_str(&pprust::pat_to_string(&i.pat));\n                     sig.text.push_str(\": \");\n                     let nested = i.ty.make(offset + sig.text.len(), Some(i.id), scx)?;\n@@ -922,7 +922,7 @@ fn make_method_signature(id: NodeId,\n \n     sig.text.push('(');\n     for i in &m.decl.inputs {\n-        // FIXME shoudl descend into patterns to add defs.\n+        // FIXME should descend into patterns to add defs.\n         sig.text.push_str(&pprust::pat_to_string(&i.pat));\n         sig.text.push_str(\": \");\n         let nested = i.ty.make(sig.text.len(), Some(i.id), scx)?;"}, {"sha": "631907b28f8b8d0a40736b5d1e6f8386aeeaac71", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 0, "deletions": 85, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -16,7 +16,6 @@ use std::cell::Cell;\n use std::env;\n use std::path::Path;\n \n-use syntax::ast;\n use syntax::parse::lexer::{self, StringReader};\n use syntax::parse::token::{self, Token};\n use syntax::symbol::keywords;\n@@ -207,75 +206,6 @@ impl<'a> SpanUtils<'a> {\n         result\n     }\n \n-    // Reparse span and return an owned vector of sub spans of the first limit\n-    // identifier tokens in the given nesting level.\n-    // example with Foo<Bar<T,V>, Bar<T,V>>\n-    // Nesting = 0: all idents outside of angle brackets: [Foo]\n-    // Nesting = 1: idents within one level of angle brackets: [Bar, Bar]\n-    pub fn spans_with_brackets(&self, span: Span, nesting: isize, limit: isize) -> Vec<Span> {\n-        let mut result: Vec<Span> = vec![];\n-\n-        let mut toks = self.retokenise_span(span);\n-        // We keep track of how many brackets we're nested in\n-        let mut angle_count: isize = 0;\n-        let mut bracket_count: isize = 0;\n-        let mut found_ufcs_sep = false;\n-        loop {\n-            let ts = toks.real_token();\n-            if ts.tok == token::Eof {\n-                if angle_count != 0 || bracket_count != 0 {\n-                    if generated_code(span) {\n-                        return vec![];\n-                    }\n-                    let loc = self.sess.codemap().lookup_char_pos(span.lo);\n-                    span_bug!(span,\n-                              \"Mis-counted brackets when breaking path? \\\n-                               Parsing '{}' in {}, line {}\",\n-                              self.snippet(span),\n-                              loc.file.name,\n-                              loc.line);\n-                }\n-                return result\n-            }\n-            if (result.len() as isize) == limit {\n-                return result;\n-            }\n-            bracket_count += match ts.tok {\n-                token::OpenDelim(token::Bracket) => 1,\n-                token::CloseDelim(token::Bracket) => -1,\n-                _ => 0,\n-            };\n-            if bracket_count > 0 {\n-                continue;\n-            }\n-            angle_count += match ts.tok {\n-                token::Lt => 1,\n-                token::Gt => -1,\n-                token::BinOp(token::Shl) => 2,\n-                token::BinOp(token::Shr) => -2,\n-                _ => 0,\n-            };\n-\n-            // Ignore the `>::` in `<Type as Trait>::AssocTy`.\n-\n-            // The root cause of this hack is that the AST representation of\n-            // qpaths is horrible. It treats <A as B>::C as a path with two\n-            // segments, B and C and notes that there is also a self type A at\n-            // position 0. Because we don't have spans for individual idents,\n-            // only the whole path, we have to iterate over the tokens in the\n-            // path, trying to pull out the non-nested idents (e.g., avoiding 'a\n-            // in `<A as B<'a>>::C`). So we end up with a span for `B>::C` from\n-            // the start of the first ident to the end of the path.\n-            if !found_ufcs_sep && angle_count == -1 {\n-                found_ufcs_sep = true;\n-                angle_count += 1;\n-            }\n-            if ts.tok.is_ident() && angle_count == nesting {\n-                result.push(ts.sp);\n-            }\n-        }\n-    }\n-\n     pub fn sub_span_before_token(&self, span: Span, tok: Token) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         let mut prev = toks.real_token();\n@@ -330,21 +260,6 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-\n-    // Returns a list of the spans of idents in a path.\n-    // E.g., For foo::bar<x,t>::baz, we return [foo, bar, baz] (well, their spans)\n-    pub fn spans_for_path_segments(&self, path: &ast::Path) -> Vec<Span> {\n-        self.spans_with_brackets(path.span, 0, -1)\n-    }\n-\n-    // Return an owned vector of the subspans of the param identifier\n-    // tokens found in span.\n-    pub fn spans_for_ty_params(&self, span: Span, number: isize) -> Vec<Span> {\n-        // Type params are nested within one level of brackets:\n-        // i.e. we want Vec<A, B> from Foo<A, B<T,U>>\n-        self.spans_with_brackets(span, 1, number)\n-    }\n-\n     // // Return the name for a macro definition (identifier after first `!`)\n     // pub fn span_for_macro_def_name(&self, span: Span) -> Option<Span> {\n     //     let mut toks = self.retokenise_span(span);"}, {"sha": "b4a2891f94c2af91ea278df98f9d82940afdfc72", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -191,7 +191,7 @@ pub fn compare_simd_types<'a, 'tcx>(\n /// adjustment.\n ///\n /// The `old_info` argument is a bit funny. It is intended for use\n-/// in an upcast, where the new vtable for an object will be drived\n+/// in an upcast, where the new vtable for an object will be derived\n /// from the old one.\n pub fn unsized_info<'ccx, 'tcx>(ccx: &CrateContext<'ccx, 'tcx>,\n                                 source: Ty<'tcx>,\n@@ -488,7 +488,7 @@ impl Lifetime {\n     // on), and `ptr` is nonzero-sized, then extracts the size of `ptr`\n     // and the intrinsic for `lt` and passes them to `emit`, which is in\n     // charge of generating code to call the passed intrinsic on whatever\n-    // block of generated code is targetted for the intrinsic.\n+    // block of generated code is targeted for the intrinsic.\n     //\n     // If LLVM lifetime intrinsic support is disabled (i.e.  optimizations\n     // off) or `ptr` is zero-sized, then no-op (does not call `emit`)."}, {"sha": "5dd1c15fd2d6ed88aec2783fd009fcdc512d207f", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -36,7 +36,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                           t: Ty<'tcx>,\n                                           qualified: bool,\n                                           output: &mut String) {\n-    // When targeting MSVC, emit C++ style type names for compatability with\n+    // When targeting MSVC, emit C++ style type names for compatibility with\n     // .natvis visualizers (and perhaps other existing native debuggers?)\n     let cpp_like_names = cx.sess().target.target.options.is_like_msvc;\n "}, {"sha": "033ef988571dd263a5ad4c82161a3a522b89b2a3", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -246,7 +246,11 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 let val = if fn_ty.args[1].is_indirect() {\n                     bcx.load(llargs[1], None)\n                 } else {\n-                    from_immediate(bcx, llargs[1])\n+                    if !type_is_zero_size(ccx, tp_ty) {\n+                        from_immediate(bcx, llargs[1])\n+                    } else {\n+                        C_nil(ccx)\n+                    }\n                 };\n                 let ptr = bcx.pointercast(llargs[0], val_ty(val).ptr_to());\n                 let store = bcx.volatile_store(val, ptr);"}, {"sha": "3899295da40b80f3c5287f4fc167bfe3e8355687", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             (scope, source_info.span)\n         } else {\n             // Walk up the macro expansion chain until we reach a non-expanded span.\n-            // We also stop at the function body level because no line stepping can occurr\n+            // We also stop at the function body level because no line stepping can occur\n             // at the level above that.\n             let mut span = source_info.span;\n             while span.ctxt != NO_EXPANSION && span.ctxt != self.mir.span.ctxt {"}, {"sha": "264158f0de9eeedf986e8e99d388de473f587d06", "filename": "src/librustc_trans_utils/link.rs", "status": "modified", "additions": 4, "deletions": 27, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_trans_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_trans_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flink.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -8,34 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rustc::session::config::{self, /*NoDebugInfo,*/ OutputFilenames, Input, OutputType};\n-/*use rustc::session::filesearch;\n-use rustc::session::search_paths::PathKind;\n-*/use rustc::session::Session;\n-use rustc::middle::cstore;/*::{self, LinkMeta, NativeLibrary, LibSource, LinkagePreference,\n-                            NativeLibraryKind};*/\n-/*use rustc::middle::dependency_format::Linkage;\n-use rustc::util::common::time;\n-use rustc::util::fs::fix_windows_verbatim_for_gcc;\n-use rustc::dep_graph::{DepKind, DepNode};\n-use rustc::hir::def_id::CrateNum;\n-use rustc::hir::svh::Svh;\n-use rustc_back::tempdir::TempDir;\n-use rustc_back::{PanicStrategy, RelroLevel};\n-use rustc_incremental::IncrementalHashesMap;*/\n-\n-/*use std::ascii;\n-use std::char;\n-use std::env;\n-use std::ffi::OsString;\n-use std::fs;\n-use std::io::{self, Read, Write};\n-use std::mem;\n-*/use std::path::PathBuf;/*{Path, PathBuf};\n-use std::process::Command;\n-use std::str;*/\n+use rustc::session::config::{self, OutputFilenames, Input, OutputType};\n+use rustc::session::Session;\n+use rustc::middle::cstore;\n+use std::path::PathBuf;\n use syntax::ast;\n-//use syntax::attr;\n use syntax_pos::Span;\n \n pub fn find_crate_name(sess: Option<&Session>,"}, {"sha": "b49b9377e8c56095370a006a19ba8cd5c4016fe1", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -118,8 +118,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // identical to what could be scraped from the HIR, but this will change with\n                 // default binding modes (#42640).\n                 let bm = ty::BindingMode::convert(ba);\n-                self.inh.tables.borrow_mut().pat_binding_modes.insert(pat.id, bm);\n-\n+                self.inh\n+                    .tables\n+                    .borrow_mut()\n+                    .pat_binding_modes_mut()\n+                    .insert(pat.hir_id, bm);\n                 let typ = self.local_ty(pat.span, pat.id);\n                 match bm {\n                     ty::BindByReference(mutbl) => {\n@@ -323,7 +326,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        self.write_ty(pat.id, ty);\n+        self.write_ty(pat.hir_id, ty);\n \n         // (*) In most of the cases above (literals and constants being\n         // the exception), we relate types using strict equality, evewn"}, {"sha": "460e2858b22ec091ea4272467e4bdc2cef4c1235", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -222,7 +222,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 if let hir::ExprCall(ref expr, _) = call_expr.node {\n                     let def = if let hir::ExprPath(ref qpath) = expr.node {\n-                        self.tables.borrow().qpath_def(qpath, expr.id)\n+                        self.tables.borrow().qpath_def(qpath, expr.hir_id)\n                     } else {\n                         Def::Err\n                     };\n@@ -314,7 +314,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                            TupleArgumentsFlag::TupleArguments,\n                                                            expected);\n \n-        self.write_method_call(call_expr.id, method_callee);\n+        self.write_method_call(call_expr.hir_id, method_callee);\n         output_type\n     }\n }\n@@ -364,7 +364,8 @@ impl<'a, 'gcx, 'tcx> DeferredCallResolution<'gcx, 'tcx> {\n                 adjustments.extend(autoref);\n                 fcx.apply_adjustments(self.callee_expr, adjustments);\n \n-                fcx.write_method_call(self.call_expr.id, method_callee);\n+                fcx.write_method_call(self.call_expr.hir_id,\n+                                      method_callee);\n             }\n             None => {\n                 span_bug!(self.call_expr.span,"}, {"sha": "b18b11f3d906992c2f4bfb09dc5c775672fd893b", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -330,12 +330,13 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         } else if self.try_coercion_cast(fcx) {\n             self.trivial_cast_lint(fcx);\n             debug!(\" -> CoercionCast\");\n-            fcx.tables.borrow_mut().cast_kinds.insert(self.expr.id, CastKind::CoercionCast);\n+            fcx.tables.borrow_mut().cast_kinds_mut().insert(self.expr.hir_id,\n+                                                            CastKind::CoercionCast);\n         } else {\n             match self.do_check(fcx) {\n                 Ok(k) => {\n                     debug!(\" -> {:?}\", k);\n-                    fcx.tables.borrow_mut().cast_kinds.insert(self.expr.id, k);\n+                    fcx.tables.borrow_mut().cast_kinds_mut().insert(self.expr.hir_id, k);\n                 }\n                 Err(e) => self.report_cast_error(fcx, e),\n             };"}, {"sha": "8f8dc71899fccf0db41cadc7377e82aab1a5bd7e", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -111,12 +111,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                sig,\n                opt_kind);\n \n-        self.tables.borrow_mut().closure_tys.insert(expr.id, sig);\n-        match opt_kind {\n-            Some(kind) => {\n-                self.tables.borrow_mut().closure_kinds.insert(expr.id, (kind, None));\n+        {\n+            let mut tables = self.tables.borrow_mut();\n+            tables.closure_tys_mut().insert(expr.hir_id, sig);\n+            match opt_kind {\n+                Some(kind) => {\n+                    tables.closure_kinds_mut().insert(expr.hir_id, (kind, None));\n+                }\n+                None => {}\n             }\n-            None => {}\n         }\n \n         closure_type"}, {"sha": "53f3d811fae4fb9d3ebba7d8f441197c40ca7e8e", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -844,7 +844,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // First try to coerce the new expression to the type of the previous ones,\n         // but only if the new expression has no coercion already applied to it.\n         let mut first_error = None;\n-        if !self.tables.borrow().adjustments.contains_key(&new.id) {\n+        if !self.tables.borrow().adjustments().contains_key(new.hir_id) {\n             let result = self.commit_if_ok(|_| coerce.coerce(new_ty, prev_ty));\n             match result {\n                 Ok(ok) => {\n@@ -866,7 +866,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     Adjustment { kind: Adjust::Deref(_), .. },\n                     Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(_, mutbl_adj)), .. }\n                 ] => {\n-                    match self.node_ty(expr.id).sty {\n+                    match self.node_ty(expr.hir_id).sty {\n                         ty::TyRef(_, mt_orig) => {\n                             // Reborrow that we can safely ignore, because\n                             // the next adjustment can only be a Deref"}, {"sha": "fc241c023cdaf25f6e3c8f3fe4e51db2e357ee38", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -67,7 +67,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Ok(InferOk { obligations, value: () }) => {\n                 self.register_predicates(obligations);\n                 None\n-            },\n+            }\n             Err(e) => {\n                 Some(self.report_mismatched_types(cause, expected, actual, e))\n             }\n@@ -82,7 +82,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     // Checks that the type of `expr` can be coerced to `expected`.\n     //\n-    // NB: This code relies on `self.diverges` to be accurate.  In\n+    // NB: This code relies on `self.diverges` to be accurate. In\n     // particular, assignments to `!` will be permitted if the\n     // diverges flag is currently \"always\".\n     pub fn demand_coerce_diag(&self,"}, {"sha": "72ff9eb6f5b0d48ee3bdbc2abda3a9ad7057702f", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -22,7 +22,7 @@ use util::nodemap::FxHashSet;\n \n use syntax_pos::Span;\n \n-/// check_drop_impl confirms that the Drop implementation identfied by\n+/// check_drop_impl confirms that the Drop implementation identified by\n /// `drop_impl_did` is not any more specialized than the type it is\n /// attached to (Issue #8142).\n ///"}, {"sha": "355e6cdbbe074b2093cc3d4012bc0bee7b1938eb", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -445,11 +445,14 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             // Fix up the autoderefs. Autorefs can only occur immediately preceding\n             // overloaded lvalue ops, and will be fixed by them in order to get\n             // the correct region.\n-            let mut source = self.node_ty(expr.id);\n+            let mut source = self.node_ty(expr.hir_id);\n             // Do not mutate adjustments in place, but rather take them,\n             // and replace them after mutating them, to avoid having the\n             // tables borrowed during (`deref_mut`) method resolution.\n-            let previous_adjustments = self.tables.borrow_mut().adjustments.remove(&expr.id);\n+            let previous_adjustments = self.tables\n+                                           .borrow_mut()\n+                                           .adjustments_mut()\n+                                           .remove(expr.hir_id);\n             if let Some(mut adjustments) = previous_adjustments {\n                 let pref = LvaluePreference::PreferMutLvalue;\n                 for adjustment in &mut adjustments {\n@@ -466,12 +469,12 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                     }\n                     source = adjustment.target;\n                 }\n-                self.tables.borrow_mut().adjustments.insert(expr.id, adjustments);\n+                self.tables.borrow_mut().adjustments_mut().insert(expr.hir_id, adjustments);\n             }\n \n             match expr.node {\n                 hir::ExprIndex(ref base_expr, ref index_expr) => {\n-                    let index_expr_ty = self.node_ty(index_expr.id);\n+                    let index_expr_ty = self.node_ty(index_expr.hir_id);\n                     self.convert_lvalue_op_to_mutable(\n                         LvalueOp::Index, expr, base_expr, &[index_expr_ty]);\n                 }\n@@ -498,7 +501,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         }\n \n         let base_ty = self.tables.borrow().expr_adjustments(base_expr).last()\n-            .map_or_else(|| self.node_ty(expr.id), |adj| adj.target);\n+            .map_or_else(|| self.node_ty(expr.hir_id), |adj| adj.target);\n         let base_ty = self.resolve_type_vars_if_possible(&base_ty);\n \n         // Need to deref because overloaded lvalue ops take self by-reference.\n@@ -513,7 +516,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\")\n         };\n         debug!(\"convert_lvalue_op_to_mutable: method={:?}\", method);\n-        self.write_method_call(expr.id, method);\n+        self.write_method_call(expr.hir_id, method);\n \n         let (region, mutbl) = if let ty::TyRef(r, mt) = method.sig.inputs()[0].sty {\n             (r, mt.mutbl)\n@@ -523,8 +526,11 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         // Convert the autoref in the base expr to mutable with the correct\n         // region and mutability.\n-        let base_expr_ty = self.node_ty(base_expr.id);\n-        if let Some(adjustments) = self.tables.borrow_mut().adjustments.get_mut(&base_expr.id) {\n+        let base_expr_ty = self.node_ty(base_expr.hir_id);\n+        if let Some(adjustments) = self.tables\n+                                       .borrow_mut()\n+                                       .adjustments_mut()\n+                                       .get_mut(base_expr.hir_id) {\n             let mut source = base_expr_ty;\n             for adjustment in &mut adjustments[..] {\n                 if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {"}, {"sha": "a1c987f22e053d07fccdd4d9c7a9dc019ab8e9a5", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -219,7 +219,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// `lookup_method_in_trait` is used for overloaded operators.\n     /// It does a very narrow slice of what the normal probe/confirm path does.\n     /// In particular, it doesn't really do any probing: it simply constructs\n-    /// an obligation for aparticular trait with the given self-type and checks\n+    /// an obligation for a particular trait with the given self-type and checks\n     /// whether that trait is implemented.\n     ///\n     /// FIXME(#18741) -- It seems likely that we can consolidate some of this"}, {"sha": "a55f4878ac6e2b3b1373fdd1757049772a5e0f5b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -822,19 +822,20 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             let closure_id = match step.self_ty.sty {\n                 ty::TyClosure(def_id, _) => {\n                     if let Some(id) = self.tcx.hir.as_local_node_id(def_id) {\n-                        id\n+                        self.tcx.hir.node_to_hir_id(id)\n                     } else {\n                         continue;\n                     }\n                 }\n                 _ => continue,\n             };\n \n-            let closure_kinds = &self.tables.borrow().closure_kinds;\n-            let closure_kind = match closure_kinds.get(&closure_id) {\n-                Some(&(k, _)) => k,\n-                None => {\n-                    return Err(MethodError::ClosureAmbiguity(trait_def_id));\n+            let closure_kind = {\n+                match self.tables.borrow().closure_kinds().get(closure_id) {\n+                    Some(&(k, _)) => k,\n+                    None => {\n+                        return Err(MethodError::ClosureAmbiguity(trait_def_id));\n+                    }\n                 }\n             };\n "}, {"sha": "ff96f3db7ebb4ad9a0e0a1e8bafb1c026843c3c8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 74, "deletions": 45, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -534,7 +534,7 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ///   `foo(return)`; we warn on the `foo()` expression. (We then\n     ///   update the flag to `WarnedAlways` to suppress duplicate\n     ///   reports.) Similarly, if we traverse to a fresh statement (or\n-    ///   tail expression) from a `Always` setting, we will isssue a\n+    ///   tail expression) from a `Always` setting, we will issue a\n     ///   warning. This corresponds to something like `{return;\n     ///   foo();}` or `{return; 22}`, where we would warn on the\n     ///   `foo()` or `22`.\n@@ -543,7 +543,7 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ///   (including the \"return slot\") of type `!`.  This is allowed\n     ///   if **either** the type of value being assigned is `!`, which\n     ///   means the current code is dead, **or** the expression's\n-    ///   divering flag is true, which means that a divering value was\n+    ///   diverging flag is true, which means that a diverging value was\n     ///   wrapped (e.g., `let x: ! = foo(return)`).\n     ///\n     /// To repeat the last point: an expression represents dead-code\n@@ -577,8 +577,16 @@ pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n     pub fn build(tcx: TyCtxt<'a, 'gcx, 'gcx>, def_id: DefId)\n                  -> InheritedBuilder<'a, 'gcx, 'tcx> {\n+        let hir_id_root = if def_id.is_local() {\n+            let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n+            let hir_id = tcx.hir.definitions().node_to_hir_id(node_id);\n+            DefId::local(hir_id.owner)\n+        } else {\n+            def_id\n+        };\n+\n         InheritedBuilder {\n-            infcx: tcx.infer_ctxt().with_fresh_in_progress_tables(),\n+            infcx: tcx.infer_ctxt().with_fresh_in_progress_tables(hir_id_root),\n             def_id,\n         }\n     }\n@@ -749,7 +757,8 @@ fn closure_kind<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           def_id: DefId)\n                           -> ty::ClosureKind {\n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-    tcx.typeck_tables_of(def_id).closure_kinds[&node_id].0\n+    let hir_id = tcx.hir.node_to_hir_id(node_id);\n+    tcx.typeck_tables_of(def_id).closure_kinds()[hir_id].0\n }\n \n fn adt_destructor<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -854,7 +863,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     });\n     let body = tcx.hir.body(body_id);\n \n-    Inherited::build(tcx, def_id).enter(|inh| {\n+    let tables = Inherited::build(tcx, def_id).enter(|inh| {\n         let param_env = tcx.param_env(def_id);\n         let fcx = if let Some(decl) = fn_decl {\n             let fn_sig = tcx.fn_sig(def_id);\n@@ -902,7 +911,13 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         fcx.resolve_type_vars_in_body(body)\n-    })\n+    });\n+\n+    // Consistency check our TypeckTables instance can hold all ItemLocalIds\n+    // it will need to hold.\n+    assert_eq!(tables.local_id_root,\n+               Some(DefId::local(tcx.hir.definitions().node_to_hir_id(id).owner)));\n+    tables\n }\n \n fn check_abi<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span, abi: Abi) {\n@@ -1032,28 +1047,28 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n             fcx.require_type_is_sized(arg_ty, decl.output.span(), traits::MiscObligation);\n         }\n \n-        fcx.write_ty(arg.id, arg_ty);\n+        fcx.write_ty(arg.hir_id, arg_ty);\n     }\n \n     let gen_ty = if can_be_generator && body.is_generator {\n         let gen_sig = ty::GenSig {\n             yield_ty: fcx.yield_ty.unwrap(),\n             return_ty: ret_ty,\n         };\n-        inherited.tables.borrow_mut().generator_sigs.insert(fn_id, Some(gen_sig));\n+        inherited.tables.borrow_mut().generator_sigs.insert(fn_hir_id, Some(gen_sig));\n \n         let witness = fcx.next_ty_var(TypeVariableOrigin::MiscVariable(span));\n         fcx.deferred_generator_interiors.borrow_mut().push((body.id(), witness));\n         let interior = ty::GeneratorInterior::new(witness);\n \n-        inherited.tables.borrow_mut().generator_interiors.insert(fn_id, interior);\n+        inherited.tables.borrow_mut().generator_interiors.insert(fn_hir_id, interior);\n \n         Some(interior)\n     } else {\n-        inherited.tables.borrow_mut().generator_sigs.insert(fn_id, None);\n+        inherited.tables.borrow_mut().generator_sigs.insert(fn_hir_id, None);\n         None\n     };\n-    inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig);\n+    inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_hir_id, fn_sig);\n \n     fcx.check_return_expr(&body.value);\n \n@@ -1834,30 +1849,37 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n-        debug!(\"write_ty({}, {:?}) in fcx {}\",\n-               node_id, self.resolve_type_vars_if_possible(&ty), self.tag());\n-        self.tables.borrow_mut().node_types.insert(node_id, ty);\n+    pub fn write_ty(&self, id: hir::HirId, ty: Ty<'tcx>) {\n+        debug!(\"write_ty({:?}, {:?}) in fcx {}\",\n+               id, self.resolve_type_vars_if_possible(&ty), self.tag());\n+        self.tables.borrow_mut().node_types_mut().insert(id, ty);\n \n         if ty.references_error() {\n             self.has_errors.set(true);\n             self.set_tainted_by_errors();\n         }\n     }\n \n-    pub fn write_method_call(&self, node_id: ast::NodeId, method: MethodCallee<'tcx>) {\n-        self.tables.borrow_mut().type_dependent_defs.insert(node_id, Def::Method(method.def_id));\n-        self.write_substs(node_id, method.substs);\n+    // The NodeId and the ItemLocalId must identify the same item. We just pass\n+    // both of them for consistency checking.\n+    pub fn write_method_call(&self,\n+                             hir_id: hir::HirId,\n+                             method: MethodCallee<'tcx>) {\n+        self.tables\n+            .borrow_mut()\n+            .type_dependent_defs_mut()\n+            .insert(hir_id, Def::Method(method.def_id));\n+        self.write_substs(hir_id, method.substs);\n     }\n \n-    pub fn write_substs(&self, node_id: ast::NodeId, substs: &'tcx Substs<'tcx>) {\n+    pub fn write_substs(&self, node_id: hir::HirId, substs: &'tcx Substs<'tcx>) {\n         if !substs.is_noop() {\n-            debug!(\"write_substs({}, {:?}) in fcx {}\",\n+            debug!(\"write_substs({:?}, {:?}) in fcx {}\",\n                    node_id,\n                    substs,\n                    self.tag());\n \n-            self.tables.borrow_mut().node_substs.insert(node_id, substs);\n+            self.tables.borrow_mut().node_substs_mut().insert(node_id, substs);\n         }\n     }\n \n@@ -1868,7 +1890,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return;\n         }\n \n-        match self.tables.borrow_mut().adjustments.entry(expr.id) {\n+        match self.tables.borrow_mut().adjustments_mut().entry(expr.hir_id) {\n             Entry::Vacant(entry) => { entry.insert(adj); },\n             Entry::Occupied(mut entry) => {\n                 debug!(\" - composing on top of {:?}\", entry.get());\n@@ -1936,7 +1958,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         value.fold_with(&mut BottomUpFolder { tcx: self.tcx, fldop: |ty| {\n             if let ty::TyAnon(def_id, substs) = ty.sty {\n                 // Use the same type variable if the exact same TyAnon appears more\n-                // than once in the return type (e.g. if it's pased to a type alias).\n+                // than once in the return type (e.g. if it's passed to a type alias).\n                 let id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                 if let Some(ty_var) = self.anon_types.borrow().get(&id) {\n                     return ty_var;\n@@ -2021,13 +2043,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         t\n     }\n \n-    pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        match self.tables.borrow().node_types.get(&id) {\n+    pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {\n+        match self.tables.borrow().node_types().get(id) {\n             Some(&t) => t,\n             None if self.err_count_since_creation() != 0 => self.tcx.types.err,\n             None => {\n+                let node_id = self.tcx.hir.definitions().find_node_for_hir_id(id);\n                 bug!(\"no type for node {}: {} in fcx {}\",\n-                     id, self.tcx.hir.node_to_string(id),\n+                     node_id, self.tcx.hir.node_to_string(node_id),\n                      self.tag());\n             }\n         }\n@@ -2302,7 +2325,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 self.apply_adjustments(base_expr, adjustments);\n \n-                self.write_method_call(expr.id, method);\n+                self.write_method_call(expr.hir_id, method);\n                 (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n             });\n             if result.is_some() {\n@@ -2691,7 +2714,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // While we don't allow *arbitrary* coercions here, we *do* allow\n         // coercions from ! to `expected`.\n         if ty.is_never() {\n-            assert!(!self.tables.borrow().adjustments.contains_key(&expr.id),\n+            assert!(!self.tables.borrow().adjustments().contains_key(expr.hir_id),\n                     \"expression with never type wound up being adjusted\");\n             let adj_ty = self.next_diverging_ty_var(\n                 TypeVariableOrigin::AdjustmentType(expr.span));\n@@ -2842,7 +2865,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                               expr,\n                                               rcvr) {\n             Ok(method) => {\n-                self.write_method_call(expr.id, method);\n+                self.write_method_call(expr.hir_id, method);\n                 Ok(method)\n             }\n             Err(error) => {\n@@ -3416,7 +3439,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let fru_field_types = adt.struct_variant().fields.iter().map(|f| {\n                         self.normalize_associated_types_in(expr.span, &f.ty(self.tcx, substs))\n                     }).collect();\n-                    self.tables.borrow_mut().fru_field_types.insert(expr.id, fru_field_types);\n+\n+                    self.tables\n+                        .borrow_mut()\n+                        .fru_field_types_mut()\n+                        .insert(expr.hir_id, fru_field_types);\n                 }\n                 _ => {\n                     span_err!(self.tcx.sess, base_expr.span, E0436,\n@@ -3474,7 +3501,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Record the type, which applies it effects.\n         // We need to do this after the warning above, so that\n         // we don't warn for the diverging expression itself.\n-        self.write_ty(expr.id, ty);\n+        self.write_ty(expr.hir_id, ty);\n \n         // Combine the diverging and has_error flags.\n         self.diverges.set(self.diverges.get() | old_diverges);\n@@ -3547,7 +3574,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 }]);\n                             }\n                             oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n-                            self.write_method_call(expr.id, method);\n+                            self.write_method_call(expr.hir_id, method);\n                         } else {\n                             type_error_struct!(tcx.sess, expr.span, oprnd_t, E0614,\n                                                \"type `{}` cannot be dereferenced\",\n@@ -3625,7 +3652,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n               // We always require that the type provided as the value for\n               // a type parameter outlives the moment of instantiation.\n-              let substs = self.tables.borrow().node_substs(expr.id);\n+              let substs = self.tables.borrow().node_substs(expr.hir_id);\n               self.add_wf_bounds(substs, expr);\n \n               ty\n@@ -4057,7 +4084,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                    ty, def, segment);\n \n                 // Write back the new resolution.\n-                self.tables.borrow_mut().type_dependent_defs.insert(node_id, def);\n+                let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+                self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, def);\n \n                 (def, ty)\n             }\n@@ -4098,7 +4126,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         // Write back the new resolution.\n-        self.tables.borrow_mut().type_dependent_defs.insert(node_id, def);\n+        let hir_id = self.tcx.hir.node_to_hir_id(node_id);\n+        self.tables.borrow_mut().type_dependent_defs_mut().insert(hir_id, def);\n         (def, Some(ty), slice::ref_slice(&**item_segment))\n     }\n \n@@ -4130,19 +4159,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn check_decl_local(&self, local: &'gcx hir::Local)  {\n         let t = self.local_ty(local.span, local.id);\n-        self.write_ty(local.id, t);\n+        self.write_ty(local.hir_id, t);\n \n         if let Some(ref init) = local.init {\n             let init_ty = self.check_decl_initializer(local, &init);\n             if init_ty.references_error() {\n-                self.write_ty(local.id, init_ty);\n+                self.write_ty(local.hir_id, init_ty);\n             }\n         }\n \n         self.check_pat(&local.pat, t);\n-        let pat_ty = self.node_ty(local.pat.id);\n+        let pat_ty = self.node_ty(local.pat.hir_id);\n         if pat_ty.references_error() {\n-            self.write_ty(local.id, pat_ty);\n+            self.write_ty(local.hir_id, pat_ty);\n         }\n     }\n \n@@ -4294,14 +4323,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ty = self.tcx.types.err\n         }\n \n-        self.write_ty(blk.id, ty);\n+        self.write_ty(blk.hir_id, ty);\n \n         *self.ps.borrow_mut() = prev;\n         ty\n     }\n \n     /// Given a `NodeId`, return the `FnDecl` of the method it is enclosed by and whether a\n-    /// suggetion can be made, `None` otherwise.\n+    /// suggestion can be made, `None` otherwise.\n     pub fn get_fn_decl(&self, blk_id: ast::NodeId) -> Option<(hir::FnDecl, bool)> {\n         // Get enclosing Fn, if it is a function or a trait method, unless there's a `loop` or\n         // `while` before reaching it, as block tail returns are not available in them.\n@@ -4369,7 +4398,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// ```\n     ///\n     /// This routine checks if the return expression in a block would make sense on its own as a\n-    /// statement and the return type has been left as defaultor has been specified as `()`. If so,\n+    /// statement and the return type has been left as default or has been specified as `()`. If so,\n     /// it suggests adding a semicolon.\n     fn suggest_missing_semicolon(&self,\n                                      err: &mut DiagnosticBuilder<'tcx>,\n@@ -4472,7 +4501,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             hir::StmtSemi(ref e, _) => e,\n             _ => return,\n         };\n-        let last_expr_ty = self.node_ty(last_expr.id);\n+        let last_expr_ty = self.node_ty(last_expr.hir_id);\n         if self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err() {\n             return;\n         }\n@@ -4615,7 +4644,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let nid = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                 let ty = self.local_ty(span, nid);\n                 let ty = self.normalize_associated_types_in(span, &ty);\n-                self.write_ty(node_id, ty);\n+                self.write_ty(self.tcx.hir.node_to_hir_id(node_id), ty);\n                 return ty;\n             }\n             _ => {}\n@@ -4747,7 +4776,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n-        self.write_substs(node_id, substs);\n+        self.write_substs(self.tcx.hir.node_to_hir_id(node_id), substs);\n         ty_substituted\n     }\n "}, {"sha": "a4e1fdaf39e29a4a306d23dcba5a198c8b918e24", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -210,11 +210,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // some cases applied on the RHS, on top of which we need\n                         // to autoref, which is not allowed by apply_adjustments.\n                         // self.apply_adjustments(rhs_expr, vec![autoref]);\n-                        self.tables.borrow_mut().adjustments.entry(rhs_expr.id)\n-                            .or_insert(vec![]).push(autoref);\n+                        self.tables\n+                            .borrow_mut()\n+                            .adjustments_mut()\n+                            .entry(rhs_expr.hir_id)\n+                            .or_insert(vec![])\n+                            .push(autoref);\n                     }\n                 }\n-                self.write_method_call(expr.id, method);\n+                self.write_method_call(expr.hir_id, method);\n \n                 method.sig.output()\n             }\n@@ -340,7 +344,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         assert!(op.is_by_value());\n         match self.lookup_op_method(operand_ty, &[], Op::Unary(op, ex.span)) {\n             Ok(method) => {\n-                self.write_method_call(ex.id, method);\n+                self.write_method_call(ex.hir_id, method);\n                 method.sig.output()\n             }\n             Err(()) => {"}, {"sha": "baaeae93e08c06aa3f42d95b6607930c89bfab9b", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -284,7 +284,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Try to resolve the type for the given node.\n-    fn resolve_node_type(&self, id: ast::NodeId) -> Ty<'tcx> {\n+    fn resolve_node_type(&self, id: hir::HirId) -> Ty<'tcx> {\n         let t = self.node_ty(id);\n         self.resolve_type(t)\n     }\n@@ -309,8 +309,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n         let fn_sig = {\n-            let fn_sig_map = &self.tables.borrow().liberated_fn_sigs;\n-            match fn_sig_map.get(&id) {\n+            let fn_hir_id = self.tcx.hir.node_to_hir_id(id);\n+            match self.tables.borrow().liberated_fn_sigs().get(fn_hir_id) {\n                 Some(f) => f.clone(),\n                 None => {\n                     bug!(\"No fn-sig entry for id={}\", id);\n@@ -338,8 +338,9 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"visit_fn_body body.id {:?} call_site_scope: {:?}\",\n                body.id(), call_site_scope);\n         let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope));\n+        let body_hir_id = self.tcx.hir.node_to_hir_id(body_id.node_id);\n         self.type_of_node_must_outlive(infer::CallReturn(span),\n-                                       body_id.node_id,\n+                                       body_hir_id,\n                                        call_site_region);\n \n         self.region_bound_pairs.truncate(old_region_bounds_pairs_len);\n@@ -613,9 +614,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             let var_region = self.tcx.mk_region(ty::ReScope(var_scope));\n \n             let origin = infer::BindingTypeIsNotValidAtDecl(span);\n-            self.type_of_node_must_outlive(origin, id, var_region);\n+            let hir_id = self.tcx.hir.node_to_hir_id(id);\n+            self.type_of_node_must_outlive(origin, hir_id, var_region);\n \n-            let typ = self.resolve_node_type(id);\n+            let typ = self.resolve_node_type(hir_id);\n             let _ = dropck::check_safety_of_destructor_if_necessary(\n                 self, typ, span, var_scope);\n         })\n@@ -664,7 +666,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n \n         // No matter what, the type of each expression must outlive the\n         // scope of that expression. This also guarantees basic WF.\n-        let expr_ty = self.resolve_node_type(expr.id);\n+        let expr_ty = self.resolve_node_type(expr.hir_id);\n         // the region corresponding to this expression\n         let expr_region = self.tcx.node_scope_region(expr.id);\n         self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n@@ -686,7 +688,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                     infer::ParameterOrigin::OverloadedOperator\n             };\n \n-            let substs = self.tables.borrow().node_substs(expr.id);\n+            let substs = self.tables.borrow().node_substs(expr.hir_id);\n             self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n             // Arguments (sub-expressions) are checked via `constrain_call`, below.\n         }\n@@ -709,7 +711,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                expr, self.repeating_scope);\n         match expr.node {\n             hir::ExprPath(_) => {\n-                let substs = self.tables.borrow().node_substs(expr.id);\n+                let substs = self.tables.borrow().node_substs(expr.hir_id);\n                 let origin = infer::ParameterOrigin::Path;\n                 self.substs_wf_in_scope(origin, substs, expr.span, expr_region);\n             }\n@@ -718,7 +720,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 if is_method_call {\n                     self.constrain_call(expr, Some(&callee), args.iter().map(|e| &*e));\n                 } else {\n-                    self.constrain_callee(callee.id, expr, &callee);\n+                    self.constrain_callee(&callee);\n                     self.constrain_call(expr, None, args.iter().map(|e| &*e));\n                 }\n \n@@ -812,7 +814,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                 // adjustments*.\n                 //\n                 // FIXME(#6268) nested method calls requires that this rule change\n-                let ty0 = self.resolve_node_type(expr.id);\n+                let ty0 = self.resolve_node_type(expr.hir_id);\n                 self.type_must_outlive(infer::AddrOf(expr.span), ty0, expr_region);\n                 intravisit::walk_expr(self, expr);\n             }\n@@ -849,7 +851,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for RegionCtxt<'a, 'gcx, 'tcx> {\n                        ret_expr.id, call_site_scope);\n                 let call_site_region = self.tcx.mk_region(ty::ReScope(call_site_scope.unwrap()));\n                 self.type_of_node_must_outlive(infer::CallReturn(ret_expr.span),\n-                                               ret_expr.id,\n+                                               ret_expr.hir_id,\n                                                call_site_region);\n                 intravisit::walk_expr(self, expr);\n             }\n@@ -870,8 +872,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                cast_expr,\n                source_expr);\n \n-        let source_ty = self.resolve_node_type(source_expr.id);\n-        let target_ty = self.resolve_node_type(cast_expr.id);\n+        let source_ty = self.resolve_node_type(source_expr.hir_id);\n+        let target_ty = self.resolve_node_type(cast_expr.hir_id);\n \n         self.walk_cast(cast_expr, source_ty, target_ty);\n     }\n@@ -915,11 +917,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n         self.set_repeating_scope(repeating_scope);\n     }\n \n-    fn constrain_callee(&mut self,\n-                        callee_id: ast::NodeId,\n-                        _call_expr: &hir::Expr,\n-                        _callee_expr: &hir::Expr) {\n-        let callee_ty = self.resolve_node_type(callee_id);\n+    fn constrain_callee(&mut self, callee_expr: &hir::Expr) {\n+        let callee_ty = self.resolve_node_type(callee_expr.hir_id);\n         match callee_ty.sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => { }\n             _ => {\n@@ -962,14 +961,16 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n             // ensure that any regions appearing in the argument type are\n             // valid for at least the lifetime of the function:\n             self.type_of_node_must_outlive(infer::CallArg(arg_expr.span),\n-                                           arg_expr.id, callee_region);\n+                                           arg_expr.hir_id,\n+                                           callee_region);\n         }\n \n         // as loop above, but for receiver\n         if let Some(r) = receiver {\n             debug!(\"receiver: {:?}\", r);\n             self.type_of_node_must_outlive(infer::CallRcvr(r.span),\n-                                           r.id, callee_region);\n+                                           r.hir_id,\n+                                           callee_region);\n         }\n     }\n \n@@ -1038,7 +1039,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 //\n                 // FIXME(#6268) remove to support nested method calls\n                 self.type_of_node_must_outlive(infer::AutoBorrow(expr.span),\n-                                               expr.id, expr_region);\n+                                               expr.hir_id,\n+                                               expr_region);\n             }\n \n             cmt = self.with_mc(|mc| mc.cat_expr_adjusted(expr, cmt, &adjustment))?;\n@@ -1109,21 +1111,25 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// adjustments) are valid for at least `minimum_lifetime`\n     fn type_of_node_must_outlive(&mut self,\n         origin: infer::SubregionOrigin<'tcx>,\n-        id: ast::NodeId,\n+        hir_id: hir::HirId,\n         minimum_lifetime: ty::Region<'tcx>)\n     {\n         // Try to resolve the type.  If we encounter an error, then typeck\n         // is going to fail anyway, so just stop here and let typeck\n         // report errors later on in the writeback phase.\n-        let ty0 = self.resolve_node_type(id);\n-        let ty = self.tables.borrow().adjustments.get(&id)\n-            .and_then(|adj| adj.last())\n-            .map_or(ty0, |adj| adj.target);\n+        let ty0 = self.resolve_node_type(hir_id);\n+\n+        let ty = self.tables\n+                     .borrow()\n+                     .adjustments()\n+                     .get(hir_id)\n+                     .and_then(|adj| adj.last())\n+                     .map_or(ty0, |adj| adj.target);\n         let ty = self.resolve_type(ty);\n         debug!(\"constrain_regions_in_type_of_node(\\\n-                ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n+                ty={}, ty0={}, id={:?}, minimum_lifetime={:?})\",\n                 ty,  ty0,\n-               id, minimum_lifetime);\n+                hir_id, minimum_lifetime);\n         self.type_must_outlive(origin, ty, minimum_lifetime);\n     }\n \n@@ -1137,7 +1143,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n \n         debug!(\"link_addr_of: cmt={:?}\", cmt);\n \n-        self.link_region_from_node_type(expr.span, expr.id, mutability, cmt);\n+        self.link_region_from_node_type(expr.span, expr.hir_id, mutability, cmt);\n     }\n \n     /// Computes the guarantors for any ref bindings in a `let` and\n@@ -1173,7 +1179,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn link_fn_args(&self, body_scope: CodeExtent, args: &[hir::Arg]) {\n         debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n         for arg in args {\n-            let arg_ty = self.node_ty(arg.id);\n+            let arg_ty = self.node_ty(arg.hir_id);\n             let re_scope = self.tcx.mk_region(ty::ReScope(body_scope));\n             let arg_cmt = self.with_mc(|mc| {\n                 mc.cat_rvalue(arg.id, arg.pat.span, re_scope, arg_ty)\n@@ -1197,10 +1203,10 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                 match sub_pat.node {\n                     // `ref x` pattern\n                     PatKind::Binding(..) => {\n-                        let bm = *mc.tables.pat_binding_modes.get(&sub_pat.id)\n-                                                             .expect(\"missing binding mode\");\n+                        let bm = *mc.tables.pat_binding_modes().get(sub_pat.hir_id)\n+                                                               .expect(\"missing binding mode\");\n                         if let ty::BindByReference(mutbl) = bm {\n-                            self.link_region_from_node_type(sub_pat.span, sub_pat.id,\n+                            self.link_region_from_node_type(sub_pat.span, sub_pat.hir_id,\n                                                             mutbl, sub_cmt);\n                         }\n                     }\n@@ -1236,7 +1242,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     /// which must be some reference (`&T`, `&str`, etc).\n     fn link_region_from_node_type(&self,\n                                   span: Span,\n-                                  id: ast::NodeId,\n+                                  id: hir::HirId,\n                                   mutbl: hir::Mutability,\n                                   cmt_borrowed: mc::cmt<'tcx>) {\n         debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\","}, {"sha": "77e597b30c8ee6031667e29cfc3b7788fe5a9be5", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 61, "deletions": 35, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -50,8 +50,9 @@ use rustc::infer::UpvarRegion;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n+use rustc::hir::def_id::DefIndex;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::util::nodemap::NodeMap;\n+use rustc::util::nodemap::FxHashMap;\n \n use std::collections::hash_map::Entry;\n \n@@ -78,7 +79,10 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n             hir::ExprClosure(cc, _, body_id, _, is_generator) => {\n                 let body = self.fcx.tcx.hir.body(body_id);\n                 self.visit_body(body);\n-                self.fcx.analyze_closure(expr.id, expr.span, body, cc,\n+                self.fcx.analyze_closure((expr.id, expr.hir_id),\n+                                         expr.span,\n+                                         body,\n+                                         cc,\n                                          is_generator);\n             }\n \n@@ -91,7 +95,7 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for InferBorrowKindVisitor<'a, 'gcx, 'tcx> {\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn analyze_closure(&self,\n-                       id: ast::NodeId,\n+                       (closure_node_id, closure_hir_id): (ast::NodeId, hir::HirId),\n                        span: Span,\n                        body: &hir::Body,\n                        capture_clause: hir::CaptureClause,\n@@ -100,25 +104,33 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n          * Analysis starting point.\n          */\n \n-        debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id());\n+        debug!(\"analyze_closure(id={:?}, body.id={:?})\", closure_node_id, body.id());\n \n-        let infer_kind = if gen { false } else {\n-            match self.tables.borrow_mut().closure_kinds.entry(id) {\n+        let infer_kind = if gen {\n+            false\n+        } else {\n+            match self.tables\n+                      .borrow_mut()\n+                      .closure_kinds_mut()\n+                      .entry(closure_hir_id) {\n                 Entry::Occupied(_) => false,\n                 Entry::Vacant(entry) => {\n-                    debug!(\"check_closure: adding closure {:?} as Fn\", id);\n+                    debug!(\"check_closure: adding closure {:?} as Fn\", closure_node_id);\n                     entry.insert((ty::ClosureKind::Fn, None));\n                     true\n                 }\n             }\n         };\n \n-        self.tcx.with_freevars(id, |freevars| {\n+        let closure_def_id = self.tcx.hir.local_def_id(closure_node_id);\n+\n+        self.tcx.with_freevars(closure_node_id, |freevars| {\n             for freevar in freevars {\n-                let def_id = freevar.def.def_id();\n-                let var_node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                let upvar_id = ty::UpvarId { var_id: var_node_id,\n-                                             closure_expr_id: id };\n+                let var_def_id = freevar.def.def_id();\n+                let upvar_id = ty::UpvarId {\n+                    var_id: var_def_id.index,\n+                    closure_expr_id: closure_def_id.index,\n+                };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n \n                 let capture_kind = match capture_clause {\n@@ -143,7 +155,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let region_maps = &self.tcx.region_maps(body_owner_def_id);\n             let mut delegate = InferBorrowKind {\n                 fcx: self,\n-                adjust_closure_kinds: NodeMap(),\n+                adjust_closure_kinds: FxHashMap(),\n                 adjust_upvar_captures: ty::UpvarCaptureMap::default(),\n             };\n             euv::ExprUseVisitor::with_infer(&mut delegate,\n@@ -155,8 +167,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             // Write the adjusted values back into the main tables.\n             if infer_kind {\n-                if let Some(kind) = delegate.adjust_closure_kinds.remove(&id) {\n-                    self.tables.borrow_mut().closure_kinds.insert(id, kind);\n+                if let Some(kind) = delegate.adjust_closure_kinds\n+                                            .remove(&closure_def_id.index) {\n+                    self.tables\n+                        .borrow_mut()\n+                        .closure_kinds_mut()\n+                        .insert(closure_hir_id, kind);\n                 }\n             }\n             self.tables.borrow_mut().upvar_capture_map.extend(\n@@ -176,21 +192,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // inference algorithm will reject it).\n \n         // Extract the type variables UV0...UVn.\n-        let (def_id, closure_substs) = match self.node_ty(id).sty {\n+        let (def_id, closure_substs) = match self.node_ty(closure_hir_id).sty {\n             ty::TyClosure(def_id, substs) |\n             ty::TyGenerator(def_id, substs, _) => (def_id, substs),\n             ref t => {\n                 span_bug!(\n                     span,\n                     \"type of closure expr {:?} is not a closure {:?}\",\n-                    id, t);\n+                    closure_node_id, t);\n             }\n         };\n \n         // Equate the type variables with the actual types.\n-        let final_upvar_tys = self.final_upvar_tys(id);\n+        let final_upvar_tys = self.final_upvar_tys(closure_node_id);\n         debug!(\"analyze_closure: id={:?} closure_substs={:?} final_upvar_tys={:?}\",\n-               id, closure_substs, final_upvar_tys);\n+               closure_node_id, closure_substs, final_upvar_tys);\n         for (upvar_ty, final_upvar_ty) in\n             closure_substs.upvar_tys(def_id, self.tcx).zip(final_upvar_tys)\n         {\n@@ -200,7 +216,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If we are also inferred the closure kind here,\n         // process any deferred resolutions.\n         if infer_kind {\n-            let closure_def_id = self.tcx.hir.local_def_id(id);\n             let deferred_call_resolutions =\n                 self.remove_deferred_call_resolutions(closure_def_id);\n             for deferred_call_resolution in deferred_call_resolutions {\n@@ -217,19 +232,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // This may change if abstract return types of some sort are\n         // implemented.\n         let tcx = self.tcx;\n+        let closure_def_index = tcx.hir.local_def_id(closure_id).index;\n+\n         tcx.with_freevars(closure_id, |freevars| {\n             freevars.iter().map(|freevar| {\n-                let def_id = freevar.def.def_id();\n-                let var_id = tcx.hir.as_local_node_id(def_id).unwrap();\n-                let freevar_ty = self.node_ty(var_id);\n+                let var_def_id = freevar.def.def_id();\n+                let var_node_id = tcx.hir.as_local_node_id(var_def_id).unwrap();\n+                let freevar_ty = self.node_ty(tcx.hir.node_to_hir_id(var_node_id));\n                 let upvar_id = ty::UpvarId {\n-                    var_id: var_id,\n-                    closure_expr_id: closure_id\n+                    var_id: var_def_id.index,\n+                    closure_expr_id: closure_def_index,\n                 };\n                 let capture = self.tables.borrow().upvar_capture(upvar_id);\n \n                 debug!(\"var_id={:?} freevar_ty={:?} capture={:?}\",\n-                       var_id, freevar_ty, capture);\n+                       var_node_id, freevar_ty, capture);\n \n                 match capture {\n                     ty::UpvarCapture::ByValue => freevar_ty,\n@@ -247,7 +264,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n struct InferBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    adjust_closure_kinds: NodeMap<(ty::ClosureKind, Option<(Span, ast::Name)>)>,\n+    adjust_closure_kinds: FxHashMap<DefIndex, (ty::ClosureKind, Option<(Span, ast::Name)>)>,\n     adjust_upvar_captures: ty::UpvarCaptureMap<'tcx>,\n }\n \n@@ -286,7 +303,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                         self.adjust_closure_kind(upvar_id.closure_expr_id,\n                                                  ty::ClosureKind::FnOnce,\n                                                  guarantor.span,\n-                                                 tcx.hir.name(upvar_id.var_id));\n+                                                 var_name(tcx, upvar_id.var_id));\n \n                         self.adjust_upvar_captures.insert(upvar_id, ty::UpvarCapture::ByValue);\n                     }\n@@ -300,7 +317,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                         self.adjust_closure_kind(upvar_id.closure_expr_id,\n                                                  ty::ClosureKind::FnOnce,\n                                                  guarantor.span,\n-                                                 tcx.hir.name(upvar_id.var_id));\n+                                                 var_name(tcx, upvar_id.var_id));\n                     }\n                     mc::NoteNone => {\n                     }\n@@ -405,7 +422,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 self.adjust_closure_kind(upvar_id.closure_expr_id,\n                                          ty::ClosureKind::FnMut,\n                                          cmt.span,\n-                                         tcx.hir.name(upvar_id.var_id));\n+                                         var_name(tcx, upvar_id.var_id));\n \n                 true\n             }\n@@ -416,7 +433,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 self.adjust_closure_kind(upvar_id.closure_expr_id,\n                                          ty::ClosureKind::FnMut,\n                                          cmt.span,\n-                                         tcx.hir.name(upvar_id.var_id));\n+                                         var_name(tcx, upvar_id.var_id));\n \n                 true\n             }\n@@ -465,17 +482,21 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     }\n \n     fn adjust_closure_kind(&mut self,\n-                           closure_id: ast::NodeId,\n+                           closure_id: DefIndex,\n                            new_kind: ty::ClosureKind,\n                            upvar_span: Span,\n                            var_name: ast::Name) {\n-        debug!(\"adjust_closure_kind(closure_id={}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n+        debug!(\"adjust_closure_kind(closure_id={:?}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n                closure_id, new_kind, upvar_span, var_name);\n \n         let closure_kind = self.adjust_closure_kinds.get(&closure_id).cloned()\n-            .or_else(|| self.fcx.tables.borrow().closure_kinds.get(&closure_id).cloned());\n+            .or_else(|| {\n+                let closure_id = self.fcx.tcx.hir.def_index_to_hir_id(closure_id);\n+                self.fcx.tables.borrow().closure_kinds().get(closure_id).cloned()\n+            });\n+\n         if let Some((existing_kind, _)) = closure_kind {\n-            debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\",\n+            debug!(\"adjust_closure_kind: closure_id={:?}, existing_kind={:?}, new_kind={:?}\",\n                    closure_id, existing_kind, new_kind);\n \n             match (existing_kind, new_kind) {\n@@ -565,3 +586,8 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         self.adjust_upvar_borrow_kind_for_mut(assignee_cmt);\n     }\n }\n+\n+fn var_name(tcx: ty::TyCtxt, var_def_index: DefIndex) -> ast::Name {\n+    let var_node_id = tcx.hir.def_index_to_node_id(var_def_index);\n+    tcx.hir.name(var_node_id)\n+}"}, {"sha": "31e14a6b630d277885381555534d65ae31524469", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -255,7 +255,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n         // We want to ensure:\n         //\n         // 1) that there are no items contained within\n-        // the trait defintion\n+        // the trait definition\n         //\n         // 2) that the definition doesn't violate the no-super trait rule\n         // for auto traits."}, {"sha": "54be3507774d2de5b219ae38848d6b00f89ea706", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 124, "deletions": 53, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -14,6 +14,7 @@\n \n use check::FnCtxt;\n use rustc::hir;\n+use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::infer::{InferCtxt};\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -34,7 +35,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let mut wbcx = WritebackCx::new(self, body);\n         for arg in &body.arguments {\n-            wbcx.visit_node_id(arg.pat.span, arg.id);\n+            wbcx.visit_node_id(arg.pat.span, arg.hir_id);\n         }\n         wbcx.visit_body(body);\n         wbcx.visit_upvar_borrow_map();\n@@ -76,10 +77,13 @@ struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>, body: &'gcx hir::Body)\n-        -> WritebackCx<'cx, 'gcx, 'tcx> {\n+        -> WritebackCx<'cx, 'gcx, 'tcx>\n+    {\n+        let owner = fcx.tcx.hir.definitions().node_to_hir_id(body.id().node_id);\n+\n         WritebackCx {\n             fcx: fcx,\n-            tables: ty::TypeckTables::empty(),\n+            tables: ty::TypeckTables::empty(Some(DefId::local(owner.owner))),\n             body: body\n         }\n     }\n@@ -88,10 +92,10 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         self.fcx.tcx\n     }\n \n-    fn write_ty_to_tables(&mut self, node_id: ast::NodeId, ty: Ty<'gcx>) {\n-        debug!(\"write_ty_to_tables({}, {:?})\", node_id,  ty);\n+    fn write_ty_to_tables(&mut self, hir_id: hir::HirId, ty: Ty<'gcx>) {\n+        debug!(\"write_ty_to_tables({:?}, {:?})\", hir_id,  ty);\n         assert!(!ty.needs_infer());\n-        self.tables.node_types.insert(node_id, ty);\n+        self.tables.node_types_mut().insert(hir_id, ty);\n     }\n \n     // Hacky hack: During type-checking, we treat *all* operators\n@@ -102,37 +106,38 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         match e.node {\n             hir::ExprUnary(hir::UnNeg, ref inner) |\n             hir::ExprUnary(hir::UnNot, ref inner)  => {\n-                let inner_ty = self.fcx.node_ty(inner.id);\n+                let inner_ty = self.fcx.node_ty(inner.hir_id);\n                 let inner_ty = self.fcx.resolve_type_vars_if_possible(&inner_ty);\n \n                 if inner_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n-                    tables.type_dependent_defs.remove(&e.id);\n-                    tables.node_substs.remove(&e.id);\n+                    tables.type_dependent_defs_mut().remove(e.hir_id);\n+                    tables.node_substs_mut().remove(e.hir_id);\n                 }\n             }\n             hir::ExprBinary(ref op, ref lhs, ref rhs) |\n             hir::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n-                let lhs_ty = self.fcx.node_ty(lhs.id);\n+                let lhs_ty = self.fcx.node_ty(lhs.hir_id);\n                 let lhs_ty = self.fcx.resolve_type_vars_if_possible(&lhs_ty);\n \n-                let rhs_ty = self.fcx.node_ty(rhs.id);\n+                let rhs_ty = self.fcx.node_ty(rhs.hir_id);\n                 let rhs_ty = self.fcx.resolve_type_vars_if_possible(&rhs_ty);\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n                     let mut tables = self.fcx.tables.borrow_mut();\n-                    tables.type_dependent_defs.remove(&e.id);\n-                    tables.node_substs.remove(&e.id);\n+                    tables.type_dependent_defs_mut().remove(e.hir_id);\n+                    tables.node_substs_mut().remove(e.hir_id);\n \n                     match e.node {\n                         hir::ExprBinary(..) => {\n                             if !op.node.is_by_value() {\n-                                tables.adjustments.get_mut(&lhs.id).map(|a| a.pop());\n-                                tables.adjustments.get_mut(&rhs.id).map(|a| a.pop());\n+                                let mut adjustments = tables.adjustments_mut();\n+                                adjustments.get_mut(lhs.hir_id).map(|a| a.pop());\n+                                adjustments.get_mut(rhs.hir_id).map(|a| a.pop());\n                             }\n                         },\n                         hir::ExprAssignOp(..) => {\n-                            tables.adjustments.get_mut(&lhs.id).map(|a| a.pop());\n+                            tables.adjustments_mut().get_mut(lhs.hir_id).map(|a| a.pop());\n                         },\n                         _ => {},\n                     }\n@@ -159,13 +164,13 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     fn visit_expr(&mut self, e: &'gcx hir::Expr) {\n         self.fix_scalar_builtin_expr(e);\n \n-        self.visit_node_id(e.span, e.id);\n+        self.visit_node_id(e.span, e.hir_id);\n \n         if let hir::ExprClosure(_, _, body, _, _) = e.node {\n             let body = self.fcx.tcx.hir.body(body);\n             // FIXME: Why visit the args here?\n             for arg in &body.arguments {\n-                self.visit_node_id(e.span, arg.id);\n+                self.visit_node_id(e.span, arg.hir_id);\n             }\n \n             self.visit_body(body);\n@@ -175,29 +180,33 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_block(&mut self, b: &'gcx hir::Block) {\n-        self.visit_node_id(b.span, b.id);\n+        self.visit_node_id(b.span, b.hir_id);\n         intravisit::walk_block(self, b);\n     }\n \n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n         match p.node {\n             hir::PatKind::Binding(..) => {\n-                let bm = *self.fcx.tables.borrow().pat_binding_modes.get(&p.id)\n-                                                                    .expect(\"missing binding mode\");\n-                self.tables.pat_binding_modes.insert(p.id, bm);\n+                let bm = *self.fcx\n+                              .tables\n+                              .borrow()\n+                              .pat_binding_modes()\n+                              .get(p.hir_id)\n+                              .expect(\"missing binding mode\");\n+                self.tables.pat_binding_modes_mut().insert(p.hir_id, bm);\n             }\n             _ => {}\n         };\n \n-        self.visit_node_id(p.span, p.id);\n+        self.visit_node_id(p.span, p.hir_id);\n         intravisit::walk_pat(self, p);\n     }\n \n     fn visit_local(&mut self, l: &'gcx hir::Local) {\n         intravisit::walk_local(self, l);\n         let var_ty = self.fcx.local_ty(l.span, l.id);\n         let var_ty = self.resolve(&var_ty, &l.span);\n-        self.write_ty_to_tables(l.id, var_ty);\n+        self.write_ty_to_tables(l.hir_id, var_ty);\n     }\n }\n \n@@ -221,19 +230,42 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_closures(&mut self) {\n-        for (&id, closure_ty) in self.fcx.tables.borrow().closure_tys.iter() {\n-            let closure_ty = self.resolve(closure_ty, &id);\n-            self.tables.closure_tys.insert(id, closure_ty);\n+        let fcx_tables = self.fcx.tables.borrow();\n+        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+\n+        for (&id, closure_ty) in fcx_tables.closure_tys().iter() {\n+            let hir_id = hir::HirId {\n+                owner: common_local_id_root.index,\n+                local_id: id,\n+            };\n+            let closure_ty = self.resolve(closure_ty, &hir_id);\n+            self.tables.closure_tys_mut().insert(hir_id, closure_ty);\n         }\n \n-        for (&id, &closure_kind) in self.fcx.tables.borrow().closure_kinds.iter() {\n-            self.tables.closure_kinds.insert(id, closure_kind);\n+        for (&id, &closure_kind) in fcx_tables.closure_kinds().iter() {\n+            let hir_id = hir::HirId {\n+                owner: common_local_id_root.index,\n+                local_id: id,\n+            };\n+            self.tables.closure_kinds_mut().insert(hir_id, closure_kind);\n         }\n     }\n \n     fn visit_cast_types(&mut self) {\n-        self.tables.cast_kinds.extend(\n-            self.fcx.tables.borrow().cast_kinds.iter().map(|(&key, &value)| (key, value)));\n+        let fcx_tables = self.fcx.tables.borrow();\n+        let fcx_cast_kinds = fcx_tables.cast_kinds();\n+        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        let mut self_cast_kinds = self.tables.cast_kinds_mut();\n+        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+\n+        for (&local_id, &cast_kind) in fcx_cast_kinds.iter() {\n+            let hir_id = hir::HirId {\n+                owner: common_local_id_root.index,\n+                local_id,\n+            };\n+            self_cast_kinds.insert(hir_id, cast_kind);\n+        }\n     }\n \n     fn visit_free_region_map(&mut self) {\n@@ -276,45 +308,54 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 }\n             });\n \n-            self.tables.node_types.insert(node_id, outside_ty);\n+            let hir_id = self.tcx().hir.node_to_hir_id(node_id);\n+            self.tables.node_types_mut().insert(hir_id, outside_ty);\n         }\n     }\n \n-    fn visit_node_id(&mut self, span: Span, node_id: ast::NodeId) {\n+    fn visit_node_id(&mut self, span: Span, hir_id: hir::HirId) {\n         // Export associated path extensions and method resultions.\n-        if let Some(def) = self.fcx.tables.borrow_mut().type_dependent_defs.remove(&node_id) {\n-            self.tables.type_dependent_defs.insert(node_id, def);\n+        if let Some(def) = self.fcx\n+                               .tables\n+                               .borrow_mut()\n+                               .type_dependent_defs_mut()\n+                               .remove(hir_id) {\n+            self.tables.type_dependent_defs_mut().insert(hir_id, def);\n         }\n \n         // Resolve any borrowings for the node with id `node_id`\n-        self.visit_adjustments(span, node_id);\n+        self.visit_adjustments(span, hir_id);\n \n         // Resolve the type of the node with id `node_id`\n-        let n_ty = self.fcx.node_ty(node_id);\n+        let n_ty = self.fcx.node_ty(hir_id);\n         let n_ty = self.resolve(&n_ty, &span);\n-        self.write_ty_to_tables(node_id, n_ty);\n-        debug!(\"Node {} has type {:?}\", node_id, n_ty);\n+        self.write_ty_to_tables(hir_id, n_ty);\n+        debug!(\"Node {:?} has type {:?}\", hir_id, n_ty);\n \n         // Resolve any substitutions\n-        if let Some(&substs) = self.fcx.tables.borrow().node_substs.get(&node_id) {\n+        if let Some(substs) = self.fcx.tables.borrow().node_substs_opt(hir_id) {\n             let substs = self.resolve(&substs, &span);\n-            debug!(\"write_substs_to_tcx({}, {:?})\", node_id, substs);\n+            debug!(\"write_substs_to_tcx({:?}, {:?})\", hir_id, substs);\n             assert!(!substs.needs_infer());\n-            self.tables.node_substs.insert(node_id, substs);\n+            self.tables.node_substs_mut().insert(hir_id, substs);\n         }\n     }\n \n-    fn visit_adjustments(&mut self, span: Span, node_id: ast::NodeId) {\n-        let adjustment = self.fcx.tables.borrow_mut().adjustments.remove(&node_id);\n+    fn visit_adjustments(&mut self, span: Span, hir_id: hir::HirId) {\n+        let adjustment = self.fcx\n+                             .tables\n+                             .borrow_mut()\n+                             .adjustments_mut()\n+                             .remove(hir_id);\n         match adjustment {\n             None => {\n-                debug!(\"No adjustments for node {}\", node_id);\n+                debug!(\"No adjustments for node {:?}\", hir_id);\n             }\n \n             Some(adjustment) => {\n                 let resolved_adjustment = self.resolve(&adjustment, &span);\n-                debug!(\"Adjustments for node {}: {:?}\", node_id, resolved_adjustment);\n-                self.tables.adjustments.insert(node_id, resolved_adjustment);\n+                debug!(\"Adjustments for node {:?}: {:?}\", hir_id, resolved_adjustment);\n+                self.tables.adjustments_mut().insert(hir_id, resolved_adjustment);\n             }\n         }\n     }\n@@ -337,16 +378,32 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_liberated_fn_sigs(&mut self) {\n-        for (&node_id, fn_sig) in self.fcx.tables.borrow().liberated_fn_sigs.iter() {\n-            let fn_sig = self.resolve(fn_sig, &node_id);\n-            self.tables.liberated_fn_sigs.insert(node_id, fn_sig.clone());\n+        let fcx_tables = self.fcx.tables.borrow();\n+        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+\n+        for (&local_id, fn_sig) in fcx_tables.liberated_fn_sigs().iter() {\n+            let hir_id = hir::HirId {\n+                owner: common_local_id_root.index,\n+                local_id,\n+            };\n+            let fn_sig = self.resolve(fn_sig, &hir_id);\n+            self.tables.liberated_fn_sigs_mut().insert(hir_id, fn_sig.clone());\n         }\n     }\n \n     fn visit_fru_field_types(&mut self) {\n-        for (&node_id, ftys) in self.fcx.tables.borrow().fru_field_types.iter() {\n-            let ftys = self.resolve(ftys, &node_id);\n-            self.tables.fru_field_types.insert(node_id, ftys);\n+        let fcx_tables = self.fcx.tables.borrow();\n+        debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n+        let common_local_id_root = fcx_tables.local_id_root.unwrap();\n+\n+        for (&local_id, ftys) in fcx_tables.fru_field_types().iter() {\n+            let hir_id = hir::HirId {\n+                owner: common_local_id_root.index,\n+                local_id,\n+            };\n+            let ftys = self.resolve(ftys, &hir_id);\n+            self.tables.fru_field_types_mut().insert(hir_id, ftys);\n         }\n     }\n \n@@ -376,6 +433,20 @@ impl Locatable for ast::NodeId {\n     fn to_span(&self, tcx: &TyCtxt) -> Span { tcx.hir.span(*self) }\n }\n \n+impl Locatable for DefIndex {\n+    fn to_span(&self, tcx: &TyCtxt) -> Span {\n+        let node_id = tcx.hir.def_index_to_node_id(*self);\n+        tcx.hir.span(node_id)\n+    }\n+}\n+\n+impl Locatable for hir::HirId {\n+    fn to_span(&self, tcx: &TyCtxt) -> Span {\n+        let node_id = tcx.hir.definitions().find_node_for_hir_id(*self);\n+        tcx.hir.span(node_id)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // The Resolver. This is the type folding engine that detects\n // unresolved types and so forth."}, {"sha": "6060312f51e81ce0ab828d5a9d323416a3df02c4", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -1191,7 +1191,8 @@ fn type_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         NodeTy(&hir::Ty { node: TyImplTrait(..), .. }) => {\n             let owner = tcx.hir.get_parent_did(node_id);\n-            tcx.typeck_tables_of(owner).node_id_to_type(node_id)\n+            let hir_id = tcx.hir.node_to_hir_id(node_id);\n+            tcx.typeck_tables_of(owner).node_id_to_type(hir_id)\n         }\n \n         x => {\n@@ -1242,8 +1243,8 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             ))\n         }\n \n-        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n-            tcx.typeck_tables_of(def_id).closure_tys[&node_id]\n+        NodeExpr(&hir::Expr { node: hir::ExprClosure(..), hir_id, .. }) => {\n+            tcx.typeck_tables_of(def_id).closure_tys()[hir_id]\n         }\n \n         x => {"}, {"sha": "37cb1f9280b61ea0c6858262c750092f1b77bffc", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -98,7 +98,7 @@ pub fn identify_constrained_type_params<'tcx>(tcx: ty::TyCtxt,\n \n /// Order the predicates in `predicates` such that each parameter is\n /// constrained before it is used, if that is possible, and add the\n-/// paramaters so constrained to `input_parameters`. For example,\n+/// parameters so constrained to `input_parameters`. For example,\n /// imagine the following impl:\n ///\n ///     impl<T: Debug, U: Iterator<Item=T>> Trait for U"}, {"sha": "ba2a8594ec0e226a7b5568b8899d53d664d7fce5", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -51,7 +51,7 @@ pub struct Constraint<'a> {\n     pub variance: &'a VarianceTerm<'a>,\n }\n \n-/// To build constriants, we visit one item (type, trait) at a time\n+/// To build constraints, we visit one item (type, trait) at a time\n /// and look at its contents. So e.g. if we have\n ///\n ///     struct Foo<T> {"}, {"sha": "da8c3a5cf206bc67042e1e5d73ecf78cebc03061", "filename": "src/librustdoc/clean/cfg.rs", "status": "added", "additions": 889, "deletions": 0, "changes": 889, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,889 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Representation of a `#[doc(cfg(...))]` attribute.\n+\n+// FIXME: Once RFC #1868 is implemented, switch to use those structures instead.\n+\n+use std::mem;\n+use std::fmt::{self, Write};\n+use std::ops;\n+use std::ascii::AsciiExt;\n+\n+use syntax::symbol::Symbol;\n+use syntax::ast::{MetaItem, MetaItemKind, NestedMetaItem, NestedMetaItemKind, LitKind};\n+use syntax::parse::ParseSess;\n+use syntax::feature_gate::Features;\n+\n+use syntax_pos::Span;\n+\n+use html::escape::Escape;\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, PartialEq)]\n+pub enum Cfg {\n+    /// Accepts all configurations.\n+    True,\n+    /// Denies all configurations.\n+    False,\n+    /// A generic configration option, e.g. `test` or `target_os = \"linux\"`.\n+    Cfg(Symbol, Option<Symbol>),\n+    /// Negate a configuration requirement, i.e. `not(x)`.\n+    Not(Box<Cfg>),\n+    /// Union of a list of configuration requirements, i.e. `any(...)`.\n+    Any(Vec<Cfg>),\n+    /// Intersection of a list of configuration requirements, i.e. `all(...)`.\n+    All(Vec<Cfg>),\n+}\n+\n+#[derive(PartialEq, Debug)]\n+pub struct InvalidCfgError {\n+    pub msg: &'static str,\n+    pub span: Span,\n+}\n+\n+impl Cfg {\n+    /// Parses a `NestedMetaItem` into a `Cfg`.\n+    fn parse_nested(nested_cfg: &NestedMetaItem) -> Result<Cfg, InvalidCfgError> {\n+        match nested_cfg.node {\n+            NestedMetaItemKind::MetaItem(ref cfg) => Cfg::parse(cfg),\n+            NestedMetaItemKind::Literal(ref lit) => Err(InvalidCfgError {\n+                msg: \"unexpected literal\",\n+                span: lit.span,\n+            }),\n+        }\n+    }\n+\n+    /// Parses a `MetaItem` into a `Cfg`.\n+    ///\n+    /// The `MetaItem` should be the content of the `#[cfg(...)]`, e.g. `unix` or\n+    /// `target_os = \"redox\"`.\n+    ///\n+    /// If the content is not properly formatted, it will return an error indicating what and where\n+    /// the error is.\n+    pub fn parse(cfg: &MetaItem) -> Result<Cfg, InvalidCfgError> {\n+        let name = cfg.name();\n+        match cfg.node {\n+            MetaItemKind::Word => Ok(Cfg::Cfg(name, None)),\n+            MetaItemKind::NameValue(ref lit) => match lit.node {\n+                LitKind::Str(value, _) => Ok(Cfg::Cfg(name, Some(value))),\n+                _ => Err(InvalidCfgError {\n+                    // FIXME: if the main #[cfg] syntax decided to support non-string literals,\n+                    // this should be changed as well.\n+                    msg: \"value of cfg option should be a string literal\",\n+                    span: lit.span,\n+                }),\n+            },\n+            MetaItemKind::List(ref items) => {\n+                let mut sub_cfgs = items.iter().map(Cfg::parse_nested);\n+                match &*name.as_str() {\n+                    \"all\" => sub_cfgs.fold(Ok(Cfg::True), |x, y| Ok(x? & y?)),\n+                    \"any\" => sub_cfgs.fold(Ok(Cfg::False), |x, y| Ok(x? | y?)),\n+                    \"not\" => if sub_cfgs.len() == 1 {\n+                        Ok(!sub_cfgs.next().unwrap()?)\n+                    } else {\n+                        Err(InvalidCfgError {\n+                            msg: \"expected 1 cfg-pattern\",\n+                            span: cfg.span,\n+                        })\n+                    },\n+                    _ => Err(InvalidCfgError {\n+                        msg: \"invalid predicate\",\n+                        span: cfg.span,\n+                    }),\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Checks whether the given configuration can be matched in the current session.\n+    ///\n+    /// Equivalent to `attr::cfg_matches`.\n+    // FIXME: Actually make use of `features`.\n+    pub fn matches(&self, parse_sess: &ParseSess, features: Option<&Features>) -> bool {\n+        match *self {\n+            Cfg::False => false,\n+            Cfg::True => true,\n+            Cfg::Not(ref child) => !child.matches(parse_sess, features),\n+            Cfg::All(ref sub_cfgs) => {\n+                sub_cfgs.iter().all(|sub_cfg| sub_cfg.matches(parse_sess, features))\n+            },\n+            Cfg::Any(ref sub_cfgs) => {\n+                sub_cfgs.iter().any(|sub_cfg| sub_cfg.matches(parse_sess, features))\n+            },\n+            Cfg::Cfg(name, value) => parse_sess.config.contains(&(name, value)),\n+        }\n+    }\n+\n+    /// Whether the configuration consists of just `Cfg` or `Not`.\n+    fn is_simple(&self) -> bool {\n+        match *self {\n+            Cfg::False | Cfg::True | Cfg::Cfg(..) | Cfg::Not(..) => true,\n+            Cfg::All(..) | Cfg::Any(..) => false,\n+        }\n+    }\n+\n+    /// Whether the configuration consists of just `Cfg`, `Not` or `All`.\n+    fn is_all(&self) -> bool {\n+        match *self {\n+            Cfg::False | Cfg::True | Cfg::Cfg(..) | Cfg::Not(..) | Cfg::All(..) => true,\n+            Cfg::Any(..) => false,\n+        }\n+    }\n+\n+    /// Renders the configuration for human display, as a short HTML description.\n+    pub(crate) fn render_short_html(&self) -> String {\n+        let mut msg = Html(self).to_string();\n+        if self.should_capitalize_first_letter() {\n+            if let Some(i) = msg.find(|c: char| c.is_ascii_alphanumeric()) {\n+                msg[i .. i+1].make_ascii_uppercase();\n+            }\n+        }\n+        msg\n+    }\n+\n+    /// Renders the configuration for long display, as a long HTML description.\n+    pub(crate) fn render_long_html(&self) -> String {\n+        let mut msg = format!(\"This is supported on <strong>{}</strong>\", Html(self));\n+        if self.should_append_only_to_description() {\n+            msg.push_str(\" only\");\n+        }\n+        msg.push('.');\n+        msg\n+    }\n+\n+    fn should_capitalize_first_letter(&self) -> bool {\n+        match *self {\n+            Cfg::False | Cfg::True | Cfg::Not(..) => true,\n+            Cfg::Any(ref sub_cfgs) | Cfg::All(ref sub_cfgs) => {\n+                sub_cfgs.first().map(Cfg::should_capitalize_first_letter).unwrap_or(false)\n+            },\n+            Cfg::Cfg(name, _) => match &*name.as_str() {\n+                \"debug_assertions\" | \"target_endian\" => true,\n+                _ => false,\n+            },\n+        }\n+    }\n+\n+    fn should_append_only_to_description(&self) -> bool {\n+        match *self {\n+            Cfg::False | Cfg::True => false,\n+            Cfg::Any(..) | Cfg::All(..) | Cfg::Cfg(..) => true,\n+            Cfg::Not(ref child) => match **child {\n+                Cfg::Cfg(..) => true,\n+                _ => false,\n+            }\n+        }\n+    }\n+}\n+\n+impl ops::Not for Cfg {\n+    type Output = Cfg;\n+    fn not(self) -> Cfg {\n+        match self {\n+            Cfg::False => Cfg::True,\n+            Cfg::True => Cfg::False,\n+            Cfg::Not(cfg) => *cfg,\n+            s => Cfg::Not(Box::new(s)),\n+        }\n+    }\n+}\n+\n+impl ops::BitAndAssign for Cfg {\n+    fn bitand_assign(&mut self, other: Cfg) {\n+        match (self, other) {\n+            (&mut Cfg::False, _) | (_, Cfg::True) => {},\n+            (s, Cfg::False) => *s = Cfg::False,\n+            (s @ &mut Cfg::True, b) => *s = b,\n+            (&mut Cfg::All(ref mut a), Cfg::All(ref mut b)) => a.append(b),\n+            (&mut Cfg::All(ref mut a), ref mut b) => a.push(mem::replace(b, Cfg::True)),\n+            (s, Cfg::All(mut a)) => {\n+                let b = mem::replace(s, Cfg::True);\n+                a.push(b);\n+                *s = Cfg::All(a);\n+            },\n+            (s, b) => {\n+                let a = mem::replace(s, Cfg::True);\n+                *s = Cfg::All(vec![a, b]);\n+            },\n+        }\n+    }\n+}\n+\n+impl ops::BitAnd for Cfg {\n+    type Output = Cfg;\n+    fn bitand(mut self, other: Cfg) -> Cfg {\n+        self &= other;\n+        self\n+    }\n+}\n+\n+impl ops::BitOrAssign for Cfg {\n+    fn bitor_assign(&mut self, other: Cfg) {\n+        match (self, other) {\n+            (&mut Cfg::True, _) | (_, Cfg::False) => {},\n+            (s, Cfg::True) => *s = Cfg::True,\n+            (s @ &mut Cfg::False, b) => *s = b,\n+            (&mut Cfg::Any(ref mut a), Cfg::Any(ref mut b)) => a.append(b),\n+            (&mut Cfg::Any(ref mut a), ref mut b) => a.push(mem::replace(b, Cfg::True)),\n+            (s, Cfg::Any(mut a)) => {\n+                let b = mem::replace(s, Cfg::True);\n+                a.push(b);\n+                *s = Cfg::Any(a);\n+            },\n+            (s, b) => {\n+                let a = mem::replace(s, Cfg::True);\n+                *s = Cfg::Any(vec![a, b]);\n+            },\n+        }\n+    }\n+}\n+\n+impl ops::BitOr for Cfg {\n+    type Output = Cfg;\n+    fn bitor(mut self, other: Cfg) -> Cfg {\n+        self |= other;\n+        self\n+    }\n+}\n+\n+struct Html<'a>(&'a Cfg);\n+\n+fn write_with_opt_paren<T: fmt::Display>(\n+    fmt: &mut fmt::Formatter,\n+    has_paren: bool,\n+    obj: T,\n+) -> fmt::Result {\n+    if has_paren {\n+        fmt.write_char('(')?;\n+    }\n+    obj.fmt(fmt)?;\n+    if has_paren {\n+        fmt.write_char(')')?;\n+    }\n+    Ok(())\n+}\n+\n+\n+impl<'a> fmt::Display for Html<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match *self.0 {\n+            Cfg::Not(ref child) => match **child {\n+                Cfg::Any(ref sub_cfgs) => {\n+                    let separator = if sub_cfgs.iter().all(Cfg::is_simple) {\n+                        \" nor \"\n+                    } else {\n+                        \", nor \"\n+                    };\n+                    for (i, sub_cfg) in sub_cfgs.iter().enumerate() {\n+                        fmt.write_str(if i == 0 { \"neither \" } else { separator })?;\n+                        write_with_opt_paren(fmt, !sub_cfg.is_all(), Html(sub_cfg))?;\n+                    }\n+                    Ok(())\n+                }\n+                ref simple @ Cfg::Cfg(..) => write!(fmt, \"non-{}\", Html(simple)),\n+                ref c => write!(fmt, \"not ({})\", Html(c)),\n+            },\n+\n+            Cfg::Any(ref sub_cfgs) => {\n+                let separator = if sub_cfgs.iter().all(Cfg::is_simple) {\n+                    \" or \"\n+                } else {\n+                    \", or \"\n+                };\n+                for (i, sub_cfg) in sub_cfgs.iter().enumerate() {\n+                    if i != 0 {\n+                        fmt.write_str(separator)?;\n+                    }\n+                    write_with_opt_paren(fmt, !sub_cfg.is_all(), Html(sub_cfg))?;\n+                }\n+                Ok(())\n+            },\n+\n+            Cfg::All(ref sub_cfgs) => {\n+                for (i, sub_cfg) in sub_cfgs.iter().enumerate() {\n+                    if i != 0 {\n+                        fmt.write_str(\" and \")?;\n+                    }\n+                    write_with_opt_paren(fmt, !sub_cfg.is_simple(), Html(sub_cfg))?;\n+                }\n+                Ok(())\n+            },\n+\n+            Cfg::True => fmt.write_str(\"everywhere\"),\n+            Cfg::False => fmt.write_str(\"nowhere\"),\n+\n+            Cfg::Cfg(name, value) => {\n+                let n = &*name.as_str();\n+                let human_readable = match (n, value) {\n+                    (\"unix\", None) => \"Unix\",\n+                    (\"windows\", None) => \"Windows\",\n+                    (\"debug_assertions\", None) => \"debug-assertions enabled\",\n+                    (\"target_os\", Some(os)) => match &*os.as_str() {\n+                        \"android\" => \"Android\",\n+                        \"bitrig\" => \"Bitrig\",\n+                        \"dragonfly\" => \"DragonFly BSD\",\n+                        \"emscripten\" => \"Emscripten\",\n+                        \"freebsd\" => \"FreeBSD\",\n+                        \"fuchsia\" => \"Fuchsia\",\n+                        \"haiku\" => \"Haiku\",\n+                        \"ios\" => \"iOS\",\n+                        \"l4re\" => \"L4Re\",\n+                        \"linux\" => \"Linux\",\n+                        \"macos\" => \"macOS\",\n+                        \"nacl\" => \"NaCl\",\n+                        \"netbsd\" => \"NetBSD\",\n+                        \"openbsd\" => \"OpenBSD\",\n+                        \"redox\" => \"Redox\",\n+                        \"solaris\" => \"Solaris\",\n+                        \"windows\" => \"Windows\",\n+                        _ => \"\",\n+                    },\n+                    (\"target_arch\", Some(arch)) => match &*arch.as_str() {\n+                        \"aarch64\" => \"AArch64\",\n+                        \"arm\" => \"ARM\",\n+                        \"asmjs\" => \"asm.js\",\n+                        \"mips\" => \"MIPS\",\n+                        \"mips64\" => \"MIPS-64\",\n+                        \"msp430\" => \"MSP430\",\n+                        \"powerpc\" => \"PowerPC\",\n+                        \"powerpc64\" => \"PowerPC-64\",\n+                        \"s390x\" => \"s390x\",\n+                        \"sparc64\" => \"SPARC64\",\n+                        \"wasm32\" => \"WebAssembly\",\n+                        \"x86\" => \"x86\",\n+                        \"x86_64\" => \"x86-64\",\n+                        _ => \"\",\n+                    },\n+                    (\"target_vendor\", Some(vendor)) => match &*vendor.as_str() {\n+                        \"apple\" => \"Apple\",\n+                        \"pc\" => \"PC\",\n+                        \"rumprun\" => \"Rumprun\",\n+                        \"sun\" => \"Sun\",\n+                        _ => \"\"\n+                    },\n+                    (\"target_env\", Some(env)) => match &*env.as_str() {\n+                        \"gnu\" => \"GNU\",\n+                        \"msvc\" => \"MSVC\",\n+                        \"musl\" => \"musl\",\n+                        \"newlib\" => \"Newlib\",\n+                        \"uclibc\" => \"uClibc\",\n+                        _ => \"\",\n+                    },\n+                    (\"target_endian\", Some(endian)) => return write!(fmt, \"{}-endian\", endian),\n+                    (\"target_pointer_width\", Some(bits)) => return write!(fmt, \"{}-bit\", bits),\n+                    _ => \"\",\n+                };\n+                if !human_readable.is_empty() {\n+                    fmt.write_str(human_readable)\n+                } else if let Some(v) = value {\n+                    write!(fmt, \"<code>{}=\\\"{}\\\"</code>\", Escape(n), Escape(&*v.as_str()))\n+                } else {\n+                    write!(fmt, \"<code>{}</code>\", Escape(n))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::Cfg;\n+\n+    use syntax::symbol::Symbol;\n+    use syntax::ast::*;\n+    use syntax::codemap::dummy_spanned;\n+    use syntax_pos::DUMMY_SP;\n+\n+    fn word_cfg(s: &str) -> Cfg {\n+        Cfg::Cfg(Symbol::intern(s), None)\n+    }\n+\n+    fn name_value_cfg(name: &str, value: &str) -> Cfg {\n+        Cfg::Cfg(Symbol::intern(name), Some(Symbol::intern(value)))\n+    }\n+\n+    #[test]\n+    fn test_cfg_not() {\n+        assert_eq!(!Cfg::False, Cfg::True);\n+        assert_eq!(!Cfg::True, Cfg::False);\n+        assert_eq!(!word_cfg(\"test\"), Cfg::Not(Box::new(word_cfg(\"test\"))));\n+        assert_eq!(\n+            !Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+            Cfg::Not(Box::new(Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")])))\n+        );\n+        assert_eq!(\n+            !Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+            Cfg::Not(Box::new(Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")])))\n+        );\n+        assert_eq!(!Cfg::Not(Box::new(word_cfg(\"test\"))), word_cfg(\"test\"));\n+    }\n+\n+    #[test]\n+    fn test_cfg_and() {\n+        let mut x = Cfg::False;\n+        x &= Cfg::True;\n+        assert_eq!(x, Cfg::False);\n+\n+        x = word_cfg(\"test\");\n+        x &= Cfg::False;\n+        assert_eq!(x, Cfg::False);\n+\n+        x = word_cfg(\"test2\");\n+        x &= Cfg::True;\n+        assert_eq!(x, word_cfg(\"test2\"));\n+\n+        x = Cfg::True;\n+        x &= word_cfg(\"test3\");\n+        assert_eq!(x, word_cfg(\"test3\"));\n+\n+        x &= word_cfg(\"test4\");\n+        assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n+\n+        x &= word_cfg(\"test5\");\n+        assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\"), word_cfg(\"test5\")]));\n+\n+        x &= Cfg::All(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n+        assert_eq!(x, Cfg::All(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+        ]));\n+\n+        let mut y = Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n+        y &= x;\n+        assert_eq!(y, Cfg::All(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+            Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+        ]));\n+\n+        assert_eq!(\n+            word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\"),\n+            Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n+        );\n+    }\n+\n+    #[test]\n+    fn test_cfg_or() {\n+        let mut x = Cfg::True;\n+        x |= Cfg::False;\n+        assert_eq!(x, Cfg::True);\n+\n+        x = word_cfg(\"test\");\n+        x |= Cfg::True;\n+        assert_eq!(x, Cfg::True);\n+\n+        x = word_cfg(\"test2\");\n+        x |= Cfg::False;\n+        assert_eq!(x, word_cfg(\"test2\"));\n+\n+        x = Cfg::False;\n+        x |= word_cfg(\"test3\");\n+        assert_eq!(x, word_cfg(\"test3\"));\n+\n+        x |= word_cfg(\"test4\");\n+        assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n+\n+        x |= word_cfg(\"test5\");\n+        assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\"), word_cfg(\"test5\")]));\n+\n+        x |= Cfg::Any(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n+        assert_eq!(x, Cfg::Any(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+        ]));\n+\n+        let mut y = Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n+        y |= x;\n+        assert_eq!(y, Cfg::Any(vec![\n+            word_cfg(\"test3\"),\n+            word_cfg(\"test4\"),\n+            word_cfg(\"test5\"),\n+            word_cfg(\"test6\"),\n+            word_cfg(\"test7\"),\n+            Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]),\n+        ]));\n+\n+        assert_eq!(\n+            word_cfg(\"a\") | word_cfg(\"b\") | word_cfg(\"c\"),\n+            Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n+        );\n+    }\n+\n+    #[test]\n+    fn test_parse_ok() {\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::Word,\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"all\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::NameValue(dummy_spanned(LitKind::Str(\n+                Symbol::intern(\"done\"),\n+                StrStyle::Cooked,\n+            ))),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(name_value_cfg(\"all\", \"done\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"any\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") | word_cfg(\"b\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(!word_cfg(\"a\")));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"any\"),\n+                    node: MetaItemKind::List(vec![\n+                        dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                            name: Symbol::intern(\"a\"),\n+                            node: MetaItemKind::Word,\n+                            span: DUMMY_SP,\n+                        })),\n+                        dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                            name: Symbol::intern(\"all\"),\n+                            node: MetaItemKind::List(vec![\n+                                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                                    name: Symbol::intern(\"b\"),\n+                                    node: MetaItemKind::Word,\n+                                    span: DUMMY_SP,\n+                                })),\n+                                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                                    name: Symbol::intern(\"c\"),\n+                                    node: MetaItemKind::Word,\n+                                    span: DUMMY_SP,\n+                                })),\n+                            ]),\n+                            span: DUMMY_SP,\n+                        })),\n+                    ]),\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(!(word_cfg(\"a\") | (word_cfg(\"b\") & word_cfg(\"c\")))));\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"c\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert_eq!(Cfg::parse(&mi), Ok(word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\")));\n+    }\n+\n+    #[test]\n+    fn test_parse_err() {\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"foo\"),\n+            node: MetaItemKind::NameValue(dummy_spanned(LitKind::Bool(false))),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"foo\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"all\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"foo\"),\n+                    node: MetaItemKind::List(vec![]),\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"b\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"any\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"a\"),\n+                    node: MetaItemKind::Word,\n+                    span: DUMMY_SP,\n+                })),\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"foo\"),\n+                    node: MetaItemKind::List(vec![]),\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+\n+        let mi = MetaItem {\n+            name: Symbol::intern(\"not\"),\n+            node: MetaItemKind::List(vec![\n+                dummy_spanned(NestedMetaItemKind::MetaItem(MetaItem {\n+                    name: Symbol::intern(\"foo\"),\n+                    node: MetaItemKind::List(vec![]),\n+                    span: DUMMY_SP,\n+                })),\n+            ]),\n+            span: DUMMY_SP,\n+        };\n+        assert!(Cfg::parse(&mi).is_err());\n+    }\n+\n+    #[test]\n+    fn test_render_short_html() {\n+        assert_eq!(\n+            word_cfg(\"unix\").render_short_html(),\n+            \"Unix\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_os\", \"macos\").render_short_html(),\n+            \"macOS\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_pointer_width\", \"16\").render_short_html(),\n+            \"16-bit\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_endian\", \"little\").render_short_html(),\n+            \"Little-endian\"\n+        );\n+        assert_eq!(\n+            (!word_cfg(\"windows\")).render_short_html(),\n+            \"Non-Windows\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") & word_cfg(\"windows\")).render_short_html(),\n+            \"Unix and Windows\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") | word_cfg(\"windows\")).render_short_html(),\n+            \"Unix or Windows\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") & word_cfg(\"windows\") & word_cfg(\"debug_assertions\")\n+            ).render_short_html(),\n+            \"Unix and Windows and debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\")\n+            ).render_short_html(),\n+            \"Unix or Windows or debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                !(word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\"))\n+            ).render_short_html(),\n+            \"Neither Unix nor Windows nor debug-assertions enabled\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"unix\") & name_value_cfg(\"target_arch\", \"x86_64\")) |\n+                (word_cfg(\"windows\") & name_value_cfg(\"target_pointer_width\", \"64\"))\n+            ).render_short_html(),\n+            \"Unix and x86-64, or Windows and 64-bit\"\n+        );\n+        assert_eq!(\n+            (!(word_cfg(\"unix\") & word_cfg(\"windows\"))).render_short_html(),\n+            \"Not (Unix and Windows)\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"debug_assertions\") | word_cfg(\"windows\")) & word_cfg(\"unix\")\n+            ).render_short_html(),\n+            \"(Debug-assertions enabled or Windows) and Unix\"\n+        );\n+    }\n+\n+    #[test]\n+    fn test_render_long_html() {\n+        assert_eq!(\n+            word_cfg(\"unix\").render_long_html(),\n+            \"This is supported on <strong>Unix</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_os\", \"macos\").render_long_html(),\n+            \"This is supported on <strong>macOS</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_pointer_width\", \"16\").render_long_html(),\n+            \"This is supported on <strong>16-bit</strong> only.\"\n+        );\n+        assert_eq!(\n+            name_value_cfg(\"target_endian\", \"little\").render_long_html(),\n+            \"This is supported on <strong>little-endian</strong> only.\"\n+        );\n+        assert_eq!(\n+            (!word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>non-Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") & word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>Unix and Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (word_cfg(\"unix\") | word_cfg(\"windows\")).render_long_html(),\n+            \"This is supported on <strong>Unix or Windows</strong> only.\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") & word_cfg(\"windows\") & word_cfg(\"debug_assertions\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix and Windows and debug-assertions enabled</strong> \\\n+                only.\"\n+        );\n+        assert_eq!(\n+            (\n+                word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix or Windows or debug-assertions enabled</strong> \\\n+                only.\"\n+        );\n+        assert_eq!(\n+            (\n+                !(word_cfg(\"unix\") | word_cfg(\"windows\") | word_cfg(\"debug_assertions\"))\n+            ).render_long_html(),\n+            \"This is supported on <strong>neither Unix nor Windows nor debug-assertions \\\n+                enabled</strong>.\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"unix\") & name_value_cfg(\"target_arch\", \"x86_64\")) |\n+                (word_cfg(\"windows\") & name_value_cfg(\"target_pointer_width\", \"64\"))\n+            ).render_long_html(),\n+            \"This is supported on <strong>Unix and x86-64, or Windows and 64-bit</strong> only.\"\n+        );\n+        assert_eq!(\n+            (!(word_cfg(\"unix\") & word_cfg(\"windows\"))).render_long_html(),\n+            \"This is supported on <strong>not (Unix and Windows)</strong>.\"\n+        );\n+        assert_eq!(\n+            (\n+                (word_cfg(\"debug_assertions\") | word_cfg(\"windows\")) & word_cfg(\"unix\")\n+            ).render_long_html(),\n+            \"This is supported on <strong>(debug-assertions enabled or Windows) and Unix</strong> \\\n+                only.\"\n+        );\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "9b4c4e479d046e17813a291b5bc33139a57c060a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -495,7 +495,7 @@ fn build_static(cx: &DocContext, did: DefId, mutable: bool) -> clean::Static {\n \n /// A trait's generics clause actually contains all of the predicates for all of\n /// its associated types as well. We specifically move these clauses to the\n-/// associated types instead when displaying, so when we're genering the\n+/// associated types instead when displaying, so when we're generating the\n /// generics for the trait itself we need to be sure to remove them.\n /// We also need to remove the implied \"recursive\" Self: Trait bound.\n ///"}, {"sha": "e849f93a6bb7bf8130b35b9ce5baa9aa6e4ce2d1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -52,8 +52,11 @@ use visit_ast;\n use html::item_type::ItemType;\n \n pub mod inline;\n+pub mod cfg;\n mod simplify;\n \n+use self::cfg::Cfg;\n+\n // extract the stability index for a node from tcx, if possible\n fn get_stability(cx: &DocContext, def_id: DefId) -> Option<Stability> {\n     cx.tcx.lookup_stability(def_id).clean(cx)\n@@ -536,31 +539,67 @@ impl<I: IntoIterator<Item=ast::NestedMetaItem>> NestedAttributesExt for I {\n pub struct Attributes {\n     pub doc_strings: Vec<String>,\n     pub other_attrs: Vec<ast::Attribute>,\n+    pub cfg: Option<Rc<Cfg>>,\n     pub span: Option<syntax_pos::Span>,\n }\n \n impl Attributes {\n-    pub fn from_ast(attrs: &[ast::Attribute]) -> Attributes {\n+    /// Extracts the content from an attribute `#[doc(cfg(content))]`.\n+    fn extract_cfg(mi: &ast::MetaItem) -> Option<&ast::MetaItem> {\n+        use syntax::ast::NestedMetaItemKind::MetaItem;\n+\n+        if let ast::MetaItemKind::List(ref nmis) = mi.node {\n+            if nmis.len() == 1 {\n+                if let MetaItem(ref cfg_mi) = nmis[0].node {\n+                    if cfg_mi.check_name(\"cfg\") {\n+                        if let ast::MetaItemKind::List(ref cfg_nmis) = cfg_mi.node {\n+                            if cfg_nmis.len() == 1 {\n+                                if let MetaItem(ref content_mi) = cfg_nmis[0].node {\n+                                    return Some(content_mi);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    pub fn from_ast(diagnostic: &::errors::Handler, attrs: &[ast::Attribute]) -> Attributes {\n         let mut doc_strings = vec![];\n         let mut sp = None;\n+        let mut cfg = Cfg::True;\n+\n         let other_attrs = attrs.iter().filter_map(|attr| {\n             attr.with_desugared_doc(|attr| {\n-                if let Some(value) = attr.value_str() {\n-                    if attr.check_name(\"doc\") {\n-                        doc_strings.push(value.to_string());\n-                        if sp.is_none() {\n-                            sp = Some(attr.span);\n+                if attr.check_name(\"doc\") {\n+                    if let Some(mi) = attr.meta() {\n+                        if let Some(value) = mi.value_str() {\n+                            // Extracted #[doc = \"...\"]\n+                            doc_strings.push(value.to_string());\n+                            if sp.is_none() {\n+                                sp = Some(attr.span);\n+                            }\n+                            return None;\n+                        } else if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n+                            // Extracted #[doc(cfg(...))]\n+                            match Cfg::parse(cfg_mi) {\n+                                Ok(new_cfg) => cfg &= new_cfg,\n+                                Err(e) => diagnostic.span_err(e.span, e.msg),\n+                            }\n+                            return None;\n                         }\n-                        return None;\n                     }\n                 }\n-\n                 Some(attr.clone())\n             })\n         }).collect();\n         Attributes {\n-            doc_strings: doc_strings,\n-            other_attrs: other_attrs,\n+            doc_strings,\n+            other_attrs,\n+            cfg: if cfg == Cfg::True { None } else { Some(Rc::new(cfg)) },\n             span: sp,\n         }\n     }\n@@ -579,8 +618,8 @@ impl AttributesExt for Attributes {\n }\n \n impl Clean<Attributes> for [ast::Attribute] {\n-    fn clean(&self, _cx: &DocContext) -> Attributes {\n-        Attributes::from_ast(self)\n+    fn clean(&self, cx: &DocContext) -> Attributes {\n+        Attributes::from_ast(cx.sess().diagnostic(), self)\n     }\n }\n "}, {"sha": "9bb7e4e3a09d51e859b5fd7a2a0bc170be71503b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -10,6 +10,7 @@\n \n use rustc_lint;\n use rustc_driver::{driver, target_features, abort_on_err};\n+use rustc_driver::pretty::ReplaceBodyWithLoop;\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config};\n use rustc::hir::def_id::DefId;\n@@ -26,6 +27,7 @@ use rustc_metadata::cstore::CStore;\n \n use syntax::{ast, codemap};\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::fold::Folder;\n use errors;\n use errors::emitter::ColorConfig;\n \n@@ -158,6 +160,7 @@ pub fn run_core(search_paths: SearchPaths,\n     let krate = panictry!(driver::phase_1_parse_input(&driver::CompileController::basic(),\n                                                       &sess,\n                                                       &input));\n+    let krate = ReplaceBodyWithLoop::new().fold_crate(krate);\n \n     let name = link::find_crate_name(Some(&sess), &krate.attrs, &input);\n "}, {"sha": "82c252ae4d72675eb273b3478f84f89a49b28bb2", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -190,8 +190,8 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n                     .map(|l| map_line(l).for_code())\n                     .collect::<Vec<&str>>().join(\"\\n\");\n                 let krate = krate.as_ref().map(|s| &**s);\n-                let test = test::maketest(&test, krate, false,\n-                                        &Default::default());\n+                let test = test::make_test(&test, krate, false,\n+                                           &Default::default());\n                 let channel = if test.contains(\"#![feature(\") {\n                     \"&amp;version=nightly\"\n                 } else {\n@@ -584,8 +584,8 @@ pub fn render(w: &mut fmt::Formatter,\n                         .map(|l| map_line(l).for_code())\n                         .collect::<Vec<&str>>().join(\"\\n\");\n                     let krate = krate.as_ref().map(|s| &**s);\n-                    let test = test::maketest(&test, krate, false,\n-                                              &Default::default());\n+                    let test = test::make_test(&test, krate, false,\n+                                               &Default::default());\n                     let channel = if test.contains(\"#![feature(\") {\n                         \"&amp;version=nightly\"\n                     } else {"}, {"sha": "4e3181759f999aafb26458776c5bebcf25bc0b2f", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -762,17 +762,29 @@ fn write_shared(cx: &Context,\n             }\n         };\n \n+        let mut have_impls = false;\n         let mut implementors = format!(r#\"implementors[\"{}\"] = [\"#, krate.name);\n         for imp in imps {\n             // If the trait and implementation are in the same crate, then\n             // there's no need to emit information about it (there's inlining\n             // going on). If they're in different crates then the crate defining\n             // the trait will be interested in our implementation.\n             if imp.def_id.krate == did.krate { continue }\n+            // If the implementation is from another crate then that crate\n+            // should add it.\n+            if !imp.def_id.is_local() { continue }\n+            have_impls = true;\n             write!(implementors, \"{},\", as_json(&imp.impl_.to_string())).unwrap();\n         }\n         implementors.push_str(\"];\");\n \n+        // Only create a js file if we have impls to add to it. If the trait is\n+        // documented locally though we always create the file to avoid dead\n+        // links.\n+        if !have_impls && !cache.paths.contains_key(&did) {\n+            continue;\n+        }\n+\n         let mut mydst = dst.clone();\n         for part in &remote_path[..remote_path.len() - 1] {\n             mydst.push(part);\n@@ -1950,6 +1962,14 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n         stability.push(format!(\"<div class='stab deprecated'>{}</div>\", text))\n     }\n \n+    if let Some(ref cfg) = item.attrs.cfg {\n+        stability.push(format!(\"<div class='stab portability'>{}</div>\", if show_reason {\n+            cfg.render_long_html()\n+        } else {\n+            cfg.render_short_html()\n+        }));\n+    }\n+\n     stability\n }\n "}, {"sha": "08bf5a10fe9d981280810ff6bbd4ff9dac1e1301", "filename": "src/librustdoc/html/static/styles/main.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fstyles%2Fmain.css?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -152,6 +152,7 @@ a.test-arrow {\n \n .stab.unstable { background: #FFF5D6; border-color: #FFC600; }\n .stab.deprecated { background: #F3DFFF; border-color: #7F0087; }\n+.stab.portability { background: #C4ECFF; border-color: #7BA5DB; }\n \n #help > div {\n \tbackground: #e9e9e9;"}, {"sha": "9264015ed9edfae068ccc6d783af38e71726498f", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -26,6 +26,7 @@\n #![feature(test)]\n #![feature(unicode)]\n #![feature(vec_remove_item)]\n+#![feature(ascii_ctype)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "146629486fabdf58788170ff1213c53703bba808", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -33,6 +33,9 @@ pub use self::strip_priv_imports::strip_priv_imports;\n mod unindent_comments;\n pub use self::unindent_comments::unindent_comments;\n \n+mod propagate_doc_cfg;\n+pub use self::propagate_doc_cfg::propagate_doc_cfg;\n+\n type Pass = (&'static str,                                      // name\n              fn(clean::Crate) -> plugins::PluginResult,         // fn\n              &'static str);                                     // description\n@@ -49,13 +52,16 @@ pub const PASSES: &'static [Pass] = &[\n       implies strip-priv-imports\"),\n     (\"strip-priv-imports\", strip_priv_imports,\n      \"strips all private import statements (`use`, `extern crate`) from a crate\"),\n+    (\"propagate-doc-cfg\", propagate_doc_cfg,\n+     \"propagates `#[doc(cfg(...))]` to child items\"),\n ];\n \n pub const DEFAULT_PASSES: &'static [&'static str] = &[\n     \"strip-hidden\",\n     \"strip-private\",\n     \"collapse-docs\",\n     \"unindent-comments\",\n+    \"propagate-doc-cfg\",\n ];\n \n "}, {"sha": "9e65fff5e2ac6f3f65c04f9a3af106a9e708c65a", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+use clean::{Crate, Item};\n+use clean::cfg::Cfg;\n+use fold::DocFolder;\n+use plugins::PluginResult;\n+\n+pub fn propagate_doc_cfg(cr: Crate) -> PluginResult {\n+    CfgPropagator { parent_cfg: None }.fold_crate(cr)\n+}\n+\n+struct CfgPropagator {\n+    parent_cfg: Option<Rc<Cfg>>,\n+}\n+\n+impl DocFolder for CfgPropagator {\n+    fn fold_item(&mut self, mut item: Item) -> Option<Item> {\n+        let old_parent_cfg = self.parent_cfg.clone();\n+\n+        let new_cfg = match (self.parent_cfg.take(), item.attrs.cfg.take()) {\n+            (None, None) => None,\n+            (Some(rc), None) | (None, Some(rc)) => Some(rc),\n+            (Some(mut a), Some(b)) => {\n+                let b = Rc::try_unwrap(b).unwrap_or_else(|rc| Cfg::clone(&rc));\n+                *Rc::make_mut(&mut a) &= b;\n+                Some(a)\n+            }\n+        };\n+        self.parent_cfg = new_cfg.clone();\n+        item.attrs.cfg = new_cfg;\n+\n+        let result = self.fold_item_recur(item);\n+        self.parent_cfg = old_parent_cfg;\n+\n+        result\n+    }\n+}"}, {"sha": "b1fb343b8bb9c5cddb8daa3d31914b4d3ecdf917", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -32,13 +32,15 @@ use rustc_back::dynamic_lib::DynamicLibrary;\n use rustc_back::tempdir::TempDir;\n use rustc_driver::{self, driver, Compilation};\n use rustc_driver::driver::phase_2_configure_and_expand;\n+use rustc_driver::pretty::ReplaceBodyWithLoop;\n use rustc_metadata::cstore::CStore;\n use rustc_resolve::MakeGlobMap;\n use rustc_trans;\n use rustc_trans::back::link;\n use syntax::ast;\n use syntax::codemap::CodeMap;\n use syntax::feature_gate::UnstableFeatures;\n+use syntax::fold::Folder;\n use syntax_pos::{BytePos, DUMMY_SP, Pos, Span};\n use errors;\n use errors::emitter::ColorConfig;\n@@ -72,6 +74,7 @@ pub fn run(input: &str,\n         crate_types: vec![config::CrateTypeDylib],\n         externs: externs.clone(),\n         unstable_features: UnstableFeatures::from_environment(),\n+        lint_cap: Some(::rustc::lint::Level::Allow),\n         actually_rustdoc: true,\n         ..config::basic_options().clone()\n     };\n@@ -94,6 +97,7 @@ pub fn run(input: &str,\n     let krate = panictry!(driver::phase_1_parse_input(&driver::CompileController::basic(),\n                                                       &sess,\n                                                       &input));\n+    let krate = ReplaceBodyWithLoop::new().fold_crate(krate);\n     let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n         phase_2_configure_and_expand(\n             &sess, &cstore, krate, None, \"rustdoc-test\", None, MakeGlobMap::No, |_| Ok(())\n@@ -121,6 +125,7 @@ pub fn run(input: &str,\n         let map = hir::map::map_crate(&mut hir_forest, defs);\n         let krate = map.krate();\n         let mut hir_collector = HirCollector {\n+            sess: &sess,\n             collector: &mut collector,\n             map: &map\n         };\n@@ -169,16 +174,16 @@ fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n     opts\n }\n \n-fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n-           externs: Externs,\n-           should_panic: bool, no_run: bool, as_test_harness: bool,\n-           compile_fail: bool, mut error_codes: Vec<String>, opts: &TestOptions,\n-           maybe_sysroot: Option<PathBuf>) {\n+fn run_test(test: &str, cratename: &str, filename: &str, cfgs: Vec<String>, libs: SearchPaths,\n+            externs: Externs,\n+            should_panic: bool, no_run: bool, as_test_harness: bool,\n+            compile_fail: bool, mut error_codes: Vec<String>, opts: &TestOptions,\n+            maybe_sysroot: Option<PathBuf>) {\n     // the test harness wants its own `main` & top level functions, so\n     // never wrap the test in `fn main() { ... }`\n-    let test = maketest(test, Some(cratename), as_test_harness, opts);\n+    let test = make_test(test, Some(cratename), as_test_harness, opts);\n     let input = config::Input::Str {\n-        name: driver::anon_src(),\n+        name: filename.to_owned(),\n         input: test.to_owned(),\n     };\n     let outputs = OutputTypes::new(&[(OutputType::Exe, None)]);\n@@ -315,8 +320,11 @@ fn runtest(test: &str, cratename: &str, cfgs: Vec<String>, libs: SearchPaths,\n     }\n }\n \n-pub fn maketest(s: &str, cratename: Option<&str>, dont_insert_main: bool,\n-                opts: &TestOptions) -> String {\n+pub fn make_test(s: &str,\n+                 cratename: Option<&str>,\n+                 dont_insert_main: bool,\n+                 opts: &TestOptions)\n+                 -> String {\n     let (crate_attrs, everything_else) = partition_source(s);\n \n     let mut prog = String::new();\n@@ -500,18 +508,19 @@ impl Collector {\n                     rustc_driver::in_rustc_thread(move || {\n                         io::set_panic(panic);\n                         io::set_print(print);\n-                        runtest(&test,\n-                                &cratename,\n-                                cfgs,\n-                                libs,\n-                                externs,\n-                                should_panic,\n-                                no_run,\n-                                as_test_harness,\n-                                compile_fail,\n-                                error_codes,\n-                                &opts,\n-                                maybe_sysroot)\n+                        run_test(&test,\n+                                 &cratename,\n+                                 &filename,\n+                                 cfgs,\n+                                 libs,\n+                                 externs,\n+                                 should_panic,\n+                                 no_run,\n+                                 as_test_harness,\n+                                 compile_fail,\n+                                 error_codes,\n+                                 &opts,\n+                                 maybe_sysroot)\n                     })\n                 } {\n                     Ok(()) => (),\n@@ -574,6 +583,7 @@ impl Collector {\n }\n \n struct HirCollector<'a, 'hir: 'a> {\n+    sess: &'a session::Session,\n     collector: &'a mut Collector,\n     map: &'a hir::map::Map<'hir>\n }\n@@ -583,12 +593,18 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n                                             name: String,\n                                             attrs: &[ast::Attribute],\n                                             nested: F) {\n+        let mut attrs = Attributes::from_ast(self.sess.diagnostic(), attrs);\n+        if let Some(ref cfg) = attrs.cfg {\n+            if !cfg.matches(&self.sess.parse_sess, Some(&self.sess.features.borrow())) {\n+                return;\n+            }\n+        }\n+\n         let has_name = !name.is_empty();\n         if has_name {\n             self.collector.names.push(name);\n         }\n \n-        let mut attrs = Attributes::from_ast(attrs);\n         attrs.collapse_doc_comments();\n         attrs.unindent_doc_comments();\n         if let Some(doc) = attrs.doc_value() {"}, {"sha": "1e692abaff2f9cf9c479acbfdf2b052c6752afe7", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -657,7 +657,7 @@ impl OpenOptions {\n     /// This function will return an error under a number of different\n     /// circumstances. Some of these error conditions are listed here, together\n     /// with their [`ErrorKind`]. The mapping to [`ErrorKind`]s is not part of\n-    /// the compatiblity contract of the function, especially the `Other` kind\n+    /// the compatibility contract of the function, especially the `Other` kind\n     /// might change to more specific kinds in the future.\n     ///\n     /// * [`NotFound`]: The specified file does not exist and neither `create`"}, {"sha": "880caa2ade5d82a39a7418b6e80a4a09d86b76d2", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -243,6 +243,7 @@\n #![feature(allocator_api)]\n #![feature(alloc_system)]\n #![feature(allocator_internals)]\n+#![feature(allow_internal_unsafe)]\n #![feature(allow_internal_unstable)]\n #![feature(asm)]\n #![feature(box_syntax)]\n@@ -314,6 +315,7 @@\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n+#![feature(doc_cfg)]\n #![cfg_attr(test, feature(update_panic_count))]\n \n #![default_lib_allocator]"}, {"sha": "c426bf8086eefd5686c6c72c07af163d784347df", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 47, "deletions": 8, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -461,9 +461,26 @@ pub mod builtin {\n     ///\n     /// # Examples\n     ///\n+    /// Assume there are two files in the same directory with the following\n+    /// contents:\n+    ///\n+    /// File 'spanish.in':\n+    ///\n+    /// ```text\n+    /// adi\u00f3s\n+    /// ```\n+    ///\n+    /// File 'main.rs':\n+    ///\n     /// ```ignore (cannot-doctest-external-file-dependency)\n-    /// let secret_key = include_str!(\"secret-key.ascii\");\n+    /// fn main() {\n+    ///     let my_str = include_str!(\"spanish.in\");\n+    ///     assert_eq!(my_str, \"adi\u00f3s\\n\");\n+    ///     print!(\"{}\", my_str);\n+    /// }\n     /// ```\n+    ///\n+    /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     macro_rules! include_str { ($file:expr) => ({ /* compiler built-in */ }) }\n@@ -478,9 +495,26 @@ pub mod builtin {\n     ///\n     /// # Examples\n     ///\n+    /// Assume there are two files in the same directory with the following\n+    /// contents:\n+    ///\n+    /// File 'spanish.in':\n+    ///\n+    /// ```text\n+    /// adi\u00f3s\n+    /// ```\n+    ///\n+    /// File 'main.rs':\n+    ///\n     /// ```ignore (cannot-doctest-external-file-dependency)\n-    /// let secret_key = include_bytes!(\"secret-key.bin\");\n+    /// fn main() {\n+    ///     let bytes = include_bytes!(\"spanish.in\");\n+    ///     assert_eq!(bytes, b\"adi\\xc3\\xb3s\\n\");\n+    ///     print!(\"{}\", String::from_utf8_lossy(bytes));\n+    /// }\n     /// ```\n+    ///\n+    /// Compiling 'main.rs' and running the resulting binary will print \"adi\u00f3s\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     macro_rules! include_bytes { ($file:expr) => ({ /* compiler built-in */ }) }\n@@ -545,23 +579,28 @@ pub mod builtin {\n     /// Assume there are two files in the same directory with the following\n     /// contents:\n     ///\n-    /// File 'my_str.in':\n+    /// File 'monkeys.in':\n     ///\n     /// ```ignore (only-for-syntax-highlight)\n-    /// \"Hello World!\"\n+    /// ['\ud83d\ude48', '\ud83d\ude4a', '\ud83d\ude49']\n+    ///     .iter()\n+    ///     .cycle()\n+    ///     .take(6)\n+    ///     .collect::<String>()\n     /// ```\n     ///\n     /// File 'main.rs':\n     ///\n     /// ```ignore (cannot-doctest-external-file-dependency)\n     /// fn main() {\n-    ///     let my_str = include!(\"my_str.in\");\n-    ///     println!(\"{}\", my_str);\n+    ///     let my_string = include!(\"monkeys.in\");\n+    ///     assert_eq!(\"\ud83d\ude48\ud83d\ude4a\ud83d\ude49\ud83d\ude48\ud83d\ude4a\ud83d\ude49\", my_string);\n+    ///     println!(\"{}\", my_string);\n     /// }\n     /// ```\n     ///\n-    /// Compiling 'main.rs' and running the resulting binary will print \"Hello\n-    /// World!\".\n+    /// Compiling 'main.rs' and running the resulting binary will print\n+    /// \"\ud83d\ude48\ud83d\ude4a\ud83d\ude49\ud83d\ude48\ud83d\ude4a\ud83d\ude49\".\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[macro_export]\n     macro_rules! include { ($file:expr) => ({ /* compiler built-in */ }) }"}, {"sha": "2eabb46441b321a48dcffe61226db7e3932d9cac", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -147,7 +147,7 @@ impl TcpStream {\n     /// connection request.\n     ///\n     /// [`SocketAddr`]: ../../std/net/enum.SocketAddr.html\n-    #[unstable(feature = \"tcpstream_connect_timeout\", issue = \"43709\")]\n+    #[unstable(feature = \"tcpstream_connect_timeout\", issue = \"43079\")]\n     pub fn connect_timeout(addr: &SocketAddr, timeout: Duration) -> io::Result<TcpStream> {\n         net_imp::TcpStream::connect_timeout(addr, timeout).map(TcpStream)\n     }\n@@ -351,7 +351,7 @@ impl TcpStream {\n         self.0.write_timeout()\n     }\n \n-    /// Receives data on the socket from the remote adress to which it is\n+    /// Receives data on the socket from the remote address to which it is\n     /// connected, without removing that data from the queue. On success,\n     /// returns the number of bytes peeked.\n     ///"}, {"sha": "9aff98978853649e7e050d048d731c67116bc241", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -622,7 +622,7 @@ impl UdpSocket {\n         self.0.recv(buf)\n     }\n \n-    /// Receives data on the socket from the remote adress to which it is\n+    /// Receives data on the socket from the remote address to which it is\n     /// connected, without removing that data from the queue. On success,\n     /// returns the number of bytes peeked.\n     ///"}, {"sha": "72eed549f62a0b4e4f019051d440018007814428", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -13,26 +13,36 @@\n #![stable(feature = \"os\", since = \"1.0.0\")]\n #![allow(missing_docs, bad_style, missing_debug_implementations)]\n \n-#[cfg(any(target_os = \"redox\", unix))]\n+#[cfg(all(not(dox), any(target_os = \"redox\", unix)))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use sys::ext as unix;\n-#[cfg(windows)]\n+#[cfg(all(not(dox), windows))]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use sys::ext as windows;\n \n-#[cfg(target_os = \"android\")]   pub mod android;\n-#[cfg(target_os = \"bitrig\")]    pub mod bitrig;\n-#[cfg(target_os = \"dragonfly\")] pub mod dragonfly;\n-#[cfg(target_os = \"freebsd\")]   pub mod freebsd;\n-#[cfg(target_os = \"haiku\")]     pub mod haiku;\n-#[cfg(target_os = \"ios\")]       pub mod ios;\n-#[cfg(target_os = \"linux\")]     pub mod linux;\n-#[cfg(target_os = \"macos\")]     pub mod macos;\n-#[cfg(target_os = \"nacl\")]      pub mod nacl;\n-#[cfg(target_os = \"netbsd\")]   pub mod netbsd;\n-#[cfg(target_os = \"openbsd\")]   pub mod openbsd;\n-#[cfg(target_os = \"solaris\")]   pub mod solaris;\n-#[cfg(target_os = \"emscripten\")] pub mod emscripten;\n-#[cfg(target_os = \"fuchsia\")]    pub mod fuchsia;\n+#[cfg(dox)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use sys::unix_ext as unix;\n+#[cfg(dox)]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use sys::windows_ext as windows;\n+\n+#[cfg(any(dox, target_os = \"linux\"))]\n+#[doc(cfg(target_os = \"linux\"))]\n+pub mod linux;\n+\n+#[cfg(all(not(dox), target_os = \"android\"))]    pub mod android;\n+#[cfg(all(not(dox), target_os = \"bitrig\"))]     pub mod bitrig;\n+#[cfg(all(not(dox), target_os = \"dragonfly\"))]  pub mod dragonfly;\n+#[cfg(all(not(dox), target_os = \"freebsd\"))]    pub mod freebsd;\n+#[cfg(all(not(dox), target_os = \"haiku\"))]      pub mod haiku;\n+#[cfg(all(not(dox), target_os = \"ios\"))]        pub mod ios;\n+#[cfg(all(not(dox), target_os = \"macos\"))]      pub mod macos;\n+#[cfg(all(not(dox), target_os = \"nacl\"))]       pub mod nacl;\n+#[cfg(all(not(dox), target_os = \"netbsd\"))]     pub mod netbsd;\n+#[cfg(all(not(dox), target_os = \"openbsd\"))]    pub mod openbsd;\n+#[cfg(all(not(dox), target_os = \"solaris\"))]    pub mod solaris;\n+#[cfg(all(not(dox), target_os = \"emscripten\"))] pub mod emscripten;\n+#[cfg(all(not(dox), target_os = \"fuchsia\"))]    pub mod fuchsia;\n \n pub mod raw;"}, {"sha": "97b09b7e2ad996b28c244adabffe7ed0d80b2063", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -37,7 +37,7 @@ pub use panicking::{take_hook, set_hook, PanicInfo, Location};\n /// In Rust a function can \"return\" early if it either panics or calls a\n /// function which transitively panics. This sort of control flow is not always\n /// anticipated, and has the possibility of causing subtle bugs through a\n-/// combination of two cricial components:\n+/// combination of two critical components:\n ///\n /// 1. A data structure is in a temporarily invalid state when the thread\n ///    panics."}, {"sha": "99567bd08bbf49c894285634abeee5ba511a2bed", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -171,7 +171,7 @@ pub fn take_hook() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n /// use std::panic;\n ///\n /// panic::set_hook(Box::new(|panic_info| {\n-///     println!(\"panic occured: {:?}\", panic_info.payload().downcast_ref::<&str>().unwrap());\n+///     println!(\"panic occurred: {:?}\", panic_info.payload().downcast_ref::<&str>().unwrap());\n /// }));\n ///\n /// panic!(\"Normal panic\");\n@@ -196,7 +196,7 @@ impl<'a> PanicInfo<'a> {\n     /// use std::panic;\n     ///\n     /// panic::set_hook(Box::new(|panic_info| {\n-    ///     println!(\"panic occured: {:?}\", panic_info.payload().downcast_ref::<&str>().unwrap());\n+    ///     println!(\"panic occurred: {:?}\", panic_info.payload().downcast_ref::<&str>().unwrap());\n     /// }));\n     ///\n     /// panic!(\"Normal panic\");\n@@ -221,9 +221,10 @@ impl<'a> PanicInfo<'a> {\n     ///\n     /// panic::set_hook(Box::new(|panic_info| {\n     ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occured in file '{}' at line {}\", location.file(), location.line());\n+    ///         println!(\"panic occurred in file '{}' at line {}\", location.file(),\n+    ///             location.line());\n     ///     } else {\n-    ///         println!(\"panic occured but can't get location information...\");\n+    ///         println!(\"panic occurred but can't get location information...\");\n     ///     }\n     /// }));\n     ///\n@@ -249,9 +250,9 @@ impl<'a> PanicInfo<'a> {\n ///\n /// panic::set_hook(Box::new(|panic_info| {\n ///     if let Some(location) = panic_info.location() {\n-///         println!(\"panic occured in file '{}' at line {}\", location.file(), location.line());\n+///         println!(\"panic occurred in file '{}' at line {}\", location.file(), location.line());\n ///     } else {\n-///         println!(\"panic occured but can't get location information...\");\n+///         println!(\"panic occurred but can't get location information...\");\n ///     }\n /// }));\n ///\n@@ -275,9 +276,9 @@ impl<'a> Location<'a> {\n     ///\n     /// panic::set_hook(Box::new(|panic_info| {\n     ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occured in file '{}'\", location.file());\n+    ///         println!(\"panic occurred in file '{}'\", location.file());\n     ///     } else {\n-    ///         println!(\"panic occured but can't get location information...\");\n+    ///         println!(\"panic occurred but can't get location information...\");\n     ///     }\n     /// }));\n     ///\n@@ -297,9 +298,9 @@ impl<'a> Location<'a> {\n     ///\n     /// panic::set_hook(Box::new(|panic_info| {\n     ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occured at line {}\", location.line());\n+    ///         println!(\"panic occurred at line {}\", location.line());\n     ///     } else {\n-    ///         println!(\"panic occured but can't get location information...\");\n+    ///         println!(\"panic occurred but can't get location information...\");\n     ///     }\n     /// }));\n     ///\n@@ -320,9 +321,9 @@ impl<'a> Location<'a> {\n     ///\n     /// panic::set_hook(Box::new(|panic_info| {\n     ///     if let Some(location) = panic_info.location() {\n-    ///         println!(\"panic occured at column {}\", location.column());\n+    ///         println!(\"panic occurred at column {}\", location.column());\n     ///     } else {\n-    ///         println!(\"panic occured but can't get location information...\");\n+    ///         println!(\"panic occurred but can't get location information...\");\n     ///     }\n     /// }));\n     ///"}, {"sha": "c52899db4373364ba2f769b2c08fe982308197db", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -906,7 +906,7 @@ mod prim_ref { }\n /// These markers can be combined, so `unsafe extern \"stdcall\" fn()` is a valid type.\n ///\n /// Like references in rust, function pointers are assumed to not be null, so if you want to pass a\n-/// function pointer over FFI and be able to accomodate null pointers, make your type\n+/// function pointer over FFI and be able to accommodate null pointers, make your type\n /// `Option<fn()>` with your required signature.\n ///\n /// Function pointers implement the following traits:"}, {"sha": "d91c2073a23a83e5b31941a5c00b650f3d7690ba", "filename": "src/libstd/sys/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -45,3 +45,33 @@ mod imp;\n #[cfg(target_os = \"redox\")]\n #[path = \"redox/mod.rs\"]\n mod imp;\n+\n+\n+// Import essential modules from both platforms when documenting.\n+\n+#[cfg(all(dox, not(unix)))]\n+use os::linux as platform;\n+\n+#[cfg(all(dox, not(any(unix, target_os = \"redox\"))))]\n+#[path = \"unix/ext/mod.rs\"]\n+pub mod unix_ext;\n+\n+#[cfg(all(dox, any(unix, target_os = \"redox\")))]\n+pub use self::ext as unix_ext;\n+\n+\n+#[cfg(all(dox, not(windows)))]\n+#[macro_use]\n+#[path = \"windows/compat.rs\"]\n+mod compat;\n+\n+#[cfg(all(dox, not(windows)))]\n+#[path = \"windows/c.rs\"]\n+mod c;\n+\n+#[cfg(all(dox, not(windows)))]\n+#[path = \"windows/ext/mod.rs\"]\n+pub mod windows_ext;\n+\n+#[cfg(all(dox, windows))]\n+pub use self::ext as windows_ext;"}, {"sha": "5d4edc2cf92c2bfd056f25853fbbf2e6f9623807", "filename": "src/libstd/sys/redox/ext/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Ffs.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -121,7 +121,7 @@ pub trait OpenOptionsExt {\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn mode(&mut self, mode: u32) -> &mut Self;\n \n-    /// Pass custom flags to the `flags` agument of `open`.\n+    /// Pass custom flags to the `flags` argument of `open`.\n     ///\n     /// The bits that define the access mode are masked out with `O_ACCMODE`, to\n     /// ensure they do not interfere with the access mode set by Rusts options."}, {"sha": "259cda5bcb3ebe485d07f2cd5f8090e2ebf1b18a", "filename": "src/libstd/sys/redox/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -28,6 +28,7 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![doc(cfg(target_os = \"redox\"))]\n \n pub mod ffi;\n pub mod fs;"}, {"sha": "e68e180acf1c4cdf9a3c3dd5785c20e30af33ee3", "filename": "src/libstd/sys/redox/ext/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fext%2Fprocess.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -47,7 +47,7 @@ pub trait CommandExt {\n     /// # Notes\n     ///\n     /// This closure will be run in the context of the child process after a\n-    /// `fork`. This primarily means that any modificatons made to memory on\n+    /// `fork`. This primarily means that any modifications made to memory on\n     /// behalf of this closure will **not** be visible to the parent process.\n     /// This is often a very constrained environment where normal operations\n     /// like `malloc` or acquiring a mutex are not guaranteed to work (due to"}, {"sha": "49cde89dc0544f66f2a380342bc74ae54ff46dda", "filename": "src/libstd/sys/redox/net/dns/mod.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fnet%2Fdns%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -102,6 +102,7 @@ impl Dns {\n     }\n \n     pub fn parse(data: &[u8]) -> Result<Self, String> {\n+        let name_ind = 0b11000000;\n         let mut i = 0;\n \n         macro_rules! pop_u8 {\n@@ -147,9 +148,15 @@ impl Dns {\n             () => {\n                 {\n                     let mut name = String::new();\n+                    let old_i = i;\n \n                     loop {\n                         let name_len = pop_u8!();\n+                        if name_len & name_ind == name_ind {\n+                            i -= 1;\n+                            i = (pop_n16!() - ((name_ind as u16) << 8)) as usize;\n+                            continue;\n+                        }\n                         if name_len == 0 {\n                             break;\n                         }\n@@ -161,6 +168,10 @@ impl Dns {\n                         }\n                     }\n \n+                    if i <= old_i {\n+                        i = old_i + 2;\n+                    }\n+\n                     name\n                 }\n             };\n@@ -184,21 +195,8 @@ impl Dns {\n \n         let mut answers = Vec::new();\n         for _answer_i in 0..answers_len {\n-            let name_ind = 0b11000000;\n-            let name_test = pop_u8!();\n-            i -= 1;\n-\n             answers.push(DnsAnswer {\n-                name: if name_test & name_ind == name_ind {\n-                    let name_off = pop_n16!() - ((name_ind as u16) << 8);\n-                    let old_i = i;\n-                    i = name_off as usize;\n-                    let name = pop_name!();\n-                    i = old_i;\n-                    name\n-                } else {\n-                    pop_name!()\n-                },\n+                name: pop_name!(),\n                 a_type: pop_n16!(),\n                 a_class: pop_n16!(),\n                 ttl_a: pop_n16!(),"}, {"sha": "9fc809eb821d8345e5b559151cea9fdc51380140", "filename": "src/libstd/sys/redox/syscall/call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fredox%2Fsyscall%2Fcall.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -40,7 +40,7 @@ pub unsafe fn brk(addr: usize) -> Result<usize> {\n ///\n /// * `EACCES` - permission is denied for one of the components of `path`, or `path`\n /// * `EFAULT` - `path` does not point to the process's addressible memory\n-/// * `EIO` - an I/O error occured\n+/// * `EIO` - an I/O error occurred\n /// * `ENOENT` - `path` does not exit\n /// * `ENOTDIR` - `path` is not a directory\n pub fn chdir(path: &str) -> Result<usize> {\n@@ -290,7 +290,7 @@ pub fn waitpid(pid: usize, status: &mut usize, options: usize) -> Result<usize>\n /// * `EAGAIN` - the file descriptor was opened with `O_NONBLOCK` and writing would block\n /// * `EBADF` - the file descriptor is not valid or is not open for writing\n /// * `EFAULT` - `buf` does not point to the process's addressible memory\n-/// * `EIO` - an I/O error occured\n+/// * `EIO` - an I/O error occurred\n /// * `ENOSPC` - the device containing the file descriptor has no room for data\n /// * `EPIPE` - the file descriptor refers to a pipe or socket whose reading end is closed\n pub fn write(fd: usize, buf: &[u8]) -> Result<usize> {"}, {"sha": "a94585723a1eee12ad03f0ce8eb62c7933d9a17f", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -46,7 +46,7 @@ pub trait FileExt {\n     ///\n     /// The current file cursor is not affected by this function.\n     ///\n-    /// When writing beyond the end of the file, the file is appropiately\n+    /// When writing beyond the end of the file, the file is appropriately\n     /// extended and the intermediate bytes are initialized with the value 0.\n     ///\n     /// Note that similar to `File::write`, it is not an error to return a\n@@ -168,7 +168,7 @@ pub trait OpenOptionsExt {\n     #[stable(feature = \"fs_ext\", since = \"1.1.0\")]\n     fn mode(&mut self, mode: u32) -> &mut Self;\n \n-    /// Pass custom flags to the `flags` agument of `open`.\n+    /// Pass custom flags to the `flags` argument of `open`.\n     ///\n     /// The bits that define the access mode are masked out with `O_ACCMODE`, to\n     /// ensure they do not interfere with the access mode set by Rusts options."}, {"sha": "67fe46cc9c7a20326b6c8b4dec7726f8356128b6", "filename": "src/libstd/sys/unix/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -28,6 +28,7 @@\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![doc(cfg(unix))]\n \n pub mod io;\n pub mod ffi;"}, {"sha": "278534271281fe6996120085ac65c9684e04ee44", "filename": "src/libstd/sys/unix/ext/net.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fnet.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -12,8 +12,19 @@\n \n //! Unix-specific networking functionality\n \n+#[cfg(unix)]\n use libc;\n \n+// FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n+#[cfg(not(unix))]\n+mod libc {\n+    pub use libc::c_int;\n+    pub type socklen_t = u32;\n+    pub struct sockaddr;\n+    #[derive(Clone)]\n+    pub struct sockaddr_un;\n+}\n+\n use ascii;\n use ffi::OsStr;\n use fmt;\n@@ -327,7 +338,7 @@ impl UnixStream {\n     ///\n     /// The returned `UnixStream` is a reference to the same stream that this\n     /// object references. Both handles will read and write the same stream of\n-    /// data, and options set on one stream will be propogated to the other\n+    /// data, and options set on one stream will be propagated to the other\n     /// stream.\n     ///\n     /// # Examples"}, {"sha": "cde21b089a20df7910f782b9946ba7cb556bba77", "filename": "src/libstd/sys/unix/ext/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -47,7 +47,7 @@ pub trait CommandExt {\n     /// # Notes\n     ///\n     /// This closure will be run in the context of the child process after a\n-    /// `fork`. This primarily means that any modificatons made to memory on\n+    /// `fork`. This primarily means that any modifications made to memory on\n     /// behalf of this closure will **not** be visible to the parent process.\n     /// This is often a very constrained environment where normal operations\n     /// like `malloc` or acquiring a mutex are not guaranteed to work (due to"}, {"sha": "4393aedf162a3bf9b0d787a3e8e69d0f207d8e9e", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -13,20 +13,21 @@\n use io::{self, ErrorKind};\n use libc;\n \n-#[cfg(target_os = \"android\")]   pub use os::android as platform;\n-#[cfg(target_os = \"bitrig\")]    pub use os::bitrig as platform;\n-#[cfg(target_os = \"dragonfly\")] pub use os::dragonfly as platform;\n-#[cfg(target_os = \"freebsd\")]   pub use os::freebsd as platform;\n-#[cfg(target_os = \"haiku\")]     pub use os::haiku as platform;\n-#[cfg(target_os = \"ios\")]       pub use os::ios as platform;\n-#[cfg(target_os = \"linux\")]     pub use os::linux as platform;\n-#[cfg(target_os = \"macos\")]     pub use os::macos as platform;\n-#[cfg(target_os = \"nacl\")]      pub use os::nacl as platform;\n-#[cfg(target_os = \"netbsd\")]    pub use os::netbsd as platform;\n-#[cfg(target_os = \"openbsd\")]   pub use os::openbsd as platform;\n-#[cfg(target_os = \"solaris\")]   pub use os::solaris as platform;\n-#[cfg(target_os = \"emscripten\")] pub use os::emscripten as platform;\n-#[cfg(target_os = \"fuchsia\")]   pub use os::fuchsia as platform;\n+#[cfg(any(dox, target_os = \"linux\"))] pub use os::linux as platform;\n+\n+#[cfg(all(not(dox), target_os = \"android\"))]   pub use os::android as platform;\n+#[cfg(all(not(dox), target_os = \"bitrig\"))]    pub use os::bitrig as platform;\n+#[cfg(all(not(dox), target_os = \"dragonfly\"))] pub use os::dragonfly as platform;\n+#[cfg(all(not(dox), target_os = \"freebsd\"))]   pub use os::freebsd as platform;\n+#[cfg(all(not(dox), target_os = \"haiku\"))]     pub use os::haiku as platform;\n+#[cfg(all(not(dox), target_os = \"ios\"))]       pub use os::ios as platform;\n+#[cfg(all(not(dox), target_os = \"macos\"))]     pub use os::macos as platform;\n+#[cfg(all(not(dox), target_os = \"nacl\"))]      pub use os::nacl as platform;\n+#[cfg(all(not(dox), target_os = \"netbsd\"))]    pub use os::netbsd as platform;\n+#[cfg(all(not(dox), target_os = \"openbsd\"))]   pub use os::openbsd as platform;\n+#[cfg(all(not(dox), target_os = \"solaris\"))]   pub use os::solaris as platform;\n+#[cfg(all(not(dox), target_os = \"emscripten\"))] pub use os::emscripten as platform;\n+#[cfg(all(not(dox), target_os = \"fuchsia\"))]   pub use os::fuchsia as platform;\n \n #[macro_use]\n pub mod weak;"}, {"sha": "ba54ca6ea18281a893d698d8d49104e02d012976", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -301,7 +301,7 @@ pub const PIPE_READMODE_BYTE: DWORD = 0x00000000;\n pub const FD_SETSIZE: usize = 64;\n \n #[repr(C)]\n-#[cfg(target_arch = \"x86\")]\n+#[cfg(not(target_pointer_width = \"64\"))]\n pub struct WSADATA {\n     pub wVersion: WORD,\n     pub wHighVersion: WORD,\n@@ -312,7 +312,7 @@ pub struct WSADATA {\n     pub lpVendorInfo: *mut u8,\n }\n #[repr(C)]\n-#[cfg(target_arch = \"x86_64\")]\n+#[cfg(target_pointer_width = \"64\")]\n pub struct WSADATA {\n     pub wVersion: WORD,\n     pub wHighVersion: WORD,\n@@ -768,6 +768,14 @@ pub struct FLOATING_SAVE_AREA {\n     _Dummy: [u8; 512] // FIXME: Fill this out\n }\n \n+// FIXME(#43348): This structure is used for backtrace only, and a fake\n+// definition is provided here only to allow rustdoc to pass type-check. This\n+// will not appear in the final documentation. This should be also defined for\n+// other architectures supported by Windows such as ARM, and for historical\n+// interest, maybe MIPS and PowerPC as well.\n+#[cfg(all(dox, not(any(target_arch = \"x86_64\", target_arch = \"x86\"))))]\n+pub enum CONTEXT {}\n+\n #[repr(C)]\n pub struct SOCKADDR_STORAGE_LH {\n     pub ss_family: ADDRESS_FAMILY,"}, {"sha": "d58a3505154dd9f74b27bd60da921dbff9ec52a6", "filename": "src/libstd/sys/windows/ext/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Ffs.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -66,7 +66,7 @@ pub trait FileExt {\n     /// from the current cursor. The current cursor **is** affected by this\n     /// function, it is set to the end of the write.\n     ///\n-    /// When writing beyond the end of the file, the file is appropiately\n+    /// When writing beyond the end of the file, the file is appropriately\n     /// extended and the intermediate bytes are left uninitialized.\n     ///\n     /// Note that similar to `File::write`, it is not an error to return a"}, {"sha": "4b458d293bce278a7f8d4708d50e49958d0e40fb", "filename": "src/libstd/sys/windows/ext/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fext%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -17,6 +17,7 @@\n //! platform-agnostic idioms would not normally support.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n+#![doc(cfg(windows))]\n \n pub mod ffi;\n pub mod fs;"}, {"sha": "48f611a343941bb336300c56d0cd463acfffe2ad", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -91,13 +91,13 @@ pub struct LocalKey<T: 'static> {\n     //\n     // Note that the thunk is itself unsafe because the returned lifetime of the\n     // slot where data lives, `'static`, is not actually valid. The lifetime\n-    // here is actually `'thread`!\n+    // here is actually slightly shorter than the currently running thread!\n     //\n     // Although this is an extra layer of indirection, it should in theory be\n     // trivially devirtualizable by LLVM because the value of `inner` never\n     // changes and the constant should be readonly within a crate. This mainly\n     // only runs into problems when TLS statics are exported across crates.\n-    inner: fn() -> Option<&'static UnsafeCell<Option<T>>>,\n+    inner: unsafe fn() -> Option<&'static UnsafeCell<Option<T>>>,\n \n     // initialization routine to invoke to create a value\n     init: fn() -> T,\n@@ -157,12 +157,13 @@ macro_rules! thread_local {\n            issue = \"0\")]\n #[macro_export]\n #[allow_internal_unstable]\n+#[cfg_attr(not(stage0), allow_internal_unsafe)]\n macro_rules! __thread_local_inner {\n     ($(#[$attr:meta])* $vis:vis $name:ident, $t:ty, $init:expr) => {\n         $(#[$attr])* $vis static $name: $crate::thread::LocalKey<$t> = {\n             fn __init() -> $t { $init }\n \n-            fn __getit() -> $crate::option::Option<\n+            unsafe fn __getit() -> $crate::option::Option<\n                 &'static $crate::cell::UnsafeCell<\n                     $crate::option::Option<$t>>>\n             {\n@@ -178,7 +179,9 @@ macro_rules! __thread_local_inner {\n                 __KEY.get()\n             }\n \n-            $crate::thread::LocalKey::new(__getit, __init)\n+            unsafe {\n+                $crate::thread::LocalKey::new(__getit, __init)\n+            }\n         };\n     }\n }\n@@ -252,8 +255,8 @@ impl<T: 'static> LocalKey<T> {\n     #[unstable(feature = \"thread_local_internals\",\n                reason = \"recently added to create a key\",\n                issue = \"0\")]\n-    pub const fn new(inner: fn() -> Option<&'static UnsafeCell<Option<T>>>,\n-                     init: fn() -> T) -> LocalKey<T> {\n+    pub const unsafe fn new(inner: unsafe fn() -> Option<&'static UnsafeCell<Option<T>>>,\n+                            init: fn() -> T) -> LocalKey<T> {\n         LocalKey {\n             inner: inner,\n             init: init,\n@@ -391,6 +394,7 @@ pub mod fast {\n         }\n     }\n \n+    #[cfg(stage0)]\n     unsafe impl<T> ::marker::Sync for Key<T> { }\n \n     impl<T> Key<T> {\n@@ -402,14 +406,12 @@ pub mod fast {\n             }\n         }\n \n-        pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n-            unsafe {\n-                if mem::needs_drop::<T>() && self.dtor_running.get() {\n-                    return None\n-                }\n-                self.register_dtor();\n+        pub unsafe fn get(&self) -> Option<&'static UnsafeCell<Option<T>>> {\n+            if mem::needs_drop::<T>() && self.dtor_running.get() {\n+                return None\n             }\n-            Some(&self.inner)\n+            self.register_dtor();\n+            Some(&*(&self.inner as *const _))\n         }\n \n         unsafe fn register_dtor(&self) {\n@@ -478,26 +480,24 @@ pub mod os {\n             }\n         }\n \n-        pub fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n-            unsafe {\n-                let ptr = self.os.get() as *mut Value<T>;\n-                if !ptr.is_null() {\n-                    if ptr as usize == 1 {\n-                        return None\n-                    }\n-                    return Some(&(*ptr).value);\n+        pub unsafe fn get(&'static self) -> Option<&'static UnsafeCell<Option<T>>> {\n+            let ptr = self.os.get() as *mut Value<T>;\n+            if !ptr.is_null() {\n+                if ptr as usize == 1 {\n+                    return None\n                 }\n-\n-                // If the lookup returned null, we haven't initialized our own\n-                // local copy, so do that now.\n-                let ptr: Box<Value<T>> = box Value {\n-                    key: self,\n-                    value: UnsafeCell::new(None),\n-                };\n-                let ptr = Box::into_raw(ptr);\n-                self.os.set(ptr as *mut u8);\n-                Some(&(*ptr).value)\n+                return Some(&(*ptr).value);\n             }\n+\n+            // If the lookup returned null, we haven't initialized our own\n+            // local copy, so do that now.\n+            let ptr: Box<Value<T>> = box Value {\n+                key: self,\n+                value: UnsafeCell::new(None),\n+            };\n+            let ptr = Box::into_raw(ptr);\n+            self.os.set(ptr as *mut u8);\n+            Some(&(*ptr).value)\n         }\n     }\n "}, {"sha": "80eb8ba93f7544f4d72adc3d3af29644bd08fedc", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -531,7 +531,7 @@ pub fn current() -> Thread {\n ///\n /// However programmers will usually prefer to use, [`channel`]s, [`Condvar`]s,\n /// [`Mutex`]es or [`join`] for their synchronisation routines, as they avoid\n-/// thinking about thread schedulling.\n+/// thinking about thread scheduling.\n ///\n /// Note that [`channel`]s for example are implemented using this primitive.\n /// Indeed when you call `send` or `recv`, which are blocking, they will yield"}, {"sha": "14578179b435795f1be9e560b3c4f5c2baab4343", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -563,8 +563,8 @@ pub enum PatKind {\n     TupleStruct(Path, Vec<P<Pat>>, Option<usize>),\n \n     /// A possibly qualified path pattern.\n-    /// Unquailfied path patterns `A::B::C` can legally refer to variants, structs, constants\n-    /// or associated constants. Quailfied path patterns `<A>::B::C`/`<A as Trait>::B::C` can\n+    /// Unqualified path patterns `A::B::C` can legally refer to variants, structs, constants\n+    /// or associated constants. Qualified path patterns `<A>::B::C`/`<A as Trait>::B::C` can\n     /// only legally refer to associated constants.\n     Path(Option<QSelf>, Path),\n \n@@ -1841,7 +1841,7 @@ pub struct Item {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ItemKind {\n-    /// An`extern crate` item, with optional original crate name.\n+    /// An `extern crate` item, with optional original crate name.\n     ///\n     /// E.g. `extern crate foo` or `extern crate foo_bar as foo`\n     ExternCrate(Option<Name>),"}, {"sha": "d5caf458fd762a233451db6b523a844f38376c76", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -435,7 +435,7 @@ pub fn mk_attr_inner(span: Span, id: AttrId, item: MetaItem) -> Attribute {\n     mk_spanned_attr_inner(span, id, item)\n }\n \n-/// Returns an innter attribute with the given value and span.\n+/// Returns an inner attribute with the given value and span.\n pub fn mk_spanned_attr_inner(sp: Span, id: AttrId, item: MetaItem) -> Attribute {\n     Attribute {\n         id: id,"}, {"sha": "6c48b4cadd84fdcf9235cdd273738acc3a5c03a3", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -761,7 +761,7 @@ mod tests {\n     }\n \n     /// Given a string like \" ~~~~~~~~~~~~ \", produces a span\n-    /// coverting that range. The idea is that the string has the same\n+    /// converting that range. The idea is that the string has the same\n     /// length as the input, and we uncover the byte positions.  Note\n     /// that this can span lines and so on.\n     fn span_from_selection(input: &str, selection: &str) -> Span {\n@@ -771,7 +771,7 @@ mod tests {\n         Span { lo: BytePos(left_index), hi: BytePos(right_index + 1), ctxt: NO_EXPANSION }\n     }\n \n-    /// Test span_to_snippet and span_to_lines for a span coverting 3\n+    /// Test span_to_snippet and span_to_lines for a span converting 3\n     /// lines in the middle of a file.\n     #[test]\n     fn span_to_snippet_and_lines_spanning_multiple_lines() {"}, {"sha": "72b2552f64fc662295fc1108d21c04b89a98b4af", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -532,10 +532,16 @@ pub enum SyntaxExtension {\n     /// A normal, function-like syntax extension.\n     ///\n     /// `bytes!` is a `NormalTT`.\n-    ///\n-    /// The `bool` dictates whether the contents of the macro can\n-    /// directly use `#[unstable]` things (true == yes).\n-    NormalTT(Box<TTMacroExpander>, Option<(ast::NodeId, Span)>, bool),\n+    NormalTT {\n+        expander: Box<TTMacroExpander>,\n+        def_info: Option<(ast::NodeId, Span)>,\n+        /// Whether the contents of the macro can\n+        /// directly use `#[unstable]` things (true == yes).\n+        allow_internal_unstable: bool,\n+        /// Whether the contents of the macro can use `unsafe`\n+        /// without triggering the `unsafe_code` lint.\n+        allow_internal_unsafe: bool,\n+    },\n \n     /// A function-like syntax extension that has an extra ident before\n     /// the block.\n@@ -562,7 +568,7 @@ impl SyntaxExtension {\n     pub fn kind(&self) -> MacroKind {\n         match *self {\n             SyntaxExtension::DeclMacro(..) |\n-            SyntaxExtension::NormalTT(..) |\n+            SyntaxExtension::NormalTT { .. } |\n             SyntaxExtension::IdentTT(..) |\n             SyntaxExtension::ProcMacro(..) =>\n                 MacroKind::Bang,"}, {"sha": "38715f7275de5add9d39a947fa4a95dacb9b4dcb", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -64,6 +64,7 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt, span: Span, traits: &[ast::Path]\n             format: ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)),\n             span: None,\n             allow_internal_unstable: true,\n+            allow_internal_unsafe: false,\n         },\n     });\n "}, {"sha": "9625602fa4a5a02bcdf96b1101ef922d648a2ff5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -411,6 +411,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 format: MacroAttribute(Symbol::intern(&format!(\"{}\", attr.path))),\n                 span: None,\n                 allow_internal_unstable: false,\n+                allow_internal_unsafe: false,\n             }\n         });\n \n@@ -458,7 +459,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let path = &mac.node.path;\n \n         let ident = ident.unwrap_or_else(|| keywords::Invalid.ident());\n-        let validate_and_set_expn_info = |def_site_span, allow_internal_unstable| {\n+        let validate_and_set_expn_info = |def_site_span,\n+                                          allow_internal_unstable,\n+                                          allow_internal_unsafe| {\n             if ident.name != keywords::Invalid.name() {\n                 return Err(format!(\"macro {}! expects no ident argument, given '{}'\", path, ident));\n             }\n@@ -467,7 +470,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 callee: NameAndSpan {\n                     format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n                     span: def_site_span,\n-                    allow_internal_unstable: allow_internal_unstable,\n+                    allow_internal_unstable,\n+                    allow_internal_unsafe,\n                 },\n             });\n             Ok(())\n@@ -476,20 +480,26 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let opt_expanded = match *ext {\n             DeclMacro(ref expand, def_span) => {\n                 if let Err(msg) = validate_and_set_expn_info(def_span.map(|(_, s)| s),\n-                                                             false) {\n+                                                             false, false) {\n                     self.cx.span_err(path.span, &msg);\n                     return kind.dummy(span);\n                 }\n                 kind.make_from(expand.expand(self.cx, span, mac.node.stream()))\n             }\n \n-            NormalTT(ref expandfun, def_info, allow_internal_unstable) => {\n+            NormalTT {\n+                ref expander,\n+                def_info,\n+                allow_internal_unstable,\n+                allow_internal_unsafe\n+            } => {\n                 if let Err(msg) = validate_and_set_expn_info(def_info.map(|(_, s)| s),\n-                                                             allow_internal_unstable) {\n+                                                             allow_internal_unstable,\n+                                                             allow_internal_unsafe) {\n                     self.cx.span_err(path.span, &msg);\n                     return kind.dummy(span);\n                 }\n-                kind.make_from(expandfun.expand(self.cx, span, mac.node.stream()))\n+                kind.make_from(expander.expand(self.cx, span, mac.node.stream()))\n             }\n \n             IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n@@ -504,7 +514,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     callee: NameAndSpan {\n                         format: MacroBang(Symbol::intern(&format!(\"{}\", path))),\n                         span: tt_span,\n-                        allow_internal_unstable: allow_internal_unstable,\n+                        allow_internal_unstable,\n+                        allow_internal_unsafe: false,\n                     }\n                 });\n \n@@ -540,6 +551,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         span: None,\n                         // FIXME probably want to follow macro_rules macros here.\n                         allow_internal_unstable: false,\n+                        allow_internal_unsafe: false,\n                     },\n                 });\n \n@@ -578,6 +590,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 format: MacroAttribute(pretty_name),\n                 span: None,\n                 allow_internal_unstable: false,\n+                allow_internal_unsafe: false,\n             }\n         };\n "}, {"sha": "95fe41be122545cd4061ea0986c7c20c1266c020", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -193,13 +193,14 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n // resolve a file-system path to an absolute file-system path (if it\n // isn't already)\n fn res_rel_file(cx: &mut ExtCtxt, sp: syntax_pos::Span, arg: &Path) -> PathBuf {\n-    // NB: relative paths are resolved relative to the compilation unit\n+    // Relative paths are resolved relative to the file in which they are found\n+    // after macro expansion (that is, they are unhygienic).\n     if !arg.is_absolute() {\n         let callsite = sp.source_callsite();\n-        let mut cu = PathBuf::from(&cx.codemap().span_to_filename(callsite));\n-        cu.pop();\n-        cu.push(arg);\n-        cu\n+        let mut path = PathBuf::from(&cx.codemap().span_to_filename(callsite));\n+        path.pop();\n+        path.push(arg);\n+        path\n     } else {\n         arg.to_path_buf()\n     }"}, {"sha": "7b3fe2bd993a9a6941232d00505a3cb4df39d448", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -269,7 +269,7 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n         valid &= check_lhs_no_empty_seq(sess, &[lhs.clone()])\n     }\n \n-    let exp: Box<_> = Box::new(MacroRulesMacroExpander {\n+    let expander: Box<_> = Box::new(MacroRulesMacroExpander {\n         name: def.ident,\n         lhses: lhses,\n         rhses: rhses,\n@@ -278,9 +278,15 @@ pub fn compile(sess: &ParseSess, features: &RefCell<Features>, def: &ast::Item)\n \n     if body.legacy {\n         let allow_internal_unstable = attr::contains_name(&def.attrs, \"allow_internal_unstable\");\n-        NormalTT(exp, Some((def.id, def.span)), allow_internal_unstable)\n+        let allow_internal_unsafe = attr::contains_name(&def.attrs, \"allow_internal_unsafe\");\n+        NormalTT {\n+            expander,\n+            def_info: Some((def.id, def.span)),\n+            allow_internal_unstable,\n+            allow_internal_unsafe\n+        }\n     } else {\n-        SyntaxExtension::DeclMacro(exp, Some((def.id, def.span)))\n+        SyntaxExtension::DeclMacro(expander, Some((def.id, def.span)))\n     }\n }\n "}, {"sha": "dd64bc3072e6d12838937ff1d59c61cb3a23083d", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -194,6 +194,14 @@ declare_features! (\n     // rustc internal\n     (active, allow_internal_unstable, \"1.0.0\", None),\n \n+    // Allows the use of #[allow_internal_unsafe]. This is an\n+    // attribute on macro_rules! and can't use the attribute handling\n+    // below (it has to be checked before expansion possibly makes\n+    // macros disappear).\n+    //\n+    // rustc internal\n+    (active, allow_internal_unsafe, \"1.0.0\", None),\n+\n     // #23121. Array patterns have some hazards yet.\n     (active, slice_patterns, \"1.0.0\", Some(23121)),\n \n@@ -368,6 +376,9 @@ declare_features! (\n     // global allocators and their internals\n     (active, global_allocator, \"1.20.0\", None),\n     (active, allocator_internals, \"1.20.0\", None),\n+\n+    // #[doc(cfg(...))]\n+    (active, doc_cfg, \"1.21.0\", Some(43781)),\n );\n \n declare_features! (\n@@ -739,6 +750,11 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n                                               EXPLAIN_ALLOW_INTERNAL_UNSTABLE,\n                                               cfg_fn!(allow_internal_unstable))),\n \n+    (\"allow_internal_unsafe\", Normal, Gated(Stability::Unstable,\n+                                            \"allow_internal_unsafe\",\n+                                            EXPLAIN_ALLOW_INTERNAL_UNSAFE,\n+                                            cfg_fn!(allow_internal_unsafe))),\n+\n     (\"fundamental\", Whitelisted, Gated(Stability::Unstable,\n                                        \"fundamental\",\n                                        \"the `#[fundamental]` attribute \\\n@@ -1049,6 +1065,8 @@ pub const EXPLAIN_TRACE_MACROS: &'static str =\n     \"`trace_macros` is not stable enough for use and is subject to change\";\n pub const EXPLAIN_ALLOW_INTERNAL_UNSTABLE: &'static str =\n     \"allow_internal_unstable side-steps feature gating and stability checks\";\n+pub const EXPLAIN_ALLOW_INTERNAL_UNSAFE: &'static str =\n+    \"allow_internal_unsafe side-steps the unsafe_code lint\";\n \n pub const EXPLAIN_CUSTOM_DERIVE: &'static str =\n     \"`#[derive]` for custom traits is deprecated and will be removed in the future.\";\n@@ -1161,6 +1179,16 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             self.context.check_attribute(attr, false);\n         }\n \n+        if attr.check_name(\"doc\") {\n+            if let Some(content) = attr.meta_item_list() {\n+                if content.len() == 1 && content[0].check_name(\"cfg\") {\n+                    gate_feature_post!(&self, doc_cfg, attr.span,\n+                        \"#[doc(cfg(...))] is experimental\"\n+                    );\n+                }\n+            }\n+        }\n+\n         if self.context.features.proc_macro && attr::is_known(attr) {\n             return\n         }"}, {"sha": "957164bab79a708dcdb066371b4fb09c449ab082", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -124,7 +124,7 @@ pub fn parse_expr_from_source_str(name: String, source: String, sess: &ParseSess\n \n /// Parses an item.\n ///\n-/// Returns `Ok(Some(item))` when successful, `Ok(None)` when no item was found, and`Err`\n+/// Returns `Ok(Some(item))` when successful, `Ok(None)` when no item was found, and `Err`\n /// when a syntax error occurred.\n pub fn parse_item_from_source_str(name: String, source: String, sess: &ParseSess)\n                                       -> PResult<Option<P<ast::Item>>> {"}, {"sha": "245452dcb39cfc1d3a7b7362463979597ae422c7", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -3595,7 +3595,7 @@ impl<'a> Parser<'a> {\n \n     /// Parse a local variable declaration\n     fn parse_local(&mut self, attrs: ThinVec<Attribute>) -> PResult<'a, P<Local>> {\n-        let lo = self.span;\n+        let lo = self.prev_span;\n         let pat = self.parse_pat()?;\n \n         let ty = if self.eat(&token::Colon) {"}, {"sha": "430976e7d3ce4e98a29b25a0185a29daa6b03005", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -28,6 +28,7 @@ fn ignored_span(sp: Span) -> Span {\n             format: MacroAttribute(Symbol::intern(\"std_inject\")),\n             span: None,\n             allow_internal_unstable: true,\n+            allow_internal_unsafe: false,\n         }\n     });\n     Span { ctxt: SyntaxContext::empty().apply_mark(mark), ..sp }"}, {"sha": "c05e166e01331ef8a875bc12f3aec414f9ccc033", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -291,6 +291,7 @@ fn generate_test_harness(sess: &ParseSess,\n             format: MacroAttribute(Symbol::intern(\"test\")),\n             span: None,\n             allow_internal_unstable: true,\n+            allow_internal_unsafe: false,\n         }\n     });\n "}, {"sha": "439538a8b5ee311305babf8a9b5fb569df77bbb8", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -64,7 +64,12 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n             register(Symbol::intern(stringify!($name)),\n-                     NormalTT(Box::new($f as MacroExpanderFn), None, false));\n+                     NormalTT {\n+                        expander: Box::new($f as MacroExpanderFn),\n+                        def_info: None,\n+                        allow_internal_unstable: false,\n+                        allow_internal_unsafe: false,\n+                    });\n         )* }\n     }\n \n@@ -112,7 +117,12 @@ pub fn register_builtins(resolver: &mut syntax::ext::base::Resolver,\n \n     // format_args uses `unstable` things internally.\n     register(Symbol::intern(\"format_args\"),\n-             NormalTT(Box::new(format::expand_format_args), None, true));\n+             NormalTT {\n+                expander: Box::new(format::expand_format_args),\n+                def_info: None,\n+                allow_internal_unstable: true,\n+                allow_internal_unsafe: false,\n+            });\n \n     for (name, ext) in user_exts {\n         register(name, ext);"}, {"sha": "700386f68fee047e6b57a5f7fcf806fd6090fa0f", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -368,6 +368,7 @@ fn mk_registrar(cx: &mut ExtCtxt,\n             format: MacroAttribute(Symbol::intern(\"proc_macro\")),\n             span: None,\n             allow_internal_unstable: true,\n+            allow_internal_unsafe: false,\n         }\n     });\n     let span = Span { ctxt: SyntaxContext::empty().apply_mark(mark), ..DUMMY_SP };"}, {"sha": "514cc26666e39444d130fb56f3b4d9738b462ed7", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -310,6 +310,9 @@ pub struct NameAndSpan {\n     /// features internally without forcing the whole crate to opt-in\n     /// to them.\n     pub allow_internal_unstable: bool,\n+    /// Whether the macro is allowed to use `unsafe` internally\n+    /// even if the user crate has `#![forbid(unsafe_code)]`.\n+    pub allow_internal_unsafe: bool,\n     /// The span of the macro definition itself. The macro may not\n     /// have a sensible definition span (e.g. something defined\n     /// completely inside libsyntax) in which case this is None."}, {"sha": "e162bc26412f2c9f8e61a8c326d1eeae8bcf0a21", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -153,6 +153,16 @@ impl Span {\n         }\n     }\n \n+    /// Check if a span is \"internal\" to a macro in which `unsafe`\n+    /// can be used without triggering the `unsafe_code` lint\n+    //  (that is, a macro marked with `#[allow_internal_unsafe]`).\n+    pub fn allows_unsafe(&self) -> bool {\n+        match self.ctxt.outer().expn_info() {\n+            Some(info) => info.callee.allow_internal_unsafe,\n+            None => false,\n+        }\n+    }\n+\n     pub fn macro_backtrace(mut self) -> Vec<MacroBacktrace> {\n         let mut prev_span = DUMMY_SP;\n         let mut result = vec![];"}, {"sha": "590dc619f2f1aa3bc32f110f964cc82ba8dee167", "filename": "src/test/compile-fail/feature-gate-allow-internal-unsafe-nested-macro.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unsafe-nested-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unsafe-nested-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-allow-internal-unsafe-nested-macro.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// gate-test-allow_internal_unsafe\n+\n+#![allow(unused_macros)]\n+\n+macro_rules! bar {\n+    () => {\n+        // more layers don't help:\n+        #[allow_internal_unsafe] //~ ERROR allow_internal_unsafe side-steps\n+        macro_rules! baz {\n+            () => {}\n+        }\n+    }\n+}\n+\n+bar!();\n+\n+fn main() {}"}, {"sha": "1a77d918014572c3c4974867dec71738a8665d4a", "filename": "src/test/compile-fail/feature-gate-doc_cfg.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fcompile-fail%2Ffeature-gate-doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fcompile-fail%2Ffeature-gate-doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-doc_cfg.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,12 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[doc(cfg(unix))] //~ ERROR: #[doc(cfg(...))] is experimental\n+fn main() {}"}, {"sha": "4befe3ebc865ab73d401dfb1467e35aaf5f9e907", "filename": "src/test/compile-fail/issue-17954.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fcompile-fail%2Fissue-17954.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fcompile-fail%2Fissue-17954.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17954.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(thread_local)]\n+\n+#[thread_local]\n+static FOO: u8 = 3;\n+\n+fn main() {\n+    let a = &FOO;\n+    //~^ ERROR borrowed value does not live long enough\n+    //~| does not live long enough\n+    //~| NOTE borrowed value must be valid for the static lifetime\n+\n+    std::thread::spawn(move || {\n+        println!(\"{}\", a);\n+    });\n+} //~ temporary value only lives until here"}, {"sha": "e1d34f339dc60e10a253802ce591e13724513f26", "filename": "src/test/compile-fail/issue-43250.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fcompile-fail%2Fissue-43250.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fcompile-fail%2Fissue-43250.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43250.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let mut y;\n+    const C: u32 = 0;\n+    macro_rules! m {\n+        ($a:expr) => {\n+            let $a = 0;\n+        }\n+    }\n+    m!(y);\n+    //~^ ERROR arbitrary expressions aren't allowed in patterns\n+    m!(C);\n+    //~^ ERROR arbitrary expressions aren't allowed in patterns\n+}"}, {"sha": "3dff34c2ebb1280f88565a202dff0213b9caaab9", "filename": "src/test/compile-fail/issue-43733-2.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn, drop_types_in_const)]\n+#![feature(cfg_target_thread_local, thread_local_internals)]\n+\n+// On platforms *without* `#[thread_local]`, use\n+// a custom non-`Sync` type to fake the same error.\n+#[cfg(not(target_thread_local))]\n+struct Key<T> {\n+    _data: std::cell::UnsafeCell<Option<T>>,\n+    _flag: std::cell::Cell<bool>,\n+}\n+\n+#[cfg(not(target_thread_local))]\n+impl<T> Key<T> {\n+    const fn new() -> Self {\n+        Key {\n+            _data: std::cell::UnsafeCell::new(None),\n+            _flag: std::cell::Cell::new(false),\n+        }\n+    }\n+}\n+\n+#[cfg(target_thread_local)]\n+use std::thread::__FastLocalKeyInner as Key;\n+\n+static __KEY: Key<()> = Key::new();\n+//~^ ERROR `std::cell::UnsafeCell<std::option::Option<()>>: std::marker::Sync` is not satisfied\n+//~| ERROR `std::cell::Cell<bool>: std::marker::Sync` is not satisfied\n+\n+fn main() {}"}, {"sha": "a4aad21a9f8325c659855bad3f93b90f6bf409c5", "filename": "src/test/compile-fail/issue-43733.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43733.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn, drop_types_in_const)]\n+#![feature(cfg_target_thread_local, thread_local_internals)]\n+\n+type Foo = std::cell::RefCell<String>;\n+\n+#[cfg(target_thread_local)]\n+static __KEY: std::thread::__FastLocalKeyInner<Foo> =\n+    std::thread::__FastLocalKeyInner::new();\n+\n+#[cfg(not(target_thread_local))]\n+static __KEY: std::thread::__OsLocalKeyInner<Foo> =\n+    std::thread::__OsLocalKeyInner::new();\n+\n+fn __getit() -> std::option::Option<\n+    &'static std::cell::UnsafeCell<\n+        std::option::Option<Foo>>>\n+{\n+    __KEY.get() //~ ERROR  invocation of unsafe method requires unsafe\n+}\n+\n+static FOO: std::thread::LocalKey<Foo> =\n+    std::thread::LocalKey::new(__getit, Default::default);\n+//~^ ERROR call to unsafe function requires unsafe\n+\n+fn main() {\n+    FOO.with(|foo| println!(\"{}\", foo.borrow()));\n+    std::thread::spawn(|| {\n+        FOO.with(|foo| *foo.borrow_mut() += \"foo\");\n+    }).join().unwrap();\n+    FOO.with(|foo| println!(\"{}\", foo.borrow()));\n+}"}, {"sha": "720e15991c05988c4284dcb13a1c74be159f5b6b", "filename": "src/test/compile-fail/thread-local-in-ctfe.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fcompile-fail%2Fthread-local-in-ctfe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fcompile-fail%2Fthread-local-in-ctfe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fthread-local-in-ctfe.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_fn, thread_local)]\n+\n+#[thread_local]\n+static A: u32 = 1;\n+\n+static B: u32 = A;\n+//~^ ERROR thread-local statics cannot be accessed at compile-time\n+//~| ERROR cannot refer to other statics by value\n+//~| WARN non-constant path in constant expression\n+\n+static C: &u32 = &A;\n+//~^ ERROR thread-local statics cannot be accessed at compile-time\n+\n+const D: u32 = A;\n+//~^ ERROR thread-local statics cannot be accessed at compile-time\n+//~| ERROR cannot refer to statics by value\n+//~| WARN non-constant path in constant expression\n+\n+const E: &u32 = &A;\n+//~^ ERROR thread-local statics cannot be accessed at compile-time\n+\n+const fn f() -> u32 {\n+    A\n+    //~^ ERROR thread-local statics cannot be accessed at compile-time\n+    //~| ERROR cannot refer to statics by value\n+}\n+\n+fn main() {}"}, {"sha": "f9735253ab6824a86bccfb9a8ba3332cff8d444e", "filename": "src/test/run-make/issues-41478-43796/Makefile", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-make%2Fissues-41478-43796%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-make%2Fissues-41478-43796%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissues-41478-43796%2FMakefile?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,8 @@\n+-include ../tools.mk\n+\n+all:\n+\t# Work in /tmp, because we need to create the `save-analysis-temp` folder.\n+\tcp a.rs $(TMPDIR)/\n+\tcd $(TMPDIR) && $(RUSTC) -Zsave-analysis $(TMPDIR)/a.rs 2> $(TMPDIR)/stderr.txt || ( cat $(TMPDIR)/stderr.txt && exit 1 )\n+\t[ ! -s $(TMPDIR)/stderr.txt ] || ( cat $(TMPDIR)/stderr.txt && exit 1 )\n+\t[ -f $(TMPDIR)/save-analysis/liba.json ] || ( ls -la $(TMPDIR) && exit 1 )"}, {"sha": "9d95f8b25852727dc4f81053e310b5d5e2f7cd36", "filename": "src/test/run-make/issues-41478-43796/a.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-make%2Fissues-41478-43796%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-make%2Fissues-41478-43796%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissues-41478-43796%2Fa.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_type = \"lib\"]\n+pub struct V<S>(S);\n+pub trait An {\n+    type U;\n+}\n+pub trait F<A> {\n+}\n+impl<A: An> F<A> for V<<A as An>::U> {\n+}"}, {"sha": "8da2ae8b29abe48dbb00b44ff555709b74c67453", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin_args.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin_args.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -48,5 +48,10 @@ impl TTMacroExpander for Expander {\n pub fn plugin_registrar(reg: &mut Registry) {\n     let args = reg.args().to_owned();\n     reg.register_syntax_extension(Symbol::intern(\"plugin_args\"),\n-        NormalTT(Box::new(Expander { args: args, }), None, false));\n+        NormalTT {\n+            expander: Box::new(Expander { args: args, }),\n+            def_info: None,\n+            allow_internal_unstable: false,\n+            allow_internal_unsafe: false,\n+        });\n }"}, {"sha": "e9457886be80d890a5e8287823777ab2508e1ed9", "filename": "src/test/run-pass/auxiliary/thread-local-extern-static.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass%2Fauxiliary%2Fthread-local-extern-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass%2Fauxiliary%2Fthread-local-extern-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fthread-local-extern-static.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -8,10 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(thread_local)]\n-#![feature(cfg_target_thread_local)]\n+#![feature(cfg_target_thread_local, const_fn, thread_local)]\n #![crate_type = \"lib\"]\n \n+#[cfg(target_thread_local)]\n+use std::cell::Cell;\n+\n #[no_mangle]\n-#[cfg_attr(target_thread_local, thread_local)]\n-pub static FOO: u32 = 3;\n+#[cfg(target_thread_local)]\n+#[thread_local]\n+pub static FOO: Cell<u32> = Cell::new(3);"}, {"sha": "e9074f8c230960efda61f3a7f0263bd35c333610", "filename": "src/test/run-pass/impl-trait/auxiliary/xcrate.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauxiliary%2Fxcrate.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -13,3 +13,14 @@\n pub fn fourway_add(a: i32) -> impl Fn(i32) -> impl Fn(i32) -> impl Fn(i32) -> i32 {\n     move |b| move |c| move |d| a + b + c + d\n }\n+\n+fn some_internal_fn() -> u32 {\n+    1\n+}\n+\n+// See #40839\n+pub fn return_closure_accessing_internal_fn() -> impl Fn() -> u32 {\n+    || {\n+        some_internal_fn() + 1\n+    }\n+}"}, {"sha": "6d00c46fa35089c0a309ae8c57ec2317ba9fb31e", "filename": "src/test/run-pass/impl-trait/xcrate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fxcrate.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -14,4 +14,5 @@ extern crate xcrate;\n \n fn main() {\n     assert_eq!(xcrate::fourway_add(1)(2)(3)(4), 10);\n+    xcrate::return_closure_accessing_internal_fn()();\n }"}, {"sha": "621607e5f6fa8ba99117ef4906d54702c9fed61e", "filename": "src/test/run-pass/issue-30756.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass%2Fissue-30756.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass%2Fissue-30756.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-30756.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![deny(unsafe_code)]\n+#![forbid(unsafe_code)]\n \n thread_local!(static FOO: u8 = 1);\n "}, {"sha": "b753cf5844fa9185d34d88eed9e81d1b10968ecb", "filename": "src/test/run-pass/issue-39827.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass%2Fissue-39827.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass%2Fissue-39827.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-39827.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![feature(core_intrinsics)]\n+\n+use std::intrinsics::{ volatile_copy_memory, volatile_store, volatile_load,\n+                       volatile_copy_nonoverlapping_memory,\n+                       volatile_set_memory };\n+\n+//\n+// This test ensures that volatile intrinsics can be specialised with\n+// zero-sized types and, in case of copy/set functions, can accept\n+// number of elements equal to zero.\n+//\n+fn main () {\n+    let mut dst_pair = (1, 2);\n+    let src_pair = (3, 4);\n+    let mut dst_empty = ();\n+    let src_empty = ();\n+\n+    const COUNT_0: usize = 0;\n+    const COUNT_100: usize = 100;\n+\n+    unsafe {\n+        volatile_copy_memory(&mut dst_pair, &dst_pair, COUNT_0);\n+        volatile_copy_nonoverlapping_memory(&mut dst_pair, &src_pair, 0);\n+        volatile_copy_memory(&mut dst_empty, &dst_empty, 100);\n+        volatile_copy_nonoverlapping_memory(&mut dst_empty, &src_empty,\n+                                            COUNT_100);\n+        volatile_set_memory(&mut dst_empty, 0, COUNT_100);\n+        volatile_set_memory(&mut dst_pair, 0, COUNT_0);\n+        volatile_store(&mut dst_empty, ());\n+        volatile_store(&mut dst_empty, src_empty);\n+        volatile_load(&src_empty);\n+    }\n+}"}, {"sha": "f55d584ea24fbc36fa6bd3225b8f69cec6ba8d2d", "filename": "src/test/run-pass/issue-43853.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass%2Fissue-43853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass%2Fissue-43853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-43853.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::panic;\n+\n+fn test() {\n+    wait(|| panic!());\n+}\n+\n+fn wait<T, F: FnOnce() -> T>(f: F) -> F::Output {\n+    From::from(f())\n+}\n+\n+fn main() {\n+    let result = panic::catch_unwind(move || test());\n+    assert!(result.is_err());\n+}"}, {"sha": "09c8b64776c7b9112ba9ca864b8892242de0b218", "filename": "src/test/run-pass/thread-local-extern-static.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass%2Fthread-local-extern-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frun-pass%2Fthread-local-extern-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthread-local-extern-static.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -11,18 +11,26 @@\n // ignore-windows\n // aux-build:thread-local-extern-static.rs\n \n-#![feature(thread_local)]\n-#![feature(cfg_target_thread_local)]\n+#![feature(cfg_target_thread_local, thread_local)]\n \n+#[cfg(target_thread_local)]\n extern crate thread_local_extern_static;\n \n+#[cfg(target_thread_local)]\n+use std::cell::Cell;\n+\n+#[cfg(target_thread_local)]\n extern {\n-    #[cfg_attr(target_thread_local, thread_local)]\n-    static FOO: u32;\n+    #[thread_local]\n+    static FOO: Cell<u32>;\n }\n \n+#[cfg(target_thread_local)]\n fn main() {\n     unsafe {\n-        assert_eq!(FOO, 3);\n+        assert_eq!(FOO.get(), 3);\n     }\n }\n+\n+#[cfg(not(target_thread_local))]\n+fn main() {}"}, {"sha": "cfb37912fe757587e37f06e72b2cb4e7915d3680", "filename": "src/test/rustdoc/doc-cfg.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdoc-cfg.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(doc_cfg)]\n+\n+// @has doc_cfg/struct.Portable.html\n+// @!has - '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' ''\n+// @has - '//*[@id=\"method.unix_and_arm_only_function\"]' 'fn unix_and_arm_only_function()'\n+// @has - '//*[@class=\"stab portability\"]' 'This is supported on Unix and ARM only.'\n+pub struct Portable;\n+\n+// @has doc_cfg/unix_only/index.html \\\n+//  '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\\n+//  'This is supported on Unix only.'\n+// @matches - '//*[@class=\" module-item\"]//*[@class=\"stab portability\"]' '\\AUnix\\Z'\n+// @matches - '//*[@class=\" module-item\"]//*[@class=\"stab portability\"]' '\\AUnix and ARM\\Z'\n+// @count - '//*[@class=\"stab portability\"]' 3\n+#[doc(cfg(unix))]\n+pub mod unix_only {\n+    // @has doc_cfg/unix_only/fn.unix_only_function.html \\\n+    //  '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\\n+    //  'This is supported on Unix only.'\n+    // @count - '//*[@class=\"stab portability\"]' 1\n+    pub fn unix_only_function() {\n+        content::should::be::irrelevant();\n+    }\n+\n+    // @has doc_cfg/unix_only/trait.ArmOnly.html \\\n+    //  '//*[@id=\"main\"]/*[@class=\"stability\"]/*[@class=\"stab portability\"]' \\\n+    //  'This is supported on Unix and ARM only.'\n+    // @count - '//*[@class=\"stab portability\"]' 2\n+    #[doc(cfg(target_arch = \"arm\"))]\n+    pub trait ArmOnly {\n+        fn unix_and_arm_only_function();\n+    }\n+\n+    impl ArmOnly for super::Portable {\n+        fn unix_and_arm_only_function() {}\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "6ac341d8b02249e8a21aceccc37701b48e57b8c8", "filename": "src/test/rustdoc/issue-43153.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frustdoc%2Fissue-43153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frustdoc%2Fissue-43153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-43153.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that `include!` in a doc test searches relative to the directory in\n+// which the test is declared.\n+\n+// compile-flags:--test\n+\n+/// ```rust\n+/// include!(\"auxiliary/empty.rs\");\n+/// fn main() {}\n+/// ```\n+pub struct Foo;"}, {"sha": "791d83195990d4ecd996cb0b28177f5631314584", "filename": "src/test/rustdoc/issue-43701.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frustdoc%2Fissue-43701.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Frustdoc%2Fissue-43701.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-43701.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![crate_name = \"foo\"]\n+\n+pub use std::vec::Vec;\n+\n+// @!has implementors/core/clone/trait.Clone.js"}, {"sha": "7757a503c7e87a72d77ed2ffc951ed9a386ade96", "filename": "src/test/ui/issue-43806.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fui%2Fissue-43806.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftest%2Fui%2Fissue-43806.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-43806.rs?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-pass\n+\n+#![deny(unused_results)]\n+\n+enum Void {}\n+\n+fn foo() {}\n+\n+fn bar() -> ! {\n+    loop {}\n+}\n+\n+fn baz() -> Void {\n+    loop {}\n+}\n+\n+fn qux() {\n+    foo();\n+    bar();\n+    baz();\n+}\n+\n+fn main() {}"}, {"sha": "344f617ef95bc069da4e78c66caf95e98d14da91", "filename": "src/tools/rustdoc/Cargo.toml", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftools%2Frustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1413253a41de87ce7da73f0733aa3f433b1f5a3b/src%2Ftools%2Frustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc%2FCargo.toml?ref=1413253a41de87ce7da73f0733aa3f433b1f5a3b", "patch": "@@ -3,8 +3,11 @@ name = \"rustdoc-tool\"\n version = \"0.0.0\"\n authors = [\"The Rust Project Developers\"]\n \n+# Cargo adds a number of paths to the dylib search path on windows, which results in\n+# the wrong rustdoc being executed. To avoid the conflicting rustdocs, we name the \"tool\"\n+# rustdoc a different name.\n [[bin]]\n-name = \"rustdoc\"\n+name = \"rustdoc-tool-binary\"\n path = \"main.rs\"\n \n [dependencies]"}]}