{"sha": "8a0cb6ae7d3fd7ec3e3fd9986a5f90b91d03f5a4", "node_id": "C_kwDOAAsO6NoAKDhhMGNiNmFlN2QzZmQ3ZWMzZTNmZDk5ODZhNWY5MGI5MWQwM2Y1YTQ", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-06-02T10:02:30Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-06-10T08:09:50Z"}, "message": "`BoundVarReplacer` remove `Option`", "tree": {"sha": "2f4984339b1281f68106c527ef65864f1ba08a88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f4984339b1281f68106c527ef65864f1ba08a88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a0cb6ae7d3fd7ec3e3fd9986a5f90b91d03f5a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a0cb6ae7d3fd7ec3e3fd9986a5f90b91d03f5a4", "html_url": "https://github.com/rust-lang/rust/commit/8a0cb6ae7d3fd7ec3e3fd9986a5f90b91d03f5a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a0cb6ae7d3fd7ec3e3fd9986a5f90b91d03f5a4/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52ee2a2738c957ca6fd54e97b4e090a266ba96ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/52ee2a2738c957ca6fd54e97b4e090a266ba96ba", "html_url": "https://github.com/rust-lang/rust/commit/52ee2a2738c957ca6fd54e97b4e090a266ba96ba"}], "stats": {"total": 81, "additions": 36, "deletions": 45}, "files": [{"sha": "794c0ddf97dc802ca589bd8023406e2fa9833d90", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 36, "deletions": 45, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8a0cb6ae7d3fd7ec3e3fd9986a5f90b91d03f5a4/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a0cb6ae7d3fd7ec3e3fd9986a5f90b91d03f5a4/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=8a0cb6ae7d3fd7ec3e3fd9986a5f90b91d03f5a4", "patch": "@@ -656,17 +656,17 @@ struct BoundVarReplacer<'a, 'tcx> {\n     /// the ones we have visited.\n     current_index: ty::DebruijnIndex,\n \n-    fld_r: Option<&'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a)>,\n-    fld_t: Option<&'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a)>,\n-    fld_c: Option<&'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> ty::Const<'tcx> + 'a)>,\n+    fld_r: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n+    fld_t: &'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a),\n+    fld_c: &'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> ty::Const<'tcx> + 'a),\n }\n \n impl<'a, 'tcx> BoundVarReplacer<'a, 'tcx> {\n     fn new(\n         tcx: TyCtxt<'tcx>,\n-        fld_r: Option<&'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a)>,\n-        fld_t: Option<&'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a)>,\n-        fld_c: Option<&'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> ty::Const<'tcx> + 'a)>,\n+        fld_r: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n+        fld_t: &'a mut (dyn FnMut(ty::BoundTy) -> Ty<'tcx> + 'a),\n+        fld_c: &'a mut (dyn FnMut(ty::BoundVar, Ty<'tcx>) -> ty::Const<'tcx> + 'a),\n     ) -> Self {\n         BoundVarReplacer { tcx, current_index: ty::INNERMOST, fld_r, fld_t, fld_c }\n     }\n@@ -690,55 +690,42 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BoundVarReplacer<'a, 'tcx> {\n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match *t.kind() {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.current_index => {\n-                if let Some(fld_t) = self.fld_t.as_mut() {\n-                    let ty = fld_t(bound_ty);\n-                    return ty::fold::shift_vars(self.tcx, ty, self.current_index.as_u32());\n-                }\n-            }\n-            _ if t.has_vars_bound_at_or_above(self.current_index) => {\n-                return t.super_fold_with(self);\n+                let ty = (self.fld_t)(bound_ty);\n+                ty::fold::shift_vars(self.tcx, ty, self.current_index.as_u32())\n             }\n-            _ => {}\n+            _ if t.has_vars_bound_at_or_above(self.current_index) => t.super_fold_with(self),\n+            _ => t,\n         }\n-        t\n     }\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n             ty::ReLateBound(debruijn, br) if debruijn == self.current_index => {\n-                if let Some(fld_r) = self.fld_r.as_mut() {\n-                    let region = fld_r(br);\n-                    return if let ty::ReLateBound(debruijn1, br) = *region {\n-                        // If the callback returns a late-bound region,\n-                        // that region should always use the INNERMOST\n-                        // debruijn index. Then we adjust it to the\n-                        // correct depth.\n-                        assert_eq!(debruijn1, ty::INNERMOST);\n-                        self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n-                    } else {\n-                        region\n-                    };\n+                let region = (self.fld_r)(br);\n+                if let ty::ReLateBound(debruijn1, br) = *region {\n+                    // If the callback returns a late-bound region,\n+                    // that region should always use the INNERMOST\n+                    // debruijn index. Then we adjust it to the\n+                    // correct depth.\n+                    assert_eq!(debruijn1, ty::INNERMOST);\n+                    self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n+                } else {\n+                    region\n                 }\n             }\n-            _ => {}\n+            _ => r,\n         }\n-        r\n     }\n \n     fn fold_const(&mut self, ct: ty::Const<'tcx>) -> ty::Const<'tcx> {\n         match ct.val() {\n             ty::ConstKind::Bound(debruijn, bound_const) if debruijn == self.current_index => {\n-                if let Some(fld_c) = self.fld_c.as_mut() {\n-                    let ct = fld_c(bound_const, ct.ty());\n-                    return ty::fold::shift_vars(self.tcx, ct, self.current_index.as_u32());\n-                }\n-            }\n-            _ if ct.has_vars_bound_at_or_above(self.current_index) => {\n-                return ct.super_fold_with(self);\n+                let ct = (self.fld_c)(bound_const, ct.ty());\n+                ty::fold::shift_vars(self.tcx, ct, self.current_index.as_u32())\n             }\n-            _ => {}\n+            _ if ct.has_vars_bound_at_or_above(self.current_index) => ct.super_fold_with(self),\n+            _ => ct,\n         }\n-        ct\n     }\n }\n \n@@ -752,8 +739,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// returned at the end with each bound region and the free region\n     /// that replaced it.\n     ///\n-    /// This method only replaces late bound regions and the result may still\n-    /// contain escaping bound types.\n+    /// # Panics\n+    ///\n+    /// This method only replaces late bound regions. Any types or\n+    /// constants bound by `value` will cause an ICE.\n     pub fn replace_late_bound_regions<T, F>(\n         self,\n         value: Binder<'tcx, T>,\n@@ -766,11 +755,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut region_map = BTreeMap::new();\n         let mut real_fld_r =\n             |br: ty::BoundRegion| *region_map.entry(br).or_insert_with(|| fld_r(br));\n+        let mut fld_t = |b| bug!(\"unexpected bound ty in binder: {b:?}\");\n+        let mut fld_c = |b, ty| bug!(\"unexpected bound ct in binder: {b:?} {ty}\");\n+\n         let value = value.skip_binder();\n         let value = if !value.has_escaping_bound_vars() {\n             value\n         } else {\n-            let mut replacer = BoundVarReplacer::new(self, Some(&mut real_fld_r), None, None);\n+            let mut replacer = BoundVarReplacer::new(self, &mut real_fld_r, &mut fld_t, &mut fld_c);\n             value.fold_with(&mut replacer)\n         };\n         (value, region_map)\n@@ -795,15 +787,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         if !value.has_escaping_bound_vars() {\n             value\n         } else {\n-            let mut replacer =\n-                BoundVarReplacer::new(self, Some(&mut fld_r), Some(&mut fld_t), Some(&mut fld_c));\n+            let mut replacer = BoundVarReplacer::new(self, &mut fld_r, &mut fld_t, &mut fld_c);\n             value.fold_with(&mut replacer)\n         }\n     }\n \n     /// Replaces all types or regions bound by the given `Binder`. The `fld_r`\n-    /// closure replaces bound regions while the `fld_t` closure replaces bound\n-    /// types.\n+    /// closure replaces bound regions, the `fld_t` closure replaces bound\n+    /// types, and `fld_c` replaces bound constants.\n     pub fn replace_bound_vars<T, F, G, H>(\n         self,\n         value: Binder<'tcx, T>,"}]}