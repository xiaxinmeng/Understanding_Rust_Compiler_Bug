{"sha": "979f566603bad15fadb48b9ce4d9f87632cbf849", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3OWY1NjY2MDNiYWQxNWZhZGI0OGI5Y2U0ZDlmODc2MzJjYmY4NDk=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-05-31T18:29:43Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-07-02T16:15:19Z"}, "message": "lexical_region_resolve: rustfmt", "tree": {"sha": "73a9f3623f8672e76e980b7cc552c8a5058d89aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73a9f3623f8672e76e980b7cc552c8a5058d89aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/979f566603bad15fadb48b9ce4d9f87632cbf849", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/979f566603bad15fadb48b9ce4d9f87632cbf849", "html_url": "https://github.com/rust-lang/rust/commit/979f566603bad15fadb48b9ce4d9f87632cbf849", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/979f566603bad15fadb48b9ce4d9f87632cbf849/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14e23a5835a385d9aa392abb0ddda5a80208f780", "url": "https://api.github.com/repos/rust-lang/rust/commits/14e23a5835a385d9aa392abb0ddda5a80208f780", "html_url": "https://github.com/rust-lang/rust/commit/14e23a5835a385d9aa392abb0ddda5a80208f780"}], "stats": {"total": 154, "additions": 68, "deletions": 86}, "files": [{"sha": "cebaef21912a7ecd1c49fce24b9b350ef3e2e08d", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 68, "deletions": 86, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/979f566603bad15fadb48b9ce4d9f87632cbf849/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/979f566603bad15fadb48b9ce4d9f87632cbf849/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=979f566603bad15fadb48b9ce4d9f87632cbf849", "patch": "@@ -8,6 +8,11 @@ use crate::infer::region_constraints::VerifyBound;\n use crate::infer::RegionVariableOrigin;\n use crate::infer::SubregionOrigin;\n use crate::middle::free_region::RegionRelations;\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::{self, Ty, TyCtxt};\n+use crate::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n+use crate::ty::{ReLateBound, RePlaceholder, ReScope, ReVar};\n+use crate::ty::{Region, RegionVid};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n@@ -16,11 +21,6 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use smallvec::SmallVec;\n use std::fmt;\n use std::u32;\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::{self, Ty, TyCtxt};\n-use crate::ty::{ReEarlyBound, ReEmpty, ReErased, ReFree, ReStatic};\n-use crate::ty::{ReLateBound, ReScope, RePlaceholder, ReVar};\n-use crate::ty::{Region, RegionVid};\n \n mod graphviz;\n \n@@ -36,11 +36,7 @@ pub fn resolve<'tcx>(\n ) -> (LexicalRegionResolutions<'tcx>, Vec<RegionResolutionError<'tcx>>) {\n     debug!(\"RegionConstraintData: resolve_regions()\");\n     let mut errors = vec![];\n-    let mut resolver = LexicalResolver {\n-        region_rels,\n-        var_infos,\n-        data,\n-    };\n+    let mut resolver = LexicalResolver { region_rels, var_infos, data };\n     let values = resolver.infer_variable_values(&mut errors);\n     (values, errors)\n }\n@@ -136,7 +132,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     fn construct_var_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n         LexicalRegionResolutions {\n             error_region: tcx.lifetimes.re_static,\n-            values: IndexVec::from_elem_n(VarValue::Value(tcx.lifetimes.re_empty), self.num_vars())\n+            values: IndexVec::from_elem_n(VarValue::Value(tcx.lifetimes.re_empty), self.num_vars()),\n         }\n     }\n \n@@ -196,15 +192,15 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                         let b_data = var_values.value_mut(b_vid);\n                         let retain = match *b_data {\n                             VarValue::Value(ReStatic) | VarValue::ErrorValue => false,\n-                            _ => true\n+                            _ => true,\n                         };\n                         (a_region, b_vid, b_data, retain)\n                     }\n                 },\n                 Constraint::RegSubReg(..) | Constraint::VarSubReg(..) => {\n                     // These constraints are checked after expansion\n                     // is done, in `collect_errors`.\n-                    return (false, false)\n+                    return (false, false);\n                 }\n             };\n \n@@ -226,16 +222,16 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n         match *a_region {\n             // Check if this relationship is implied by a given.\n-            ty::ReEarlyBound(_) | ty::ReFree(_) => if self.data.givens.contains(&(a_region, b_vid))\n-            {\n-                debug!(\"given\");\n-                return false;\n-            },\n+            ty::ReEarlyBound(_) | ty::ReFree(_) => {\n+                if self.data.givens.contains(&(a_region, b_vid)) {\n+                    debug!(\"given\");\n+                    return false;\n+                }\n+            }\n \n             _ => {}\n         }\n \n-\n         match *b_data {\n             VarValue::Value(cur_region) => {\n                 // Identical scopes can show up quite often, if the fixed point\n@@ -267,10 +263,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     }\n                 }\n \n-                debug!(\n-                    \"Expanding value of {:?} from {:?} to {:?}\",\n-                    b_vid, cur_region, lub\n-                );\n+                debug!(\"Expanding value of {:?} from {:?} to {:?}\", b_vid, cur_region, lub);\n \n                 *b_data = VarValue::Value(lub);\n                 return true;\n@@ -321,17 +314,16 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // at least as big as fr.scope\".  So, we can\n                 // reasonably compare free regions and scopes:\n                 let fr_scope = match (a, b) {\n-                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => self.region_rels\n-                        .region_scope_tree\n-                        .early_free_scope(self.tcx(), br),\n-                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => self.region_rels\n-                        .region_scope_tree\n-                        .free_scope(self.tcx(), fr),\n+                    (&ReEarlyBound(ref br), _) | (_, &ReEarlyBound(ref br)) => {\n+                        self.region_rels.region_scope_tree.early_free_scope(self.tcx(), br)\n+                    }\n+                    (&ReFree(ref fr), _) | (_, &ReFree(ref fr)) => {\n+                        self.region_rels.region_scope_tree.free_scope(self.tcx(), fr)\n+                    }\n                     _ => bug!(),\n                 };\n-                let r_id = self.region_rels\n-                    .region_scope_tree\n-                    .nearest_common_ancestor(fr_scope, s_id);\n+                let r_id =\n+                    self.region_rels.region_scope_tree.nearest_common_ancestor(fr_scope, s_id);\n                 if r_id == fr_scope {\n                     // if the free region's scope `fr.scope` is bigger than\n                     // the scope region `s_id`, then the LUB is the free\n@@ -352,9 +344,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 // The region corresponding to an outer block is a\n                 // subtype of the region corresponding to an inner\n                 // block.\n-                let lub = self.region_rels\n-                    .region_scope_tree\n-                    .nearest_common_ancestor(a_id, b_id);\n+                let lub = self.region_rels.region_scope_tree.nearest_common_ancestor(a_id, b_id);\n                 tcx.mk_region(ReScope(lub))\n             }\n \n@@ -365,11 +355,13 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n \n             // For these types, we cannot define any additional\n             // relationship:\n-            (&RePlaceholder(..), _) | (_, &RePlaceholder(..)) => if a == b {\n-                a\n-            } else {\n-                tcx.lifetimes.re_static\n-            },\n+            (&RePlaceholder(..), _) | (_, &RePlaceholder(..)) => {\n+                if a == b {\n+                    a\n+                } else {\n+                    tcx.lifetimes.re_static\n+                }\n+            }\n         }\n     }\n \n@@ -382,10 +374,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         errors: &mut Vec<RegionResolutionError<'tcx>>,\n     ) {\n         for (constraint, origin) in &self.data.constraints {\n-            debug!(\n-                \"collect_errors: constraint={:?} origin={:?}\",\n-                constraint, origin\n-            );\n+            debug!(\"collect_errors: constraint={:?} origin={:?}\", constraint, origin);\n             match *constraint {\n                 Constraint::RegSubVar(..) | Constraint::VarSubVar(..) => {\n                     // Expansion will ensure that these constraints hold. Ignore.\n@@ -490,27 +479,27 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 VarValue::Value(_) => { /* Inference successful */ }\n                 VarValue::ErrorValue => {\n                     /* Inference impossible: this value contains\n-                       inconsistent constraints.\n-\n-                       I think that in this case we should report an\n-                       error now -- unlike the case above, we can't\n-                       wait to see whether the user needs the result\n-                       of this variable. The reason is that the mere\n-                       existence of this variable implies that the\n-                       region graph is inconsistent, whether or not it\n-                       is used.\n-\n-                       For example, we may have created a region\n-                       variable that is the GLB of two other regions\n-                       which do not have a GLB. Even if that variable\n-                       is not used, it implies that those two regions\n-                       *should* have a GLB.\n-\n-                       At least I think this is true. It may be that\n-                       the mere existence of a conflict in a region variable\n-                       that is not used is not a problem, so if this rule\n-                       starts to create problems we'll have to revisit\n-                       this portion of the code and think hard about it. =) */\n+                    inconsistent constraints.\n+\n+                    I think that in this case we should report an\n+                    error now -- unlike the case above, we can't\n+                    wait to see whether the user needs the result\n+                    of this variable. The reason is that the mere\n+                    existence of this variable implies that the\n+                    region graph is inconsistent, whether or not it\n+                    is used.\n+\n+                    For example, we may have created a region\n+                    variable that is the GLB of two other regions\n+                    which do not have a GLB. Even if that variable\n+                    is not used, it implies that those two regions\n+                    *should* have a GLB.\n+\n+                    At least I think this is true. It may be that\n+                    the mere existence of a conflict in a region variable\n+                    that is not used is not a problem, so if this rule\n+                    starts to create problems we'll have to revisit\n+                    this portion of the code and think hard about it. =) */\n                     self.collect_error_for_expanding_node(graph, &mut dup_vec, node_vid, errors);\n                 }\n             }\n@@ -604,9 +593,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             };\n \n             for upper_bound in &upper_bounds {\n-                if !self.region_rels\n-                    .is_subregion_of(effective_lower_bound, upper_bound.region)\n-                {\n+                if !self.region_rels.is_subregion_of(effective_lower_bound, upper_bound.region) {\n                     let origin = self.var_infos[node_idx].origin.clone();\n                     debug!(\n                         \"region inference error at {:?} for {:?}: SubSupConflict sub: {:?} \\\n@@ -681,9 +668,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             process_edges(&self.data, &mut state, graph, node_idx, dir);\n         }\n \n-        let WalkState {\n-            result, dup_found, ..\n-        } = state;\n+        let WalkState { result, dup_found, .. } = state;\n         return (result, dup_found);\n \n         fn process_edges<'tcx>(\n@@ -699,11 +684,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n             for (_, edge) in graph.adjacent_edges(source_node_index, dir) {\n                 match edge.data {\n                     Constraint::VarSubVar(from_vid, to_vid) => {\n-                        let opp_vid = if from_vid == source_vid {\n-                            to_vid\n-                        } else {\n-                            from_vid\n-                        };\n+                        let opp_vid = if from_vid == source_vid { to_vid } else { from_vid };\n                         if state.set.insert(opp_vid) {\n                             state.stack.push(opp_vid);\n                         }\n@@ -726,7 +707,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n     }\n \n     fn iterate_until_fixed_point<F>(&self, tag: &str, mut body: F)\n-        where F: FnMut(&Constraint<'tcx>) -> (bool, bool),\n+    where\n+        F: FnMut(&Constraint<'tcx>) -> (bool, bool),\n     {\n         let mut constraints: SmallVec<[_; 16]> = self.data.constraints.keys().collect();\n         let mut iteration = 0;\n@@ -760,17 +742,17 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                     && self.bound_is_met(b, var_values, generic_ty, min)\n             }\n \n-            VerifyBound::OutlivedBy(r) =>\n-                self.region_rels.is_subregion_of(\n-                    min,\n-                    var_values.normalize(self.tcx(), r),\n-                ),\n+            VerifyBound::OutlivedBy(r) => {\n+                self.region_rels.is_subregion_of(min, var_values.normalize(self.tcx(), r))\n+            }\n \n-            VerifyBound::AnyBound(bs) => bs.iter()\n-                .any(|b| self.bound_is_met(b, var_values, generic_ty, min)),\n+            VerifyBound::AnyBound(bs) => {\n+                bs.iter().any(|b| self.bound_is_met(b, var_values, generic_ty, min))\n+            }\n \n-            VerifyBound::AllBounds(bs) => bs.iter()\n-                .all(|b| self.bound_is_met(b, var_values, generic_ty, min)),\n+            VerifyBound::AllBounds(bs) => {\n+                bs.iter().all(|b| self.bound_is_met(b, var_values, generic_ty, min))\n+            }\n         }\n     }\n }"}]}